/**
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// If the loader is already loaded, just stop.
if (!self.define) {
  let registry = {};

  // Used for `eval` and `importScripts` where we can't get script URL by other means.
  // In both cases, it's safe to use a global var because those functions are synchronous.
  let nextDefineUri;

  const singleRequire = (uri, parentUri) => {
    uri = new URL(uri + ".js", parentUri).href;
    return registry[uri] || (
      
        new Promise(resolve => {
          if ("document" in self) {
            const script = document.createElement("script");
            script.src = uri;
            script.onload = resolve;
            document.head.appendChild(script);
          } else {
            nextDefineUri = uri;
            importScripts(uri);
            resolve();
          }
        })
      
      .then(() => {
        let promise = registry[uri];
        if (!promise) {
          throw new Error(`Module ${uri} didn’t register its module`);
        }
        return promise;
      })
    );
  };

  self.define = (depsNames, factory) => {
    const uri = nextDefineUri || ("document" in self ? document.currentScript.src : "") || location.href;
    if (registry[uri]) {
      // Module is already loading or loaded.
      return;
    }
    let exports = {};
    const require = depUri => singleRequire(depUri, uri);
    const specialDeps = {
      module: { uri },
      exports,
      require
    };
    registry[uri] = Promise.all(depsNames.map(
      depName => specialDeps[depName] || require(depName)
    )).then(deps => {
      factory(...deps);
      return exports;
    });
  };
}
define(['module', 'require', 'exports'], (function (module, require, exports) { 'use strict';

    var id$3 = "nodysseus_hyperapp";
    var out = "out";
    var nodes$1 = [
    	{
    		id: "in"
    	},
    	{
    		id: "arrays"
    	},
    	{
    		id: "utility"
    	},
    	{
    		id: "flow"
    	},
    	{
    		id: "html"
    	},
    	{
    		id: "object"
    	},
    	{
    		id: "custom"
    	},
    	{
    		id: "state"
    	},
    	{
    		id: "JSON"
    	},
    	{
    		id: "log",
    		args: [
    			"value"
    		],
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "value",
    				ref: "arg",
    				value: "value"
    			},
    			{
    				id: "out",
    				args: [
    				],
    				script: "console.log(_node.name ?? _node.id); console.log(value); return value"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "input"
    			},
    			{
    				from: "value",
    				to: "out",
    				as: "value"
    			}
    		]
    	},
    	{
    		id: "fetch",
    		name: "fetch",
    		extern: "utility.fetch"
    	},
    	{
    		id: "call",
    		name: "call",
    		extern: "utility.call"
    	},
    	{
    		id: "stringify",
    		name: "stringify",
    		extern: "JSON.stringify"
    	},
    	{
    		id: "parse",
    		name: "parse",
    		extern: "JSON.parse"
    	},
    	{
    		id: "add",
    		extern: "utility.add"
    	},
    	{
    		id: "mult",
    		extern: "utility.mult"
    	},
    	{
    		id: "divide",
    		extern: "utility.divide"
    	},
    	{
    		id: "negate",
    		extern: "utility.negate"
    	},
    	{
    		id: "wrap_array",
    		args: [
    			"value"
    		],
    		script: "return [value]"
    	},
    	{
    		id: "graph_to_sim_fn",
    		out: "action",
    		nodes: [
    			{
    				id: "state",
    				ref: "arg",
    				value: 0
    			},
    			{
    				id: "payload",
    				ref: "arg",
    				value: 1
    			},
    			{
    				id: "action",
    				script: "return _lib.scripts.graphToSimulationNodes(state, payload)"
    			}
    		],
    		edges: [
    			{
    				from: "state",
    				to: "action",
    				as: "state"
    			},
    			{
    				from: "payload",
    				to: "action",
    				as: "payload"
    			}
    		]
    	},
    	{
    		id: "sim_to_hyperapp_action",
    		out: "action",
    		nodes: [
    			{
    				id: "state",
    				ref: "arg",
    				value: 0
    			},
    			{
    				id: "old_nodes",
    				ref: "arg",
    				value: "0.nodes"
    			},
    			{
    				id: "old_links",
    				ref: "arg",
    				value: "0.links"
    			},
    			{
    				id: "new_nodes",
    				ref: "arg",
    				value: "1.nodes"
    			},
    			{
    				id: "new_links",
    				ref: "arg",
    				value: "1.links"
    			},
    			{
    				id: "selected",
    				ref: "arg",
    				value: "0.selected"
    			},
    			{
    				id: "display_graph",
    				ref: "arg",
    				value: "0.display_graph"
    			},
    			{
    				id: "payload",
    				ref: "arg",
    				value: 1
    			},
    			{
    				id: "calculate_levels",
    				script: "return _lib.scripts.calculateLevels(nodes, links, display_graph, selected)"
    			},
    			{
    				id: "with_levels",
    				script: "return {...state, levels}"
    			},
    			{
    				id: "graph_topology_change",
    				script: "return true"
    			},
    			{
    				id: "if_levels",
    				ref: "if"
    			},
    			{
    				id: "panzoom_selected_effector",
    				ref: "arg",
    				value: "0.panzoom_selected_effect"
    			},
    			{
    				id: "action",
    				script: "return [{...state, nodes: new_nodes, links: new_links, randid: Math.random().toString(36).substring(2, 9)}, panzoom_selected_effect && false && [panzoom_selected_effect, {...state, selected: state.selected[0], nodes: new_nodes, links: new_links}], [state.update_hyperapp]]"
    			}
    		],
    		edges: [
    			{
    				from: "old_nodes",
    				to: "graph_topology_change",
    				as: "old_nodes"
    			},
    			{
    				from: "new_nodes",
    				to: "graph_topology_change",
    				as: "new_nodes"
    			},
    			{
    				from: "new_links",
    				to: "graph_topology_change",
    				as: "new_links"
    			},
    			{
    				from: "old_links",
    				to: "graph_topology_change",
    				as: "old_links"
    			},
    			{
    				from: "new_nodes",
    				to: "calculate_levels",
    				as: "nodes"
    			},
    			{
    				from: "new_links",
    				to: "calculate_levels",
    				as: "links"
    			},
    			{
    				from: "selected",
    				to: "calculate_levels",
    				as: "selected"
    			},
    			{
    				from: "display_graph",
    				to: "calculate_levels",
    				as: "display_graph"
    			},
    			{
    				from: "calculate_levels",
    				to: "with_levels",
    				as: "levels"
    			},
    			{
    				from: "state",
    				to: "with_levels",
    				as: "state"
    			},
    			{
    				from: "graph_topology_change",
    				to: "if_levels",
    				as: "pred"
    			},
    			{
    				from: "with_levels",
    				to: "if_levels",
    				as: "true"
    			},
    			{
    				from: "state",
    				to: "if_levels",
    				as: "false"
    			},
    			{
    				from: "new_nodes",
    				to: "action",
    				as: "new_nodes"
    			},
    			{
    				from: "new_links",
    				to: "action",
    				as: "new_links"
    			},
    			{
    				from: "if_levels",
    				to: "action",
    				as: "state"
    			},
    			{
    				from: "panzoom_selected_effector",
    				to: "action",
    				as: "panzoom_selected_effect"
    			}
    		]
    	},
    	{
    		id: "hyperapp_app",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "init",
    				ref: "arg",
    				value: "init"
    			},
    			{
    				id: "view",
    				ref: "arg",
    				value: "view"
    			},
    			{
    				id: "html_id",
    				ref: "arg",
    				value: "html_id"
    			},
    			{
    				id: "static",
    				ref: "arg",
    				value: "static"
    			},
    			{
    				id: "display_graph",
    				ref: "arg",
    				value: "display_graph"
    			},
    			{
    				id: "update_hyperapp",
    				ref: "arg",
    				value: "update_hyperapp"
    			},
    			{
    				id: "update_sim",
    				ref: "arg",
    				value: "update_sim"
    			},
    			{
    				id: "sim_to_hyperapp_action",
    				ref: "arg",
    				value: "sim_to_hyperapp_action"
    			},
    			{
    				id: "render_graph_effect",
    				ref: "arg",
    				value: "render_graph_effect"
    			},
    			{
    				id: "onkey_fn",
    				ref: "arg",
    				value: "onkey_fn"
    			},
    			{
    				id: "out",
    				args: [
    					"init",
    					"view"
    				],
    				script: "return {dispatch: _lib.ha.app({dispatch: _lib.no.middleware, init: () => [init, static && [update_sim, {...init, action: sim_to_hyperapp_action}], [update_hyperapp], [() => _lib.no.runtime.add_graph(init.display_graph)]], view: s => {if(s instanceof Map){ throw new Error('stop') } return view(s).el}, node: document.getElementById(html_id), subscriptions: s => [!static && [_lib.scripts.d3subscription, {action: sim_to_hyperapp_action, update: update_sim}], !static && [_lib.scripts.graph_subscription, {graph: s.display_graph}], !static && [_lib.scripts.result_subscription, {graph: s.display_graph}], !s.popover_graph && [_lib.scripts.keydownSubscription, {action: onkey_fn}], _lib.scripts.listen('resize', (s, _) => [{...s, dimensions: {x: document.getElementById(html_id).clientWidth, y: document.getElementById(html_id).clientHeight}}, [update_sim, s]]), !!document.getElementById( `${html_id}-editor-panzoom`) && [_lib.pz.panzoom, {id: `${html_id}-editor-panzoom`, action: (s, p) => [{...s, show_all: p.event !== 'effect_transform', svg_offset: p.transform}]}]]})}"
    			}
    		],
    		edges: [
    			{
    				from: "view",
    				to: "out",
    				as: "view"
    			},
    			{
    				from: "html_id",
    				to: "out",
    				as: "html_id"
    			},
    			{
    				from: "display_graph",
    				to: "out",
    				as: "display_graph"
    			},
    			{
    				from: "static",
    				to: "out",
    				as: "static"
    			},
    			{
    				from: "update_sim",
    				to: "out",
    				as: "update_sim"
    			},
    			{
    				from: "update_hyperapp",
    				to: "out",
    				as: "update_hyperapp"
    			},
    			{
    				from: "sim_to_hyperapp_action",
    				to: "out",
    				as: "sim_to_hyperapp_action"
    			},
    			{
    				from: "onkey_fn",
    				to: "out",
    				as: "onkey_fn"
    			},
    			{
    				from: "render_graph_effect",
    				to: "out",
    				as: "render_graph_effect"
    			},
    			{
    				from: "init",
    				to: "out",
    				as: "init"
    			}
    		]
    	},
    	{
    		id: "children_els",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "out",
    				args: [
    					"children"
    				],
    				script: "return [children.map(c => c.el)]"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out"
    			}
    		]
    	},
    	{
    		id: "append",
    		type: "(array: A[], item: A) => A[]",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "array",
    				ref: "arg",
    				value: "array"
    			},
    			{
    				id: "item",
    				ref: "arg",
    				value: "item"
    			},
    			{
    				id: "out",
    				script: "return array.concat(Array.isArray(item) ? item : [item])"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "_",
    				type: "ref"
    			},
    			{
    				from: "array",
    				to: "out",
    				as: "array"
    			},
    			{
    				from: "item",
    				to: "out",
    				as: "item"
    			}
    		]
    	},
    	{
    		id: "concat",
    		type: "(array: A[], items: A[]) => A[]",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "array",
    				ref: "arg",
    				value: "array"
    			},
    			{
    				id: "items",
    				ref: "arg",
    				value: "items"
    			},
    			{
    				id: "out",
    				args: [
    					"item",
    					"array"
    				],
    				script: "return (array ?? []).concat(items ?? [])"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "array",
    				to: "out",
    				as: "array"
    			},
    			{
    				from: "items",
    				to: "out",
    				as: "items"
    			}
    		]
    	},
    	{
    		id: "filter",
    		name: "filter",
    		"in": "74n1jfm",
    		out: "lahq5z4",
    		nodes: [
    			{
    				id: "lahq5z4",
    				args: [
    				],
    				name: "filter/out",
    				script: "const filter_fn = _lib.no.executeGraphNode({graph: _graph})(typeof fn === 'string' ? fn : fn.fn); return arr.filter(element => filter_fn(Object.assign(fn.args ?? {}, {element})))"
    			},
    			{
    				id: "pfoypo5",
    				args: [
    				],
    				ref: "arg",
    				value: "key"
    			},
    			{
    				id: "zinx621",
    				args: [
    				],
    				ref: "arg",
    				value: "value"
    			},
    			{
    				id: "x2sz5kb",
    				args: [
    				],
    				ref: "arg",
    				value: "arr"
    			},
    			{
    				id: "fn",
    				ref: "arg",
    				value: "fn"
    			},
    			{
    				id: "74n1jfm",
    				args: [
    				],
    				name: "filter/in"
    			}
    		],
    		edges: [
    			{
    				from: "pfoypo5",
    				to: "lahq5z4",
    				as: "key"
    			},
    			{
    				from: "zinx621",
    				to: "lahq5z4",
    				as: "value"
    			},
    			{
    				from: "x2sz5kb",
    				to: "lahq5z4",
    				as: "arr"
    			},
    			{
    				from: "74n1jfm",
    				to: "lahq5z4",
    				as: "input"
    			},
    			{
    				from: "fn",
    				to: "lahq5z4",
    				as: "fn"
    			}
    		]
    	},
    	{
    		id: "filter_eq",
    		name: "filter_eq",
    		"in": "74n1jfm",
    		out: "lahq5z4",
    		nodes: [
    			{
    				id: "lahq5z4",
    				args: [
    				],
    				name: "filter/out",
    				script: "return arr.filter(v => v[key] === value)"
    			},
    			{
    				id: "pfoypo5",
    				args: [
    				],
    				ref: "arg",
    				value: "key"
    			},
    			{
    				id: "zinx621",
    				args: [
    				],
    				ref: "arg",
    				value: "value"
    			},
    			{
    				id: "x2sz5kb",
    				args: [
    				],
    				ref: "arg",
    				value: "arr"
    			},
    			{
    				id: "74n1jfm",
    				args: [
    				],
    				name: "filter/in"
    			}
    		],
    		edges: [
    			{
    				from: "pfoypo5",
    				to: "lahq5z4",
    				as: "key"
    			},
    			{
    				from: "zinx621",
    				to: "lahq5z4",
    				as: "value"
    			},
    			{
    				from: "x2sz5kb",
    				to: "lahq5z4",
    				as: "arr"
    			},
    			{
    				from: "74n1jfm",
    				to: "lahq5z4",
    				as: "input"
    			}
    		]
    	},
    	{
    		id: "default",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "value",
    				ref: "arg",
    				value: "value"
    			},
    			{
    				id: "otherwise",
    				ref: "arg",
    				value: "otherwise"
    			},
    			{
    				id: "data"
    			},
    			{
    				id: "out",
    				script: "return value ?? data['otherwise']"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "_args",
    				type: "ref"
    			},
    			{
    				from: "value",
    				to: "out",
    				as: "value"
    			},
    			{
    				from: "otherwise",
    				to: "data",
    				as: "otherwise"
    			},
    			{
    				from: "data",
    				to: "out",
    				as: "data"
    			}
    		]
    	},
    	{
    		id: "switch",
    		args: [
    			"data",
    			"input"
    		],
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "out",
    				args: [
    					"data",
    					"input"
    				],
    				script: "return data[input] ?? otherwise;"
    			},
    			{
    				id: "input",
    				ref: "arg",
    				value: "input"
    			},
    			{
    				id: "otherwise",
    				ref: "arg",
    				value: "otherwise"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "data"
    			},
    			{
    				from: "input",
    				to: "out",
    				as: "input"
    			},
    			{
    				from: "otherwise",
    				to: "out",
    				as: "otherwise"
    			}
    		]
    	},
    	{
    		id: "if",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "pred",
    				ref: "arg",
    				value: "pred"
    			},
    			{
    				id: "true",
    				ref: "arg",
    				value: "true"
    			},
    			{
    				id: "false",
    				ref: "arg",
    				value: "false"
    			},
    			{
    				id: "data"
    			},
    			{
    				id: "out",
    				script: "return !!pred ? data.true_val : data.false_val"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "data"
    			},
    			{
    				from: "true",
    				to: "data",
    				as: "true_val"
    			},
    			{
    				from: "false",
    				to: "data",
    				as: "false_val"
    			},
    			{
    				from: "data",
    				to: "out",
    				as: "data"
    			},
    			{
    				from: "pred",
    				to: "out",
    				as: "pred"
    			}
    		]
    	},
    	{
    		id: "find_node",
    		script: "const nid = typeof node_id === 'string' ? node_id : node_id[0]; return nodes.find(n => n.id === nid || n.node_id === nid)"
    	},
    	{
    		id: "svg_text",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "dom_type",
    				value: "text"
    			},
    			{
    				id: "text",
    				ref: "arg",
    				value: "text"
    			},
    			{
    				id: "props",
    				ref: "arg",
    				value: "props"
    			},
    			{
    				id: "text_el",
    				ref: "html_text"
    			},
    			{
    				id: "children",
    				script: "return [text]"
    			},
    			{
    				id: "div",
    				value: "div"
    			},
    			{
    				id: "out",
    				ref: "html_element"
    			}
    		],
    		edges: [
    			{
    				from: "dom_type",
    				to: "out",
    				as: "dom_type"
    			},
    			{
    				from: "text",
    				to: "text_el",
    				as: "text"
    			},
    			{
    				from: "text_el",
    				to: "children",
    				as: "text"
    			},
    			{
    				from: "props",
    				to: "out",
    				as: "props"
    			},
    			{
    				from: "children",
    				to: "out",
    				as: "children"
    			}
    		]
    	},
    	{
    		id: "runnable",
    		out: "out",
    		nodes: [
    			{
    				id: "fn",
    				ref: "arg",
    				value: "fn"
    			},
    			{
    				id: "value_args",
    				ref: "arg",
    				value: "args"
    			},
    			{
    				id: "context_args",
    				ref: "arg",
    				value: "_args"
    			},
    			{
    				id: "fn_path",
    				value: "fn"
    			},
    			{
    				id: "args_path",
    				value: "args"
    			},
    			{
    				id: "prune_vals",
    				value: {
    					args: false
    				}
    			},
    			{
    				id: "delete_fn",
    				ref: "delete"
    			},
    			{
    				id: "delete_args",
    				ref: "delete"
    			},
    			{
    				id: "args",
    				ref: "merge_objects"
    			},
    			{
    				id: "out",
    				script: "const parent_id = _node.id.substring(0, _node.id.lastIndexOf('/')); const input = _lib.no.runtime.get_edges_in(_graph, parent_id).find(i => i.as === 'fn'); return input ? {fn: input.from, graph: _graph, args: args ?? {}} : false"
    			}
    		],
    		edges: [
    			{
    				from: "context_args",
    				to: "delete_fn",
    				as: "target"
    			},
    			{
    				from: "fn_path",
    				to: "delete_fn",
    				as: "path"
    			},
    			{
    				from: "delete_fn",
    				to: "delete_args",
    				as: "target"
    			},
    			{
    				from: "args_path",
    				to: "delete_args",
    				as: "path"
    			},
    			{
    				from: "delete_args",
    				to: "args",
    				as: "o0"
    			},
    			{
    				from: "prune_vals",
    				to: "args",
    				as: "o1"
    			},
    			{
    				from: "value_args",
    				to: "args",
    				as: "o2"
    			},
    			{
    				from: "args",
    				to: "out",
    				as: "args",
    				type: "resolve"
    			},
    			{
    				from: "fn",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "dispatch_runnable",
    		nodes: [
    			{
    				id: "dispatch",
    				ref: "arg",
    				value: "dispatch",
    				type: "internal"
    			},
    			{
    				id: "fn",
    				ref: "arg",
    				value: "fn"
    			},
    			{
    				id: "run",
    				ref: "run"
    			},
    			{
    				id: "args",
    				ref: "arg",
    				value: "_args"
    			},
    			{
    				id: "out",
    				script: "dispatch({...fn, args: {...args, ...fn.args}})"
    			}
    		],
    		edges: [
    			{
    				from: "fn",
    				to: "run",
    				as: "runnable"
    			},
    			{
    				from: "fn",
    				to: "out",
    				as: "fn"
    			},
    			{
    				from: "run",
    				to: "_out",
    				as: "res"
    			},
    			{
    				from: "dispatch",
    				to: "out",
    				as: "dispatch"
    			},
    			{
    				from: "args",
    				to: "out",
    				as: "args"
    			}
    		]
    	},
    	{
    		id: "execute_graph",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "fn",
    				ref: "arg",
    				value: "fn"
    			},
    			{
    				id: "fn_graph",
    				ref: "arg",
    				value: "fn_graph"
    			},
    			{
    				id: "args",
    				ref: "arg",
    				value: "_args"
    			},
    			{
    				id: "filter_args",
    				script: "const ret = {...args}; delete ret.fn; delete ret.graph;"
    			},
    			{
    				id: "out",
    				script: "const res_graph = fn_graph ?? _graph; return (...inner_args) => {return _lib.no.executeGraphNode({graph: {...res_graph, nodes: [...res_graph.nodes], edges: [...res_graph.edges]}})(fn)(Object.keys(args).length > 0 ? Object.assign(args, inner_args.length === 1 ? inner_args[0] : inner_args) : inner_args.length === 1 ? inner_args[0] : inner_args);}"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "fn",
    				to: "out",
    				as: "fn"
    			},
    			{
    				from: "fn_graph",
    				to: "out",
    				as: "fn_graph"
    			}
    		]
    	},
    	{
    		id: "apply",
    		script: "return _lib.no.executeGraphNode({graph: fn.graph ?? _graph})(fn.fn ?? fn)(args);"
    	},
    	{
    		id: "apply_graph",
    		script: "return _lib.no.executeGraphNode({graph})(fn)(args);"
    	},
    	{
    		id: "partial",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "input_value",
    				ref: "arg",
    				value: "_args"
    			},
    			{
    				id: "fn",
    				ref: "arg",
    				value: "fn"
    			},
    			{
    				id: "args",
    				ref: "arg",
    				value: "args"
    			},
    			{
    				id: "out",
    				script: "return _lib.no.executeGraphNode({graph: _graph})(fn)(Object.assign({}, _args, args))"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args",
    				type: "ref"
    			},
    			{
    				from: "fn",
    				to: "out",
    				as: "fn"
    			},
    			{
    				from: "args",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "input_value",
    				to: "out",
    				as: "_args"
    			}
    		]
    	},
    	{
    		id: "partial_graph",
    		script: "return _lib.no.executeGraphNode({graph})(fn)(Object.assign({}, _args, args))"
    	},
    	{
    		id: "resolve",
    		args: [
    			"data"
    		],
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "keys",
    				args: [
    					"data"
    				],
    				script: "return [...data.keys()]"
    			},
    			{
    				id: "collate"
    			},
    			{
    				id: "out",
    				args: [
    					"data"
    				],
    				script: "return data"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "keys"
    			},
    			{
    				from: "keys",
    				to: "collate",
    				as: "input"
    			},
    			{
    				from: "in",
    				to: "collate"
    			},
    			{
    				from: "collate",
    				to: "out",
    				as: "data"
    			}
    		]
    	},
    	{
    		id: "array",
    		name: "array",
    		extern: "utility.new_array"
    	},
    	{
    		id: "wrap_effect_fn",
    		args: [
    			"fn"
    		],
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "fn",
    				ref: "arg",
    				value: "fn"
    			},
    			{
    				id: "payload",
    				ref: "arg",
    				value: "payload"
    			},
    			{
    				id: "out",
    				args: [
    					"fn"
    				],
    				script: "return (_, payload) => fn(payload)"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "arg0"
    			},
    			{
    				from: "payload",
    				to: "out",
    				as: "payload"
    			},
    			{
    				from: "fn",
    				to: "out",
    				as: "fn"
    			}
    		]
    	},
    	{
    		id: "merge_objects",
    		extern: "utility.merge_objects"
    	},
    	{
    		id: "get",
    		args: [
    			"target",
    			"path"
    		],
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "target",
    				ref: "arg",
    				value: "target"
    			},
    			{
    				id: "path",
    				ref: "arg",
    				value: "path"
    			},
    			{
    				id: "def",
    				ref: "arg",
    				value: "def"
    			},
    			{
    				id: "out",
    				extern: "just.get"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "input"
    			},
    			{
    				from: "def",
    				to: "out",
    				as: "def"
    			},
    			{
    				from: "path",
    				to: "out",
    				as: "path"
    			},
    			{
    				from: "target",
    				to: "out",
    				as: "target"
    			}
    		]
    	},
    	{
    		id: "arg",
    		extern: "utility.arg"
    	},
    	{
    		id: "set-mutable",
    		args: [
    			"target",
    			"path",
    			"value"
    		],
    		script: "return _lib.just.set(target, path, value)"
    	},
    	{
    		id: "set",
    		type: "(target: any, value: any, path: string) => any",
    		script: "const keys = path.split('.'); const check = (o, v, k) => k.length === 1 ? {...o, [k[0]]: v, _needsresolve: true} : o.hasOwnProperty(k[0]) ? {...o, [k[0]]: check(o[k[0]], v, k.slice(1)), _needsresolve: true} : o; return check(target, value, keys)"
    	},
    	{
    		id: "delete",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "target",
    				ref: "arg",
    				value: "target"
    			},
    			{
    				id: "path",
    				ref: "arg",
    				value: "path"
    			},
    			{
    				id: "out",
    				script: "const new_val = Object.assign({}, target); delete new_val[path]; return new_val"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "target",
    				to: "out",
    				as: "target"
    			},
    			{
    				from: "path",
    				to: "out",
    				as: "path"
    			}
    		]
    	},
    	{
    		id: "event_publisher",
    		out: "update",
    		nodes: [
    			{
    				id: "name",
    				ref: "arg",
    				value: "name"
    			},
    			{
    				id: "value",
    				ref: "arg",
    				value: "value"
    			},
    			{
    				id: "update",
    				extern: "no.runtime.publish"
    			}
    		],
    		edges: [
    			{
    				from: "name",
    				to: "update",
    				as: "event"
    			},
    			{
    				from: "value",
    				to: "update",
    				as: "data"
    			}
    		]
    	},
    	{
    		id: "event_subscriber",
    		out: "out",
    		nodes: [
    			{
    				id: "name",
    				ref: "arg",
    				value: "name"
    			},
    			{
    				id: "add_listener",
    				script: "const parent = _lib.no.runtime.get_node(_graph, _node.id.substring(0, _node.id.lastIndexOf('/'))); _lib.no.runtime.add_listener(_graph, event, parent.id, (graph, ev) => _lib.no.runtime.add_node(_graph, {...parent , value: ev}), true)"
    			},
    			{
    				id: "out",
    				script: "return _lib.no.runtime.get_node(_graph, _node.id.substring(0, _node.id.lastIndexOf('/'))).value;"
    			}
    		],
    		edges: [
    			{
    				from: "name",
    				to: "add_listener",
    				as: "event"
    			},
    			{
    				from: "add_listener",
    				to: "out",
    				as: "listener"
    			}
    		]
    	},
    	{
    		id: "fuse vertices",
    		name: "fuse vertices",
    		"in": "g8mx5sn1u",
    		out: "vnw7d8iaw",
    		args: [
    			"graph"
    		],
    		nodes: [
    			{
    				id: "vnw7d8iaw",
    				name: "fuse vertices",
    				ref: "switch",
    				args: [
    					"fuse",
    					"graph"
    				]
    			},
    			{
    				id: "6uzm3ifn3",
    				args: [
    					"graph"
    				],
    				script: "return graph.edges.length > 0 ? \"fuse\" : \"graph\""
    			},
    			{
    				id: "p229wzcj5",
    				ref: "fuse vertices"
    			},
    			{
    				id: "idjoql4db"
    			},
    			{
    				id: "wfld638dn",
    				args: [
    					"remaining_edges"
    				],
    				script: "return [remaining_edges.map(e => ({...e, to: e.to === chosen_edge.to || e.to === chosen_edge.from ? new_id : e.to, from: e.from === chosen_edge.from || e.from === chosen_edge.to ? new_id : e.from}))]"
    			},
    			{
    				id: "ungdjbio6",
    				args: [
    					"graph",
    					"chosen_edge"
    				],
    				script: "const remaining = graph.nodes\n.filter(n => n.id !== chosen_edge.to && n.id !== chosen_edge.from);\n\nconst from = [...(graph.nodes\n.find(n => n.id === chosen_edge.to).nodes ?? [chosen_edge.to])]\n\nconst to = [...(graph.nodes.find(n => n.id === chosen_edge.from).nodes ?? [chosen_edge.from])];\n\nreturn [remaining\n.concat([{\nid: new_id, \nnodes: [...(new Set(from.concat(to))).keys()],\n}])\n\n];"
    			},
    			{
    				id: "mh8lknkfv",
    				args: [
    					"graph"
    				],
    				script: "return [graph.edges.slice(1)]"
    			},
    			{
    				id: "h8bhlzbph",
    				args: [
    					"chosen_edge"
    				],
    				script: "return chosen_edge.to + \"_\" + chosen_edge.from;",
    				name: "new_id"
    			},
    			{
    				id: "1m739wxv9",
    				args: [
    					"graph"
    				],
    				script: "return graph.edges[0]",
    				name: "edge"
    			},
    			{
    				id: "nznzj5bfn",
    				name: "get graph",
    				ref: "get"
    			},
    			{
    				id: "g8mx5sn1u",
    				name: "fuse vertices/in"
    			},
    			{
    				id: "tta1nggm4",
    				value: "graph"
    			}
    		],
    		edges: [
    			{
    				from: "6uzm3ifn3",
    				to: "vnw7d8iaw",
    				as: "input"
    			},
    			{
    				from: "p229wzcj5",
    				to: "vnw7d8iaw",
    				as: "fuse"
    			},
    			{
    				from: "idjoql4db",
    				to: "p229wzcj5",
    				as: "graph"
    			},
    			{
    				from: "wfld638dn",
    				to: "idjoql4db",
    				as: "edges"
    			},
    			{
    				from: "ungdjbio6",
    				to: "idjoql4db",
    				as: "nodes"
    			},
    			{
    				from: "mh8lknkfv",
    				to: "wfld638dn",
    				as: "remaining_edges"
    			},
    			{
    				from: "h8bhlzbph",
    				to: "wfld638dn",
    				as: "new_id"
    			},
    			{
    				from: "1m739wxv9",
    				to: "wfld638dn",
    				as: "chosen_edge"
    			},
    			{
    				from: "h8bhlzbph",
    				to: "ungdjbio6",
    				as: "new_id"
    			},
    			{
    				from: "1m739wxv9",
    				to: "ungdjbio6",
    				as: "chosen_edge"
    			},
    			{
    				from: "nznzj5bfn",
    				to: "vnw7d8iaw",
    				as: "graph"
    			},
    			{
    				from: "nznzj5bfn",
    				to: "6uzm3ifn3",
    				as: "graph"
    			},
    			{
    				from: "nznzj5bfn",
    				to: "ungdjbio6",
    				as: "graph"
    			},
    			{
    				from: "nznzj5bfn",
    				to: "mh8lknkfv",
    				as: "graph"
    			},
    			{
    				from: "1m739wxv9",
    				to: "h8bhlzbph",
    				as: "chosen_edge"
    			},
    			{
    				from: "nznzj5bfn",
    				to: "1m739wxv9",
    				as: "graph"
    			},
    			{
    				from: "g8mx5sn1u",
    				to: "nznzj5bfn",
    				as: "target"
    			},
    			{
    				from: "tta1nggm4",
    				to: "nznzj5bfn",
    				as: "path"
    			}
    		]
    	},
    	{
    		id: "remove pendant",
    		name: "remove pendant",
    		"in": "jhykipayt",
    		out: "ay4hfrqw1",
    		nodes: [
    			{
    				id: "ay4hfrqw1",
    				args: [
    				],
    				name: "remove pendant",
    				ref: "switch"
    			},
    			{
    				id: "r5lka2sj5",
    				args: [
    				],
    				script: "return pendants.length > 0 ? [\"remove\"] : [\"graph\"]"
    			},
    			{
    				id: "7elx5ekij",
    				args: [
    				],
    				ref: "remove pendant"
    			},
    			{
    				id: "cz08pewa3",
    				args: [
    				]
    			},
    			{
    				id: "7n24u6kpt",
    				args: [
    					"nodes"
    				],
    				script: "return [nodes.filter(n => !pendant_edges.includes(n.id))]",
    				name: "filter out pendants"
    			},
    			{
    				id: "cuiccwvbv",
    				args: [
    				],
    				script: "return [edges.filter(e => !pendant_edges.includes(e.to) && !pendant_edges.includes(e.from))]",
    				name: "filter penant"
    			},
    			{
    				id: "lgzenfpvl",
    				args: [
    				],
    				script: "let accfrom = edges.flatMap(e => [e.from]).reduce((acc, v) => { acc[v] = (acc[v] ?? 0) + 1; return acc}, {});\nlet accto = edges.flatMap(e => [e.to]).reduce((acc, v) => { acc[v] = (acc[v] ?? 0) + 1; return acc}, {});\n\nreturn nodes.map(n => n.id).filter(n => (!isNaN(accfrom[n]) && accfrom[n] <= 1) && !accto[n] );",
    				name: "pendant edges"
    			},
    			{
    				id: "7g81ijcqb",
    				name: "nodes",
    				"in": "in",
    				out: "7g81ijcqb",
    				nodes: [
    					{
    						id: "7g81ijcqb",
    						args: [
    						],
    						ref: "get",
    						name: "nodes"
    					},
    					{
    						id: "2yshp7jvu",
    						args: [
    						],
    						value: "nodes"
    					},
    					{
    						id: "in"
    					}
    				],
    				edges: [
    					{
    						from: "2yshp7jvu",
    						to: "7g81ijcqb",
    						as: "path"
    					},
    					{
    						from: "in",
    						to: "7g81ijcqb"
    					}
    				]
    			},
    			{
    				id: "zkg9zpu3e",
    				name: "edges",
    				"in": "in",
    				out: "zkg9zpu3e",
    				nodes: [
    					{
    						id: "zkg9zpu3e",
    						args: [
    						],
    						ref: "get",
    						name: "edges"
    					},
    					{
    						id: "g18jj6zvq",
    						args: [
    						],
    						value: "edges"
    					},
    					{
    						id: "in"
    					}
    				],
    				edges: [
    					{
    						from: "g18jj6zvq",
    						to: "zkg9zpu3e",
    						as: "path"
    					},
    					{
    						from: "in",
    						to: "zkg9zpu3e"
    					}
    				]
    			},
    			{
    				id: "bp1cy89hk",
    				args: [
    				],
    				ref: "get",
    				name: "graph"
    			},
    			{
    				id: "jhykipayt",
    				args: [
    				],
    				name: "remove pendant/in"
    			},
    			{
    				id: "iqkdwjpuz",
    				args: [
    				],
    				value: "graph"
    			}
    		],
    		edges: [
    			{
    				from: "r5lka2sj5",
    				to: "ay4hfrqw1",
    				as: "input"
    			},
    			{
    				from: "7elx5ekij",
    				to: "ay4hfrqw1",
    				as: "remove"
    			},
    			{
    				from: "cz08pewa3",
    				to: "7elx5ekij",
    				as: "graph"
    			},
    			{
    				from: "7n24u6kpt",
    				to: "cz08pewa3",
    				as: "nodes"
    			},
    			{
    				from: "cuiccwvbv",
    				to: "cz08pewa3",
    				as: "edges"
    			},
    			{
    				from: "lgzenfpvl",
    				to: "r5lka2sj5",
    				as: "pendants"
    			},
    			{
    				from: "lgzenfpvl",
    				to: "cz08pewa3",
    				as: "pendants"
    			},
    			{
    				from: "7g81ijcqb",
    				to: "7n24u6kpt",
    				as: "nodes"
    			},
    			{
    				from: "lgzenfpvl",
    				to: "7n24u6kpt",
    				as: "pendant_edges"
    			},
    			{
    				from: "zkg9zpu3e",
    				to: "7n24u6kpt",
    				as: "edges"
    			},
    			{
    				from: "lgzenfpvl",
    				to: "cuiccwvbv",
    				as: "pendant_edges"
    			},
    			{
    				from: "zkg9zpu3e",
    				to: "cuiccwvbv",
    				as: "edges"
    			},
    			{
    				from: "zkg9zpu3e",
    				to: "lgzenfpvl",
    				as: "edges"
    			},
    			{
    				from: "7g81ijcqb",
    				to: "lgzenfpvl",
    				as: "nodes"
    			},
    			{
    				from: "bp1cy89hk",
    				to: "ay4hfrqw1",
    				as: "graph"
    			},
    			{
    				from: "bp1cy89hk",
    				to: "cz08pewa3"
    			},
    			{
    				from: "bp1cy89hk",
    				to: "7g81ijcqb",
    				as: "target"
    			},
    			{
    				from: "bp1cy89hk",
    				to: "zkg9zpu3e",
    				as: "target"
    			},
    			{
    				from: "jhykipayt",
    				to: "bp1cy89hk",
    				as: "target"
    			},
    			{
    				from: "iqkdwjpuz",
    				to: "bp1cy89hk",
    				as: "path"
    			}
    		]
    	},
    	{
    		id: "hyperapp_action",
    		script: "return {fn, graph: _graph}"
    	},
    	{
    		id: "hyperapp_state_action",
    		script: "return {fn, graph: _graph, stateonly: true}"
    	},
    	{
    		id: "hyperapp_action_effect",
    		description: "Creates an effect that dispatches the passed-in fn",
    		script: "const action = typeof fn === 'string' ? {fn, graph: _graph} : (typeof fn === 'function' || (typeof fn === 'object' && fn.hasOwnProperty('fn'))) ? fn : undefined; return (dispatch, payload) => dispatch(action, payload)"
    	},
    	{
    		id: "hyperapp_action_effect_debounced",
    		description: "Creates an effect that dispatches the passed-in fn",
    		script: "const action = typeof fn === 'string' ? {fn, graph: _graph} : (typeof fn === 'function' || (typeof fn === 'object' && fn.hasOwnProperty('fn'))) ? fn : undefined; return (dispatch, payload) => requestAnimationFrame(() => dispatch(action, payload))"
    	},
    	{
    		id: "run",
    		out: "out",
    		nodes: [
    			{
    				id: "runnable",
    				ref: "arg",
    				value: "runnable"
    			},
    			{
    				id: "args",
    				ref: "arg",
    				value: "_args"
    			},
    			{
    				id: "out",
    				script: "return _lib.no.runGraph(runnable.graph, runnable.fn, Object.assign({}, args, {runnable: undefined}, runnable.args))"
    			}
    		],
    		edges: [
    			{
    				from: "args",
    				to: "out",
    				as: "args",
    				type: "resolve"
    			},
    			{
    				from: "runnable",
    				to: "out",
    				as: "runnable"
    			}
    		]
    	},
    	{
    		id: "create_fn",
    		out: "out",
    		nodes: [
    			{
    				id: "runnable",
    				ref: "arg",
    				value: "runnable"
    			},
    			{
    				id: "args",
    				ref: "arg",
    				value: "_args"
    			},
    			{
    				id: "out",
    				script: "return (fnargs) => _lib.no.runGraph(runnable.graph, runnable.fn, Object.assign({}, args, {runnable: undefined}, runnable.args, typeof fnargs === 'object' ? fnargs : {}))"
    			}
    		],
    		edges: [
    			{
    				from: "args",
    				to: "out",
    				as: "args",
    				type: "resolve"
    			},
    			{
    				from: "runnable",
    				to: "out",
    				as: "runnable"
    			}
    		]
    	},
    	{
    		id: "runnable_hyperapp_effect",
    		out: "out",
    		nodes: [
    			{
    				id: "fn",
    				ref: "arg",
    				value: "fn"
    			},
    			{
    				id: "out",
    				script: "return (dispatch, payload) => {const wrapped_dispatch = (a, p) => Promise.resolve(p).then(resp => Promise.resolve(a).then(aresp => [aresp, resp])).then(([a, p]) => dispatch(a, p)).catch(e => dispatch(s => [{...s, error: e}])); wrapped_dispatch(state => {Promise.resolve(state).then(s => _lib.no.runGraph(fn.graph, fn.fn, {state: s, ...payload, ...fn.args, dispatch: wrapped_dispatch})); return state.error ? {...state, error: false} : state;})}"
    			}
    		],
    		edges: [
    			{
    				from: "fn",
    				to: "out",
    				as: "fn"
    			}
    		]
    	},
    	{
    		id: "run_display_graph_effect",
    		out: "out",
    		nodes: [
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "display_graph",
    				ref: "arg",
    				value: "state.display_graph"
    			},
    			{
    				id: "payload",
    				ref: "arg",
    				value: "payload"
    			},
    			{
    				id: "dispatch",
    				ref: "arg",
    				value: "dispatch"
    			},
    			{
    				id: "display_graph_runnable",
    				script: "return {fn: 'main/out', graph: {...display_graph, nodes: [...display_graph.nodes], edges: [...display_graph.edges]}, args: {state, graph: state.display_graph, payload: {event: payload}}}"
    			},
    			{
    				id: "result_runnable",
    				script: "try { const res = _lib.no.runGraph(runnable); dispatch(s => s.error ? {...s, error: false} : s); return res; } catch(e) { dispatch(s => ({...s, error: e}));}"
    			},
    			{
    				id: "run_result",
    				ref: "runnable_hyperapp_effect"
    			},
    			{
    				id: "out",
    				script: "return (dispatch, payload) => {try { const res = _lib.no.runGraph(runnable); Promise.resolve(res).then(r => dispatch(s => r.result_display ? {...s, result_display: r.result_display, error: false} : s.error ? {...s, error: false} : s)); } catch(e) { dispatch(s => ({...s, error: e}));}}"
    			},
    			{
    				id: "_out",
    				script: "return (dispatch, payload) => {const wrapped_dispatch = (a, p) => Promise.resolve(p).then(resp => Promise.resolve(a).then(aresp => [aresp, resp])).then(([a, p]) => dispatch(a, p)).catch(e => dispatch(s => [{...s, error: e}])); wrapped_dispatch(state => {new Promise((resolve, reject) => resolve(_lib.no.runGraph({...runnable, args: {...runnable.args, dispatch: wrapped_dispatch}}))).then(res => _lib.no.runGraph(res)).catch(e => dispatch(s => [{...s, error: e}])); return state.error ? {...state, error: false} : state;})}"
    			}
    		],
    		edges: [
    			{
    				from: "state",
    				to: "result",
    				as: "state"
    			},
    			{
    				from: "payload",
    				to: "result",
    				as: "payload"
    			},
    			{
    				from: "dispatch",
    				to: "result",
    				as: "dispatch"
    			},
    			{
    				from: "display_graph",
    				to: "result",
    				as: "fn_graph"
    			},
    			{
    				from: "result",
    				to: "_out",
    				as: "fn",
    				type: "ref"
    			},
    			{
    				from: "result",
    				to: "_run_result",
    				as: "fn"
    			},
    			{
    				from: "display_graph",
    				to: "display_graph_runnable",
    				as: "display_graph"
    			},
    			{
    				from: "dispatch",
    				to: "display_graph_runnable",
    				as: "dispatch"
    			},
    			{
    				from: "payload",
    				to: "display_graph_runnable",
    				as: "payload"
    			},
    			{
    				from: "state",
    				to: "display_graph_runnable",
    				as: "state"
    			},
    			{
    				from: "display_graph_runnable",
    				to: "result_runnable",
    				as: "runnable"
    			},
    			{
    				from: "dispatch",
    				to: "result_runnable",
    				as: "dispatch"
    			},
    			{
    				from: "result_runnable",
    				to: "result_wrapper",
    				as: "fn"
    			},
    			{
    				from: "result_runnable",
    				to: "run_result",
    				as: "fn"
    			},
    			{
    				from: "display_graph_runnable",
    				to: "out",
    				as: "runnable"
    			}
    		]
    	},
    	{
    		id: "update_graph_display",
    		"in": "in",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "payload",
    				ref: "arg",
    				value: "payload"
    			},
    			{
    				id: "update_sim_effect",
    				ref: "arg",
    				value: "state.update_sim_effect"
    			},
    			{
    				id: "show_result",
    				ref: "arg",
    				value: "state.show_result"
    			},
    			{
    				id: "state_result",
    				ref: "arg",
    				value: "state.result"
    			},
    			{
    				id: "error_nodes",
    				ref: "arg",
    				value: "state.error_nodes"
    			},
    			{
    				id: "update_arg",
    				ref: "arg",
    				value: "state.update"
    			},
    			{
    				id: "nodes",
    				ref: "arg",
    				value: "state.nodes"
    			},
    			{
    				id: "links",
    				ref: "arg",
    				value: "state.links"
    			},
    			{
    				id: "selected",
    				ref: "arg",
    				value: "state.selected"
    			},
    			{
    				id: "readonly",
    				ref: "arg",
    				value: "state.readonly"
    			},
    			{
    				id: "html_id",
    				ref: "arg",
    				value: "state.html_id"
    			},
    			{
    				id: "norun",
    				ref: "arg",
    				value: "state.norun"
    			},
    			{
    				id: "show_args_effector",
    				ref: "show_args_effect"
    			},
    			{
    				id: "show_args_effect",
    				ref: "array"
    			},
    			{
    				id: "should_show_args",
    				ref: "switch"
    			},
    			{
    				id: "dispatch_custom_event_effect",
    				ref: "dispatch_custom_event_effect"
    			},
    			{
    				id: "in_effects",
    				ref: "arg",
    				value: "effects"
    			},
    			{
    				id: "new_effects",
    				ref: "array"
    			},
    			{
    				id: "effects",
    				ref: "concat"
    			},
    			{
    				id: "display_graph",
    				ref: "arg",
    				value: "state.display_graph"
    			},
    			{
    				id: "calculate_levels",
    				script: "return _lib.scripts.calculateLevels(nodes, links, display_graph, selected)"
    			},
    			{
    				id: "reduce_graph",
    				ref: "fuse vertices"
    			},
    			{
    				id: "levels",
    				ref: "switch",
    				args: [
    					"levels"
    				]
    			},
    			{
    				id: "levels_inputs",
    				args: [
    					"selected"
    				],
    				script: "return ['levels']"
    			},
    			{
    				id: "set_levels",
    				args: [
    					"state",
    					"levels"
    				],
    				script: "return {...state, levels: levels ?? state.levels}"
    			},
    			{
    				id: "graph_sim",
    				script: "return undefined;"
    			},
    			{
    				id: "new_state_cases",
    				script: "return [graph_sim && 'graph_sim', 'state']"
    			},
    			{
    				id: "new_state",
    				script: "return Object.assign({}, state, {nodes: graph_sim?.nodes ?? state.nodes, links: graph_sim?.links ?? state.links, levels: graph_sim?.levels ?? state.levels});"
    			},
    			{
    				id: "update",
    				script: "return update || !!display_graph || !!selected"
    			},
    			{
    				id: "run",
    				ref: "run_display_graph_effect"
    			},
    			{
    				id: "run_wrapper"
    			},
    			{
    				id: "out",
    				script: "return {state, effects: [!readonly && (!!update || !!update_graph_sim) && [update_sim_effect, state], !readonly && [dispatch_custom_event_effect, {html_id, event: 'updategraph', detail: {graph: state.display_graph}}], ...(effects?.filter(e => e?.[0]) ?? [])]}"
    			}
    		],
    		edges: [
    			{
    				from: "update_arg",
    				to: "update",
    				as: "update"
    			},
    			{
    				from: "state",
    				to: "set_levels",
    				as: "state"
    			},
    			{
    				from: "in",
    				to: "levels_inputs"
    			},
    			{
    				from: "in",
    				to: "graph"
    			},
    			{
    				from: "display_graph",
    				to: "reduce_graph",
    				as: "graph"
    			},
    			{
    				from: "payload",
    				to: "run",
    				as: "payload"
    			},
    			{
    				from: "display_graph",
    				to: "run",
    				as: "display_graph"
    			},
    			{
    				from: "html_id",
    				to: "run",
    				as: "html_id"
    			},
    			{
    				from: "nodes",
    				to: "calculate_levels",
    				as: "nodes"
    			},
    			{
    				from: "links",
    				to: "calculate_levels",
    				as: "links"
    			},
    			{
    				from: "selected",
    				to: "calculate_levels",
    				as: "selected"
    			},
    			{
    				from: "display_graph",
    				to: "calculate_levels",
    				as: "display_graph"
    			},
    			{
    				from: "calculate_levels",
    				to: "levels",
    				as: "levels"
    			},
    			{
    				from: "levels",
    				to: "set_levels",
    				as: "levels"
    			},
    			{
    				from: "set_levels",
    				to: "new_state",
    				as: "state"
    			},
    			{
    				from: "levels_inputs",
    				to: "levels",
    				as: "input"
    			},
    			{
    				from: "graph_sim",
    				to: "new_state",
    				as: "graph_sim"
    			},
    			{
    				from: "error_nodes",
    				to: "run",
    				as: "error_nodes"
    			},
    			{
    				from: "state_result",
    				to: "run",
    				as: "prev_result"
    			},
    			{
    				from: "run",
    				to: "result",
    				as: "run"
    			},
    			{
    				from: "norun",
    				to: "out",
    				as: "norun"
    			},
    			{
    				from: "show_result",
    				to: "out",
    				as: "show_result"
    			},
    			{
    				from: "run",
    				to: "run_wrapper",
    				as: "run"
    			},
    			{
    				from: "run_wrapper",
    				to: "out",
    				as: "run"
    			},
    			{
    				from: "readonly",
    				to: "out",
    				as: "readonly"
    			},
    			{
    				from: "selected",
    				to: "update",
    				as: "selected"
    			},
    			{
    				from: "display_graph",
    				to: "update",
    				as: "display_graph"
    			},
    			{
    				from: "update",
    				to: "out",
    				as: "update"
    			},
    			{
    				from: "readonly",
    				to: "should_show_args",
    				as: "input"
    			},
    			{
    				from: "show_args_effector",
    				to: "show_args_effect",
    				as: "a0"
    			},
    			{
    				from: "show_args_effect",
    				to: "should_show_args",
    				as: "false"
    			},
    			{
    				from: "should_show_args",
    				to: "new_effects",
    				as: "a0"
    			},
    			{
    				from: "new_effects",
    				to: "effects",
    				as: "array"
    			},
    			{
    				from: "in_effects",
    				to: "effects",
    				as: "items"
    			},
    			{
    				from: "payload",
    				to: "out",
    				as: "payload"
    			},
    			{
    				from: "html_id",
    				to: "out",
    				as: "html_id"
    			},
    			{
    				from: "display_graph",
    				to: "out",
    				as: "display_graph"
    			},
    			{
    				from: "effects",
    				to: "out",
    				as: "effects",
    				type: "resolve"
    			},
    			{
    				from: "dispatch_custom_event_effect",
    				to: "out",
    				as: "dispatch_custom_event_effect"
    			},
    			{
    				from: "update_sim_effect",
    				to: "out",
    				as: "update_sim_effect"
    			},
    			{
    				from: "new_state",
    				to: "out",
    				as: "state"
    			}
    		]
    	},
    	{
    		id: "reduce",
    		name: "reduce",
    		"in": "m3b5wg3",
    		out: "tgurdpo",
    		nodes: [
    			{
    				id: "tgurdpo",
    				ref: "call",
    				name: "out"
    			},
    			{
    				id: "m3b5wg3",
    				name: "in"
    			},
    			{
    				id: "rielyq8",
    				value: "reduce",
    				name: "rielyq8"
    			},
    			{
    				ref: "arg",
    				id: "1rre4bx",
    				value: "array",
    				name: "1rre4bx"
    			},
    			{
    				ref: "arg",
    				id: "6g75abk",
    				value: "fn",
    				name: "6g75abk"
    			},
    			{
    				id: "w0zzawl",
    				ref: "array",
    				name: "w0zzawl"
    			},
    			{
    				id: "args",
    				ref: "arg",
    				value: "_args"
    			},
    			{
    				id: "pdljod1",
    				name: "pdljod1",
    				script: "return (previous, current, index, array) => _lib.no.runGraph(fn?.graph ?? _graph, fn?.fn ?? fn, Object.assign({}, args, {previous, current, index, array}));"
    			},
    			{
    				id: "2lvs5dj",
    				script: "return _graph",
    				name: "2lvs5dj"
    			}
    		],
    		edges: [
    			{
    				from: "m3b5wg3",
    				to: "tgurdpo",
    				as: "args",
    				type: "ref"
    			},
    			{
    				from: "rielyq8",
    				to: "tgurdpo",
    				as: "fn"
    			},
    			{
    				from: "1rre4bx",
    				to: "tgurdpo",
    				as: "self"
    			},
    			{
    				from: "w0zzawl",
    				to: "tgurdpo",
    				as: "args",
    				type: "resolve"
    			},
    			{
    				from: "pdljod1",
    				to: "w0zzawl",
    				as: "a0"
    			},
    			{
    				from: "2lvs5dj",
    				to: "pdljod1",
    				as: "graph"
    			},
    			{
    				from: "args",
    				to: "pdljod1",
    				as: "args"
    			},
    			{
    				from: "6g75abk",
    				to: "pdljod1",
    				as: "fn"
    			}
    		]
    	},
    	{
    		id: "map",
    		name: "map",
    		"in": "m3b5wg3",
    		out: "tgurdpo",
    		nodes: [
    			{
    				id: "tgurdpo",
    				ref: "call",
    				name: "out"
    			},
    			{
    				id: "m3b5wg3",
    				name: "in"
    			},
    			{
    				id: "rielyq8",
    				value: "map",
    				name: "rielyq8"
    			},
    			{
    				ref: "arg",
    				id: "1rre4bx",
    				value: "array",
    				name: "1rre4bx"
    			},
    			{
    				ref: "arg",
    				id: "6g75abk",
    				value: "fn",
    				name: "6g75abk"
    			},
    			{
    				id: "w0zzawl",
    				ref: "array",
    				name: "w0zzawl"
    			},
    			{
    				id: "args",
    				ref: "arg",
    				value: "args"
    			},
    			{
    				id: "pdljod1",
    				name: "pdljod1",
    				script: "return (element, index, array) => _lib.no.runGraph(fn?.graph ?? _graph, fn?.fn ?? fn, Object.assign({}, fn.args, args, {element, index, array}));"
    			},
    			{
    				id: "2lvs5dj",
    				script: "return _graph",
    				name: "2lvs5dj"
    			}
    		],
    		edges: [
    			{
    				from: "m3b5wg3",
    				to: "tgurdpo",
    				as: "args",
    				type: "ref"
    			},
    			{
    				from: "rielyq8",
    				to: "tgurdpo",
    				as: "fn"
    			},
    			{
    				from: "1rre4bx",
    				to: "tgurdpo",
    				as: "self"
    			},
    			{
    				from: "w0zzawl",
    				to: "tgurdpo",
    				as: "args",
    				type: "resolve"
    			},
    			{
    				from: "pdljod1",
    				to: "w0zzawl",
    				as: "a0"
    			},
    			{
    				from: "2lvs5dj",
    				to: "pdljod1",
    				as: "graph"
    			},
    			{
    				from: "args",
    				to: "pdljod1",
    				as: "args"
    			},
    			{
    				from: "6g75abk",
    				to: "pdljod1",
    				as: "fn"
    			}
    		]
    	},
    	{
    		id: "toggle",
    		name: "toggle",
    		"in": "itrzmbe",
    		out: "nn4twx9",
    		nodes: [
    			{
    				id: "nn4twx9",
    				ref: "html_element",
    				inputs: [
    					{
    						from: "lvzwtzi",
    						to: "nn4twx9",
    						as: "children"
    					},
    					{
    						from: "t6q6rvf",
    						to: "nn4twx9",
    						as: "props"
    					},
    					{
    						from: "tchu5kq",
    						to: "nn4twx9",
    						as: "dom_type"
    					}
    				],
    				name: "out"
    			},
    			{
    				id: "lvzwtzi",
    				ref: "array"
    			},
    			{
    				id: "t6q6rvf"
    			},
    			{
    				id: "tchu5kq",
    				value: "button"
    			},
    			{
    				id: "583nwco",
    				name: "in"
    			},
    			{
    				id: "itrzmbe",
    				name: "in"
    			},
    			{
    				id: "vmehp75/h4hkmke",
    				ref: "html_text",
    				name: "button_text"
    			},
    			{
    				id: "punpbfw",
    				ref: "execute_graph",
    				name: "onclick_fn"
    			},
    			{
    				id: "2aqvso8",
    				ref: "arg",
    				value: "value"
    			},
    			{
    				id: "teuf938",
    				ref: "arg",
    				value: "value"
    			},
    			{
    				id: "1067z1h",
    				ref: "array"
    			},
    			{
    				id: "b8q8y2q",
    				ref: "array"
    			},
    			{
    				id: "pprukwn",
    				ref: "set"
    			},
    			{
    				id: "zu0hb6e",
    				ref: "arg",
    				value: "0.update_hyperapp"
    			},
    			{
    				id: "eo8hxkq",
    				script: "return !toggle;"
    			},
    			{
    				id: "s6847dx",
    				ref: "arg",
    				value: "0"
    			},
    			{
    				id: "5g3gdi1",
    				script: "return 'result.' + value;"
    			},
    			{
    				id: "flcuh31",
    				ref: "get"
    			},
    			{
    				id: "0eoq13n",
    				ref: "arg",
    				value: "value"
    			},
    			{
    				id: "ysqu0jj",
    				ref: "arg",
    				value: "0.result"
    			},
    			{
    				id: "8ji5lb6",
    				ref: "arg",
    				value: "value"
    			}
    		],
    		edges: [
    			{
    				from: "lvzwtzi",
    				to: "nn4twx9",
    				as: "children"
    			},
    			{
    				from: "t6q6rvf",
    				to: "nn4twx9",
    				as: "props"
    			},
    			{
    				from: "tchu5kq",
    				to: "nn4twx9",
    				as: "dom_type"
    			},
    			{
    				from: "583nwco",
    				to: "nn4twx9",
    				as: "arg3"
    			},
    			{
    				from: "itrzmbe",
    				to: "nn4twx9",
    				as: "arg4"
    			},
    			{
    				to: "lvzwtzi",
    				from: "vmehp75/h4hkmke",
    				as: "arg1"
    			},
    			{
    				from: "punpbfw",
    				to: "t6q6rvf",
    				as: "onclick"
    			},
    			{
    				from: "2aqvso8",
    				to: "vmehp75/h4hkmke",
    				as: "text"
    			},
    			{
    				from: "teuf938",
    				to: "punpbfw",
    				as: "value"
    			},
    			{
    				from: "1067z1h",
    				to: "punpbfw",
    				as: "fn",
    				type: "ref"
    			},
    			{
    				from: "b8q8y2q",
    				to: "1067z1h",
    				as: "arg1"
    			},
    			{
    				from: "pprukwn",
    				to: "1067z1h",
    				as: "arg0"
    			},
    			{
    				from: "zu0hb6e",
    				to: "b8q8y2q",
    				as: "update_hyperapp"
    			},
    			{
    				from: "eo8hxkq",
    				to: "pprukwn",
    				as: "value"
    			},
    			{
    				from: "s6847dx",
    				to: "pprukwn",
    				as: "target"
    			},
    			{
    				from: "5g3gdi1",
    				to: "pprukwn",
    				as: "path"
    			},
    			{
    				from: "flcuh31",
    				to: "eo8hxkq",
    				as: "toggle"
    			},
    			{
    				from: "0eoq13n",
    				to: "5g3gdi1",
    				as: "value"
    			},
    			{
    				from: "ysqu0jj",
    				to: "flcuh31",
    				as: "target"
    			},
    			{
    				from: "8ji5lb6",
    				to: "flcuh31",
    				as: "path"
    			}
    		]
    	},
    	{
    		id: "sequence",
    		name: "sequence",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "args",
    				ref: "arg",
    				value: "_args"
    			},
    			{
    				id: "runnable_args",
    				ref: "arg",
    				value: "_args"
    			},
    			{
    				id: "value_args",
    				ref: "arg",
    				value: "args"
    			},
    			{
    				id: "context_args",
    				ref: "arg",
    				value: "_args"
    			},
    			{
    				id: "merged_args",
    				ref: "merge_objects"
    			},
    			{
    				id: "args_path",
    				value: "args"
    			},
    			{
    				id: "seq_runnable_args",
    				ref: "delete"
    			},
    			{
    				name: "in",
    				id: "in"
    			},
    			{
    				id: "runnables_promise",
    				script: "return Promise.all(promises);"
    			},
    			{
    				id: "map_runnables",
    				ref: "map"
    			},
    			{
    				id: "runnables",
    				script: "const runnables = Object.entries(inputs).filter(e => e[0] !== 'args').map(e => [e[0], e[1] && e[1]._Proxy ? e[1]._value : e[1]]).filter(r => r[1] && r[1].hasOwnProperty('fn') && r[1].hasOwnProperty('graph')); const filtered_args = Object.fromEntries(Object.entries(args).filter(a => !runnables.find(r => r[0] === a[0]))); return runnables.map(r => r[1]).map(r => ({...r, args: {...r.args, ...filtered_args}}))"
    			},
    			{
    				id: "element",
    				ref: "arg",
    				value: "element",
    				type: "internal"
    			},
    			{
    				id: "map_fn",
    				script: "return new Promise((resolve, reject) => resolve(_lib.no.runGraph(runnable.graph, runnable.fn, runnable.args)));"
    			},
    			{
    				id: "map_fn_runnable",
    				ref: "runnable"
    			},
    			{
    				name: "seq_runnable",
    				id: "out",
    				ref: "runnable"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "runnables",
    				as: "inputs"
    			},
    			{
    				from: "args",
    				to: "runnables",
    				as: "args"
    			},
    			{
    				from: "element",
    				to: "map_fn",
    				as: "runnable"
    			},
    			{
    				from: "map_fn",
    				to: "map_fn_runnable",
    				as: "fn"
    			},
    			{
    				from: "runnable_args",
    				to: "map_runnables",
    				as: "args"
    			},
    			{
    				from: "runnables",
    				to: "map_runnables",
    				as: "array"
    			},
    			{
    				from: "map_fn_runnable",
    				to: "map_runnables",
    				as: "fn"
    			},
    			{
    				from: "map_runnables",
    				to: "runnables_promise",
    				as: "promises"
    			},
    			{
    				from: "runnables_promise",
    				to: "out",
    				as: "fn"
    			},
    			{
    				from: "context_args",
    				to: "merged_args",
    				as: "a0"
    			},
    			{
    				from: "value_args",
    				to: "merged_args",
    				as: "a1"
    			},
    			{
    				from: "merged_args",
    				to: "seq_runnable_args",
    				as: "target"
    			},
    			{
    				from: "args_path",
    				to: "seq_runnable_args",
    				as: "path"
    			},
    			{
    				from: "seq_runnable_args",
    				to: "out",
    				as: "args"
    			}
    		]
    	},
    	{
    		id: "import_json",
    		name: "import_json",
    		"in": "j5hwdot",
    		out: "06osgt6",
    		nodes: [
    			{
    				id: "06osgt6",
    				ref: "initial_state_runnable",
    				name: "out"
    			},
    			{
    				id: "lx2r71d",
    				ref: "runnable"
    			},
    			{
    				id: "j5hwdot",
    				name: "in"
    			},
    			{
    				id: "upzmz7i",
    				script: "return 'imports.' + name"
    			},
    			{
    				id: "hfgitu2",
    				ref: "run"
    			},
    			{
    				id: "i68oe5k"
    			},
    			{
    				id: "qomntld",
    				ref: "arg",
    				value: "name"
    			},
    			{
    				id: "hgo86cn",
    				ref: "runnable"
    			},
    			{
    				id: "7m3jfmy",
    				ref: "arg",
    				value: "name"
    			},
    			{
    				id: "z9zvilt",
    				ref: "arg",
    				value: "url"
    			},
    			{
    				id: "f89a5u2"
    			},
    			{
    				id: "1v653xe",
    				ref: "get"
    			},
    			{
    				id: "my879k4",
    				ref: "call"
    			},
    			{
    				id: "gfpdf11",
    				ref: "arg",
    				value: "name"
    			},
    			{
    				id: "23kbk1n",
    				ref: "run"
    			},
    			{
    				id: "71ppowa",
    				script: "return \"1\";"
    			},
    			{
    				id: "mzijca2",
    				ref: "fetch"
    			},
    			{
    				id: "vdfrqzc",
    				value: "json"
    			},
    			{
    				id: "83xy8y2",
    				ref: "sequence"
    			},
    			{
    				id: "5hat6g2",
    				ref: "arg",
    				value: "url"
    			},
    			{
    				id: "olx0rqo",
    				ref: "runnable"
    			},
    			{
    				id: "9swjqs2",
    				ref: "runnable"
    			},
    			{
    				id: "cbahtxj"
    			},
    			{
    				id: "jpuj66z",
    				ref: "dispatch_runnable"
    			},
    			{
    				id: "rfmgm5u",
    				ref: "arg",
    				value: "imported_graph",
    				type: "internal"
    			},
    			{
    				id: "jrt3ao3",
    				ref: "arg",
    				value: "name",
    				type: "internal"
    			},
    			{
    				id: "830e6rx",
    				ref: "arg",
    				value: "imported_graph",
    				type: "internal"
    			},
    			{
    				id: "4qd7fl3",
    				ref: "runnable"
    			},
    			{
    				id: "sae69iz"
    			},
    			{
    				id: "j6g4jd4"
    			},
    			{
    				id: "um99k99",
    				ref: "arg",
    				value: "imported_graph",
    				type: "internal"
    			},
    			{
    				id: "z2ccs2u",
    				ref: "arg",
    				value: "name"
    			},
    			{
    				id: "xl0tqsd",
    				ref: "set"
    			},
    			{
    				id: "sajmrbs",
    				value: "display_graph"
    			},
    			{
    				id: "i50d0rl",
    				ref: "set"
    			},
    			{
    				id: "59iaxzp",
    				ref: "arg",
    				value: "state",
    				type: "internal"
    			},
    			{
    				id: "pfe7svb",
    				ref: "arg",
    				value: "state.display_graph",
    				type: "internal"
    			},
    			{
    				id: "dsqrh2d",
    				value: "nodes"
    			},
    			{
    				id: "9zfxac6",
    				ref: "append"
    			},
    			{
    				id: "2zvxan2",
    				ref: "map"
    			},
    			{
    				id: "hrzgjqm",
    				script: "return nodes.filter(n => !n.id.startsWith(imported_id)).concat([{id: imported_id}]);"
    			},
    			{
    				id: "a8x8a5c",
    				ref: "arg",
    				value: "payload.imported_graph.nodes",
    				type: "internal"
    			},
    			{
    				id: "d4yl375",
    				ref: "runnable"
    			},
    			{
    				id: "2f1lyvz",
    				ref: "arg",
    				value: "state.display_graph.nodes",
    				type: "internal"
    			},
    			{
    				id: "oco33oy",
    				ref: "arg",
    				value: "payload.name",
    				type: "internal"
    			},
    			{
    				id: "55qulh4",
    				ref: "set"
    			},
    			{
    				id: "4az2m7o"
    			},
    			{
    				id: "ugtx81k",
    				ref: "arg",
    				value: "element",
    				type: "internal"
    			},
    			{
    				id: "2eq7kuu",
    				value: "id"
    			},
    			{
    				id: "2tekj7w",
    				script: "return imported_id + '.' + node_id;"
    			},
    			{
    				id: "2xt8tpx",
    				ref: "arg",
    				value: "payload.name",
    				type: "internal"
    			},
    			{
    				id: "og27c4d",
    				ref: "arg",
    				value: "imported_id",
    				type: "internal"
    			},
    			{
    				id: "aodmtk1",
    				ref: "arg",
    				value: "element.id",
    				type: "internal"
    			}
    		],
    		edges: [
    			{
    				from: "lx2r71d",
    				to: "06osgt6",
    				as: "fn"
    			},
    			{
    				from: "j5hwdot",
    				to: "06osgt6",
    				as: "_"
    			},
    			{
    				from: "upzmz7i",
    				to: "06osgt6",
    				as: "value"
    			},
    			{
    				from: "hfgitu2",
    				to: "lx2r71d",
    				as: "fn"
    			},
    			{
    				from: "i68oe5k",
    				to: "lx2r71d",
    				as: "args"
    			},
    			{
    				from: "qomntld",
    				to: "upzmz7i",
    				as: "name"
    			},
    			{
    				from: "hgo86cn",
    				to: "hfgitu2",
    				as: "runnable"
    			},
    			{
    				from: "7m3jfmy",
    				to: "i68oe5k",
    				as: "name"
    			},
    			{
    				from: "z9zvilt",
    				to: "i68oe5k",
    				as: "url"
    			},
    			{
    				from: "f89a5u2",
    				to: "hgo86cn",
    				as: "args"
    			},
    			{
    				from: "1v653xe",
    				to: "hgo86cn",
    				as: "fn"
    			},
    			{
    				from: "my879k4",
    				to: "f89a5u2",
    				as: "imported_graph"
    			},
    			{
    				from: "gfpdf11",
    				to: "f89a5u2",
    				as: "name"
    			},
    			{
    				from: "23kbk1n",
    				to: "1v653xe",
    				as: "target"
    			},
    			{
    				from: "71ppowa",
    				to: "1v653xe",
    				as: "path"
    			},
    			{
    				from: "mzijca2",
    				to: "my879k4",
    				as: "self"
    			},
    			{
    				from: "vdfrqzc",
    				to: "my879k4",
    				as: "fn"
    			},
    			{
    				from: "83xy8y2",
    				to: "23kbk1n",
    				as: "runnable"
    			},
    			{
    				from: "5hat6g2",
    				to: "mzijca2",
    				as: "url"
    			},
    			{
    				from: "olx0rqo",
    				to: "83xy8y2",
    				as: "arg0"
    			},
    			{
    				from: "9swjqs2",
    				to: "83xy8y2",
    				as: "arg1"
    			},
    			{
    				from: "cbahtxj",
    				to: "83xy8y2",
    				as: "args"
    			},
    			{
    				from: "jpuj66z",
    				to: "olx0rqo",
    				as: "fn"
    			},
    			{
    				from: "rfmgm5u",
    				to: "9swjqs2",
    				as: "fn"
    			},
    			{
    				from: "jrt3ao3",
    				to: "cbahtxj",
    				as: "name"
    			},
    			{
    				from: "830e6rx",
    				to: "cbahtxj",
    				as: "imported_graph"
    			},
    			{
    				from: "4qd7fl3",
    				to: "jpuj66z",
    				as: "fn"
    			},
    			{
    				from: "sae69iz",
    				to: "4qd7fl3",
    				as: "args"
    			},
    			{
    				from: "j6g4jd4",
    				to: "4qd7fl3",
    				as: "fn"
    			},
    			{
    				from: "um99k99",
    				to: "sae69iz",
    				as: "imported_graph"
    			},
    			{
    				from: "z2ccs2u",
    				to: "sae69iz",
    				as: "name"
    			},
    			{
    				from: "xl0tqsd",
    				to: "j6g4jd4",
    				as: "state"
    			},
    			{
    				from: "sajmrbs",
    				to: "xl0tqsd",
    				as: "path"
    			},
    			{
    				from: "i50d0rl",
    				to: "xl0tqsd",
    				as: "value"
    			},
    			{
    				from: "59iaxzp",
    				to: "xl0tqsd",
    				as: "target"
    			},
    			{
    				from: "pfe7svb",
    				to: "i50d0rl",
    				as: "target"
    			},
    			{
    				from: "dsqrh2d",
    				to: "i50d0rl",
    				as: "path"
    			},
    			{
    				from: "9zfxac6",
    				to: "i50d0rl",
    				as: "value"
    			},
    			{
    				from: "2zvxan2",
    				to: "9zfxac6",
    				as: "item"
    			},
    			{
    				from: "hrzgjqm",
    				to: "9zfxac6",
    				as: "array"
    			},
    			{
    				from: "a8x8a5c",
    				to: "2zvxan2",
    				as: "array"
    			},
    			{
    				from: "d4yl375",
    				to: "2zvxan2",
    				as: "fn"
    			},
    			{
    				from: "2f1lyvz",
    				to: "hrzgjqm",
    				as: "nodes"
    			},
    			{
    				from: "oco33oy",
    				to: "hrzgjqm",
    				as: "imported_id"
    			},
    			{
    				from: "55qulh4",
    				to: "d4yl375",
    				as: "fn"
    			},
    			{
    				from: "4az2m7o",
    				to: "d4yl375",
    				as: "args"
    			},
    			{
    				from: "ugtx81k",
    				to: "55qulh4",
    				as: "target"
    			},
    			{
    				from: "2eq7kuu",
    				to: "55qulh4",
    				as: "path"
    			},
    			{
    				from: "2tekj7w",
    				to: "55qulh4",
    				as: "value"
    			},
    			{
    				from: "2xt8tpx",
    				to: "4az2m7o",
    				as: "imported_id"
    			},
    			{
    				from: "og27c4d",
    				to: "2tekj7w",
    				as: "imported_id"
    			},
    			{
    				from: "aodmtk1",
    				to: "2tekj7w",
    				as: "node_id"
    			}
    		]
    	},
    	{
    		id: "initial_state_runnable",
    		name: "initial_state_runnable",
    		"in": "0tsqw11",
    		out: "pd64cr8",
    		nodes: [
    			{
    				name: "out",
    				id: "pd64cr8",
    				ref: "default"
    			},
    			{
    				id: "usd4433",
    				name: "modify_state_runnable",
    				ref: "modify_state_runnable"
    			},
    			{
    				id: "0tsqw11",
    				name: "in"
    			},
    			{
    				id: "6rdgk5r",
    				ref: "get"
    			},
    			{
    				id: "4g0xgt3",
    				value: "value",
    				ref: "arg"
    			},
    			{
    				id: "itmdest",
    				value: "fn",
    				ref: "arg"
    			},
    			{
    				id: "s5ns82c",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "eb0nj9q",
    				ref: "arg",
    				value: "value"
    			}
    		],
    		edges: [
    			{
    				from: "usd4433",
    				to: "pd64cr8",
    				as: "otherwise"
    			},
    			{
    				from: "0tsqw11",
    				to: "pd64cr8",
    				as: "_"
    			},
    			{
    				from: "6rdgk5r",
    				to: "pd64cr8",
    				as: "value"
    			},
    			{
    				from: "4g0xgt3",
    				to: "usd4433",
    				as: "value"
    			},
    			{
    				from: "itmdest",
    				to: "usd4433",
    				as: "fn"
    			},
    			{
    				from: "s5ns82c",
    				to: "6rdgk5r",
    				as: "target"
    			},
    			{
    				from: "eb0nj9q",
    				to: "6rdgk5r",
    				as: "path"
    			}
    		]
    	},
    	{
    		id: "modify_state_runnable",
    		name: "modify_state_runnable",
    		"in": "0tke7mk",
    		out: "4k16rxs",
    		nodes: [
    			{
    				id: "4k16rxs",
    				ref: "runnable",
    				name: "out"
    			},
    			{
    				id: "17hgmhe",
    				ref: "dispatch_runnable"
    			},
    			{
    				id: "0tke7mk",
    				name: "in"
    			},
    			{
    				id: "qsm5fqf"
    			},
    			{
    				id: "6i1lek8",
    				ref: "runnable"
    			},
    			{
    				id: "ecixhbu",
    				ref: "arg",
    				value: "value"
    			},
    			{
    				id: "3d6xwzp",
    				ref: "arg",
    				value: "fn"
    			},
    			{
    				id: "ysv47a4",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "yl8sikb"
    			},
    			{
    				id: "4hrg1ky"
    			},
    			{
    				id: "ywscm67",
    				ref: "set"
    			},
    			{
    				id: "hsgqfec",
    				ref: "arg",
    				value: "value"
    			},
    			{
    				id: "a5z6wdp",
    				ref: "run"
    			},
    			{
    				id: "vjtdfop",
    				ref: "arg",
    				value: "payload.value"
    			},
    			{
    				id: "hej7g0o",
    				ref: "arg",
    				value: "payload.state_value"
    			},
    			{
    				id: "bohly2o",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "y65mfa8",
    				ref: "set"
    			},
    			{
    				id: "tmsibf6",
    				ref: "merge_objects"
    			},
    			{
    				id: "dkoqs5x",
    				value: "args"
    			},
    			{
    				id: "zmexk3x",
    				ref: "arg",
    				value: "fn"
    			},
    			{
    				id: "nl97w9x"
    			},
    			{
    				id: "oz8h5rr",
    				ref: "arg",
    				value: "fn.args"
    			},
    			{
    				id: "5g3mq34",
    				ref: "arg",
    				value: "dispatch"
    			},
    			{
    				id: "jdxnymc",
    				ref: "arg",
    				value: "payload"
    			},
    			{
    				id: "69fs5ao",
    				ref: "get"
    			},
    			{
    				id: "lsjg9ew",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "vc4ejyt",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "n3riawv",
    				ref: "arg",
    				value: "value"
    			}
    		],
    		edges: [
    			{
    				from: "17hgmhe",
    				to: "4k16rxs",
    				as: "fn"
    			},
    			{
    				from: "0tke7mk",
    				to: "4k16rxs",
    				as: "arg0"
    			},
    			{
    				from: "qsm5fqf",
    				to: "4k16rxs",
    				as: "args"
    			},
    			{
    				from: "6i1lek8",
    				to: "17hgmhe",
    				as: "fn"
    			},
    			{
    				from: "ecixhbu",
    				to: "qsm5fqf",
    				as: "value"
    			},
    			{
    				from: "3d6xwzp",
    				to: "qsm5fqf",
    				as: "fn"
    			},
    			{
    				from: "ysv47a4",
    				to: "qsm5fqf",
    				as: "state"
    			},
    			{
    				from: "yl8sikb",
    				to: "6i1lek8",
    				as: "fn"
    			},
    			{
    				from: "4hrg1ky",
    				to: "6i1lek8",
    				as: "args"
    			},
    			{
    				from: "ywscm67",
    				to: "yl8sikb",
    				as: "state"
    			},
    			{
    				from: "hsgqfec",
    				to: "4hrg1ky",
    				as: "value"
    			},
    			{
    				from: "a5z6wdp",
    				to: "4hrg1ky",
    				as: "state_value"
    			},
    			{
    				from: "vjtdfop",
    				to: "ywscm67",
    				as: "path"
    			},
    			{
    				from: "hej7g0o",
    				to: "ywscm67",
    				as: "value"
    			},
    			{
    				from: "bohly2o",
    				to: "ywscm67",
    				as: "target"
    			},
    			{
    				from: "y65mfa8",
    				to: "a5z6wdp",
    				as: "runnable"
    			},
    			{
    				from: "tmsibf6",
    				to: "y65mfa8",
    				as: "value"
    			},
    			{
    				from: "dkoqs5x",
    				to: "y65mfa8",
    				as: "path"
    			},
    			{
    				from: "zmexk3x",
    				to: "y65mfa8",
    				as: "target"
    			},
    			{
    				from: "nl97w9x",
    				to: "tmsibf6",
    				as: "arg0"
    			},
    			{
    				from: "oz8h5rr",
    				to: "tmsibf6",
    				as: "arg1"
    			},
    			{
    				from: "5g3mq34",
    				to: "nl97w9x",
    				as: "dispatch"
    			},
    			{
    				from: "jdxnymc",
    				to: "nl97w9x",
    				as: "payload"
    			},
    			{
    				from: "69fs5ao",
    				to: "nl97w9x",
    				as: "state_value"
    			},
    			{
    				from: "lsjg9ew",
    				to: "nl97w9x",
    				as: "state"
    			},
    			{
    				from: "vc4ejyt",
    				to: "69fs5ao",
    				as: "target"
    			},
    			{
    				from: "n3riawv",
    				to: "69fs5ao",
    				as: "path"
    			}
    		]
    	},
    	{
    		id: "object_entries",
    		name: "object_entries",
    		"in": "tkd4tqn",
    		out: "j8c79uf",
    		nodes: [
    			{
    				name: "out",
    				id: "j8c79uf",
    				ref: "filter"
    			},
    			{
    				id: "tkd4tqn",
    				name: "in"
    			},
    			{
    				id: "hfexsuu",
    				script: "return !key?.startsWith('_');"
    			},
    			{
    				id: "bgi2g37",
    				script: "return Object.entries(obj)"
    			},
    			{
    				id: "7gqcw0o",
    				ref: "arg",
    				value: "0.0"
    			},
    			{
    				id: "kpakw50",
    				ref: "arg",
    				value: "object"
    			}
    		],
    		edges: [
    			{
    				from: "tkd4tqn",
    				to: "j8c79uf",
    				as: "arr"
    			},
    			{
    				from: "hfexsuu",
    				to: "j8c79uf",
    				as: "fn",
    				type: "ref"
    			},
    			{
    				from: "bgi2g37",
    				to: "j8c79uf",
    				as: "arr"
    			},
    			{
    				from: "7gqcw0o",
    				to: "hfexsuu",
    				as: "key"
    			},
    			{
    				from: "kpakw50",
    				to: "bgi2g37",
    				as: "obj"
    			}
    		]
    	},
    	{
    		id: "css_styles",
    		name: "css_styles",
    		"in": "xw3pmx7",
    		out: "5yxmxua",
    		nodes: [
    			{
    				id: "5yxmxua",
    				ref: "html_element",
    				name: "out"
    			},
    			{
    				id: "vgv61zj",
    				ref: "html_text"
    			},
    			{
    				id: "jstjx7g"
    			},
    			{
    				id: "h40e3j9",
    				value: "style"
    			},
    			{
    				id: "xw3pmx7",
    				name: "in"
    			},
    			{
    				id: "jlgp7uy",
    				ref: "call"
    			},
    			{
    				id: "o1j78dd",
    				value: "result-view"
    			},
    			{
    				id: "ij4z84e",
    				ref: "map"
    			},
    			{
    				id: "q3pwj9j",
    				value: "join"
    			},
    			{
    				id: "d6h3gdw",
    				ref: "array"
    			},
    			{
    				id: "j8c79uf",
    				name: "object_entries",
    				ref: "object_entries"
    			},
    			{
    				id: "aelf1a7",
    				script: "return key + '{' + value + '}'"
    			},
    			{
    				id: "z63iaay",
    				script: "return \"\\n\";"
    			},
    			{
    				id: "vwsgweb",
    				ref: "default"
    			},
    			{
    				id: "5eqf77t",
    				value: "element.0",
    				ref: "arg"
    			},
    			{
    				id: "1hpnid4",
    				ref: "call"
    			},
    			{
    				id: "mkwx4yx"
    			},
    			{
    				id: "fzr4mkv",
    				ref: "arg",
    				value: "css_object"
    			},
    			{
    				id: "bbbp82v",
    				ref: "map"
    			},
    			{
    				id: "cp66ig5",
    				value: "join"
    			},
    			{
    				id: "uwq9u81",
    				ref: "array"
    			},
    			{
    				id: "i1ifamx",
    				ref: "object_entries"
    			},
    			{
    				id: "0d4yh8u",
    				script: "return key + ': ' + value + \";\";"
    			},
    			{
    				id: "gth1wc2",
    				script: "return \"\\n\";"
    			},
    			{
    				id: "y25dg2n",
    				value: "element.1",
    				ref: "arg"
    			},
    			{
    				id: "h13a9fd",
    				ref: "arg",
    				value: "element.0"
    			},
    			{
    				id: "h7me3v8",
    				ref: "arg",
    				value: "element.1"
    			}
    		],
    		edges: [
    			{
    				from: "vgv61zj",
    				to: "5yxmxua",
    				as: "children"
    			},
    			{
    				from: "jstjx7g",
    				to: "5yxmxua",
    				as: "props"
    			},
    			{
    				from: "h40e3j9",
    				to: "5yxmxua",
    				as: "dom_type"
    			},
    			{
    				from: "xw3pmx7",
    				to: "5yxmxua",
    				as: "arg3"
    			},
    			{
    				from: "jlgp7uy",
    				to: "vgv61zj",
    				as: "text"
    			},
    			{
    				from: "o1j78dd",
    				to: "jstjx7g",
    				as: "key"
    			},
    			{
    				from: "ij4z84e",
    				to: "jlgp7uy",
    				as: "self"
    			},
    			{
    				from: "q3pwj9j",
    				to: "jlgp7uy",
    				as: "fn"
    			},
    			{
    				from: "d6h3gdw",
    				to: "jlgp7uy",
    				as: "args"
    			},
    			{
    				from: "j8c79uf",
    				to: "ij4z84e",
    				as: "array"
    			},
    			{
    				from: "aelf1a7",
    				to: "ij4z84e",
    				as: "fn",
    				type: "ref"
    			},
    			{
    				from: "z63iaay",
    				to: "d6h3gdw",
    				as: "arg0"
    			},
    			{
    				from: "vwsgweb",
    				to: "j8c79uf",
    				as: "object"
    			},
    			{
    				from: "5eqf77t",
    				to: "aelf1a7",
    				as: "key"
    			},
    			{
    				from: "1hpnid4",
    				to: "aelf1a7",
    				as: "value"
    			},
    			{
    				from: "mkwx4yx",
    				to: "vwsgweb",
    				as: "otherwise"
    			},
    			{
    				from: "fzr4mkv",
    				to: "vwsgweb",
    				as: "value"
    			},
    			{
    				from: "bbbp82v",
    				to: "1hpnid4",
    				as: "self"
    			},
    			{
    				from: "cp66ig5",
    				to: "1hpnid4",
    				as: "fn"
    			},
    			{
    				from: "uwq9u81",
    				to: "1hpnid4",
    				as: "args"
    			},
    			{
    				from: "i1ifamx",
    				to: "bbbp82v",
    				as: "array"
    			},
    			{
    				from: "0d4yh8u",
    				to: "bbbp82v",
    				as: "fn",
    				type: "ref"
    			},
    			{
    				from: "gth1wc2",
    				to: "uwq9u81",
    				as: "arg0"
    			},
    			{
    				from: "y25dg2n",
    				to: "i1ifamx",
    				as: "object"
    			},
    			{
    				from: "h13a9fd",
    				to: "0d4yh8u",
    				as: "key"
    			},
    			{
    				from: "h7me3v8",
    				to: "0d4yh8u",
    				as: "value"
    			}
    		]
    	},
    	{
    		id: "set_display",
    		name: "set_display",
    		description: "Use like an html_element to add html to the page.",
    		"in": "fkp4pck/wb73q0h",
    		out: "a59hci8",
    		nodes: [
    			{
    				name: "out",
    				id: "a59hci8",
    				ref: "sequence"
    			},
    			{
    				id: "da71z9c/2435ihf/jd1mc84",
    				name: "modify_state_runnable",
    				ref: "modify_state_runnable"
    			},
    			{
    				id: "fkp4pck/wb73q0h",
    				name: "in"
    			},
    			{
    				id: "da71z9c/2435ihf/jd1mc84/a59hci8/da71z9c/2435ihf/y4qbl8k",
    				value: "result_display"
    			},
    			{
    				id: "da71z9c/2435ihf/jd1mc84/a59hci8/da71z9c/2435ihf/lol0vdh",
    				ref: "runnable"
    			},
    			{
    				id: "da71z9c/2435ihf/jd1mc84/a59hci8/da71z9c/2435ihf/w8vpdfx",
    				ref: "html_element"
    			},
    			{
    				id: "da71z9c/2435ihf/jd1mc84/a59hci8/da71z9c/2435ihf/vofecaa",
    				ref: "arg",
    				value: "props"
    			},
    			{
    				id: "da71z9c/2435ihf/jd1mc84/a59hci8/da71z9c/2435ihf/j8qudts",
    				ref: "arg",
    				value: "children"
    			},
    			{
    				id: "da71z9c/2435ihf/jd1mc84/a59hci8/da71z9c/2435ihf/iead5y3",
    				ref: "arg",
    				value: "dom_type"
    			}
    		],
    		edges: [
    			{
    				from: "da71z9c/2435ihf/jd1mc84",
    				to: "a59hci8",
    				as: "arg0"
    			},
    			{
    				to: "a59hci8",
    				from: "fkp4pck/wb73q0h",
    				as: "arg1"
    			},
    			{
    				from: "da71z9c/2435ihf/jd1mc84/a59hci8/da71z9c/2435ihf/y4qbl8k",
    				to: "da71z9c/2435ihf/jd1mc84",
    				as: "value"
    			},
    			{
    				from: "da71z9c/2435ihf/jd1mc84/a59hci8/da71z9c/2435ihf/lol0vdh",
    				to: "da71z9c/2435ihf/jd1mc84",
    				as: "fn"
    			},
    			{
    				from: "da71z9c/2435ihf/jd1mc84/a59hci8/da71z9c/2435ihf/w8vpdfx",
    				to: "da71z9c/2435ihf/jd1mc84/a59hci8/da71z9c/2435ihf/lol0vdh",
    				as: "fn"
    			},
    			{
    				from: "da71z9c/2435ihf/jd1mc84/a59hci8/da71z9c/2435ihf/vofecaa",
    				to: "da71z9c/2435ihf/jd1mc84/a59hci8/da71z9c/2435ihf/w8vpdfx",
    				as: "props"
    			},
    			{
    				from: "da71z9c/2435ihf/jd1mc84/a59hci8/da71z9c/2435ihf/j8qudts",
    				to: "da71z9c/2435ihf/jd1mc84/a59hci8/da71z9c/2435ihf/w8vpdfx",
    				as: "children"
    			},
    			{
    				from: "da71z9c/2435ihf/jd1mc84/a59hci8/da71z9c/2435ihf/iead5y3",
    				to: "da71z9c/2435ihf/jd1mc84/a59hci8/da71z9c/2435ihf/w8vpdfx",
    				as: "dom_type"
    			}
    		]
    	},
    	{
    		id: "input",
    		name: "input",
    		"in": "7rhq0q5",
    		out: "nn4twx9",
    		nodes: [
    			{
    				id: "nn4twx9",
    				ref: "html_element",
    				inputs: [
    					{
    						from: "bw4iez5/gvkhkfw",
    						to: "bw4iez5/nn4twx9",
    						as: "children"
    					},
    					{
    						from: "bw4iez5/7rhq0q5",
    						to: "bw4iez5/nn4twx9",
    						as: "props"
    					}
    				],
    				name: "out"
    			},
    			{
    				id: "gvkhkfw",
    				ref: "array"
    			},
    			{
    				id: "7rhq0q5",
    				name: "in"
    			},
    			{
    				id: "4972gx3",
    				ref: "html_element"
    			},
    			{
    				id: "1ldhfah",
    				ref: "html_element",
    				name: "label"
    			},
    			{
    				id: "ee5i5r2",
    				value: "input"
    			},
    			{
    				id: "ro8n2gc",
    				ref: "merge_objects"
    			},
    			{
    				id: "wet0jdv",
    				ref: "array"
    			},
    			{
    				id: "gcuxiw9"
    			},
    			{
    				id: "875c1wk",
    				value: "label"
    			},
    			{
    				id: "t6q6rvf"
    			},
    			{
    				id: "rjwtb3c",
    				ref: "default"
    			},
    			{
    				id: "utkc9o6",
    				ref: "html_text"
    			},
    			{
    				id: "jxl9r29",
    				script: "return \"input-\" + value;"
    			},
    			{
    				id: "2zxw9oo",
    				ref: "execute_graph",
    				name: "stop_propagation"
    			},
    			{
    				id: "i7y9dyy",
    				script: "return (state, payload) => [{...state, [value]: payload.target.value}, onchange_fn && [_ => dispatch(onchange_fn)]]"
    			},
    			{
    				id: "vks4vul",
    				ref: "arg",
    				value: "props"
    			},
    			{
    				id: "ddfgy2s"
    			},
    			{
    				id: "trd8ptp",
    				ref: "arg",
    				value: "value"
    			},
    			{
    				id: "zfrrk0z",
    				ref: "arg",
    				value: "value"
    			},
    			{
    				id: "qseh2tb",
    				ref: "array"
    			},
    			{
    				id: "b0j8nyq",
    				ref: "arg",
    				value: "dispatch"
    			},
    			{
    				id: "eotod0l",
    				ref: "sequence"
    			},
    			{
    				id: "qxwvdfe",
    				ref: "arg",
    				value: "value"
    			},
    			{
    				id: "0dnqo5l",
    				ref: "arg",
    				value: "onchange_fn"
    			},
    			{
    				id: "1wps21n",
    				name: "stop propagation effect",
    				out: "hj2cig0",
    				nodes: [
    					{
    						id: "hj2cig0",
    						ref: "array",
    						name: "stop propagation effect"
    					},
    					{
    						id: "1pvaim9",
    						ref: "execute_graph"
    					},
    					{
    						id: "0o86xp3",
    						ref: "arg",
    						value: "1"
    					},
    					{
    						id: "d60jwms",
    						script: "payload.stopPropagation();"
    					},
    					{
    						id: "xgbubrq",
    						ref: "arg",
    						value: "1"
    					}
    				],
    				edges: [
    					{
    						from: "1pvaim9",
    						to: "hj2cig0",
    						as: "a0"
    					},
    					{
    						from: "0o86xp3",
    						to: "hj2cig0",
    						as: "a1"
    					},
    					{
    						from: "d60jwms",
    						to: "1pvaim9",
    						as: "fn",
    						type: "ref"
    					},
    					{
    						from: "xgbubrq",
    						to: "d60jwms",
    						as: "payload"
    					}
    				]
    			},
    			{
    				id: "y5q7mbn",
    				ref: "arg",
    				value: "0"
    			},
    			{
    				id: "qjc0zt6",
    				ref: "modify_state_runnable"
    			},
    			{
    				id: "widk6u6",
    				ref: "runnable"
    			},
    			{
    				id: "506ntvb",
    				ref: "arg",
    				value: "value"
    			},
    			{
    				id: "4ck1vaf",
    				ref: "arg",
    				value: "payload.target.value"
    			}
    		],
    		edges: [
    			{
    				from: "gvkhkfw",
    				to: "nn4twx9",
    				as: "children"
    			},
    			{
    				from: "7rhq0q5",
    				to: "nn4twx9",
    				as: "_"
    			},
    			{
    				from: "4972gx3",
    				to: "gvkhkfw",
    				as: "arg1"
    			},
    			{
    				from: "1ldhfah",
    				to: "gvkhkfw",
    				as: "arg0"
    			},
    			{
    				from: "ee5i5r2",
    				to: "4972gx3",
    				as: "dom_type"
    			},
    			{
    				from: "ro8n2gc",
    				to: "4972gx3",
    				as: "props"
    			},
    			{
    				from: "wet0jdv",
    				to: "1ldhfah",
    				as: "children"
    			},
    			{
    				from: "gcuxiw9",
    				to: "1ldhfah",
    				as: "props"
    			},
    			{
    				from: "875c1wk",
    				to: "1ldhfah",
    				as: "dom_type"
    			},
    			{
    				from: "t6q6rvf",
    				to: "ro8n2gc",
    				as: "arg0"
    			},
    			{
    				from: "rjwtb3c",
    				to: "ro8n2gc",
    				as: "props"
    			},
    			{
    				from: "utkc9o6",
    				to: "wet0jdv",
    				as: "arg0"
    			},
    			{
    				from: "jxl9r29",
    				to: "gcuxiw9",
    				as: "for"
    			},
    			{
    				from: "2zxw9oo",
    				to: "t6q6rvf",
    				as: "onkeydown"
    			},
    			{
    				from: "i7y9dyy",
    				to: "t6q6rvf",
    				as: "onchange"
    			},
    			{
    				from: "vks4vul",
    				to: "rjwtb3c",
    				as: "value"
    			},
    			{
    				from: "ddfgy2s",
    				to: "rjwtb3c",
    				as: "otherwise"
    			},
    			{
    				from: "trd8ptp",
    				to: "utkc9o6",
    				as: "text"
    			},
    			{
    				from: "zfrrk0z",
    				to: "jxl9r29",
    				as: "value"
    			},
    			{
    				to: "2zxw9oo",
    				from: "qseh2tb",
    				as: "fn",
    				type: "ref"
    			},
    			{
    				from: "b0j8nyq",
    				to: "i7y9dyy",
    				as: "dispatch"
    			},
    			{
    				from: "eotod0l",
    				to: "i7y9dyy",
    				as: "seq"
    			},
    			{
    				from: "qxwvdfe",
    				to: "i7y9dyy",
    				as: "value"
    			},
    			{
    				from: "0dnqo5l",
    				to: "i7y9dyy",
    				as: "onchange_fn"
    			},
    			{
    				from: "1wps21n",
    				to: "qseh2tb",
    				as: "a1"
    			},
    			{
    				from: "y5q7mbn",
    				to: "qseh2tb",
    				as: "a0"
    			},
    			{
    				from: "qjc0zt6",
    				to: "eotod0l",
    				as: "arg"
    			},
    			{
    				from: "widk6u6",
    				to: "qjc0zt6",
    				as: "fn"
    			},
    			{
    				from: "506ntvb",
    				to: "qjc0zt6",
    				as: "value"
    			},
    			{
    				from: "4ck1vaf",
    				to: "widk6u6",
    				as: "fn"
    			}
    		]
    	},
    	{
    		id: "html_text",
    		description: "Some HTML plaintext. Usually used as a child of html_element.",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "text",
    				ref: "arg",
    				value: "text"
    			},
    			{
    				id: "text_value",
    				value: "text_value"
    			},
    			{
    				id: "out"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "_",
    				type: "ref"
    			},
    			{
    				from: "text_value",
    				to: "out",
    				as: "dom_type"
    			},
    			{
    				from: "text",
    				to: "out",
    				as: "text"
    			}
    		]
    	},
    	{
    		id: "html_element",
    		description: "An HTML Element. `children` is an array of html_element or html_text, `props` are the attributes for the html element as an object.",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "children",
    				ref: "arg",
    				value: "children"
    			},
    			{
    				id: "props",
    				ref: "arg",
    				value: "props"
    			},
    			{
    				id: "dom_type",
    				ref: "arg",
    				value: "dom_type"
    			},
    			{
    				id: "div",
    				value: "div"
    			},
    			{
    				id: "fill_children",
    				script: "return children === undefined ? [] : children.length !== undefined ? children.filter(c => !!c).map(c => c.el ?? c) : [children.el ?? children]"
    			},
    			{
    				id: "fill_props",
    				script: "return props ?? {}"
    			},
    			{
    				id: "dom_type_def",
    				ref: "default"
    			},
    			{
    				id: "out",
    				script: "if(!(typeof dom_type === 'string' && Array.isArray(children))){ throw new Error('invalid element');} children.filter(c => c).forEach(c => {if(typeof c.dom_type !== 'string'){throw new Error ('invalid child element');}}); return {el: {dom_type, props, children}}"
    			}
    		],
    		edges: [
    			{
    				from: "children",
    				to: "fill_children",
    				as: "children"
    			},
    			{
    				from: "props",
    				to: "fill_props",
    				as: "props",
    				type: "resolve"
    			},
    			{
    				from: "fill_children",
    				to: "out",
    				as: "children",
    				type: "resolve"
    			},
    			{
    				from: "fill_props",
    				to: "out",
    				as: "props"
    			},
    			{
    				from: "dom_type",
    				to: "dom_type_def",
    				as: "value"
    			},
    			{
    				from: "div",
    				to: "dom_type_def",
    				as: "otherwise"
    			},
    			{
    				from: "dom_type_def",
    				to: "out",
    				as: "dom_type"
    			},
    			{
    				from: "in",
    				to: "out",
    				as: "args",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "icon",
    		name: "icon",
    		out: "c2sko9c",
    		nodes: [
    			{
    				id: "c2sko9c",
    				ref: "html_element",
    				name: "ionicon"
    			},
    			{
    				id: "2lr3ihi",
    				value: "ion-icon"
    			},
    			{
    				id: "empty_obj",
    				value: {
    				}
    			},
    			{
    				id: "props",
    				ref: "arg",
    				value: "props"
    			},
    			{
    				id: "defined_props",
    				ref: "if"
    			},
    			{
    				id: "name_path",
    				value: "name"
    			},
    			{
    				id: "a0jb5es",
    				ref: "set"
    			},
    			{
    				id: "s5x2r1f",
    				ref: "arg",
    				value: "icon"
    			}
    		],
    		edges: [
    			{
    				from: "2lr3ihi",
    				to: "c2sko9c",
    				as: "dom_type"
    			},
    			{
    				from: "props",
    				to: "defined_props",
    				as: "true"
    			},
    			{
    				from: "props",
    				to: "defined_props",
    				as: "pred"
    			},
    			{
    				from: "empty_obj",
    				to: "defined_props",
    				as: "false"
    			},
    			{
    				from: "defined_props",
    				to: "a0jb5es",
    				as: "target"
    			},
    			{
    				from: "name_path",
    				to: "a0jb5es",
    				as: "path"
    			},
    			{
    				from: "a0jb5es",
    				to: "c2sko9c",
    				as: "props"
    			},
    			{
    				from: "s5x2r1f",
    				to: "a0jb5es",
    				as: "value"
    			}
    		]
    	},
    	{
    		id: "add_circle_icon",
    		out: "out",
    		nodes: [
    			{
    				id: "in_props",
    				ref: "arg",
    				value: "props"
    			},
    			{
    				id: "viewbox_props",
    				value: {
    					viewBox: "0 0 512 512"
    				}
    			},
    			{
    				id: "props",
    				ref: "merge_objects"
    			},
    			{
    				id: "svg",
    				value: "svg"
    			},
    			{
    				id: "path",
    				value: "path"
    			},
    			{
    				id: "add_props",
    				value: {
    					d: "M256 176v160M336 256H176",
    					"class": "add"
    				}
    			},
    			{
    				id: "add",
    				ref: "html_element"
    			},
    			{
    				id: "circle_props",
    				value: {
    					d: "M448 256c0-106-86-192-192-192S64 150 64 256s86 192 192 192 192-86 192-192z",
    					"class": "circle"
    				}
    			},
    			{
    				id: "circle",
    				ref: "html_element"
    			},
    			{
    				id: "children",
    				ref: "array"
    			},
    			{
    				id: "out",
    				ref: "html_element"
    			}
    		],
    		edges: [
    			{
    				from: "add_props",
    				to: "add",
    				as: "props"
    			},
    			{
    				from: "circle_props",
    				to: "circle",
    				as: "props"
    			},
    			{
    				from: "add",
    				to: "children",
    				as: "a1"
    			},
    			{
    				from: "circle",
    				to: "children",
    				as: "a0"
    			},
    			{
    				from: "path",
    				to: "add",
    				as: "dom_type"
    			},
    			{
    				from: "path",
    				to: "circle",
    				as: "dom_type"
    			},
    			{
    				from: "svg",
    				to: "out",
    				as: "dom_type"
    			},
    			{
    				from: "children",
    				to: "out",
    				as: "children"
    			},
    			{
    				from: "in_props",
    				to: "props",
    				as: "o1"
    			},
    			{
    				from: "viewbox_props",
    				to: "props",
    				as: "o2"
    			},
    			{
    				from: "props",
    				to: "out",
    				as: "props"
    			}
    		]
    	},
    	{
    		id: "run_h",
    		"in": "in",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "dom_type",
    				ref: "arg",
    				value: "dom_type"
    			},
    			{
    				id: "props",
    				ref: "arg",
    				value: "props"
    			},
    			{
    				id: "children",
    				ref: "arg",
    				value: "children"
    			},
    			{
    				id: "graph",
    				ref: "arg",
    				value: "graph"
    			},
    			{
    				id: "text",
    				ref: "arg",
    				value: "text"
    			},
    			{
    				id: "mapped_children",
    				script: "let run_graph = {...graph, in: 'run_h/in', out: 'run_h'}; const fn = _lib.no.executeGraphValue({graph: run_graph}); return (children?.filter(c => !!c) ?? []).map(c => ({...c, graph: run_graph})).map(fn).filter(c => c).map(c => c.el ?? c);"
    			},
    			{
    				id: "out_h",
    				extern: "ha.h"
    			},
    			{
    				id: "out_text",
    				extern: "ha.text"
    			},
    			{
    				id: "els"
    			},
    			{
    				id: "out_input",
    				args: [
    					"dom_type"
    				],
    				script: "return dom_type === 'text_value' ? 'h_text' : 'h'"
    			},
    			{
    				id: "out_el",
    				ref: "switch"
    			},
    			{
    				id: "out"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "_",
    				type: "ref"
    			},
    			{
    				from: "dom_type",
    				to: "out_input",
    				as: "dom_type"
    			},
    			{
    				from: "dom_type",
    				to: "out_h",
    				as: "dom_type"
    			},
    			{
    				from: "children",
    				to: "mapped_children",
    				as: "children"
    			},
    			{
    				from: "mapped_children",
    				to: "out_h",
    				as: "children"
    			},
    			{
    				from: "props",
    				to: "out_h",
    				as: "props"
    			},
    			{
    				from: "graph",
    				to: "mapped_children",
    				as: "graph"
    			},
    			{
    				from: "text",
    				to: "out_text",
    				as: "text",
    				type: "resolve"
    			},
    			{
    				from: "out_text",
    				to: "out_el",
    				as: "h_text"
    			},
    			{
    				from: "out_h",
    				to: "out_el",
    				as: "h"
    			},
    			{
    				from: "out_input",
    				to: "out_el",
    				as: "input"
    			},
    			{
    				from: "out_el",
    				to: "out",
    				as: "el",
    				type: "resolve"
    			}
    		]
    	},
    	{
    		id: "expand_contract",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "node_id",
    				ref: "arg",
    				value: "node_id"
    			},
    			{
    				id: "display_graph",
    				ref: "arg",
    				value: "display_graph"
    			},
    			{
    				id: "display_graph_out",
    				ref: "arg",
    				value: "display_graph_out"
    			},
    			{
    				id: "selected_node",
    				script: "return display_graph.nodes.find(n => n.id === selected)"
    			},
    			{
    				id: "expand_contract_result_inputs",
    				script: "return expandable ? 'expand' : contractable ? 'contract' : undefined"
    			},
    			{
    				id: "selected",
    				script: "return [contract] ?? [expand]"
    			},
    			{
    				id: "expand_contract_result",
    				ref: "switch"
    			},
    			{
    				id: "get_name",
    				script: "return node.name"
    			},
    			{
    				id: "expandable_id",
    				script: "return node.id ? node.id + '/' + out : undefined"
    			},
    			{
    				id: "contractable_id",
    				script: "node_id = name ?? node_id; return !node_id ? undefined : node_id.endsWith('/out') ? node_id.substring(0, node_id.lastIndexOf('/')) : node_id.lastIndexOf('/') >= 0 ? node_id.substring(0, node_id.lastIndexOf('/')) : node_id"
    			},
    			{
    				id: "expand",
    				script: "return display_graph && node_id ? _lib.scripts.expand_node({display_graph, node_id}) : []"
    			},
    			{
    				id: "contract",
    				script: "return display_graph && node_id ? _lib.scripts.contract_node({display_graph, node_id, name, node_name}) : []"
    			},
    			{
    				id: "has_nodes",
    				script: "return !!display_graph.nodes.find(n => n.id === node_id).nodes"
    			},
    			{
    				id: "is_contractable",
    				script: "return !has_nodes"
    			},
    			{
    				id: "out",
    				ref: "default"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args",
    				type: "ref"
    			},
    			{
    				from: "node_id",
    				to: "selected_node",
    				as: "selected"
    			},
    			{
    				from: "display_graph",
    				to: "selected_node",
    				as: "display_graph"
    			},
    			{
    				from: "display_graph",
    				to: "has_nodes",
    				as: "display_graph"
    			},
    			{
    				from: "node_id",
    				to: "has_nodes",
    				as: "node_id"
    			},
    			{
    				from: "display_graph",
    				to: "contract",
    				as: "display_graph"
    			},
    			{
    				from: "node_id",
    				to: "contract",
    				as: "node_id"
    			},
    			{
    				from: "node_id",
    				to: "expand",
    				as: "node_id"
    			},
    			{
    				from: "display_graph",
    				to: "expand",
    				as: "display_graph"
    			},
    			{
    				from: "has_nodes",
    				to: "is_contractable",
    				as: "has_nodes"
    			},
    			{
    				from: "selected_node",
    				to: "get_name",
    				as: "node"
    			},
    			{
    				from: "selected_node",
    				to: "expandable_id",
    				as: "node"
    			},
    			{
    				from: "display_graph_out",
    				to: "expandable_id",
    				as: "out"
    			},
    			{
    				from: "selected_node",
    				to: "contract",
    				as: "node"
    			},
    			{
    				from: "get_name",
    				to: "contract",
    				as: "node_name"
    			},
    			{
    				from: "contractable_id",
    				to: "contract",
    				as: "name"
    			},
    			{
    				from: "get_name",
    				to: "is_contractable",
    				as: "name"
    			},
    			{
    				from: "node_id",
    				to: "contractable_id",
    				as: "node_id"
    			},
    			{
    				from: "get_name",
    				to: "contractable_id",
    				as: "name"
    			},
    			{
    				from: "contractable_id",
    				to: "selected",
    				as: "contract"
    			},
    			{
    				from: "expandable_id",
    				to: "selected",
    				as: "expand"
    			},
    			{
    				from: "has_nodes",
    				to: "expand_contract_result_inputs",
    				as: "expandable"
    			},
    			{
    				from: "is_contractable",
    				to: "expand_contract_result_inputs",
    				as: "contractable"
    			},
    			{
    				from: "expand_contract_result_inputs",
    				to: "selected",
    				as: "input"
    			},
    			{
    				from: "expand_contract_result_inputs",
    				to: "expand_contract_result",
    				as: "input"
    			},
    			{
    				from: "selected",
    				to: "expand_contract_result",
    				as: "selected"
    			},
    			{
    				from: "expand",
    				to: "expand_contract_result",
    				as: "expand"
    			},
    			{
    				from: "contract",
    				to: "expand_contract_result",
    				as: "contract"
    			},
    			{
    				from: "expand_contract_result",
    				to: "out",
    				as: "value"
    			},
    			{
    				from: "in",
    				to: "out",
    				as: "otherwise"
    			}
    		]
    	},
    	{
    		id: "default_node_display",
    		name: "default_node_display",
    		"in": "6pqqchhnk",
    		out: "tsxlng4gd",
    		nodes: [
    			{
    				id: "tsxlng4gd",
    				ref: "html_element",
    				name: "default_node_display"
    			},
    			{
    				id: "osgrk7ddu",
    				args: [
    				],
    				ref: "html_text"
    			},
    			{
    				id: "hghirvcml",
    				args: [
    				],
    				value: "pre"
    			},
    			{
    				id: "ha6b5qttf",
    				args: [
    					"data"
    				],
    				script: "return JSON.stringify({node: data.node, result: data.result}, null, 2)"
    			},
    			{
    				id: "6pqqchhnk",
    				name: "default_node_display/in"
    			}
    		],
    		edges: [
    			{
    				from: "osgrk7ddu",
    				to: "tsxlng4gd",
    				as: "children"
    			},
    			{
    				from: "hghirvcml",
    				to: "tsxlng4gd",
    				as: "dom_type"
    			},
    			{
    				from: "ha6b5qttf",
    				to: "osgrk7ddu",
    				as: "text"
    			},
    			{
    				from: "6pqqchhnk",
    				to: "ha6b5qttf",
    				as: "data"
    			}
    		]
    	},
    	{
    		id: "graph_display",
    		name: "graph_display",
    		"in": "in",
    		out: "out",
    		nodes: [
    			{
    				id: "out",
    				ref: "html_element",
    				name: "graph_display"
    			},
    			{
    				id: "ml655hs73",
    				args: [
    				],
    				value: "pre"
    			},
    			{
    				id: "thsez3hy1",
    				args: [
    				],
    				ref: "html_text"
    			},
    			{
    				id: "stringify",
    				args: [
    					"data"
    				],
    				script: "return JSON.stringify({...data.node, nodes: data.node.nodes.length, edges:data.node.edges.length, result: data.result}, null, 2)"
    			},
    			{
    				id: "in"
    			}
    		],
    		edges: [
    			{
    				from: "ml655hs73",
    				to: "out",
    				as: "dom_type"
    			},
    			{
    				from: "thsez3hy1",
    				to: "out",
    				as: "children"
    			},
    			{
    				from: "stringify",
    				to: "thsez3hy1",
    				as: "text"
    			},
    			{
    				from: "in",
    				to: "stringify",
    				as: "data"
    			},
    			{
    				from: "in",
    				to: "stringify",
    				as: "data"
    			}
    		]
    	},
    	{
    		id: "number_display",
    		name: "number_display",
    		"in": "6pqqchhnk",
    		out: "tsxlng4gd",
    		nodes: [
    			{
    				id: "tsxlng4gd",
    				args: [
    				],
    				ref: "html_element",
    				name: "number_display"
    			},
    			{
    				id: "hghirvcml",
    				args: [
    				],
    				value: "input"
    			},
    			{
    				id: "cd571vftv"
    			},
    			{
    				id: "h5xzkeoql",
    				args: [
    				],
    				value: {
    					ref: "number"
    				}
    			},
    			{
    				id: "ltncqmqe9",
    				args: [
    				],
    				ref: "get"
    			},
    			{
    				id: "9kkegcpi2",
    				args: [
    				],
    				ref: "execute_graph"
    			},
    			{
    				id: "e96vv0gpq",
    				args: [
    				],
    				value: "node.value"
    			},
    			{
    				id: "tw41k3wzg",
    				args: [
    				],
    				ref: "get"
    			},
    			{
    				id: "u9feks2l9",
    				args: [
    				],
    				ref: "update_graph_display"
    			},
    			{
    				id: "6pqqchhnk",
    				args: [
    				],
    				name: "number_display/in"
    			},
    			{
    				id: "yxaspmy5c",
    				args: [
    				],
    				value: "graph"
    			},
    			{
    				id: "rhzddw3c6",
    				args: [
    				],
    				ref: "set"
    			},
    			{
    				id: "8jmaa71ct",
    				args: [
    				],
    				script: "return arg0 !== arg1;"
    			},
    			{
    				id: "w5lqhh9qr",
    				args: [
    				],
    				value: "value"
    			},
    			{
    				id: "es0e6as0j",
    				args: [
    				],
    				ref: "get",
    				name: "get target value"
    			},
    			{
    				id: "vnta2m4py",
    				args: [
    				],
    				ref: "get"
    			},
    			{
    				id: "gh99zvhy2",
    				args: [
    				],
    				value: "1.target.valueAsNumber",
    				name: "target valueasnum"
    			},
    			{
    				id: "88f3s3qrq",
    				args: [
    				],
    				value: "value"
    			},
    			{
    				id: "fxbdw1jrr",
    				args: [
    				],
    				ref: "selected_node"
    			},
    			{
    				id: "pkih97fsa",
    				args: [
    				],
    				ref: "get",
    				name: "state"
    			},
    			{
    				id: "mbbx3d26q",
    				args: [
    				]
    			},
    			{
    				id: "vbwsmt7jt",
    				args: [
    				],
    				value: 0
    			}
    		],
    		edges: [
    			{
    				from: "hghirvcml",
    				to: "tsxlng4gd",
    				as: "dom_type"
    			},
    			{
    				from: "cd571vftv",
    				to: "tsxlng4gd",
    				as: "props"
    			},
    			{
    				from: "h5xzkeoql",
    				to: "cd571vftv"
    			},
    			{
    				from: "ltncqmqe9",
    				to: "cd571vftv",
    				as: "value"
    			},
    			{
    				from: "9kkegcpi2",
    				to: "cd571vftv",
    				as: "oninput"
    			},
    			{
    				from: "e96vv0gpq",
    				to: "ltncqmqe9",
    				as: "path"
    			},
    			{
    				from: "tw41k3wzg",
    				to: "9kkegcpi2",
    				as: "graph"
    			},
    			{
    				from: "u9feks2l9",
    				to: "9kkegcpi2",
    				as: "fn",
    				type: "ref"
    			},
    			{
    				from: "6pqqchhnk",
    				to: "ltncqmqe9",
    				as: "target"
    			},
    			{
    				from: "6pqqchhnk",
    				to: "tw41k3wzg",
    				as: "target"
    			},
    			{
    				from: "yxaspmy5c",
    				to: "tw41k3wzg",
    				as: "path"
    			},
    			{
    				from: "rhzddw3c6",
    				to: "u9feks2l9",
    				as: "node"
    			},
    			{
    				from: "8jmaa71ct",
    				to: "u9feks2l9",
    				as: "update_graph_display"
    			},
    			{
    				from: "w5lqhh9qr",
    				to: "rhzddw3c6",
    				as: "path"
    			},
    			{
    				from: "es0e6as0j",
    				to: "rhzddw3c6",
    				as: "value"
    			},
    			{
    				from: "vnta2m4py",
    				to: "8jmaa71ct",
    				as: "arg0"
    			},
    			{
    				from: "es0e6as0j",
    				to: "8jmaa71ct",
    				as: "arg1"
    			},
    			{
    				from: "gh99zvhy2",
    				to: "es0e6as0j",
    				as: "path"
    			},
    			{
    				from: "88f3s3qrq",
    				to: "vnta2m4py",
    				as: "path"
    			},
    			{
    				from: "fxbdw1jrr",
    				to: "rhzddw3c6",
    				as: "target"
    			},
    			{
    				from: "fxbdw1jrr",
    				to: "vnta2m4py",
    				as: "target"
    			},
    			{
    				from: "mbbx3d26q",
    				to: "pkih97fsa",
    				as: "target"
    			},
    			{
    				from: "mbbx3d26q",
    				to: "9kkegcpi2",
    				as: "in_node",
    				type: "ref"
    			},
    			{
    				from: "mbbx3d26q",
    				to: "es0e6as0j",
    				as: "target"
    			},
    			{
    				from: "pkih97fsa",
    				to: "u9feks2l9"
    			},
    			{
    				from: "pkih97fsa",
    				to: "fxbdw1jrr"
    			},
    			{
    				from: "vbwsmt7jt",
    				to: "pkih97fsa",
    				as: "path"
    			}
    		]
    	},
    	{
    		id: "default_error_display",
    		"in": "in",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "stringify",
    				args: [
    					"data"
    				],
    				script: "const e = data.error; return JSON.stringify({error: e instanceof AggregateError ? e.errors.map(e => e.toString()).join(\" \") : e.toString(), data}, null, 2)"
    			},
    			{
    				id: "text",
    				ref: "html_text"
    			},
    			{
    				id: "out_dom_type",
    				value: "pre"
    			},
    			{
    				id: "out",
    				ref: "html_element"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "stringify",
    				as: "data"
    			},
    			{
    				from: "stringify",
    				to: "text",
    				as: "text"
    			},
    			{
    				from: "text",
    				to: "out",
    				as: "children",
    				type: "resolve"
    			},
    			{
    				from: "out_dom_type",
    				to: "out",
    				as: "dom_type"
    			}
    		]
    	},
    	{
    		id: "not",
    		args: [
    			"target"
    		],
    		script: "return !target"
    	},
    	{
    		id: "data",
    		value: "data"
    	},
    	{
    		id: "graph",
    		value: "graph"
    	},
    	{
    		id: "display_graph",
    		value: "display_graph"
    	},
    	{
    		id: "nodes",
    		value: "nodes"
    	},
    	{
    		id: "readonly",
    		ref: "arg",
    		value: "readonly"
    	},
    	{
    		id: "norun",
    		ref: "arg",
    		value: "norun"
    	},
    	{
    		id: "hash",
    		ref: "arg",
    		value: "hash"
    	},
    	{
    		id: "static",
    		ref: "arg",
    		value: "static"
    	},
    	{
    		id: "hide_types",
    		ref: "arg",
    		value: "hide_types"
    	},
    	{
    		id: "graph_nodes",
    		value: [
    			[
    				"graph",
    				"nodes"
    			]
    		]
    	},
    	{
    		id: "initial_state",
    		value: {
    			nodes: [
    			],
    			links: [
    			],
    			editing: false,
    			search: false,
    			show_all: false,
    			show_result: false,
    			node_el_width: 256,
    			args_display: false,
    			imports: {
    			},
    			history: [
    			],
    			redo_history: [
    			]
    		}
    	},
    	{
    		id: "dimensions",
    		ref: "arg",
    		value: "dimensions"
    	},
    	{
    		id: "error_nodes",
    		script: "return new Map()"
    	},
    	{
    		id: "hyperapp_init_state"
    	},
    	{
    		id: "calculate_levels",
    		script: "return _lib.scripts.calculateLevels([], [], display_graph, selected)"
    	},
    	{
    		id: "get_graph",
    		ref: "arg",
    		value: "graph"
    	},
    	{
    		id: "get_display_graph",
    		ref: "arg",
    		value: "display_graph"
    	},
    	{
    		id: "display_graph_out",
    		ref: "arg",
    		value: "display_graph.out"
    	},
    	{
    		id: "init_selected",
    		ref: "array"
    	},
    	{
    		id: "hyperapp_view",
    		ref: "execute_graph"
    	},
    	{
    		id: "update_hyperapp",
    		ref: "update_graph_display"
    	},
    	{
    		id: "update_hyperapp_action",
    		ref: "hyperapp_action"
    	},
    	{
    		id: "update_hyperapp_effect",
    		ref: "hyperapp_action_effect"
    	},
    	{
    		id: "html_id",
    		ref: "arg",
    		value: "html_id"
    	},
    	{
    		id: "examples",
    		ref: "arg",
    		value: "examples"
    	},
    	{
    		id: "initialize_hyperapp_app",
    		ref: "hyperapp_app"
    	},
    	{
    		id: "out"
    	},
    	{
    		id: "nodes",
    		ref: "arg",
    		value: "nodes"
    	},
    	{
    		id: "links",
    		ref: "arg",
    		value: "links"
    	},
    	{
    		id: "graph_to_simulation",
    		args: [
    			"nodes",
    			"links",
    			"display_graph",
    			"selected",
    			"levels"
    		],
    		ref: "graph_to_sim_fn",
    		_script: "return _lib.scripts.graphToSimulationNodes({display_graph, nodes, links, selected, levels})"
    	},
    	{
    		id: "sim_to_hyperapp",
    		ref: "sim_to_hyperapp_action"
    	},
    	{
    		id: "sim_to_hyperapp_fn",
    		ref: "execute_graph"
    	},
    	{
    		id: "graph_to_sim_action",
    		ref: "execute_graph"
    	},
    	{
    		id: "update_nodes_in"
    	},
    	{
    		id: "onkey_fn",
    		ref: "hyperapp_action"
    	},
    	{
    		id: "eq",
    		script: "return a === b;"
    	},
    	{
    		id: "neq",
    		script: "return a !== b;"
    	},
    	{
    		id: "clear_popover_graph",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "popover_path",
    				value: "popover_graph"
    			},
    			{
    				id: "false",
    				value: false
    			},
    			{
    				id: "clear_popover",
    				ref: "set"
    			},
    			{
    				id: "new_state"
    			},
    			{
    				id: "popover_dispatch",
    				ref: "arg",
    				value: "state.popover_dispatch"
    			},
    			{
    				id: "clear_popover_hyperapp_effect",
    				script: "return [[(dispatch, payload) => { payload.dispatch(s => undefined); dispatch(s => ({...s, popover_dispatch: undefined}))}, {dispatch: popover_dispatch}]]"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "new_state",
    				as: "args"
    			},
    			{
    				from: "state",
    				to: "clear_popover",
    				as: "target"
    			},
    			{
    				from: "state",
    				to: "clear_popover_hyperapp_effect",
    				as: "state"
    			},
    			{
    				from: "popover_path",
    				to: "clear_popover",
    				as: "path"
    			},
    			{
    				from: "false",
    				to: "clear_popover",
    				as: "value"
    			},
    			{
    				from: "clear_popover",
    				to: "new_state",
    				as: "state"
    			},
    			{
    				from: "popover_dispatch",
    				to: "clear_popover_hyperapp_effect",
    				as: "popover_dispatch"
    			},
    			{
    				from: "clear_popover_hyperapp_effect",
    				to: "new_state",
    				as: "effects"
    			},
    			{
    				from: "new_state",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "show_popover_graph",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "popover_graph_path",
    				value: "popover_graph"
    			},
    			{
    				id: "graph",
    				ref: "arg",
    				value: "state.graph"
    			},
    			{
    				id: "selected",
    				ref: "arg",
    				value: "state.selected.0"
    			},
    			{
    				id: "html_id",
    				ref: "arg",
    				value: "state.html_id"
    			},
    			{
    				id: "dimensions",
    				ref: "arg",
    				value: "state.dimensions"
    			},
    			{
    				id: "popover_dispatch",
    				ref: "arg",
    				value: "state.popover_dispatch"
    			},
    			{
    				id: "set_popover_graph",
    				ref: "set"
    			},
    			{
    				id: "popover_graph_value",
    				ref: "arg",
    				value: "payload.popover_graph"
    			},
    			{
    				id: "render_popover_graph_effector",
    				ref: "render_popover_graph_effect"
    			},
    			{
    				id: "render_popover_graph_effect_payload"
    			},
    			{
    				id: "render_popover_graph_effect",
    				ref: "array"
    			},
    			{
    				id: "effects",
    				ref: "array"
    			},
    			{
    				id: "new_state"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "state",
    				to: "set_popover_graph",
    				as: "target"
    			},
    			{
    				from: "popover_graph_value",
    				to: "set_popover_graph",
    				as: "value"
    			},
    			{
    				from: "popover_graph_path",
    				to: "set_popover_graph",
    				as: "path"
    			},
    			{
    				from: "set_popover_graph",
    				to: "new_state",
    				as: "state"
    			},
    			{
    				from: "popover_graph_value",
    				to: "render_popover_graph_effect_payload",
    				as: "display_graph"
    			},
    			{
    				from: "graph",
    				to: "render_popover_graph_effect_payload",
    				as: "graph"
    			},
    			{
    				from: "html_id",
    				to: "render_popover_graph_effect_payload",
    				as: "html_id"
    			},
    			{
    				from: "dimensions",
    				to: "render_popover_graph_effect_payload",
    				as: "dimensions"
    			},
    			{
    				from: "popover_dispatch",
    				to: "render_popover_graph_effect_payload",
    				as: "popover_dispatch"
    			},
    			{
    				from: "render_popover_graph_effect_payload",
    				to: "render_popover_graph_effect",
    				as: "arg1"
    			},
    			{
    				from: "render_popover_graph_effector",
    				to: "render_popover_graph_effect",
    				as: "arg0"
    			},
    			{
    				from: "render_popover_graph_effect",
    				to: "effects",
    				as: "arg0"
    			},
    			{
    				from: "effects",
    				to: "new_state",
    				as: "effects"
    			},
    			{
    				from: "new_state",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "expand_contract_effect",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "display_graph_path",
    				value: "display_graph"
    			},
    			{
    				id: "selected_path",
    				value: "selected"
    			},
    			{
    				id: "node_id",
    				ref: "arg",
    				value: "payload.id"
    			},
    			{
    				id: "display_graph",
    				ref: "arg",
    				value: "state.display_graph"
    			},
    			{
    				id: "expand_contract",
    				ref: "expand_contract"
    			},
    			{
    				id: "expand_contract_display_graph",
    				ref: "get"
    			},
    			{
    				id: "expand_contract_selected",
    				ref: "get"
    			},
    			{
    				id: "set_display_graph",
    				ref: "set"
    			},
    			{
    				id: "set_selected",
    				ref: "set"
    			},
    			{
    				id: "update_sim_effector",
    				ref: "arg",
    				value: "state.update_sim_effect"
    			},
    			{
    				id: "update_sim_effect",
    				ref: "array"
    			},
    			{
    				id: "update_display_graph",
    				script: "return [() => _lib.no.runtime.update_graph(display_graph)]"
    			},
    			{
    				id: "effects",
    				ref: "array"
    			},
    			{
    				id: "return_value"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "state",
    				to: "set_display_graph",
    				as: "target"
    			},
    			{
    				from: "node_id",
    				to: "expand_contract",
    				as: "node_id"
    			},
    			{
    				from: "display_graph",
    				to: "expand_contract",
    				as: "display_graph"
    			},
    			{
    				from: "expand_contract",
    				to: "expand_contract_display_graph",
    				as: "target"
    			},
    			{
    				from: "display_graph_path",
    				to: "expand_contract_display_graph",
    				as: "path"
    			},
    			{
    				from: "expand_contract",
    				to: "expand_contract_selected",
    				as: "target"
    			},
    			{
    				from: "selected_path",
    				to: "expand_contract_selected",
    				as: "path"
    			},
    			{
    				from: "expand_contract_selected",
    				to: "set_selected",
    				as: "value"
    			},
    			{
    				from: "selected_path",
    				to: "set_selected",
    				as: "path"
    			},
    			{
    				from: "state",
    				to: "set_selected",
    				as: "target"
    			},
    			{
    				from: "update_sim_effector",
    				to: "update_sim_effect",
    				as: "a0"
    			},
    			{
    				from: "set_selected",
    				to: "update_sim_effect",
    				as: "a1"
    			},
    			{
    				from: "update_sim_effect",
    				to: "effects",
    				as: "a1"
    			},
    			{
    				from: "expand_contract_display_graph",
    				to: "update_display_graph",
    				as: "display_graph"
    			},
    			{
    				from: "update_display_graph",
    				to: "effects",
    				as: "a0"
    			},
    			{
    				from: "set_selected",
    				to: "return_value",
    				as: "state"
    			},
    			{
    				from: "effects",
    				to: "return_value",
    				as: "effects"
    			},
    			{
    				from: "return_value",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "delete_node_action",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "nodes",
    				ref: "arg",
    				value: "state.display_graph.nodes"
    			},
    			{
    				id: "edges",
    				ref: "arg",
    				value: "state.display_graph.edges"
    			},
    			{
    				id: "update_sim_effect",
    				ref: "arg",
    				value: "state.update_sim_effect"
    			},
    			{
    				id: "display_graph_out",
    				ref: "arg",
    				value: "state.display_graph.out"
    			},
    			{
    				id: "display_graph",
    				ref: "arg",
    				value: "state.display_graph"
    			},
    			{
    				id: "history",
    				ref: "arg",
    				value: "state.history"
    			},
    			{
    				id: "edges_path",
    				value: "display_graph.edges"
    			},
    			{
    				id: "nodes_path",
    				value: "display_graph.nodes"
    			},
    			{
    				id: "selected_path",
    				value: "selected"
    			},
    			{
    				id: "history_path",
    				value: "history"
    			},
    			{
    				id: "payload",
    				ref: "arg",
    				value: "payload"
    			},
    			{
    				id: "node_id",
    				ref: "arg",
    				value: "payload.id"
    			},
    			{
    				id: "edge",
    				ref: "arg",
    				value: "edge"
    			},
    			{
    				id: "node",
    				ref: "find_node"
    			},
    			{
    				id: "new_nodes",
    				script: "return nodes.filter(n => n.id !== node_id)"
    			},
    			{
    				id: "parent_edge",
    				script: "return edges.find(e => e.from === node_id)"
    			},
    			{
    				id: "replaced_edges",
    				script: "return edges.filter(e => e.to === node_id)"
    			},
    			{
    				id: "new_edges",
    				script: "return edges.filter(e => e !== parent_edge).map(e => e.to === node_id ? {...e, ...parent_edge, from: e.from} : e)"
    			},
    			{
    				id: "new_selected",
    				script: "return [edges.find(e => e.from === node_id)?.to ?? out]"
    			},
    			{
    				id: "history_item",
    				script: "return {action: 'delete_node', node, edges, parent_edge, runnable: {fn: 'delete_node_action', graph: _graph, args: payload}}"
    			},
    			{
    				id: "new_history",
    				ref: "append"
    			},
    			{
    				id: "set_selected",
    				ref: "set"
    			},
    			{
    				id: "set_nodes",
    				ref: "set"
    			},
    			{
    				id: "set_edges",
    				ref: "set"
    			},
    			{
    				id: "set_history",
    				ref: "set"
    			},
    			{
    				id: "out"
    			},
    			{
    				id: "effects",
    				script: "return [[() => _lib.no.runtime.delete_node(display_graph, id)], [update_sim_effect, new_state.state]]"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "state",
    				to: "set_edges",
    				as: "target"
    			},
    			{
    				from: "node_id",
    				to: "new_nodes",
    				as: "node_id"
    			},
    			{
    				from: "nodes",
    				to: "new_nodes",
    				as: "nodes"
    			},
    			{
    				from: "node_id",
    				to: "node",
    				as: "node_id"
    			},
    			{
    				from: "nodes",
    				to: "node",
    				as: "nodes"
    			},
    			{
    				from: "new_nodes",
    				to: "set_nodes",
    				as: "value"
    			},
    			{
    				from: "nodes_path",
    				to: "set_nodes",
    				as: "path"
    			},
    			{
    				from: "state",
    				to: "set_selected",
    				as: "target"
    			},
    			{
    				from: "edges",
    				to: "new_edges",
    				as: "edges"
    			},
    			{
    				from: "node_id",
    				to: "new_edges",
    				as: "node_id"
    			},
    			{
    				from: "parent_edge",
    				to: "new_edges",
    				as: "parent_edge"
    			},
    			{
    				from: "edge",
    				to: "new_edges",
    				as: "edge"
    			},
    			{
    				from: "new_edges",
    				to: "set_edges",
    				as: "value"
    			},
    			{
    				from: "edges_path",
    				to: "set_edges",
    				as: "path"
    			},
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "set_edges",
    				to: "set_nodes",
    				as: "target"
    			},
    			{
    				from: "edges",
    				to: "new_selected",
    				as: "edges"
    			},
    			{
    				from: "node_id",
    				to: "new_selected",
    				as: "node_id"
    			},
    			{
    				from: "display_graph_out",
    				to: "new_selected",
    				as: "out"
    			},
    			{
    				from: "new_selected",
    				to: "set_selected",
    				as: "value"
    			},
    			{
    				from: "selected_path",
    				to: "set_selected",
    				as: "path"
    			},
    			{
    				from: "set_selected",
    				to: "set_history",
    				as: "target"
    			},
    			{
    				from: "payload",
    				to: "history_item",
    				as: "payload"
    			},
    			{
    				from: "node",
    				to: "history_item",
    				as: "node"
    			},
    			{
    				from: "edges",
    				to: "replaced_edges",
    				as: "edges"
    			},
    			{
    				from: "node_id",
    				to: "replaced_edges",
    				as: "node_id"
    			},
    			{
    				from: "replaced_edges",
    				to: "history_item",
    				as: "edges"
    			},
    			{
    				from: "node_id",
    				to: "parent_edge",
    				as: "node_id"
    			},
    			{
    				from: "edges",
    				to: "parent_edge",
    				as: "edges"
    			},
    			{
    				from: "parent_edge",
    				to: "history_item",
    				as: "parent_edge"
    			},
    			{
    				from: "history",
    				to: "new_history",
    				as: "array"
    			},
    			{
    				from: "history_item",
    				to: "new_history",
    				as: "item"
    			},
    			{
    				from: "new_history",
    				to: "set_history",
    				as: "value"
    			},
    			{
    				from: "history_path",
    				to: "set_history",
    				as: "path"
    			},
    			{
    				from: "set_history",
    				to: "out",
    				as: "state"
    			},
    			{
    				from: "set_history",
    				to: "effects",
    				as: "new_state"
    			},
    			{
    				from: "update_sim_effect",
    				to: "effects",
    				as: "update_sim_effect"
    			},
    			{
    				from: "node_id",
    				to: "effects",
    				as: "id"
    			},
    			{
    				from: "display_graph",
    				to: "effects",
    				as: "display_graph"
    			},
    			{
    				from: "effects",
    				to: "out",
    				as: "effects"
    			}
    		]
    	},
    	{
    		id: "delete_node",
    		out: "out",
    		nodes: [
    			{
    				id: "delete_node",
    				ref: "delete_node_action"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "delete_node",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "next_edge",
    		out: "new_edge",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "payload_edge",
    				ref: "arg",
    				value: "edge"
    			},
    			{
    				id: "nodes",
    				ref: "arg",
    				value: "graph.nodes"
    			},
    			{
    				id: "edges",
    				ref: "arg",
    				value: "graph.edges"
    			},
    			{
    				id: "new_edge",
    				script: "return {...payload_edge, as: payload_edge.as ?? next_arg ??  (`arg${(siblings.map(s => s.as).filter(a => a.startsWith('arg')).sort().map(s => parseInt(s.substring(3))).filter(i => !isNaN(i)).reverse()[0] ?? -1) + 1}`)}"
    			},
    			{
    				id: "child_node",
    				script: "return nodes.find(n => n.id === edge.to)"
    			},
    			{
    				id: "siblings",
    				script: "return edges.filter(e => e.to === new_edge.to)"
    			},
    			{
    				id: "node_args",
    				ref: "node_args"
    			},
    			{
    				id: "next_arg",
    				script: "return args?.filter(a => !(a === '_node_inputs' || a === '_lib' || a === '_node' || a === '_args') && !siblings.find(e => e.as === a))[0]"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "edges",
    				to: "new_edges",
    				as: "array"
    			},
    			{
    				from: "edges",
    				to: "siblings",
    				as: "edges"
    			},
    			{
    				from: "payload_edge",
    				to: "siblings",
    				as: "new_edge"
    			},
    			{
    				from: "payload_edge",
    				to: "new_edge",
    				as: "payload_edge"
    			},
    			{
    				from: "siblings",
    				to: "new_edge",
    				as: "siblings"
    			},
    			{
    				from: "nodes",
    				to: "child_node",
    				as: "nodes"
    			},
    			{
    				from: "payload_edge",
    				to: "child_node",
    				as: "edge"
    			},
    			{
    				from: "nodes",
    				to: "node_args",
    				as: "nodes"
    			},
    			{
    				from: "child_node",
    				to: "node_args",
    				as: "node"
    			},
    			{
    				from: "siblings",
    				to: "next_arg",
    				as: "siblings"
    			},
    			{
    				from: "node_args",
    				to: "next_arg",
    				as: "args"
    			},
    			{
    				from: "next_arg",
    				to: "new_edge",
    				as: "next_arg"
    			},
    			{
    				from: "siblings",
    				to: "new_edge",
    				as: "sibling_count"
    			}
    		]
    	},
    	{
    		id: "add_edge",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "display_graph",
    				ref: "state.display_graph"
    			},
    			{
    				id: "next_edge",
    				ref: "next_edge"
    			},
    			{
    				id: "edges_path",
    				value: "display_graph.edges"
    			},
    			{
    				id: "new_edges",
    				ref: "append"
    			},
    			{
    				id: "set_new_edges",
    				ref: "set"
    			},
    			{
    				id: "effects",
    				script: "return [[update_sim_effect, new_state]]"
    			},
    			{
    				id: "new_state"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "_"
    			},
    			{
    				from: "display_graph",
    				to: "next_edge",
    				as: "graph"
    			},
    			{
    				from: "next_edge",
    				to: "new_edges",
    				as: "item"
    			},
    			{
    				from: "state",
    				to: "set_new_edges",
    				as: "target"
    			},
    			{
    				from: "edges_path",
    				to: "set_new_edges",
    				as: "path"
    			},
    			{
    				from: "new_edges",
    				to: "set_new_edges",
    				as: "value"
    			},
    			{
    				from: "update_sim_effect",
    				to: "effects",
    				as: "update_sim_effect"
    			},
    			{
    				from: "set_new_edges",
    				to: "effects",
    				as: "new_state"
    			},
    			{
    				from: "set_new_edges",
    				to: "new_state",
    				as: "state"
    			},
    			{
    				from: "effects",
    				to: "new_state",
    				as: "effects"
    			},
    			{
    				from: "new_state",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "save_effect",
    		script: "return (dispatch, payload) => { const graph_list = JSON.parse(localStorage.getItem('graph_list'))?.filter(l => l !== payload.display_graph.id) ?? []; graph_list.unshift(payload.display_graph.id); localStorage.setItem('graph_list', JSON.stringify(graph_list)); const graphstr = JSON.stringify({...payload.display_graph, node_map: undefined, in_edge_map: undefined}); localStorage.setItem(payload.display_graph.id, graphstr); window.location.hash = '#' + payload.display_graph.id; }"
    	},
    	{
    		id: "export_effect",
    		script: "return (dispatch, payload) => { const str = `data:text/json;charset=utf-8,${encodeURIComponent(payload.data)}`; const a = document.createElement('a'); a.setAttribute('href', str); a.setAttribute('download', payload.id + '.' + payload.ext); a.click(); a.remove();}"
    	},
    	{
    		id: "graph_list_effect",
    		script: "return (dispatch, payload)"
    	},
    	{
    		id: "new_graph_effect",
    		script: "return (dispatch, payload) => { localStorage.removeItem('display_graph'); window.location.reload(); }"
    	},
    	{
    		id: "focus_effect",
    		script: "return (dispatch, payload) => requestAnimationFrame(() => document.querySelector(payload.selector)?.focus())"
    	},
    	{
    		id: "blur_effect",
    		script: "return (dispatch, payload) => requestAnimationFrame(() => document.querySelector(payload.selector)?.blur())"
    	},
    	{
    		id: "open_graph_effect",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "new_graph",
    				ref: "arg",
    				value: "payload.graph"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "update_sim_effector",
    				ref: "arg",
    				value: "state.update_sim_effect"
    			},
    			{
    				id: "display_graph_path",
    				value: "display_graph"
    			},
    			{
    				id: "set_display_graph",
    				ref: "set"
    			},
    			{
    				id: "update_sim_effect",
    				ref: "array"
    			},
    			{
    				id: "effects",
    				ref: "array"
    			},
    			{
    				id: "result"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args",
    				type: "ref"
    			},
    			{
    				from: "state",
    				to: "set_display_graph",
    				as: "target"
    			},
    			{
    				from: "display_graph_path",
    				to: "set_display_graph",
    				as: "path"
    			},
    			{
    				from: "new_graph",
    				to: "set_display_graph",
    				as: "value"
    			},
    			{
    				from: "set_display_graph",
    				to: "result",
    				as: "state"
    			},
    			{
    				from: "update_sim_effector",
    				to: "update_sim_effect",
    				as: "a0"
    			},
    			{
    				from: "update_sim_effect",
    				to: "effects",
    				as: "a0"
    			},
    			{
    				from: "effects",
    				to: "result",
    				as: "effects"
    			},
    			{
    				from: "result",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "open_saved_graph_effect",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "new_graph_id",
    				ref: "arg",
    				value: "payload.id"
    			},
    			{
    				id: "new_graph",
    				script: "return JSON.parse(localStorage.getItem(id))"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "open_graph_effector",
    				ref: "open_graph_effect"
    			},
    			{
    				id: "open_graph_payload"
    			},
    			{
    				id: "open_graph_effect",
    				ref: "array"
    			},
    			{
    				id: "effects",
    				ref: "array"
    			},
    			{
    				id: "result"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args",
    				type: "ref"
    			},
    			{
    				from: "new_graph_id",
    				to: "new_graph",
    				as: "id"
    			},
    			{
    				from: "new_graph",
    				to: "open_graph_payload",
    				as: "graph"
    			},
    			{
    				from: "open_graph_effector",
    				to: "open_graph_effect",
    				as: "a0"
    			},
    			{
    				from: "open_graph_payload",
    				to: "open_graph_effect",
    				as: "a1"
    			},
    			{
    				from: "open_graph_effect",
    				to: "effects",
    				as: "a0"
    			},
    			{
    				from: "state",
    				to: "result",
    				as: "state"
    			},
    			{
    				from: "effects",
    				to: "result",
    				as: "effects"
    			},
    			{
    				from: "result",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "update_node_fn",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "nodes",
    				ref: "arg",
    				value: "state.display_graph.nodes"
    			},
    			{
    				id: "edges",
    				ref: "arg",
    				value: "state.display_graph.edges"
    			},
    			{
    				id: "history",
    				ref: "arg",
    				value: "state.history"
    			},
    			{
    				id: "display_graph",
    				ref: "arg",
    				value: "state.display_graph"
    			},
    			{
    				id: "update_hyperapp",
    				ref: "arg",
    				value: "state.update_hyperapp"
    			},
    			{
    				id: "update_hyperapp_effect",
    				ref: "array"
    			},
    			{
    				id: "new_display_graph_values"
    			},
    			{
    				id: "new_display_graph",
    				ref: "merge_objects"
    			},
    			{
    				id: "payload",
    				ref: "arg",
    				value: "payload"
    			},
    			{
    				id: "node_id",
    				ref: "arg",
    				value: "payload.id"
    			},
    			{
    				id: "node_properties",
    				ref: "arg",
    				value: "payload.properties"
    			},
    			{
    				id: "prev_node",
    				ref: "find_node"
    			},
    			{
    				id: "new_node",
    				ref: "merge_objects"
    			},
    			{
    				id: "replace_node",
    				script: "return nodes.map(n => n.id === new_node.id ? new_node : n)"
    			},
    			{
    				id: "node_args",
    				ref: "node_args"
    			},
    			{
    				id: "arg_value",
    				script: "return node.ref === 'arg' ? node.value.substring(node.value.lastIndexOf('.') + 1) : undefined"
    			},
    			{
    				id: "replace_edges",
    				script: "const parents = edges.filter(e => e.to === node_id).map(e => e.as); const needed_args = !update.hasOwnProperty('ref') ? [] : node_args.filter(a => !parents.includes(a) && a !== '_node_inputs' && a !== '_graph' && a !== '_lib' && a !== '_args'); return edges.map(e => e.from === node_id && arg_value && (e.as.startsWith('arg') || e.as === prev_node?.value) ? {...e, as: arg_value} : e.to === node_id && !node_args.includes(e.as) && needed_args?.length > 0 ? {...e, as: needed_args.shift()} : e)"
    			},
    			{
    				id: "history_item",
    				script: "return {action: 'update_node', node, update, parent_edge: edges.find(e => e.from === node.id), child_edges: edges.filter(e => e.to === node.id), runnable: {fn: 'update_node_fn', graph: _graph, args: payload}}"
    			},
    			{
    				id: "new_history",
    				ref: "append"
    			},
    			{
    				id: "display_graph_nodes_path",
    				value: "display_graph.nodes"
    			},
    			{
    				id: "history_path",
    				value: "history"
    			},
    			{
    				id: "set_history",
    				ref: "set"
    			},
    			{
    				id: "add_node_effect",
    				script: "return [() => _lib.no.runtime.update_graph(display_graph)]"
    			},
    			{
    				id: "effects",
    				ref: "array"
    			},
    			{
    				id: "out"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "nodes",
    				to: "replace_node",
    				as: "nodes"
    			},
    			{
    				from: "nodes",
    				to: "prev_node",
    				as: "nodes"
    			},
    			{
    				from: "edges",
    				to: "replace_edges",
    				as: "edges"
    			},
    			{
    				from: "node_properties",
    				to: "replace_edges",
    				as: "update"
    			},
    			{
    				from: "node_id",
    				to: "prev_node",
    				as: "node_id"
    			},
    			{
    				from: "node_properties",
    				to: "new_node",
    				as: "o1"
    			},
    			{
    				from: "prev_node",
    				to: "new_node",
    				as: "o0"
    			},
    			{
    				from: "new_node",
    				to: "replace_node",
    				as: "new_node"
    			},
    			{
    				from: "state",
    				to: "set_display_graph_nodes",
    				as: "target"
    			},
    			{
    				from: "display_graph_nodes_path",
    				to: "set_display_graph_nodes",
    				as: "path"
    			},
    			{
    				from: "replace_node",
    				to: "new_display_graph_values",
    				as: "nodes"
    			},
    			{
    				from: "nodes",
    				to: "node_args",
    				as: "nodes"
    			},
    			{
    				from: "new_node",
    				to: "node_args",
    				as: "node"
    			},
    			{
    				from: "new_node",
    				to: "arg_value",
    				as: "node"
    			},
    			{
    				from: "node_id",
    				to: "arg_value",
    				as: "node_id"
    			},
    			{
    				from: "prev_node",
    				to: "replace_edges",
    				as: "prev_node"
    			},
    			{
    				from: "arg_value",
    				to: "replace_edges",
    				as: "arg_value"
    			},
    			{
    				from: "node_args",
    				to: "replace_edges",
    				as: "node_args"
    			},
    			{
    				from: "node_id",
    				to: "replace_edges",
    				as: "node_id"
    			},
    			{
    				from: "replace_edges",
    				to: "new_display_graph_values",
    				as: "edges"
    			},
    			{
    				from: "new_display_graph_values",
    				to: "new_display_graph",
    				as: "o1"
    			},
    			{
    				from: "display_graph",
    				to: "new_display_graph",
    				as: "o0"
    			},
    			{
    				from: "display_graph_edges_path",
    				to: "set_display_graph_edges",
    				as: "path"
    			},
    			{
    				from: "state",
    				to: "set_history",
    				as: "target"
    			},
    			{
    				from: "payload",
    				to: "history_item",
    				as: "payload"
    			},
    			{
    				from: "edges",
    				to: "history_item",
    				as: "edges"
    			},
    			{
    				from: "node_properties",
    				to: "history_item",
    				as: "update"
    			},
    			{
    				from: "prev_node",
    				to: "history_item",
    				as: "node"
    			},
    			{
    				from: "history_path",
    				to: "set_history",
    				as: "path"
    			},
    			{
    				from: "history",
    				to: "new_history",
    				as: "array"
    			},
    			{
    				from: "history_item",
    				to: "new_history",
    				as: "item"
    			},
    			{
    				from: "new_history",
    				to: "set_history",
    				as: "value"
    			},
    			{
    				from: "set_history",
    				to: "out",
    				as: "state"
    			},
    			{
    				from: "update_hyperapp",
    				to: "update_hyperapp_effect",
    				as: "a0"
    			},
    			{
    				from: "update_hyperapp_effect",
    				to: "effects",
    				as: "a1"
    			},
    			{
    				from: "new_display_graph",
    				to: "add_node_effect",
    				as: "display_graph"
    			},
    			{
    				from: "add_node_effect",
    				to: "effects",
    				as: "a0"
    			},
    			{
    				from: "effects",
    				to: "out",
    				as: "effects"
    			}
    		]
    	},
    	{
    		id: "update_node_action",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "update_node_fn",
    				ref: "update_node_fn"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "update_node_fn",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "update_node",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "update_node_fn",
    				ref: "update_node_fn"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "update_node_fn",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "update_edge_fn",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "edges",
    				ref: "arg",
    				value: "state.display_graph.edges"
    			},
    			{
    				id: "history",
    				ref: "arg",
    				value: "state.history"
    			},
    			{
    				id: "display_graph",
    				ref: "arg",
    				value: "state.display_graph"
    			},
    			{
    				id: "display_graph_edges_path",
    				value: "display_graph.edges"
    			},
    			{
    				id: "payload",
    				ref: "arg",
    				value: "payload"
    			},
    			{
    				id: "edge",
    				ref: "arg",
    				value: "payload.id"
    			},
    			{
    				id: "properties",
    				ref: "arg",
    				value: "payload.properties"
    			},
    			{
    				id: "history_path",
    				value: "history"
    			},
    			{
    				id: "display_graph_edges_path",
    				value: "display_graph.edges"
    			},
    			{
    				id: "prev_edge",
    				script: "return edges.find(e => e.to === edge.to && e.from === edge.from)"
    			},
    			{
    				id: "new_edge",
    				ref: "merge_objects"
    			},
    			{
    				id: "replace_edge",
    				script: "return edges.map(e => e.from === edge.from && e.to === edge.to ? Object.assign({}, e, Object.fromEntries(Object.entries(update).map(e => [e[0], e[1] === '' ? undefined : e[1]]))) : e)"
    			},
    			{
    				id: "history_item",
    				script: "return {action: 'update_edge', edge, update, runnable: {fn: 'update_edge_fn', graph: _graph, args: payload}}"
    			},
    			{
    				id: "new_history",
    				ref: "append"
    			},
    			{
    				id: "set_history",
    				ref: "set"
    			},
    			{
    				id: "set_display_graph_edges",
    				ref: "set"
    			},
    			{
    				id: "update_hyperapp",
    				ref: "arg",
    				value: "state.update_hyperapp"
    			},
    			{
    				id: "update_hyperapp_effect",
    				ref: "array"
    			},
    			{
    				id: "edit_edge_effect",
    				script: "return [() => _lib.no.runtime.edit_edge(display_graph, edge)]"
    			},
    			{
    				id: "effects",
    				ref: "array"
    			},
    			{
    				id: "out"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "edges",
    				to: "replace_edge",
    				as: "edges"
    			},
    			{
    				from: "edge",
    				to: "replace_edge",
    				as: "edge"
    			},
    			{
    				from: "properties",
    				to: "replace_edge",
    				as: "update"
    			},
    			{
    				from: "state",
    				to: "set_display_graph_edges",
    				as: "target"
    			},
    			{
    				from: "display_graph_edges_path",
    				to: "set_display_graph_edges",
    				as: "path"
    			},
    			{
    				from: "replace_edge",
    				to: "set_display_graph_edges",
    				as: "value"
    			},
    			{
    				from: "edge",
    				to: "prev_edge",
    				as: "edge"
    			},
    			{
    				from: "edges",
    				to: "prev_edge",
    				as: "edges"
    			},
    			{
    				from: "prev_edge",
    				to: "history_item",
    				as: "edge"
    			},
    			{
    				from: "properties",
    				to: "history_item",
    				as: "update"
    			},
    			{
    				from: "payload",
    				to: "history_item",
    				as: "payload"
    			},
    			{
    				from: "history_item",
    				to: "new_history",
    				as: "item"
    			},
    			{
    				from: "history",
    				to: "new_history",
    				as: "array"
    			},
    			{
    				from: "state",
    				to: "set_history",
    				as: "target"
    			},
    			{
    				from: "history_path",
    				to: "set_history",
    				as: "path"
    			},
    			{
    				from: "new_history",
    				to: "set_history",
    				as: "value"
    			},
    			{
    				from: "set_history",
    				to: "out",
    				as: "state"
    			},
    			{
    				from: "update_hyperapp",
    				to: "update_hyperapp_effect",
    				as: "a0"
    			},
    			{
    				from: "prev_edge",
    				to: "new_edge",
    				as: "o0"
    			},
    			{
    				from: "properties",
    				to: "new_edge",
    				as: "o1"
    			},
    			{
    				from: "new_edge",
    				to: "edit_edge_effect",
    				as: "edge"
    			},
    			{
    				from: "display_graph",
    				to: "edit_edge_effect",
    				as: "display_graph"
    			},
    			{
    				from: "update_hyperapp_effect",
    				to: "effects",
    				as: "a0"
    			},
    			{
    				from: "edit_edge_effect",
    				to: "effects",
    				as: "a1"
    			},
    			{
    				from: "effects",
    				to: "out",
    				as: "effects"
    			}
    		]
    	},
    	{
    		id: "update_edge_action",
    		nodes: [
    			{
    				id: "update_edge_fn",
    				ref: "update_edge_fn"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action"
    			}
    		],
    		edges: [
    			{
    				from: "update_edge_fn",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "update_edge",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "update_edge_action",
    				ref: "update_edge_fn"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "update_edge_action",
    				to: "out",
    				as: "fn"
    			}
    		]
    	},
    	{
    		id: "copy_effect",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "nodes",
    				ref: "arg",
    				value: "state.display_graph.nodes"
    			},
    			{
    				id: "clipboard_path",
    				value: "clipboard"
    			},
    			{
    				id: "node_id",
    				ref: "arg",
    				value: "payload.id"
    			},
    			{
    				id: "node",
    				ref: "find_node"
    			},
    			{
    				id: "set_clipboard",
    				ref: "set"
    			},
    			{
    				id: "effects",
    				ref: "array"
    			},
    			{
    				id: "result"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "state",
    				to: "set_clipboard",
    				as: "target"
    			},
    			{
    				from: "clipboard_path",
    				to: "set_clipboard",
    				as: "path"
    			},
    			{
    				from: "node_id",
    				to: "node",
    				as: "node_id"
    			},
    			{
    				from: "nodes",
    				to: "node",
    				as: "nodes"
    			},
    			{
    				from: "node",
    				to: "set_clipboard",
    				as: "value"
    			},
    			{
    				from: "set_clipboard",
    				to: "result",
    				as: "state"
    			},
    			{
    				from: "result",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "change_display_graph_id",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "id_path",
    				value: "display_graph.id"
    			},
    			{
    				id: "id",
    				ref: "arg",
    				value: "payload.properties.id"
    			},
    			{
    				id: "set_display_graph_id",
    				ref: "set"
    			},
    			{
    				id: "effects",
    				ref: "array"
    			},
    			{
    				id: "result"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "state",
    				to: "set_display_graph_id",
    				as: "target"
    			},
    			{
    				from: "id_path",
    				to: "set_display_graph_id",
    				as: "path"
    			},
    			{
    				from: "id",
    				to: "set_display_graph_id",
    				as: "value"
    			},
    			{
    				from: "set_display_graph_id",
    				to: "result",
    				as: "state"
    			},
    			{
    				from: "effects",
    				to: "result",
    				as: "effects"
    			},
    			{
    				from: "result",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "paste_node_effect",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "nodes",
    				ref: "arg",
    				value: "state.display_graph.nodes"
    			},
    			{
    				id: "edges",
    				ref: "arg",
    				value: "state.display_graph.edges"
    			},
    			{
    				id: "randid",
    				ref: "arg",
    				value: "payload.randid"
    			},
    			{
    				id: "selected",
    				ref: "arg",
    				value: "payload.node_id"
    			},
    			{
    				id: "node",
    				ref: "arg",
    				value: "state.clipboard"
    			},
    			{
    				id: "id_path",
    				value: "id"
    			},
    			{
    				id: "clipboard_path",
    				value: "clipboard"
    			},
    			{
    				id: "delete_clipboard",
    				ref: "delete"
    			},
    			{
    				id: "add_node_effector",
    				ref: "add_node"
    			},
    			{
    				id: "new_node",
    				ref: "set"
    			},
    			{
    				id: "select",
    				value: "true"
    			},
    			{
    				id: "add_node_payload"
    			},
    			{
    				id: "add_node_effect",
    				ref: "array"
    			},
    			{
    				id: "add_edge_effector",
    				ref: "add_edge"
    			},
    			{
    				id: "add_edge_payload"
    			},
    			{
    				id: "add_edge_effect",
    				ref: "array"
    			},
    			{
    				id: "update_hyperapp",
    				ref: "arg",
    				value: "state.update_hyperapp"
    			},
    			{
    				id: "update_hyperapp_effect",
    				ref: "array"
    			},
    			{
    				id: "effects",
    				ref: "array"
    			},
    			{
    				id: "result"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "state",
    				to: "delete_clipboard",
    				as: "target"
    			},
    			{
    				from: "id_path",
    				to: "new_node",
    				as: "path"
    			},
    			{
    				from: "randid",
    				to: "new_node",
    				as: "value"
    			},
    			{
    				from: "node",
    				to: "new_node",
    				as: "target"
    			},
    			{
    				from: "new_node",
    				to: "add_node_payload",
    				as: "node"
    			},
    			{
    				from: "select",
    				to: "add_node_payload",
    				as: "select"
    			},
    			{
    				from: "clipboard_path",
    				to: "delete_clipboard",
    				as: "path"
    			},
    			{
    				from: "delete_clipboard",
    				to: "result",
    				as: "state"
    			},
    			{
    				from: "add_node_effector",
    				to: "add_node_effect",
    				as: "a0"
    			},
    			{
    				from: "add_node_payload",
    				to: "add_node_effect",
    				as: "a1"
    			},
    			{
    				from: "add_node_effect",
    				to: "effects",
    				as: "a0"
    			},
    			{
    				from: "randid",
    				to: "add_edge_payload",
    				as: "from"
    			},
    			{
    				from: "selected",
    				to: "add_edge_payload",
    				as: "to"
    			},
    			{
    				from: "add_edge_effector",
    				to: "add_edge_effect",
    				as: "a0"
    			},
    			{
    				from: "add_edge_payload",
    				to: "add_edge_effect",
    				as: "a1"
    			},
    			{
    				from: "add_edge_effect",
    				to: "effects",
    				as: "a1"
    			},
    			{
    				from: "update_hyperapp",
    				to: "update_hyperapp_effect",
    				as: "a0"
    			},
    			{
    				from: "update_hyperapp_effect",
    				to: "effects",
    				as: "a2"
    			},
    			{
    				from: "effects",
    				to: "result",
    				as: "effects"
    			},
    			{
    				from: "result",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "show_edit_text",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "display_graph",
    				ref: "arg",
    				value: "state.display_graph"
    			},
    			{
    				id: "dimensions",
    				ref: "arg",
    				value: "state.dimensions"
    			},
    			{
    				id: "html_id",
    				ref: "arg",
    				value: "state.html_id"
    			},
    			{
    				id: "node_el_width",
    				ref: "arg",
    				value: "state.node_el_width"
    			},
    			{
    				id: "oneditconfirm",
    				ref: "arg",
    				value: "payload.oneditconfirm"
    			},
    			{
    				id: "oneditmore",
    				ref: "arg",
    				value: "payload.oneditmore"
    			},
    			{
    				id: "id",
    				ref: "arg",
    				value: "payload.id"
    			},
    			{
    				id: "current_value",
    				ref: "arg",
    				value: "payload.value"
    			},
    			{
    				id: "property",
    				ref: "arg",
    				value: "payload.property"
    			},
    			{
    				id: "arg_position",
    				ref: "arg",
    				value: "payload.position"
    			},
    			{
    				id: "more_action",
    				ref: "arg",
    				value: "payload.more_action"
    			},
    			{
    				id: "editing_path",
    				value: "editing"
    			},
    			{
    				id: "edit_value_path",
    				value: "edit_value"
    			},
    			{
    				id: "edit_id_path",
    				value: "edit_id"
    			},
    			{
    				id: "edit_onconfirm_path",
    				value: "oneditconfirm"
    			},
    			{
    				id: "edit_onmore_path",
    				value: "oneditmore"
    			},
    			{
    				id: "edit_position_path",
    				value: "edit_position"
    			},
    			{
    				id: "default_position",
    				script: "return {x: dimensions.x * 0.5, y: dimensions.y * 0.5}"
    			},
    			{
    				id: "arg_position_offset",
    				script: "return position && {x: position.x + node_el_width * 0.25, y: position.y + 32}"
    			},
    			{
    				id: "position",
    				ref: "default"
    			},
    			{
    				id: "set_editing",
    				ref: "set"
    			},
    			{
    				id: "set_edit_value",
    				ref: "set"
    			},
    			{
    				id: "set_edit_onconfirm",
    				ref: "set"
    			},
    			{
    				id: "set_edit_onmore",
    				ref: "set"
    			},
    			{
    				id: "set_edit_id",
    				ref: "set"
    			},
    			{
    				id: "set_edit_position",
    				ref: "set"
    			},
    			{
    				id: "focus_props",
    				script: "return {'selector': `#${html_id}-edit-value .${editing}`, focus: true}"
    			},
    			{
    				id: "focus_effector",
    				ref: "focus_effect"
    			},
    			{
    				id: "focus_effect",
    				ref: "array"
    			},
    			{
    				id: "effects",
    				ref: "array"
    			},
    			{
    				id: "result"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "editing_path",
    				to: "set_editing",
    				as: "path"
    			},
    			{
    				from: "property",
    				to: "set_editing",
    				as: "value"
    			},
    			{
    				from: "state",
    				to: "set_editing",
    				as: "target"
    			},
    			{
    				from: "display_graph",
    				to: "selected_node",
    				as: "display_graph"
    			},
    			{
    				from: "property",
    				to: "current_node_value",
    				as: "path"
    			},
    			{
    				from: "selected_node",
    				to: "current_node_value",
    				as: "target"
    			},
    			{
    				from: "set_editing",
    				to: "set_edit_value",
    				as: "target"
    			},
    			{
    				from: "edit_value_path",
    				to: "set_edit_value",
    				as: "path"
    			},
    			{
    				from: "current_value",
    				to: "set_edit_value",
    				as: "value"
    			},
    			{
    				from: "set_edit_value",
    				to: "set_edit_onconfirm",
    				as: "target"
    			},
    			{
    				from: "edit_onconfirm_path",
    				to: "set_edit_onconfirm",
    				as: "path"
    			},
    			{
    				from: "oneditconfirm",
    				to: "set_edit_onconfirm",
    				as: "value"
    			},
    			{
    				from: "set_edit_onconfirm",
    				to: "set_edit_onmore",
    				as: "target"
    			},
    			{
    				from: "edit_onmore_path",
    				to: "set_edit_onmore",
    				as: "path"
    			},
    			{
    				from: "oneditmore",
    				to: "set_edit_onmore",
    				as: "value"
    			},
    			{
    				from: "set_edit_onmore",
    				to: "set_edit_id",
    				as: "target"
    			},
    			{
    				from: "edit_id_path",
    				to: "set_edit_id",
    				as: "path"
    			},
    			{
    				from: "id",
    				to: "set_edit_id",
    				as: "value"
    			},
    			{
    				from: "node_el_width",
    				to: "arg_position_offset",
    				as: "node_el_width"
    			},
    			{
    				from: "arg_position",
    				to: "arg_position_offset",
    				as: "position"
    			},
    			{
    				from: "arg_position_offset",
    				to: "position",
    				as: "value"
    			},
    			{
    				from: "dimensions",
    				to: "default_position",
    				as: "dimensions"
    			},
    			{
    				from: "default_position",
    				to: "position",
    				as: "otherwise"
    			},
    			{
    				from: "position",
    				to: "set_edit_position",
    				as: "value"
    			},
    			{
    				from: "edit_position_path",
    				to: "set_edit_position",
    				as: "path"
    			},
    			{
    				from: "set_edit_id",
    				to: "set_edit_position",
    				as: "target"
    			},
    			{
    				from: "focus_effector",
    				to: "focus_effect",
    				as: "a0"
    			},
    			{
    				from: "html_id",
    				to: "focus_props",
    				as: "html_id"
    			},
    			{
    				from: "property",
    				to: "focus_props",
    				as: "editing"
    			},
    			{
    				from: "focus_props",
    				to: "focus_effect",
    				as: "a1"
    			},
    			{
    				from: "focus_effect",
    				to: "effects",
    				as: "a0"
    			},
    			{
    				from: "set_edit_position",
    				to: "result",
    				as: "state"
    			},
    			{
    				from: "effects",
    				to: "result",
    				as: "effects"
    			},
    			{
    				from: "result",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "node_args",
    		out: "out",
    		nodes: [
    			{
    				id: "node",
    				ref: "arg",
    				value: "node"
    			},
    			{
    				id: "nodes",
    				ref: "arg",
    				value: "nodes"
    			},
    			{
    				id: "ref_path",
    				value: "ref"
    			},
    			{
    				id: "ref",
    				ref: "get"
    			},
    			{
    				id: "ref_node",
    				script: "return nodes.find(n => n.id === selected)"
    			},
    			{
    				id: "source_node",
    				ref: "if"
    			},
    			{
    				id: "nodes_path",
    				value: "nodes"
    			},
    			{
    				id: "node_nodes",
    				ref: "get"
    			},
    			{
    				id: "node_arg_nodes",
    				script: "return nodes?.filter(n => n.ref ==='arg' && n.type !== 'internal')"
    			},
    			{
    				id: "should_show",
    				ref: "get"
    			},
    			{
    				id: "nested_node_args",
    				script: "return [...(new Set(nodes.map(n => n.value).filter(a => !a.includes('.'))))]"
    			},
    			{
    				id: "extern_node_args",
    				script: "return _lib.just.get.fn(_lib, node.extern).args"
    			},
    			{
    				id: "node_args_input",
    				script: "return node.id === 'arg' ? undefined : node.extern ? 'extern' : node.nodes ?  'nested' : 'none'"
    			},
    			{
    				id: "node_args",
    				ref: "switch"
    			},
    			{
    				id: "empty",
    				value: [
    				]
    			},
    			{
    				id: "out",
    				ref: "default"
    			}
    		],
    		edges: [
    			{
    				from: "ref_path",
    				to: "ref",
    				as: "path"
    			},
    			{
    				from: "ref",
    				to: "source_node",
    				as: "pred"
    			},
    			{
    				from: "ref_node",
    				to: "source_node",
    				as: "true"
    			},
    			{
    				from: "node",
    				to: "source_node",
    				as: "false"
    			},
    			{
    				from: "node",
    				to: "ref",
    				as: "target"
    			},
    			{
    				from: "node",
    				to: "ref_node",
    				as: "node"
    			},
    			{
    				from: "nodes",
    				to: "ref_node",
    				as: "nodes"
    			},
    			{
    				from: "ref",
    				to: "ref_node",
    				as: "selected"
    			},
    			{
    				from: "source_node",
    				to: "node_nodes",
    				as: "target"
    			},
    			{
    				from: "nodes_path",
    				to: "node_nodes",
    				as: "path"
    			},
    			{
    				from: "node_nodes",
    				to: "node_arg_nodes",
    				as: "nodes"
    			},
    			{
    				from: "node_arg_nodes",
    				to: "nested_node_args",
    				as: "nodes"
    			},
    			{
    				from: "nested_node_args",
    				to: "node_args",
    				as: "nested"
    			},
    			{
    				from: "source_node",
    				to: "extern_node_args",
    				as: "node"
    			},
    			{
    				from: "extern_node_args",
    				to: "node_args",
    				as: "extern"
    			},
    			{
    				from: "nodes",
    				to: "node_args_input",
    				as: "nodes"
    			},
    			{
    				from: "source_node",
    				to: "node_args_input",
    				as: "node"
    			},
    			{
    				from: "node",
    				to: "node_args_input",
    				as: "ng"
    			},
    			{
    				from: "node_args_input",
    				to: "node_args",
    				as: "input"
    			},
    			{
    				from: "empty",
    				to: "out",
    				as: "otherwise"
    			},
    			{
    				from: "node_args",
    				to: "out",
    				as: "value"
    			}
    		]
    	},
    	{
    		id: "node_description",
    		out: "out",
    		nodes: [
    			{
    				id: "node_id",
    				ref: "arg",
    				value: "node_id"
    			},
    			{
    				id: "nodes",
    				ref: "arg",
    				value: "nodes"
    			},
    			{
    				id: "node",
    				script: "return nodes.find(n => n.id === node_id)"
    			},
    			{
    				id: "ref_path",
    				value: "ref"
    			},
    			{
    				id: "ref",
    				ref: "get"
    			},
    			{
    				id: "ref_node",
    				script: "return nodes.find(n => n.id === selected)"
    			},
    			{
    				id: "source_node",
    				ref: "if"
    			},
    			{
    				id: "description_path",
    				value: "description"
    			},
    			{
    				id: "node_description",
    				ref: "get"
    			},
    			{
    				id: "empty_text",
    				value: ""
    			},
    			{
    				id: "out",
    				ref: "default"
    			}
    		],
    		edges: [
    			{
    				from: "node_id",
    				to: "node",
    				as: "node_id"
    			},
    			{
    				from: "nodes",
    				to: "node",
    				as: "nodes"
    			},
    			{
    				from: "ref_path",
    				to: "ref",
    				as: "path"
    			},
    			{
    				from: "ref",
    				to: "source_node",
    				as: "pred"
    			},
    			{
    				from: "ref_node",
    				to: "source_node",
    				as: "true"
    			},
    			{
    				from: "node",
    				to: "source_node",
    				as: "false"
    			},
    			{
    				from: "node",
    				to: "ref",
    				as: "target"
    			},
    			{
    				from: "node",
    				to: "ref_node",
    				as: "node"
    			},
    			{
    				from: "nodes",
    				to: "ref_node",
    				as: "nodes"
    			},
    			{
    				from: "ref",
    				to: "ref_node",
    				as: "selected"
    			},
    			{
    				from: "source_node",
    				to: "node_description",
    				as: "target"
    			},
    			{
    				from: "description_path",
    				to: "node_description",
    				as: "path"
    			},
    			{
    				from: "node_description",
    				to: "out",
    				as: "value"
    			},
    			{
    				from: "empty_text",
    				to: "out",
    				as: "otherwise"
    			}
    		]
    	},
    	{
    		id: "show_args_effect",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "display_graph_nodes",
    				ref: "arg",
    				value: "state.display_graph.nodes"
    			},
    			{
    				id: "display_graph_edges",
    				ref: "arg",
    				value: "state.display_graph.edges"
    			},
    			{
    				id: "nodes",
    				ref: "arg",
    				value: "state.nodes"
    			},
    			{
    				id: "selected",
    				ref: "arg",
    				value: "state.selected.0"
    			},
    			{
    				id: "dimensions",
    				ref: "arg",
    				value: "state.dimensions"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "svg_offset",
    				ref: "arg",
    				value: "state.svg_offset"
    			},
    			{
    				id: "x_path",
    				value: "x"
    			},
    			{
    				id: "y_path",
    				value: "y"
    			},
    			{
    				id: "length_path",
    				value: "length"
    			},
    			{
    				id: "node_args_arr",
    				ref: "node_args"
    			},
    			{
    				id: "create_input",
    				script: "return `arg${(siblings.map(s => s.as).filter(a => a.startsWith('arg')).sort().map(s => parseInt(s.substring(3))).filter(i => !isNaN(i)).reverse()[0] ?? -1) + 1}`"
    			},
    			{
    				id: "clickable_args",
    				ref: "append"
    			},
    			{
    				id: "node_args_text",
    				value: "inputs: "
    			},
    			{
    				id: "node_args_count",
    				ref: "get"
    			},
    			{
    				id: "node_description",
    				ref: "node_description"
    			},
    			{
    				id: "info_display_path",
    				value: "args_display"
    			},
    			{
    				id: "selected_node",
    				script: "return nodes.find(n => n.id === selected)"
    			},
    			{
    				id: "selected_inputs",
    				script: "return edges.filter(e => e.to === selected)"
    			},
    			{
    				id: "selected_el_node",
    				script: "return nodes.find(n => n.node_id === selected)"
    			},
    			{
    				id: "x",
    				ref: "get"
    			},
    			{
    				id: "y",
    				ref: "get"
    			},
    			{
    				id: "arg_el",
    				out: "out",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "selected",
    						ref: "arg",
    						value: "state.selected.0"
    					},
    					{
    						id: "randid",
    						ref: "arg",
    						value: "state.randid"
    					},
    					{
    						id: "child_as",
    						ref: "arg",
    						value: "payload.text"
    					},
    					{
    						id: "text",
    						ref: "arg",
    						value: "element"
    					},
    					{
    						id: "inputs",
    						ref: "arg",
    						value: "inputs"
    					},
    					{
    						id: "add_node",
    						ref: "add_node_action"
    					},
    					{
    						id: "add_node_action",
    						ref: "runnable"
    					},
    					{
    						id: "new_node"
    					},
    					{
    						id: "payload"
    					},
    					{
    						id: "create_node"
    					},
    					{
    						id: "clickable_action_args"
    					},
    					{
    						id: "clickable_action",
    						ref: "runnable"
    					},
    					{
    						id: "action",
    						ref: "if"
    					},
    					{
    						id: "text_html",
    						ref: "html_text"
    					},
    					{
    						id: "clickable",
    						script: "return !(text === '_args' || text === '_node_inputs' || text === '_node' || text === '_graph') && !inputs.find(e => e.as === text)"
    					},
    					{
    						id: "class"
    					},
    					{
    						id: "props"
    					},
    					{
    						id: "dom_type",
    						value: "span"
    					},
    					{
    						id: "out",
    						ref: "html_element"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "_"
    					},
    					{
    						from: "selected",
    						to: "payload",
    						as: "child"
    					},
    					{
    						from: "randid",
    						to: "new_node",
    						as: "id"
    					},
    					{
    						from: "new_node",
    						to: "payload",
    						as: "node"
    					},
    					{
    						from: "child_as",
    						to: "payload",
    						as: "child_as"
    					},
    					{
    						from: "add_node",
    						to: "add_node_action",
    						as: "fn"
    					},
    					{
    						from: "add_node_action",
    						to: "create_node",
    						as: "action"
    					},
    					{
    						from: "payload",
    						to: "create_node",
    						as: "payload"
    					},
    					{
    						from: "text",
    						to: "clickable_action_args",
    						as: "text"
    					},
    					{
    						from: "clickable_action_args",
    						to: "clickable_action",
    						as: "args"
    					},
    					{
    						from: "create_node",
    						to: "clickable_action",
    						as: "fn"
    					},
    					{
    						from: "clickable",
    						to: "action",
    						as: "pred"
    					},
    					{
    						from: "clickable_action",
    						to: "action",
    						as: "true"
    					},
    					{
    						from: "action",
    						to: "props",
    						as: "onclick"
    					},
    					{
    						from: "inputs",
    						to: "clickable",
    						as: "inputs"
    					},
    					{
    						from: "text",
    						to: "clickable",
    						as: "text"
    					},
    					{
    						from: "clickable",
    						to: "class",
    						as: "clickable"
    					},
    					{
    						from: "class",
    						to: "props",
    						as: "class"
    					},
    					{
    						from: "props",
    						to: "out",
    						as: "props"
    					},
    					{
    						from: "text",
    						to: "text_html",
    						as: "text"
    					},
    					{
    						from: "text_html",
    						to: "out",
    						as: "children"
    					},
    					{
    						from: "dom_type",
    						to: "out",
    						as: "dom_type"
    					}
    				]
    			},
    			{
    				id: "arg_el_runnable_args"
    			},
    			{
    				id: "arg_el_runnable",
    				ref: "runnable"
    			},
    			{
    				id: "args_links",
    				ref: "map"
    			},
    			{
    				id: "args_h_text",
    				ref: "html_text"
    			},
    			{
    				id: "args_h_text_array",
    				ref: "array"
    			},
    			{
    				id: "args_h_children",
    				ref: "append"
    			},
    			{
    				id: "args_h",
    				ref: "html_element"
    			},
    			{
    				id: "args_h_props",
    				value: {
    					"class": "args"
    				}
    			},
    			{
    				id: "args_h_out",
    				ref: "default"
    			},
    			{
    				id: "description_h_text",
    				ref: "html_text"
    			},
    			{
    				id: "description_h",
    				ref: "html_element"
    			},
    			{
    				id: "description_h_out",
    				ref: "if"
    			},
    			{
    				id: "info_h_children",
    				ref: "array"
    			},
    			{
    				id: "info_h_dom_type",
    				value: "div"
    			},
    			{
    				id: "info_h_props",
    				script: "return {class: {'node-info': true}, style: {left: `${Math.min(x * (svg_offset?.scale ?? 1) + (svg_offset?.x ?? 0) - 64, dimensions.x - 256)}px`, top: `${y * (svg_offset?.scale ?? 1) + (svg_offset?.y ?? 0) + 32}px`}}"
    			},
    			{
    				id: "info_h",
    				ref: "html_element"
    			},
    			{
    				id: "info_pred",
    				script: "return true"
    			},
    			{
    				id: "info_out",
    				ref: "if"
    			},
    			{
    				id: "set_info_display",
    				ref: "set"
    			},
    			{
    				id: "result"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect_debounced"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args",
    				type: "ref"
    			},
    			{
    				from: "display_graph_nodes",
    				to: "selected_node",
    				as: "nodes"
    			},
    			{
    				from: "selected",
    				to: "selected_node",
    				as: "selected"
    			},
    			{
    				from: "display_graph_nodes",
    				to: "node_args_arr",
    				as: "nodes"
    			},
    			{
    				from: "selected_node",
    				to: "node_args_arr",
    				as: "node"
    			},
    			{
    				from: "node_args_text",
    				to: "args_h_text",
    				as: "text"
    			},
    			{
    				from: "args_h_text",
    				to: "args_h_text_array",
    				as: "a0"
    			},
    			{
    				from: "node_args_arr",
    				to: "node_args_count",
    				as: "target"
    			},
    			{
    				from: "length_path",
    				to: "node_args_count",
    				as: "path"
    			},
    			{
    				from: "selected",
    				to: "selected_inputs",
    				as: "selected"
    			},
    			{
    				from: "display_graph_edges",
    				to: "selected_inputs",
    				as: "edges"
    			},
    			{
    				from: "selected_inputs",
    				to: "arg_el_runnable_args",
    				as: "inputs"
    			},
    			{
    				from: "arg_el_runnable_args",
    				to: "arg_el_runnable",
    				as: "args"
    			},
    			{
    				from: "arg_el",
    				to: "arg_el_runnable",
    				as: "fn"
    			},
    			{
    				from: "arg_el_runnable",
    				to: "args_links",
    				as: "fn",
    				type: "resolve"
    			},
    			{
    				from: "selected_inputs",
    				to: "create_input",
    				as: "siblings"
    			},
    			{
    				from: "create_input",
    				to: "clickable_args",
    				as: "item"
    			},
    			{
    				from: "node_args_arr",
    				to: "clickable_args",
    				as: "array"
    			},
    			{
    				from: "clickable_args",
    				to: "args_links",
    				as: "array"
    			},
    			{
    				from: "args_links",
    				to: "args_h_children",
    				as: "item"
    			},
    			{
    				from: "args_h_text_array",
    				to: "args_h_children",
    				as: "array"
    			},
    			{
    				from: "args_h_children",
    				to: "args_h",
    				as: "children"
    			},
    			{
    				from: "args_h_props",
    				to: "args_h",
    				as: "props"
    			},
    			{
    				from: "args_h",
    				to: "args_h_out",
    				as: "value"
    			},
    			{
    				from: "selected",
    				to: "node_description",
    				as: "node_id"
    			},
    			{
    				from: "display_graph_nodes",
    				to: "node_description",
    				as: "nodes"
    			},
    			{
    				from: "node_description",
    				to: "description_h_text",
    				as: "text"
    			},
    			{
    				from: "description_h_text",
    				to: "description_h",
    				as: "children"
    			},
    			{
    				from: "description_h",
    				to: "description_h_out",
    				as: "true"
    			},
    			{
    				from: "node_description",
    				to: "description_h_out",
    				as: "pred"
    			},
    			{
    				from: "nodes",
    				to: "selected_el_node",
    				as: "nodes"
    			},
    			{
    				from: "selected",
    				to: "selected_el_node",
    				as: "selected"
    			},
    			{
    				from: "selected_el_node",
    				to: "x",
    				as: "target"
    			},
    			{
    				from: "x_path",
    				to: "x",
    				as: "path"
    			},
    			{
    				from: "selected_el_node",
    				to: "y",
    				as: "target"
    			},
    			{
    				from: "y_path",
    				to: "y",
    				as: "path"
    			},
    			{
    				from: "dimensions",
    				to: "info_h_props",
    				as: "dimensions"
    			},
    			{
    				from: "x",
    				to: "info_h_props",
    				as: "x"
    			},
    			{
    				from: "y",
    				to: "info_h_props",
    				as: "y"
    			},
    			{
    				from: "svg_offset",
    				to: "info_h_props",
    				as: "svg_offset"
    			},
    			{
    				from: "info_h_props",
    				to: "info_h",
    				as: "props"
    			},
    			{
    				from: "args_h_out",
    				to: "info_h_children",
    				as: "a0"
    			},
    			{
    				from: "description_h_out",
    				to: "info_h_children",
    				as: "a1"
    			},
    			{
    				from: "info_h_children",
    				to: "info_h",
    				as: "children"
    			},
    			{
    				from: "info_h",
    				to: "info_out",
    				as: "true"
    			},
    			{
    				from: "node_args_count",
    				to: "info_pred",
    				as: "args_count"
    			},
    			{
    				from: "node_description",
    				to: "info_pred",
    				as: "description"
    			},
    			{
    				from: "info_pred",
    				to: "info_out",
    				as: "pred"
    			},
    			{
    				from: "state",
    				to: "set_info_display",
    				as: "target"
    			},
    			{
    				from: "info_display_path",
    				to: "set_info_display",
    				as: "path"
    			},
    			{
    				from: "info_out",
    				to: "set_info_display",
    				as: "value"
    			},
    			{
    				from: "set_info_display",
    				to: "result",
    				as: "state"
    			},
    			{
    				from: "result",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "confirm_edit_text",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "property",
    				ref: "arg",
    				value: "state.editing"
    			},
    			{
    				id: "payload_value_raw",
    				ref: "arg",
    				value: "state.edit_value"
    			},
    			{
    				id: "payload_value",
    				script: "return value === '' ? undefined : value"
    			},
    			{
    				id: "id",
    				ref: "arg",
    				value: "state.edit_id"
    			},
    			{
    				id: "edit_id_path",
    				ref: "arg",
    				value: "edit_id"
    			},
    			{
    				id: "on_change",
    				ref: "arg",
    				value: "state.oneditconfirm"
    			},
    			{
    				id: "html_id",
    				ref: "arg",
    				value: "state.html_id"
    			},
    			{
    				id: "false",
    				value: false
    			},
    			{
    				id: "empty_string",
    				value: ""
    			},
    			{
    				id: "editing_path",
    				value: "editing"
    			},
    			{
    				id: "edit_value_path",
    				value: "edit_value"
    			},
    			{
    				id: "set_editing",
    				ref: "set"
    			},
    			{
    				id: "set_edit_value",
    				ref: "set"
    			},
    			{
    				id: "set_edit_id",
    				ref: "delete"
    			},
    			{
    				id: "change_effector",
    				ref: "hyperapp_action_effect"
    			},
    			{
    				id: "change_effect_payload"
    			},
    			{
    				id: "change_effect",
    				ref: "array"
    			},
    			{
    				id: "blur_payload",
    				script: "return {selector: `#${html_id}-edit-value textarea`}"
    			},
    			{
    				id: "blur_effector",
    				ref: "blur_effect"
    			},
    			{
    				id: "blur_effect",
    				ref: "array"
    			},
    			{
    				id: "empty",
    				value: {
    				}
    			},
    			{
    				id: "new_node_props",
    				ref: "set"
    			},
    			{
    				id: "effects",
    				ref: "array"
    			},
    			{
    				id: "result"
    			},
    			{
    				id: "noop"
    			},
    			{
    				id: "out_result",
    				ref: "if"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "editing_path",
    				to: "set_editing",
    				as: "path"
    			},
    			{
    				from: "false",
    				to: "set_editing",
    				as: "value"
    			},
    			{
    				from: "state",
    				to: "set_editing",
    				as: "target"
    			},
    			{
    				from: "empty_string",
    				to: "set_edit_value",
    				as: "value"
    			},
    			{
    				from: "set_editing",
    				to: "set_edit_value",
    				as: "target"
    			},
    			{
    				from: "edit_value_path",
    				to: "set_edit_value",
    				as: "path"
    			},
    			{
    				from: "empty",
    				to: "new_node_props",
    				as: "target"
    			},
    			{
    				from: "property",
    				to: "new_node_props",
    				as: "path"
    			},
    			{
    				from: "payload_value_raw",
    				to: "payload_value",
    				as: "value"
    			},
    			{
    				from: "payload_value",
    				to: "new_node_props",
    				as: "value"
    			},
    			{
    				from: "set_edit_value",
    				to: "set_edit_id",
    				as: "target"
    			},
    			{
    				from: "edit_id_path",
    				to: "set_edit_id",
    				as: "path"
    			},
    			{
    				from: "set_edit_id",
    				to: "result",
    				as: "state"
    			},
    			{
    				from: "new_node_props",
    				to: "change_effect_payload",
    				as: "properties"
    			},
    			{
    				from: "id",
    				to: "change_effect_payload",
    				as: "id"
    			},
    			{
    				from: "on_change",
    				to: "change_effector",
    				as: "fn"
    			},
    			{
    				from: "change_effector",
    				to: "change_effect",
    				as: "a0"
    			},
    			{
    				from: "change_effect_payload",
    				to: "change_effect",
    				as: "a1"
    			},
    			{
    				from: "change_effect",
    				to: "effects",
    				as: "a0"
    			},
    			{
    				from: "html_id",
    				to: "blur_payload",
    				as: "html_id"
    			},
    			{
    				from: "blur_payload",
    				to: "blur_effect",
    				as: "a1"
    			},
    			{
    				from: "blur_effector",
    				to: "blur_effect",
    				as: "a0"
    			},
    			{
    				from: "blur_effect",
    				to: "effects",
    				as: "a1"
    			},
    			{
    				from: "effects",
    				to: "result",
    				as: "effects"
    			},
    			{
    				from: "state",
    				to: "noop",
    				as: "state"
    			},
    			{
    				from: "noop",
    				to: "out_result",
    				as: "false"
    			},
    			{
    				from: "result",
    				to: "out_result",
    				as: "true"
    			},
    			{
    				from: "property",
    				to: "out_result",
    				as: "pred"
    			},
    			{
    				from: "result",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "open_reference_popover",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "nodes",
    				ref: "arg",
    				value: "state.display_graph.nodes"
    			},
    			{
    				id: "edges",
    				ref: "arg",
    				value: "state.display_graph.edges"
    			},
    			{
    				id: "levels",
    				ref: "arg",
    				value: "state.levels"
    			},
    			{
    				id: "node_id",
    				ref: "arg",
    				value: "payload.id"
    			},
    			{
    				id: "set_popover_graph_path",
    				value: "popover_graph"
    			},
    			{
    				id: "update_node",
    				ref: "update_node"
    			},
    			{
    				id: "clear_popover",
    				ref: "clear_popover_graph"
    			},
    			{
    				id: "valid_nodes",
    				script: "return nodes.filter(n => !n.ref && !levels.level_by_node.has(n.id))"
    			},
    			{
    				id: "popover_graph_nodes",
    				script: "return nodes.map(n => ({id: `reference-popover${n.id}`, name: n.name ?? n.id, value: n.hasOwnProperty('script') || n.hasOwnProperty('nodes') || n.hasOwnProperty('extern') ? [[update_node, {id: node_id, properties: {ref: n.id}}], [clear_popover]] : []})).concat([{id: 'out', name: 'reference nodes', value: [[clear_popover]]}])"
    			},
    			{
    				id: "popover_graph_edges",
    				script: "return edges.filter(e => !!nodes.find(n => e.to === n.id)).map(e => ({from: `reference-popover${e.from}`, to:  `reference-popover${e.to}`})).concat(nodes.filter(n => edges.filter(e => e.from === n.id).length === 0).map(n => ({from: `reference-popover${n.id}`, to: 'out'})))"
    			},
    			{
    				id: "popover_graph_out",
    				value: "out"
    			},
    			{
    				id: "popover_graph_value"
    			},
    			{
    				id: "show_popover_graph_payload"
    			},
    			{
    				id: "show_popover_graph",
    				ref: "show_popover_graph"
    			},
    			{
    				id: "show_popover_graph_effect",
    				ref: "array"
    			},
    			{
    				id: "set_popover_graph",
    				ref: "set"
    			},
    			{
    				id: "effects",
    				ref: "array"
    			},
    			{
    				id: "result"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "nodes",
    				to: "valid_nodes",
    				as: "nodes"
    			},
    			{
    				from: "edges",
    				to: "popover_graph_edges",
    				as: "edges"
    			},
    			{
    				from: "levels",
    				to: "valid_nodes",
    				as: "levels"
    			},
    			{
    				from: "levels",
    				to: "popover_graph_edges",
    				as: "levels"
    			},
    			{
    				from: "node_id",
    				to: "popover_graph_nodes",
    				as: "node_id"
    			},
    			{
    				from: "clear_popover",
    				to: "popover_graph_nodes",
    				as: "clear_popover"
    			},
    			{
    				from: "update_node",
    				to: "popover_graph_nodes",
    				as: "update_node"
    			},
    			{
    				from: "valid_nodes",
    				to: "popover_graph_nodes",
    				as: "nodes"
    			},
    			{
    				from: "popover_graph_nodes",
    				to: "popover_graph_value",
    				as: "nodes"
    			},
    			{
    				from: "valid_nodes",
    				to: "popover_graph_edges",
    				as: "nodes"
    			},
    			{
    				from: "popover_graph_edges",
    				to: "popover_graph_value",
    				as: "edges"
    			},
    			{
    				from: "popover_graph_out",
    				to: "popover_graph_value",
    				as: "out"
    			},
    			{
    				from: "popover_graph_value",
    				to: "set_popover_graph",
    				as: "value"
    			},
    			{
    				from: "set_popover_graph_path",
    				to: "set_popover_graph",
    				as: "path"
    			},
    			{
    				from: "state",
    				to: "set_popover_graph",
    				as: "target"
    			},
    			{
    				from: "show_popover_graph",
    				to: "show_popover_graph_effect",
    				as: "a0"
    			},
    			{
    				from: "popover_graph_value",
    				to: "show_popover_graph_payload",
    				as: "popover_graph"
    			},
    			{
    				from: "show_popover_graph_payload",
    				to: "show_popover_graph_effect",
    				as: "a1"
    			},
    			{
    				from: "show_popover_graph_effect",
    				to: "effects",
    				as: "a0"
    			},
    			{
    				from: "effects",
    				to: "result",
    				as: "effects"
    			},
    			{
    				from: "state",
    				to: "result",
    				as: "state"
    			},
    			{
    				from: "result",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "insert_node",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "display_graph",
    				ref: "arg",
    				value: "state.display_graph"
    			},
    			{
    				id: "edge",
    				ref: "arg",
    				value: "payload.edge"
    			},
    			{
    				id: "edge_to",
    				ref: "arg",
    				value: "payload.edge.to"
    			},
    			{
    				id: "edge_as",
    				ref: "arg",
    				value: "payload.edge.as"
    			},
    			{
    				id: "edge_from",
    				ref: "arg",
    				value: "payload.edge.from"
    			},
    			{
    				id: "id",
    				ref: "arg",
    				value: "payload.node.id"
    			},
    			{
    				id: "name",
    				ref: "arg",
    				value: "payload.node.name"
    			},
    			{
    				id: "in_node",
    				ref: "arg",
    				value: "payload.in_node"
    			},
    			{
    				id: "edges",
    				ref: "arg",
    				value: "state.display_graph.edges"
    			},
    			{
    				id: "nodes",
    				ref: "arg",
    				value: "state.display_graph.nodes"
    			},
    			{
    				id: "display_graph_path",
    				value: "display_graph"
    			},
    			{
    				id: "from_path",
    				value: "from"
    			},
    			{
    				id: "selected_path",
    				value: "selected"
    			},
    			{
    				id: "select",
    				script: "return !in_node"
    			},
    			{
    				id: "edges_path",
    				value: "edges"
    			},
    			{
    				id: "arg0",
    				value: "arg0"
    			},
    			{
    				id: "new_in_edge"
    			},
    			{
    				id: "new_out_edge",
    				ref: "set"
    			},
    			{
    				id: "set_edges",
    				ref: "set"
    			},
    			{
    				id: "add_node_effector",
    				ref: "add_node"
    			},
    			{
    				id: "new_node"
    			},
    			{
    				id: "next_edge",
    				ref: "next_edge"
    			},
    			{
    				id: "new_nodes",
    				ref: "append"
    			},
    			{
    				id: "remove_edge",
    				ref: "remove_edge"
    			},
    			{
    				id: "add_node",
    				ref: "create_or_update_node"
    			},
    			{
    				id: "add_out_edge",
    				ref: "create_or_update_edge"
    			},
    			{
    				id: "add_in_edge",
    				ref: "create_or_update_edge"
    			},
    			{
    				id: "new_display_graph_values"
    			},
    			{
    				id: "new_display_graph",
    				ref: "merge_objects"
    			},
    			{
    				id: "add_node_payload"
    			},
    			{
    				id: "selected_array",
    				ref: "array"
    			},
    			{
    				id: "set_selected",
    				ref: "set"
    			},
    			{
    				id: "set_display_graph",
    				ref: "set"
    			},
    			{
    				id: "update_graph_effect",
    				script: "return [() => _lib.no.runtime.update_graph(display_graph)]"
    			},
    			{
    				id: "effects",
    				ref: "array"
    			},
    			{
    				id: "result"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args",
    				type: "ref"
    			},
    			{
    				from: "state",
    				to: "set_selected",
    				as: "target"
    			},
    			{
    				from: "id",
    				to: "selected_array",
    				as: "value"
    			},
    			{
    				from: "selected_array",
    				to: "set_selected",
    				as: "value"
    			},
    			{
    				from: "selected_path",
    				to: "set_selected",
    				as: "path"
    			},
    			{
    				from: "set_selected",
    				to: "set_display_graph",
    				as: "target"
    			},
    			{
    				from: "add_in_edge",
    				to: "set_display_graph",
    				as: "value"
    			},
    			{
    				from: "display_graph_path",
    				to: "set_display_graph",
    				as: "path"
    			},
    			{
    				from: "set_display_graph",
    				to: "result",
    				as: "state"
    			},
    			{
    				from: "id",
    				to: "new_node",
    				as: "id"
    			},
    			{
    				from: "name",
    				to: "new_node",
    				as: "name"
    			},
    			{
    				from: "edge_to",
    				to: "add_node_payload",
    				as: "child"
    			},
    			{
    				from: "edge_as",
    				to: "add_node_payload",
    				as: "child_as"
    			},
    			{
    				from: "new_node",
    				to: "add_node_payload",
    				as: "node"
    			},
    			{
    				from: "display_graph",
    				to: "remove_edge",
    				as: "graph"
    			},
    			{
    				from: "edge",
    				to: "remove_edge",
    				as: "edge"
    			},
    			{
    				from: "remove_edge",
    				to: "add_node",
    				as: "graph"
    			},
    			{
    				from: "new_node",
    				to: "add_node",
    				as: "node"
    			},
    			{
    				from: "edge",
    				to: "new_out_edge",
    				as: "target"
    			},
    			{
    				from: "from_path",
    				to: "new_out_edge",
    				as: "path"
    			},
    			{
    				from: "id",
    				to: "new_out_edge",
    				as: "value"
    			},
    			{
    				from: "add_node",
    				to: "add_out_edge",
    				as: "graph"
    			},
    			{
    				from: "new_out_edge",
    				to: "add_out_edge",
    				as: "edge"
    			},
    			{
    				from: "add_out_edge",
    				to: "next_edge",
    				as: "graph"
    			},
    			{
    				from: "id",
    				to: "new_in_edge",
    				as: "to"
    			},
    			{
    				from: "edge_from",
    				to: "new_in_edge",
    				as: "from"
    			},
    			{
    				from: "arg0",
    				to: "new_in_edge",
    				as: "as"
    			},
    			{
    				from: "add_out_edge",
    				to: "add_in_edge",
    				as: "graph"
    			},
    			{
    				from: "new_in_edge",
    				to: "add_in_edge",
    				as: "edge"
    			},
    			{
    				from: "add_in_edge",
    				to: "update_graph_effect",
    				as: "display_graph"
    			},
    			{
    				from: "update_graph_effect",
    				to: "effects",
    				as: "a1"
    			},
    			{
    				from: "effects",
    				to: "result",
    				as: "effects"
    			},
    			{
    				from: "result",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "create_reference_effect",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "id",
    				ref: "arg",
    				value: "payload.id"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "nodes",
    				ref: "arg",
    				value: "state.display_graph.nodes"
    			},
    			{
    				id: "edges",
    				ref: "arg",
    				value: "state.display_graph.edges"
    			},
    			{
    				id: "nodes_path",
    				value: "display_graph.nodes"
    			},
    			{
    				id: "edges_path",
    				value: "display_graph.edges"
    			},
    			{
    				id: "node",
    				script: "return nodes.find(n => n.id === id)"
    			},
    			{
    				id: "ref",
    				script: "return node.name ?? (node.id + 'reference')"
    			},
    			{
    				id: "new_nodes",
    				script: "return nodes.filter(n => n.id !== ref).flatMap(n => n.id === id ? [{id: n.id, name: n.name, ref}, {...n, id: ref, name: n.name ?? ref}] : n)"
    			},
    			{
    				id: "set_nodes",
    				ref: "set"
    			},
    			{
    				id: "new_edges",
    				script: "return edges.concat([{from: ref, to: 'custom'}])"
    			},
    			{
    				id: "set_edges",
    				ref: "set"
    			},
    			{
    				id: "result"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args",
    				type: "ref"
    			},
    			{
    				from: "id",
    				to: "new_nodes",
    				as: "id"
    			},
    			{
    				from: "id",
    				to: "node",
    				as: "id"
    			},
    			{
    				from: "nodes",
    				to: "node",
    				as: "nodes"
    			},
    			{
    				from: "node",
    				to: "ref",
    				as: "node"
    			},
    			{
    				from: "ref",
    				to: "new_nodes",
    				as: "ref"
    			},
    			{
    				from: "nodes",
    				to: "new_nodes",
    				as: "nodes"
    			},
    			{
    				from: "nodes_path",
    				to: "set_nodes",
    				as: "path"
    			},
    			{
    				from: "new_nodes",
    				to: "set_nodes",
    				as: "value"
    			},
    			{
    				from: "state",
    				to: "set_nodes",
    				as: "target"
    			},
    			{
    				from: "ref",
    				to: "new_edges",
    				as: "ref"
    			},
    			{
    				from: "edges",
    				to: "new_edges",
    				as: "edges"
    			},
    			{
    				from: "new_edges",
    				to: "set_edges",
    				as: "value"
    			},
    			{
    				from: "edges_path",
    				to: "set_edges",
    				as: "path"
    			},
    			{
    				from: "set_nodes",
    				to: "set_edges",
    				as: "target"
    			},
    			{
    				from: "set_edges",
    				to: "result",
    				as: "state"
    			},
    			{
    				from: "result",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "redo_action",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "redo_history",
    				ref: "arg",
    				value: "state.redo_history"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "update",
    				ref: "arg",
    				value: "state.update_sim_effect"
    			},
    			{
    				id: "state_path",
    				value: "state"
    			},
    			{
    				id: "effects_path",
    				value: "effects"
    			},
    			{
    				id: "new_history",
    				ref: "append"
    			},
    			{
    				id: "new_redo_history",
    				script: "return redo_history.slice(0, -1)"
    			},
    			{
    				id: "last_change",
    				script: "return redo_history[redo_history.length - 1]"
    			},
    			{
    				id: "last_change_action",
    				script: "return {...last_change.runnable, args: {payload: last_change.runnable.args, state}}"
    			},
    			{
    				id: "redo",
    				ref: "run"
    			},
    			{
    				id: "redo_state",
    				ref: "get"
    			},
    			{
    				id: "history_obj"
    			},
    			{
    				id: "new_state",
    				ref: "merge_objects"
    			},
    			{
    				id: "result",
    				ref: "if"
    			},
    			{
    				id: "update_effect",
    				ref: "array"
    			},
    			{
    				id: "onchange_effects",
    				script: "return (redo.effects ?? []).concat([update])"
    			},
    			{
    				id: "noop_effects",
    				ref: "array"
    			},
    			{
    				id: "effects",
    				ref: "if"
    			},
    			{
    				id: "out"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "_",
    				type: "ref"
    			},
    			{
    				from: "state",
    				to: "last_change_action",
    				as: "state"
    			},
    			{
    				from: "redo_history",
    				to: "last_change",
    				as: "redo_history"
    			},
    			{
    				from: "last_change",
    				to: "last_change_action",
    				as: "last_change"
    			},
    			{
    				from: "last_change_action",
    				to: "redo",
    				as: "runnable"
    			},
    			{
    				from: "state_path",
    				to: "redo_state",
    				as: "path"
    			},
    			{
    				from: "redo",
    				to: "redo_state",
    				as: "target"
    			},
    			{
    				from: "redo_state",
    				to: "new_state",
    				as: "a0"
    			},
    			{
    				from: "redo_history",
    				to: "new_redo_history",
    				as: "redo_history"
    			},
    			{
    				from: "new_redo_history",
    				to: "history_obj",
    				as: "redo_history"
    			},
    			{
    				from: "history_obj",
    				to: "new_state",
    				as: "a1"
    			},
    			{
    				from: "new_state",
    				to: "result",
    				as: "true"
    			},
    			{
    				from: "state",
    				to: "result",
    				as: "false"
    			},
    			{
    				from: "last_change",
    				to: "result",
    				as: "pred"
    			},
    			{
    				from: "result",
    				to: "out",
    				as: "state"
    			},
    			{
    				from: "update",
    				to: "update_effect",
    				as: "a0"
    			},
    			{
    				from: "update_effect",
    				to: "onchange_effects",
    				as: "update"
    			},
    			{
    				from: "effects_path",
    				to: "redo_effects",
    				as: "path"
    			},
    			{
    				from: "redo",
    				to: "onchange_effects",
    				as: "redo"
    			},
    			{
    				from: "onchange_effects",
    				to: "effects",
    				as: "true"
    			},
    			{
    				from: "noop_effects",
    				to: "effects",
    				as: "false"
    			},
    			{
    				from: "last_change",
    				to: "effects",
    				as: "pred"
    			},
    			{
    				from: "effects",
    				to: "out",
    				as: "effects"
    			}
    		]
    	},
    	{
    		id: "undo_action",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "history",
    				ref: "arg",
    				value: "state.history"
    			},
    			{
    				id: "redo_history",
    				ref: "arg",
    				value: "state.redo_history"
    			},
    			{
    				id: "update",
    				ref: "arg",
    				value: "state.update_sim_effect"
    			},
    			{
    				id: "last_change",
    				script: "return history[history.length - 1]"
    			},
    			{
    				id: "new_history",
    				script: "return history.slice(0, -1)"
    			},
    			{
    				id: "new_redo_history",
    				ref: "append"
    			},
    			{
    				id: "last_change_action",
    				script: "return change?.action"
    			},
    			{
    				id: "undo_add_node",
    				script: "return {...state, selected: [change.child], display_graph: {...state.display_graph, nodes: state.display_graph.nodes.filter(n => n.id !== change.node.id), edges: state.display_graph.edges.filter(e => e.from !== change.node.id)}}"
    			},
    			{
    				id: "undo_delete_node",
    				script: "return {...state, selected: [change.node.id], display_graph: {...state.display_graph, nodes: state.display_graph.nodes.concat([change.node]), edges: state.display_graph.edges.filter(e => !change.edges.find(c => c.from === e.from)).concat(change.edges).concat([change.parent_edge])}}"
    			},
    			{
    				id: "undo_update_node",
    				script: "return {...state, selected: [change.node.id], display_graph: {...state.display_graph, nodes: state.display_graph.nodes.filter(n => n.id !== change.node.id).concat([change.node]), edges: state.display_graph.edges.filter(e => !((change.parent_edge.to === e.to && change.parent_edge.from === e.from) || change.child_edges.find(c => c.from === e.from))).concat(change.child_edges).concat([change.parent_edge])}}"
    			},
    			{
    				id: "undo_update_edge",
    				script: "return {...state, display_graph: {...state.display_graph, edges: state.display_graph.edges.filter(e => !(e.to === change.edge.to && e.from === change.edge.from)).concat([change.edge])}}"
    			},
    			{
    				id: "history_obj"
    			},
    			{
    				id: "action_state",
    				ref: "switch"
    			},
    			{
    				id: "new_state",
    				ref: "merge_objects"
    			},
    			{
    				id: "update_effect",
    				ref: "array"
    			},
    			{
    				id: "onchange_effects",
    				ref: "array"
    			},
    			{
    				id: "effects",
    				ref: "if"
    			},
    			{
    				id: "action",
    				ref: "if"
    			},
    			{
    				id: "out"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "_",
    				type: "ref"
    			},
    			{
    				from: "history",
    				to: "last_change",
    				as: "history"
    			},
    			{
    				from: "state",
    				to: "undo_add_node",
    				as: "state"
    			},
    			{
    				from: "last_change",
    				to: "undo_add_node",
    				as: "change"
    			},
    			{
    				from: "undo_add_node",
    				to: "action_state",
    				as: "add_node"
    			},
    			{
    				from: "state",
    				to: "undo_delete_node",
    				as: "state"
    			},
    			{
    				from: "last_change",
    				to: "undo_delete_node",
    				as: "change"
    			},
    			{
    				from: "undo_delete_node",
    				to: "action_state",
    				as: "delete_node"
    			},
    			{
    				from: "state",
    				to: "undo_update_node",
    				as: "state"
    			},
    			{
    				from: "last_change",
    				to: "undo_update_node",
    				as: "change"
    			},
    			{
    				from: "undo_update_node",
    				to: "action_state",
    				as: "update_node"
    			},
    			{
    				from: "state",
    				to: "undo_update_edge",
    				as: "state"
    			},
    			{
    				from: "last_change",
    				to: "undo_update_edge",
    				as: "change"
    			},
    			{
    				from: "undo_update_edge",
    				to: "action_state",
    				as: "update_edge"
    			},
    			{
    				from: "last_change",
    				to: "last_change_action",
    				as: "change"
    			},
    			{
    				from: "last_change_action",
    				to: "action_state",
    				as: "input"
    			},
    			{
    				from: "action_state",
    				to: "new_state",
    				as: "a0"
    			},
    			{
    				from: "history",
    				to: "new_history",
    				as: "history"
    			},
    			{
    				from: "new_history",
    				to: "history_obj",
    				as: "history"
    			},
    			{
    				from: "redo_history",
    				to: "new_redo_history",
    				as: "array"
    			},
    			{
    				from: "last_change",
    				to: "new_redo_history",
    				as: "item"
    			},
    			{
    				from: "new_redo_history",
    				to: "history_obj",
    				as: "redo_history"
    			},
    			{
    				from: "history_obj",
    				to: "new_state",
    				as: "a1"
    			},
    			{
    				from: "last_change_action",
    				to: "action",
    				as: "pred"
    			},
    			{
    				from: "new_state",
    				to: "action",
    				as: "true"
    			},
    			{
    				from: "state",
    				to: "action",
    				as: "false"
    			},
    			{
    				from: "action",
    				to: "out",
    				as: "state"
    			},
    			{
    				from: "update",
    				to: "update_effect",
    				as: "a0"
    			},
    			{
    				from: "update_effect",
    				to: "onchange_effects",
    				as: "a0"
    			},
    			{
    				from: "last_change_action",
    				to: "effects",
    				as: "pred"
    			},
    			{
    				from: "onchange_effects",
    				to: "effects",
    				as: "true"
    			},
    			{
    				from: "effects",
    				to: "out",
    				as: "effects"
    			}
    		]
    	},
    	{
    		id: "create_or_update_node",
    		out: "new_graph",
    		nodes: [
    			{
    				id: "id",
    				ref: "arg",
    				value: "node.id"
    			},
    			{
    				id: "arg_node",
    				ref: "arg",
    				value: "node"
    			},
    			{
    				id: "graph",
    				ref: "arg",
    				value: "graph"
    			},
    			{
    				id: "nodes",
    				ref: "arg",
    				value: "graph.nodes"
    			},
    			{
    				id: "old_node",
    				ref: "find_node"
    			},
    			{
    				id: "node",
    				ref: "merge_objects"
    			},
    			{
    				id: "nodes_path",
    				value: "nodes"
    			},
    			{
    				id: "filtered_nodes",
    				script: "return nodes.filter(n => n.id !== node_id)"
    			},
    			{
    				id: "new_nodes",
    				ref: "append"
    			},
    			{
    				id: "new_graph",
    				ref: "set"
    			}
    		],
    		edges: [
    			{
    				from: "id",
    				to: "old_node",
    				as: "node_id"
    			},
    			{
    				from: "nodes",
    				to: "old_node",
    				as: "nodes"
    			},
    			{
    				from: "old_node",
    				to: "node",
    				as: "o0"
    			},
    			{
    				from: "arg_node",
    				to: "node",
    				as: "o1"
    			},
    			{
    				from: "node",
    				to: "new_nodes",
    				as: "item",
    				type: "resolve"
    			},
    			{
    				from: "id",
    				to: "filtered_nodes",
    				as: "node_id"
    			},
    			{
    				from: "nodes",
    				to: "filtered_nodes",
    				as: "nodes"
    			},
    			{
    				from: "filtered_nodes",
    				to: "new_nodes",
    				as: "array"
    			},
    			{
    				from: "new_nodes",
    				to: "new_graph",
    				as: "value"
    			},
    			{
    				from: "nodes_path",
    				to: "new_graph",
    				as: "path"
    			},
    			{
    				from: "graph",
    				to: "new_graph",
    				as: "target"
    			}
    		]
    	},
    	{
    		id: "create_or_update_edge",
    		out: "new_graph",
    		nodes: [
    			{
    				id: "arg_edge",
    				ref: "arg",
    				value: "edge"
    			},
    			{
    				id: "graph",
    				ref: "arg",
    				value: "graph"
    			},
    			{
    				id: "edges",
    				ref: "arg",
    				value: "graph.edges"
    			},
    			{
    				id: "old_edge",
    				script: "return edges.find(e => e.to === edge.to && e.from === edge.from)"
    			},
    			{
    				id: "new_edge",
    				ref: "merge_objects"
    			},
    			{
    				id: "edges_path",
    				value: "edges"
    			},
    			{
    				id: "filtered_edges",
    				script: "return edges.filter(e => !(e.to === edge.to && e.from === edge.from))"
    			},
    			{
    				id: "new_edges",
    				ref: "append"
    			},
    			{
    				id: "new_graph",
    				ref: "set"
    			}
    		],
    		edges: [
    			{
    				from: "arg_edge",
    				to: "old_edge",
    				as: "edge"
    			},
    			{
    				from: "edges",
    				to: "old_edge",
    				as: "edges"
    			},
    			{
    				from: "old_edge",
    				to: "new_edge",
    				as: "o0"
    			},
    			{
    				from: "arg_edge",
    				to: "new_edge",
    				as: "o1"
    			},
    			{
    				from: "new_edge",
    				to: "new_edges",
    				as: "item",
    				type: "resolve"
    			},
    			{
    				from: "arg_edge",
    				to: "filtered_edges",
    				as: "edge"
    			},
    			{
    				from: "edges",
    				to: "filtered_edges",
    				as: "edges"
    			},
    			{
    				from: "filtered_edges",
    				to: "new_edges",
    				as: "array"
    			},
    			{
    				from: "new_edges",
    				to: "new_graph",
    				as: "value"
    			},
    			{
    				from: "edges_path",
    				to: "new_graph",
    				as: "path"
    			},
    			{
    				from: "graph",
    				to: "new_graph",
    				as: "target"
    			}
    		]
    	},
    	{
    		id: "remove_edge",
    		out: "new_graph",
    		nodes: [
    			{
    				id: "arg_edge",
    				ref: "arg",
    				value: "edge"
    			},
    			{
    				id: "graph",
    				ref: "arg",
    				value: "graph"
    			},
    			{
    				id: "edges",
    				ref: "arg",
    				value: "graph.edges"
    			},
    			{
    				id: "edges_path",
    				value: "edges"
    			},
    			{
    				id: "filtered_edges",
    				script: "return edges.filter(e => !(e.to === edge.to && e.from === edge.from))"
    			},
    			{
    				id: "new_graph",
    				ref: "set"
    			}
    		],
    		edges: [
    			{
    				from: "arg_edge",
    				to: "filtered_edges",
    				as: "edge"
    			},
    			{
    				from: "edges",
    				to: "filtered_edges",
    				as: "edges"
    			},
    			{
    				from: "filtered_edges",
    				to: "new_graph",
    				as: "value"
    			},
    			{
    				from: "edges_path",
    				to: "new_graph",
    				as: "path"
    			},
    			{
    				from: "graph",
    				to: "new_graph",
    				as: "target"
    			}
    		]
    	},
    	{
    		id: "add_node_action",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "id",
    				ref: "arg",
    				value: "payload.node.id"
    			},
    			{
    				id: "payload",
    				ref: "arg",
    				value: "payload"
    			},
    			{
    				id: "node",
    				ref: "arg",
    				value: "payload.node"
    			},
    			{
    				id: "select",
    				ref: "arg",
    				value: "payload.select"
    			},
    			{
    				id: "child",
    				ref: "arg",
    				value: "payload.child"
    			},
    			{
    				id: "child_as",
    				ref: "arg",
    				value: "payload.child_as"
    			},
    			{
    				id: "history",
    				ref: "arg",
    				value: "state.history"
    			},
    			{
    				id: "selected",
    				ref: "arg",
    				value: "state.selected"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "display_graph",
    				ref: "arg",
    				value: "state.display_graph"
    			},
    			{
    				id: "history_path",
    				value: "history"
    			},
    			{
    				id: "display_graph_path",
    				value: "display_graph"
    			},
    			{
    				id: "id_array",
    				ref: "array"
    			},
    			{
    				id: "update_sim_effect",
    				ref: "arg",
    				value: "state.update_sim_effect"
    			},
    			{
    				id: "nodes",
    				ref: "arg",
    				value: "state.display_graph.nodes"
    			},
    			{
    				id: "history_item",
    				script: "return {action: 'add_node', node, child, runnable: {fn: 'add_node_action', graph: _graph, args: payload}}"
    			},
    			{
    				id: "new_history",
    				ref: "append"
    			},
    			{
    				id: "new_edge",
    				script: "return {from: id, to: child, as: child_as}"
    			},
    			{
    				id: "next_edge",
    				ref: "next_edge"
    			},
    			{
    				id: "add_node",
    				ref: "create_or_update_node"
    			},
    			{
    				id: "add_edge",
    				ref: "create_or_update_edge"
    			},
    			{
    				id: "effects",
    				script: "return [[() => _lib.no.runtime.update_graph(display_graph)], [update_sim_effect]]"
    			},
    			{
    				id: "set_display_graph",
    				ref: "set"
    			},
    			{
    				id: "nodes_path",
    				value: "display_graph.nodes"
    			},
    			{
    				id: "selected_path",
    				value: "selected"
    			},
    			{
    				id: "new_node"
    			},
    			{
    				id: "new_nodes",
    				ref: "append"
    			},
    			{
    				id: "add_edge_effector",
    				ref: "add_edge"
    			},
    			{
    				id: "set_new_nodes",
    				ref: "set"
    			},
    			{
    				id: "new_selected",
    				ref: "if"
    			},
    			{
    				id: "set_selected",
    				ref: "set"
    			},
    			{
    				id: "set_history",
    				ref: "set"
    			},
    			{
    				id: "out"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "node",
    				to: "new_node"
    			},
    			{
    				from: "node",
    				to: "history_item",
    				as: "node"
    			},
    			{
    				from: "payload",
    				to: "history_item",
    				as: "payload"
    			},
    			{
    				from: "child",
    				to: "history_item",
    				as: "child"
    			},
    			{
    				from: "child_as",
    				to: "history_item",
    				as: "child_as"
    			},
    			{
    				from: "history_item",
    				to: "new_history",
    				as: "item"
    			},
    			{
    				from: "history",
    				to: "new_history",
    				as: "array"
    			},
    			{
    				from: "id",
    				to: "id_array",
    				as: "arg0"
    			},
    			{
    				from: "nodes",
    				to: "new_nodes",
    				as: "array"
    			},
    			{
    				from: "new_node",
    				to: "new_nodes",
    				as: "item"
    			},
    			{
    				from: "state",
    				to: "set_new_nodes",
    				as: "target"
    			},
    			{
    				from: "nodes_path",
    				to: "set_new_nodes",
    				as: "path"
    			},
    			{
    				from: "new_nodes",
    				to: "set_new_nodes",
    				as: "value"
    			},
    			{
    				from: "id",
    				to: "new_edge",
    				as: "id"
    			},
    			{
    				from: "child",
    				to: "new_edge",
    				as: "child"
    			},
    			{
    				from: "child_as",
    				to: "new_edge",
    				as: "child_as"
    			},
    			{
    				from: "display_graph",
    				to: "add_node",
    				as: "graph"
    			},
    			{
    				from: "new_node",
    				to: "add_node",
    				as: "node"
    			},
    			{
    				from: "add_node",
    				to: "add_edge",
    				as: "graph"
    			},
    			{
    				from: "add_node",
    				to: "next_edge",
    				as: "graph"
    			},
    			{
    				from: "new_edge",
    				to: "next_edge",
    				as: "edge"
    			},
    			{
    				from: "next_edge",
    				to: "add_edge",
    				as: "edge"
    			},
    			{
    				from: "add_edge",
    				to: "effects",
    				as: "display_graph"
    			},
    			{
    				from: "update_sim_effect",
    				to: "effects",
    				as: "update_sim_effect"
    			},
    			{
    				from: "state",
    				to: "set_display_graph",
    				as: "target"
    			},
    			{
    				from: "display_graph_path",
    				to: "set_display_graph",
    				as: "path"
    			},
    			{
    				from: "add_node",
    				to: "set_display_graph",
    				as: "value"
    			},
    			{
    				from: "set_display_graph",
    				to: "set_selected",
    				as: "target"
    			},
    			{
    				from: "selected_path",
    				to: "set_selected",
    				as: "path"
    			},
    			{
    				from: "set_selected",
    				to: "set_history",
    				as: "target"
    			},
    			{
    				from: "history_path",
    				to: "set_history",
    				as: "path"
    			},
    			{
    				from: "new_history",
    				to: "set_history",
    				as: "value"
    			},
    			{
    				from: "id_array",
    				to: "new_selected",
    				as: "true"
    			},
    			{
    				from: "selected",
    				to: "new_selected",
    				as: "false"
    			},
    			{
    				from: "select",
    				to: "new_selected",
    				as: "pred"
    			},
    			{
    				from: "new_selected",
    				to: "set_selected",
    				as: "value"
    			},
    			{
    				from: "set_selected",
    				to: "effects",
    				as: "new_state"
    			},
    			{
    				from: "set_history",
    				to: "out",
    				as: "state"
    			},
    			{
    				from: "effects",
    				to: "out",
    				as: "effects"
    			}
    		]
    	},
    	{
    		id: "add_node",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "add_node_fn",
    				ref: "add_node_action"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out"
    			},
    			{
    				from: "add_node_fn",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "keybindings",
    		out: "out",
    		nodes: [
    			{
    				id: "editing"
    			},
    			{
    				id: "searching"
    			},
    			{
    				id: "graph"
    			},
    			{
    				id: "j",
    				value: "down"
    			},
    			{
    				id: "k",
    				value: "up"
    			},
    			{
    				value: "right",
    				id: "arrowright"
    			},
    			{
    				value: "left",
    				id: "arrowleft"
    			},
    			{
    				id: "arrowdown",
    				value: "down"
    			},
    			{
    				id: "arrowup",
    				value: "up"
    			},
    			{
    				value: "left",
    				id: "h"
    			},
    			{
    				value: "right",
    				id: "l"
    			},
    			{
    				value: "edit_value",
    				id: "v"
    			},
    			{
    				value: "edit_name",
    				id: "n"
    			},
    			{
    				value: "edit_ref",
    				id: "r"
    			},
    			{
    				value: "edit_script",
    				id: "s"
    			},
    			{
    				value: "edit_edge",
    				id: "e"
    			},
    			{
    				value: "node_menu",
    				id: "node_menu"
    			},
    			{
    				value: "create_input",
    				id: "create_input"
    			},
    			{
    				value: "delete",
    				id: "delete"
    			},
    			{
    				value: "find",
    				id: "find"
    			},
    			{
    				value: "esc_editing",
    				id: "esc_editing"
    			},
    			{
    				value: "clear_popover",
    				id: "esc"
    			},
    			{
    				value: "copy",
    				id: "y"
    			},
    			{
    				value: "copy",
    				id: "ctrl_c"
    			},
    			{
    				value: "paste",
    				id: "p"
    			},
    			{
    				value: "paste",
    				id: "ctrl_v"
    			},
    			{
    				value: "add_node",
    				id: "o"
    			},
    			{
    				value: "add_arg_node",
    				id: "a"
    			},
    			{
    				value: "delete_node",
    				id: "x"
    			},
    			{
    				value: "expand_contract",
    				id: "shift_enter"
    			},
    			{
    				value: "save",
    				id: "ctrl_s"
    			},
    			{
    				value: "undo",
    				id: "ctrl_z"
    			},
    			{
    				value: "redo",
    				id: "ctrl_y"
    			},
    			{
    				value: "select",
    				id: "enter"
    			},
    			{
    				value: "show_keybindings",
    				id: "?"
    			},
    			{
    				value: "find",
    				id: "f"
    			},
    			{
    				value: "cancel_search",
    				id: "esc_search"
    			},
    			{
    				id: "out"
    			}
    		],
    		edges: [
    			{
    				from: "editing",
    				to: "out",
    				as: "editing"
    			},
    			{
    				from: "searching",
    				to: "out",
    				as: "searching"
    			},
    			{
    				from: "graph",
    				to: "out",
    				as: "graph"
    			},
    			{
    				from: "arrowdown",
    				to: "graph",
    				as: "arrowdown"
    			},
    			{
    				from: "arrowup",
    				to: "graph",
    				as: "arrowup"
    			},
    			{
    				from: "arrowleft",
    				to: "graph",
    				as: "arrowleft"
    			},
    			{
    				from: "arrowright",
    				to: "graph",
    				as: "arrowright"
    			},
    			{
    				from: "j",
    				to: "graph",
    				as: "j"
    			},
    			{
    				from: "k",
    				to: "graph",
    				as: "k"
    			},
    			{
    				from: "h",
    				to: "graph",
    				as: "h"
    			},
    			{
    				from: "l",
    				to: "graph",
    				as: "l"
    			},
    			{
    				from: "v",
    				to: "graph",
    				as: "v"
    			},
    			{
    				from: "n",
    				to: "graph",
    				as: "n"
    			},
    			{
    				from: "s",
    				to: "graph",
    				as: "s"
    			},
    			{
    				from: "r",
    				to: "graph",
    				as: "r"
    			},
    			{
    				from: "o",
    				to: "graph",
    				as: "o"
    			},
    			{
    				from: "y",
    				to: "graph",
    				as: "y"
    			},
    			{
    				from: "p",
    				to: "graph",
    				as: "p"
    			},
    			{
    				from: "x",
    				to: "graph",
    				as: "x"
    			},
    			{
    				from: "a",
    				to: "graph",
    				as: "a"
    			},
    			{
    				from: "f",
    				to: "graph",
    				as: "f"
    			},
    			{
    				from: "e",
    				to: "graph",
    				as: "e"
    			},
    			{
    				from: "enter",
    				to: "graph",
    				as: "enter"
    			},
    			{
    				from: "ctrl_c",
    				to: "graph",
    				as: "ctrl_c"
    			},
    			{
    				from: "ctrl_v",
    				to: "graph",
    				as: "ctrl_v"
    			},
    			{
    				from: "ctrl_s",
    				to: "graph",
    				as: "ctrl_s"
    			},
    			{
    				from: "ctrl_z",
    				to: "graph",
    				as: "ctrl_z"
    			},
    			{
    				from: "ctrl_y",
    				to: "graph",
    				as: "ctrl_y"
    			},
    			{
    				from: "shift_enter",
    				to: "graph",
    				as: "shift_enter"
    			},
    			{
    				from: "esc_search",
    				to: "searching",
    				as: "escape"
    			}
    		]
    	},
    	{
    		id: "onkey_fn_body",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "key_event",
    				ref: "arg",
    				value: "payload"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "static",
    				ref: "arg",
    				value: "state.static"
    			},
    			{
    				id: "randid",
    				ref: "arg",
    				value: "state.randid"
    			},
    			{
    				id: "arg_levels",
    				ref: "arg",
    				value: "state.levels"
    			},
    			{
    				id: "dimensions",
    				ref: "arg",
    				value: "state.dimensions"
    			},
    			{
    				id: "html_id",
    				ref: "arg",
    				value: "state.html_id"
    			},
    			{
    				id: "arg_display_graph",
    				ref: "arg",
    				value: "state.display_graph"
    			},
    			{
    				id: "arg_display_graph_nodes",
    				ref: "arg",
    				value: "state.display_graph.nodes"
    			},
    			{
    				id: "display_graph_out",
    				ref: "arg",
    				value: "state.display_graph.out"
    			},
    			{
    				id: "nodes",
    				ref: "arg",
    				value: "state.nodes"
    			},
    			{
    				id: "edges",
    				ref: "arg",
    				value: "state.display_graph.edges"
    			},
    			{
    				id: "links",
    				ref: "arg",
    				value: "state.links"
    			},
    			{
    				id: "editing",
    				ref: "arg",
    				value: "state.editing"
    			},
    			{
    				id: "search",
    				ref: "arg",
    				value: "state.search"
    			},
    			{
    				id: "selected",
    				ref: "arg",
    				value: "state.selected.0"
    			},
    			{
    				id: "arg_selected_edge",
    				ref: "arg",
    				value: "state.selected_edge"
    			},
    			{
    				id: "add_node_effect",
    				ref: "add_node"
    			},
    			{
    				id: "add_edge_effect",
    				ref: "add_edge"
    			},
    			{
    				id: "delete_node_effect",
    				ref: "delete_node"
    			},
    			{
    				id: "save_effect",
    				ref: "save_effect"
    			},
    			{
    				id: "show_edit_text",
    				ref: "show_edit_text"
    			},
    			{
    				id: "update_node",
    				ref: "update_node_action"
    			},
    			{
    				id: "open_reference_popover",
    				ref: "open_reference_popover"
    			},
    			{
    				id: "confirm_edit_text",
    				ref: "confirm_edit_text"
    			},
    			{
    				id: "onselectnode_effect",
    				ref: "onselectnode_effect"
    			},
    			{
    				id: "update_edge",
    				ref: "update_edge_action"
    			},
    			{
    				id: "onselectnode_action",
    				ref: "onselectnode_action"
    			},
    			{
    				id: "search_effect",
    				ref: "search_effect"
    			},
    			{
    				id: "focus_effect",
    				ref: "focus_effect"
    			},
    			{
    				id: "blur_effect",
    				ref: "blur_effect"
    			},
    			{
    				id: "stop_propagation",
    				ref: "stop_propagation_effect"
    			},
    			{
    				id: "copy_effect",
    				ref: "copy_effect"
    			},
    			{
    				id: "paste_effect",
    				ref: "paste_node_effect"
    			},
    			{
    				id: "expand_contract_effect",
    				ref: "expand_contract_effect"
    			},
    			{
    				id: "run_display_graph_effector",
    				ref: "run_display_graph_effect"
    			},
    			{
    				id: "run_display_graph_effect",
    				ref: "array"
    			},
    			{
    				id: "keybindings",
    				ref: "keybindings"
    			},
    			{
    				id: "mode",
    				script: "return editing !== false ? 'editing' : search !== false ? 'searching' : 'graph'"
    			},
    			{
    				id: "mode_keybindings",
    				ref: "get"
    			},
    			{
    				id: "key_action_effect",
    				ref: "get"
    			},
    			{
    				id: "effects_map",
    				ref: "switch"
    			},
    			{
    				id: "actions_map",
    				ref: "switch"
    			},
    			{
    				id: "key",
    				script: "return ev.key?.toLowerCase()"
    			},
    			{
    				id: "key_inputs",
    				script: "return (ev.ctrlKey ? 'ctrl_' : '') + (ev.shiftKey ? 'shift_' : '') + ev.key.toLowerCase()"
    			},
    			{
    				id: "selected_node",
    				ref: "find_node"
    			},
    			{
    				id: "edge_out",
    				script: "return edges.find(e => e.from === node_id)"
    			},
    			{
    				id: "el_node",
    				script: "return nodes.find(n => n.node_id === node_id)"
    			},
    			{
    				id: "save",
    				script: "return [[save_effect, {display_graph}]]"
    			},
    			{
    				id: "undo",
    				ref: "undo_action"
    			},
    			{
    				id: "redo",
    				ref: "redo_action"
    			},
    			{
    				id: "down",
    				script: "const next_node_edge = display_graph.edges.find(e => e.from === selected); return next_node_edge ? {state: {...state, selected: [next_node_edge.to]}, effects: [[stop_propagation, event], [state.panzoom_selected_effect, {...state, selected: [next_node_edge.to]}], [state.update_hyperapp]]} : {state, effects: [[stop_propagation, event]]}"
    			},
    			{
    				id: "up",
    				script: "const next_edges = display_graph.edges.filter(e => e.to === selected); const next_node_edge = next_edges[Math.ceil(next_edges.length / 2) - 1]; return next_node_edge ? {state: {...state, selected: [next_node_edge.from]}, effects: [[stop_propagation, event], [state.panzoom_selected_effect, {...state, selected: [next_node_edge.from]}], [state.update_hyperapp]]} : {state, effects: [[stop_propagation, event]]}"
    			},
    			{
    				id: "left",
    				script: "const current_node = nodes.find(n => n.node_id === selected); const siblings = levels.siblings.get(selected); const next_node = static ? nodes.find(n => n.node_id === siblings[(siblings.findIndex(s => s === selected) - 1 + siblings.length) % siblings.length]): siblings.reduce((dist, sibling) => { const sibling_node = nodes.find(n => n.node_id === sibling); if(!sibling_node){ return dist } const xdist = Math.abs(sibling_node.x - current_node.x); dist = (sibling_node.x < current_node.x) && xdist < dist[0] ? [xdist, sibling_node] : dist; return dist }, [dimensions.x])[1]; return next_node ? {state: {...state, selected: [next_node.node_id]}, effects: [[stop_propagation, event], [state.panzoom_selected_effect, {...state, selected: next_node.node_id}], [state.update_hyperapp]]} : {state, effects: [[stop_propagation, event]]}"
    			},
    			{
    				id: "left_edge",
    				script: "const link = links.find(l => l.source.node_child_id === selected_edge.from + '_' + selected_edge.to); return links.filter(l => l.target.node_id === link.target.node_id).reduce(([current, dist], l) => l.source.x < link.source.x && Math.abs(l.source.x - link.source.x) < dist ? [{from: l.source.node_id, to: l.target.node_id} , Math.abs(l.source.x - link.source.x)] : [current, dist], [selected_edge, 10000])[0]"
    			},
    			{
    				id: "right",
    				script: "const current_node = nodes.find(n => n.node_id === selected); const siblings = levels.siblings.get(selected); const next_node = static ? nodes.find(n => n.node_id === siblings[(siblings.findIndex(s => s === selected) + 1) % siblings.length]) : siblings.reduce((dist, sibling) => { const sibling_node = nodes.find(n => n.node_id === sibling); if(!sibling_node){ return dist } const xdist = Math.abs(sibling_node.x - current_node.x); dist = sibling_node.x > current_node.x && xdist < dist[0] ? [xdist, sibling_node] : dist; return dist }, [dimensions.x])[1]; return next_node ? {state: {...state, selected: [next_node.node_id]}, effects: [[stop_propagation, event], [state.panzoom_selected_effect, {...state, selected: next_node.node_id}], [state.update_hyperapp]]} : {state, effects: [[stop_propagation, event]]}"
    			},
    			{
    				id: "right_edge",
    				script: "const link = links.find(l => l.source.node_child_id === selected_edge.from + '_' + selected_edge.to); return links.filter(l => l.target.node_id === link.target.node_id).reduce(([current, dist], l) => l.source.x > link.source.x && Math.abs(l.source.x - link.source.x) < dist ? [{from: l.source.node_id, to: l.target.node_id} , Math.abs(l.source.x - link.source.x)] : [current, dist], [{to: link.target.node_id, from: link.source.node_id}, 10000])[0]"
    			},
    			{
    				id: "edit_value",
    				script: "return [[show_edit_text, {id, property:'value', oneditconfirm: update_node, value: selected_node.value, position: {x: node.x, y: node.y}}]]"
    			},
    			{
    				id: "edit_name",
    				script: "return [[show_edit_text, {id, property:'name', oneditconfirm: update_node, value: selected_node.name, position: {x: node.x, y: node.y}}]]"
    			},
    			{
    				id: "edit_ref",
    				script: "return [[show_edit_text, {id, property: 'ref', oneditconfirm: update_node, value: selected_node.ref, position: {x: node.x, y: node.y}}]]"
    			},
    			{
    				id: "edit_script",
    				script: "return [[show_edit_text, {id, property:'script', oneditconfirm: update_node, value: selected_node.script, position: {x: node.x, y: node.y}}]]"
    			},
    			{
    				id: "edit_edge",
    				script: "return [[show_edit_text, {id: edge, property: 'as', oneditconfirm: update_edge, value: edge.as, position: {x: node.x, y: node.y}}]]"
    			},
    			{
    				id: "select",
    				script: "return [[onselectnode, {node_id, event}]]"
    			},
    			{
    				id: "add_node",
    				script: "return [[add_node, {node: {id: randid}, select: true, child: selected}]]"
    			},
    			{
    				id: "delete_node",
    				script: "return [[delete_node, {id: selected}]]"
    			},
    			{
    				id: "copy",
    				script: "return [[copy_effect, {id}]]"
    			},
    			{
    				id: "paste",
    				script: "return [[paste_effect, {node_id: id, randid}]]"
    			},
    			{
    				id: "expand_contract",
    				script: "return [[expand_contract, {id}]]"
    			},
    			{
    				id: "add_arg_node",
    				script: "return [[add_node, {node: {id: randid, ref: 'arg'}, select: true, child: selected}], [show_edit_text, {id: randid, property:'value', oneditconfirm: update_node, value: ''}]]"
    			},
    			{
    				id: "find",
    				args: [
    				],
    				script: "return [[search, {search: ''}], [focus, {selector: `#${html_id}-search-input`}]]"
    			},
    			{
    				id: "cancel_search",
    				script: "return [[search, {search: false}], [blur, {selector: `#${html_id}-search-input`}]]"
    			},
    			{
    				id: "e",
    				script: "return selected_edge ? null : display_graph.edges.find(e => e.to === selected);"
    			},
    			{
    				id: "esc_editing",
    				script: "return [[confirm_edit_text]]"
    			},
    			{
    				id: "esc",
    				script: "return [[onselectnode, {node_id, event}]]"
    			},
    			{
    				id: "panzoom_selected_id",
    				script: "return selected"
    			},
    			{
    				id: "panzoom_selected_effector",
    				ref: "arg",
    				value: "state.panzoom_selected_effect"
    			},
    			{
    				id: "panzoom_selected_effect",
    				ref: "array"
    			},
    			{
    				id: "panzoom_selected_effect_arr",
    				ref: "array"
    			},
    			{
    				id: "panzoom_selected_payload"
    			},
    			{
    				id: "set_clipboard",
    				script: "state.clipboard = clipboard ? clipboard : state.clipboard; return state"
    			},
    			{
    				id: "graph_effects",
    				ref: "switch"
    			},
    			{
    				id: "update_effects_input",
    				script: "return typeof search === 'string' ? 'search' : 'graph'"
    			},
    			{
    				id: "update_effects",
    				ref: "switch"
    			},
    			{
    				id: "editing_effects",
    				ref: "switch"
    			},
    			{
    				id: "effects",
    				ref: "switch"
    			},
    			{
    				id: "update_graph_sim",
    				script: "return (!state.editing && state.search === false && (key === 'enter' || key.toLowerCase() === 'o' || key === 'x' || (key === 't' && shiftKey) || (!!pending_edges.edge_to && !!pending_edges.edge_from))) || key === 'escape' || selected"
    			},
    			{
    				id: "graph_state"
    			},
    			{
    				id: "search_state"
    			},
    			{
    				id: "update_state",
    				ref: "switch"
    			},
    			{
    				id: "no_update"
    			},
    			{
    				id: "update",
    				ref: "update_graph_display"
    			},
    			{
    				id: "update_effector",
    				ref: "hyperapp_action_effect"
    			},
    			{
    				id: "update_effect",
    				ref: "array"
    			},
    			{
    				id: "default_fx",
    				ref: "array"
    			},
    			{
    				id: "default_out"
    			},
    			{
    				id: "out_effects"
    			},
    			{
    				id: "out_action_effect",
    				ref: "default"
    			},
    			{
    				id: "out_pred",
    				script: "return action || effect"
    			},
    			{
    				id: "out",
    				ref: "if"
    			}
    		],
    		edges: [
    			{
    				from: "randid",
    				to: "add_node",
    				as: "randid"
    			},
    			{
    				from: "selected",
    				to: "add_node",
    				as: "selected"
    			},
    			{
    				from: "add_edge_effect",
    				to: "add_node",
    				as: "add_edge"
    			},
    			{
    				from: "add_node_effect",
    				to: "add_node",
    				as: "add_node"
    			},
    			{
    				from: "selected",
    				to: "copy",
    				as: "id"
    			},
    			{
    				from: "copy_effect",
    				to: "copy",
    				as: "copy_effect"
    			},
    			{
    				from: "selected",
    				to: "paste",
    				as: "id"
    			},
    			{
    				from: "randid",
    				to: "paste",
    				as: "randid"
    			},
    			{
    				from: "paste_effect",
    				to: "paste",
    				as: "paste_effect"
    			},
    			{
    				from: "selected",
    				to: "expand_contract",
    				as: "id"
    			},
    			{
    				from: "expand_contract_effect",
    				to: "expand_contract",
    				as: "expand_contract"
    			},
    			{
    				from: "randid",
    				to: "add_arg_node",
    				as: "randid"
    			},
    			{
    				from: "selected",
    				to: "add_arg_node",
    				as: "selected"
    			},
    			{
    				from: "add_edge_effect",
    				to: "add_arg_node",
    				as: "add_edge"
    			},
    			{
    				from: "add_node_effect",
    				to: "add_arg_node",
    				as: "add_node"
    			},
    			{
    				from: "show_edit_text",
    				to: "add_arg_node",
    				as: "show_edit_text"
    			},
    			{
    				from: "update_node",
    				to: "add_arg_node",
    				as: "update_node"
    			},
    			{
    				from: "edit_value",
    				to: "effects_map",
    				as: "edit_value"
    			},
    			{
    				from: "edit_name",
    				to: "effects_map",
    				as: "edit_name"
    			},
    			{
    				from: "edit_ref",
    				to: "effects_map",
    				as: "edit_ref"
    			},
    			{
    				from: "edit_script",
    				to: "effects_map",
    				as: "edit_script"
    			},
    			{
    				from: "edit_edge",
    				to: "effects_map",
    				as: "edit_edge"
    			},
    			{
    				from: "add_node",
    				to: "effects_map",
    				as: "add_node"
    			},
    			{
    				from: "add_arg_node",
    				to: "effects_map",
    				as: "add_arg_node"
    			},
    			{
    				from: "delete_node",
    				to: "effects_map",
    				as: "delete_node"
    			},
    			{
    				from: "copy",
    				to: "effects_map",
    				as: "copy"
    			},
    			{
    				from: "paste",
    				to: "effects_map",
    				as: "paste"
    			},
    			{
    				from: "expand_contract",
    				to: "effects_map",
    				as: "expand_contract"
    			},
    			{
    				from: "save",
    				to: "effects_map",
    				as: "save"
    			},
    			{
    				from: "cancel_search",
    				to: "effects_map",
    				as: "cancel_search"
    			},
    			{
    				from: "find",
    				to: "effects_map",
    				as: "find"
    			},
    			{
    				from: "select",
    				to: "effects_map",
    				as: "select"
    			},
    			{
    				from: "undo",
    				to: "actions_map",
    				as: "undo"
    			},
    			{
    				from: "redo",
    				to: "actions_map",
    				as: "redo"
    			},
    			{
    				from: "down",
    				to: "actions_map",
    				as: "down"
    			},
    			{
    				from: "up",
    				to: "actions_map",
    				as: "up"
    			},
    			{
    				from: "left",
    				to: "actions_map",
    				as: "left"
    			},
    			{
    				from: "right",
    				to: "actions_map",
    				as: "right"
    			},
    			{
    				from: "editing",
    				to: "mode",
    				as: "editing"
    			},
    			{
    				from: "search",
    				to: "mode",
    				as: "search"
    			},
    			{
    				from: "keybindings",
    				to: "mode_keybindings",
    				as: "target"
    			},
    			{
    				from: "mode",
    				to: "mode_keybindings",
    				as: "path"
    			},
    			{
    				from: "mode_keybindings",
    				to: "key_action_effect",
    				as: "target"
    			},
    			{
    				from: "key_inputs",
    				to: "key_action_effect",
    				as: "path"
    			},
    			{
    				from: "key_action_effect",
    				to: "effects_map",
    				as: "input"
    			},
    			{
    				from: "effects_map",
    				to: "out_effects",
    				as: "effects"
    			},
    			{
    				from: "state",
    				to: "out_effects",
    				as: "state"
    			},
    			{
    				from: "out_effects",
    				to: "out_action_effect",
    				as: "otherwise"
    			},
    			{
    				from: "key_action_effect",
    				to: "actions_map",
    				as: "input"
    			},
    			{
    				from: "actions_map",
    				to: "out_action_effect",
    				as: "value"
    			},
    			{
    				from: "out_action_effect",
    				to: "out",
    				as: "true"
    			},
    			{
    				from: "state",
    				to: "default_out",
    				as: "state"
    			},
    			{
    				from: "actions_map",
    				to: "out_pred",
    				as: "action"
    			},
    			{
    				from: "effects_map",
    				to: "out_pred",
    				as: "effect"
    			},
    			{
    				from: "run_display_graph_effector",
    				to: "run_display_graph_effect",
    				as: "a0"
    			},
    			{
    				from: "key_event",
    				to: "run_display_graph_effect",
    				as: "a1"
    			},
    			{
    				from: "run_display_graph_effect",
    				to: "_default_fx",
    				as: "a0"
    			},
    			{
    				from: "update",
    				to: "update_effector",
    				as: "fn",
    				type: "ref"
    			},
    			{
    				from: "update_effector",
    				to: "update_effect",
    				as: "a0"
    			},
    			{
    				from: "key_event",
    				to: "update_effect",
    				as: "a1"
    			},
    			{
    				from: "update_effect",
    				to: "default_fx",
    				as: "a0"
    			},
    			{
    				from: "default_fx",
    				to: "default_out",
    				as: "effects"
    			},
    			{
    				from: "out_pred",
    				to: "out",
    				as: "pred"
    			},
    			{
    				from: "default_out",
    				to: "out",
    				as: "false"
    			},
    			{
    				from: "state",
    				to: "key_inputs",
    				as: "state"
    			},
    			{
    				from: "key_event",
    				to: "key",
    				as: "ev"
    			},
    			{
    				from: "state",
    				to: "key_inputs",
    				as: "state"
    			},
    			{
    				from: "key_event",
    				to: "key_inputs",
    				as: "ev"
    			},
    			{
    				from: "arg_display_graph_nodes",
    				to: "selected_node",
    				as: "nodes"
    			},
    			{
    				from: "selected",
    				to: "selected_node",
    				as: "node_id"
    			},
    			{
    				from: "nodes",
    				to: "el_node",
    				as: "nodes"
    			},
    			{
    				from: "selected",
    				to: "el_node",
    				as: "node_id"
    			},
    			{
    				from: "edges",
    				to: "edge_out",
    				as: "edges"
    			},
    			{
    				from: "selected",
    				to: "edge_out",
    				as: "node_id"
    			},
    			{
    				from: "key_event",
    				to: "run"
    			},
    			{
    				from: "key_inputs",
    				to: "graph_effects",
    				as: "input"
    			},
    			{
    				from: "key_inputs",
    				to: "editing_effects",
    				as: "input"
    			},
    			{
    				from: "state",
    				to: "calculate_levels",
    				as: "state"
    			},
    			{
    				from: "selected",
    				to: "calculate_levels",
    				as: "selected"
    			},
    			{
    				from: "display_graph",
    				to: "calculate_levels",
    				as: "display_graph"
    			},
    			{
    				from: "key_inputs",
    				to: "edit_value",
    				as: "input"
    			},
    			{
    				from: "key_inputs",
    				to: "display_graph",
    				as: "input"
    			},
    			{
    				from: "key_inputs",
    				to: "clipboard",
    				as: "input"
    			},
    			{
    				from: "key_inputs",
    				to: "show_all",
    				as: "input"
    			},
    			{
    				from: "key_inputs",
    				to: "show_result",
    				as: "input"
    			},
    			{
    				from: "arg_display_graph",
    				to: "save",
    				as: "display_graph"
    			},
    			{
    				from: "save_effect",
    				to: "save",
    				as: "save_effect"
    			},
    			{
    				from: "onselectnode_action",
    				to: "up",
    				as: "onselectnode"
    			},
    			{
    				from: "state",
    				to: "up",
    				as: "state"
    			},
    			{
    				from: "selected",
    				to: "up",
    				as: "selected"
    			},
    			{
    				from: "arg_display_graph",
    				to: "up",
    				as: "display_graph"
    			},
    			{
    				from: "key_event",
    				to: "up",
    				as: "event"
    			},
    			{
    				from: "stop_propagation",
    				to: "up",
    				as: "stop_propagation"
    			},
    			{
    				from: "key_event",
    				to: "down",
    				as: "event"
    			},
    			{
    				from: "stop_propagation",
    				to: "down",
    				as: "stop_propagation"
    			},
    			{
    				from: "onselectnode_action",
    				to: "down",
    				as: "onselectnode"
    			},
    			{
    				from: "state",
    				to: "down",
    				as: "state"
    			},
    			{
    				from: "selected",
    				to: "down",
    				as: "selected"
    			},
    			{
    				from: "arg_display_graph",
    				to: "down",
    				as: "display_graph"
    			},
    			{
    				from: "show_edit_text",
    				to: "edit_value",
    				as: "show_edit_text"
    			},
    			{
    				from: "update_node",
    				to: "edit_value",
    				as: "update_node"
    			},
    			{
    				from: "el_node",
    				to: "edit_value",
    				as: "node"
    			},
    			{
    				from: "selected_node",
    				to: "edit_value",
    				as: "selected_node"
    			},
    			{
    				from: "selected",
    				to: "edit_value",
    				as: "id"
    			},
    			{
    				from: "edit_value",
    				to: "graph_effects",
    				as: "edit_value"
    			},
    			{
    				from: "selected_node",
    				to: "edit_name",
    				as: "selected_node"
    			},
    			{
    				from: "show_edit_text",
    				to: "edit_name",
    				as: "show_edit_text"
    			},
    			{
    				from: "update_node",
    				to: "edit_name",
    				as: "update_node"
    			},
    			{
    				from: "el_node",
    				to: "edit_name",
    				as: "node"
    			},
    			{
    				from: "selected",
    				to: "edit_name",
    				as: "id"
    			},
    			{
    				from: "edit_name",
    				to: "graph_effects",
    				as: "edit_name"
    			},
    			{
    				from: "el_node",
    				to: "edit_ref",
    				as: "node"
    			},
    			{
    				from: "selected_node",
    				to: "edit_ref",
    				as: "selected_node"
    			},
    			{
    				from: "show_edit_text",
    				to: "edit_ref",
    				as: "show_edit_text"
    			},
    			{
    				from: "update_node",
    				to: "edit_ref",
    				as: "update_node"
    			},
    			{
    				from: "selected",
    				to: "edit_ref",
    				as: "id"
    			},
    			{
    				from: "el_node",
    				to: "edit_script",
    				as: "node"
    			},
    			{
    				from: "show_edit_text",
    				to: "edit_script",
    				as: "show_edit_text"
    			},
    			{
    				from: "update_node",
    				to: "edit_script",
    				as: "update_node"
    			},
    			{
    				from: "selected_node",
    				to: "edit_script",
    				as: "selected_node"
    			},
    			{
    				from: "selected",
    				to: "edit_script",
    				as: "id"
    			},
    			{
    				from: "el_node",
    				to: "edit_edge",
    				as: "node"
    			},
    			{
    				from: "edge_out",
    				to: "edit_edge",
    				as: "edge"
    			},
    			{
    				from: "show_edit_text",
    				to: "edit_edge",
    				as: "show_edit_text"
    			},
    			{
    				from: "update_edge",
    				to: "edit_edge",
    				as: "update_edge"
    			},
    			{
    				from: "el_node",
    				to: "edit_edge",
    				as: "node"
    			},
    			{
    				from: "edit_ref",
    				to: "graph_effects",
    				as: "edit_ref"
    			},
    			{
    				from: "show_edit_text",
    				to: "s",
    				as: "show_edit_text"
    			},
    			{
    				from: "update_node",
    				to: "s",
    				as: "update_node"
    			},
    			{
    				from: "el_node",
    				to: "s",
    				as: "node"
    			},
    			{
    				from: "selected_node",
    				to: "s",
    				as: "selected_node"
    			},
    			{
    				from: "s",
    				to: "graph_effects",
    				as: "s"
    			},
    			{
    				from: "add_node_effect",
    				to: "a",
    				as: "add_node"
    			},
    			{
    				from: "show_edit_text",
    				to: "a",
    				as: "show_edit_text"
    			},
    			{
    				from: "update_node",
    				to: "a",
    				as: "update_node"
    			},
    			{
    				from: "el_node",
    				to: "a",
    				as: "node"
    			},
    			{
    				from: "add_edge_effect",
    				to: "a",
    				as: "add_edge"
    			},
    			{
    				from: "randid",
    				to: "a",
    				as: "randid"
    			},
    			{
    				from: "a",
    				to: "graph_effects",
    				as: "a"
    			},
    			{
    				from: "selected",
    				to: "select",
    				as: "node_id"
    			},
    			{
    				from: "onselectnode_effect",
    				to: "select",
    				as: "onselectnode"
    			},
    			{
    				from: "key_event",
    				to: "select",
    				as: "event"
    			},
    			{
    				from: "key_event",
    				to: "t"
    			},
    			{
    				from: "state",
    				to: "t"
    			},
    			{
    				from: "key_event",
    				to: "shift_t"
    			},
    			{
    				from: "state",
    				to: "shift_t"
    			},
    			{
    				from: "html_id",
    				to: "s",
    				as: "html_id"
    			},
    			{
    				from: "html_id",
    				to: "f",
    				as: "html_id"
    			},
    			{
    				from: "focus_effect",
    				to: "f",
    				as: "focus_effect"
    			},
    			{
    				from: "html_id",
    				to: "t",
    				as: "html_id"
    			},
    			{
    				from: "html_id",
    				to: "set_selected",
    				as: "html_id"
    			},
    			{
    				from: "html_id",
    				to: "esc_search",
    				as: "html_id"
    			},
    			{
    				from: "key_event",
    				to: "s"
    			},
    			{
    				from: "state",
    				to: "s"
    			},
    			{
    				from: "state",
    				to: "p"
    			},
    			{
    				from: "state",
    				to: "q"
    			},
    			{
    				from: "key_event",
    				to: "n"
    			},
    			{
    				from: "state",
    				to: "n"
    			},
    			{
    				from: "key_event",
    				to: "a"
    			},
    			{
    				from: "state",
    				to: "a"
    			},
    			{
    				from: "selected",
    				to: "delete_node",
    				as: "selected"
    			},
    			{
    				from: "delete_node_effect",
    				to: "delete_node",
    				as: "delete_node"
    			},
    			{
    				from: "randid",
    				to: "o",
    				as: "randid"
    			},
    			{
    				from: "selected",
    				to: "o",
    				as: "selected"
    			},
    			{
    				from: "add_edge_effect",
    				to: "o",
    				as: "add_edge"
    			},
    			{
    				from: "state",
    				to: "i",
    				as: "state"
    			},
    			{
    				from: "state",
    				to: "e"
    			},
    			{
    				from: "selected_node",
    				to: "y",
    				as: "node"
    			},
    			{
    				from: "key_event",
    				to: "left",
    				as: "event"
    			},
    			{
    				from: "dimensions",
    				to: "left",
    				as: "dimensions"
    			},
    			{
    				from: "links",
    				to: "left",
    				as: "links"
    			},
    			{
    				from: "arg_levels",
    				to: "left",
    				as: "levels"
    			},
    			{
    				from: "selected",
    				to: "left",
    				as: "selected"
    			},
    			{
    				from: "arg_selected_edge",
    				to: "left",
    				as: "selected_edge"
    			},
    			{
    				from: "arg_display_graph",
    				to: "left",
    				as: "display_graph"
    			},
    			{
    				from: "nodes",
    				to: "left",
    				as: "nodes"
    			},
    			{
    				from: "onselectnode_action",
    				to: "left",
    				as: "onselectnode"
    			},
    			{
    				from: "state",
    				to: "left",
    				as: "state"
    			},
    			{
    				from: "static",
    				to: "left",
    				as: "static"
    			},
    			{
    				from: "stop_propagation",
    				to: "left",
    				as: "stop_propagation"
    			},
    			{
    				from: "static",
    				to: "right",
    				as: "static"
    			},
    			{
    				from: "stop_propagation",
    				to: "right",
    				as: "stop_propagation"
    			},
    			{
    				from: "key_event",
    				to: "right",
    				as: "event"
    			},
    			{
    				from: "dimensions",
    				to: "right",
    				as: "dimensions"
    			},
    			{
    				from: "nodes",
    				to: "right",
    				as: "nodes"
    			},
    			{
    				from: "links",
    				to: "right",
    				as: "links"
    			},
    			{
    				from: "arg_levels",
    				to: "right",
    				as: "levels"
    			},
    			{
    				from: "selected",
    				to: "right",
    				as: "selected"
    			},
    			{
    				from: "arg_selected_edge",
    				to: "right",
    				as: "selected_edge"
    			},
    			{
    				from: "arg_display_graph",
    				to: "right",
    				as: "display_graph"
    			},
    			{
    				from: "onselectnode_action",
    				to: "right",
    				as: "onselectnode"
    			},
    			{
    				from: "state",
    				to: "right",
    				as: "state"
    			},
    			{
    				from: "static",
    				to: "right_edge",
    				as: "static"
    			},
    			{
    				from: "dimensions",
    				to: "right_edge",
    				as: "dimensions"
    			},
    			{
    				from: "nodes",
    				to: "right_edge",
    				as: "nodes"
    			},
    			{
    				from: "links",
    				to: "right_edge",
    				as: "links"
    			},
    			{
    				from: "arg_levels",
    				to: "right_edge",
    				as: "levels"
    			},
    			{
    				from: "selected",
    				to: "right_edge",
    				as: "selected"
    			},
    			{
    				from: "arg_selected_edge",
    				to: "right_edge",
    				as: "selected_edge"
    			},
    			{
    				from: "arg_display_graph",
    				to: "right_edge",
    				as: "display_graph"
    			},
    			{
    				from: "right_edge",
    				to: "selected_edge",
    				as: "arrowright"
    			},
    			{
    				from: "right_edge",
    				to: "selected_edge",
    				as: "l"
    			},
    			{
    				from: "selected_edge",
    				to: "set_selected_edge",
    				as: "selected_edge"
    			},
    			{
    				from: "state",
    				to: "pending_edges",
    				as: "state"
    			},
    			{
    				from: "key_event",
    				to: "pending_edges"
    			},
    			{
    				from: "pending_edges",
    				to: "make_edge",
    				as: "pending_edges"
    			},
    			{
    				from: "pending_edges",
    				to: "set_pending_edges",
    				as: "pending_edges"
    			},
    			{
    				from: "state",
    				to: "make_edge",
    				as: "state"
    			},
    			{
    				from: "q",
    				to: "show_all",
    				as: "q"
    			},
    			{
    				from: "i",
    				to: "show_result",
    				as: "i"
    			},
    			{
    				from: "confirm_edit_text",
    				to: "esc_editing",
    				as: "confirm_edit_text"
    			},
    			{
    				from: "esc_editing",
    				to: "editing_effects",
    				as: "escape"
    			},
    			{
    				from: "html_id",
    				to: "cancel_search",
    				as: "html_id"
    			},
    			{
    				from: "search_effect",
    				to: "cancel_search",
    				as: "search"
    			},
    			{
    				from: "blur_effect",
    				to: "cancel_search",
    				as: "blur"
    			},
    			{
    				from: "html_id",
    				to: "find",
    				as: "html_id"
    			},
    			{
    				from: "focus_effect",
    				to: "find",
    				as: "focus"
    			},
    			{
    				from: "search_effect",
    				to: "find",
    				as: "search"
    			}
    		]
    	},
    	{
    		id: "simulation",
    		ref: "arg",
    		value: "simulation"
    	},
    	{
    		id: "arg_nodes",
    		ref: "arg",
    		value: "nodes"
    	},
    	{
    		id: "arg_links",
    		ref: "arg",
    		value: "links"
    	},
    	{
    		id: "arg_selected",
    		ref: "arg",
    		value: "selected"
    	},
    	{
    		id: "arg_levels",
    		ref: "arg",
    		value: "levels"
    	},
    	{
    		id: "update_sim_effect",
    		script: "return (dispatch, payload) => payload ? !(payload.simulation || payload.static) ? undefined : _lib.scripts.updateSimulationNodes(dispatch, payload) : dispatch(state => [state, [() => !(state.simulation || state.static) ? undefined : _lib.scripts.updateSimulationNodes(dispatch, state)]])"
    	},
    	{
    		id: "update_sim_in"
    	},
    	{
    		id: "update_sim_fn",
    		ref: "execute_graph"
    	},
    	{
    		id: "_update_sim_effect",
    		ref: "wrap_effect_fn"
    	},
    	{
    		id: "stop_propagation_effect",
    		script: "return (_, payload) => {payload.stopPropagation(); payload.preventDefault();}"
    	},
    	{
    		id: "dispatch_custom_event_effect",
    		script: "return (_, payload) => document.getElementById(`${payload.html_id}`).dispatchEvent(new CustomEvent(payload.event, {detail: payload.detail}))"
    	},
    	{
    		id: "search_effect",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "search",
    				ref: "arg",
    				value: "payload.search"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "search_path",
    				value: "search"
    			},
    			{
    				id: "set_search",
    				ref: "set"
    			},
    			{
    				id: "result"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args",
    				type: "ref"
    			},
    			{
    				from: "state",
    				to: "set_search",
    				as: "target"
    			},
    			{
    				from: "search_path",
    				to: "set_search",
    				as: "path"
    			},
    			{
    				from: "search",
    				to: "set_search",
    				as: "value"
    			},
    			{
    				from: "set_search",
    				to: "result",
    				as: "state"
    			},
    			{
    				from: "result",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "create_object_graph",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "in_obj",
    				ref: "arg",
    				value: "obj"
    			},
    			{
    				id: "name",
    				ref: "arg",
    				value: "name"
    			},
    			{
    				id: "map_obj",
    				script: "return _lib.no.objToGraph(obj)"
    			},
    			{
    				id: "out_node_id",
    				script: "return Object.keys(obj)[0]"
    			},
    			{
    				id: "out"
    			}
    		],
    		edges: [
    			{
    				from: "in_obj",
    				to: "map_obj",
    				as: "obj"
    			},
    			{
    				from: "in_obj",
    				to: "out_node_id",
    				as: "obj"
    			},
    			{
    				from: "name",
    				to: "out_node",
    				as: "name"
    			},
    			{
    				from: "map_obj",
    				to: "out"
    			},
    			{
    				from: "in",
    				to: "out",
    				as: "args",
    				type: "ref"
    			},
    			{
    				from: "out_node_id",
    				to: "out",
    				as: "out"
    			}
    		]
    	},
    	{
    		id: "create_popover_graph",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "in_nodes",
    				ref: "arg",
    				value: "nodes"
    			},
    			{
    				id: "name",
    				ref: "arg",
    				value: "name"
    			},
    			{
    				id: "clear_popover",
    				ref: "clear_popover_graph"
    			},
    			{
    				id: "out_node",
    				script: "return {'id': 'out', name, value: [[clear_popover]]}"
    			},
    			{
    				id: "out_node_id",
    				value: "out"
    			},
    			{
    				id: "edges",
    				script: "return nodes.map(n => ({from: n.id, to: 'out', _needsresolve: true}))"
    			},
    			{
    				id: "nodes",
    				ref: "append"
    			},
    			{
    				id: "out"
    			}
    		],
    		edges: [
    			{
    				from: "clear_popover",
    				to: "out_node",
    				as: "clear_popover"
    			},
    			{
    				from: "name",
    				to: "out_node",
    				as: "name"
    			},
    			{
    				from: "out_node",
    				to: "nodes",
    				as: "item"
    			},
    			{
    				from: "in_nodes",
    				to: "nodes",
    				as: "array"
    			},
    			{
    				from: "in_nodes",
    				to: "edges",
    				as: "nodes"
    			},
    			{
    				from: "in",
    				to: "out",
    				as: "args",
    				type: "ref"
    			},
    			{
    				from: "nodes",
    				to: "out",
    				as: "nodes"
    			},
    			{
    				from: "edges",
    				to: "out",
    				as: "edges"
    			},
    			{
    				from: "out_node_id",
    				to: "out",
    				as: "out"
    			}
    		]
    	},
    	{
    		id: "graph_ui_action",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "payload",
    				ref: "arg",
    				value: "payload"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "name",
    				ref: "arg",
    				value: "state.display_graph.id"
    			},
    			{
    				id: "display_graph",
    				ref: "arg",
    				value: "state.display_graph"
    			},
    			{
    				id: "readonly",
    				ref: "arg",
    				value: "state.readonly"
    			},
    			{
    				id: "html_id",
    				ref: "arg",
    				value: "state.html_id"
    			},
    			{
    				id: "examples",
    				ref: "arg",
    				value: "state.examples"
    			},
    			{
    				id: "event_name",
    				value: "graphclick"
    			},
    			{
    				id: "id_path",
    				value: "id"
    			},
    			{
    				id: "clear_popover",
    				ref: "clear_popover_graph"
    			},
    			{
    				id: "clear_popover_effect",
    				ref: "array"
    			},
    			{
    				id: "save_effector",
    				ref: "save_effect"
    			},
    			{
    				id: "save_payload"
    			},
    			{
    				id: "save_effect",
    				ref: "array"
    			},
    			{
    				id: "save_node_effects",
    				ref: "array"
    			},
    			{
    				id: "save_name",
    				value: "save"
    			},
    			{
    				id: "save_id",
    				value: "save"
    			},
    			{
    				id: "save_node"
    			},
    			{
    				id: "export_effector",
    				ref: "export_effect"
    			},
    			{
    				id: "export_json_payload"
    			},
    			{
    				id: "export_json_ext",
    				value: "json"
    			},
    			{
    				id: "export_json_effect",
    				ref: "array"
    			},
    			{
    				id: "export_json_node_effects",
    				ref: "array"
    			},
    			{
    				id: "export_json_node_name",
    				value: "json"
    			},
    			{
    				id: "export_json_node_id",
    				value: "export_json"
    			},
    			{
    				id: "export_json_data",
    				script: "return JSON.stringify(display_graph)"
    			},
    			{
    				id: "export_js_payload"
    			},
    			{
    				id: "export_js_ext",
    				value: "js"
    			},
    			{
    				id: "export_js_effect",
    				ref: "array"
    			},
    			{
    				id: "export_js_node_effects",
    				ref: "array"
    			},
    			{
    				id: "export_js_node_name",
    				value: "js"
    			},
    			{
    				id: "export_js_node_id",
    				value: "export_js"
    			},
    			{
    				id: "export_js_data",
    				script: "return `let graph = ${JSON.stringify(display_graph)}; import('nodysseus.bundle.js').then(({runGraph}) => runGraph(graph, 'main/out', {}))`"
    			},
    			{
    				id: "export_json_name",
    				value: "export"
    			},
    			{
    				id: "export_json_id",
    				value: "export"
    			},
    			{
    				id: "export_js_name",
    				value: "export"
    			},
    			{
    				id: "export_js_id",
    				value: "export"
    			},
    			{
    				id: "export_json_node"
    			},
    			{
    				id: "export_js_node"
    			},
    			{
    				id: "export_node"
    			},
    			{
    				id: "new_graph_effector",
    				ref: "new_graph_effect"
    			},
    			{
    				id: "new_graph_effect",
    				ref: "array"
    			},
    			{
    				id: "new_graph_name",
    				value: "new_graph"
    			},
    			{
    				id: "new_graph_id",
    				value: "new_graph"
    			},
    			{
    				id: "new_graph_node_effects",
    				ref: "array"
    			},
    			{
    				id: "new_graph_node"
    			},
    			{
    				id: "popover_graph_actions",
    				ref: "array"
    			},
    			{
    				id: "empty",
    				value: {
    				}
    			},
    			{
    				id: "popover_graph_obj_actions",
    				ref: "array"
    			},
    			{
    				id: "popover_graph_obj"
    			},
    			{
    				id: "popover_graph_parent_obj",
    				ref: "set"
    			},
    			{
    				id: "popover_graph",
    				ref: "create_object_graph"
    			},
    			{
    				id: "show_popover_effector",
    				ref: "show_popover_graph"
    			},
    			{
    				id: "show_popover_effect",
    				ref: "array"
    			},
    			{
    				id: "show_popover_payload"
    			},
    			{
    				id: "display_graph_path",
    				value: "display_graph"
    			},
    			{
    				id: "change_display_graph_id",
    				ref: "change_display_graph_id"
    			},
    			{
    				id: "change_display_graph_id_node_name",
    				value: "change id"
    			},
    			{
    				id: "change_display_graph_id_node_id",
    				value: "change_display_graph_id_node"
    			},
    			{
    				id: "change_display_graph_id_node_value",
    				ref: "array"
    			},
    			{
    				id: "change_display_graph_id_node"
    			},
    			{
    				id: "show_edit_text_effector",
    				ref: "show_edit_text"
    			},
    			{
    				id: "show_edit_text_payload"
    			},
    			{
    				id: "show_edit_text_effect",
    				ref: "array"
    			},
    			{
    				id: "open_graph",
    				ref: "open_saved_graph_effect"
    			},
    			{
    				id: "open_obj",
    				script: "return Object.fromEntries(JSON.parse(localStorage.getItem('graph_list') ?? '[]').map(g => [g, [clear_popover, [open_graph, {id: g}]]]))"
    			},
    			{
    				id: "open_example_graph",
    				ref: "open_graph_effect"
    			},
    			{
    				id: "examples_obj",
    				script: "return Object.fromEntries(examples.map(e => ['example-' + e.id, [clear_popover, [open_graph, {graph: e}]]]))"
    			},
    			{
    				id: "stop_propagation_effector",
    				ref: "stop_propagation_effect"
    			},
    			{
    				id: "stop_propagation_effect",
    				ref: "array"
    			},
    			{
    				id: "dispatch_on_graph_click_effector",
    				ref: "dispatch_custom_event_effect"
    			},
    			{
    				id: "dispatch_on_graph_click_payload"
    			},
    			{
    				id: "dispatch_on_graph_click_effect",
    				ref: "array"
    			},
    			{
    				id: "edit_effects",
    				ref: "array"
    			},
    			{
    				id: "readonly_effects",
    				ref: "array"
    			},
    			{
    				id: "effects",
    				ref: "if"
    			},
    			{
    				id: "result"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "payload",
    				to: "stop_propagation_effect",
    				as: "a1"
    			},
    			{
    				from: "display_graph",
    				to: "save_payload",
    				as: "display_graph"
    			},
    			{
    				from: "clear_popover",
    				to: "clear_popover_effect",
    				as: "a0"
    			},
    			{
    				from: "clear_popover_effect",
    				to: "save_node_effects",
    				as: "a1"
    			},
    			{
    				from: "save_effector",
    				to: "save_effect",
    				as: "a0"
    			},
    			{
    				from: "save_payload",
    				to: "save_effect",
    				as: "a1"
    			},
    			{
    				from: "save_effect",
    				to: "save_node_effects",
    				as: "a0"
    			},
    			{
    				from: "save_effector",
    				to: "save_effect",
    				as: "a0"
    			},
    			{
    				from: "save_payload",
    				to: "save_effect",
    				as: "a1"
    			},
    			{
    				from: "save_effect",
    				to: "save_node_effects",
    				as: "a0"
    			},
    			{
    				from: "save_node_effects",
    				to: "popover_graph_obj",
    				as: "save"
    			},
    			{
    				from: "save_name",
    				to: "save_node",
    				as: "name"
    			},
    			{
    				from: "save_id",
    				to: "save_node",
    				as: "id"
    			},
    			{
    				from: "save_node",
    				to: "popover_graph_actions",
    				as: "a"
    			},
    			{
    				from: "clear_popover_effect",
    				to: "export_node_effects",
    				as: "a1"
    			},
    			{
    				from: "display_graph",
    				to: "export_json_data",
    				as: "display_graph"
    			},
    			{
    				from: "display_graph",
    				to: "export_js_data",
    				as: "display_graph"
    			},
    			{
    				from: "export_effector",
    				to: "export_json_effect",
    				as: "a0"
    			},
    			{
    				from: "export_effector",
    				to: "export_js_effect",
    				as: "a0"
    			},
    			{
    				from: "export_json_payload",
    				to: "export_json_effect",
    				as: "a1"
    			},
    			{
    				from: "export_js_payload",
    				to: "export_js_effect",
    				as: "a1"
    			},
    			{
    				from: "export_json_effect",
    				to: "export_json_node_effects",
    				as: "a0"
    			},
    			{
    				from: "export_js_effect",
    				to: "export_js_node_effects",
    				as: "a0"
    			},
    			{
    				from: "clear_popover_effect",
    				to: "export_json_node_effects",
    				as: "a1"
    			},
    			{
    				from: "clear_popover_effect",
    				to: "export_js_node_effects",
    				as: "a1"
    			},
    			{
    				from: "export_json_node_effects",
    				to: "export_json_node",
    				as: "_value"
    			},
    			{
    				from: "export_js_node_effects",
    				to: "export_js_node",
    				as: "_value"
    			},
    			{
    				from: "export_json_node",
    				to: "export_node",
    				as: "json"
    			},
    			{
    				from: "export_js_node",
    				to: "export_node",
    				as: "js"
    			},
    			{
    				from: "export_node",
    				to: "popover_graph_obj",
    				as: "export"
    			},
    			{
    				from: "export_json_data",
    				to: "export_json_payload",
    				as: "data"
    			},
    			{
    				from: "export_json_ext",
    				to: "export_json_payload",
    				as: "ext"
    			},
    			{
    				from: "name",
    				to: "export_json_payload",
    				as: "id"
    			},
    			{
    				from: "name",
    				to: "export_js_payload",
    				as: "id"
    			},
    			{
    				from: "export_js_data",
    				to: "export_js_payload",
    				as: "data"
    			},
    			{
    				from: "export_js_ext",
    				to: "export_js_payload",
    				as: "ext"
    			},
    			{
    				from: "export_node",
    				to: "popover_graph_actions",
    				as: "c"
    			},
    			{
    				from: "new_graph_effector",
    				to: "new_graph_effect",
    				as: "a0"
    			},
    			{
    				from: "new_graph_effect",
    				to: "new_graph_node_effects",
    				as: "a0"
    			},
    			{
    				from: "new_graph_node_effects",
    				to: "popover_graph_obj",
    				as: "new"
    			},
    			{
    				from: "new_graph_name",
    				to: "new_graph_node",
    				as: "name"
    			},
    			{
    				from: "new_graph_id",
    				to: "new_graph_node",
    				as: "id"
    			},
    			{
    				from: "new_graph_node",
    				to: "popover_graph_actions",
    				as: "b"
    			},
    			{
    				from: "change_display_graph_id_effector",
    				to: "change_display_graph_id_effect",
    				as: "a0"
    			},
    			{
    				from: "change_display_graph_id",
    				to: "show_edit_text_payload",
    				as: "oneditconfirm"
    			},
    			{
    				from: "display_graph_path",
    				to: "show_edit_text_payload",
    				as: "id"
    			},
    			{
    				from: "name",
    				to: "show_edit_text_payload",
    				as: "value"
    			},
    			{
    				from: "id_path",
    				to: "show_edit_text_payload",
    				as: "property"
    			},
    			{
    				from: "show_edit_text_effector",
    				to: "show_edit_text_effect",
    				as: "a0"
    			},
    			{
    				from: "show_edit_text_payload",
    				to: "show_edit_text_effect",
    				as: "a1"
    			},
    			{
    				from: "show_edit_text_effect",
    				to: "change_display_graph_id_node_value",
    				as: "a"
    			},
    			{
    				from: "clear_popover_effect",
    				to: "change_display_graph_id_node_value",
    				as: "b"
    			},
    			{
    				from: "change_display_graph_id_node_value",
    				to: "popover_graph_obj",
    				as: "change_name"
    			},
    			{
    				from: "change_display_graph_id_node_id",
    				to: "change_display_graph_id_node",
    				as: "id"
    			},
    			{
    				from: "change_display_graph_id_node_name",
    				to: "change_display_graph_id_node",
    				as: "name"
    			},
    			{
    				from: "change_display_graph_id_node",
    				to: "popover_graph_actions",
    				as: "d"
    			},
    			{
    				from: "clear_popover_effect",
    				to: "open_obj",
    				as: "clear_popover"
    			},
    			{
    				from: "open_graph",
    				to: "open_obj",
    				as: "open_graph"
    			},
    			{
    				from: "open_obj",
    				to: "popover_graph_obj",
    				as: "open"
    			},
    			{
    				from: "examples",
    				to: "examples_obj",
    				as: "examples"
    			},
    			{
    				from: "clear_popover_effect",
    				to: "examples_obj",
    				as: "clear_popover"
    			},
    			{
    				from: "open_example_graph",
    				to: "examples_obj",
    				as: "open_graph"
    			},
    			{
    				from: "examples_obj",
    				to: "popover_graph_obj",
    				as: "examples"
    			},
    			{
    				from: "clear_popover_effect",
    				to: "popover_graph_obj_actions",
    				as: "a0"
    			},
    			{
    				from: "popover_graph_obj_actions",
    				to: "popover_graph_obj",
    				as: "_value"
    			},
    			{
    				from: "name",
    				to: "popover_graph",
    				as: "name"
    			},
    			{
    				from: "empty",
    				to: "popover_graph_parent_obj",
    				as: "target"
    			},
    			{
    				from: "name",
    				to: "popover_graph_parent_obj",
    				as: "path"
    			},
    			{
    				from: "popover_graph_obj",
    				to: "popover_graph_parent_obj",
    				as: "value"
    			},
    			{
    				from: "popover_graph_parent_obj",
    				to: "popover_graph",
    				as: "obj",
    				type: "resolve"
    			},
    			{
    				from: "popover_graph",
    				to: "show_popover_payload",
    				as: "popover_graph"
    			},
    			{
    				from: "show_popover_effector",
    				to: "show_popover_effect",
    				as: "a0"
    			},
    			{
    				from: "show_popover_payload",
    				to: "show_popover_effect",
    				as: "a1"
    			},
    			{
    				from: "stop_propagation_effector",
    				to: "stop_propagation_effect",
    				as: "a0"
    			},
    			{
    				from: "payload",
    				to: "stop_propagation_effect",
    				as: "a1"
    			},
    			{
    				from: "stop_propagation_effect",
    				to: "edit_effects",
    				as: "a1"
    			},
    			{
    				from: "html_id",
    				to: "dispatch_on_graph_click_payload",
    				as: "html_id"
    			},
    			{
    				from: "event_name",
    				to: "dispatch_on_graph_click_payload",
    				as: "event"
    			},
    			{
    				from: "dispatch_on_graph_click_effector",
    				to: "dispatch_on_graph_click_effect",
    				as: "a0"
    			},
    			{
    				from: "dispatch_on_graph_click_payload",
    				to: "dispatch_on_graph_click_effect",
    				as: "a1"
    			},
    			{
    				from: "dispatch_on_graph_click_effect",
    				to: "readonly_effects",
    				as: "a0"
    			},
    			{
    				from: "show_popover_effect",
    				to: "edit_effects",
    				as: "a0"
    			},
    			{
    				from: "edit_effects",
    				to: "effects",
    				as: "false"
    			},
    			{
    				from: "readonly_effects",
    				to: "effects",
    				as: "true"
    			},
    			{
    				from: "readonly",
    				to: "effects",
    				as: "pred"
    			},
    			{
    				from: "effects",
    				to: "result",
    				as: "effects"
    			},
    			{
    				from: "state",
    				to: "result",
    				as: "state"
    			},
    			{
    				from: "result",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "onclick_graph_action",
    		nodes: [
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "false",
    				value: false
    			},
    			{
    				id: "search_payload"
    			},
    			{
    				id: "search_effect",
    				ref: "search_effect"
    			},
    			{
    				id: "clear_search",
    				ref: "array"
    			},
    			{
    				id: "effects",
    				ref: "array"
    			},
    			{
    				id: "result"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action"
    			}
    		],
    		edges: [
    			{
    				from: "false",
    				to: "search_payload",
    				as: "search"
    			},
    			{
    				from: "search_payload",
    				to: "clear_search",
    				as: "a1"
    			},
    			{
    				from: "search_effect",
    				to: "clear_search",
    				as: "a0"
    			},
    			{
    				from: "clear_search",
    				to: "effects",
    				as: "a0"
    			},
    			{
    				from: "effects",
    				to: "result",
    				as: "effects"
    			},
    			{
    				from: "state",
    				to: "result",
    				as: "state"
    			},
    			{
    				from: "result",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "onselectnode",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "html_id",
    				ref: "arg",
    				value: "state.html_id"
    			},
    			{
    				id: "event",
    				ref: "arg",
    				value: "payload.event"
    			},
    			{
    				id: "node_id",
    				ref: "arg",
    				value: "payload.node_id"
    			},
    			{
    				id: "arg_selected",
    				ref: "arg",
    				value: "state.selected"
    			},
    			{
    				id: "readonly",
    				ref: "arg",
    				value: "state.readonly"
    			},
    			{
    				id: "arg_display_graph",
    				ref: "arg",
    				value: "state.display_graph"
    			},
    			{
    				id: "display_graph_nodes",
    				ref: "arg",
    				value: "state.display_graph.nodes"
    			},
    			{
    				id: "node_el_width",
    				ref: "arg",
    				value: "state.node_el_width"
    			},
    			{
    				id: "dimensions",
    				ref: "arg",
    				value: "state.dimensions"
    			},
    			{
    				id: "nodes",
    				ref: "arg",
    				value: "state.nodes"
    			},
    			{
    				id: "links",
    				ref: "arg",
    				value: "state.links"
    			},
    			{
    				id: "wrapped_node_id",
    				ref: "wrap_array"
    			},
    			{
    				id: "get_selected_node",
    				script: "return Object.assign({}, nodes.find(n => n.node_id === node_id), display_graph.nodes.find(n => n.id === node_id))"
    			},
    			{
    				id: "show_all_path",
    				value: "show_all"
    			},
    			{
    				id: "set_selected",
    				args: [
    					"selected",
    					"state"
    				],
    				script: "return {...state, selected: [node_id]}"
    			},
    			{
    				id: "display_graph_inputs",
    				script: "return event.ty === 'down' && node.node_id === selected[0] ? 'expand_contract' : undefined"
    			},
    			{
    				id: "display_graph",
    				ref: "switch"
    			},
    			{
    				id: "set_display_graph",
    				args: [
    					"display_graph",
    					"state"
    				],
    				script: "state.display_graph = display_graph ?? state.display_graph; return state"
    			},
    			{
    				id: "false",
    				value: false
    			},
    			{
    				id: "should_show_popover",
    				script: "return !readonly && node_id === selected[0]"
    			},
    			{
    				id: "randid",
    				ref: "arg",
    				value: "state.randid"
    			},
    			{
    				id: "add_node_effect",
    				ref: "add_node"
    			},
    			{
    				id: "add_edge_effect",
    				ref: "add_edge"
    			},
    			{
    				id: "paste_node_effect",
    				ref: "paste_node_effect"
    			},
    			{
    				id: "copy_effect",
    				ref: "copy_effect"
    			},
    			{
    				id: "delete_node_effect",
    				ref: "delete_node"
    			},
    			{
    				id: "expand_contract_effect",
    				ref: "expand_contract_effect"
    			},
    			{
    				id: "open_reference_popover",
    				ref: "open_reference_popover"
    			},
    			{
    				id: "show_edit_text",
    				ref: "show_edit_text"
    			},
    			{
    				id: "clear_popover",
    				ref: "clear_popover_graph"
    			},
    			{
    				id: "update_node",
    				ref: "update_node_action"
    			},
    			{
    				id: "update_node_effect",
    				ref: "update_node"
    			},
    			{
    				id: "create_reference_effect",
    				ref: "create_reference_effect"
    			},
    			{
    				id: "popover_graph_obj",
    				script: "return {[selected.node_id]: {_value: [[clear_popover]], inputs: {create_input: [[add_node, {node: {id: randid}, select: true, child: selected.node_id}], [clear_popover]], arg: [[add_node, {node: {id: randid, ref: 'arg'}, select: true, child: selected.node_id}], [show_edit_text, {id: randid, property:'value', oneditconfirm: update_node, value: ''}], [clear_popover]]}, structure: {delete: [[delete_node, {id: selected.node_id}], [clear_popover]], expand_contract: [[expand_contract, {id: selected.node_id}], [clear_popover]]}, change: {name: [[show_edit_text, {id: selected.node_id, property:'name', position: {x: selected.x, y: selected.y}, oneditconfirm: update_node, value: selected.name}], [clear_popover]], value: [[show_edit_text, {id: selected.node_id, property:'value', position: {x: selected.x, y: selected.y}, oneditconfirm: update_node, value: selected.value}], [clear_popover]], script: [[show_edit_text, {id: selected.node_id, property:'script', position: {x: selected.x, y: selected.y}, oneditconfirm: update_node, value: selected.script}], [clear_popover]]}, clipboard: {copy: [[copy_effect, {id: selected.node_id}], [clear_popover]], paste: [[paste_node_effect, {randid, node_id: selected.node_id}], [clear_popover]]}, reference: {create: [[create_reference_effect, {id: selected.node_id}], [clear_popover]], clear: [[update_node_effect, {id: selected.node_id, properties: {ref: undefined}}], [clear_popover]], copy: [[update_node_effect, {id: selected.node_id, properties: {...nodes.find(n => n.id === selected.ref), id: selected.node_id, ref: undefined}}], [clear_popover]], change: [[show_edit_text, {id: selected.node_id, property: 'ref', position: {x: selected.x, y: selected.y}, oneditconfirm: update_node, value: selected.ref}], [clear_popover]]}}}"
    			},
    			{
    				id: "popover_graph_value",
    				ref: "create_object_graph"
    			},
    			{
    				id: "dispatch_custom_event_effect",
    				script: "return [(_, payload) => document.getElementById(`${html_id}`).dispatchEvent(new CustomEvent(`selectnode`, {detail: {node: node_id}}))]"
    			},
    			{
    				id: "show_popover_payload"
    			},
    			{
    				id: "show_popover_effector",
    				ref: "show_popover_graph"
    			},
    			{
    				id: "show_popover_effect",
    				ref: "array"
    			},
    			{
    				id: "stop_propagation_effector",
    				ref: "stop_propagation_effect"
    			},
    			{
    				id: "payload",
    				ref: "arg",
    				value: "payload"
    			},
    			{
    				id: "stop_propagation_effect",
    				ref: "array"
    			},
    			{
    				id: "panzoom_selected_effector",
    				ref: "arg",
    				value: "state.panzoom_selected_effect"
    			},
    			{
    				id: "panzoom_selected_effect",
    				ref: "array"
    			},
    			{
    				id: "panzoom_selected_payload"
    			},
    			{
    				id: "clear_search_payload",
    				value: {
    					search: false
    				}
    			},
    			{
    				id: "search_effect",
    				ref: "search_effect"
    			},
    			{
    				id: "clear_search",
    				ref: "array"
    			},
    			{
    				id: "if_show_popover",
    				ref: "if"
    			},
    			{
    				id: "effects",
    				ref: "array"
    			},
    			{
    				id: "out",
    				ref: "update_graph_display"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "node_id",
    				to: "selected_inputs",
    				as: "node_id"
    			},
    			{
    				from: "node_id",
    				to: "get_selected_node",
    				as: "node_id"
    			},
    			{
    				from: "arg_display_graph",
    				to: "get_selected_node",
    				as: "display_graph"
    			},
    			{
    				from: "nodes",
    				to: "get_selected_node",
    				as: "nodes"
    			},
    			{
    				from: "get_selected_node",
    				to: "selected_inputs",
    				as: "node"
    			},
    			{
    				from: "event",
    				to: "selected_inputs",
    				as: "event"
    			},
    			{
    				from: "node_id",
    				to: "wrapped_node_id",
    				as: "value"
    			},
    			{
    				from: "wrapped_node_id",
    				to: "selected",
    				as: "node_id"
    			},
    			{
    				from: "state",
    				to: "set_selected",
    				as: "state"
    			},
    			{
    				from: "node_id",
    				to: "set_selected",
    				as: "node_id"
    			},
    			{
    				from: "html_id",
    				to: "set_selected",
    				as: "html_id"
    			},
    			{
    				from: "set_selected",
    				to: "set_display_graph",
    				as: "state"
    			},
    			{
    				from: "display_graph",
    				to: "set_display_graph",
    				as: "display_graph"
    			},
    			{
    				from: "get_selected_node",
    				to: "display_graph_inputs",
    				as: "node"
    			},
    			{
    				from: "state",
    				to: "display_graph_inputs"
    			},
    			{
    				from: "event",
    				to: "display_graph_inputs",
    				as: "event"
    			},
    			{
    				from: "display_graph_inputs",
    				to: "display_graph",
    				as: "input"
    			},
    			{
    				from: "state",
    				to: "expand_contract"
    			},
    			{
    				from: "node_id",
    				to: "expand_contract",
    				as: "node_id"
    			},
    			{
    				from: "event",
    				to: "out",
    				as: "payload"
    			},
    			{
    				from: "show_popover_effector",
    				to: "show_popover_effect",
    				as: "arg0"
    			},
    			{
    				from: "event",
    				to: "stop_propagation_effect",
    				as: "a1"
    			},
    			{
    				from: "stop_propagation_effector",
    				to: "stop_propagation_effect",
    				as: "a0"
    			},
    			{
    				from: "randid",
    				to: "popover_graph_obj",
    				as: "randid"
    			},
    			{
    				from: "display_graph_nodes",
    				to: "popover_graph_obj",
    				as: "nodes"
    			},
    			{
    				from: "get_selected_node",
    				to: "popover_graph_obj",
    				as: "selected"
    			},
    			{
    				from: "add_node_effect",
    				to: "popover_graph_obj",
    				as: "add_node"
    			},
    			{
    				from: "add_edge_effect",
    				to: "popover_graph_obj",
    				as: "add_edge"
    			},
    			{
    				from: "delete_node_effect",
    				to: "popover_graph_obj",
    				as: "delete_node"
    			},
    			{
    				from: "expand_contract_effect",
    				to: "popover_graph_obj",
    				as: "expand_contract"
    			},
    			{
    				from: "open_reference_popover",
    				to: "popover_graph_obj",
    				as: "open_reference_popover"
    			},
    			{
    				from: "show_edit_text",
    				to: "popover_graph_obj",
    				as: "show_edit_text"
    			},
    			{
    				from: "clear_popover",
    				to: "popover_graph_obj",
    				as: "clear_popover"
    			},
    			{
    				from: "update_node",
    				to: "popover_graph_obj",
    				as: "update_node"
    			},
    			{
    				from: "update_node_effect",
    				to: "popover_graph_obj",
    				as: "update_node_effect"
    			},
    			{
    				from: "copy_effect",
    				to: "popover_graph_obj",
    				as: "copy_effect"
    			},
    			{
    				from: "paste_node_effect",
    				to: "popover_graph_obj",
    				as: "paste_node_effect"
    			},
    			{
    				from: "create_reference_effect",
    				to: "popover_graph_obj",
    				as: "create_reference_effect"
    			},
    			{
    				from: "popover_graph_obj",
    				to: "popover_graph_value",
    				as: "obj"
    			},
    			{
    				from: "popover_graph_value",
    				to: "show_popover_payload",
    				as: "popover_graph"
    			},
    			{
    				from: "show_popover_payload",
    				to: "show_popover_effect",
    				as: "arg1"
    			},
    			{
    				from: "show_popover_effect",
    				to: "if_show_popover",
    				as: "true"
    			},
    			{
    				from: "false",
    				to: "if_show_popover",
    				as: "false"
    			},
    			{
    				from: "node_id",
    				to: "should_show_popover",
    				as: "node_id"
    			},
    			{
    				from: "readonly",
    				to: "should_show_popover",
    				as: "readonly"
    			},
    			{
    				from: "arg_selected",
    				to: "should_show_popover",
    				as: "selected"
    			},
    			{
    				from: "should_show_popover",
    				to: "if_show_popover",
    				as: "pred"
    			},
    			{
    				from: "arg_selected",
    				to: "dispatch_custom_event_effect",
    				as: "selected"
    			},
    			{
    				from: "html_id",
    				to: "dispatch_custom_event_effect",
    				as: "html_id"
    			},
    			{
    				from: "node_id",
    				to: "dispatch_custom_event_effect",
    				as: "node_id"
    			},
    			{
    				from: "if_show_popover",
    				to: "effects",
    				as: "a1"
    			},
    			{
    				from: "stop_propagation_effect",
    				to: "effects",
    				as: "a0"
    			},
    			{
    				from: "dispatch_custom_event_effect",
    				to: "effects",
    				as: "a2"
    			},
    			{
    				from: "node_id",
    				to: "panzoom_selected_payload",
    				as: "selected"
    			},
    			{
    				from: "html_id",
    				to: "panzoom_selected_payload",
    				as: "html_id"
    			},
    			{
    				from: "dimensions",
    				to: "panzoom_selected_payload",
    				as: "dimensions"
    			},
    			{
    				from: "node_el_width",
    				to: "panzoom_selected_payload",
    				as: "node_el_width"
    			},
    			{
    				from: "links",
    				to: "panzoom_selected_payload",
    				as: "links"
    			},
    			{
    				from: "nodes",
    				to: "panzoom_selected_payload",
    				as: "nodes"
    			},
    			{
    				from: "panzoom_selected_payload",
    				to: "panzoom_selected_effect",
    				as: "a1"
    			},
    			{
    				from: "panzoom_selected_effector",
    				to: "panzoom_selected_effect",
    				as: "a0"
    			},
    			{
    				from: "panzoom_selected_effect",
    				to: "effects",
    				as: "a3"
    			},
    			{
    				from: "search_effect",
    				to: "clear_search",
    				as: "a0"
    			},
    			{
    				from: "clear_search_payload",
    				to: "clear_search",
    				as: "a1"
    			},
    			{
    				from: "clear_search",
    				to: "effects",
    				as: "a4"
    			},
    			{
    				from: "effects",
    				to: "out",
    				as: "effects",
    				type: "resolve"
    			},
    			{
    				from: "set_selected",
    				to: "out",
    				as: "state"
    			}
    		]
    	},
    	{
    		id: "onselectnode_effect",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "onselectnode",
    				ref: "onselectnode"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action_effect"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				type: "ref",
    				as: "args"
    			},
    			{
    				from: "onselectnode",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "onselectnode_action",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "onselectnode",
    				ref: "onselectnode"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				type: "ref",
    				as: "args"
    			},
    			{
    				from: "onselectnode",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "open_edge_popover",
    		nodes: [
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "edge",
    				ref: "arg",
    				value: "state.edit_id"
    			},
    			{
    				id: "edge_as",
    				ref: "arg",
    				value: "state.edit_id.as"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "readonly",
    				ref: "arg",
    				value: "state.readonly"
    			},
    			{
    				id: "randid",
    				ref: "arg",
    				value: "state.randid"
    			},
    			{
    				id: "display_graph_nodes",
    				ref: "arg",
    				value: "state.display_graph.nodes"
    			},
    			{
    				id: "links",
    				ref: "arg",
    				value: "state.links"
    			},
    			{
    				id: "event",
    				ref: "arg",
    				value: "payload.event"
    			},
    			{
    				id: "as_path",
    				value: "as"
    			},
    			{
    				id: "clear_popover",
    				ref: "clear_popover_graph"
    			},
    			{
    				id: "clear_popover_type",
    				ref: "clear_popover_graph"
    			},
    			{
    				id: "update_edge",
    				ref: "update_edge"
    			},
    			{
    				id: "update_edge_action",
    				ref: "update_edge_action"
    			},
    			{
    				id: "show_edit_text",
    				ref: "show_edit_text"
    			},
    			{
    				id: "insert_node",
    				ref: "insert_node"
    			},
    			{
    				id: "update_sim",
    				ref: "arg",
    				value: "update_sim_effect"
    			},
    			{
    				id: "type_popover_actions",
    				script: "return {change_type: {_value: [[clear_popover]], ref: [[update_edge, {id: edge, properties: {type: 'ref'}}], [clear_popover]], none: [[update_edge, {id: edge, properties: {type: undefined}}], [clear_popover]], resolve: [[update_edge, {id: edge, properties: {type: 'resolve'}}], [clear_popover]]}}"
    			},
    			{
    				id: "type_popover",
    				ref: "create_object_graph"
    			},
    			{
    				id: "type_popover_name",
    				value: "change_type"
    			},
    			{
    				id: "to_name",
    				script: "return nodes.find(n => n.id === edge.to).name"
    			},
    			{
    				id: "popover_graph_actions",
    				script: "return {edit_edge: {_value: [[clear_popover]], 'change_type': [[show_popover_graph, {popover_graph: type_popover}]],'change_as': [[show_edit_text, {id: edge, property: 'as', value: edge.as, oneditconfirm: update_edge}], [clear_popover]], 'insert': {node: [[insert_node, {node: {id: randid}, edge, in_node: false}], [clear_popover]], in_node: [[insert_node, {node: {id:  randid, name: (to_name ?? edge.to) + '/in'}, edge, in_node: true}], [clear_popover]]}}}"
    			},
    			{
    				id: "popover_graph_name",
    				value: "change edge"
    			},
    			{
    				id: "popover_graph",
    				ref: "create_object_graph"
    			},
    			{
    				id: "show_popover_graph_payload"
    			},
    			{
    				id: "show_popover_graph_effector",
    				ref: "show_popover_graph"
    			},
    			{
    				id: "show_popover_graph",
    				ref: "array"
    			},
    			{
    				id: "effects",
    				ref: "array"
    			},
    			{
    				id: "result"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action"
    			}
    		],
    		edges: [
    			{
    				from: "type_popover_actions",
    				to: "type_popover",
    				as: "obj"
    			},
    			{
    				from: "type_popover_name",
    				to: "type_popover",
    				as: "name"
    			},
    			{
    				from: "edge",
    				to: "type_popover_actions",
    				as: "edge"
    			},
    			{
    				from: "clear_popover_type",
    				to: "type_popover_actions",
    				as: "clear_popover"
    			},
    			{
    				from: "update_edge",
    				to: "type_popover_actions",
    				as: "update_edge"
    			},
    			{
    				from: "update_edge_action",
    				to: "popover_graph_actions",
    				as: "update_edge"
    			},
    			{
    				from: "type_popover",
    				to: "popover_graph_actions",
    				as: "type_popover"
    			},
    			{
    				from: "edge",
    				to: "clear_popover",
    				as: "edge"
    			},
    			{
    				from: "edge",
    				to: "to_name",
    				as: "edge"
    			},
    			{
    				from: "display_graph_nodes",
    				to: "to_name",
    				as: "nodes"
    			},
    			{
    				from: "to_name",
    				to: "popover_graph_actions",
    				as: "to_name"
    			},
    			{
    				from: "clear_popover",
    				to: "popover_graph_actions",
    				as: "clear_popover"
    			},
    			{
    				from: "insert_node",
    				to: "popover_graph_actions",
    				as: "insert_node"
    			},
    			{
    				from: "edge",
    				to: "popover_graph_actions",
    				as: "edge"
    			},
    			{
    				from: "randid",
    				to: "popover_graph_actions",
    				as: "randid"
    			},
    			{
    				from: "show_edit_text",
    				to: "popover_graph_actions",
    				as: "show_edit_text"
    			},
    			{
    				from: "update_sim",
    				to: "popover_graph_actions",
    				as: "update_sim"
    			},
    			{
    				from: "show_popover_graph_effector",
    				to: "popover_graph_actions",
    				as: "show_popover_graph"
    			},
    			{
    				from: "popover_graph_actions",
    				to: "popover_graph",
    				as: "obj"
    			},
    			{
    				from: "popover_graph_name",
    				to: "popover_graph",
    				as: "name"
    			},
    			{
    				from: "popover_graph",
    				to: "show_popover_graph_payload",
    				as: "popover_graph"
    			},
    			{
    				from: "show_popover_graph_effector",
    				to: "show_popover_graph",
    				as: "a0"
    			},
    			{
    				from: "show_popover_graph_payload",
    				to: "show_popover_graph",
    				as: "a1"
    			},
    			{
    				from: "show_popover_graph",
    				to: "effects",
    				as: "a0"
    			},
    			{
    				from: "effects",
    				to: "result",
    				as: "effects"
    			},
    			{
    				from: "state",
    				to: "result",
    				as: "state"
    			},
    			{
    				from: "result",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "onclick_edge",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "edge",
    				ref: "arg",
    				value: "payload.edge"
    			},
    			{
    				id: "edge_as",
    				ref: "arg",
    				value: "payload.edge.as"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "readonly",
    				ref: "arg",
    				value: "state.readonly"
    			},
    			{
    				id: "randid",
    				ref: "arg",
    				value: "state.randid"
    			},
    			{
    				id: "display_graph_nodes",
    				ref: "arg",
    				value: "state.display_graph.nodes"
    			},
    			{
    				id: "links",
    				ref: "arg",
    				value: "state.links"
    			},
    			{
    				id: "event",
    				ref: "arg",
    				value: "payload.event"
    			},
    			{
    				id: "as_path",
    				value: "as"
    			},
    			{
    				id: "update_edge",
    				ref: "update_edge"
    			},
    			{
    				id: "update_edge_action",
    				ref: "update_edge_action"
    			},
    			{
    				id: "show_edit_text",
    				ref: "show_edit_text"
    			},
    			{
    				id: "edit_text_position",
    				script: "return links.filter(l => l.source.node_id === edge.from && l.target.node_id === edge.to).map(l => ({x: (l.source.x + l.target.x) * 0.5, y: (l.source.y + l.target.y) * 0.5}))[0]"
    			},
    			{
    				id: "open_edge_popover",
    				ref: "open_edge_popover"
    			},
    			{
    				id: "edit_edge_as_payload"
    			},
    			{
    				id: "edit_edge_as",
    				ref: "array"
    			},
    			{
    				id: "stop_propagation_effector",
    				ref: "stop_propagation_effect"
    			},
    			{
    				id: "stop_propagation",
    				ref: "array"
    			},
    			{
    				id: "editable_effects",
    				ref: "array"
    			},
    			{
    				id: "readonly_effects",
    				ref: "array"
    			},
    			{
    				id: "effects",
    				ref: "if"
    			},
    			{
    				id: "result"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "out",
    				as: "args"
    			},
    			{
    				from: "edge",
    				to: "edit_text_position",
    				as: "edge"
    			},
    			{
    				from: "links",
    				to: "edit_text_position",
    				as: "links"
    			},
    			{
    				from: "edit_text_position",
    				to: "edit_edge_as_payload",
    				as: "position"
    			},
    			{
    				from: "as_path",
    				to: "edit_edge_as_payload",
    				as: "property"
    			},
    			{
    				from: "update_edge_action",
    				to: "edit_edge_as_payload",
    				as: "oneditconfirm"
    			},
    			{
    				from: "edge",
    				to: "edit_edge_as_payload",
    				as: "id"
    			},
    			{
    				from: "edge_as",
    				to: "edit_edge_as_payload",
    				as: "value"
    			},
    			{
    				from: "open_edge_popover",
    				to: "edit_edge_as_payload",
    				as: "oneditmore"
    			},
    			{
    				from: "edit_edge_as_payload",
    				to: "edit_edge_as",
    				as: "a1"
    			},
    			{
    				from: "show_edit_text",
    				to: "edit_edge_as",
    				as: "a0"
    			},
    			{
    				from: "edit_edge_as",
    				to: "editable_effects",
    				as: "a0"
    			},
    			{
    				from: "event",
    				to: "stop_propagation_payload",
    				as: "event"
    			},
    			{
    				from: "stop_propagation_effector",
    				to: "stop_propagation",
    				as: "a0"
    			},
    			{
    				from: "event",
    				to: "stop_propagation",
    				as: "a1"
    			},
    			{
    				from: "stop_propagation",
    				to: "editable_effects",
    				as: "a1"
    			},
    			{
    				from: "editable_effects",
    				to: "effects",
    				as: "false"
    			},
    			{
    				from: "readonly_effects",
    				to: "effects",
    				as: "true"
    			},
    			{
    				from: "readonly",
    				to: "effects",
    				as: "pred"
    			},
    			{
    				from: "state",
    				to: "result",
    				as: "state"
    			},
    			{
    				from: "effects",
    				to: "result",
    				as: "effects"
    			},
    			{
    				from: "result",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "editor_dom_type",
    		value: "div"
    	},
    	{
    		id: "editor_props",
    		value: {
    			key: "editor"
    		}
    	},
    	{
    		id: "popover_dimensions",
    		value: {
    			x: 400,
    			y: 800
    		}
    	},
    	{
    		id: "html_id",
    		ref: "arg",
    		value: "html_id"
    	},
    	{
    		id: "render_popover_graph_effect",
    		script: "return (dispatch, payload) => requestAnimationFrame(() => {payload = _lib.no.resolve(payload); if(payload.popover_dispatch) { payload.popover_dispatch(s => [{...s, display_graph: payload.display_graph, selected: [payload.display_graph.out]}, [s.update_sim_effect, {...s, display_graph: payload.display_graph}], [s.update_hyperapp] ]) } else { const popover_dispatch = _lib.no.executeGraphNode({graph: payload.graph})('initialize_hyperapp_app')({graph: payload.graph, display_graph: payload.display_graph, html_id: `${payload.html_id}-popover`, dimensions: payload.dimensions, readonly: true, hide_types: true, static: true, hash: ''}).dispatch; dispatch(s => ({...s, popover_dispatch}));}})"
    	},
    	{
    		id: "handle_popover_event",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "state",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "randid",
    				ref: "arg",
    				value: "state.randid"
    			},
    			{
    				id: "selected",
    				ref: "arg",
    				value: "state.selected"
    			},
    			{
    				id: "popover_graph",
    				ref: "arg",
    				value: "state.popover_graph"
    			},
    			{
    				id: "payload",
    				ref: "arg",
    				value: "payload"
    			},
    			{
    				id: "clear_popover_effect",
    				ref: "clear_popover_graph"
    			},
    			{
    				id: "effects",
    				script: "return popover_graph.nodes.find(n => n.id === payload.detail.node).value"
    			},
    			{
    				id: "new_state"
    			},
    			{
    				id: "out",
    				ref: "hyperapp_action"
    			}
    		],
    		edges: [
    			{
    				from: "in",
    				to: "new_state",
    				as: "args"
    			},
    			{
    				from: "state",
    				to: "new_state",
    				as: "state"
    			},
    			{
    				from: "selected",
    				to: "effects",
    				as: "selected"
    			},
    			{
    				from: "popover_graph",
    				to: "effects",
    				as: "popover_graph"
    			},
    			{
    				from: "clear_popover_effect",
    				to: "effects",
    				as: "clear_popover"
    			},
    			{
    				from: "randid",
    				to: "effects",
    				as: "randid"
    			},
    			{
    				from: "payload",
    				to: "effects",
    				as: "payload"
    			},
    			{
    				from: "effects",
    				to: "new_state",
    				as: "effects"
    			},
    			{
    				from: "new_state",
    				to: "out",
    				as: "fn",
    				type: "ref"
    			}
    		]
    	},
    	{
    		id: "editor",
    		out: "out",
    		nodes: [
    			{
    				id: "in"
    			},
    			{
    				id: "wrapper",
    				ref: "run_h"
    			},
    			{
    				id: "graph",
    				ref: "arg",
    				value: "graph"
    			},
    			{
    				id: "display_graph",
    				ref: "arg",
    				value: "display_graph"
    			},
    			{
    				id: "show_result",
    				ref: "arg",
    				value: "show_result"
    			},
    			{
    				id: "show_all",
    				ref: "arg",
    				value: "show_all"
    			},
    			{
    				id: "html_id",
    				ref: "arg",
    				value: "html_id"
    			},
    			{
    				id: "result_display",
    				ref: "arg",
    				value: "result_display"
    			},
    			{
    				id: "editing",
    				ref: "arg",
    				value: "editing"
    			},
    			{
    				id: "args_display",
    				ref: "arg",
    				value: "args_display"
    			},
    			{
    				id: "update_sim",
    				ref: "arg",
    				value: "update_sim"
    			},
    			{
    				id: "popover_graph",
    				ref: "arg",
    				value: "popover_graph"
    			},
    			{
    				id: "readonly",
    				ref: "arg",
    				value: "readonly"
    			},
    			{
    				id: "error",
    				ref: "arg",
    				value: "error"
    			},
    			{
    				id: "search",
    				ref: "arg",
    				value: "search"
    			},
    			{
    				id: "result_wrapper",
    				ref: "run_h"
    			},
    			{
    				id: "wrapper_dom_type",
    				value: "div"
    			},
    			{
    				id: "wrapper_props",
    				value: {
    				}
    			},
    			{
    				id: "wrapper_children",
    				script: "return [styles.el, node_editor.el, !readonly && editing !== false && edit_text.el, !readonly && popover_graph && popover_graph_h.el.el, !!result_display && result_display.el, !editing && !show_all && args_display && args_display.el, !!error && error_display.el, menu.el].filter(e => e)"
    			},
    			{
    				id: "styles",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "style_content",
    						value: "#node-editor { position: relative; width: 100%; height: 100vh; color: white; font-family: consolas; overflow: hidden; } #node-editor-editor.hash-view { background-color: unset; } svg { user-select: none; } .graph-ui { display: flex; position: absolute; right: 100px; top: 100px; flex-direction: row; gap: 8px; } .graph-ui ion-icon { cursor: pointer; width: 1.5em; height: 1.5em; color: #ccc; } .graph-ui ion-icon:hover { color: #fff; } .edit-value { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #00000011; } .edit-value .more { cursor: pointer; } .edit-value .centering { position: absolute; width: 32vw; display: flex; flex-direction: column; } .edit-value.none { left: -1000%; } .edit-value textarea { width: 32vw; font-size: (1em + 1vh); outline: none; resize: none; } .edit-value label { font-size: calc(1em + 2vh) } .edit-value textarea { height: 64em; } .edit-value.ref input { position:relative; left: 0; } .edit-value .input { width: 256px; } .search-input.hidden { left: -1000px; } #arrow polyline { stroke: #fff; stroke-width: 2; fill: none } .node { cursor: pointer; } .node.hover { opacity: 1 !important; } .node .fill { opacity: 0; } .node .shape { animation_: 2s blink infinite; fill: #66ccff; } .node.hover .shape { stroke-width: 2; stroke: #3fc } .node.selected .shape { fill: #fcc; } .node .shape.script { transform-box: fill-box; transform-origin: 50% 50%; transform: rotate(45deg); fill: none; stroke-width: 2px; stroke: #66ccff; } .node.selected .shape.script { stroke: #fcc; } .node .shape.none { stroke-width: 2px; stroke: #66ccff; } .node .shape.error { fill: #FF0000 !important; } .node.selected .shape.none { stroke: #fcc; } .node-info { position: absolute; top: 0; left: 0; z-index: 10; border: 1px solid white; background: black; padding: .4em; max-width: 256px; color: white; display: flex; gap: .4em; flex-direction: column; } .node-info .args { display: flex; gap: 8px; flex-wrap: wrap; } .node-info .args span.clickable { cursor: pointer; text-decoration: underline dotted;  } /* result props */ .result { position: fixed; bottom: 100px; left: 100px; max-width: 33%; } .result.error { color: red; } text { user-select: none; fill: white; } .link.selected { stroke: red; } .link { stroke: #ccc; } svg.edge-info.selected rect { fill: red; } .insert-node, #dummy-add-node { cursor: pointer; stroke: #fff; stroke-width: 32; stroke-opacity: 1; } .insert-node .circle, #dummy-add-node .circle { fill-opacity: 0.5; } .node text { filter: url(#flood-background) } .node text .primary { font-weight: bold; } .node text .secondary { font-style: italic; } .node.selected text .secondary:hover { text-decoration: dashed underline; } .show-key { position: fixed; right: 100px; top: 100px; font-size: 2em;; font-family: consolas; } .edge-info { filter: url(\"#flood-background\"); padding: 4px; cursor: pointer; } .edge-info.selected { filter: url(\"#selected-flood-background\"); } .error.main { position: absolute; top: 0; left: 0; width: 25vw; color: red; padding: 1em; height: 8em; z-index: 100; } /* popover */ #node-editor-popover { position: fixed; width: 100vw; height: 100vh; z-index: 100; top: 0; left: 0; background: #000000EE; } .popover { position: absolute; z-index: 100; background: #000000EE; }"
    					},
    					{
    						id: "style_h_text",
    						ref: "html_text"
    					},
    					{
    						id: "style_dom_type",
    						value: "style"
    					},
    					{
    						id: "out",
    						ref: "html_element"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "args",
    						type: "ref"
    					},
    					{
    						from: "style_h_text",
    						to: "out",
    						as: "children"
    					},
    					{
    						from: "style_content",
    						to: "style_h_text",
    						as: "text"
    					},
    					{
    						from: "style_dom_type",
    						to: "out",
    						as: "dom_type"
    					}
    				]
    			},
    			{
    				id: "edit_text",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "html_id",
    						ref: "arg",
    						value: "html_id"
    					},
    					{
    						id: "display_graph_nodes",
    						ref: "arg",
    						value: "display_graph.nodes"
    					},
    					{
    						id: "nodes",
    						ref: "arg",
    						value: "nodes"
    					},
    					{
    						id: "selected",
    						ref: "arg",
    						value: "selected.0"
    					},
    					{
    						id: "dimensions",
    						ref: "arg",
    						value: "dimensions"
    					},
    					{
    						id: "display_graph",
    						ref: "arg",
    						value: "display_graph"
    					},
    					{
    						id: "selected_edge",
    						ref: "arg",
    						value: "selected_edge"
    					},
    					{
    						id: "editing",
    						ref: "arg",
    						value: "editing"
    					},
    					{
    						id: "levels",
    						ref: "arg",
    						value: "levels"
    					},
    					{
    						id: "edit_value",
    						ref: "arg",
    						value: "edit_value"
    					},
    					{
    						id: "on_editmore_action",
    						ref: "arg",
    						value: "oneditmore"
    					},
    					{
    						id: "selected_node",
    						script: "return nodes.find(n => n.node_id === selected)"
    					},
    					{
    						id: "ref_nodes",
    						script: "return nodes.filter(n => !(n.ref || levels.level_by_node.has(n.id)) && (n.script || n.nodes))"
    					},
    					{
    						id: "edit_text",
    						ref: "html_element"
    					},
    					{
    						id: "edit_text_dom_type",
    						value: "div"
    					},
    					{
    						id: "edit_text_label_wrapper_children",
    						ref: "array"
    					},
    					{
    						id: "edit_text_label_wrapper",
    						ref: "html_element"
    					},
    					{
    						id: "edit_text_input",
    						ref: "html_element"
    					},
    					{
    						id: "edit_text_textarea",
    						ref: "html_element"
    					},
    					{
    						id: "confirm_edit_text",
    						ref: "confirm_edit_text"
    					},
    					{
    						id: "edit_position",
    						ref: "arg",
    						value: "edit_position"
    					},
    					{
    						id: "svg_offset",
    						ref: "arg",
    						value: "svg_offset"
    					},
    					{
    						id: "edit_html_position",
    						script: "return {x: Math.min(dimensions.x - 256 * 1.25, (position?.x ?? 0) * (svg_offset?.scale ?? 1) + (svg_offset?.x ?? 0)), y: Math.min(dimensions.y - 64, (position?.y ?? 0) * (svg_offset?.scale ?? 1) + (svg_offset?.y ?? 0))}"
    					},
    					{
    						id: "edit_text_base_props",
    						script: "return {id: `${html_id}-edit-value`, class: {'edit-value': true, [editing]: true}, onclick: (s, payload) => (payload.preventDefault(), payload.stopPropagation(), [s, [confirm_edit_text, payload]])}"
    					},
    					{
    						id: "edit_text_props"
    					},
    					{
    						id: "edit_text_edit_box",
    						ref: "switch"
    					},
    					{
    						id: "centering_wrapper_children",
    						script: "return [label.el, edit_box?.el, editing === 'ref' ? ref_description?.el : false, editing === 'ref' ? ref_datalist.el : false]"
    					},
    					{
    						id: "edit_text_textarea_dom_type",
    						args: [
    							"editing"
    						],
    						script: "return 'textarea'"
    					},
    					{
    						id: "edit_text_textarea_props",
    						script: "const start_value = edit_value ?? (!editing ? '' : (selected_edge ? display_graph.edges.find(e => e.from === selected_edge.from && e.to === selected_edge.to) : display_graph.nodes.find(n => n.id === selected))[editing]); return {id: `${html_id}-textarea`, class: {textarea: true, [editing]: true}, onclick: (s, payload) => (payload.stopPropagation(), s), value: typeof(start_value) === 'string' ? start_value : JSON.stringify(start_value), oninput: (s, payload) => ({...s, edit_value: payload.target.value}), onfocus: (s, payload) => [s, [() => payload.target.setSelectionRange(0, payload.target.value.length)]] }"
    					},
    					{
    						id: "edit_text_input_dom_type",
    						args: [
    							"editing"
    						],
    						script: "return 'input'"
    					},
    					{
    						id: "edit_text_input_props",
    						script: "const start_value = edit_value ?? (!editing ? '' : (selected_edge ? display_graph.edges.find(e => e.from === selected_edge.from && e.to === selected_edge.to) : display_graph.nodes.find(n => n.id === selected))[editing]); return Object.assign({id: `${html_id}-edit-text`, class: {input: true, [editing]: true}, value: typeof(start_value) === 'string' ? start_value : JSON.stringify(start_value), onclick: (s, payload) => (payload.stopPropagation(), s), onkeydown: (s, payload) => [s, (payload.key === 'Enter' ? (payload.stopPropagation(), [confirm_edit_text, payload]): false)], oninput: (s, payload) => ({...s, edit_value: payload.target.value}), onfocus: (s, payload) => [s, [() => payload.target.setSelectionRange(0, payload.target.value.length)]]}, editing === 'ref' ? {list: 'node-options', type: 'text'} : {})"
    					},
    					{
    						id: "edit_text_label",
    						ref: "html_element"
    					},
    					{
    						id: "edit_text_label_dom_type",
    						value: "label"
    					},
    					{
    						id: "edit_text_label_props",
    						script: "return {for: `${html_id}-edit-text`}"
    					},
    					{
    						id: "edit_text_label_text",
    						ref: "html_text"
    					},
    					{
    						id: "edit_text_more_props",
    						script: "return {onclick: on_editmore_action, class: {more: true, hydrated: true, md: true}}"
    					},
    					{
    						id: "edit_text_more_icon",
    						value: "ellipsis-vertical-outline"
    					},
    					{
    						id: "edit_text_more",
    						ref: "icon"
    					},
    					{
    						id: "editing_path",
    						value: "editing"
    					},
    					{
    						id: "editing",
    						ref: "arg",
    						value: "editing"
    					},
    					{
    						id: "ref_description",
    						out: "out",
    						nodes: [
    							{
    								id: "node_id",
    								ref: "arg",
    								value: "node_id"
    							},
    							{
    								id: "nodes",
    								ref: "arg",
    								value: "nodes"
    							},
    							{
    								id: "node_description",
    								ref: "node_description"
    							},
    							{
    								id: "description_text",
    								ref: "html_text"
    							},
    							{
    								id: "out",
    								ref: "html_element"
    							}
    						],
    						edges: [
    							{
    								from: "node_id",
    								to: "node_description",
    								as: "node_id"
    							},
    							{
    								from: "nodes",
    								to: "node_description",
    								as: "nodes"
    							},
    							{
    								from: "node_description",
    								to: "description_text",
    								as: "text"
    							},
    							{
    								from: "description_text",
    								to: "out",
    								as: "children"
    							}
    						]
    					},
    					{
    						id: "ref_datalist",
    						name: "ref_datalist",
    						out: "xtr0qj6",
    						nodes: [
    							{
    								id: "xtr0qj6",
    								ref: "html_element",
    								name: "ref_datalist"
    							},
    							{
    								id: "0msbgbm",
    								ref: "map"
    							},
    							{
    								id: "buav28h",
    								value: "datalist"
    							},
    							{
    								id: "ql1hqrf"
    							},
    							{
    								id: "jppiihp/jppiihp",
    								ref: "html_element"
    							},
    							{
    								id: "h2altl0",
    								ref: "arg",
    								value: "ref_nodes"
    							},
    							{
    								id: "jgaye79",
    								value: "node-options"
    							},
    							{
    								id: "tk685lj"
    							},
    							{
    								id: "2xycz42",
    								value: "option"
    							},
    							{
    								id: "8v5dk5c",
    								ref: "html_text"
    							},
    							{
    								id: "jppiihp/ci554ww",
    								ref: "arg",
    								value: "element.id"
    							},
    							{
    								id: "n5dpir5",
    								ref: "default"
    							},
    							{
    								id: "9q28w9y",
    								ref: "arg",
    								value: "element.name"
    							},
    							{
    								id: "6s0wcu9",
    								ref: "arg",
    								value: "element.id"
    							}
    						],
    						edges: [
    							{
    								from: "0msbgbm",
    								to: "xtr0qj6",
    								as: "children"
    							},
    							{
    								from: "buav28h",
    								to: "xtr0qj6",
    								as: "dom_type"
    							},
    							{
    								from: "ql1hqrf",
    								to: "xtr0qj6",
    								as: "props"
    							},
    							{
    								from: "jppiihp/jppiihp",
    								to: "0msbgbm",
    								as: "fn",
    								type: "ref"
    							},
    							{
    								from: "h2altl0",
    								to: "0msbgbm",
    								as: "array"
    							},
    							{
    								from: "jgaye79",
    								to: "ql1hqrf",
    								as: "id"
    							},
    							{
    								from: "tk685lj",
    								to: "jppiihp/jppiihp",
    								as: "props"
    							},
    							{
    								from: "2xycz42",
    								to: "jppiihp/jppiihp",
    								as: "dom_type"
    							},
    							{
    								from: "8v5dk5c",
    								to: "jppiihp/jppiihp",
    								as: "children"
    							},
    							{
    								from: "jppiihp/ci554ww",
    								to: "tk685lj",
    								as: "value"
    							},
    							{
    								from: "n5dpir5",
    								to: "8v5dk5c",
    								as: "text"
    							},
    							{
    								from: "9q28w9y",
    								to: "n5dpir5",
    								as: "value"
    							},
    							{
    								from: "6s0wcu9",
    								to: "n5dpir5",
    								as: "otherwise"
    							}
    						]
    					},
    					{
    						id: "get_nodes",
    						ref: "arg",
    						value: "display_graph.nodes"
    					},
    					{
    						id: "get_id",
    						script: "return node.id"
    					},
    					{
    						id: "centering_wrapper_dom_type",
    						value: "div"
    					},
    					{
    						id: "centering_wrapper_props",
    						script: "return {class: {centering: true}, style: {left: `${position.x}px`, top: `${position.y}px`} }"
    					},
    					{
    						id: "centering_wrapper",
    						ref: "html_element"
    					},
    					{
    						id: "edit_text_children",
    						ref: "array"
    					},
    					{
    						id: "edit_text_el_wrapper",
    						script: "return et.el"
    					},
    					{
    						id: "out"
    					}
    				],
    				edges: [
    					{
    						from: "selected",
    						to: "edit_text_textarea_props",
    						as: "selected"
    					},
    					{
    						from: "selected_edge",
    						to: "edit_text_textarea_props",
    						as: "selected_edge"
    					},
    					{
    						from: "display_graph",
    						to: "edit_text_textarea_props",
    						as: "display_graph"
    					},
    					{
    						from: "edit_value",
    						to: "edit_text_textarea_props",
    						as: "edit_value"
    					},
    					{
    						from: "editing",
    						to: "edit_text_textarea_props",
    						as: "editing"
    					},
    					{
    						from: "selected",
    						to: "edit_text_textarea_props",
    						as: "selected"
    					},
    					{
    						from: "selected_edge",
    						to: "edit_text_input_props",
    						as: "selected_edge"
    					},
    					{
    						from: "display_graph",
    						to: "edit_text_input_props",
    						as: "display_graph"
    					},
    					{
    						from: "edit_value",
    						to: "edit_text_input_props",
    						as: "edit_value"
    					},
    					{
    						from: "editing",
    						to: "edit_text_input_props",
    						as: "editing"
    					},
    					{
    						from: "selected",
    						to: "edit_text_input_props",
    						as: "selected"
    					},
    					{
    						from: "selected",
    						to: "selected_node",
    						as: "selected"
    					},
    					{
    						from: "nodes",
    						to: "selected_node",
    						as: "nodes"
    					},
    					{
    						from: "selected_node",
    						to: "centering_wrapper_props",
    						as: "node"
    					},
    					{
    						from: "edit_text",
    						to: "edit_text_el_wrapper",
    						as: "et"
    					},
    					{
    						from: "editing",
    						to: "edit_text_edit_box",
    						as: "input"
    					},
    					{
    						from: "editing",
    						to: "centering_wrapper_children",
    						as: "editing"
    					},
    					{
    						from: "edit_text_el_wrapper",
    						to: "out",
    						as: "el"
    					},
    					{
    						from: "edit_text_dom_type",
    						to: "edit_text",
    						as: "dom_type"
    					},
    					{
    						from: "html_id",
    						to: "edit_text_base_props",
    						as: "html_id"
    					},
    					{
    						from: "edit_text_base_props",
    						to: "edit_text_props"
    					},
    					{
    						from: "edit_text_props",
    						to: "edit_text",
    						as: "props"
    					},
    					{
    						from: "centering_wrapper",
    						to: "edit_text",
    						as: "children"
    					},
    					{
    						from: "dimensions",
    						to: "edit_html_position",
    						as: "dimensions"
    					},
    					{
    						from: "edit_position",
    						to: "edit_html_position",
    						as: "position"
    					},
    					{
    						from: "svg_offset",
    						to: "edit_html_position",
    						as: "svg_offset"
    					},
    					{
    						from: "edit_html_position",
    						to: "centering_wrapper_props",
    						as: "position"
    					},
    					{
    						from: "html_id",
    						to: "edit_text_input_props",
    						as: "html_id"
    					},
    					{
    						from: "confirm_edit_text",
    						to: "edit_text_input_props",
    						as: "confirm_edit_text"
    					},
    					{
    						from: "edit_text_input_props",
    						to: "edit_text_input",
    						as: "props"
    					},
    					{
    						from: "edit_text_input_dom_type",
    						to: "edit_text_input",
    						as: "dom_type"
    					},
    					{
    						from: "edit_text_input",
    						to: "edit_text_edit_box",
    						as: "otherwise"
    					},
    					{
    						from: "edit_text_textarea",
    						to: "edit_text_edit_box",
    						as: "script"
    					},
    					{
    						from: "edit_text_edit_box",
    						to: "centering_wrapper_children",
    						as: "edit_box"
    					},
    					{
    						from: "levels",
    						to: "ref_nodes",
    						as: "levels"
    					},
    					{
    						from: "nodes",
    						to: "ref_nodes",
    						as: "nodes"
    					},
    					{
    						from: "display_graph_nodes",
    						to: "ref_nodes",
    						as: "nodes"
    					},
    					{
    						from: "ref_nodes",
    						to: "ref_datalist",
    						as: "ref_nodes"
    					},
    					{
    						from: "ref_datalist",
    						to: "centering_wrapper_children",
    						as: "ref_datalist"
    					},
    					{
    						from: "edit_value",
    						to: "ref_description",
    						as: "node_id"
    					},
    					{
    						from: "display_graph_nodes",
    						to: "ref_description",
    						as: "nodes"
    					},
    					{
    						from: "ref_description",
    						to: "centering_wrapper_children",
    						as: "ref_description"
    					},
    					{
    						from: "html_id",
    						to: "edit_text_textarea_props",
    						as: "html_id"
    					},
    					{
    						from: "edit_text_textarea_props",
    						to: "edit_text_textarea",
    						as: "props"
    					},
    					{
    						from: "edit_text_textarea_dom_type",
    						to: "edit_text_textarea",
    						as: "dom_type"
    					},
    					{
    						from: "html_id",
    						to: "edit_text_label_props",
    						as: "html_id"
    					},
    					{
    						from: "edit_text_more",
    						to: "edit_text_label_wrapper_children",
    						as: "a1"
    					},
    					{
    						from: "edit_text_label",
    						to: "edit_text_label_wrapper_children",
    						as: "a0"
    					},
    					{
    						from: "edit_text_label_wrapper_children",
    						to: "edit_text_label_wrapper",
    						as: "children"
    					},
    					{
    						from: "edit_text_label_wrapper",
    						to: "centering_wrapper_children",
    						as: "label"
    					},
    					{
    						from: "edit_text_label_props",
    						to: "edit_text_label",
    						as: "props"
    					},
    					{
    						from: "edit_text_label_dom_type",
    						to: "edit_text_label",
    						as: "dom_type"
    					},
    					{
    						from: "edit_text_label_text",
    						to: "edit_text_label",
    						as: "children"
    					},
    					{
    						from: "on_editmore_action",
    						to: "edit_text_more_props",
    						as: "on_editmore_action"
    					},
    					{
    						from: "edit_text_more_props",
    						to: "edit_text_more",
    						as: "props"
    					},
    					{
    						from: "edit_text_more_icon",
    						to: "edit_text_more",
    						as: "icon"
    					},
    					{
    						from: "in",
    						to: "get_nodes"
    					},
    					{
    						from: "get_nodes",
    						to: "get_id",
    						as: "node"
    					},
    					{
    						from: "get_id",
    						to: "id_text",
    						as: "text"
    					},
    					{
    						from: "editing",
    						to: "edit_text_label_text",
    						as: "text"
    					},
    					{
    						from: "editing",
    						to: "edit_text_base_props",
    						as: "editing"
    					},
    					{
    						from: "confirm_edit_text",
    						to: "edit_text_base_props",
    						as: "confirm_edit_text"
    					},
    					{
    						from: "centering_wrapper_dom_type",
    						to: "centering_wrapper",
    						as: "dom_type"
    					},
    					{
    						from: "centering_wrapper_props",
    						to: "centering_wrapper",
    						as: "props"
    					},
    					{
    						from: "centering_wrapper_children",
    						to: "centering_wrapper",
    						as: "children"
    					},
    					{
    						from: "centering_wrapper",
    						to: "edit_text_children",
    						as: "a0"
    					},
    					{
    						from: "edit_text_children",
    						to: "edit_text",
    						as: "children"
    					}
    				]
    			},
    			{
    				id: "popover_graph_h",
    				nodes: [
    					{
    						id: "html_id",
    						ref: "arg",
    						value: "html_id"
    					},
    					{
    						id: "update_sim",
    						ref: "arg",
    						value: "update_sim"
    					},
    					{
    						id: "randid",
    						ref: "arg",
    						value: "randid"
    					},
    					{
    						id: "handle_popover_event",
    						ref: "handle_popover_event"
    					},
    					{
    						id: "clear_popover",
    						ref: "clear_popover_graph"
    					},
    					{
    						id: "props",
    						script: "return {id: `${html_id}-popover`, class: {popover: true}, key:  `${html_id}-popover`, onselectnode: handle_popover_event, ongraphclick: (s, p) => [s]}"
    					},
    					{
    						id: "dom_type",
    						value: "div"
    					},
    					{
    						id: "out",
    						ref: "html_element"
    					}
    				],
    				edges: [
    					{
    						from: "update_sim",
    						to: "props",
    						as: "update_sim"
    					},
    					{
    						from: "handle_popover_event",
    						to: "props",
    						as: "handle_popover_event"
    					},
    					{
    						from: "clear_popover",
    						to: "props",
    						as: "clear_popover"
    					},
    					{
    						from: "props",
    						to: "out",
    						as: "props"
    					},
    					{
    						from: "html_id",
    						to: "props",
    						as: "html_id"
    					},
    					{
    						from: "dom_type",
    						to: "out",
    						as: "dom_type"
    					}
    				]
    			},
    			{
    				id: "popover_graph_h_wrapper"
    			},
    			{
    				id: "result",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "error",
    						ref: "arg",
    						value: "error"
    					},
    					{
    						id: "html_id",
    						ref: "arg",
    						value: "html_id"
    					},
    					{
    						id: "get_node",
    						script: "return display_graph.nodes.find(n => n.id === selected[0])"
    					},
    					{
    						id: "get_type",
    						script: "return ref?.display_type ? ref.display_type : typeof value !== 'undefined' && typeof value !== 'object' ? typeof value : ref ? (ref.node_type ?? ref) : nodes ? 'graph' : script ? 'script' : 'object'"
    					},
    					{
    						id: "result",
    						ref: "arg",
    						value: "result"
    					},
    					{
    						id: "display_graph",
    						ref: "arg",
    						value: "display_graph"
    					},
    					{
    						id: "container_dom_type",
    						value: "div"
    					},
    					{
    						id: "container_props",
    						args: [
    							"error"
    						],
    						script: "return {class: {error: error ? 'error' : '', result: true}, id: `${html_id}-result`}"
    					},
    					{
    						id: "container_children_inputs",
    						script: "return error? ['error_display'] : ['display']"
    					},
    					{
    						id: "container_children",
    						ref: "switch"
    					},
    					{
    						id: "container",
    						ref: "html_element"
    					},
    					{
    						id: "text_value",
    						args: [
    							"result",
    							"error"
    						],
    						script: "return error ?? result ?? ''"
    					},
    					{
    						id: "out"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "container_props"
    					},
    					{
    						from: "in",
    						to: "get_node"
    					},
    					{
    						from: "in",
    						to: "get_node_display"
    					},
    					{
    						from: "in",
    						to: "get_error_display"
    					},
    					{
    						from: "in",
    						to: "run_error_display"
    					},
    					{
    						from: "error",
    						to: "container_children_inputs",
    						as: "error"
    					},
    					{
    						from: "get_node",
    						to: "get_type"
    					},
    					{
    						from: "get_type",
    						to: "get_node_display",
    						as: "type"
    					},
    					{
    						from: "get_type",
    						to: "get_error_display",
    						as: "type"
    					},
    					{
    						from: "get_node",
    						to: "run_node_display",
    						as: "node"
    					},
    					{
    						from: "get_node",
    						to: "run_error_display",
    						as: "node"
    					},
    					{
    						from: "get_node_display",
    						to: "run_node_display",
    						as: "display"
    					},
    					{
    						from: "display_graph",
    						to: "run_node_display",
    						as: "display_graph"
    					},
    					{
    						from: "result",
    						to: "run_node_display",
    						as: "result"
    					},
    					{
    						from: "get_error_display",
    						to: "run_error_display",
    						as: "error_display"
    					},
    					{
    						from: "container_children_inputs",
    						to: "container_children",
    						as: "input"
    					},
    					{
    						from: "run_node_display",
    						to: "container_children",
    						as: "display"
    					},
    					{
    						from: "run_error_display",
    						to: "container_children",
    						as: "error_display"
    					},
    					{
    						from: "run_node_display",
    						to: "run_error_display"
    					},
    					{
    						from: "container_props",
    						to: "container",
    						as: "props"
    					},
    					{
    						from: "container_children",
    						to: "container",
    						as: "children"
    					},
    					{
    						from: "container_dom_type",
    						to: "container",
    						as: "dom_type"
    					},
    					{
    						from: "container",
    						to: "out"
    					}
    				]
    			},
    			{
    				id: "menu",
    				nodes: [
    					{
    						id: "readonly",
    						ref: "arg",
    						value: "readonly"
    					},
    					{
    						id: "false",
    						value: false
    					},
    					{
    						id: "search_input",
    						nodes: [
    							{
    								id: "in"
    							},
    							{
    								id: "search",
    								ref: "arg",
    								value: "search"
    							},
    							{
    								id: "is_searching",
    								script: "return typeof search === 'string'"
    							},
    							{
    								id: "search_input_dom_type",
    								value: "input"
    							},
    							{
    								id: "nodes",
    								ref: "arg",
    								value: "nodes"
    							},
    							{
    								id: "html_id",
    								ref: "arg",
    								value: "html_id"
    							},
    							{
    								id: "display_graph",
    								ref: "arg",
    								value: "display_graph"
    							},
    							{
    								id: "search_input_props",
    								script: "return {id: `${html_id}-search-input`, key: `${html_id}-search-input`, class: 'search-input', type: 'text', onkeydown: (s, payload) => { if(payload.key === 'Enter'){ const direction = payload.shiftKey ? -1 : 1; const idx = (s.search_results.length + s.search_index + direction) % s.search_results.length; return [{...s, selected: s.search_results.slice(idx, idx + 1), search_index: idx}, [s.panzoom_selected_effect, {...s, selected: s.search_results[idx]}], [s.update_hyperapp]] } else { return s;} }, oninput: (s, payload) => {const search_results = new _lib.Fuse(nodes.map(n => Object.assign({}, n, display_graph.nodes.find(d => d.id === n.node_id))), {keys: ['name', 'node_id', 'ref', 'value']}).search(payload.target.value).map(r => r.item.node_id); return [{...s, search: payload.target.value, selected: search_results.length > 0 ? search_results.slice(0, 1) : s.selected, search_results, search_index: 0}, search_results.length > 0 && [s.panzoom_selected_effect, {...s, selected: search_results[0]}], [s.update_hyperapp]]}}"
    							},
    							{
    								id: "search_field",
    								ref: "html_element"
    							},
    							{
    								id: "search_effect",
    								ref: "search_effect"
    							},
    							{
    								id: "focus_effect",
    								ref: "focus_effect"
    							},
    							{
    								id: "search_icon_props",
    								script: "return {id: `${html_id}-search-input`, key: `${html_id}-search-input-icon`, class: 'search-input search-input-icon', onclick: s => [s, [search, {search: ''}], [focus, {selector: `#${html_id}-search-input`}]]}"
    							},
    							{
    								id: "search_icon_dom_type",
    								value: "div"
    							},
    							{
    								id: "search_icon_name",
    								value: "search"
    							},
    							{
    								id: "search_icon",
    								ref: "icon"
    							},
    							{
    								id: "out",
    								ref: "if"
    							}
    						],
    						edges: [
    							{
    								from: "html_id",
    								to: "search_input_props",
    								as: "html_id"
    							},
    							{
    								from: "nodes",
    								to: "search_input_props",
    								as: "nodes"
    							},
    							{
    								from: "display_graph",
    								to: "search_input_props",
    								as: "display_graph"
    							},
    							{
    								from: "search",
    								to: "is_searching",
    								as: "search"
    							},
    							{
    								from: "search_input_dom_type",
    								to: "search_field",
    								as: "dom_type"
    							},
    							{
    								from: "search_input_props",
    								to: "search_field",
    								as: "props"
    							},
    							{
    								from: "html_id",
    								to: "search_icon_props",
    								as: "html_id"
    							},
    							{
    								from: "search_effect",
    								to: "search_icon_props",
    								as: "search"
    							},
    							{
    								from: "focus_effect",
    								to: "search_icon_props",
    								as: "focus"
    							},
    							{
    								from: "search_icon_props",
    								to: "search_icon",
    								as: "props"
    							},
    							{
    								from: "search_icon_dom_type",
    								to: "search_icon",
    								as: "dom_type"
    							},
    							{
    								from: "search_icon_name",
    								to: "search_icon",
    								as: "icon"
    							},
    							{
    								from: "search_icon",
    								to: "out",
    								as: "false"
    							},
    							{
    								from: "search_field",
    								to: "out",
    								as: "true"
    							},
    							{
    								from: "is_searching",
    								to: "out",
    								as: "pred"
    							}
    						]
    					},
    					{
    						id: "close",
    						nodes: [
    							{
    								id: "icon",
    								value: "close"
    							},
    							{
    								id: "dispatch_custom_event_effect",
    								ref: "dispatch_custom_event_effect"
    							},
    							{
    								id: "props",
    								script: "return {onclick: (s, p) => (p.stopPropagation(), [s, [dispatch_custom, {event: 'selectnode', detail: {node: s.display_graph.out}, html_id: s.html_id}]])}"
    							},
    							{
    								id: "out",
    								ref: "icon"
    							}
    						],
    						edges: [
    							{
    								from: "dispatch_custom_event_effect",
    								to: "props",
    								as: "dispatch_custom"
    							},
    							{
    								from: "props",
    								to: "out",
    								as: "props"
    							},
    							{
    								from: "icon",
    								to: "out",
    								as: "icon"
    							}
    						]
    					},
    					{
    						id: "close_readonly",
    						ref: "if"
    					},
    					{
    						id: "more",
    						nodes: [
    							{
    								id: "icon",
    								value: "ellipsis-vertical-outline"
    							},
    							{
    								id: "onclick",
    								ref: "graph_ui_action"
    							},
    							{
    								id: "props",
    								script: "return {onclick}"
    							},
    							{
    								id: "out",
    								ref: "icon"
    							}
    						],
    						edges: [
    							{
    								from: "props",
    								to: "out",
    								as: "props"
    							},
    							{
    								from: "icon",
    								to: "out",
    								as: "icon"
    							},
    							{
    								from: "onclick",
    								to: "props",
    								as: "onclick"
    							}
    						]
    					},
    					{
    						id: "more_readonly",
    						ref: "if"
    					},
    					{
    						id: "dom_type",
    						value: "div"
    					},
    					{
    						id: "children",
    						ref: "array"
    					},
    					{
    						id: "html_id",
    						ref: "arg",
    						value: "html_id"
    					},
    					{
    						id: "props",
    						script: "return {class: {'graph-ui': true}, key: `${html_id}-graph-ui`}"
    					},
    					{
    						id: "out",
    						ref: "html_element"
    					}
    				],
    				edges: [
    					{
    						from: "more",
    						to: "more_readonly",
    						as: "false"
    					},
    					{
    						from: "false",
    						to: "more_readonly",
    						as: "true"
    					},
    					{
    						from: "readonly",
    						to: "more_readonly",
    						as: "pred"
    					},
    					{
    						from: "more_readonly",
    						to: "children",
    						as: "a1"
    					},
    					{
    						from: "search_input",
    						to: "children",
    						as: "a0"
    					},
    					{
    						from: "readonly",
    						to: "close_readonly",
    						as: "pred"
    					},
    					{
    						from: "close",
    						to: "close_readonly",
    						as: "true"
    					},
    					{
    						from: "false",
    						to: "close_readonly",
    						as: "false"
    					},
    					{
    						from: "close_readonly",
    						to: "children",
    						as: "a2",
    						type: "resolve"
    					},
    					{
    						from: "html_id",
    						to: "props",
    						as: "html_id"
    					},
    					{
    						from: "children",
    						to: "out",
    						as: "children"
    					},
    					{
    						from: "props",
    						to: "out",
    						as: "props"
    					},
    					{
    						from: "dom_type",
    						to: "out",
    						as: "dom_type"
    					}
    				]
    			},
    			{
    				id: "node_editor",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "out",
    						ref: "html_element"
    					},
    					{
    						id: "panzoom_box_dom_type",
    						value: "g"
    					},
    					{
    						id: "panzoom_box_props",
    						script: "return {id: `${html_id}-editor-panzoom`}"
    					},
    					{
    						id: "panzoom_box",
    						ref: "html_element"
    					},
    					{
    						id: "panzoom_box_arr",
    						ref: "array"
    					},
    					{
    						id: "html_id",
    						ref: "arg",
    						value: "html_id"
    					},
    					{
    						id: "hover",
    						ref: "arg",
    						value: "hover"
    					},
    					{
    						id: "randid",
    						ref: "arg",
    						value: "randid"
    					},
    					{
    						id: "node_el_width",
    						ref: "arg",
    						value: "node_el_width"
    					},
    					{
    						id: "display_graph",
    						ref: "arg",
    						value: "display_graph"
    					},
    					{
    						id: "readonly",
    						ref: "arg",
    						value: "readonly"
    					},
    					{
    						id: "hash",
    						ref: "arg",
    						value: "hash"
    					},
    					{
    						id: "show_all",
    						ref: "arg",
    						value: "show_all"
    					},
    					{
    						id: "error",
    						ref: "arg",
    						value: "error"
    					},
    					{
    						id: "hide_types",
    						ref: "arg",
    						value: "hide_types"
    					},
    					{
    						id: "links",
    						ref: "arg",
    						value: "links"
    					},
    					{
    						id: "get_levels",
    						ref: "arg",
    						value: "levels"
    					},
    					{
    						id: "nodes",
    						ref: "arg",
    						value: "nodes"
    					},
    					{
    						id: "dg_nodes",
    						ref: "arg",
    						value: "display_graph.nodes"
    					},
    					{
    						id: "dg_selected",
    						ref: "find_node"
    					},
    					{
    						id: "get_nodes",
    						script: "return nodes?.map(n => ({...n, x: (n.x - node_el_width * 0.5)})) ?? []"
    					},
    					{
    						id: "get_links",
    						script: "return links?.map(l => (Object.assign({}, l, {source: Object.assign({}, l.source, {x: (l.source.x - node_el_width * 0.5)}), target: Object.assign({}, l.target, {x: (l.target.x - node_el_width * 0.5)})}))) ?? []"
    					},
    					{
    						id: "get_selected",
    						ref: "arg",
    						value: "selected"
    					},
    					{
    						id: "get_graph",
    						ref: "arg",
    						value: "graph"
    					},
    					{
    						id: "get_selected_node",
    						ref: "find_node"
    					},
    					{
    						id: "get_selected_edge",
    						ref: "arg",
    						value: "selected_edge"
    					},
    					{
    						id: "dimensions",
    						ref: "arg",
    						value: "dimensions"
    					},
    					{
    						id: "onclick_graph",
    						ref: "onclick_graph_action"
    					},
    					{
    						id: "node_editor_props",
    						script: "return {id: `${html_id}-editor`, class: {[`hash-${hash.substring(1)}`]: hash.length > 0},width: dimensions.x, height: dimensions.y, onclick: onclick_graph, ontouchstart: onclick_graph}"
    					},
    					{
    						id: "node_editor_dom_type",
    						value: "svg"
    					},
    					{
    						id: "node_editor_children",
    						script: "return [defs.el].concat(nodes?.map(c => c.el) ?? []).concat(links?.flatMap(l => l.map(lc => lc.el)) ?? [])"
    					},
    					{
    						id: "node_args",
    						ref: "node_args"
    					},
    					{
    						id: "dummy_nodes",
    						script: "return !selected_node ? [] : [{node_id: selected_node.node_id + a, node_child_id: selected_node.node_id + a, dummy: true, name: a, x: selected_node.x - 128, y: selected_node.y + 32 * i}))"
    					},
    					{
    						id: "dummy_links",
    						script: "return !selected_node ? [] : nodes.map(n => ({edge: {from: n.id, to: selected_node.node_id, as: n.name}, source: n, target: selected_node}))"
    					},
    					{
    						id: "dummy_node_el",
    						nodes: [
    							{
    								id: "randid",
    								ref: "arg",
    								value: "randid"
    							},
    							{
    								id: "selected",
    								ref: "arg",
    								value: "selected_node.node_id"
    							},
    							{
    								id: "selected_node",
    								ref: "arg",
    								value: "selected_node"
    							},
    							{
    								id: "add_node",
    								ref: "add_node"
    							},
    							{
    								id: "base_props",
    								value: {
    									href: "svg/add-circle-outline.svg#icon",
    									width: "32px",
    									height: "32px",
    									id: "dummy-add-node"
    								}
    							},
    							{
    								id: "onclick_props",
    								script: "return {onclick: (s, p) => [s, [add_node, {node: {id: randid}, child}]], ontouchstart: (s, p) => [s, [add_node, {node: {id: randid}, child}]]}"
    							},
    							{
    								id: "position",
    								script: "return {x: (node?.x ?? 0) - 64, y: (node?.y ?? 0) - 64}"
    							},
    							{
    								id: "props",
    								ref: "merge_objects"
    							},
    							{
    								id: "out",
    								ref: "add_circle_icon"
    							}
    						],
    						edges: [
    							{
    								from: "selected",
    								to: "onclick_props",
    								as: "child"
    							},
    							{
    								from: "randid",
    								to: "onclick_props",
    								as: "randid"
    							},
    							{
    								from: "add_node",
    								to: "onclick_props",
    								as: "add_node"
    							},
    							{
    								from: "base_props",
    								to: "props",
    								as: "a0"
    							},
    							{
    								from: "onclick_props",
    								to: "props",
    								as: "a1"
    							},
    							{
    								from: "selected_node",
    								to: "position",
    								as: "node"
    							},
    							{
    								from: "position",
    								to: "_props",
    								as: "a2"
    							},
    							{
    								from: "props",
    								to: "out",
    								as: "props"
    							}
    						]
    					},
    					{
    						id: "dummy_node_els",
    						script: "const fn = _lib.no.executeGraphNode({graph: _graph})(node_layout_map); return nodes.map(n => fn({node: n, selected, selected_distance: 0}))"
    					},
    					{
    						id: "dummy_link_els",
    						script: "const fn = _lib.no.executeGraphNode({graph: _graph})(link_layout_map); return links.map(l => fn({link: Object.assign(l, {edge: l.edge}), selected_distance: 0}))"
    					},
    					{
    						id: "node_layout",
    						script: "const error_nodes = error instanceof AggregateError ? error.errors.map(e => e instanceof _lib.no.NodysseusError ? e.node_id : false).filter(n => n) : error instanceof _lib.no.NodysseusError ? [error.node_id] : []; const fn = _lib.no.executeGraphNode({graph: {..._graph}})(node_layout_map); return nodes.sort((a, b) => levels.distance_from_selected.get(b.node_child_id) - levels.distance_from_selected.get(a.node_child_id)).map(n => fn(Object.assign({node: Object.assign({}, n, display_graph.nodes.find(dgn => dgn.id === n.node_id)), hide_types, show_all, selected_distance: levels.distance_from_selected.get(n.node_child_id), level: levels.level_by_node.get(n.node_id), node_error: !error_nodes ? false : error_nodes.filter(k => k.startsWith(n.node_id)).length > 0}, _node_inputs)))"
    					},
    					{
    						id: "node_layout_map",
    						nodes: [
    							{
    								id: "in"
    							},
    							{
    								id: "get_node",
    								ref: "arg",
    								value: "node"
    							},
    							{
    								id: "hover",
    								ref: "arg",
    								value: "hover"
    							},
    							{
    								id: "selected_edge",
    								ref: "arg",
    								value: "selected_edge"
    							},
    							{
    								id: "html_id",
    								ref: "arg",
    								value: "html_id"
    							},
    							{
    								id: "show_all",
    								ref: "arg",
    								value: "show_all"
    							},
    							{
    								id: "selected",
    								ref: "arg",
    								value: "selected"
    							},
    							{
    								id: "node_el_width",
    								ref: "arg",
    								value: "node_el_width"
    							},
    							{
    								id: "is_selected",
    								script: "return node.node_id === selected[0]"
    							},
    							{
    								id: "selected_distance",
    								ref: "arg",
    								value: "selected_distance"
    							},
    							{
    								id: "level",
    								ref: "arg",
    								value: "level"
    							},
    							{
    								id: "hide_types",
    								ref: "arg",
    								value: "hide_types"
    							},
    							{
    								id: "error",
    								ref: "arg",
    								value: "node_error"
    							},
    							{
    								id: "out",
    								ref: "html_element"
    							},
    							{
    								id: "parent",
    								ref: "html_element"
    							},
    							{
    								id: "parent_dom_type",
    								value: "svg"
    							},
    							{
    								id: "onclick_node",
    								ref: "onselectnode_action"
    							},
    							{
    								id: "parent_attrs",
    								script: "return ({onclick: (_, payload) => [onclick, {event: payload, node_id: node.node_id}],  onmouseover: (state, payload) => [{...state, hover: node.node_id}], onmouseout: (state, payload) => [{...state, hover: undefined}],  ontouchstart: (_, payload) => [onclick, {event: payload, node_id: node.node_id}], width: '256', height: '64', key: html_id + '-' + node.node_child_id, id: html_id + '-' + node.node_child_id, class: {node: true,  selected: selected[0] === node.node_id, hover: hover === node.node_id }, opacity: selected_edge?.from === node.node_id || show_all ? 1 : selected_distance !== undefined ? Math.max(0.05, 1 - (selected_distance * selected_distance) / 6) : 0.1})"
    							},
    							{
    								id: "children",
    								nodes: [
    									{
    										id: "in"
    									},
    									{
    										id: "selected_distance",
    										ref: "arg",
    										value: "selected_distance"
    									},
    									{
    										id: "node",
    										ref: "arg",
    										value: "node"
    									},
    									{
    										id: "node_node",
    										ref: "arg",
    										value: "node.node"
    									},
    									{
    										id: "error",
    										ref: "arg",
    										value: "node_error"
    									},
    									{
    										id: "node_shape_attrs",
    										script: "const r = 24; return node.script ? {class:{shape: true, script: true, error}, width: r, height: r, x: 10, y: 10} : node.ref && node.ref !== 'arg' ? {class: {shape: true, ref: true, error}, width: r, height: r, x: 10, y: 10} : node.nodes ? {class: {shape: true, graph: true, error}, r: r * 0.5, cx: r * 0.5 + 4, cy: r * 0.5 + 4}  : node.value !== undefined ? {class: {shape: true, value: true, error}, points: `4,${4 + r} ${4 + r},${4 + r} ${4 + r * 0.5},4`} : {class: {shape: true, none: true, error}, r: r * 0.5 , cx: r * 0.5 + 4, cy: r * 0.5 + 4}"
    									},
    									{
    										id: "default_color",
    										value: "blue"
    									},
    									{
    										id: "empty_array",
    										value: [
    										]
    									},
    									{
    										id: "node_shape_dom_type",
    										script: "return node.script ? 'rect' : node.ref && node.ref !== 'arg' ? 'rect' : node.value !== undefined ? 'polygon' : 'circle'"
    									},
    									{
    										id: "node_shape",
    										ref: "html_element"
    									},
    									{
    										id: "text",
    										nodes: [
    											{
    												id: "in"
    											},
    											{
    												id: "out"
    											},
    											{
    												id: "node_id",
    												value: "node_id"
    											},
    											{
    												id: "node_ref",
    												value: "ref"
    											},
    											{
    												id: "node_name",
    												value: "name"
    											},
    											{
    												id: "node_value",
    												value: "value"
    											},
    											{
    												id: "id_path"
    											},
    											{
    												id: "get_id",
    												ref: "get"
    											},
    											{
    												id: "get_name",
    												ref: "get"
    											},
    											{
    												id: "arg_node",
    												ref: "arg",
    												value: "node"
    											},
    											{
    												id: "payload_node",
    												ref: "arg",
    												value: "payload.node"
    											},
    											{
    												id: "node",
    												ref: "default"
    											},
    											{
    												id: "event",
    												ref: "arg",
    												value: "payload.event"
    											},
    											{
    												id: "hide_types",
    												ref: "arg",
    												value: "hide_types"
    											},
    											{
    												id: "update_node",
    												ref: "update_node_action"
    											},
    											{
    												id: "show_edit_text",
    												ref: "show_edit_text"
    											},
    											{
    												id: "stop_propagation_effector",
    												ref: "stop_propagation_effect"
    											},
    											{
    												id: "stop_propagation_payload"
    											},
    											{
    												id: "stop_propagation_effect",
    												ref: "array"
    											},
    											{
    												id: "get_value",
    												script: "return target.value !== undefined ? (typeof target.value === 'object' ? JSON.stringify(target.value) : target.value.toString()) : def"
    											},
    											{
    												id: "get_ref",
    												script: "return (target.ref ? target.ref : target.value !== undefined ? 'value' : target.script ? 'script' : target.nodes ? `graph (${target.nested_node_count}, ${target.nested_edge_count})` : 'object')"
    											},
    											{
    												id: "selected_distance",
    												ref: "arg",
    												value: "selected_distance"
    											},
    											{
    												id: "shorten",
    												args: [
    													"text"
    												],
    												script: "return text.substring(text.lastIndexOf('/') + 1)"
    											},
    											{
    												id: "node_primary_text_attrs",
    												value: {
    													"class": "primary",
    													dy: ".6em",
    													x: "48"
    												}
    											},
    											{
    												id: "tspan_dom_type",
    												value: "tspan"
    											},
    											{
    												id: "display_name_input",
    												script: "return n.name ? 'name' : n.value !== undefined ? 'value' : 'id'"
    											},
    											{
    												id: "display_name",
    												ref: "switch"
    											},
    											{
    												id: "node_primary_text_text",
    												ref: "html_text"
    											},
    											{
    												id: "node_primary_text",
    												ref: "html_element"
    											},
    											{
    												id: "node_secondary_text_base_props",
    												value: {
    													"class": "secondary",
    													dy: "1.2em",
    													x: "48"
    												}
    											},
    											{
    												id: "state",
    												ref: "arg",
    												value: "state"
    											},
    											{
    												id: "state_nodes",
    												ref: "arg",
    												value: "state.display_graph.nodes"
    											},
    											{
    												id: "arg_nodes",
    												ref: "arg",
    												value: "nodes"
    											},
    											{
    												id: "nodes",
    												ref: "default"
    											},
    											{
    												id: "dg_nodes",
    												ref: "default"
    											},
    											{
    												id: "state_selected",
    												ref: "arg",
    												value: "state.selected.0"
    											},
    											{
    												id: "arg_selected",
    												ref: "arg",
    												value: "selected"
    											},
    											{
    												id: "selected",
    												ref: "default"
    											},
    											{
    												id: "is_selected",
    												ref: "eq"
    											},
    											{
    												id: "selected_node",
    												ref: "find_node"
    											},
    											{
    												id: "selected_dg_node",
    												ref: "find_node"
    											},
    											{
    												id: "selected_node_id",
    												ref: "get"
    											},
    											{
    												id: "node_secondary_text_onclick_show_edit_text_payload"
    											},
    											{
    												id: "node_secondary_text_onclick_show_edit_text",
    												ref: "array"
    											},
    											{
    												id: "node_secondary_text_onclick_effects",
    												ref: "array"
    											},
    											{
    												id: "node_secondary_text_onclick"
    											},
    											{
    												id: "node_secondary_text_onclick_runnable",
    												ref: "runnable"
    											},
    											{
    												id: "node_selected_secondary_text_onclick_runnable",
    												ref: "if"
    											},
    											{
    												id: "node_secondary_text_onclick_props"
    											},
    											{
    												id: "node_secondary_text_props",
    												ref: "merge_objects"
    											},
    											{
    												id: "node_secondary_text_text",
    												ref: "html_text"
    											},
    											{
    												id: "node_secondary_text",
    												ref: "html_element"
    											},
    											{
    												id: "node_text_dom_type",
    												value: "text"
    											},
    											{
    												id: "node_text",
    												ref: "html_element"
    											},
    											{
    												id: "script",
    												value: "script"
    											},
    											{
    												id: "node_text_props",
    												args: [
    													"selected_distance"
    												],
    												script: "return { x: 48, y: 12 }"
    											},
    											{
    												id: "node_text_children",
    												args: [
    													"primary",
    													"secondary"
    												],
    												script: "return [primary.el, !hide_types && secondary.el]"
    											},
    											{
    												id: "text",
    												value: "text"
    											}
    										],
    										edges: [
    											{
    												from: "node",
    												to: "get_id",
    												as: "target"
    											},
    											{
    												from: "node_id",
    												to: "get_id",
    												as: "path"
    											},
    											{
    												from: "state_nodes",
    												to: "nodes",
    												as: "otherwise"
    											},
    											{
    												from: "arg_nodes",
    												to: "nodes",
    												as: "value"
    											},
    											{
    												from: "get_id",
    												to: "selected_node",
    												as: "node_id"
    											},
    											{
    												from: "nodes",
    												to: "selected_node",
    												as: "nodes"
    											},
    											{
    												from: "arg_node",
    												to: "node",
    												as: "value"
    											},
    											{
    												from: "payload_node",
    												to: "node",
    												as: "otherwise"
    											},
    											{
    												from: "state_selected",
    												to: "selected",
    												as: "otherwise"
    											},
    											{
    												from: "arg_selected",
    												to: "selected",
    												as: "value"
    											},
    											{
    												from: "get_id",
    												to: "is_selected",
    												as: "a"
    											},
    											{
    												from: "selected",
    												to: "is_selected",
    												as: "b"
    											},
    											{
    												from: "node",
    												to: "get_ref",
    												as: "target"
    											},
    											{
    												from: "node",
    												to: "get_value",
    												as: "target"
    											},
    											{
    												from: "node",
    												to: "get_name",
    												as: "target"
    											},
    											{
    												from: "get_id",
    												to: "display_name",
    												as: "id"
    											},
    											{
    												from: "get_value",
    												to: "display_name",
    												as: "value"
    											},
    											{
    												from: "node_ref",
    												to: "get_ref",
    												as: "path"
    											},
    											{
    												from: "node_name",
    												to: "get_name",
    												as: "path"
    											},
    											{
    												from: "script",
    												to: "get_ref",
    												as: "default_value"
    											},
    											{
    												from: "get_name",
    												to: "display_name",
    												as: "name"
    											},
    											{
    												from: "node",
    												to: "display_name_input",
    												as: "n"
    											},
    											{
    												from: "display_name_input",
    												to: "display_name",
    												as: "input"
    											},
    											{
    												from: "stop_propagation_effector",
    												to: "stop_propagation_effect",
    												as: "a0"
    											},
    											{
    												from: "event",
    												to: "stop_propagation_effect",
    												as: "a1"
    											},
    											{
    												from: "display_name",
    												to: "node_primary_text_text",
    												as: "text"
    											},
    											{
    												from: "get_ref",
    												to: "node_secondary_text_text",
    												as: "text"
    											},
    											{
    												from: "node_text_props",
    												to: "node_text",
    												as: "props"
    											},
    											{
    												from: "node_primary_text_text",
    												to: "node_primary_text",
    												as: "children"
    											},
    											{
    												from: "node_primary_text_attrs",
    												to: "node_primary_text",
    												as: "props"
    											},
    											{
    												from: "node_primary_text",
    												to: "node_text_children",
    												as: "primary"
    											},
    											{
    												from: "hide_types",
    												to: "node_text_children",
    												as: "hide_types"
    											},
    											{
    												from: "node_secondary_text_text",
    												to: "node_secondary_text",
    												as: "children"
    											},
    											{
    												from: "node_secondary_text_base_props",
    												to: "node_secondary_text_props",
    												as: "a0"
    											},
    											{
    												from: "node_secondary_text_onclick_props",
    												to: "node_secondary_text_props",
    												as: "a1"
    											},
    											{
    												from: "node",
    												to: "node_secondary_text_onclick_runnable",
    												as: "node"
    											},
    											{
    												from: "node_secondary_text_onclick_runnable",
    												to: "node_selected_secondary_text_onclick_runnable",
    												as: "true"
    											},
    											{
    												from: "arg_selected",
    												to: "node_selected_secondary_text_onclick_runnable",
    												as: "pred"
    											},
    											{
    												from: "node_selected_secondary_text_onclick_runnable",
    												to: "node_secondary_text_onclick_props",
    												as: "onclick"
    											},
    											{
    												from: "node_selected_secondary_text_onclick_runnable",
    												to: "node_secondary_text_onclick_props",
    												as: "ontouchstart"
    											},
    											{
    												from: "node_secondary_text_onclick",
    												to: "node_secondary_text_onclick_runnable",
    												as: "fn"
    											},
    											{
    												from: "show_edit_text",
    												to: "node_secondary_text_onclick_show_edit_text",
    												as: "a0"
    											},
    											{
    												from: "update_node",
    												to: "node_secondary_text_onclick_show_edit_text_payload",
    												as: "oneditconfirm"
    											},
    											{
    												from: "node",
    												to: "node_secondary_text_onclick_show_edit_text_payload",
    												as: "position"
    											},
    											{
    												from: "get_id",
    												to: "node_secondary_text_onclick_show_edit_text_payload",
    												as: "id"
    											},
    											{
    												from: "get_ref",
    												to: "node_secondary_text_onclick_show_edit_text_payload",
    												as: "value"
    											},
    											{
    												from: "node_ref",
    												to: "node_secondary_text_onclick_show_edit_text_payload",
    												as: "property"
    											},
    											{
    												from: "node",
    												to: "node_secondary_text_onclick_show_edit_text_payload",
    												as: "node"
    											},
    											{
    												from: "node_secondary_text_onclick_show_edit_text_payload",
    												to: "node_secondary_text_onclick_show_edit_text",
    												as: "a1"
    											},
    											{
    												from: "stop_propagation_effect",
    												to: "node_secondary_text_onclick_effects",
    												as: "a1"
    											},
    											{
    												from: "node_secondary_text_onclick_show_edit_text",
    												to: "node_secondary_text_onclick_effects",
    												as: "a0"
    											},
    											{
    												from: "node_secondary_text_onclick_effects",
    												to: "node_secondary_text_onclick",
    												as: "effects"
    											},
    											{
    												from: "state",
    												to: "node_secondary_text_onclick",
    												as: "state"
    											},
    											{
    												from: "node_secondary_text_props",
    												to: "node_secondary_text",
    												as: "props"
    											},
    											{
    												from: "tspan_dom_type",
    												to: "node_primary_text",
    												as: "dom_type"
    											},
    											{
    												from: "node_secondary_text",
    												to: "node_text_children",
    												as: "secondary"
    											},
    											{
    												from: "tspan_dom_type",
    												to: "node_secondary_text",
    												as: "dom_type"
    											},
    											{
    												from: "node_text_children",
    												to: "node_text",
    												as: "children"
    											},
    											{
    												from: "node_text_dom_type",
    												to: "node_text",
    												as: "dom_type"
    											},
    											{
    												from: "node_text",
    												to: "out"
    											}
    										]
    									},
    									{
    										id: "fill_rect",
    										script: "return {dom_type: 'rect', props:{class:{fill: true}, width: '48', 'height': '48'}, children: []}"
    									},
    									{
    										id: "order",
    										args: [
    											"shape",
    											"text"
    										],
    										script: "return [shape.el, text.el, rect]"
    									},
    									{
    										id: "out"
    									}
    								],
    								edges: [
    									{
    										from: "in",
    										to: "out",
    										as: "_"
    									},
    									{
    										from: "node",
    										to: "node_shape_attrs",
    										as: "node"
    									},
    									{
    										from: "selected_distance",
    										to: "node_shape_attrs",
    										as: "selected_distance"
    									},
    									{
    										from: "error",
    										to: "node_shape_attrs",
    										as: "error"
    									},
    									{
    										from: "default_color",
    										to: "node_shape_attrs",
    										as: "color"
    									},
    									{
    										from: "empty_array",
    										to: "node_shape",
    										as: "children"
    									},
    									{
    										from: "node",
    										to: "node_shape_dom_type",
    										as: "node"
    									},
    									{
    										from: "node_shape_dom_type",
    										to: "node_shape",
    										as: "dom_type"
    									},
    									{
    										from: "node_node",
    										to: "text"
    									},
    									{
    										from: "node_shape_attrs",
    										to: "node_shape",
    										as: "props"
    									},
    									{
    										from: "node_shape",
    										to: "order",
    										as: "shape"
    									},
    									{
    										from: "text",
    										to: "order",
    										as: "text"
    									},
    									{
    										from: "fill_rect",
    										to: "order",
    										as: "rect"
    									},
    									{
    										from: "order",
    										to: "out",
    										as: "children"
    									}
    								]
    							}
    						],
    						edges: [
    							{
    								from: "selected",
    								to: "is_selected",
    								as: "selected"
    							},
    							{
    								from: "selected",
    								to: "parent_attrs",
    								as: "selected"
    							},
    							{
    								from: "selected_edge",
    								to: "parent_attrs",
    								as: "selected_edge"
    							},
    							{
    								from: "hover",
    								to: "parent_attrs",
    								as: "hover"
    							},
    							{
    								from: "get_node",
    								to: "get_ref"
    							},
    							{
    								from: "get_node",
    								to: "is_selected",
    								as: "node"
    							},
    							{
    								from: "is_selected",
    								to: "children",
    								as: "selected"
    							},
    							{
    								from: "children",
    								to: "out"
    							},
    							{
    								from: "show_all",
    								to: "parent_attrs",
    								as: "show_all"
    							},
    							{
    								from: "html_id",
    								to: "parent_attrs",
    								as: "html_id"
    							},
    							{
    								from: "selected_distance",
    								to: "parent_attrs",
    								as: "selected_distance"
    							},
    							{
    								from: "selected_distance",
    								to: "children",
    								as: "selected_distance"
    							},
    							{
    								from: "onclick_node",
    								to: "parent_attrs",
    								as: "onclick"
    							},
    							{
    								from: "parent_attrs",
    								to: "out",
    								as: "props"
    							},
    							{
    								from: "parent_dom_type",
    								to: "out",
    								as: "dom_type"
    							},
    							{
    								from: "get_node",
    								to: "parent_attrs",
    								as: "node"
    							}
    						]
    					},
    					{
    						id: "link_layout",
    						script: "const fn = _lib.no.executeGraphNode({graph: _graph})(link_layout_map); return links.map(link => fn(Object.assign({readonly, show_all, randid, link: Object.assign({edge: display_graph.edges.find(e => link.source.node_id === e.from && link.target.node_id === e.to)}, link), selected_distance: levels.distance_from_selected.get(link.target.node_child_id) !== undefined ? Math.min(levels.distance_from_selected.get(link.target.node_child_id), levels.distance_from_selected.get(link.source.node_child_id)) : undefined, sibling_index_normalized: (levels.siblings.get(link.source.node_id).findIndex(n => n === link.source.node_id) + 1) / (levels.siblings.get(link.source.node_id).length + 1)}, _node_inputs)))"
    					},
    					{
    						id: "link_layout_map",
    						nodes: [
    							{
    								id: "in"
    							},
    							{
    								id: "get_link",
    								ref: "arg",
    								value: "link"
    							},
    							{
    								id: "get_selected_edge",
    								ref: "arg",
    								value: "selected_edge"
    							},
    							{
    								id: "source",
    								ref: "arg",
    								value: "link.source"
    							},
    							{
    								id: "target",
    								ref: "arg",
    								value: "link.target"
    							},
    							{
    								id: "selected_distance",
    								ref: "arg",
    								value: "selected_distance"
    							},
    							{
    								id: "sibling_index_normalized",
    								ref: "arg",
    								value: "sibling_index_normalized"
    							},
    							{
    								id: "show_all",
    								ref: "arg",
    								value: "show_all"
    							},
    							{
    								id: "edge",
    								ref: "arg",
    								value: "link.edge"
    							},
    							{
    								id: "edge_info_el",
    								ref: "html_element"
    							},
    							{
    								id: "edge_info_el_children",
    								script: "return [rect.el, edge_as.el, edge_type.el]"
    							},
    							{
    								id: "edge_info_dom_type",
    								value: "svg"
    							},
    							{
    								id: "onclick_edge",
    								ref: "onclick_edge"
    							},
    							{
    								id: "edge_info_props",
    								script: "return ({id: `edge-info-${source.node_child_id}`, key: `edge-info-${source.node_child_id}`, z: selected_edge && source.node_id === selected_edge.from && target.node_id === selected_edge.to ? 100 : 200, opacity: show_all ? 1 : selected_distance !== undefined ? Math.max(0.05, 1 - selected_distance * selected_distance / 2) : 0.1, class: {'edge-info': true, selected: selected_edge && (source.node_id === selected_edge.from + '_' + selected_edge.to || (source.node_id === selected_edge.from && target.node_id === selected_edge.to))}, onclick: (state, payload) => [onclick_edge, {event: payload, edge}], ontouchstart: (state, payload) => [onclick_edge, {event: payload, edge}]})"
    							},
    							{
    								id: "edge_info_line_position",
    								value: 0.5,
    								min: 0,
    								max: 1,
    								step: 0.01
    							},
    							{
    								id: "edge_info_type_props",
    								value: {
    									"font-size": 14,
    									y: 32
    								}
    							},
    							{
    								id: "edge_info_type_el",
    								ref: "svg_text"
    							},
    							{
    								id: "edge_info_type_text",
    								script: "return edge?.type ?? ''"
    							},
    							{
    								id: "edge_info_as_props",
    								value: {
    									"font-size": 14,
    									y: 16
    								}
    							},
    							{
    								id: "edge_info_as_el",
    								ref: "svg_text"
    							},
    							{
    								id: "readonly",
    								ref: "arg",
    								value: "readonly"
    							},
    							{
    								id: "edge_info_as_text",
    								script: "return edge?.as ?? (readonly ? '' : '*')"
    							},
    							{
    								id: "edge_info_rect_dom_type",
    								value: "rect"
    							},
    							{
    								id: "edge_info_rect",
    								ref: "html_element"
    							},
    							{
    								id: "lerp_length",
    								value: 24
    							},
    							{
    								id: "line_lerp",
    								script: "const length_x = Math.abs(source.x - target.x); const length_y = Math.abs(source.y - target.y); const length = Math.sqrt(length_x * length_x + length_y * length_y); return {selected_distance, selected_edge, source: {...source, x: source.x + (target.x - source.x) * lerp_length / length, y: source.y + (target.y - source.y) * lerp_length / length}, target: {...target, x: source.x + (target.x - source.x) * (1 - (lerp_length / length)), y: source.y + (target.y - source.y) * (1 - (lerp_length / length))}}"
    							},
    							{
    								id: "line_props",
    								script: "return ({id: `link-${source.node_child_id}`, key: `link-${source.node_child_id}`, onclick: (state, payload) => [onclick_edge, {event: payload, edge}], class: `link ${selected_edge && (source.node_id === selected_edge.from + '_' + selected_edge.to || (source.node_id === selected_edge.from && target.node_id === selected_edge.to)) ? 'selected' : 'unselected'}`, 'marker-end': 'url(#arrow)', opacity: show_all ? 1 : selected_distance !== undefined ? Math.max(0.05, 1 - selected_distance * selected_distance / 2) : 0.1})"
    							},
    							{
    								id: "line_dom_type",
    								value: "line"
    							},
    							{
    								id: "empty_array",
    								value: [
    								]
    							},
    							{
    								id: "line",
    								ref: "html_element"
    							},
    							{
    								id: "insert_node_el",
    								out: "el",
    								nodes: [
    									{
    										id: "link",
    										ref: "arg",
    										value: "link"
    									},
    									{
    										id: "randid",
    										ref: "arg",
    										value: "randid"
    									},
    									{
    										id: "base_props",
    										value: {
    											href: "svg/add-circle-outline.svg#icon",
    											width: "32px",
    											height: "32px",
    											"class": "insert-node"
    										}
    									},
    									{
    										id: "position",
    										script: "return {x: (link.source.x + link.target.x) * 0.5 - 16, y: (link.source.y + link.target.y) * 0.5 - 16, id: `insert-${link.source.node_child_id}`, key: `insert-${link.source.node_child_id}`}"
    									},
    									{
    										id: "insert_node",
    										ref: "insert_node"
    									},
    									{
    										id: "onclick_props",
    										script: "return {onclick: (s, p) => [s, [insert_node, {edge: link.edge, node: {id: randid}}]], ontouchstart: (s, p) => [s, [insert_node, {edge: link.edge, node: {id: randid}}]]}"
    									},
    									{
    										id: "props",
    										ref: "merge_objects"
    									},
    									{
    										id: "el",
    										ref: "add_circle_icon"
    									}
    								],
    								edges: [
    									{
    										from: "randid",
    										to: "onclick_props",
    										as: "randid"
    									},
    									{
    										from: "link",
    										to: "onclick_props",
    										as: "link"
    									},
    									{
    										from: "insert_node",
    										to: "onclick_props",
    										as: "insert_node"
    									},
    									{
    										from: "link",
    										to: "position",
    										as: "link"
    									},
    									{
    										from: "base_props",
    										to: "props",
    										as: "o0"
    									},
    									{
    										from: "position",
    										to: "props",
    										as: "o1"
    									},
    									{
    										from: "onclick_props",
    										to: "props",
    										as: "o2"
    									},
    									{
    										from: "props",
    										to: "el",
    										as: "props"
    									}
    								]
    							},
    							{
    								id: "out",
    								args: [
    									"line",
    									"edge_info"
    								],
    								script: "return [line, edge_info, !readonly && selected_distance < 1 && insert_node]"
    							}
    						],
    						edges: [
    							{
    								from: "in",
    								to: "line_props"
    							},
    							{
    								from: "get_link",
    								to: "line_lerp"
    							},
    							{
    								from: "show_all",
    								to: "line_props",
    								as: "show_all"
    							},
    							{
    								from: "get_selected_edge",
    								to: "line_props",
    								as: "selected_edge"
    							},
    							{
    								from: "get_selected_edge",
    								to: "line_lerp",
    								as: "selected_edge"
    							},
    							{
    								from: "get_selected_edge",
    								to: "edge_info_props",
    								as: "selected_edge"
    							},
    							{
    								from: "selected_distance",
    								to: "edge_info_props",
    								as: "selected_distance"
    							},
    							{
    								from: "sibling_index_normalized",
    								to: "edge_info_props",
    								as: "sibling_index_normalized"
    							},
    							{
    								from: "show_all",
    								to: "edge_info_props",
    								as: "show_all"
    							},
    							{
    								from: "onclick_edge",
    								to: "edge_info_props",
    								as: "onclick_edge"
    							},
    							{
    								from: "edge",
    								to: "line_props",
    								as: "edge"
    							},
    							{
    								from: "onclick_edge",
    								to: "line_props",
    								as: "onclick_edge"
    							},
    							{
    								from: "selected_distance",
    								to: "line_props",
    								as: "selected_distance"
    							},
    							{
    								from: "source",
    								to: "line_lerp",
    								as: "source"
    							},
    							{
    								from: "target",
    								to: "line_lerp",
    								as: "target"
    							},
    							{
    								from: "source",
    								to: "line_props",
    								as: "source"
    							},
    							{
    								from: "target",
    								to: "line_props",
    								as: "target"
    							},
    							{
    								from: "source",
    								to: "edge_info_props",
    								as: "source"
    							},
    							{
    								from: "target",
    								to: "edge_info_props",
    								as: "target"
    							},
    							{
    								from: "selected_distance",
    								to: "line_lerp",
    								as: "selected_distance"
    							},
    							{
    								from: "line_lerp",
    								to: "line_props"
    							},
    							{
    								from: "lerp_length",
    								to: "line_lerp",
    								as: "lerp_length"
    							},
    							{
    								from: "get_link",
    								to: "edge_info_props"
    							},
    							{
    								from: "edge",
    								to: "edge_info_props",
    								as: "edge"
    							},
    							{
    								from: "readonly",
    								to: "edge_info_props",
    								as: "readonly"
    							},
    							{
    								from: "edge",
    								to: "edge_info_as_text",
    								as: "edge"
    							},
    							{
    								from: "edge_info_dom_type",
    								to: "edge_info_el",
    								as: "dom_type"
    							},
    							{
    								from: "edge_info_props",
    								to: "edge_info_el",
    								as: "props"
    							},
    							{
    								from: "edge_info_line_position",
    								to: "edge_info_props",
    								as: "line_position"
    							},
    							{
    								from: "edge_info_rect",
    								to: "edge_info_el_children",
    								as: "rect"
    							},
    							{
    								from: "edge_info_rect_dom_type",
    								to: "edge_info_rect",
    								as: "dom_type"
    							},
    							{
    								from: "edge_info_el_children",
    								to: "edge_info_el",
    								as: "children"
    							},
    							{
    								from: "edge_info_el",
    								to: "out",
    								as: "edge_info"
    							},
    							{
    								from: "edge_info_type_props",
    								to: "edge_info_type_el",
    								as: "props"
    							},
    							{
    								from: "edge",
    								to: "edge_info_type_text",
    								as: "edge"
    							},
    							{
    								from: "edge_info_type_text",
    								to: "edge_info_type_el",
    								as: "text"
    							},
    							{
    								from: "edge_info_type_el",
    								to: "edge_info_el_children",
    								as: "edge_type",
    								type: "resolve"
    							},
    							{
    								from: "edge_info_as_props",
    								to: "edge_info_as_el",
    								as: "props"
    							},
    							{
    								from: "readonly",
    								to: "edge_info_as_text",
    								as: "readonly"
    							},
    							{
    								from: "edge_info_as_text",
    								to: "edge_info_as_el",
    								as: "text"
    							},
    							{
    								from: "edge_info_as_el",
    								to: "edge_info_el_children",
    								as: "edge_as",
    								type: "resolve"
    							},
    							{
    								from: "line_props",
    								to: "line",
    								as: "props"
    							},
    							{
    								from: "line_dom_type",
    								to: "line",
    								as: "dom_type"
    							},
    							{
    								from: "empty_array",
    								to: "line",
    								as: "children"
    							},
    							{
    								from: "empty_array",
    								to: "line",
    								as: "children"
    							},
    							{
    								from: "line",
    								to: "out",
    								as: "line"
    							},
    							{
    								from: "selected_distance",
    								to: "out",
    								as: "selected_distance"
    							},
    							{
    								from: "readonly",
    								to: "out",
    								as: "readonly"
    							},
    							{
    								from: "insert_node_el",
    								to: "out",
    								as: "insert_node"
    							}
    						]
    					},
    					{
    						id: "line_end",
    						ref: "html_element"
    					},
    					{
    						id: "line_end_props",
    						value: {
    							id: "arrow",
    							refX: 8,
    							refY: 4,
    							markerWidth: 8,
    							markerHeight: 8,
    							markerUnits: "userSpaceOnUse",
    							orient: "auto"
    						}
    					},
    					{
    						id: "line_end_children",
    						args: [
    							"children"
    						],
    						script: "return [children.el]"
    					},
    					{
    						id: "arrow_path",
    						ref: "html_element"
    					},
    					{
    						id: "arrow_path_props",
    						value: {
    							points: "1 1, 8 4, 1 8"
    						}
    					},
    					{
    						id: "arrow_path_dom_type",
    						value: "polyline"
    					},
    					{
    						id: "fill_filter_flood_dom_type",
    						value: "feFlood"
    					},
    					{
    						id: "fill_filter_flood_props",
    						value: {
    							"flood-color": "#000a"
    						}
    					},
    					{
    						id: "fill_filter_flood",
    						ref: "html_element"
    					},
    					{
    						id: "fill_filter_props",
    						value: {
    							id: "flood-background",
    							width: 1.2,
    							height: 1.1,
    							x: -0.1,
    							y: -0.05
    						}
    					},
    					{
    						id: "fill_filter_flood_selected_dom_type",
    						value: "feFlood"
    					},
    					{
    						id: "fill_filter_flood_selected_props",
    						value: {
    							"flood-color": "red"
    						}
    					},
    					{
    						id: "fill_filter_flood_selected",
    						ref: "html_element"
    					},
    					{
    						id: "fill_filter_selected_props",
    						value: {
    							id: "selected-flood-background",
    							width: 1.2,
    							height: 1.5,
    							x: -0.1,
    							y: -0.25
    						}
    					},
    					{
    						id: "fill_filter_composite_props",
    						value: {
    							"in": "SourceGraphic"
    						}
    					},
    					{
    						id: "fill_filter_composite_dom_type",
    						value: "feComposite"
    					},
    					{
    						id: "fill_filter_composite",
    						ref: "html_element"
    					},
    					{
    						id: "fill_filter_children",
    						script: "return [flood.el, comp.el]"
    					},
    					{
    						id: "fill_filter_selected_children",
    						script: "return [flood.el, comp.el]"
    					},
    					{
    						id: "fill_filter_dom_type",
    						value: "filter"
    					},
    					{
    						id: "fill_filter",
    						ref: "html_element"
    					},
    					{
    						id: "fill_filter_selected",
    						ref: "html_element"
    					},
    					{
    						id: "marker",
    						value: "marker"
    					},
    					{
    						id: "defs_children",
    						args: [
    							"arrow",
    							"bg_color",
    							"bg_color_selected"
    						],
    						script: "return [bg_color.el, bg_color_selected.el, arrow.el]"
    					},
    					{
    						id: "defs",
    						ref: "html_element"
    					},
    					{
    						id: "defs_dom_type",
    						value: "defs"
    					},
    					{
    						id: "defs_props",
    						value: {
    						}
    					},
    					{
    						id: "link_selected_distance",
    						args: [
    							"link"
    						],
    						script: "return !link ? [] : link.selected_distance ? link.selected_distance : 10"
    					},
    					{
    						id: "filter_links",
    						ref: "filter_eq"
    					}
    				],
    				edges: [
    					{
    						from: "nodes",
    						to: "get_nodes",
    						as: "nodes"
    					},
    					{
    						from: "get_selected",
    						to: "get_links",
    						as: "selected"
    					},
    					{
    						from: "links",
    						to: "get_links",
    						as: "links"
    					},
    					{
    						from: "node_el_width",
    						to: "get_nodes",
    						as: "node_el_width"
    					},
    					{
    						from: "html_id",
    						to: "node_layout",
    						as: "html_id"
    					},
    					{
    						from: "hover",
    						to: "node_layout",
    						as: "hover"
    					},
    					{
    						from: "error",
    						to: "node_layout",
    						as: "error"
    					},
    					{
    						from: "display_graph",
    						to: "node_layout",
    						as: "display_graph"
    					},
    					{
    						from: "node_el_width",
    						to: "node_layout",
    						as: "node_el_width"
    					},
    					{
    						from: "get_nodes",
    						to: "node_layout",
    						as: "nodes"
    					},
    					{
    						from: "node_el_width",
    						to: "get_links",
    						as: "node_el_width"
    					},
    					{
    						from: "get_links",
    						to: "duplicate_nodes",
    						as: "links"
    					},
    					{
    						from: "get_levels",
    						to: "duplicate_nodes",
    						as: "levels"
    					},
    					{
    						from: "get_levels",
    						to: "node_layout",
    						as: "levels"
    					},
    					{
    						from: "get_graph",
    						to: "node_layout",
    						as: "graph"
    					},
    					{
    						from: "show_all",
    						to: "link_layout",
    						as: "show_all"
    					},
    					{
    						from: "randid",
    						to: "link_layout",
    						as: "randid"
    					},
    					{
    						from: "readonly",
    						to: "link_layout",
    						as: "readonly"
    					},
    					{
    						from: "show_all",
    						to: "node_layout",
    						as: "show_all"
    					},
    					{
    						from: "hide_types",
    						to: "node_layout",
    						as: "hide_types"
    					},
    					{
    						from: "display_graph",
    						to: "link_layout",
    						as: "display_graph"
    					},
    					{
    						from: "get_graph",
    						to: "link_layout",
    						as: "graph"
    					},
    					{
    						from: "get_selected",
    						to: "node_layout",
    						as: "selected"
    					},
    					{
    						from: "get_links",
    						to: "link_selected_distance",
    						as: "link"
    					},
    					{
    						from: "get_selected_edge",
    						to: "filter_links",
    						as: "selected_edge"
    					},
    					{
    						from: "get_selected_edge",
    						to: "node_layout",
    						as: "selected_edge"
    					},
    					{
    						from: "get_selected_edge",
    						to: "link_layout",
    						as: "selected_edge"
    					},
    					{
    						from: "link_selected_distance",
    						to: "filter_links",
    						as: "keep"
    					},
    					{
    						from: "get_links",
    						to: "filter_links"
    					},
    					{
    						from: "get_links",
    						to: "link_layout",
    						as: "links"
    					},
    					{
    						from: "get_levels",
    						to: "link_layout",
    						as: "levels"
    					},
    					{
    						from: "link_layout_map",
    						to: "link_layout",
    						as: "link_layout_map",
    						type: "ref"
    					},
    					{
    						from: "in",
    						to: "node_editor_props"
    					},
    					{
    						from: "html_id",
    						to: "node_editor_props",
    						as: "html_id"
    					},
    					{
    						from: "readonly",
    						to: "node_editor_props",
    						as: "readonly"
    					},
    					{
    						from: "hash",
    						to: "node_editor_props",
    						as: "hash"
    					},
    					{
    						from: "html_id",
    						to: "panzoom_box_props",
    						as: "html_id"
    					},
    					{
    						from: "get_selected",
    						to: "get_selected_node",
    						as: "node_id"
    					},
    					{
    						from: "node_el_width",
    						to: "node_editor_props",
    						as: "node_el_width"
    					},
    					{
    						from: "dimensions",
    						to: "node_editor_props",
    						as: "dimensions"
    					},
    					{
    						from: "get_nodes",
    						to: "get_selected_node",
    						as: "nodes"
    					},
    					{
    						from: "get_selected_node",
    						to: "node_editor_props",
    						as: "selected"
    					},
    					{
    						from: "onclick_graph",
    						to: "node_editor_props",
    						as: "onclick_graph"
    					},
    					{
    						from: "node_editor_props",
    						to: "out",
    						as: "props"
    					},
    					{
    						from: "node_editor_dom_type",
    						to: "out",
    						as: "dom_type"
    					},
    					{
    						from: "node_layout_map",
    						to: "node_layout",
    						as: "node_layout_map",
    						type: "ref"
    					},
    					{
    						from: "node_layout",
    						to: "node_editor_children",
    						as: "nodes"
    					},
    					{
    						from: "get_selected",
    						to: "dg_selected",
    						as: "node_id"
    					},
    					{
    						from: "dg_nodes",
    						to: "dg_selected",
    						as: "nodes"
    					},
    					{
    						from: "dg_selected",
    						to: "node_args",
    						as: "node"
    					},
    					{
    						from: "dg_nodes",
    						to: "node_args",
    						as: "nodes"
    					},
    					{
    						from: "get_selected_node",
    						to: "dummy_nodes",
    						as: "selected_node"
    					},
    					{
    						from: "node_args",
    						to: "dummy_nodes",
    						as: "args"
    					},
    					{
    						from: "get_selected",
    						to: "dummy_node_els",
    						as: "selected"
    					},
    					{
    						from: "dummy_nodes",
    						to: "dummy_node_els",
    						as: "nodes"
    					},
    					{
    						from: "dummy_nodes",
    						to: "dummy_links",
    						as: "nodes"
    					},
    					{
    						from: "get_selected_node",
    						to: "dummy_links",
    						as: "selected_node"
    					},
    					{
    						from: "node_args",
    						to: "dummy_links",
    						as: "args"
    					},
    					{
    						from: "dummy_links",
    						to: "dummy_link_els",
    						as: "links"
    					},
    					{
    						from: "node_layout_map",
    						to: "dummy_node_els",
    						as: "node_layout_map",
    						type: "ref"
    					},
    					{
    						from: "dummy_node_els",
    						to: "_node_editor_children",
    						as: "dummy_nodes"
    					},
    					{
    						from: "link_layout_map",
    						to: "dummy_link_els",
    						as: "link_layout_map",
    						type: "ref"
    					},
    					{
    						from: "dummy_link_els",
    						to: "_node_editor_children",
    						as: "dummy_links"
    					},
    					{
    						from: "get_selected_node",
    						to: "dummy_node_el",
    						as: "selected_node"
    					},
    					{
    						from: "dummy_node_el",
    						to: "node_editor_children",
    						as: "dummy_node"
    					},
    					{
    						from: "get_nodes",
    						to: "node_editor_children_inputs",
    						as: "nodes"
    					},
    					{
    						from: "link_layout",
    						to: "node_editor_children",
    						as: "links"
    					},
    					{
    						from: "get_links",
    						to: "node_editor_children_inputs",
    						as: "links"
    					},
    					{
    						from: "defs",
    						to: "node_editor_children",
    						as: "defs"
    					},
    					{
    						from: "marker",
    						to: "line_end",
    						as: "dom_type"
    					},
    					{
    						from: "arrow_path_props",
    						to: "arrow_path",
    						as: "props"
    					},
    					{
    						from: "arrow_path_dom_type",
    						to: "arrow_path",
    						as: "dom_type"
    					},
    					{
    						from: "arrow_path",
    						to: "line_end",
    						as: "children"
    					},
    					{
    						from: "line_end_props",
    						to: "line_end",
    						as: "props"
    					},
    					{
    						from: "line_end",
    						to: "defs_children",
    						as: "arrow"
    					},
    					{
    						from: "fill_filter_flood_props",
    						to: "fill_filter_flood",
    						as: "props"
    					},
    					{
    						from: "fill_filter_flood_dom_type",
    						to: "fill_filter_flood",
    						as: "dom_type"
    					},
    					{
    						from: "fill_filter_flood",
    						to: "fill_filter_children",
    						as: "flood"
    					},
    					{
    						from: "fill_filter_flood_selected_props",
    						to: "fill_filter_flood_selected",
    						as: "props"
    					},
    					{
    						from: "fill_filter_flood_selected_dom_type",
    						to: "fill_filter_flood_selected",
    						as: "dom_type"
    					},
    					{
    						from: "fill_filter_flood_selected",
    						to: "fill_filter_selected_children",
    						as: "flood"
    					},
    					{
    						from: "fill_filter_composite_props",
    						to: "fill_filter_composite",
    						as: "props"
    					},
    					{
    						from: "fill_filter_composite_dom_type",
    						to: "fill_filter_composite",
    						as: "dom_type"
    					},
    					{
    						from: "fill_filter_composite",
    						to: "fill_filter_children",
    						as: "comp"
    					},
    					{
    						from: "fill_filter_children",
    						to: "fill_filter",
    						as: "children"
    					},
    					{
    						from: "fill_filter_props",
    						to: "fill_filter",
    						as: "props"
    					},
    					{
    						from: "fill_filter_composite",
    						to: "fill_filter_selected_children",
    						as: "comp"
    					},
    					{
    						from: "fill_filter_selected_children",
    						to: "fill_filter_selected",
    						as: "children"
    					},
    					{
    						from: "fill_filter_selected_props",
    						to: "fill_filter_selected",
    						as: "props"
    					},
    					{
    						from: "fill_filter_dom_type",
    						to: "fill_filter",
    						as: "dom_type"
    					},
    					{
    						from: "fill_filter_dom_type",
    						to: "fill_filter_selected",
    						as: "dom_type"
    					},
    					{
    						from: "fill_filter",
    						to: "defs_children",
    						as: "bg_color"
    					},
    					{
    						from: "fill_filter_selected",
    						to: "defs_children",
    						as: "bg_color_selected"
    					},
    					{
    						from: "defs_dom_type",
    						to: "defs",
    						as: "dom_type"
    					},
    					{
    						from: "defs_props",
    						to: "defs",
    						as: "props"
    					},
    					{
    						from: "defs_children",
    						to: "defs",
    						as: "children"
    					},
    					{
    						from: "node_editor_children",
    						to: "panzoom_box",
    						as: "children"
    					},
    					{
    						from: "panzoom_box_dom_type",
    						to: "panzoom_box",
    						as: "dom_type"
    					},
    					{
    						from: "panzoom_box_props",
    						to: "panzoom_box",
    						as: "props"
    					},
    					{
    						from: "panzoom_box",
    						to: "out",
    						as: "children"
    					},
    					{
    						from: "panzoom_box_arr",
    						to: "node_editor",
    						as: "children"
    					}
    				]
    			},
    			{
    				id: "error_display",
    				script: "return {el: {dom_type: 'div', props: {class:{error: true, main: true}, key: `${html_id}-error_display`}, children: [{dom_type: 'text_value', text: error instanceof AggregateError ? error.errors.map(e => e.toString()).join(\" \") : error?.toString()}]}}"
    			},
    			{
    				id: "noop",
    				script: "return {el: _lib.ha.h.fn('div', {key: 'loading'}, _lib.ha.text.fn('loading...'))}"
    			},
    			{
    				id: "out_input",
    				script: "return display_graph && graph ? 'hel' : 'noop'"
    			},
    			{
    				id: "out",
    				ref: "switch"
    			}
    		],
    		edges: [
    			{
    				from: "graph",
    				to: "wrapper",
    				as: "graph"
    			},
    			{
    				from: "graph",
    				to: "out_input",
    				as: "graph"
    			},
    			{
    				from: "display_graph",
    				to: "out_input",
    				as: "display_graph"
    			},
    			{
    				from: "error",
    				to: "error_display",
    				as: "error"
    			},
    			{
    				from: "html_id",
    				to: "error_display",
    				as: "html_id"
    			},
    			{
    				from: "error",
    				to: "wrapper_children",
    				as: "error"
    			},
    			{
    				from: "search",
    				to: "wrapper_children",
    				as: "search"
    			},
    			{
    				from: "error_display",
    				to: "wrapper_children",
    				as: "error_display"
    			},
    			{
    				from: "readonly",
    				to: "wrapper_children",
    				as: "readonly"
    			},
    			{
    				from: "show_result",
    				to: "wrapper_children",
    				as: "show_result"
    			},
    			{
    				from: "editing",
    				to: "wrapper_children",
    				as: "editing"
    			},
    			{
    				from: "popover_graph",
    				to: "wrapper_children",
    				as: "popover_graph"
    			},
    			{
    				from: "args_display",
    				to: "wrapper_children",
    				as: "args_display"
    			},
    			{
    				from: "readonly",
    				to: "node_editor",
    				as: "readonly"
    			},
    			{
    				from: "graph",
    				to: "node_editor",
    				as: "graph"
    			},
    			{
    				from: "node_editor",
    				to: "wrapper_children",
    				as: "node_editor"
    			},
    			{
    				from: "edit_text",
    				to: "wrapper_children",
    				as: "edit_text"
    			},
    			{
    				from: "menu",
    				to: "wrapper_children",
    				as: "menu"
    			},
    			{
    				from: "result_display",
    				to: "result_wrapper",
    				as: "run"
    			},
    			{
    				from: "result_display",
    				to: "wrapper_children",
    				as: "result_display"
    			},
    			{
    				from: "show_all",
    				to: "wrapper_children",
    				as: "show_all"
    			},
    			{
    				from: "styles",
    				to: "wrapper_children",
    				as: "styles"
    			},
    			{
    				from: "popover_graph_h",
    				to: "popover_graph_h_wrapper",
    				as: "el"
    			},
    			{
    				from: "popover_graph_h_wrapper",
    				to: "wrapper_children",
    				as: "popover_graph_h"
    			},
    			{
    				from: "wrapper_children",
    				to: "wrapper",
    				as: "children",
    				type: "resolve"
    			},
    			{
    				from: "wrapper_dom_type",
    				to: "wrapper",
    				as: "dom_type"
    			},
    			{
    				from: "wrapper_props",
    				to: "wrapper",
    				as: "props",
    				type: "resolve"
    			},
    			{
    				from: "out_input",
    				to: "out",
    				as: "input"
    			},
    			{
    				from: "noop",
    				to: "out",
    				as: "noop",
    				type: "resolve"
    			},
    			{
    				from: "wrapper",
    				to: "out",
    				as: "hel"
    			}
    		]
    	}
    ];
    var edges = [
    	{
    		from: "editor",
    		to: "hyperapp_view",
    		type: "ref",
    		as: "fn"
    	},
    	{
    		from: "get_graph",
    		to: "update_sim_fn",
    		as: "graph"
    	},
    	{
    		from: "error_nodes",
    		to: "hyperapp_init_state",
    		as: "error_nodes"
    	},
    	{
    		from: "static",
    		to: "hyperapp_init_state",
    		as: "static"
    	},
    	{
    		from: "readonly",
    		to: "hyperapp_init_state",
    		as: "readonly"
    	},
    	{
    		from: "norun",
    		to: "hyperapp_init_state",
    		as: "norun"
    	},
    	{
    		from: "hash",
    		to: "hyperapp_init_state",
    		as: "hash"
    	},
    	{
    		from: "hide_types",
    		to: "hyperapp_init_state",
    		as: "hide_types"
    	},
    	{
    		from: "dimensions",
    		to: "hyperapp_init_state",
    		as: "dimensions"
    	},
    	{
    		from: "html_id",
    		to: "hyperapp_init_state",
    		as: "html_id"
    	},
    	{
    		from: "examples",
    		to: "hyperapp_init_state",
    		as: "examples"
    	},
    	{
    		from: "display_graph_out",
    		to: "init_selected",
    		as: "a0"
    	},
    	{
    		from: "init_selected",
    		to: "hyperapp_init_state",
    		as: "selected"
    	},
    	{
    		from: "update_sim_effect",
    		to: "hyperapp_init_state",
    		as: "update_sim_effect"
    	},
    	{
    		from: "sim_to_hyperapp_fn",
    		to: "hyperapp_init_state",
    		as: "sim_to_hyperapp"
    	},
    	{
    		from: "get_graph",
    		to: "onkey_fn",
    		as: "graph"
    	},
    	{
    		from: "onkey_fn",
    		to: "initialize_hyperapp_app",
    		as: "onkey_fn"
    	},
    	{
    		from: "onkey_fn_body",
    		to: "onkey_fn",
    		as: "fn",
    		type: "ref"
    	},
    	{
    		from: "html_id",
    		to: "render_graph_effect",
    		as: "html_id"
    	},
    	{
    		from: "update_sim_effect",
    		to: "render_graph_effect",
    		as: "update_sim"
    	},
    	{
    		from: "popover_dimensions",
    		to: "render_graph_effect",
    		as: "dimensions"
    	},
    	{
    		from: "get_graph",
    		to: "render_graph_effect",
    		as: "graph"
    	},
    	{
    		from: "html_id",
    		to: "initialize_hyperapp_app",
    		as: "html_id"
    	},
    	{
    		from: "render_graph_effect",
    		to: "_initialize_hyperapp_app",
    		as: "render_graph_effect"
    	},
    	{
    		from: "hyperapp_view",
    		to: "initialize_hyperapp_app",
    		as: "view"
    	},
    	{
    		from: "update_hyperapp",
    		to: "update_hyperapp_action",
    		as: "fn",
    		type: "ref"
    	},
    	{
    		from: "update_hyperapp_action",
    		to: "update_hyperapp_effect",
    		as: "fn"
    	},
    	{
    		from: "update_hyperapp_effect",
    		to: "initialize_hyperapp_app",
    		as: "update_hyperapp"
    	},
    	{
    		from: "update_hyperapp_effect",
    		to: "hyperapp_init_state",
    		as: "update_hyperapp"
    	},
    	{
    		from: "hyperapp_init_state",
    		to: "initialize_hyperapp_app",
    		as: "init"
    	},
    	{
    		from: "get_graph",
    		to: "hyperapp_view",
    		as: "graph"
    	},
    	{
    		from: "get_graph",
    		to: "hyperapp_init_state",
    		as: "graph"
    	},
    	{
    		from: "get_graph",
    		to: "update_nodes",
    		as: "graph"
    	},
    	{
    		from: "get_display_graph",
    		to: "update_nodes",
    		as: "display_graph"
    	},
    	{
    		from: "get_display_graph",
    		to: "hyperapp_init_state",
    		as: "display_graph"
    	},
    	{
    		from: "display_graph_out",
    		to: "calculate_levels",
    		as: "selected"
    	},
    	{
    		from: "get_display_graph",
    		to: "calculate_levels",
    		as: "display_graph"
    	},
    	{
    		from: "calculate_levels",
    		to: "hyperapp_init_state",
    		as: "levels"
    	},
    	{
    		from: "initial_state",
    		to: "hyperapp_init_state"
    	},
    	{
    		from: "nodes",
    		to: "graph_to_simulation",
    		as: "nodes"
    	},
    	{
    		from: "links",
    		to: "graph_to_simulation",
    		as: "links"
    	},
    	{
    		from: "graph_to_simulation",
    		to: "graph_to_sim_action",
    		as: "fn",
    		type: "ref"
    	},
    	{
    		from: "sim_to_hyperapp",
    		to: "sim_to_hyperapp_fn",
    		as: "fn",
    		type: "ref"
    	},
    	{
    		from: "sim_to_hyperapp_fn",
    		to: "initialize_hyperapp_app",
    		as: "sim_to_hyperapp_action"
    	},
    	{
    		from: "graph_to_sim_action",
    		to: "initialize_hyperapp_app",
    		as: "graph_to_sim_action"
    	},
    	{
    		from: "update_sim_in",
    		to: "update_sim_fn",
    		as: "in_node",
    		type: "ref"
    	},
    	{
    		from: "update_sim_fn",
    		to: "update_sim_effect",
    		as: "fn"
    	},
    	{
    		from: "update_sim_effect",
    		to: "editor",
    		as: "update_sim"
    	},
    	{
    		from: "update_sim_effect",
    		to: "initialize_hyperapp_app",
    		as: "update_sim"
    	},
    	{
    		from: "initialize_hyperapp_app",
    		to: "out",
    		type: "resolve"
    	},
    	{
    		from: "get",
    		to: "object"
    	},
    	{
    		from: "set",
    		to: "object"
    	},
    	{
    		from: "delete",
    		to: "object"
    	},
    	{
    		from: "switch",
    		to: "flow"
    	},
    	{
    		from: "if",
    		to: "flow"
    	},
    	{
    		from: "html_element",
    		to: "html"
    	},
    	{
    		from: "toggle",
    		to: "html"
    	},
    	{
    		from: "input",
    		to: "html"
    	},
    	{
    		from: "css_styles",
    		to: "html"
    	},
    	{
    		from: "modify_state_runnable",
    		to: "state"
    	},
    	{
    		from: "set_display",
    		to: "state"
    	},
    	{
    		from: "array",
    		to: "arrays"
    	},
    	{
    		from: "filter",
    		to: "arrays"
    	},
    	{
    		from: "append",
    		to: "arrays"
    	},
    	{
    		from: "map",
    		to: "arrays"
    	},
    	{
    		from: "log",
    		to: "utility"
    	},
    	{
    		from: "execute_graph",
    		to: "utility"
    	},
    	{
    		from: "arg",
    		to: "utility"
    	},
    	{
    		from: "partial",
    		to: "utility"
    	},
    	{
    		from: "apply",
    		to: "utility"
    	},
    	{
    		from: "fetch",
    		to: "utility"
    	},
    	{
    		from: "merge_objects",
    		to: "utility"
    	},
    	{
    		from: "sequence",
    		to: "utility"
    	},
    	{
    		from: "runnable",
    		to: "utility"
    	},
    	{
    		from: "object_entries",
    		to: "utility"
    	},
    	{
    		from: "add",
    		to: "math"
    	},
    	{
    		from: "divide",
    		to: "math"
    	},
    	{
    		from: "negate",
    		to: "math"
    	},
    	{
    		from: "mult",
    		to: "math"
    	},
    	{
    		from: "stringify",
    		to: "JSON"
    	}
    ];
    var DEFAULT_GRAPH = {
    	id: id$3,
    	out: out,
    	nodes: nodes$1,
    	edges: edges
    };

    var examples = [
    	{
    		out: "main/out",
    		id: "simple",
    		nodes: [
    			{
    				id: "state_path",
    				ref: "arg",
    				value: "state"
    			},
    			{
    				id: "args"
    			},
    			{
    				id: "state_log",
    				ref: "log"
    			},
    			{
    				id: "log_state",
    				ref: "runnable"
    			},
    			{
    				id: "main/out"
    			}
    		],
    		edges: [
    			{
    				from: "args",
    				to: "main/out",
    				as: "args"
    			},
    			{
    				from: "state_path",
    				to: "state_log",
    				as: "value"
    			},
    			{
    				from: "state_log",
    				to: "log_state",
    				as: "fn"
    			},
    			{
    				from: "log_state",
    				to: "main/out",
    				as: "arg0"
    			}
    		]
    	},
    	{
    		"in": "main/in",
    		out: "main/out",
    		id: "hyperapp_state",
    		nodes: [
    			{
    				id: "main/out",
    				script: "console.log(\"state\")\nconsole.log(state);\nconsole.log(\"prev\")\nconsole.log(prev);\nreturn {state, display};"
    			},
    			{
    				id: "main/in"
    			},
    			{
    				id: "63tva08",
    				ref: "html_element",
    				name: "main display"
    			},
    			{
    				id: "l6vdvtn",
    				ref: "new_array",
    				name: "display elements"
    			},
    			{
    				id: "q23fegi",
    				value: "div"
    			},
    			{
    				id: "l6mvkla",
    				name: "props"
    			},
    			{
    				id: "o1wn5x1",
    				name: "class"
    			},
    			{
    				id: "zz730do",
    				value: "true"
    			},
    			{
    				id: "c2sko9c",
    				name: "hello world text",
    				out: "c2sko9c",
    				nodes: [
    					{
    						id: "c2sko9c",
    						ref: "html_element",
    						name: "hello world text"
    					},
    					{
    						id: "2lr3ihi",
    						value: "Hello, world!"
    					}
    				],
    				edges: [
    					{
    						from: "2lr3ihi",
    						to: "c2sko9c",
    						as: "text"
    					}
    				]
    			},
    			{
    				id: "ukbdszl",
    				ref: "html_element",
    				name: "display text"
    			},
    			{
    				id: "un5cq1q",
    				value: "div"
    			},
    			{
    				id: "0alhppw",
    				ref: "new_array",
    				name: "run count display"
    			},
    			{
    				id: "g82nw07",
    				ref: "html_element"
    			},
    			{
    				id: "pgygs2p/pgygs2p",
    				ref: "html_element",
    				name: "styles/out"
    			},
    			{
    				id: "pgygs2p/vdyskp6",
    				value: "style",
    				name: ""
    			},
    			{
    				id: "pgygs2p/1tf3vvf",
    				ref: "new_array",
    				name: "styles/1tf3vvf"
    			},
    			{
    				id: "pgygs2p/6yewnx1",
    				ref: "html_element",
    				name: "styles/6yewnx1"
    			},
    			{
    				id: "pgygs2p/02951w8",
    				value: ".result { position: absolute; bottom: 0; left: 0; font-size: 4em}\n.run-count { font-size: .5em; color: green}",
    				name: "css styles"
    			},
    			{
    				id: "tznmg79",
    				ref: "set",
    				name: "new state"
    			},
    			{
    				ref: "arg",
    				id: "lptd9k3",
    				value: "state"
    			},
    			{
    				id: "4ilqcxt",
    				value: "runcount"
    			},
    			{
    				ref: "arg",
    				id: "xev2phu",
    				value: "state"
    			},
    			{
    				ref: "arg",
    				id: "00ahbis",
    				value: "state.runcount"
    			},
    			{
    				id: "gbh28eu",
    				script: "return (isNaN(runcount) ? 0 : runcount) + 1",
    				name: "add 1"
    			},
    			{
    				ref: "arg",
    				id: "wegu4xm",
    				value: "state.runcount"
    			},
    			{
    				id: "wh4juqx",
    				ref: "html_element"
    			},
    			{
    				id: "edqfgkn",
    				value: "run count: "
    			},
    			{
    				id: "2t4s9uj",
    				name: "run count props"
    			},
    			{
    				id: "j630j9a",
    				value: "run-count"
    			}
    		],
    		edges: [
    			{
    				from: "main/in",
    				to: "main/out",
    				as: "args",
    				type: "ref"
    			},
    			{
    				from: "63tva08",
    				to: "main/out",
    				as: "display"
    			},
    			{
    				from: "l6vdvtn",
    				to: "63tva08",
    				as: "children"
    			},
    			{
    				from: "q23fegi",
    				to: "63tva08",
    				as: "dom_type"
    			},
    			{
    				from: "c2sko9c",
    				to: "l6vdvtn",
    				as: "arg1"
    			},
    			{
    				from: "pgygs2p/pgygs2p",
    				to: "l6vdvtn",
    				as: "arg0"
    			},
    			{
    				from: "l6mvkla",
    				to: "63tva08",
    				as: "props"
    			},
    			{
    				from: "o1wn5x1",
    				to: "l6mvkla",
    				as: "class"
    			},
    			{
    				from: "zz730do",
    				to: "o1wn5x1",
    				as: "result"
    			},
    			{
    				from: "ukbdszl",
    				to: "l6vdvtn",
    				as: "arg2"
    			},
    			{
    				from: "un5cq1q",
    				to: "ukbdszl",
    				as: "dom_type"
    			},
    			{
    				from: "0alhppw",
    				to: "ukbdszl",
    				as: "children"
    			},
    			{
    				from: "g82nw07",
    				to: "0alhppw",
    				as: "arg1"
    			},
    			{
    				from: "pgygs2p/vdyskp6",
    				to: "pgygs2p/pgygs2p",
    				as: "dom_type"
    			},
    			{
    				from: "pgygs2p/1tf3vvf",
    				to: "pgygs2p/pgygs2p",
    				as: "children"
    			},
    			{
    				from: "pgygs2p/6yewnx1",
    				to: "pgygs2p/1tf3vvf",
    				as: "arg0"
    			},
    			{
    				from: "pgygs2p/02951w8",
    				to: "pgygs2p/6yewnx1",
    				as: "text"
    			},
    			{
    				from: "tznmg79",
    				to: "main/out",
    				as: "state"
    			},
    			{
    				from: "lptd9k3",
    				to: "tznmg79",
    				as: "target"
    			},
    			{
    				from: "4ilqcxt",
    				to: "tznmg79",
    				as: "path"
    			},
    			{
    				from: "xev2phu",
    				to: "main/out",
    				as: "prev"
    			},
    			{
    				from: "00ahbis",
    				to: "g82nw07",
    				as: "text"
    			},
    			{
    				from: "gbh28eu",
    				to: "tznmg79",
    				as: "value"
    			},
    			{
    				from: "wegu4xm",
    				to: "gbh28eu",
    				as: "runcount"
    			},
    			{
    				from: "wh4juqx",
    				to: "0alhppw",
    				as: "arg0"
    			},
    			{
    				from: "edqfgkn",
    				to: "wh4juqx",
    				as: "text"
    			},
    			{
    				from: "2t4s9uj",
    				to: "ukbdszl",
    				as: "props"
    			},
    			{
    				from: "j630j9a",
    				to: "2t4s9uj",
    				as: "class"
    			}
    		]
    	},
    	{
    		edges: [
    			{
    				from: "main/in",
    				to: "main/out",
    				as: "args",
    				type: "ref"
    			},
    			{
    				from: "63tva08",
    				to: "main/out",
    				as: "display"
    			},
    			{
    				from: "l6vdvtn",
    				to: "63tva08",
    				as: "children"
    			},
    			{
    				from: "q23fegi",
    				to: "63tva08",
    				as: "dom_type"
    			},
    			{
    				from: "c2sko9c",
    				to: "l6vdvtn",
    				as: "arg1"
    			},
    			{
    				from: "pgygs2p/pgygs2p",
    				to: "l6vdvtn",
    				as: "arg0"
    			},
    			{
    				from: "l6mvkla",
    				to: "63tva08",
    				as: "props"
    			},
    			{
    				from: "o1wn5x1",
    				to: "l6mvkla",
    				as: "class"
    			},
    			{
    				from: "zz730do",
    				to: "o1wn5x1",
    				as: "result"
    			},
    			{
    				from: "pgygs2p/vdyskp6",
    				to: "pgygs2p/pgygs2p",
    				as: "dom_type"
    			},
    			{
    				from: "pgygs2p/1tf3vvf",
    				to: "pgygs2p/pgygs2p",
    				as: "children"
    			},
    			{
    				from: "pgygs2p/6yewnx1",
    				to: "pgygs2p/1tf3vvf",
    				as: "arg0"
    			},
    			{
    				from: "pgygs2p/02951w8",
    				to: "pgygs2p/6yewnx1",
    				as: "text"
    			},
    			{
    				from: "get",
    				to: "object"
    			},
    			{
    				from: "set",
    				to: "object"
    			},
    			{
    				from: "delete",
    				to: "object"
    			},
    			{
    				from: "switch",
    				to: "flow"
    			},
    			{
    				from: "if",
    				to: "flow"
    			},
    			{
    				from: "html_element",
    				to: "hyperapp"
    			},
    			{
    				from: "html_element",
    				to: "hyperapp"
    			},
    			{
    				from: "new_array",
    				to: "array"
    			},
    			{
    				from: "filter",
    				to: "array"
    			},
    			{
    				from: "log",
    				to: "utility"
    			},
    			{
    				from: "execute_graph",
    				to: "utility"
    			},
    			{
    				from: "arg",
    				to: "utility"
    			},
    			{
    				from: "partial",
    				to: "utility"
    			},
    			{
    				from: "apply",
    				to: "utility"
    			},
    			{
    				from: "fetch",
    				to: "utility"
    			}
    		],
    		nodes: [
    			{
    				id: "main/out",
    				args: [
    					"value"
    				]
    			},
    			{
    				id: "main/in"
    			},
    			{
    				id: "63tva08",
    				ref: "html_element",
    				name: "main display"
    			},
    			{
    				id: "l6vdvtn",
    				ref: "new_array",
    				name: "display elements"
    			},
    			{
    				id: "q23fegi",
    				value: "div"
    			},
    			{
    				id: "l6mvkla",
    				name: "props"
    			},
    			{
    				id: "o1wn5x1",
    				name: "class"
    			},
    			{
    				id: "zz730do",
    				value: "true"
    			},
    			{
    				id: "c2sko9c",
    				name: "hello world text",
    				out: "c2sko9c",
    				nodes: [
    					{
    						id: "c2sko9c",
    						ref: "html_element",
    						name: "hello world text"
    					},
    					{
    						id: "2lr3ihi",
    						value: "Hello, world!"
    					}
    				],
    				edges: [
    					{
    						from: "2lr3ihi",
    						to: "c2sko9c",
    						as: "text"
    					}
    				]
    			},
    			{
    				id: "pgygs2p/pgygs2p",
    				ref: "html_element",
    				name: "styles/out"
    			},
    			{
    				id: "pgygs2p/vdyskp6",
    				value: "style",
    				name: ""
    			},
    			{
    				id: "pgygs2p/1tf3vvf",
    				ref: "new_array",
    				name: "styles/1tf3vvf"
    			},
    			{
    				id: "pgygs2p/6yewnx1",
    				ref: "html_element",
    				name: "styles/6yewnx1"
    			},
    			{
    				id: "pgygs2p/02951w8",
    				value: ".result { position: absolute; bottom: 0; left: 0; font-size: 4em}\n.run-count { font-size: .5em; color: green}",
    				name: "css styles"
    			},
    			{
    				id: "array"
    			},
    			{
    				id: "utility"
    			},
    			{
    				id: "flow"
    			},
    			{
    				id: "hyperapp"
    			},
    			{
    				id: "object"
    			},
    			{
    				id: "log",
    				args: [
    					"value"
    				],
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "value",
    						ref: "arg",
    						value: "value"
    					},
    					{
    						id: "out",
    						args: [
    						],
    						script: "console.log(_node.id); console.log(value); return value"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "input"
    					},
    					{
    						from: "value",
    						to: "out",
    						as: "value"
    					}
    				]
    			},
    			{
    				id: "fetch",
    				name: "fetch",
    				extern: "utility.fetch"
    			},
    			{
    				id: "filter",
    				name: "filter",
    				"in": "74n1jfm",
    				out: "lahq5z4",
    				nodes: [
    					{
    						id: "lahq5z4",
    						args: [
    						],
    						name: "filter/out",
    						script: "const filter_fn = _lib.no.executeGraphNode({graph: _graph})(fn); return arr.filter(filter_fn)"
    					},
    					{
    						id: "pfoypo5",
    						args: [
    						],
    						ref: "arg",
    						value: "key"
    					},
    					{
    						id: "zinx621",
    						args: [
    						],
    						ref: "arg",
    						value: "value"
    					},
    					{
    						id: "x2sz5kb",
    						args: [
    						],
    						ref: "arg",
    						value: "arr"
    					},
    					{
    						id: "fn",
    						ref: "arg",
    						value: "fn"
    					},
    					{
    						id: "74n1jfm",
    						args: [
    						],
    						name: "filter/in"
    					}
    				],
    				edges: [
    					{
    						from: "pfoypo5",
    						to: "lahq5z4",
    						as: "key"
    					},
    					{
    						from: "zinx621",
    						to: "lahq5z4",
    						as: "value"
    					},
    					{
    						from: "x2sz5kb",
    						to: "lahq5z4",
    						as: "arr"
    					},
    					{
    						from: "74n1jfm",
    						to: "lahq5z4",
    						as: "input"
    					},
    					{
    						from: "fn",
    						to: "lahq5z4",
    						as: "fn"
    					}
    				]
    			},
    			{
    				id: "switch",
    				args: [
    					"data",
    					"input"
    				],
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "out",
    						args: [
    							"data",
    							"input"
    						],
    						script: "return data[input];"
    					},
    					{
    						id: "input",
    						ref: "arg",
    						value: "input"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "data"
    					},
    					{
    						from: "input",
    						to: "out",
    						as: "input"
    					}
    				]
    			},
    			{
    				id: "if",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "pred",
    						ref: "arg",
    						value: "pred"
    					},
    					{
    						id: "out",
    						script: "return pred ? data['true'] : data['false']"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "data"
    					},
    					{
    						from: "pred",
    						to: "out",
    						as: "pred"
    					}
    				]
    			},
    			{
    				id: "execute_graph",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "fn",
    						ref: "arg",
    						value: "fn"
    					},
    					{
    						id: "graph",
    						ref: "arg",
    						value: "graph"
    					},
    					{
    						id: "out",
    						script: "return (...args) => {res = _lib.no.executeGraphNode({graph})(fn)(args.length === 1 ? args[0] : args); return res;}"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "graph",
    						to: "out",
    						as: "graph"
    					}
    				]
    			},
    			{
    				id: "apply",
    				script: "return _lib.no.executeGraphNode({graph: _graph})(fn)(args);"
    			},
    			{
    				id: "partial",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "input_value",
    						ref: "arg",
    						value: "_args"
    					},
    					{
    						id: "fn",
    						ref: "arg",
    						value: "fn"
    					},
    					{
    						id: "args",
    						ref: "arg",
    						value: "args"
    					},
    					{
    						id: "out",
    						script: "return _lib.no.executeGraphNode({graph: _graph})(fn)(Object.assign({}, _args, args))"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "args",
    						type: "ref"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "input_value",
    						to: "out",
    						as: "_args"
    					}
    				]
    			},
    			{
    				id: "new_array",
    				name: "new_array",
    				extern: "utility.new_array"
    			},
    			{
    				id: "get",
    				args: [
    					"target",
    					"path"
    				],
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "def",
    						ref: "arg",
    						value: "def"
    					},
    					{
    						id: "target",
    						ref: "arg",
    						value: "target"
    					},
    					{
    						id: "path",
    						ref: "arg",
    						value: "path"
    					},
    					{
    						id: "fill_default",
    						args: [
    							"input"
    						],
    						script: "return input?.default ??  null"
    					},
    					{
    						id: "get_args",
    						ref: "new_array"
    					},
    					{
    						id: "out",
    						extern: "just.get"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "input"
    					},
    					{
    						from: "def",
    						to: "out",
    						as: "def"
    					},
    					{
    						from: "path",
    						to: "out",
    						as: "path"
    					},
    					{
    						from: "target",
    						to: "out",
    						as: "target"
    					},
    					{
    						from: "get_args",
    						to: "_out",
    						as: "args"
    					}
    				]
    			},
    			{
    				id: "arg",
    				args: [
    					"node_inputs"
    				],
    				extern: "utility.arg"
    			},
    			{
    				id: "set",
    				type: "(target: any, value: any, path: string) => any",
    				script: "const keys = path.split('.'); const check = (o, v, k) => k.length === 1 ? {...o, [k[0]]: v, _needsresolve: true} : o.hasOwnProperty(k[0]) ? {...o, [k[0]]: check(o[k[0]], v, k.slice(1)), _needsresolve: true} : o; return check(target, value, keys)"
    			},
    			{
    				id: "delete",
    				out: "out",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "target",
    						ref: "arg",
    						value: "target"
    					},
    					{
    						id: "path",
    						ref: "arg",
    						value: "path"
    					},
    					{
    						id: "out",
    						script: "const new_val = Object.assign({}, target); delete target[path]; return new_val"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "target",
    						to: "out",
    						as: "target"
    					},
    					{
    						from: "path",
    						to: "out",
    						as: "path"
    					}
    				]
    			},
    			{
    				id: "html_element",
    				args: [
    					"children",
    					"props",
    					"dom_type"
    				],
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "fill_children",
    						args: [
    							"children"
    						],
    						script: "return children === undefined ? [] : children.length !== undefined ? children.filter(c => !!c).map(c => c.el ?? c) : [children.el ?? children]"
    					},
    					{
    						id: "fill_props",
    						args: [
    							"input"
    						],
    						script: "return input.props ?? {}"
    					},
    					{
    						id: "dom_type",
    						ref: "arg",
    						value: "dom_type"
    					},
    					{
    						id: "out",
    						script: "(children ?? []).forEach(c => {if(!((c.hasOwnProperty('dom_type') && c.hasOwnProperty('props')) || c.hasOwnProperty('text'))){throw new Error('invalid child element');}}); return {el: {dom_type, props, children}}"
    					},
    					{
    						id: "_out"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "fill_children"
    					},
    					{
    						from: "in",
    						to: "dom_type"
    					},
    					{
    						from: "in",
    						to: "fill_props",
    						as: "input"
    					},
    					{
    						from: "fill_children",
    						to: "out",
    						as: "children",
    						order: 1
    					},
    					{
    						from: "fill_props",
    						to: "out",
    						as: "props",
    						type: "resolve"
    					},
    					{
    						from: "dom_type",
    						to: "out",
    						as: "dom_type"
    					}
    				]
    			},
    			{
    				id: "html_element",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "text",
    						ref: "arg",
    						value: "text"
    					},
    					{
    						id: "dom_type",
    						value: "text_value"
    					},
    					{
    						id: "el"
    					},
    					{
    						id: "out",
    						args: [
    							"text"
    						]
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "input"
    					},
    					{
    						from: "dom_type",
    						to: "el",
    						as: "dom_type"
    					},
    					{
    						from: "text",
    						to: "el",
    						as: "text"
    					},
    					{
    						from: "el",
    						to: "out",
    						as: "el",
    						type: "resolve"
    					}
    				]
    			}
    		],
    		id: "simple_html_hyperapp",
    		out: "main/out",
    		"in": "main/in"
    	},
    	{
    		"in": "main/in",
    		out: "main/out",
    		id: "promises",
    		nodes: [
    			{
    				id: "main/out",
    				args: [
    					"value"
    				]
    			},
    			{
    				id: "main/in"
    			},
    			{
    				id: "63tva08",
    				ref: "html_element",
    				name: "main display"
    			},
    			{
    				id: "q23fegi",
    				value: "div"
    			},
    			{
    				id: "l6mvkla",
    				name: "props"
    			},
    			{
    				id: "o1wn5x1",
    				name: "class"
    			},
    			{
    				id: "zz730do",
    				value: "true"
    			},
    			{
    				ref: "arg",
    				id: "xev2phu",
    				value: "state"
    			},
    			{
    				id: "el0app0",
    				name: "state"
    			},
    			{
    				id: "2gcjbds",
    				ref: "get"
    			},
    			{
    				id: "f6js4lo",
    				script: "return res.then(r => r.json())"
    			},
    			{
    				id: "91dm5vd",
    				value: "data.0.content"
    			},
    			{
    				id: "m9yeyqc",
    				ref: "fetch"
    			},
    			{
    				id: "fphsciu",
    				value: "https://fakerapi.it/api/v1/texts"
    			},
    			{
    				id: "0iscsvl",
    				ref: "switch",
    				name: "fetch if needed"
    			},
    			{
    				id: "gcg2ctk",
    				script: "return runcount === undefined ? 'fetch' : 'state'"
    			},
    			{
    				ref: "arg",
    				id: "sgnxbrn",
    				value: "state.runcount"
    			},
    			{
    				ref: "arg",
    				id: "b77sv21",
    				value: "state.runcount"
    			},
    			{
    				id: "array"
    			},
    			{
    				id: "utility"
    			},
    			{
    				id: "flow"
    			},
    			{
    				id: "hyperapp"
    			},
    			{
    				id: "object"
    			},
    			{
    				id: "log",
    				args: [
    					"value"
    				],
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "value",
    						ref: "arg",
    						value: "value"
    					},
    					{
    						id: "out",
    						args: [
    						],
    						script: "console.log(_node.id); console.log(value); return value"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "input"
    					},
    					{
    						from: "value",
    						to: "out",
    						as: "value"
    					}
    				]
    			},
    			{
    				id: "fetch",
    				name: "fetch",
    				extern: "utility.fetch"
    			},
    			{
    				id: "filter",
    				name: "filter",
    				"in": "74n1jfm",
    				out: "lahq5z4",
    				nodes: [
    					{
    						id: "lahq5z4",
    						args: [
    						],
    						name: "filter/out",
    						script: "const filter_fn = _lib.no.executeGraphNode({graph: _graph})(fn); return arr.filter(filter_fn)"
    					},
    					{
    						id: "pfoypo5",
    						args: [
    						],
    						ref: "arg",
    						value: "key"
    					},
    					{
    						id: "zinx621",
    						args: [
    						],
    						ref: "arg",
    						value: "value"
    					},
    					{
    						id: "x2sz5kb",
    						args: [
    						],
    						ref: "arg",
    						value: "arr"
    					},
    					{
    						id: "fn",
    						ref: "arg",
    						value: "fn"
    					},
    					{
    						id: "74n1jfm",
    						args: [
    						],
    						name: "filter/in"
    					}
    				],
    				edges: [
    					{
    						from: "pfoypo5",
    						to: "lahq5z4",
    						as: "key"
    					},
    					{
    						from: "zinx621",
    						to: "lahq5z4",
    						as: "value"
    					},
    					{
    						from: "x2sz5kb",
    						to: "lahq5z4",
    						as: "arr"
    					},
    					{
    						from: "74n1jfm",
    						to: "lahq5z4",
    						as: "input"
    					},
    					{
    						from: "fn",
    						to: "lahq5z4",
    						as: "fn"
    					}
    				]
    			},
    			{
    				id: "switch",
    				args: [
    					"data",
    					"input"
    				],
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "out",
    						args: [
    							"data",
    							"input"
    						],
    						script: "return data[input];"
    					},
    					{
    						id: "input",
    						ref: "arg",
    						value: "input"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "data"
    					},
    					{
    						from: "input",
    						to: "out",
    						as: "input"
    					}
    				]
    			},
    			{
    				id: "if",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "pred",
    						ref: "arg",
    						value: "pred"
    					},
    					{
    						id: "out",
    						script: "return pred ? data['true'] : data['false']"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "data"
    					},
    					{
    						from: "pred",
    						to: "out",
    						as: "pred"
    					}
    				]
    			},
    			{
    				id: "execute_graph",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "fn",
    						ref: "arg",
    						value: "fn"
    					},
    					{
    						id: "graph",
    						ref: "arg",
    						value: "graph"
    					},
    					{
    						id: "out",
    						script: "return (...args) => {res = _lib.no.executeGraphNode({graph})(fn)(args.length === 1 ? args[0] : args); return res;}"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "graph",
    						to: "out",
    						as: "graph"
    					}
    				]
    			},
    			{
    				id: "apply",
    				script: "return _lib.no.executeGraphNode({graph: _graph})(fn)(args);"
    			},
    			{
    				id: "partial",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "input_value",
    						ref: "arg",
    						value: "_args"
    					},
    					{
    						id: "fn",
    						ref: "arg",
    						value: "fn"
    					},
    					{
    						id: "args",
    						ref: "arg",
    						value: "args"
    					},
    					{
    						id: "out",
    						script: "return _lib.no.executeGraphNode({graph: _graph})(fn)(Object.assign({}, _args, args))"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "args",
    						type: "ref"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "input_value",
    						to: "out",
    						as: "_args"
    					}
    				]
    			},
    			{
    				id: "new_array",
    				name: "new_array",
    				extern: "utility.new_array"
    			},
    			{
    				id: "get",
    				args: [
    					"target",
    					"path"
    				],
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "def",
    						ref: "arg",
    						value: "def"
    					},
    					{
    						id: "target",
    						ref: "arg",
    						value: "target"
    					},
    					{
    						id: "path",
    						ref: "arg",
    						value: "path"
    					},
    					{
    						id: "fill_default",
    						args: [
    							"input"
    						],
    						script: "return input?.default ??  null"
    					},
    					{
    						id: "get_args",
    						ref: "new_array"
    					},
    					{
    						id: "out",
    						extern: "just.get"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "input"
    					},
    					{
    						from: "def",
    						to: "out",
    						as: "def"
    					},
    					{
    						from: "path",
    						to: "out",
    						as: "path"
    					},
    					{
    						from: "target",
    						to: "out",
    						as: "target"
    					},
    					{
    						from: "get_args",
    						to: "_out",
    						as: "args"
    					}
    				]
    			},
    			{
    				id: "arg",
    				args: [
    					"node_inputs"
    				],
    				extern: "utility.arg"
    			},
    			{
    				id: "set",
    				type: "(target: any, value: any, path: string) => any",
    				script: "const keys = path.split('.'); const check = (o, v, k) => k.length === 1 ? {...o, [k[0]]: v, _needsresolve: true} : o.hasOwnProperty(k[0]) ? {...o, [k[0]]: check(o[k[0]], v, k.slice(1)), _needsresolve: true} : o; return check(target, value, keys)"
    			},
    			{
    				id: "delete",
    				out: "out",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "target",
    						ref: "arg",
    						value: "target"
    					},
    					{
    						id: "path",
    						ref: "arg",
    						value: "path"
    					},
    					{
    						id: "out",
    						script: "const new_val = Object.assign({}, target); delete target[path]; return new_val"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "target",
    						to: "out",
    						as: "target"
    					},
    					{
    						from: "path",
    						to: "out",
    						as: "path"
    					}
    				]
    			},
    			{
    				id: "html_element",
    				args: [
    					"children",
    					"props",
    					"dom_type"
    				],
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "fill_children",
    						args: [
    							"children"
    						],
    						script: "return children === undefined ? [] : children.length !== undefined ? children.filter(c => !!c).map(c => c.el ?? c) : [children.el ?? children]"
    					},
    					{
    						id: "fill_props",
    						args: [
    							"input"
    						],
    						script: "return input.props ?? {}"
    					},
    					{
    						id: "dom_type",
    						ref: "arg",
    						value: "dom_type"
    					},
    					{
    						id: "out",
    						script: "(children ?? []).forEach(c => {if(!((c.hasOwnProperty('dom_type') && c.hasOwnProperty('props')) || c.hasOwnProperty('text'))){throw new Error('invalid child element');}}); return {el: {dom_type, props, children}}"
    					},
    					{
    						id: "_out"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "fill_children"
    					},
    					{
    						from: "in",
    						to: "dom_type"
    					},
    					{
    						from: "in",
    						to: "fill_props",
    						as: "input"
    					},
    					{
    						from: "fill_children",
    						to: "out",
    						as: "children",
    						order: 1
    					},
    					{
    						from: "fill_props",
    						to: "out",
    						as: "props",
    						type: "resolve"
    					},
    					{
    						from: "dom_type",
    						to: "out",
    						as: "dom_type"
    					}
    				]
    			},
    			{
    				id: "html_element",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "text",
    						ref: "arg",
    						value: "text"
    					},
    					{
    						id: "dom_type",
    						value: "text_value"
    					},
    					{
    						id: "el"
    					},
    					{
    						id: "out",
    						args: [
    							"text"
    						]
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "input"
    					},
    					{
    						from: "dom_type",
    						to: "el",
    						as: "dom_type"
    					},
    					{
    						from: "text",
    						to: "el",
    						as: "text"
    					},
    					{
    						from: "el",
    						to: "out",
    						as: "el",
    						type: "resolve"
    					}
    				]
    			},
    			{
    				id: "l6vdvtn",
    				name: "display elements",
    				out: "l6vdvtn",
    				nodes: [
    					{
    						id: "l6vdvtn",
    						ref: "new_array",
    						name: "display elements"
    					},
    					{
    						id: "c2sko9c",
    						name: "hello world text",
    						out: "c2sko9c",
    						nodes: [
    							{
    								id: "c2sko9c",
    								ref: "html_element",
    								name: "hello world text"
    							},
    							{
    								id: "2lr3ihi",
    								value: "Hello, world!"
    							}
    						],
    						edges: [
    							{
    								from: "2lr3ihi",
    								to: "c2sko9c",
    								as: "text"
    							}
    						]
    					},
    					{
    						id: "pgygs2p/pgygs2p",
    						ref: "html_element",
    						name: "styles/out"
    					},
    					{
    						id: "ukbdszl",
    						ref: "html_element",
    						name: "display text"
    					},
    					{
    						id: "pgygs2p/vdyskp6",
    						value: "style",
    						name: ""
    					},
    					{
    						id: "pgygs2p/1tf3vvf",
    						ref: "new_array",
    						name: "styles/1tf3vvf"
    					},
    					{
    						id: "un5cq1q",
    						value: "div"
    					},
    					{
    						id: "0alhppw",
    						ref: "new_array",
    						name: "run count display"
    					},
    					{
    						id: "2t4s9uj",
    						name: "run count props"
    					},
    					{
    						id: "pgygs2p/6yewnx1",
    						ref: "html_element",
    						name: "styles/6yewnx1"
    					},
    					{
    						id: "g82nw07",
    						ref: "html_element"
    					},
    					{
    						id: "wh4juqx",
    						ref: "html_element"
    					},
    					{
    						id: "j630j9a",
    						value: "run-count"
    					},
    					{
    						id: "pgygs2p/02951w8",
    						value: ".result { position: absolute; bottom: 0; left: 0; font-size: 4em}\n.run-count { font-size: .5em; color: green}",
    						name: "css styles"
    					},
    					{
    						id: "gzr41q3",
    						ref: "log"
    					},
    					{
    						id: "edqfgkn",
    						value: "run count: "
    					},
    					{
    						ref: "arg",
    						id: "00ahbis",
    						value: "state.runcount"
    					}
    				],
    				edges: [
    					{
    						from: "c2sko9c",
    						to: "l6vdvtn",
    						as: "arg1"
    					},
    					{
    						from: "pgygs2p/pgygs2p",
    						to: "l6vdvtn",
    						as: "arg0"
    					},
    					{
    						from: "ukbdszl",
    						to: "l6vdvtn",
    						as: "arg2"
    					},
    					{
    						from: "pgygs2p/vdyskp6",
    						to: "pgygs2p/pgygs2p",
    						as: "dom_type"
    					},
    					{
    						from: "pgygs2p/1tf3vvf",
    						to: "pgygs2p/pgygs2p",
    						as: "children"
    					},
    					{
    						from: "un5cq1q",
    						to: "ukbdszl",
    						as: "dom_type"
    					},
    					{
    						from: "0alhppw",
    						to: "ukbdszl",
    						as: "children"
    					},
    					{
    						from: "2t4s9uj",
    						to: "ukbdszl",
    						as: "props"
    					},
    					{
    						from: "pgygs2p/6yewnx1",
    						to: "pgygs2p/1tf3vvf",
    						as: "arg0"
    					},
    					{
    						from: "g82nw07",
    						to: "0alhppw",
    						as: "arg1"
    					},
    					{
    						from: "wh4juqx",
    						to: "0alhppw",
    						as: "arg0"
    					},
    					{
    						from: "j630j9a",
    						to: "2t4s9uj",
    						as: "class"
    					},
    					{
    						from: "pgygs2p/02951w8",
    						to: "pgygs2p/6yewnx1",
    						as: "text"
    					},
    					{
    						from: "gzr41q3",
    						to: "g82nw07",
    						as: "text"
    					},
    					{
    						from: "edqfgkn",
    						to: "wh4juqx",
    						as: "text"
    					},
    					{
    						from: "00ahbis",
    						to: "gzr41q3",
    						as: "value"
    					}
    				]
    			}
    		],
    		edges: [
    			{
    				from: "main/in",
    				to: "main/out",
    				as: "args",
    				type: "ref"
    			},
    			{
    				from: "63tva08",
    				to: "main/out",
    				as: "display"
    			},
    			{
    				from: "l6vdvtn",
    				to: "63tva08",
    				as: "children"
    			},
    			{
    				from: "q23fegi",
    				to: "63tva08",
    				as: "dom_type"
    			},
    			{
    				from: "l6mvkla",
    				to: "63tva08",
    				as: "props"
    			},
    			{
    				from: "o1wn5x1",
    				to: "l6mvkla",
    				as: "class"
    			},
    			{
    				from: "zz730do",
    				to: "o1wn5x1",
    				as: "result"
    			},
    			{
    				from: "xev2phu",
    				to: "main/out",
    				as: "prev"
    			},
    			{
    				from: "el0app0",
    				to: "main/out",
    				as: "state"
    			},
    			{
    				from: "91dm5vd",
    				to: "2gcjbds",
    				as: "path"
    			},
    			{
    				from: "m9yeyqc",
    				to: "f6js4lo",
    				as: "res"
    			},
    			{
    				from: "fphsciu",
    				to: "m9yeyqc",
    				as: "url"
    			},
    			{
    				from: "f6js4lo",
    				to: "2gcjbds",
    				as: "target"
    			},
    			{
    				from: "2gcjbds",
    				to: "0iscsvl",
    				as: "fetch"
    			},
    			{
    				from: "0iscsvl",
    				to: "el0app0",
    				as: "runcount"
    			},
    			{
    				from: "gcg2ctk",
    				to: "0iscsvl",
    				as: "input"
    			},
    			{
    				from: "sgnxbrn",
    				to: "gcg2ctk",
    				as: "runcount"
    			},
    			{
    				from: "b77sv21",
    				to: "0iscsvl",
    				as: "state"
    			},
    			{
    				from: "get",
    				to: "object"
    			},
    			{
    				from: "set",
    				to: "object"
    			},
    			{
    				from: "delete",
    				to: "object"
    			},
    			{
    				from: "switch",
    				to: "flow"
    			},
    			{
    				from: "if",
    				to: "flow"
    			},
    			{
    				from: "html_element",
    				to: "hyperapp"
    			},
    			{
    				from: "html_element",
    				to: "hyperapp"
    			},
    			{
    				from: "new_array",
    				to: "array"
    			},
    			{
    				from: "filter",
    				to: "array"
    			},
    			{
    				from: "log",
    				to: "utility"
    			},
    			{
    				from: "execute_graph",
    				to: "utility"
    			},
    			{
    				from: "arg",
    				to: "utility"
    			},
    			{
    				from: "partial",
    				to: "utility"
    			},
    			{
    				from: "apply",
    				to: "utility"
    			},
    			{
    				from: "fetch",
    				to: "utility"
    			}
    		]
    	},
    	{
    		"in": "main/in",
    		out: "main/out",
    		id: "ldjs",
    		nodes: [
    			{
    				id: "main/out",
    				args: [
    					"value"
    				]
    			},
    			{
    				id: "o880w7g",
    				value: "attach"
    			},
    			{
    				id: "vcdwujf"
    			},
    			{
    				id: "es4nfz1",
    				name: "socket",
    				out: "es4nfz1",
    				nodes: [
    					{
    						id: "es4nfz1",
    						ref: "if",
    						name: "socket"
    					},
    					{
    						id: "0pvt2ak",
    						ref: "arg",
    						value: "state.socket"
    					},
    					{
    						id: "nho7wh4",
    						script: "return new WebSocket(\"ws://192.168.50.151:5959\");"
    					},
    					{
    						id: "am3jkzy",
    						ref: "arg",
    						value: "state.socket"
    					}
    				],
    				edges: [
    					{
    						from: "0pvt2ak",
    						to: "es4nfz1",
    						as: "pred"
    					},
    					{
    						from: "nho7wh4",
    						to: "es4nfz1",
    						as: "false"
    					},
    					{
    						from: "am3jkzy",
    						to: "es4nfz1",
    						as: "true"
    					}
    				]
    			},
    			{
    				id: "63tva08",
    				name: "main display",
    				out: "63tva08",
    				nodes: [
    					{
    						id: "63tva08",
    						ref: "h",
    						name: "main display"
    					},
    					{
    						id: "l6vdvtn",
    						ref: "new_array",
    						name: "display elements"
    					},
    					{
    						id: "q23fegi",
    						value: "div"
    					},
    					{
    						id: "l6mvkla",
    						name: "props"
    					},
    					{
    						id: "pgygs2p",
    						name: "styles",
    						out: "pgygs2p",
    						nodes: [
    							{
    								id: "pgygs2p",
    								ref: "h",
    								name: "out"
    							},
    							{
    								id: "vdyskp6",
    								value: "style",
    								name: ""
    							},
    							{
    								id: "1tf3vvf",
    								ref: "new_array",
    								name: "1tf3vvf"
    							},
    							{
    								id: "6yewnx1",
    								ref: "h_text",
    								name: "6yewnx1"
    							},
    							{
    								id: "02951w8",
    								value: ".result { position: absolute; bottom: 0; left: 0; font-size: .5em}.run-count { font-size: .5em; color: green}",
    								name: "css styles"
    							}
    						],
    						edges: [
    							{
    								from: "vdyskp6",
    								to: "pgygs2p",
    								as: "dom_type"
    							},
    							{
    								from: "1tf3vvf",
    								to: "pgygs2p",
    								as: "children"
    							},
    							{
    								from: "6yewnx1",
    								to: "1tf3vvf",
    								as: "arg0"
    							},
    							{
    								from: "02951w8",
    								to: "6yewnx1",
    								as: "text"
    							}
    						]
    					},
    					{
    						id: "o1wn5x1",
    						name: "class"
    					},
    					{
    						id: "zz730do",
    						value: "true"
    					}
    				],
    				edges: [
    					{
    						from: "l6vdvtn",
    						to: "63tva08",
    						as: "children"
    					},
    					{
    						from: "q23fegi",
    						to: "63tva08",
    						as: "dom_type"
    					},
    					{
    						from: "l6mvkla",
    						to: "63tva08",
    						as: "props"
    					},
    					{
    						from: "pgygs2p",
    						to: "l6vdvtn",
    						as: "arg0"
    					},
    					{
    						from: "o1wn5x1",
    						to: "l6mvkla",
    						as: "class"
    					},
    					{
    						from: "zz730do",
    						to: "o1wn5x1",
    						as: "result"
    					}
    				]
    			},
    			{
    				id: "ejrqx1n",
    				ref: "if"
    			},
    			{
    				id: "qgwedjs",
    				script: "return socket?.readyState === 1 && (payload?.key === 'Enter' && payload?.ctrlKey)",
    				name: "run on ctrl-enter"
    			},
    			{
    				id: "zstge6a",
    				ref: "arg",
    				value: "state.socket"
    			},
    			{
    				id: "pjpvf8v",
    				ref: "arg",
    				value: "payload"
    			},
    			{
    				id: "4cij4vp",
    				ref: "ldjs.nodesToJSON"
    			},
    			{
    				id: "a4f5e7n",
    				ref: "apply"
    			},
    			{
    				id: "50uqhfx",
    				ref: "log"
    			},
    			{
    				id: "call_top",
    				name: "call_top",
    				"in": "74pvyy9",
    				out: "sqaul9z",
    				nodes: [
    					{
    						name: "out",
    						id: "sqaul9z",
    						ref: "call"
    					},
    					{
    						id: "lqm909l"
    					},
    					{
    						id: "j8ofy4f",
    						value: "top"
    					},
    					{
    						id: "3ldiqaz",
    						script: "return args.args;"
    					},
    					{
    						id: "g43t0ef",
    						name: "top",
    						out: "g43t0ef",
    						nodes: [
    							{
    								id: "g43t0ef",
    								ref: "get",
    								name: "out"
    							},
    							{
    								id: "9hon4g9",
    								value: "top"
    							},
    							{
    								id: "l1iprfr",
    								ref: "arg",
    								value: "ldjs"
    							}
    						],
    						edges: [
    							{
    								from: "9hon4g9",
    								to: "g43t0ef",
    								as: "path"
    							},
    							{
    								from: "l1iprfr",
    								to: "g43t0ef",
    								as: "target"
    							}
    						]
    					},
    					{
    						name: "in",
    						id: "74pvyy9"
    					}
    				],
    				edges: [
    					{
    						from: "lqm909l",
    						to: "sqaul9z",
    						as: "self"
    					},
    					{
    						from: "j8ofy4f",
    						to: "sqaul9z",
    						as: "fn"
    					},
    					{
    						from: "3ldiqaz",
    						to: "sqaul9z",
    						as: "args"
    					},
    					{
    						from: "g43t0ef",
    						to: "lqm909l",
    						as: "top"
    					},
    					{
    						from: "74pvyy9",
    						to: "3ldiqaz",
    						as: "args"
    					}
    				]
    			},
    			{
    				id: "kmvuyh6",
    				name: "nodes",
    				out: "kmvuyh6",
    				nodes: [
    					{
    						id: "kmvuyh6",
    						ref: "new_array"
    					},
    					{
    						id: "r6pusum",
    						ref: "call"
    					},
    					{
    						id: "fjwkp7f",
    						ref: "Node.connect"
    					},
    					{
    						id: "rhbn0kq",
    						value: "out"
    					},
    					{
    						id: "sqaul9z",
    						name: "call_top",
    						ref: "call_top"
    					},
    					{
    						id: "mks39ik",
    						name: "call_top",
    						ref: "call_top"
    					},
    					{
    						id: "spszelk",
    						ref: "new_array"
    					},
    					{
    						id: "vi3rwtb",
    						ref: "new_array"
    					},
    					{
    						id: "6mw13hh",
    						value: "noise"
    					},
    					{
    						id: "gyp9o2b",
    						value: "out"
    					}
    				],
    				edges: [
    					{
    						from: "r6pusum",
    						to: "kmvuyh6",
    						as: "arg0"
    					},
    					{
    						from: "fjwkp7f",
    						to: "r6pusum",
    						as: "self"
    					},
    					{
    						from: "rhbn0kq",
    						to: "r6pusum",
    						as: "fn"
    					},
    					{
    						from: "sqaul9z",
    						to: "fjwkp7f",
    						as: "Node"
    					},
    					{
    						from: "mks39ik",
    						to: "fjwkp7f",
    						as: "n"
    					},
    					{
    						from: "spszelk",
    						to: "sqaul9z",
    						as: "args"
    					},
    					{
    						from: "vi3rwtb",
    						to: "mks39ik",
    						as: "args"
    					},
    					{
    						from: "6mw13hh",
    						to: "spszelk",
    						as: "arg0"
    					},
    					{
    						from: "gyp9o2b",
    						to: "vi3rwtb",
    						as: "arg0"
    					}
    				]
    			},
    			{
    				id: "array"
    			},
    			{
    				id: "utility"
    			},
    			{
    				id: "flow"
    			},
    			{
    				id: "hyperapp"
    			},
    			{
    				id: "object"
    			},
    			{
    				id: "custom"
    			},
    			{
    				id: "JSON"
    			},
    			{
    				id: "log",
    				args: [
    					"value"
    				],
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "value",
    						ref: "arg",
    						value: "value"
    					},
    					{
    						id: "out",
    						args: [
    						],
    						script: "console.log(_node.name ?? _node.id); console.log(value); return value"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "input"
    					},
    					{
    						from: "value",
    						to: "out",
    						as: "value"
    					}
    				]
    			},
    			{
    				id: "fetch",
    				name: "fetch",
    				extern: "utility.fetch"
    			},
    			{
    				id: "call",
    				name: "call",
    				extern: "utility.call"
    			},
    			{
    				id: "stringify",
    				name: "stringify",
    				extern: "JSON.stringify"
    			},
    			{
    				id: "append",
    				type: "(array: A[], item: A) => A[]",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "out",
    						args: [
    							"item",
    							"array"
    						],
    						script: "return array.concat(Array.isArray(item) ? item : [item])"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out"
    					}
    				]
    			},
    			{
    				id: "filter",
    				name: "filter",
    				"in": "74n1jfm",
    				out: "lahq5z4",
    				nodes: [
    					{
    						id: "lahq5z4",
    						args: [
    						],
    						name: "filter/out",
    						script: "const filter_fn = _lib.no.executeGraphNode({graph: _graph})(fn); return arr.filter(filter_fn)"
    					},
    					{
    						id: "pfoypo5",
    						args: [
    						],
    						ref: "arg",
    						value: "key"
    					},
    					{
    						id: "zinx621",
    						args: [
    						],
    						ref: "arg",
    						value: "value"
    					},
    					{
    						id: "x2sz5kb",
    						args: [
    						],
    						ref: "arg",
    						value: "arr"
    					},
    					{
    						id: "fn",
    						ref: "arg",
    						value: "fn"
    					},
    					{
    						id: "74n1jfm",
    						args: [
    						],
    						name: "filter/in"
    					}
    				],
    				edges: [
    					{
    						from: "pfoypo5",
    						to: "lahq5z4",
    						as: "key"
    					},
    					{
    						from: "zinx621",
    						to: "lahq5z4",
    						as: "value"
    					},
    					{
    						from: "x2sz5kb",
    						to: "lahq5z4",
    						as: "arr"
    					},
    					{
    						from: "74n1jfm",
    						to: "lahq5z4",
    						as: "input"
    					},
    					{
    						from: "fn",
    						to: "lahq5z4",
    						as: "fn"
    					}
    				]
    			},
    			{
    				id: "default",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "value",
    						ref: "arg",
    						value: "value"
    					},
    					{
    						id: "otherwise",
    						ref: "arg",
    						value: "otherwise"
    					},
    					{
    						id: "out",
    						args: [
    							"data",
    							"default_value"
    						],
    						script: "return value ?? otherwise"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "value",
    						to: "out",
    						as: "value"
    					},
    					{
    						from: "otherwise",
    						to: "out",
    						as: "otherwise"
    					}
    				]
    			},
    			{
    				id: "switch",
    				args: [
    					"data",
    					"input"
    				],
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "out",
    						args: [
    							"data",
    							"input"
    						],
    						script: "return data[input];"
    					},
    					{
    						id: "input",
    						ref: "arg",
    						value: "input"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "data"
    					},
    					{
    						from: "input",
    						to: "out",
    						as: "input"
    					}
    				]
    			},
    			{
    				id: "if",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "pred",
    						ref: "arg",
    						value: "pred"
    					},
    					{
    						id: "out",
    						script: "return pred ? data['true'] : data['false']"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "data"
    					},
    					{
    						from: "pred",
    						to: "out",
    						as: "pred"
    					}
    				]
    			},
    			{
    				id: "execute_graph",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "fn",
    						ref: "arg",
    						value: "fn"
    					},
    					{
    						id: "graph",
    						ref: "arg",
    						value: "graph"
    					},
    					{
    						id: "out",
    						script: "return (...args) => {res = _lib.no.executeGraphNode({graph})(fn)(args.length === 1 ? args[0] : args); return res;}"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "graph",
    						to: "out",
    						as: "graph"
    					}
    				]
    			},
    			{
    				id: "apply",
    				script: "return _lib.no.executeGraphNode({graph: _graph})(fn)(args);"
    			},
    			{
    				id: "partial",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "input_value",
    						ref: "arg",
    						value: "_args"
    					},
    					{
    						id: "fn",
    						ref: "arg",
    						value: "fn"
    					},
    					{
    						id: "args",
    						ref: "arg",
    						value: "args"
    					},
    					{
    						id: "out",
    						script: "return _lib.no.executeGraphNode({graph: _graph})(fn)(Object.assign({}, _args, args))"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "args",
    						type: "ref"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "input_value",
    						to: "out",
    						as: "_args"
    					}
    				]
    			},
    			{
    				id: "new_array",
    				name: "new_array",
    				extern: "utility.new_array"
    			},
    			{
    				id: "get",
    				args: [
    					"target",
    					"path"
    				],
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "def",
    						ref: "arg",
    						value: "def"
    					},
    					{
    						id: "target",
    						ref: "arg",
    						value: "target"
    					},
    					{
    						id: "path",
    						ref: "arg",
    						value: "path"
    					},
    					{
    						id: "fill_default",
    						args: [
    							"input"
    						],
    						script: "return input?.default ??  null"
    					},
    					{
    						id: "get_args",
    						ref: "new_array"
    					},
    					{
    						id: "out",
    						extern: "just.get"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "input"
    					},
    					{
    						from: "def",
    						to: "out",
    						as: "def"
    					},
    					{
    						from: "path",
    						to: "out",
    						as: "path"
    					},
    					{
    						from: "target",
    						to: "out",
    						as: "target"
    					},
    					{
    						from: "get_args",
    						to: "_out",
    						as: "args"
    					}
    				]
    			},
    			{
    				id: "arg",
    				args: [
    					"node_inputs"
    				],
    				extern: "utility.arg"
    			},
    			{
    				id: "set",
    				type: "(target: any, value: any, path: string) => any",
    				script: "const keys = path.split('.'); const check = (o, v, k) => k.length === 1 ? {...o, [k[0]]: v, _needsresolve: true} : o.hasOwnProperty(k[0]) ? {...o, [k[0]]: check(o[k[0]], v, k.slice(1)), _needsresolve: true} : o; return check(target, value, keys)"
    			},
    			{
    				id: "delete",
    				out: "out",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "target",
    						ref: "arg",
    						value: "target"
    					},
    					{
    						id: "path",
    						ref: "arg",
    						value: "path"
    					},
    					{
    						id: "out",
    						script: "const new_val = Object.assign({}, target); delete target[path]; return new_val"
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "target",
    						to: "out",
    						as: "target"
    					},
    					{
    						from: "path",
    						to: "out",
    						as: "path"
    					}
    				]
    			},
    			{
    				id: "map",
    				name: "map",
    				"in": "m3b5wg3",
    				out: "tgurdpo",
    				nodes: [
    					{
    						id: "tgurdpo",
    						ref: "call",
    						name: "out"
    					},
    					{
    						id: "m3b5wg3",
    						name: "in"
    					},
    					{
    						id: "rielyq8",
    						value: "map",
    						name: "rielyq8"
    					},
    					{
    						ref: "arg",
    						id: "1rre4bx",
    						value: "array",
    						name: "1rre4bx"
    					},
    					{
    						id: "w0zzawl",
    						ref: "new_array",
    						name: "w0zzawl"
    					},
    					{
    						id: "pdljod1",
    						name: "pdljod1",
    						script: "return (element, index, array) => _lib.no.runGraph(_graph, fn, {element,index,array});"
    					},
    					{
    						id: "2lvs5dj",
    						script: "return _graph",
    						name: "2lvs5dj"
    					},
    					{
    						ref: "arg",
    						id: "6g75abk",
    						value: "fn",
    						name: "6g75abk"
    					}
    				],
    				edges: [
    					{
    						from: "m3b5wg3",
    						to: "tgurdpo",
    						as: "args",
    						type: "ref"
    					},
    					{
    						from: "rielyq8",
    						to: "tgurdpo",
    						as: "fn"
    					},
    					{
    						from: "1rre4bx",
    						to: "tgurdpo",
    						as: "self"
    					},
    					{
    						from: "w0zzawl",
    						to: "tgurdpo",
    						as: "args",
    						type: "resolve"
    					},
    					{
    						from: "pdljod1",
    						to: "w0zzawl",
    						as: "a0"
    					},
    					{
    						from: "2lvs5dj",
    						to: "pdljod1",
    						as: "graph"
    					},
    					{
    						from: "6g75abk",
    						to: "pdljod1",
    						as: "fn"
    					}
    				]
    			},
    			{
    				id: "h",
    				args: [
    					"children",
    					"props",
    					"dom_type"
    				],
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "children",
    						ref: "arg",
    						value: "children"
    					},
    					{
    						id: "props",
    						ref: "arg",
    						value: "props"
    					},
    					{
    						id: "fill_children",
    						args: [
    							"children"
    						],
    						script: "return children === undefined ? [] : children.length !== undefined ? children.filter(c => !!c).map(c => c.el ?? c) : [children.el ?? children]"
    					},
    					{
    						id: "fill_props",
    						args: [
    							"input"
    						],
    						script: "return props ?? {}"
    					},
    					{
    						id: "dom_type",
    						ref: "arg",
    						value: "dom_type"
    					},
    					{
    						id: "out",
    						script: "(children.filter(c => !!c) ?? []).forEach(c => {if(!(typeof c.dom_type === 'string' || typeof c.text === 'string')){throw new Error('invalid child element');}}); return {el: {dom_type, props, children}}"
    					},
    					{
    						id: "_out"
    					}
    				],
    				edges: [
    					{
    						from: "children",
    						to: "fill_children",
    						as: "children"
    					},
    					{
    						from: "props",
    						to: "fill_props",
    						as: "props"
    					},
    					{
    						from: "fill_children",
    						to: "out",
    						as: "children",
    						order: 1,
    						type: "resolve"
    					},
    					{
    						from: "fill_props",
    						to: "out",
    						as: "props"
    					},
    					{
    						from: "dom_type",
    						to: "out",
    						as: "dom_type"
    					},
    					{
    						from: "in",
    						to: "out",
    						as: "args",
    						type: "ref"
    					}
    				]
    			},
    			{
    				id: "h_text",
    				nodes: [
    					{
    						id: "in"
    					},
    					{
    						id: "text",
    						ref: "arg",
    						value: "text"
    					},
    					{
    						id: "dom_type",
    						value: "text_value"
    					},
    					{
    						id: "el"
    					},
    					{
    						id: "out",
    						args: [
    							"text"
    						]
    					}
    				],
    				edges: [
    					{
    						from: "in",
    						to: "out",
    						as: "input"
    					},
    					{
    						from: "dom_type",
    						to: "el",
    						as: "dom_type"
    					},
    					{
    						from: "text",
    						to: "el",
    						as: "text"
    					},
    					{
    						from: "el",
    						to: "out",
    						as: "el"
    					}
    				]
    			},
    			{
    				id: "DisconnectedNode.connect",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "DisconnectedNode"
    					},
    					{
    						id: "fn",
    						value: "connect"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "n",
    						ref: "arg",
    						value: "n"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "n",
    						to: "args",
    						as: "arg0"
    					}
    				]
    			},
    			{
    				id: "DisconnectedNode.c",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "DisconnectedNode"
    					},
    					{
    						id: "fn",
    						value: "c"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "n",
    						ref: "arg",
    						value: "n"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "n",
    						to: "args",
    						as: "arg0"
    					}
    				]
    			},
    			{
    				id: "DisconnectedNode.run",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "DisconnectedNode"
    					},
    					{
    						id: "fn",
    						value: "run"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "inputs",
    						ref: "arg",
    						value: "inputs"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "inputs",
    						to: "args",
    						as: "arg0"
    					}
    				]
    			},
    			{
    				id: "DisconnectedNode.runT",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "DisconnectedNode"
    					},
    					{
    						id: "fn",
    						value: "runT"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					}
    				]
    			},
    			{
    				id: "DisconnectedNode.out",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "DisconnectedNode"
    					},
    					{
    						id: "fn",
    						value: "out"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					}
    				]
    			},
    			{
    				id: "Node.connect",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "Node"
    					},
    					{
    						id: "fn",
    						value: "connect"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "n",
    						ref: "arg",
    						value: "n"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "n",
    						to: "args",
    						as: "arg0"
    					}
    				]
    			},
    			{
    				id: "Node.c",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "Node"
    					},
    					{
    						id: "fn",
    						value: "c"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "n",
    						ref: "arg",
    						value: "n"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "n",
    						to: "args",
    						as: "arg0"
    					}
    				]
    			},
    			{
    				id: "Node.runT",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "Node"
    					},
    					{
    						id: "fn",
    						value: "runT"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					}
    				]
    			},
    			{
    				id: "Node.out",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "Node"
    					},
    					{
    						id: "fn",
    						value: "out"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					}
    				]
    			},
    			{
    				id: "ldjs.parseJSON",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "parseJSON"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "data",
    						ref: "arg",
    						value: "data"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "data",
    						to: "args",
    						as: "arg0"
    					}
    				]
    			},
    			{
    				id: "ldjs.validateNode",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "validateNode"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "node",
    						ref: "arg",
    						value: "node"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "node",
    						to: "args",
    						as: "arg0"
    					}
    				]
    			},
    			{
    				id: "ldjs.validateNodes",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "validateNodes"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "nodes",
    						ref: "arg",
    						value: "nodes"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "nodes",
    						to: "args",
    						as: "arg0"
    					}
    				]
    			},
    			{
    				id: "ldjs.testConnection",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "testConnection"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "type",
    						ref: "arg",
    						value: "type"
    					},
    					{
    						id: "family",
    						ref: "arg",
    						value: "family"
    					},
    					{
    						id: "connection",
    						ref: "arg",
    						value: "connection"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "type",
    						to: "args",
    						as: "arg0"
    					},
    					{
    						from: "family",
    						to: "args",
    						as: "arg1"
    					},
    					{
    						from: "connection",
    						to: "args",
    						as: "arg2"
    					}
    				]
    			},
    			{
    				id: "ldjs.testParams",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "testParams"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "type",
    						ref: "arg",
    						value: "type"
    					},
    					{
    						id: "params",
    						ref: "arg",
    						value: "params"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "type",
    						to: "args",
    						as: "arg0"
    					},
    					{
    						from: "params",
    						to: "args",
    						as: "arg1"
    					}
    				]
    			},
    			{
    				id: "ldjs.isIParamAny",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "isIParamAny"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "param",
    						ref: "arg",
    						value: "param"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "param",
    						to: "args",
    						as: "arg0"
    					}
    				]
    			},
    			{
    				id: "ldjs.testParam",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "testParam"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "type",
    						ref: "arg",
    						value: "type"
    					},
    					{
    						id: "name",
    						ref: "arg",
    						value: "name"
    					},
    					{
    						id: "param",
    						ref: "arg",
    						value: "param"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "type",
    						to: "args",
    						as: "arg0"
    					},
    					{
    						from: "name",
    						to: "args",
    						as: "arg1"
    					},
    					{
    						from: "param",
    						to: "args",
    						as: "arg2"
    					}
    				]
    			},
    			{
    				id: "ldjs.nodedictout",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "nodedictout"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "nd",
    						ref: "arg",
    						value: "nd"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "nd",
    						to: "args",
    						as: "arg0"
    					}
    				]
    			},
    			{
    				id: "ldjs.dictname",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "dictname"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "optype",
    						ref: "arg",
    						value: "optype"
    					},
    					{
    						id: "opidx",
    						ref: "arg",
    						value: "opidx"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "optype",
    						to: "args",
    						as: "arg0"
    					},
    					{
    						from: "opidx",
    						to: "args",
    						as: "arg1"
    					}
    				]
    			},
    			{
    				id: "ldjs.nodeToJSON",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "nodeToJSON"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "node",
    						ref: "arg",
    						value: "node"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "node",
    						to: "args",
    						as: "arg0"
    					}
    				]
    			},
    			{
    				id: "ldjs.nodesToJSON",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "nodesToJSON"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "nodes",
    						ref: "arg",
    						value: "nodes"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "nodes",
    						to: "args",
    						as: "arg0"
    					}
    				]
    			},
    			{
    				id: "ldjs.instanceofFBTargetNode",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "instanceofFBTargetNode"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "node",
    						ref: "arg",
    						value: "node"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "node",
    						to: "args",
    						as: "arg0"
    					}
    				]
    			},
    			{
    				id: "ldjs.instanceofFBNode",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "instanceofFBNode"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "node",
    						ref: "arg",
    						value: "node"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "node",
    						to: "args",
    						as: "arg0"
    					}
    				]
    			},
    			{
    				id: "ldjs.addToNodeDict",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "addToNodeDict"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "nodedict",
    						ref: "arg",
    						value: "nodedict"
    					},
    					{
    						id: "node",
    						ref: "arg",
    						value: "node"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "nodedict",
    						to: "args",
    						as: "arg0"
    					},
    					{
    						from: "node",
    						to: "args",
    						as: "arg1"
    					}
    				]
    			},
    			{
    				id: "ldjs.addNode",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "addNode"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "nodedict",
    						ref: "arg",
    						value: "nodedict"
    					},
    					{
    						id: "node",
    						ref: "arg",
    						value: "node"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "nodedict",
    						to: "args",
    						as: "arg0"
    					},
    					{
    						from: "node",
    						to: "args",
    						as: "arg1"
    					}
    				]
    			},
    			{
    				id: "ldjs.placeInNodeDict",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "placeInNodeDict"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "nodedict",
    						ref: "arg",
    						value: "nodedict"
    					},
    					{
    						id: "node",
    						ref: "arg",
    						value: "node"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "nodedict",
    						to: "args",
    						as: "arg0"
    					},
    					{
    						from: "node",
    						to: "args",
    						as: "arg1"
    					}
    				]
    			},
    			{
    				id: "ldjs.addParameter",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "addParameter"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "nodedict",
    						ref: "arg",
    						value: "nodedict"
    					},
    					{
    						id: "parameters",
    						ref: "arg",
    						value: "parameters"
    					},
    					{
    						id: "name",
    						ref: "arg",
    						value: "name"
    					},
    					{
    						id: "param",
    						ref: "arg",
    						value: "param"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "nodedict",
    						to: "args",
    						as: "arg0"
    					},
    					{
    						from: "parameters",
    						to: "args",
    						as: "arg1"
    					},
    					{
    						from: "name",
    						to: "args",
    						as: "arg2"
    					},
    					{
    						from: "param",
    						to: "args",
    						as: "arg3"
    					}
    				]
    			},
    			{
    				id: "ldjs.addAction",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "addAction"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "nodedict",
    						ref: "arg",
    						value: "nodedict"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "nodedict",
    						to: "args",
    						as: "arg0"
    					}
    				]
    			},
    			{
    				id: "ldjs.parseParamValue",
    				nodes: [
    					{
    						id: "self",
    						ref: "arg",
    						value: "ldjs"
    					},
    					{
    						id: "fn",
    						value: "parseParamValue"
    					},
    					{
    						id: "out",
    						ref: "call"
    					},
    					{
    						id: "args",
    						ref: "new_array"
    					},
    					{
    						id: "nodedict",
    						ref: "arg",
    						value: "nodedict"
    					},
    					{
    						id: "value",
    						ref: "arg",
    						value: "value"
    					}
    				],
    				edges: [
    					{
    						from: "self",
    						to: "out",
    						as: "self"
    					},
    					{
    						from: "fn",
    						to: "out",
    						as: "fn"
    					},
    					{
    						from: "args",
    						to: "out",
    						as: "args"
    					},
    					{
    						from: "nodedict",
    						to: "args",
    						as: "arg0"
    					},
    					{
    						from: "value",
    						to: "args",
    						as: "arg1"
    					}
    				]
    			},
    			{
    				id: "u3kdq65",
    				ref: "call"
    			},
    			{
    				id: "8l0ween",
    				ref: "arg",
    				value: "socket"
    			},
    			{
    				id: "q4bdpyb",
    				ref: "new_array"
    			},
    			{
    				id: "aot1lxn",
    				value: "send"
    			},
    			{
    				id: "41hwuf4",
    				name: "run_args",
    				out: "41hwuf4",
    				nodes: [
    					{
    						id: "41hwuf4",
    						name: "run_args"
    					},
    					{
    						id: "e73m4nt",
    						script: "return _lib.ldjs;",
    						name: "ldjs"
    					},
    					{
    						id: "xao0apc",
    						ref: "arg",
    						value: "state.socket"
    					}
    				],
    				edges: [
    					{
    						from: "e73m4nt",
    						to: "41hwuf4",
    						as: "ldjs"
    					},
    					{
    						from: "xao0apc",
    						to: "41hwuf4",
    						as: "socket"
    					}
    				]
    			}
    		],
    		edges: [
    			{
    				from: "63tva08",
    				to: "main/out",
    				as: "display",
    				type: "resolve"
    			},
    			{
    				from: "o880w7g",
    				to: "c2sko9c/in",
    				as: "icon"
    			},
    			{
    				from: "vcdwujf",
    				to: "main/out",
    				as: "state"
    			},
    			{
    				from: "es4nfz1",
    				to: "vcdwujf",
    				as: "socket"
    			},
    			{
    				from: "ejrqx1n",
    				to: "vcdwujf",
    				as: "arg1"
    			},
    			{
    				from: "qgwedjs",
    				to: "ejrqx1n",
    				as: "pred"
    			},
    			{
    				from: "zstge6a",
    				to: "qgwedjs",
    				as: "socket"
    			},
    			{
    				from: "pjpvf8v",
    				to: "qgwedjs",
    				as: "payload"
    			},
    			{
    				from: "a4f5e7n",
    				to: "ejrqx1n",
    				as: "true"
    			},
    			{
    				from: "41hwuf4",
    				to: "a4f5e7n",
    				as: "args"
    			},
    			{
    				from: "50uqhfx",
    				to: "a4f5e7n",
    				as: "fn",
    				type: "ref"
    			},
    			{
    				from: "kmvuyh6",
    				to: "4cij4vp",
    				as: "nodes"
    			},
    			{
    				from: "call_top",
    				to: "custom"
    			},
    			{
    				from: "call_top",
    				to: "custom"
    			},
    			{
    				from: "get",
    				to: "object"
    			},
    			{
    				from: "set",
    				to: "object"
    			},
    			{
    				from: "delete",
    				to: "object"
    			},
    			{
    				from: "switch",
    				to: "flow"
    			},
    			{
    				from: "if",
    				to: "flow"
    			},
    			{
    				from: "h",
    				to: "hyperapp"
    			},
    			{
    				from: "h_text",
    				to: "hyperapp"
    			},
    			{
    				from: "new_array",
    				to: "array"
    			},
    			{
    				from: "filter",
    				to: "array"
    			},
    			{
    				from: "append",
    				to: "array"
    			},
    			{
    				from: "map",
    				to: "array"
    			},
    			{
    				from: "log",
    				to: "utility"
    			},
    			{
    				from: "execute_graph",
    				to: "utility"
    			},
    			{
    				from: "arg",
    				to: "utility"
    			},
    			{
    				from: "partial",
    				to: "utility"
    			},
    			{
    				from: "apply",
    				to: "utility"
    			},
    			{
    				from: "fetch",
    				to: "utility"
    			},
    			{
    				from: "stringify",
    				to: "JSON"
    			},
    			{
    				from: "DisconnectedNode.connect",
    				to: "lambdadesigner"
    			},
    			{
    				from: "DisconnectedNode.c",
    				to: "lambdadesigner"
    			},
    			{
    				from: "DisconnectedNode.run",
    				to: "lambdadesigner"
    			},
    			{
    				from: "DisconnectedNode.runT",
    				to: "lambdadesigner"
    			},
    			{
    				from: "DisconnectedNode.out",
    				to: "lambdadesigner"
    			},
    			{
    				from: "Node.connect",
    				to: "lambdadesigner"
    			},
    			{
    				from: "Node.c",
    				to: "lambdadesigner"
    			},
    			{
    				from: "Node.runT",
    				to: "lambdadesigner"
    			},
    			{
    				from: "Node.out",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.parseJSON",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.validateNode",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.validateNodes",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.testConnection",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.testParams",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.isIParamAny",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.testParam",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.nodedictout",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.dictname",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.nodeToJSON",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.nodesToJSON",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.instanceofFBTargetNode",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.instanceofFBNode",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.addToNodeDict",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.addNode",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.placeInNodeDict",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.addParameter",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.addAction",
    				to: "lambdadesigner"
    			},
    			{
    				from: "ldjs.parseParamValue",
    				to: "lambdadesigner"
    			},
    			{
    				from: "u3kdq65",
    				to: "50uqhfx",
    				as: "value"
    			},
    			{
    				from: "8l0ween",
    				to: "u3kdq65",
    				as: "self"
    			},
    			{
    				from: "4cij4vp",
    				to: "q4bdpyb",
    				as: "arg0"
    			},
    			{
    				from: "q4bdpyb",
    				to: "u3kdq65",
    				as: "args"
    			},
    			{
    				from: "aot1lxn",
    				to: "u3kdq65",
    				as: "fn"
    			}
    		]
    	}
    ];

    var objectSafeGet = get$5;

    /*
      const obj = {a: {aa: {aaa: 2}}, b: 4};

      get(obj, 'a.aa.aaa'); // 2
      get(obj, ['a', 'aa', 'aaa']); // 2

      get(obj, 'b.bb.bbb'); // undefined
      get(obj, ['b', 'bb', 'bbb']); // undefined

      get(obj.a, 'aa.aaa'); // 2
      get(obj.a, ['aa', 'aaa']); // 2

      get(obj.b, 'bb.bbb'); // undefined
      get(obj.b, ['bb', 'bbb']); // undefined

      get(obj.b, 'bb.bbb', 42); // 42
      get(obj.b, ['bb', 'bbb'], 42); // 42

      get(null, 'a'); // undefined
      get(undefined, ['a']); // undefined

      get(null, 'a', 42); // 42
      get(undefined, ['a'], 42); // 42

      const obj = {a: {}};
      const sym = Symbol();
      obj.a[sym] = 4;
      get(obj.a, sym); // 4
    */

    function get$5(obj, propsArg, defaultValue) {
      if (!obj) {
        return defaultValue;
      }
      var props, prop;
      if (Array.isArray(propsArg)) {
        props = propsArg.slice(0);
      }
      if (typeof propsArg == 'string') {
        props = propsArg.split('.');
      }
      if (typeof propsArg == 'symbol') {
        props = [propsArg];
      }
      if (!Array.isArray(props)) {
        throw new Error('props arg must be an array, a string or a symbol');
      }
      while (props.length) {
        prop = props.shift();
        if (!obj) {
          return defaultValue;
        }
        obj = obj[prop];
        if (obj === undefined) {
          return defaultValue;
        }
      }
      return obj;
    }

    var objectSafeSet = set$1;

    /*
      var obj1 = {};
      set(obj1, 'a.aa.aaa', 4); // true
      obj1; // {a: {aa: {aaa: 4}}}

      var obj2 = {};
      set(obj2, ['a', 'aa', 'aaa'], 4); // true
      obj2; // {a: {aa: {aaa: 4}}}

      var obj3 = {a: {aa: {aaa: 2}}};
      set(obj3, 'a.aa.aaa', 3); // true
      obj3; // {a: {aa: {aaa: 3}}}

      // don't clobber existing
      var obj4 = {a: {aa: {aaa: 2}}};
      set(obj4, 'a.aa', {bbb: 7}); // false

      const obj5 = {a: {}};
      const sym = Symbol();
      set(obj5.a, sym, 7); // true
      obj5; // {a: {Symbol(): 7}}
    */

    function set$1(obj, propsArg, value) {
      var props, lastProp;
      if (Array.isArray(propsArg)) {
        props = propsArg.slice(0);
      }
      if (typeof propsArg == 'string') {
        props = propsArg.split('.');
      }
      if (typeof propsArg == 'symbol') {
        props = [propsArg];
      }
      if (!Array.isArray(props)) {
        throw new Error('props arg must be an array, a string or a symbol');
      }
      lastProp = props.pop();
      if (!lastProp) {
        return false;
      }
      prototypeCheck$1(lastProp);
      var thisProp;
      while ((thisProp = props.shift())) {
        prototypeCheck$1(thisProp);
        if (typeof obj[thisProp] == 'undefined') {
          obj[thisProp] = {};
        }
        obj = obj[thisProp];
        if (!obj || typeof obj != 'object') {
          return false;
        }
      }
      obj[lastProp] = value;
      return true;
    }

    function prototypeCheck$1(prop) {
      // coercion is intentional to catch prop values like `['__proto__']`
      if (prop == '__proto__' || prop == 'constructor' || prop == 'prototype') {
        throw new Error('setting of prototype values not supported');
      }
    }

    /*
      const obj1 = {a: 4, b: 5};
      const obj2 = {a: 3, b: 5};
      const obj3 = {a: 4, c: 5};

      diff(obj1, obj2);
      [
        { "op": "replace", "path": ['a'], "value": 3 }
      ]

      diff(obj2, obj3);
      [
        { "op": "remove", "path": ['b'] },
        { "op": "replace", "path": ['a'], "value": 4 }
        { "op": "add", "path": ['c'], "value": 5 }
      ]

      // using converter to generate jsPatch standard paths
      // see http://jsonpatch.com
      import {diff, jsonPatchPathConverter} from 'just-diff'
      diff(obj1, obj2, jsonPatchPathConverter);
      [
        { "op": "replace", "path": '/a', "value": 3 }
      ]

      diff(obj2, obj3, jsonPatchPathConverter);
      [
        { "op": "remove", "path": '/b' },
        { "op": "replace", "path": '/a', "value": 4 }
        { "op": "add", "path": '/c', "value": 5 }
      ]

      // arrays
      const obj4 = {a: 4, b: [1, 2, 3]};
      const obj5 = {a: 3, b: [1, 2, 4]};
      const obj6 = {a: 3, b: [1, 2, 4, 5]};

      diff(obj4, obj5);
      [
        { "op": "replace", "path": ['a'], "value": 3 }
        { "op": "replace", "path": ['b', 2], "value": 4 }
      ]

      diff(obj5, obj6);
      [
        { "op": "add", "path": ['b', 3], "value": 5 }
      ]

      // nested paths
      const obj7 = {a: 4, b: {c: 3}};
      const obj8 = {a: 4, b: {c: 4}};
      const obj9 = {a: 5, b: {d: 4}};

      diff(obj7, obj8);
      [
        { "op": "replace", "path": ['b', 'c'], "value": 4 }
      ]

      diff(obj8, obj9);
      [
        { "op": "replace", "path": ['a'], "value": 5 }
        { "op": "remove", "path": ['b', 'c']}
        { "op": "add", "path": ['b', 'd'], "value": 4 }
      ]
    */

    function diff(obj1, obj2, pathConverter) {
      if (!obj1 || typeof obj1 != 'object' || !obj2 || typeof obj2 != 'object') {
        throw new Error('both arguments must be objects or arrays');
      }

      pathConverter ||
        (pathConverter = function(arr) {
          return arr;
        });

      function getDiff(obj1, obj2, basePath, diffs) {
        var obj1Keys = Object.keys(obj1);
        var obj1KeysLength = obj1Keys.length;
        var obj2Keys = Object.keys(obj2);
        var obj2KeysLength = obj2Keys.length;
        var path;

        for (var i = 0; i < obj1KeysLength; i++) {
          var key = Array.isArray(obj1) ? Number(obj1Keys[i]) : obj1Keys[i];
          if (!(key in obj2)) {
            path = basePath.concat(key);
            diffs.remove.push({
              op: 'remove',
              path: pathConverter(path),
            });
          }
        }

        for (var i = 0; i < obj2KeysLength; i++) {
          var key = Array.isArray(obj2) ? Number(obj2Keys[i]) : obj2Keys[i];
          var obj1AtKey = obj1[key];
          var obj2AtKey = obj2[key];
          if (!(key in obj1)) {
            path = basePath.concat(key);
            var obj2Value = obj2[key];
            diffs.add.push({
              op: 'add',
              path: pathConverter(path),
              value: obj2Value,
            });
          } else if (obj1AtKey !== obj2AtKey) {
            if (
              Object(obj1AtKey) !== obj1AtKey ||
              Object(obj2AtKey) !== obj2AtKey
            ) {
              path = pushReplace(path, basePath, key, diffs, pathConverter, obj2);
            } else {
              if (
                !Object.keys(obj1AtKey).length &&
                !Object.keys(obj2AtKey).length &&
                String(obj1AtKey) != String(obj2AtKey)
              ) {
                path = pushReplace(path, basePath, key, diffs, pathConverter, obj2);
              } else {
                getDiff(obj1[key], obj2[key], basePath.concat(key), diffs);
              }
            }
          }
        }

        return diffs.remove.reverse().concat(diffs.replace).concat(diffs.add);
      }
      return getDiff(obj1, obj2, [], {remove: [], replace: [], add: []});
    }

    function pushReplace(path, basePath, key, diffs, pathConverter, obj2) {
      path = basePath.concat(key);
      diffs.replace.push({
        op: 'replace',
        path: pathConverter(path),
        value: obj2[key],
      });
      return path;
    }

    /*
      const obj1 = {a: 3, b: 5};
      diffApply(obj1,
        [
          { "op": "remove", "path": ['b'] },
          { "op": "replace", "path": ['a'], "value": 4 },
          { "op": "add", "path": ['c'], "value": 5 }
        ]
      );
      obj1; // {a: 4, c: 5}

      // using converter to apply jsPatch standard paths
      // see http://jsonpatch.com
      import {diff, jsonPatchPathConverter} from 'just-diff'
      const obj2 = {a: 3, b: 5};
      diffApply(obj2, [
        { "op": "remove", "path": '/b' },
        { "op": "replace", "path": '/a', "value": 4 }
        { "op": "add", "path": '/c', "value": 5 }
      ], jsonPatchPathConverter);
      obj2; // {a: 4, c: 5}

      // arrays
      const obj3 = {a: 4, b: [1, 2, 3]};
      diffApply(obj3, [
        { "op": "replace", "path": ['a'], "value": 3 }
        { "op": "replace", "path": ['b', 2], "value": 4 }
        { "op": "add", "path": ['b', 3], "value": 9 }
      ]);
      obj3; // {a: 3, b: [1, 2, 4, 9]}

      // nested paths
      const obj4 = {a: 4, b: {c: 3}};
      diffApply(obj4, [
        { "op": "replace", "path": ['a'], "value": 5 }
        { "op": "remove", "path": ['b', 'c']}
        { "op": "add", "path": ['b', 'd'], "value": 4 }
      ]);
      obj4; // {a: 5, b: {d: 4}}
    */

    var REMOVE = 'remove';
    var REPLACE = 'replace';
    var ADD = 'add';

    function diffApply(obj, diff, pathConverter) {
      if (!obj || typeof obj != 'object') {
        throw new Error('base object must be an object or an array');
      }

      if (!Array.isArray(diff)) {
        throw new Error('diff must be an array');
      }

      var diffLength = diff.length;
      for (var i = 0; i < diffLength; i++) {
        var thisDiff = diff[i];
        var subObject = obj;
        var thisOp = thisDiff.op;
        var thisPath = thisDiff.path;
        if (pathConverter) {
          thisPath = pathConverter(thisPath);
          if (!Array.isArray(thisPath)) {
            throw new Error('pathConverter must return an array');
          }
        } else {
          if (!Array.isArray(thisPath)) {
            throw new Error('diff path must be an array, consider supplying a path converter');
          }
        }
        var pathCopy = thisPath.slice();
        var lastProp = pathCopy.pop();
        prototypeCheck(lastProp);
        if (lastProp == null) {
          return false;
        }
        var thisProp;
        while (((thisProp = pathCopy.shift())) != null) {
          prototypeCheck(thisProp);
          if (!(thisProp in subObject)) {
            subObject[thisProp] = {};
          }
          subObject = subObject[thisProp];
        }
        if (thisOp === REMOVE || thisOp === REPLACE) {
          if (!subObject.hasOwnProperty(lastProp)) {
            throw new Error(['expected to find property', thisDiff.path, 'in object', obj].join(' '));
          }
        }
        if (thisOp === REMOVE) {
          Array.isArray(subObject) ? subObject.splice(lastProp, 1) : delete subObject[lastProp];
        }
        if (thisOp === REPLACE || thisOp === ADD) {
          subObject[lastProp] = thisDiff.value;
        }
      }
      return subObject;
    }

    function prototypeCheck(prop) {
      // coercion is intentional to catch prop values like `['__proto__']`
      if (prop == '__proto__' || prop == 'constructor' || prop == 'prototype') {
        throw new Error('setting of prototype values not supported');
      }
    }

    var SSR_NODE = 1;
    var TEXT_NODE = 3;
    var EMPTY_OBJ = {};
    var EMPTY_ARR = [];
    var SVG_NS = "http://www.w3.org/2000/svg";

    var id$2 = (a) => a;
    var map$F = EMPTY_ARR.map;
    var isArray$1 = Array.isArray;
    var enqueue =
      typeof requestAnimationFrame !== "undefined"
        ? requestAnimationFrame
        : setTimeout;

    var createClass = (obj) => {
      var out = "";

      if (typeof obj === "string") return obj

      if (isArray$1(obj)) {
        for (var k = 0, tmp; k < obj.length; k++) {
          if ((tmp = createClass(obj[k]))) {
            out += (out && " ") + tmp;
          }
        }
      } else {
        for (var k in obj) {
          if (obj[k]) out += (out && " ") + k;
        }
      }

      return out
    };

    var shouldRestart = (a, b) => {
      for (var k in { ...a, ...b }) {
        if (typeof (isArray$1(a[k]) ? a[k][0] : a[k]) === "function") {
          b[k] = a[k];
        } else if (a[k] !== b[k]) return true
      }
    };

    var patchSubs = (oldSubs, newSubs = EMPTY_ARR, dispatch) => {
      for (
        var subs = [], i = 0, oldSub, newSub;
        i < oldSubs.length || i < newSubs.length;
        i++
      ) {
        oldSub = oldSubs[i];
        newSub = newSubs[i];

        subs.push(
          newSub && newSub !== true
            ? !oldSub ||
              newSub[0] !== oldSub[0] ||
              shouldRestart(newSub[1], oldSub[1])
              ? [
                  newSub[0],
                  newSub[1],
                  (oldSub && oldSub[2](), newSub[0](dispatch, newSub[1])),
                ]
              : oldSub
            : oldSub && oldSub[2]()
        );
      }
      return subs
    };

    var getKey = (vdom) => (vdom == null ? vdom : vdom.key);

    var patchProperty = (node, key, oldValue, newValue, listener, isSvg) => {
      if (key === "key") ; else if (key === "style") {
        for (var k in { ...oldValue, ...newValue }) {
          oldValue = newValue == null || newValue[k] == null ? "" : newValue[k];
          if (k[0] === "-") {
            node[key].setProperty(k, oldValue);
          } else {
            node[key][k] = oldValue;
          }
        }
      } else if (key[0] === "o" && key[1] === "n") {
        if (
          !((node.events || (node.events = {}))[(key = key.slice(2))] = newValue)
        ) {
          node.removeEventListener(key, listener);
        } else if (!oldValue) {
          node.addEventListener(key, listener);
        }
      } else if (!isSvg && key !== "list" && key !== "form" && key in node) {
        node[key] = newValue == null ? "" : newValue;
      } else if (
        newValue == null ||
        newValue === false ||
        (key === "class" && !(newValue = createClass(newValue)))
      ) {
        node.removeAttribute(key);
      } else {
        node.setAttribute(key, newValue);
      }
    };

    var createNode = (vdom, listener, isSvg) => {
      var props = vdom.props;
      var node =
        vdom.type === TEXT_NODE
          ? document.createTextNode(vdom.tag)
          : (isSvg = isSvg || vdom.tag === "svg")
          ? document.createElementNS(SVG_NS, vdom.tag, props.is && props)
          : document.createElement(vdom.tag, props.is && props);

      for (var k in props) {
        patchProperty(node, k, null, props[k], listener, isSvg);
      }

      for (var i = 0; i < vdom.children.length; i++) {
        node.appendChild(
          createNode(
            (vdom.children[i] = maybeVNode(vdom.children[i])),
            listener,
            isSvg
          )
        );
      }

      return (vdom.node = node)
    };

    var patch = (parent, node, oldVNode, newVNode, listener, isSvg) => {
      if (oldVNode === newVNode) ; else if (
        oldVNode != null &&
        oldVNode.type === TEXT_NODE &&
        newVNode.type === TEXT_NODE
      ) {
        if (oldVNode.tag !== newVNode.tag) node.nodeValue = newVNode.tag;
      } else if (oldVNode == null || oldVNode.tag !== newVNode.tag) {
        node = parent.insertBefore(
          createNode((newVNode = maybeVNode(newVNode)), listener, isSvg),
          node
        );
        if (oldVNode != null) {
          parent.removeChild(oldVNode.node);
        }
      } else {
        var tmpVKid;
        var oldVKid;

        var oldKey;
        var newKey;

        var oldProps = oldVNode.props;
        var newProps = newVNode.props;

        var oldVKids = oldVNode.children;
        var newVKids = newVNode.children;

        var oldHead = 0;
        var newHead = 0;
        var oldTail = oldVKids.length - 1;
        var newTail = newVKids.length - 1;

        isSvg = isSvg || newVNode.tag === "svg";

        for (var i in { ...oldProps, ...newProps }) {
          if (
            (i === "value" || i === "selected" || i === "checked"
              ? node[i]
              : oldProps[i]) !== newProps[i]
          ) {
            patchProperty(node, i, oldProps[i], newProps[i], listener, isSvg);
          }
        }

        while (newHead <= newTail && oldHead <= oldTail) {
          if (
            (oldKey = getKey(oldVKids[oldHead])) == null ||
            oldKey !== getKey(newVKids[newHead])
          ) {
            break
          }

          patch(
            node,
            oldVKids[oldHead].node,
            oldVKids[oldHead],
            (newVKids[newHead] = maybeVNode(
              newVKids[newHead++],
              oldVKids[oldHead++]
            )),
            listener,
            isSvg
          );
        }

        while (newHead <= newTail && oldHead <= oldTail) {
          if (
            (oldKey = getKey(oldVKids[oldTail])) == null ||
            oldKey !== getKey(newVKids[newTail])
          ) {
            break
          }

          patch(
            node,
            oldVKids[oldTail].node,
            oldVKids[oldTail],
            (newVKids[newTail] = maybeVNode(
              newVKids[newTail--],
              oldVKids[oldTail--]
            )),
            listener,
            isSvg
          );
        }

        if (oldHead > oldTail) {
          while (newHead <= newTail) {
            node.insertBefore(
              createNode(
                (newVKids[newHead] = maybeVNode(newVKids[newHead++])),
                listener,
                isSvg
              ),
              (oldVKid = oldVKids[oldHead]) && oldVKid.node
            );
          }
        } else if (newHead > newTail) {
          while (oldHead <= oldTail) {
            node.removeChild(oldVKids[oldHead++].node);
          }
        } else {
          for (var keyed = {}, newKeyed = {}, i = oldHead; i <= oldTail; i++) {
            if ((oldKey = oldVKids[i].key) != null) {
              keyed[oldKey] = oldVKids[i];
            }
          }

          while (newHead <= newTail) {
            oldKey = getKey((oldVKid = oldVKids[oldHead]));
            newKey = getKey(
              (newVKids[newHead] = maybeVNode(newVKids[newHead], oldVKid))
            );

            if (
              newKeyed[oldKey] ||
              (newKey != null && newKey === getKey(oldVKids[oldHead + 1]))
            ) {
              if (oldKey == null) {
                node.removeChild(oldVKid.node);
              }
              oldHead++;
              continue
            }

            if (newKey == null || oldVNode.type === SSR_NODE) {
              if (oldKey == null) {
                patch(
                  node,
                  oldVKid && oldVKid.node,
                  oldVKid,
                  newVKids[newHead],
                  listener,
                  isSvg
                );
                newHead++;
              }
              oldHead++;
            } else {
              if (oldKey === newKey) {
                patch(
                  node,
                  oldVKid.node,
                  oldVKid,
                  newVKids[newHead],
                  listener,
                  isSvg
                );
                newKeyed[newKey] = true;
                oldHead++;
              } else {
                if ((tmpVKid = keyed[newKey]) != null) {
                  patch(
                    node,
                    node.insertBefore(tmpVKid.node, oldVKid && oldVKid.node),
                    tmpVKid,
                    newVKids[newHead],
                    listener,
                    isSvg
                  );
                  newKeyed[newKey] = true;
                } else {
                  patch(
                    node,
                    oldVKid && oldVKid.node,
                    null,
                    newVKids[newHead],
                    listener,
                    isSvg
                  );
                }
              }
              newHead++;
            }
          }

          while (oldHead <= oldTail) {
            if (getKey((oldVKid = oldVKids[oldHead++])) == null) {
              node.removeChild(oldVKid.node);
            }
          }

          for (var i in keyed) {
            if (newKeyed[i] == null) {
              node.removeChild(keyed[i].node);
            }
          }
        }
      }

      return (newVNode.node = node)
    };

    var propsChanged = (a, b) => {
      for (var k in a) if (a[k] !== b[k]) return true
      for (var k in b) if (a[k] !== b[k]) return true
    };

    var maybeVNode = (newVNode, oldVNode) =>
      newVNode !== true && newVNode !== false && newVNode
        ? typeof newVNode.tag === "function"
          ? ((!oldVNode ||
              oldVNode.memo == null ||
              propsChanged(oldVNode.memo, newVNode.memo)) &&
              ((oldVNode = newVNode.tag(newVNode.memo)).memo = newVNode.memo),
            oldVNode)
          : newVNode
        : text("");

    var recycleNode = (node) =>
      node.nodeType === TEXT_NODE
        ? text(node.nodeValue, node)
        : createVNode(
            node.nodeName.toLowerCase(),
            EMPTY_OBJ,
            map$F.call(node.childNodes, recycleNode),
            SSR_NODE,
            node
          );

    var createVNode = (tag, props, children, type, node) => ({
      tag,
      props,
      key: props.key,
      children,
      type,
      node,
    });

    var memo = (tag, memo) => ({ tag, memo });

    var text = (value, node) =>
      createVNode(value, EMPTY_OBJ, EMPTY_ARR, TEXT_NODE, node);

    var h = (tag, props, children = EMPTY_ARR) =>
      createVNode(tag, props, isArray$1(children) ? children : [children]);

    var app = ({
      node,
      view,
      subscriptions,
      dispatch = id$2,
      init = EMPTY_OBJ,
    }) => {
      var vdom = node && recycleNode(node);
      var subs = [];
      var state;
      var busy;

      var update = (newState) => {
        if (state !== newState) {
          if ((state = newState) == null) dispatch = subscriptions = render = id$2;
          if (subscriptions) subs = patchSubs(subs, subscriptions(state), dispatch);
          if (view && !busy) enqueue(render, (busy = true));
        }
      };

      var render = () =>
        (node = patch(
          node.parentNode,
          node,
          vdom,
          (vdom = view(state)),
          listener,
          (busy = false)
        ));

      var listener = function (event) {
        dispatch(this.events[event.type], event);
      };

      return (
        (dispatch = dispatch((action, props) =>
          typeof action === "function"
            ? dispatch(action(state, props))
            : isArray$1(action)
            ? typeof action[0] === "function"
              ? dispatch(action[0], action[1])
              : action
                  .slice(1)
                  .map(
                    (fx) => fx && fx !== true && (fx[0] || fx)(dispatch, fx[1]),
                    update(action[0])
                  )
            : update(action)
        ))(init),
        dispatch
      )
    };

    function forceCenter(x, y) {
      var nodes, strength = 1;

      if (x == null) x = 0;
      if (y == null) y = 0;

      function force() {
        var i,
            n = nodes.length,
            node,
            sx = 0,
            sy = 0;

        for (i = 0; i < n; ++i) {
          node = nodes[i], sx += node.x, sy += node.y;
        }

        for (sx = (sx / n - x) * strength, sy = (sy / n - y) * strength, i = 0; i < n; ++i) {
          node = nodes[i], node.x -= sx, node.y -= sy;
        }
      }

      force.initialize = function(_) {
        nodes = _;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      return force;
    }

    function tree_add(d) {
      const x = +this._x.call(null, d),
          y = +this._y.call(null, d);
      return add(this.cover(x, y), x, y, d);
    }

    function add(tree, x, y, d) {
      if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

      var parent,
          node = tree._root,
          leaf = {data: d},
          x0 = tree._x0,
          y0 = tree._y0,
          x1 = tree._x1,
          y1 = tree._y1,
          xm,
          ym,
          xp,
          yp,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return tree._root = leaf, tree;

      // Find the existing leaf for the new point, or add it.
      while (node.length) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
      }

      // Is the new point is exactly coincident with the existing point?
      xp = +tree._x.call(null, node.data);
      yp = +tree._y.call(null, node.data);
      if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

      // Otherwise, split the leaf node until the old and new point are separated.
      do {
        parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
      } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
      return parent[j] = node, parent[i] = leaf, tree;
    }

    function addAll(data) {
      var d, i, n = data.length,
          x,
          y,
          xz = new Array(n),
          yz = new Array(n),
          x0 = Infinity,
          y0 = Infinity,
          x1 = -Infinity,
          y1 = -Infinity;

      // Compute the points and their extent.
      for (i = 0; i < n; ++i) {
        if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
        xz[i] = x;
        yz[i] = y;
        if (x < x0) x0 = x;
        if (x > x1) x1 = x;
        if (y < y0) y0 = y;
        if (y > y1) y1 = y;
      }

      // If there were no (valid) points, abort.
      if (x0 > x1 || y0 > y1) return this;

      // Expand the tree to cover the new points.
      this.cover(x0, y0).cover(x1, y1);

      // Add the new points.
      for (i = 0; i < n; ++i) {
        add(this, xz[i], yz[i], data[i]);
      }

      return this;
    }

    function tree_cover(x, y) {
      if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

      var x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1;

      // If the quadtree has no extent, initialize them.
      // Integer extent are necessary so that if we later double the extent,
      // the existing quadrant boundaries don’t change due to floating point error!
      if (isNaN(x0)) {
        x1 = (x0 = Math.floor(x)) + 1;
        y1 = (y0 = Math.floor(y)) + 1;
      }

      // Otherwise, double repeatedly to cover.
      else {
        var z = x1 - x0 || 1,
            node = this._root,
            parent,
            i;

        while (x0 > x || x >= x1 || y0 > y || y >= y1) {
          i = (y < y0) << 1 | (x < x0);
          parent = new Array(4), parent[i] = node, node = parent, z *= 2;
          switch (i) {
            case 0: x1 = x0 + z, y1 = y0 + z; break;
            case 1: x0 = x1 - z, y1 = y0 + z; break;
            case 2: x1 = x0 + z, y0 = y1 - z; break;
            case 3: x0 = x1 - z, y0 = y1 - z; break;
          }
        }

        if (this._root && this._root.length) this._root = node;
      }

      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      return this;
    }

    function tree_data() {
      var data = [];
      this.visit(function(node) {
        if (!node.length) do data.push(node.data); while (node = node.next)
      });
      return data;
    }

    function tree_extent(_) {
      return arguments.length
          ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
          : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
    }

    function Quad(node, x0, y0, x1, y1) {
      this.node = node;
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
    }

    function tree_find(x, y, radius) {
      var data,
          x0 = this._x0,
          y0 = this._y0,
          x1,
          y1,
          x2,
          y2,
          x3 = this._x1,
          y3 = this._y1,
          quads = [],
          node = this._root,
          q,
          i;

      if (node) quads.push(new Quad(node, x0, y0, x3, y3));
      if (radius == null) radius = Infinity;
      else {
        x0 = x - radius, y0 = y - radius;
        x3 = x + radius, y3 = y + radius;
        radius *= radius;
      }

      while (q = quads.pop()) {

        // Stop searching if this quadrant can’t contain a closer node.
        if (!(node = q.node)
            || (x1 = q.x0) > x3
            || (y1 = q.y0) > y3
            || (x2 = q.x1) < x0
            || (y2 = q.y1) < y0) continue;

        // Bisect the current quadrant.
        if (node.length) {
          var xm = (x1 + x2) / 2,
              ym = (y1 + y2) / 2;

          quads.push(
            new Quad(node[3], xm, ym, x2, y2),
            new Quad(node[2], x1, ym, xm, y2),
            new Quad(node[1], xm, y1, x2, ym),
            new Quad(node[0], x1, y1, xm, ym)
          );

          // Visit the closest quadrant first.
          if (i = (y >= ym) << 1 | (x >= xm)) {
            q = quads[quads.length - 1];
            quads[quads.length - 1] = quads[quads.length - 1 - i];
            quads[quads.length - 1 - i] = q;
          }
        }

        // Visit this point. (Visiting coincident points isn’t necessary!)
        else {
          var dx = x - +this._x.call(null, node.data),
              dy = y - +this._y.call(null, node.data),
              d2 = dx * dx + dy * dy;
          if (d2 < radius) {
            var d = Math.sqrt(radius = d2);
            x0 = x - d, y0 = y - d;
            x3 = x + d, y3 = y + d;
            data = node.data;
          }
        }
      }

      return data;
    }

    function tree_remove(d) {
      if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

      var parent,
          node = this._root,
          retainer,
          previous,
          next,
          x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1,
          x,
          y,
          xm,
          ym,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return this;

      // Find the leaf node for the point.
      // While descending, also retain the deepest parent with a non-removed sibling.
      if (node.length) while (true) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
        if (!node.length) break;
        if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
      }

      // Find the point to remove.
      while (node.data !== d) if (!(previous = node, node = node.next)) return this;
      if (next = node.next) delete node.next;

      // If there are multiple coincident points, remove just the point.
      if (previous) return (next ? previous.next = next : delete previous.next), this;

      // If this is the root point, remove it.
      if (!parent) return this._root = next, this;

      // Remove this leaf.
      next ? parent[i] = next : delete parent[i];

      // If the parent now contains exactly one leaf, collapse superfluous parents.
      if ((node = parent[0] || parent[1] || parent[2] || parent[3])
          && node === (parent[3] || parent[2] || parent[1] || parent[0])
          && !node.length) {
        if (retainer) retainer[j] = node;
        else this._root = node;
      }

      return this;
    }

    function removeAll(data) {
      for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
      return this;
    }

    function tree_root() {
      return this._root;
    }

    function tree_size() {
      var size = 0;
      this.visit(function(node) {
        if (!node.length) do ++size; while (node = node.next)
      });
      return size;
    }

    function tree_visit(callback) {
      var quads = [], q, node = this._root, child, x0, y0, x1, y1;
      if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
          var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
        }
      }
      return this;
    }

    function tree_visitAfter(callback) {
      var quads = [], next = [], q;
      if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        var node = q.node;
        if (node.length) {
          var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
        }
        next.push(q);
      }
      while (q = next.pop()) {
        callback(q.node, q.x0, q.y0, q.x1, q.y1);
      }
      return this;
    }

    function defaultX(d) {
      return d[0];
    }

    function tree_x(_) {
      return arguments.length ? (this._x = _, this) : this._x;
    }

    function defaultY(d) {
      return d[1];
    }

    function tree_y(_) {
      return arguments.length ? (this._y = _, this) : this._y;
    }

    function quadtree(nodes, x, y) {
      var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
      return nodes == null ? tree : tree.addAll(nodes);
    }

    function Quadtree(x, y, x0, y0, x1, y1) {
      this._x = x;
      this._y = y;
      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      this._root = undefined;
    }

    function leaf_copy(leaf) {
      var copy = {data: leaf.data}, next = copy;
      while (leaf = leaf.next) next = next.next = {data: leaf.data};
      return copy;
    }

    var treeProto = quadtree.prototype = Quadtree.prototype;

    treeProto.copy = function() {
      var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
          node = this._root,
          nodes,
          child;

      if (!node) return copy;

      if (!node.length) return copy._root = leaf_copy(node), copy;

      nodes = [{source: node, target: copy._root = new Array(4)}];
      while (node = nodes.pop()) {
        for (var i = 0; i < 4; ++i) {
          if (child = node.source[i]) {
            if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
            else node.target[i] = leaf_copy(child);
          }
        }
      }

      return copy;
    };

    treeProto.add = tree_add;
    treeProto.addAll = addAll;
    treeProto.cover = tree_cover;
    treeProto.data = tree_data;
    treeProto.extent = tree_extent;
    treeProto.find = tree_find;
    treeProto.remove = tree_remove;
    treeProto.removeAll = removeAll;
    treeProto.root = tree_root;
    treeProto.size = tree_size;
    treeProto.visit = tree_visit;
    treeProto.visitAfter = tree_visitAfter;
    treeProto.x = tree_x;
    treeProto.y = tree_y;

    function constant$2(x) {
      return function() {
        return x;
      };
    }

    function jiggle(random) {
      return (random() - 0.5) * 1e-6;
    }

    function x$1(d) {
      return d.x + d.vx;
    }

    function y$1(d) {
      return d.y + d.vy;
    }

    function forceCollide(radius) {
      var nodes,
          radii,
          random,
          strength = 1,
          iterations = 1;

      if (typeof radius !== "function") radius = constant$2(radius == null ? 1 : +radius);

      function force() {
        var i, n = nodes.length,
            tree,
            node,
            xi,
            yi,
            ri,
            ri2;

        for (var k = 0; k < iterations; ++k) {
          tree = quadtree(nodes, x$1, y$1).visitAfter(prepare);
          for (i = 0; i < n; ++i) {
            node = nodes[i];
            ri = radii[node.index], ri2 = ri * ri;
            xi = node.x + node.vx;
            yi = node.y + node.vy;
            tree.visit(apply);
          }
        }

        function apply(quad, x0, y0, x1, y1) {
          var data = quad.data, rj = quad.r, r = ri + rj;
          if (data) {
            if (data.index > node.index) {
              var x = xi - data.x - data.vx,
                  y = yi - data.y - data.vy,
                  l = x * x + y * y;
              if (l < r * r) {
                if (x === 0) x = jiggle(random), l += x * x;
                if (y === 0) y = jiggle(random), l += y * y;
                l = (r - (l = Math.sqrt(l))) / l * strength;
                node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
                node.vy += (y *= l) * r;
                data.vx -= x * (r = 1 - r);
                data.vy -= y * r;
              }
            }
            return;
          }
          return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
        }
      }

      function prepare(quad) {
        if (quad.data) return quad.r = radii[quad.data.index];
        for (var i = quad.r = 0; i < 4; ++i) {
          if (quad[i] && quad[i].r > quad.r) {
            quad.r = quad[i].r;
          }
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        radii = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : radius;
      };

      return force;
    }

    function index$1(d) {
      return d.index;
    }

    function find(nodeById, nodeId) {
      var node = nodeById.get(nodeId);
      if (!node) throw new Error("node not found: " + nodeId);
      return node;
    }

    function forceLink(links) {
      var id = index$1,
          strength = defaultStrength,
          strengths,
          distance = constant$2(30),
          distances,
          nodes,
          count,
          bias,
          random,
          iterations = 1;

      if (links == null) links = [];

      function defaultStrength(link) {
        return 1 / Math.min(count[link.source.index], count[link.target.index]);
      }

      function force(alpha) {
        for (var k = 0, n = links.length; k < iterations; ++k) {
          for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
            link = links[i], source = link.source, target = link.target;
            x = target.x + target.vx - source.x - source.vx || jiggle(random);
            y = target.y + target.vy - source.y - source.vy || jiggle(random);
            l = Math.sqrt(x * x + y * y);
            l = (l - distances[i]) / l * alpha * strengths[i];
            x *= l, y *= l;
            target.vx -= x * (b = bias[i]);
            target.vy -= y * b;
            source.vx += x * (b = 1 - b);
            source.vy += y * b;
          }
        }
      }

      function initialize() {
        if (!nodes) return;

        var i,
            n = nodes.length,
            m = links.length,
            nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
            link;

        for (i = 0, count = new Array(n); i < m; ++i) {
          link = links[i], link.index = i;
          if (typeof link.source !== "object") link.source = find(nodeById, link.source);
          if (typeof link.target !== "object") link.target = find(nodeById, link.target);
          count[link.source.index] = (count[link.source.index] || 0) + 1;
          count[link.target.index] = (count[link.target.index] || 0) + 1;
        }

        for (i = 0, bias = new Array(m); i < m; ++i) {
          link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
        }

        strengths = new Array(m), initializeStrength();
        distances = new Array(m), initializeDistance();
      }

      function initializeStrength() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          strengths[i] = +strength(links[i], i, links);
        }
      }

      function initializeDistance() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          distances[i] = +distance(links[i], i, links);
        }
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.links = function(_) {
        return arguments.length ? (links = _, initialize(), force) : links;
      };

      force.id = function(_) {
        return arguments.length ? (id = _, force) : id;
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$2(+_), initializeStrength(), force) : strength;
      };

      force.distance = function(_) {
        return arguments.length ? (distance = typeof _ === "function" ? _ : constant$2(+_), initializeDistance(), force) : distance;
      };

      return force;
    }

    var noop$3 = {value: () => {}};

    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch(_);
    }

    function Dispatch(_) {
      this._ = _;
    }

    function parseTypenames(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {type: t, name: name};
      });
    }

    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._,
            T = parseTypenames(typename + "", _),
            t,
            i = -1,
            n = T.length;

        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
          while (++i < n) if ((t = (typename = T[i]).type) && (t = get$4(_[t], typename.name))) return t;
          return;
        }

        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
          else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
        }

        return this;
      },
      copy: function() {
        var copy = {}, _ = this._;
        for (var t in _) copy[t] = _[t].slice();
        return new Dispatch(copy);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      }
    };

    function get$4(type, name) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
          return c.value;
        }
      }
    }

    function set(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop$3, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null) type.push({name: name, value: callback});
      return type;
    }

    var frame = 0, // is an animation frame pending?
        timeout = 0, // is a timeout pending?
        interval = 0, // are any timers active?
        pokeDelay = 1000, // how frequently we check for clock skew
        taskHead,
        taskTail,
        clockLast = 0,
        clockNow = 0,
        clockSkew = 0,
        clock = typeof performance === "object" && performance.now ? performance : Date,
        setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

    function now$1() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }

    function clearNow() {
      clockNow = 0;
    }

    function Timer() {
      this._call =
      this._time =
      this._next = null;
    }

    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now$1() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;
          else taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };

    function timer(callback, delay, time) {
      var t = new Timer;
      t.restart(callback, delay, time);
      return t;
    }

    function timerFlush() {
      now$1(); // Get the current time, if not already set.
      ++frame; // Pretend we’ve set an alarm, if we haven’t already.
      var t = taskHead, e;
      while (t) {
        if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
        t = t._next;
      }
      --frame;
    }

    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }

    function poke() {
      var now = clock.now(), delay = now - clockLast;
      if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }

    function nap() {
      var t0, t1 = taskHead, t2, time = Infinity;
      while (t1) {
        if (t1._call) {
          if (time > t1._time) time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }
      taskTail = t0;
      sleep(time);
    }

    function sleep(time) {
      if (frame) return; // Soonest alarm already set, or will be.
      if (timeout) timeout = clearTimeout(timeout);
      var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
      if (delay > 24) {
        if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval) interval = clearInterval(interval);
      } else {
        if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const a = 1664525;
    const c$1 = 1013904223;
    const m = 4294967296; // 2^32

    function lcg() {
      let s = 1;
      return () => (s = (a * s + c$1) % m) / m;
    }

    function x(d) {
      return d.x;
    }

    function y(d) {
      return d.y;
    }

    var initialRadius = 10,
        initialAngle = Math.PI * (3 - Math.sqrt(5));

    function forceSimulation(nodes) {
      var simulation,
          alpha = 1,
          alphaMin = 0.001,
          alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
          alphaTarget = 0,
          velocityDecay = 0.6,
          forces = new Map(),
          stepper = timer(step),
          event = dispatch("tick", "end"),
          random = lcg();

      if (nodes == null) nodes = [];

      function step() {
        tick();
        event.call("tick", simulation);
        if (alpha < alphaMin) {
          stepper.stop();
          event.call("end", simulation);
        }
      }

      function tick(iterations) {
        var i, n = nodes.length, node;

        if (iterations === undefined) iterations = 1;

        for (var k = 0; k < iterations; ++k) {
          alpha += (alphaTarget - alpha) * alphaDecay;

          forces.forEach(function(force) {
            force(alpha);
          });

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            if (node.fx == null) node.x += node.vx *= velocityDecay;
            else node.x = node.fx, node.vx = 0;
            if (node.fy == null) node.y += node.vy *= velocityDecay;
            else node.y = node.fy, node.vy = 0;
          }
        }

        return simulation;
      }

      function initializeNodes() {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.index = i;
          if (node.fx != null) node.x = node.fx;
          if (node.fy != null) node.y = node.fy;
          if (isNaN(node.x) || isNaN(node.y)) {
            var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
            node.x = radius * Math.cos(angle);
            node.y = radius * Math.sin(angle);
          }
          if (isNaN(node.vx) || isNaN(node.vy)) {
            node.vx = node.vy = 0;
          }
        }
      }

      function initializeForce(force) {
        if (force.initialize) force.initialize(nodes, random);
        return force;
      }

      initializeNodes();

      return simulation = {
        tick: tick,

        restart: function() {
          return stepper.restart(step), simulation;
        },

        stop: function() {
          return stepper.stop(), simulation;
        },

        nodes: function(_) {
          return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
        },

        alpha: function(_) {
          return arguments.length ? (alpha = +_, simulation) : alpha;
        },

        alphaMin: function(_) {
          return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
        },

        alphaDecay: function(_) {
          return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
        },

        alphaTarget: function(_) {
          return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
        },

        velocityDecay: function(_) {
          return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
        },

        randomSource: function(_) {
          return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
        },

        force: function(name, _) {
          return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
        },

        find: function(x, y, radius) {
          var i = 0,
              n = nodes.length,
              dx,
              dy,
              d2,
              node,
              closest;

          if (radius == null) radius = Infinity;
          else radius *= radius;

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            dx = x - node.x;
            dy = y - node.y;
            d2 = dx * dx + dy * dy;
            if (d2 < radius) closest = node, radius = d2;
          }

          return closest;
        },

        on: function(name, _) {
          return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
        }
      };
    }

    function forceManyBody() {
      var nodes,
          node,
          random,
          alpha,
          strength = constant$2(-30),
          strengths,
          distanceMin2 = 1,
          distanceMax2 = Infinity,
          theta2 = 0.81;

      function force(_) {
        var i, n = nodes.length, tree = quadtree(nodes, x, y).visitAfter(accumulate);
        for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        strengths = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
      }

      function accumulate(quad) {
        var strength = 0, q, c, weight = 0, x, y, i;

        // For internal nodes, accumulate forces from child quadrants.
        if (quad.length) {
          for (x = y = i = 0; i < 4; ++i) {
            if ((q = quad[i]) && (c = Math.abs(q.value))) {
              strength += q.value, weight += c, x += c * q.x, y += c * q.y;
            }
          }
          quad.x = x / weight;
          quad.y = y / weight;
        }

        // For leaf nodes, accumulate forces from coincident quadrants.
        else {
          q = quad;
          q.x = q.data.x;
          q.y = q.data.y;
          do strength += strengths[q.data.index];
          while (q = q.next);
        }

        quad.value = strength;
      }

      function apply(quad, x1, _, x2) {
        if (!quad.value) return true;

        var x = quad.x - node.x,
            y = quad.y - node.y,
            w = x2 - x1,
            l = x * x + y * y;

        // Apply the Barnes-Hut approximation if possible.
        // Limit forces for very close nodes; randomize direction if coincident.
        if (w * w / theta2 < l) {
          if (l < distanceMax2) {
            if (x === 0) x = jiggle(random), l += x * x;
            if (y === 0) y = jiggle(random), l += y * y;
            if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
            node.vx += x * quad.value * alpha / l;
            node.vy += y * quad.value * alpha / l;
          }
          return true;
        }

        // Otherwise, process points directly.
        else if (quad.length || l >= distanceMax2) return;

        // Limit forces for very close nodes; randomize direction if coincident.
        if (quad.data !== node || quad.next) {
          if (x === 0) x = jiggle(random), l += x * x;
          if (y === 0) y = jiggle(random), l += y * y;
          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        }

        do if (quad.data !== node) {
          w = strengths[quad.data.index] * alpha / l;
          node.vx += x * w;
          node.vy += y * w;
        } while (quad = quad.next);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : strength;
      };

      force.distanceMin = function(_) {
        return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
      };

      force.distanceMax = function(_) {
        return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
      };

      force.theta = function(_) {
        return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
      };

      return force;
    }

    function forceRadial(radius, x, y) {
      var nodes,
          strength = constant$2(0.1),
          strengths,
          radiuses;

      if (typeof radius !== "function") radius = constant$2(+radius);
      if (x == null) x = 0;
      if (y == null) y = 0;

      function force(alpha) {
        for (var i = 0, n = nodes.length; i < n; ++i) {
          var node = nodes[i],
              dx = node.x - x || 1e-6,
              dy = node.y - y || 1e-6,
              r = Math.sqrt(dx * dx + dy * dy),
              k = (radiuses[i] - r) * strengths[i] * alpha / r;
          node.vx += dx * k;
          node.vy += dy * k;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        radiuses = new Array(n);
        for (i = 0; i < n; ++i) {
          radiuses[i] = +radius(nodes[i], i, nodes);
          strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _, initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : radius;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      return force;
    }

    function forceX(x) {
      var strength = constant$2(0.1),
          nodes,
          strengths,
          xz;

      if (typeof x !== "function") x = constant$2(x == null ? 0 : +x);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        xz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : strength;
      };

      force.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : x;
      };

      return force;
    }

    function forceY(y) {
      var strength = constant$2(0.1),
          nodes,
          strengths,
          yz;

      if (typeof y !== "function") y = constant$2(y == null ? 0 : +y);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        yz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : strength;
      };

      force.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : y;
      };

      return force;
    }

    /**
     * Fuse.js v6.5.3 - Lightweight fuzzy-search (http://fusejs.io)
     *
     * Copyright (c) 2021 Kiro Risk (http://kiro.me)
     * All Rights Reserved. Apache Software License 2.0
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     */

    function isArray(value) {
      return !Array.isArray
        ? getTag(value) === '[object Array]'
        : Array.isArray(value)
    }

    // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js
    const INFINITY = 1 / 0;
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value
      }
      let result = value + '';
      return result == '0' && 1 / value == -INFINITY ? '-0' : result
    }

    function toString(value) {
      return value == null ? '' : baseToString(value)
    }

    function isString$1(value) {
      return typeof value === 'string'
    }

    function isNumber$2(value) {
      return typeof value === 'number'
    }

    // Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js
    function isBoolean$1(value) {
      return (
        value === true ||
        value === false ||
        (isObjectLike(value) && getTag(value) == '[object Boolean]')
      )
    }

    function isObject(value) {
      return typeof value === 'object'
    }

    // Checks if `value` is object-like.
    function isObjectLike(value) {
      return isObject(value) && value !== null
    }

    function isDefined(value) {
      return value !== undefined && value !== null
    }

    function isBlank(value) {
      return !value.trim().length
    }

    // Gets the `toStringTag` of `value`.
    // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js
    function getTag(value) {
      return value == null
        ? value === undefined
          ? '[object Undefined]'
          : '[object Null]'
        : Object.prototype.toString.call(value)
    }

    const EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';

    const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";

    const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) =>
      `Invalid value for key ${key}`;

    const PATTERN_LENGTH_TOO_LARGE = (max) =>
      `Pattern length exceeds max of ${max}.`;

    const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;

    const INVALID_KEY_WEIGHT_VALUE = (key) =>
      `Property 'weight' in key '${key}' must be a positive integer`;

    const hasOwn$1 = Object.prototype.hasOwnProperty;

    class KeyStore {
      constructor(keys) {
        this._keys = [];
        this._keyMap = {};

        let totalWeight = 0;

        keys.forEach((key) => {
          let obj = createKey(key);

          totalWeight += obj.weight;

          this._keys.push(obj);
          this._keyMap[obj.id] = obj;

          totalWeight += obj.weight;
        });

        // Normalize weights so that their sum is equal to 1
        this._keys.forEach((key) => {
          key.weight /= totalWeight;
        });
      }
      get(keyId) {
        return this._keyMap[keyId]
      }
      keys() {
        return this._keys
      }
      toJSON() {
        return JSON.stringify(this._keys)
      }
    }

    function createKey(key) {
      let path = null;
      let id = null;
      let src = null;
      let weight = 1;

      if (isString$1(key) || isArray(key)) {
        src = key;
        path = createKeyPath(key);
        id = createKeyId(key);
      } else {
        if (!hasOwn$1.call(key, 'name')) {
          throw new Error(MISSING_KEY_PROPERTY('name'))
        }

        const name = key.name;
        src = name;

        if (hasOwn$1.call(key, 'weight')) {
          weight = key.weight;

          if (weight <= 0) {
            throw new Error(INVALID_KEY_WEIGHT_VALUE(name))
          }
        }

        path = createKeyPath(name);
        id = createKeyId(name);
      }

      return { path, id, weight, src }
    }

    function createKeyPath(key) {
      return isArray(key) ? key : key.split('.')
    }

    function createKeyId(key) {
      return isArray(key) ? key.join('.') : key
    }

    function get$3(obj, path) {
      let list = [];
      let arr = false;

      const deepGet = (obj, path, index) => {
        if (!isDefined(obj)) {
          return
        }
        if (!path[index]) {
          // If there's no path left, we've arrived at the object we care about.
          list.push(obj);
        } else {
          let key = path[index];

          const value = obj[key];

          if (!isDefined(value)) {
            return
          }

          // If we're at the last value in the path, and if it's a string/number/bool,
          // add it to the list
          if (
            index === path.length - 1 &&
            (isString$1(value) || isNumber$2(value) || isBoolean$1(value))
          ) {
            list.push(toString(value));
          } else if (isArray(value)) {
            arr = true;
            // Search each item in the array.
            for (let i = 0, len = value.length; i < len; i += 1) {
              deepGet(value[i], path, index + 1);
            }
          } else if (path.length) {
            // An object. Recurse further.
            deepGet(value, path, index + 1);
          }
        }
      };

      // Backwards compatibility (since path used to be a string)
      deepGet(obj, isString$1(path) ? path.split('.') : path, 0);

      return arr ? list : list[0]
    }

    const MatchOptions = {
      // Whether the matches should be included in the result set. When `true`, each record in the result
      // set will include the indices of the matched characters.
      // These can consequently be used for highlighting purposes.
      includeMatches: false,
      // When `true`, the matching function will continue to the end of a search pattern even if
      // a perfect match has already been located in the string.
      findAllMatches: false,
      // Minimum number of characters that must be matched before a result is considered a match
      minMatchCharLength: 1
    };

    const BasicOptions = {
      // When `true`, the algorithm continues searching to the end of the input even if a perfect
      // match is found before the end of the same input.
      isCaseSensitive: false,
      // When true, the matching function will continue to the end of a search pattern even if
      includeScore: false,
      // List of properties that will be searched. This also supports nested properties.
      keys: [],
      // Whether to sort the result list, by score
      shouldSort: true,
      // Default sort function: sort by ascending score, ascending index
      sortFn: (a, b) =>
        a.score === b.score ? (a.idx < b.idx ? -1 : 1) : a.score < b.score ? -1 : 1
    };

    const FuzzyOptions = {
      // Approximately where in the text is the pattern expected to be found?
      location: 0,
      // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
      // (of both letters and location), a threshold of '1.0' would match anything.
      threshold: 0.6,
      // Determines how close the match must be to the fuzzy location (specified above).
      // An exact letter match which is 'distance' characters away from the fuzzy location
      // would score as a complete mismatch. A distance of '0' requires the match be at
      // the exact location specified, a threshold of '1000' would require a perfect match
      // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
      distance: 100
    };

    const AdvancedOptions = {
      // When `true`, it enables the use of unix-like search commands
      useExtendedSearch: false,
      // The get function to use when fetching an object's properties.
      // The default will search nested paths *ie foo.bar.baz*
      getFn: get$3,
      // When `true`, search will ignore `location` and `distance`, so it won't matter
      // where in the string the pattern appears.
      // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
      ignoreLocation: false,
      // When `true`, the calculation for the relevance score (used for sorting) will
      // ignore the field-length norm.
      // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
      ignoreFieldNorm: false,
      // The weight to determine how much field length norm effects scoring.
      fieldNormWeight: 1
    };

    var Config = {
      ...BasicOptions,
      ...MatchOptions,
      ...FuzzyOptions,
      ...AdvancedOptions
    };

    const SPACE = /[^ ]+/g;

    // Field-length norm: the shorter the field, the higher the weight.
    // Set to 3 decimals to reduce index size.
    function norm(weight = 1, mantissa = 3) {
      const cache = new Map();
      const m = Math.pow(10, mantissa);

      return {
        get(value) {
          const numTokens = value.match(SPACE).length;

          if (cache.has(numTokens)) {
            return cache.get(numTokens)
          }

          // Default function is 1/sqrt(x), weight makes that variable
          const norm = 1 / Math.pow(numTokens, 0.5 * weight);

          // In place of `toFixed(mantissa)`, for faster computation
          const n = parseFloat(Math.round(norm * m) / m);

          cache.set(numTokens, n);

          return n
        },
        clear() {
          cache.clear();
        }
      }
    }

    class FuseIndex {
      constructor({
        getFn = Config.getFn,
        fieldNormWeight = Config.fieldNormWeight
      } = {}) {
        this.norm = norm(fieldNormWeight, 3);
        this.getFn = getFn;
        this.isCreated = false;

        this.setIndexRecords();
      }
      setSources(docs = []) {
        this.docs = docs;
      }
      setIndexRecords(records = []) {
        this.records = records;
      }
      setKeys(keys = []) {
        this.keys = keys;
        this._keysMap = {};
        keys.forEach((key, idx) => {
          this._keysMap[key.id] = idx;
        });
      }
      create() {
        if (this.isCreated || !this.docs.length) {
          return
        }

        this.isCreated = true;

        // List is Array<String>
        if (isString$1(this.docs[0])) {
          this.docs.forEach((doc, docIndex) => {
            this._addString(doc, docIndex);
          });
        } else {
          // List is Array<Object>
          this.docs.forEach((doc, docIndex) => {
            this._addObject(doc, docIndex);
          });
        }

        this.norm.clear();
      }
      // Adds a doc to the end of the index
      add(doc) {
        const idx = this.size();

        if (isString$1(doc)) {
          this._addString(doc, idx);
        } else {
          this._addObject(doc, idx);
        }
      }
      // Removes the doc at the specified index of the index
      removeAt(idx) {
        this.records.splice(idx, 1);

        // Change ref index of every subsquent doc
        for (let i = idx, len = this.size(); i < len; i += 1) {
          this.records[i].i -= 1;
        }
      }
      getValueForItemAtKeyId(item, keyId) {
        return item[this._keysMap[keyId]]
      }
      size() {
        return this.records.length
      }
      _addString(doc, docIndex) {
        if (!isDefined(doc) || isBlank(doc)) {
          return
        }

        let record = {
          v: doc,
          i: docIndex,
          n: this.norm.get(doc)
        };

        this.records.push(record);
      }
      _addObject(doc, docIndex) {
        let record = { i: docIndex, $: {} };

        // Iterate over every key (i.e, path), and fetch the value at that key
        this.keys.forEach((key, keyIndex) => {
          // console.log(key)
          let value = this.getFn(doc, key.path);

          if (!isDefined(value)) {
            return
          }

          if (isArray(value)) {
            let subRecords = [];
            const stack = [{ nestedArrIndex: -1, value }];

            while (stack.length) {
              const { nestedArrIndex, value } = stack.pop();

              if (!isDefined(value)) {
                continue
              }

              if (isString$1(value) && !isBlank(value)) {
                let subRecord = {
                  v: value,
                  i: nestedArrIndex,
                  n: this.norm.get(value)
                };

                subRecords.push(subRecord);
              } else if (isArray(value)) {
                value.forEach((item, k) => {
                  stack.push({
                    nestedArrIndex: k,
                    value: item
                  });
                });
              } else ;
            }
            record.$[keyIndex] = subRecords;
          } else if (!isBlank(value)) {
            let subRecord = {
              v: value,
              n: this.norm.get(value)
            };

            record.$[keyIndex] = subRecord;
          }
        });

        this.records.push(record);
      }
      toJSON() {
        return {
          keys: this.keys,
          records: this.records
        }
      }
    }

    function createIndex(
      keys,
      docs,
      { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}
    ) {
      const myIndex = new FuseIndex({ getFn, fieldNormWeight });
      myIndex.setKeys(keys.map(createKey));
      myIndex.setSources(docs);
      myIndex.create();
      return myIndex
    }

    function parseIndex(
      data,
      { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}
    ) {
      const { keys, records } = data;
      const myIndex = new FuseIndex({ getFn, fieldNormWeight });
      myIndex.setKeys(keys);
      myIndex.setIndexRecords(records);
      return myIndex
    }

    function computeScore$1(
      pattern,
      {
        errors = 0,
        currentLocation = 0,
        expectedLocation = 0,
        distance = Config.distance,
        ignoreLocation = Config.ignoreLocation
      } = {}
    ) {
      const accuracy = errors / pattern.length;

      if (ignoreLocation) {
        return accuracy
      }

      const proximity = Math.abs(expectedLocation - currentLocation);

      if (!distance) {
        // Dodge divide by zero error.
        return proximity ? 1.0 : accuracy
      }

      return accuracy + proximity / distance
    }

    function convertMaskToIndices(
      matchmask = [],
      minMatchCharLength = Config.minMatchCharLength
    ) {
      let indices = [];
      let start = -1;
      let end = -1;
      let i = 0;

      for (let len = matchmask.length; i < len; i += 1) {
        let match = matchmask[i];
        if (match && start === -1) {
          start = i;
        } else if (!match && start !== -1) {
          end = i - 1;
          if (end - start + 1 >= minMatchCharLength) {
            indices.push([start, end]);
          }
          start = -1;
        }
      }

      // (i-1 - start) + 1 => i - start
      if (matchmask[i - 1] && i - start >= minMatchCharLength) {
        indices.push([start, i - 1]);
      }

      return indices
    }

    // Machine word size
    const MAX_BITS = 32;

    function search(
      text,
      pattern,
      patternAlphabet,
      {
        location = Config.location,
        distance = Config.distance,
        threshold = Config.threshold,
        findAllMatches = Config.findAllMatches,
        minMatchCharLength = Config.minMatchCharLength,
        includeMatches = Config.includeMatches,
        ignoreLocation = Config.ignoreLocation
      } = {}
    ) {
      if (pattern.length > MAX_BITS) {
        throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS))
      }

      const patternLen = pattern.length;
      // Set starting location at beginning text and initialize the alphabet.
      const textLen = text.length;
      // Handle the case when location > text.length
      const expectedLocation = Math.max(0, Math.min(location, textLen));
      // Highest score beyond which we give up.
      let currentThreshold = threshold;
      // Is there a nearby exact match? (speedup)
      let bestLocation = expectedLocation;

      // Performance: only computer matches when the minMatchCharLength > 1
      // OR if `includeMatches` is true.
      const computeMatches = minMatchCharLength > 1 || includeMatches;
      // A mask of the matches, used for building the indices
      const matchMask = computeMatches ? Array(textLen) : [];

      let index;

      // Get all exact matches, here for speed up
      while ((index = text.indexOf(pattern, bestLocation)) > -1) {
        let score = computeScore$1(pattern, {
          currentLocation: index,
          expectedLocation,
          distance,
          ignoreLocation
        });

        currentThreshold = Math.min(score, currentThreshold);
        bestLocation = index + patternLen;

        if (computeMatches) {
          let i = 0;
          while (i < patternLen) {
            matchMask[index + i] = 1;
            i += 1;
          }
        }
      }

      // Reset the best location
      bestLocation = -1;

      let lastBitArr = [];
      let finalScore = 1;
      let binMax = patternLen + textLen;

      const mask = 1 << (patternLen - 1);

      for (let i = 0; i < patternLen; i += 1) {
        // Scan for the best match; each iteration allows for one more error.
        // Run a binary search to determine how far from the match location we can stray
        // at this error level.
        let binMin = 0;
        let binMid = binMax;

        while (binMin < binMid) {
          const score = computeScore$1(pattern, {
            errors: i,
            currentLocation: expectedLocation + binMid,
            expectedLocation,
            distance,
            ignoreLocation
          });

          if (score <= currentThreshold) {
            binMin = binMid;
          } else {
            binMax = binMid;
          }

          binMid = Math.floor((binMax - binMin) / 2 + binMin);
        }

        // Use the result from this iteration as the maximum for the next.
        binMax = binMid;

        let start = Math.max(1, expectedLocation - binMid + 1);
        let finish = findAllMatches
          ? textLen
          : Math.min(expectedLocation + binMid, textLen) + patternLen;

        // Initialize the bit array
        let bitArr = Array(finish + 2);

        bitArr[finish + 1] = (1 << i) - 1;

        for (let j = finish; j >= start; j -= 1) {
          let currentLocation = j - 1;
          let charMatch = patternAlphabet[text.charAt(currentLocation)];

          if (computeMatches) {
            // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)
            matchMask[currentLocation] = +!!charMatch;
          }

          // First pass: exact match
          bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;

          // Subsequent passes: fuzzy match
          if (i) {
            bitArr[j] |=
              ((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1 | lastBitArr[j + 1];
          }

          if (bitArr[j] & mask) {
            finalScore = computeScore$1(pattern, {
              errors: i,
              currentLocation,
              expectedLocation,
              distance,
              ignoreLocation
            });

            // This match will almost certainly be better than any existing match.
            // But check anyway.
            if (finalScore <= currentThreshold) {
              // Indeed it is
              currentThreshold = finalScore;
              bestLocation = currentLocation;

              // Already passed `loc`, downhill from here on in.
              if (bestLocation <= expectedLocation) {
                break
              }

              // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.
              start = Math.max(1, 2 * expectedLocation - bestLocation);
            }
          }
        }

        // No hope for a (better) match at greater error levels.
        const score = computeScore$1(pattern, {
          errors: i + 1,
          currentLocation: expectedLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });

        if (score > currentThreshold) {
          break
        }

        lastBitArr = bitArr;
      }

      const result = {
        isMatch: bestLocation >= 0,
        // Count exact matches (those with a score of 0) to be "almost" exact
        score: Math.max(0.001, finalScore)
      };

      if (computeMatches) {
        const indices = convertMaskToIndices(matchMask, minMatchCharLength);
        if (!indices.length) {
          result.isMatch = false;
        } else if (includeMatches) {
          result.indices = indices;
        }
      }

      return result
    }

    function createPatternAlphabet(pattern) {
      let mask = {};

      for (let i = 0, len = pattern.length; i < len; i += 1) {
        const char = pattern.charAt(i);
        mask[char] = (mask[char] || 0) | (1 << (len - i - 1));
      }

      return mask
    }

    class BitapSearch {
      constructor(
        pattern,
        {
          location = Config.location,
          threshold = Config.threshold,
          distance = Config.distance,
          includeMatches = Config.includeMatches,
          findAllMatches = Config.findAllMatches,
          minMatchCharLength = Config.minMatchCharLength,
          isCaseSensitive = Config.isCaseSensitive,
          ignoreLocation = Config.ignoreLocation
        } = {}
      ) {
        this.options = {
          location,
          threshold,
          distance,
          includeMatches,
          findAllMatches,
          minMatchCharLength,
          isCaseSensitive,
          ignoreLocation
        };

        this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();

        this.chunks = [];

        if (!this.pattern.length) {
          return
        }

        const addChunk = (pattern, startIndex) => {
          this.chunks.push({
            pattern,
            alphabet: createPatternAlphabet(pattern),
            startIndex
          });
        };

        const len = this.pattern.length;

        if (len > MAX_BITS) {
          let i = 0;
          const remainder = len % MAX_BITS;
          const end = len - remainder;

          while (i < end) {
            addChunk(this.pattern.substr(i, MAX_BITS), i);
            i += MAX_BITS;
          }

          if (remainder) {
            const startIndex = len - MAX_BITS;
            addChunk(this.pattern.substr(startIndex), startIndex);
          }
        } else {
          addChunk(this.pattern, 0);
        }
      }

      searchIn(text) {
        const { isCaseSensitive, includeMatches } = this.options;

        if (!isCaseSensitive) {
          text = text.toLowerCase();
        }

        // Exact match
        if (this.pattern === text) {
          let result = {
            isMatch: true,
            score: 0
          };

          if (includeMatches) {
            result.indices = [[0, text.length - 1]];
          }

          return result
        }

        // Otherwise, use Bitap algorithm
        const {
          location,
          distance,
          threshold,
          findAllMatches,
          minMatchCharLength,
          ignoreLocation
        } = this.options;

        let allIndices = [];
        let totalScore = 0;
        let hasMatches = false;

        this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
          const { isMatch, score, indices } = search(text, pattern, alphabet, {
            location: location + startIndex,
            distance,
            threshold,
            findAllMatches,
            minMatchCharLength,
            includeMatches,
            ignoreLocation
          });

          if (isMatch) {
            hasMatches = true;
          }

          totalScore += score;

          if (isMatch && indices) {
            allIndices = [...allIndices, ...indices];
          }
        });

        let result = {
          isMatch: hasMatches,
          score: hasMatches ? totalScore / this.chunks.length : 1
        };

        if (hasMatches && includeMatches) {
          result.indices = allIndices;
        }

        return result
      }
    }

    class BaseMatch {
      constructor(pattern) {
        this.pattern = pattern;
      }
      static isMultiMatch(pattern) {
        return getMatch(pattern, this.multiRegex)
      }
      static isSingleMatch(pattern) {
        return getMatch(pattern, this.singleRegex)
      }
      search(/*text*/) {}
    }

    function getMatch(pattern, exp) {
      const matches = pattern.match(exp);
      return matches ? matches[1] : null
    }

    // Token: 'file

    class ExactMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'exact'
      }
      static get multiRegex() {
        return /^="(.*)"$/
      }
      static get singleRegex() {
        return /^=(.*)$/
      }
      search(text) {
        const isMatch = text === this.pattern;

        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, this.pattern.length - 1]
        }
      }
    }

    // Token: !fire

    class InverseExactMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'inverse-exact'
      }
      static get multiRegex() {
        return /^!"(.*)"$/
      }
      static get singleRegex() {
        return /^!(.*)$/
      }
      search(text) {
        const index = text.indexOf(this.pattern);
        const isMatch = index === -1;

        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        }
      }
    }

    // Token: ^file

    class PrefixExactMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'prefix-exact'
      }
      static get multiRegex() {
        return /^\^"(.*)"$/
      }
      static get singleRegex() {
        return /^\^(.*)$/
      }
      search(text) {
        const isMatch = text.startsWith(this.pattern);

        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, this.pattern.length - 1]
        }
      }
    }

    // Token: !^fire

    class InversePrefixExactMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'inverse-prefix-exact'
      }
      static get multiRegex() {
        return /^!\^"(.*)"$/
      }
      static get singleRegex() {
        return /^!\^(.*)$/
      }
      search(text) {
        const isMatch = !text.startsWith(this.pattern);

        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        }
      }
    }

    // Token: .file$

    class SuffixExactMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'suffix-exact'
      }
      static get multiRegex() {
        return /^"(.*)"\$$/
      }
      static get singleRegex() {
        return /^(.*)\$$/
      }
      search(text) {
        const isMatch = text.endsWith(this.pattern);

        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices: [text.length - this.pattern.length, text.length - 1]
        }
      }
    }

    // Token: !.file$

    class InverseSuffixExactMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'inverse-suffix-exact'
      }
      static get multiRegex() {
        return /^!"(.*)"\$$/
      }
      static get singleRegex() {
        return /^!(.*)\$$/
      }
      search(text) {
        const isMatch = !text.endsWith(this.pattern);
        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        }
      }
    }

    class FuzzyMatch extends BaseMatch {
      constructor(
        pattern,
        {
          location = Config.location,
          threshold = Config.threshold,
          distance = Config.distance,
          includeMatches = Config.includeMatches,
          findAllMatches = Config.findAllMatches,
          minMatchCharLength = Config.minMatchCharLength,
          isCaseSensitive = Config.isCaseSensitive,
          ignoreLocation = Config.ignoreLocation
        } = {}
      ) {
        super(pattern);
        this._bitapSearch = new BitapSearch(pattern, {
          location,
          threshold,
          distance,
          includeMatches,
          findAllMatches,
          minMatchCharLength,
          isCaseSensitive,
          ignoreLocation
        });
      }
      static get type() {
        return 'fuzzy'
      }
      static get multiRegex() {
        return /^"(.*)"$/
      }
      static get singleRegex() {
        return /^(.*)$/
      }
      search(text) {
        return this._bitapSearch.searchIn(text)
      }
    }

    // Token: 'file

    class IncludeMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'include'
      }
      static get multiRegex() {
        return /^'"(.*)"$/
      }
      static get singleRegex() {
        return /^'(.*)$/
      }
      search(text) {
        let location = 0;
        let index;

        const indices = [];
        const patternLen = this.pattern.length;

        // Get all exact matches
        while ((index = text.indexOf(this.pattern, location)) > -1) {
          location = index + patternLen;
          indices.push([index, location - 1]);
        }

        const isMatch = !!indices.length;

        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices
        }
      }
    }

    // ❗Order is important. DO NOT CHANGE.
    const searchers = [
      ExactMatch,
      IncludeMatch,
      PrefixExactMatch,
      InversePrefixExactMatch,
      InverseSuffixExactMatch,
      SuffixExactMatch,
      InverseExactMatch,
      FuzzyMatch
    ];

    const searchersLen = searchers.length;

    // Regex to split by spaces, but keep anything in quotes together
    const SPACE_RE = / +(?=([^\"]*\"[^\"]*\")*[^\"]*$)/;
    const OR_TOKEN = '|';

    // Return a 2D array representation of the query, for simpler parsing.
    // Example:
    // "^core go$ | rb$ | py$ xy$" => [["^core", "go$"], ["rb$"], ["py$", "xy$"]]
    function parseQuery(pattern, options = {}) {
      return pattern.split(OR_TOKEN).map((item) => {
        let query = item
          .trim()
          .split(SPACE_RE)
          .filter((item) => item && !!item.trim());

        let results = [];
        for (let i = 0, len = query.length; i < len; i += 1) {
          const queryItem = query[i];

          // 1. Handle multiple query match (i.e, once that are quoted, like `"hello world"`)
          let found = false;
          let idx = -1;
          while (!found && ++idx < searchersLen) {
            const searcher = searchers[idx];
            let token = searcher.isMultiMatch(queryItem);
            if (token) {
              results.push(new searcher(token, options));
              found = true;
            }
          }

          if (found) {
            continue
          }

          // 2. Handle single query matches (i.e, once that are *not* quoted)
          idx = -1;
          while (++idx < searchersLen) {
            const searcher = searchers[idx];
            let token = searcher.isSingleMatch(queryItem);
            if (token) {
              results.push(new searcher(token, options));
              break
            }
          }
        }

        return results
      })
    }

    // These extended matchers can return an array of matches, as opposed
    // to a singl match
    const MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);

    /**
     * Command-like searching
     * ======================
     *
     * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,
     * search in a given text.
     *
     * Search syntax:
     *
     * | Token       | Match type                 | Description                            |
     * | ----------- | -------------------------- | -------------------------------------- |
     * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |
     * | `=scheme`   | exact-match                | Items that are `scheme`                |
     * | `'python`   | include-match              | Items that include `python`            |
     * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |
     * | `^java`     | prefix-exact-match         | Items that start with `java`           |
     * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |
     * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |
     * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |
     *
     * A single pipe character acts as an OR operator. For example, the following
     * query matches entries that start with `core` and end with either`go`, `rb`,
     * or`py`.
     *
     * ```
     * ^core go$ | rb$ | py$
     * ```
     */
    class ExtendedSearch {
      constructor(
        pattern,
        {
          isCaseSensitive = Config.isCaseSensitive,
          includeMatches = Config.includeMatches,
          minMatchCharLength = Config.minMatchCharLength,
          ignoreLocation = Config.ignoreLocation,
          findAllMatches = Config.findAllMatches,
          location = Config.location,
          threshold = Config.threshold,
          distance = Config.distance
        } = {}
      ) {
        this.query = null;
        this.options = {
          isCaseSensitive,
          includeMatches,
          minMatchCharLength,
          findAllMatches,
          ignoreLocation,
          location,
          threshold,
          distance
        };

        this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
        this.query = parseQuery(this.pattern, this.options);
      }

      static condition(_, options) {
        return options.useExtendedSearch
      }

      searchIn(text) {
        const query = this.query;

        if (!query) {
          return {
            isMatch: false,
            score: 1
          }
        }

        const { includeMatches, isCaseSensitive } = this.options;

        text = isCaseSensitive ? text : text.toLowerCase();

        let numMatches = 0;
        let allIndices = [];
        let totalScore = 0;

        // ORs
        for (let i = 0, qLen = query.length; i < qLen; i += 1) {
          const searchers = query[i];

          // Reset indices
          allIndices.length = 0;
          numMatches = 0;

          // ANDs
          for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {
            const searcher = searchers[j];
            const { isMatch, indices, score } = searcher.search(text);

            if (isMatch) {
              numMatches += 1;
              totalScore += score;
              if (includeMatches) {
                const type = searcher.constructor.type;
                if (MultiMatchSet.has(type)) {
                  allIndices = [...allIndices, ...indices];
                } else {
                  allIndices.push(indices);
                }
              }
            } else {
              totalScore = 0;
              numMatches = 0;
              allIndices.length = 0;
              break
            }
          }

          // OR condition, so if TRUE, return
          if (numMatches) {
            let result = {
              isMatch: true,
              score: totalScore / numMatches
            };

            if (includeMatches) {
              result.indices = allIndices;
            }

            return result
          }
        }

        // Nothing was matched
        return {
          isMatch: false,
          score: 1
        }
      }
    }

    const registeredSearchers = [];

    function register(...args) {
      registeredSearchers.push(...args);
    }

    function createSearcher(pattern, options) {
      for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
        let searcherClass = registeredSearchers[i];
        if (searcherClass.condition(pattern, options)) {
          return new searcherClass(pattern, options)
        }
      }

      return new BitapSearch(pattern, options)
    }

    const LogicalOperator = {
      AND: '$and',
      OR: '$or'
    };

    const KeyType = {
      PATH: '$path',
      PATTERN: '$val'
    };

    const isExpression = (query) =>
      !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);

    const isPath = (query) => !!query[KeyType.PATH];

    const isLeaf = (query) =>
      !isArray(query) && isObject(query) && !isExpression(query);

    const convertToExplicit = (query) => ({
      [LogicalOperator.AND]: Object.keys(query).map((key) => ({
        [key]: query[key]
      }))
    });

    // When `auto` is `true`, the parse function will infer and initialize and add
    // the appropriate `Searcher` instance
    function parse$1(query, options, { auto = true } = {}) {
      const next = (query) => {
        let keys = Object.keys(query);

        const isQueryPath = isPath(query);

        if (!isQueryPath && keys.length > 1 && !isExpression(query)) {
          return next(convertToExplicit(query))
        }

        if (isLeaf(query)) {
          const key = isQueryPath ? query[KeyType.PATH] : keys[0];

          const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];

          if (!isString$1(pattern)) {
            throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key))
          }

          const obj = {
            keyId: createKeyId(key),
            pattern
          };

          if (auto) {
            obj.searcher = createSearcher(pattern, options);
          }

          return obj
        }

        let node = {
          children: [],
          operator: keys[0]
        };

        keys.forEach((key) => {
          const value = query[key];

          if (isArray(value)) {
            value.forEach((item) => {
              node.children.push(next(item));
            });
          }
        });

        return node
      };

      if (!isExpression(query)) {
        query = convertToExplicit(query);
      }

      return next(query)
    }

    // Practical scoring function
    function computeScore(
      results,
      { ignoreFieldNorm = Config.ignoreFieldNorm }
    ) {
      results.forEach((result) => {
        let totalScore = 1;

        result.matches.forEach(({ key, norm, score }) => {
          const weight = key ? key.weight : null;

          totalScore *= Math.pow(
            score === 0 && weight ? Number.EPSILON : score,
            (weight || 1) * (ignoreFieldNorm ? 1 : norm)
          );
        });

        result.score = totalScore;
      });
    }

    function transformMatches(result, data) {
      const matches = result.matches;
      data.matches = [];

      if (!isDefined(matches)) {
        return
      }

      matches.forEach((match) => {
        if (!isDefined(match.indices) || !match.indices.length) {
          return
        }

        const { indices, value } = match;

        let obj = {
          indices,
          value
        };

        if (match.key) {
          obj.key = match.key.src;
        }

        if (match.idx > -1) {
          obj.refIndex = match.idx;
        }

        data.matches.push(obj);
      });
    }

    function transformScore(result, data) {
      data.score = result.score;
    }

    function format(
      results,
      docs,
      {
        includeMatches = Config.includeMatches,
        includeScore = Config.includeScore
      } = {}
    ) {
      const transformers = [];

      if (includeMatches) transformers.push(transformMatches);
      if (includeScore) transformers.push(transformScore);

      return results.map((result) => {
        const { idx } = result;

        const data = {
          item: docs[idx],
          refIndex: idx
        };

        if (transformers.length) {
          transformers.forEach((transformer) => {
            transformer(result, data);
          });
        }

        return data
      })
    }

    class Fuse {
      constructor(docs, options = {}, index) {
        this.options = { ...Config, ...options };

        if (
          this.options.useExtendedSearch &&
          !true
        ) {
          throw new Error(EXTENDED_SEARCH_UNAVAILABLE)
        }

        this._keyStore = new KeyStore(this.options.keys);

        this.setCollection(docs, index);
      }

      setCollection(docs, index) {
        this._docs = docs;

        if (index && !(index instanceof FuseIndex)) {
          throw new Error(INCORRECT_INDEX_TYPE)
        }

        this._myIndex =
          index ||
          createIndex(this.options.keys, this._docs, {
            getFn: this.options.getFn,
            fieldNormWeight: this.options.fieldNormWeight
          });
      }

      add(doc) {
        if (!isDefined(doc)) {
          return
        }

        this._docs.push(doc);
        this._myIndex.add(doc);
      }

      remove(predicate = (/* doc, idx */) => false) {
        const results = [];

        for (let i = 0, len = this._docs.length; i < len; i += 1) {
          const doc = this._docs[i];
          if (predicate(doc, i)) {
            this.removeAt(i);
            i -= 1;
            len -= 1;

            results.push(doc);
          }
        }

        return results
      }

      removeAt(idx) {
        this._docs.splice(idx, 1);
        this._myIndex.removeAt(idx);
      }

      getIndex() {
        return this._myIndex
      }

      search(query, { limit = -1 } = {}) {
        const {
          includeMatches,
          includeScore,
          shouldSort,
          sortFn,
          ignoreFieldNorm
        } = this.options;

        let results = isString$1(query)
          ? isString$1(this._docs[0])
            ? this._searchStringList(query)
            : this._searchObjectList(query)
          : this._searchLogical(query);

        computeScore(results, { ignoreFieldNorm });

        if (shouldSort) {
          results.sort(sortFn);
        }

        if (isNumber$2(limit) && limit > -1) {
          results = results.slice(0, limit);
        }

        return format(results, this._docs, {
          includeMatches,
          includeScore
        })
      }

      _searchStringList(query) {
        const searcher = createSearcher(query, this.options);
        const { records } = this._myIndex;
        const results = [];

        // Iterate over every string in the index
        records.forEach(({ v: text, i: idx, n: norm }) => {
          if (!isDefined(text)) {
            return
          }

          const { isMatch, score, indices } = searcher.searchIn(text);

          if (isMatch) {
            results.push({
              item: text,
              idx,
              matches: [{ score, value: text, norm, indices }]
            });
          }
        });

        return results
      }

      _searchLogical(query) {

        const expression = parse$1(query, this.options);

        const evaluate = (node, item, idx) => {
          if (!node.children) {
            const { keyId, searcher } = node;

            const matches = this._findMatches({
              key: this._keyStore.get(keyId),
              value: this._myIndex.getValueForItemAtKeyId(item, keyId),
              searcher
            });

            if (matches && matches.length) {
              return [
                {
                  idx,
                  item,
                  matches
                }
              ]
            }

            return []
          }

          const res = [];
          for (let i = 0, len = node.children.length; i < len; i += 1) {
            const child = node.children[i];
            const result = evaluate(child, item, idx);
            if (result.length) {
              res.push(...result);
            } else if (node.operator === LogicalOperator.AND) {
              return []
            }
          }
          return res
        };

        const records = this._myIndex.records;
        const resultMap = {};
        const results = [];

        records.forEach(({ $: item, i: idx }) => {
          if (isDefined(item)) {
            let expResults = evaluate(expression, item, idx);

            if (expResults.length) {
              // Dedupe when adding
              if (!resultMap[idx]) {
                resultMap[idx] = { idx, item, matches: [] };
                results.push(resultMap[idx]);
              }
              expResults.forEach(({ matches }) => {
                resultMap[idx].matches.push(...matches);
              });
            }
          }
        });

        return results
      }

      _searchObjectList(query) {
        const searcher = createSearcher(query, this.options);
        const { keys, records } = this._myIndex;
        const results = [];

        // List is Array<Object>
        records.forEach(({ $: item, i: idx }) => {
          if (!isDefined(item)) {
            return
          }

          let matches = [];

          // Iterate over every key (i.e, path), and fetch the value at that key
          keys.forEach((key, keyIndex) => {
            matches.push(
              ...this._findMatches({
                key,
                value: item[keyIndex],
                searcher
              })
            );
          });

          if (matches.length) {
            results.push({
              idx,
              item,
              matches
            });
          }
        });

        return results
      }
      _findMatches({ key, value, searcher }) {
        if (!isDefined(value)) {
          return []
        }

        let matches = [];

        if (isArray(value)) {
          value.forEach(({ v: text, i: idx, n: norm }) => {
            if (!isDefined(text)) {
              return
            }

            const { isMatch, score, indices } = searcher.searchIn(text);

            if (isMatch) {
              matches.push({
                score,
                key,
                value: text,
                idx,
                norm,
                indices
              });
            }
          });
        } else {
          const { v: text, n: norm } = value;

          const { isMatch, score, indices } = searcher.searchIn(text);

          if (isMatch) {
            matches.push({ score, key, value: text, norm, indices });
          }
        }

        return matches
      }
    }

    Fuse.version = '6.5.3';
    Fuse.createIndex = createIndex;
    Fuse.parseIndex = parseIndex;
    Fuse.config = Config;

    {
      Fuse.parseQuery = parse$1;
    }

    {
      register(ExtendedSearch);
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function getAugmentedNamespace(n) {
    	if (n.__esModule) return n;
    	var a = Object.defineProperty({}, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    var wheel$1 = {exports: {}};

    /**
     * This module used to unify mouse wheel behavior between different browsers in 2014
     * Now it's just a wrapper around addEventListener('wheel');
     *
     * Usage:
     *  var addWheelListener = require('wheel').addWheelListener;
     *  var removeWheelListener = require('wheel').removeWheelListener;
     *  addWheelListener(domElement, function (e) {
     *    // mouse wheel event
     *  });
     *  removeWheelListener(domElement, function);
     */

    wheel$1.exports = addWheelListener;

    // But also expose "advanced" api with unsubscribe:
    wheel$1.exports.addWheelListener = addWheelListener;
    wheel$1.exports.removeWheelListener = removeWheelListener;


    function addWheelListener(element, listener, useCapture) {
      element.addEventListener('wheel', listener, useCapture);
    }

    function removeWheelListener( element, listener, useCapture ) {
      element.removeEventListener('wheel', listener, useCapture);
    }

    var amator = {exports: {}};

    /**
     * https://github.com/gre/bezier-easing
     * BezierEasing - use bezier curve for transition easing function
     * by Gaëtan Renaudeau 2014 - 2015 – MIT License
     */

    // These values are established by empiricism with tests (tradeoff: performance VS precision)
    var NEWTON_ITERATIONS = 4;
    var NEWTON_MIN_SLOPE = 0.001;
    var SUBDIVISION_PRECISION = 0.0000001;
    var SUBDIVISION_MAX_ITERATIONS = 10;

    var kSplineTableSize = 11;
    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

    var float32ArraySupported = typeof Float32Array === 'function';

    function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
    function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
    function C (aA1)      { return 3.0 * aA1; }

    // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
    function calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }

    // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
    function getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }

    function binarySubdivide (aX, aA, aB, mX1, mX2) {
      var currentX, currentT, i = 0;
      do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0.0) {
          aB = currentT;
        } else {
          aA = currentT;
        }
      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
      return currentT;
    }

    function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
     for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
       var currentSlope = getSlope(aGuessT, mX1, mX2);
       if (currentSlope === 0.0) {
         return aGuessT;
       }
       var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
       aGuessT -= currentX / currentSlope;
     }
     return aGuessT;
    }

    function LinearEasing (x) {
      return x;
    }

    var src$1 = function bezier (mX1, mY1, mX2, mY2) {
      if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
        throw new Error('bezier x values must be in [0, 1] range');
      }

      if (mX1 === mY1 && mX2 === mY2) {
        return LinearEasing;
      }

      // Precompute samples table
      var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }

      function getTForX (aX) {
        var intervalStart = 0.0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;

        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
          intervalStart += kSampleStepSize;
        }
        --currentSample;

        // Interpolate to provide an initial guess for t
        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;

        var initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
          return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        } else if (initialSlope === 0.0) {
          return guessForT;
        } else {
          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
      }

      return function BezierEasing (x) {
        // Because JavaScript number are imprecise, we should guarantee the extremes are right.
        if (x === 0) {
          return 0;
        }
        if (x === 1) {
          return 1;
        }
        return calcBezier(getTForX(x), mY1, mY2);
      };
    };

    var BezierEasing = src$1;

    // Predefined set of animations. Similar to CSS easing functions
    var animations = {
      ease:  BezierEasing(0.25, 0.1, 0.25, 1),
      easeIn: BezierEasing(0.42, 0, 1, 1),
      easeOut: BezierEasing(0, 0, 0.58, 1),
      easeInOut: BezierEasing(0.42, 0, 0.58, 1),
      linear: BezierEasing(0, 0, 1, 1)
    };


    amator.exports = animate$1;
    amator.exports.makeAggregateRaf = makeAggregateRaf;
    amator.exports.sharedScheduler = makeAggregateRaf();


    function animate$1(source, target, options) {
      var start = Object.create(null);
      var diff = Object.create(null);
      options = options || {};
      // We let clients specify their own easing function
      var easing = (typeof options.easing === 'function') ? options.easing : animations[options.easing];

      // if nothing is specified, default to ease (similar to CSS animations)
      if (!easing) {
        if (options.easing) {
          console.warn('Unknown easing function in amator: ' + options.easing);
        }
        easing = animations.ease;
      }

      var step = typeof options.step === 'function' ? options.step : noop$2;
      var done = typeof options.done === 'function' ? options.done : noop$2;

      var scheduler = getScheduler(options.scheduler);

      var keys = Object.keys(target);
      keys.forEach(function(key) {
        start[key] = source[key];
        diff[key] = target[key] - source[key];
      });

      var durationInMs = typeof options.duration === 'number' ? options.duration : 400;
      var durationInFrames = Math.max(1, durationInMs * 0.06); // 0.06 because 60 frames pers 1,000 ms
      var previousAnimationId;
      var frame = 0;

      previousAnimationId = scheduler.next(loop);

      return {
        cancel: cancel
      }

      function cancel() {
        scheduler.cancel(previousAnimationId);
        previousAnimationId = 0;
      }

      function loop() {
        var t = easing(frame/durationInFrames);
        frame += 1;
        setValues(t);
        if (frame <= durationInFrames) {
          previousAnimationId = scheduler.next(loop);
          step(source);
        } else {
          previousAnimationId = 0;
          setTimeout(function() { done(source); }, 0);
        }
      }

      function setValues(t) {
        keys.forEach(function(key) {
          source[key] = diff[key] * t + start[key];
        });
      }
    }

    function noop$2() { }

    function getScheduler(scheduler) {
      if (!scheduler) {
        var canRaf = typeof window !== 'undefined' && window.requestAnimationFrame;
        return canRaf ? rafScheduler() : timeoutScheduler()
      }
      if (typeof scheduler.next !== 'function') throw new Error('Scheduler is supposed to have next(cb) function')
      if (typeof scheduler.cancel !== 'function') throw new Error('Scheduler is supposed to have cancel(handle) function')

      return scheduler
    }

    function rafScheduler() {
      return {
        next: window.requestAnimationFrame.bind(window),
        cancel: window.cancelAnimationFrame.bind(window)
      }
    }

    function timeoutScheduler() {
      return {
        next: function(cb) {
          return setTimeout(cb, 1000/60)
        },
        cancel: function (id) {
          return clearTimeout(id)
        }
      }
    }

    function makeAggregateRaf() {
      var frontBuffer = new Set();
      var backBuffer = new Set();
      var frameToken = 0;

      return {
        next: next,
        cancel: next,
        clearAll: clearAll
      }

      function clearAll() {
        frontBuffer.clear();
        backBuffer.clear();
        cancelAnimationFrame(frameToken);
        frameToken = 0;
      }

      function next(callback) {
        backBuffer.add(callback);
        renderNextFrame();
      }

      function renderNextFrame() {
        if (!frameToken) frameToken = requestAnimationFrame(renderFrame);
      }

      function renderFrame() {
        frameToken = 0;

        var t = backBuffer;
        backBuffer = frontBuffer;
        frontBuffer = t;

        frontBuffer.forEach(function(callback) {
          callback();
        });
        frontBuffer.clear();
      }
    }

    var ngraph_events = function eventify(subject) {
      validateSubject(subject);

      var eventsStorage = createEventsStorage(subject);
      subject.on = eventsStorage.on;
      subject.off = eventsStorage.off;
      subject.fire = eventsStorage.fire;
      return subject;
    };

    function createEventsStorage(subject) {
      // Store all event listeners to this hash. Key is event name, value is array
      // of callback records.
      //
      // A callback record consists of callback function and its optional context:
      // { 'eventName' => [{callback: function, ctx: object}] }
      var registeredEvents = Object.create(null);

      return {
        on: function (eventName, callback, ctx) {
          if (typeof callback !== 'function') {
            throw new Error('callback is expected to be a function');
          }
          var handlers = registeredEvents[eventName];
          if (!handlers) {
            handlers = registeredEvents[eventName] = [];
          }
          handlers.push({callback: callback, ctx: ctx});

          return subject;
        },

        off: function (eventName, callback) {
          var wantToRemoveAll = (typeof eventName === 'undefined');
          if (wantToRemoveAll) {
            // Killing old events storage should be enough in this case:
            registeredEvents = Object.create(null);
            return subject;
          }

          if (registeredEvents[eventName]) {
            var deleteAllCallbacksForEvent = (typeof callback !== 'function');
            if (deleteAllCallbacksForEvent) {
              delete registeredEvents[eventName];
            } else {
              var callbacks = registeredEvents[eventName];
              for (var i = 0; i < callbacks.length; ++i) {
                if (callbacks[i].callback === callback) {
                  callbacks.splice(i, 1);
                }
              }
            }
          }

          return subject;
        },

        fire: function (eventName) {
          var callbacks = registeredEvents[eventName];
          if (!callbacks) {
            return subject;
          }

          var fireArguments;
          if (arguments.length > 1) {
            fireArguments = Array.prototype.splice.call(arguments, 1);
          }
          for(var i = 0; i < callbacks.length; ++i) {
            var callbackInfo = callbacks[i];
            callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);
          }

          return subject;
        }
      };
    }

    function validateSubject(subject) {
      if (!subject) {
        throw new Error('Eventify cannot use falsy object as events subject');
      }
      var reservedWords = ['on', 'fire', 'off'];
      for (var i = 0; i < reservedWords.length; ++i) {
        if (subject.hasOwnProperty(reservedWords[i])) {
          throw new Error("Subject cannot be eventified, since it already has property '" + reservedWords[i] + "'");
        }
      }
    }

    /**
     * Allows smooth kinetic scrolling of the surface
     */

    var kinetic_1 = kinetic$1;

    function kinetic$1(getPoint, scroll, settings) {
      if (typeof settings !== 'object') {
        // setting could come as boolean, we should ignore it, and use an object.
        settings = {};
      }

      var minVelocity = typeof settings.minVelocity === 'number' ? settings.minVelocity : 5;
      var amplitude = typeof settings.amplitude === 'number' ? settings.amplitude : 0.25;
      var cancelAnimationFrame = typeof settings.cancelAnimationFrame === 'function' ? settings.cancelAnimationFrame : getCancelAnimationFrame();
      var requestAnimationFrame = typeof settings.requestAnimationFrame === 'function' ? settings.requestAnimationFrame : getRequestAnimationFrame();

      var lastPoint;
      var timestamp;
      var timeConstant = 342;

      var ticker;
      var vx, targetX, ax;
      var vy, targetY, ay;

      var raf;

      return {
        start: start,
        stop: stop,
        cancel: dispose
      };

      function dispose() {
        cancelAnimationFrame(ticker);
        cancelAnimationFrame(raf);
      }

      function start() {
        lastPoint = getPoint();

        ax = ay = vx = vy = 0;
        timestamp = new Date();

        cancelAnimationFrame(ticker);
        cancelAnimationFrame(raf);

        // we start polling the point position to accumulate velocity
        // Once we stop(), we will use accumulated velocity to keep scrolling
        // an object.
        ticker = requestAnimationFrame(track);
      }

      function track() {
        var now = Date.now();
        var elapsed = now - timestamp;
        timestamp = now;

        var currentPoint = getPoint();

        var dx = currentPoint.x - lastPoint.x;
        var dy = currentPoint.y - lastPoint.y;

        lastPoint = currentPoint;

        var dt = 1000 / (1 + elapsed);

        // moving average
        vx = 0.8 * dx * dt + 0.2 * vx;
        vy = 0.8 * dy * dt + 0.2 * vy;

        ticker = requestAnimationFrame(track);
      }

      function stop() {
        cancelAnimationFrame(ticker);
        cancelAnimationFrame(raf);

        var currentPoint = getPoint();

        targetX = currentPoint.x;
        targetY = currentPoint.y;
        timestamp = Date.now();

        if (vx < -minVelocity || vx > minVelocity) {
          ax = amplitude * vx;
          targetX += ax;
        }

        if (vy < -minVelocity || vy > minVelocity) {
          ay = amplitude * vy;
          targetY += ay;
        }

        raf = requestAnimationFrame(autoScroll);
      }

      function autoScroll() {
        var elapsed = Date.now() - timestamp;

        var moving = false;
        var dx = 0;
        var dy = 0;

        if (ax) {
          dx = -ax * Math.exp(-elapsed / timeConstant);

          if (dx > 0.5 || dx < -0.5) moving = true;
          else dx = ax = 0;
        }

        if (ay) {
          dy = -ay * Math.exp(-elapsed / timeConstant);

          if (dy > 0.5 || dy < -0.5) moving = true;
          else dy = ay = 0;
        }

        if (moving) {
          scroll(targetX + dx, targetY + dy);
          raf = requestAnimationFrame(autoScroll);
        }
      }
    }

    function getCancelAnimationFrame() {
      if (typeof cancelAnimationFrame === 'function') return cancelAnimationFrame;
      return clearTimeout;
    }

    function getRequestAnimationFrame() {
      if (typeof requestAnimationFrame === 'function') return requestAnimationFrame;

      return function (handler) {
        return setTimeout(handler, 16);
      };
    }

    /**
     * Disallows selecting text.
     */

    var createTextSelectionInterceptor_1 = createTextSelectionInterceptor$1;

    function createTextSelectionInterceptor$1(useFake) {
      if (useFake) {
        return {
          capture: noop$1,
          release: noop$1
        };
      }

      var dragObject;
      var prevSelectStart;
      var prevDragStart;
      var wasCaptured = false;

      return {
        capture: capture,
        release: release
      };

      function capture(domObject) {
        wasCaptured = true;
        prevSelectStart = window.document.onselectstart;
        prevDragStart = window.document.ondragstart;

        window.document.onselectstart = disabled;

        dragObject = domObject;
        dragObject.ondragstart = disabled;
      }

      function release() {
        if (!wasCaptured) return;
        
        wasCaptured = false;
        window.document.onselectstart = prevSelectStart;
        if (dragObject) dragObject.ondragstart = prevDragStart;
      }
    }

    function disabled(e) {
      e.stopPropagation();
      return false;
    }

    function noop$1() {}

    var transform$1 = Transform$1;

    function Transform$1() {
      this.x = 0;
      this.y = 0;
      this.scale = 1;
    }

    var svgController = {exports: {}};

    svgController.exports = makeSvgController$1;
    svgController.exports.canAttach = isSVGElement;

    function makeSvgController$1(svgElement, options) {
      if (!isSVGElement(svgElement)) {
        throw new Error('svg element is required for svg.panzoom to work');
      }

      var owner = svgElement.ownerSVGElement;
      if (!owner) {
        throw new Error(
          'Do not apply panzoom to the root <svg> element. ' +
          'Use its child instead (e.g. <g></g>). ' +
          'As of March 2016 only FireFox supported transform on the root element');
      }

      if (!options.disableKeyboardInteraction) {
        owner.setAttribute('tabindex', 0);
      }

      var api = {
        getBBox: getBBox,
        getScreenCTM: getScreenCTM,
        getOwner: getOwner,
        applyTransform: applyTransform,
        initTransform: initTransform
      };
      
      return api;

      function getOwner() {
        return owner;
      }

      function getBBox() {
        var bbox =  svgElement.getBBox();
        return {
          left: bbox.x,
          top: bbox.y,
          width: bbox.width,
          height: bbox.height,
        };
      }

      function getScreenCTM() {
        var ctm = owner.getCTM();
        if (!ctm) {
          // This is likely firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=873106
          // The code below is not entirely correct, but still better than nothing
          return owner.getScreenCTM();
        }
        return ctm;
      }

      function initTransform(transform) {
        var screenCTM = svgElement.getCTM();

        // The above line returns null on Firefox
        if (screenCTM === null) {
          screenCTM = document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGMatrix();
        }

        transform.x = screenCTM.e;
        transform.y = screenCTM.f;
        transform.scale = screenCTM.a;
        owner.removeAttributeNS(null, 'viewBox');
      }

      function applyTransform(transform) {
        svgElement.setAttribute('transform', 'matrix(' +
          transform.scale + ' 0 0 ' +
          transform.scale + ' ' +
          transform.x + ' ' + transform.y + ')');
      }
    }

    function isSVGElement(element) {
      return element && element.ownerSVGElement && element.getCTM;
    }

    var domController = {exports: {}};

    domController.exports = makeDomController$1;

    domController.exports.canAttach = isDomElement;

    function makeDomController$1(domElement, options) {
      var elementValid = isDomElement(domElement); 
      if (!elementValid) {
        throw new Error('panzoom requires DOM element to be attached to the DOM tree');
      }

      var owner = domElement.parentElement;
      domElement.scrollTop = 0;
      
      if (!options.disableKeyboardInteraction) {
        owner.setAttribute('tabindex', 0);
      }

      var api = {
        getBBox: getBBox,
        getOwner: getOwner,
        applyTransform: applyTransform,
      };
      
      return api;

      function getOwner() {
        return owner;
      }

      function getBBox() {
        // TODO: We should probably cache this?
        return  {
          left: 0,
          top: 0,
          width: domElement.clientWidth,
          height: domElement.clientHeight
        };
      }

      function applyTransform(transform) {
        // TODO: Should we cache this?
        domElement.style.transformOrigin = '0 0 0';
        domElement.style.transform = 'matrix(' +
          transform.scale + ', 0, 0, ' +
          transform.scale + ', ' +
          transform.x + ', ' + transform.y + ')';
      }
    }

    function isDomElement(element) {
      return element && element.parentElement && element.style;
    }

    /**
     * Allows to drag and zoom svg elements
     */
    var wheel = wheel$1.exports;
    var animate = amator.exports;
    var eventify = ngraph_events;
    var kinetic = kinetic_1;
    var createTextSelectionInterceptor = createTextSelectionInterceptor_1;
    var domTextSelectionInterceptor = createTextSelectionInterceptor();
    var fakeTextSelectorInterceptor = createTextSelectionInterceptor(true);
    var Transform = transform$1;
    var makeSvgController = svgController.exports;
    var makeDomController = domController.exports;

    var defaultZoomSpeed = 1;
    var defaultDoubleTapZoomSpeed = 1.75;
    var doubleTapSpeedInMS = 300;

    var panzoom = createPanZoom;

    /**
     * Creates a new instance of panzoom, so that an object can be panned and zoomed
     *
     * @param {DOMElement} domElement where panzoom should be attached.
     * @param {Object} options that configure behavior.
     */
    function createPanZoom(domElement, options) {
      options = options || {};

      var panController = options.controller;

      if (!panController) {
        if (makeSvgController.canAttach(domElement)) {
          panController = makeSvgController(domElement, options);
        } else if (makeDomController.canAttach(domElement)) {
          panController = makeDomController(domElement, options);
        }
      }

      if (!panController) {
        throw new Error(
          'Cannot create panzoom for the current type of dom element'
        );
      }
      var owner = panController.getOwner();
      // just to avoid GC pressure, every time we do intermediate transform
      // we return this object. For internal use only. Never give it back to the consumer of this library
      var storedCTMResult = { x: 0, y: 0 };

      var isDirty = false;
      var transform = new Transform();

      if (panController.initTransform) {
        panController.initTransform(transform);
      }

      var filterKey = typeof options.filterKey === 'function' ? options.filterKey : noop;
      // TODO: likely need to unite pinchSpeed with zoomSpeed
      var pinchSpeed = typeof options.pinchSpeed === 'number' ? options.pinchSpeed : 1;
      var bounds = options.bounds;
      var maxZoom = typeof options.maxZoom === 'number' ? options.maxZoom : Number.POSITIVE_INFINITY;
      var minZoom = typeof options.minZoom === 'number' ? options.minZoom : 0;

      var boundsPadding = typeof options.boundsPadding === 'number' ? options.boundsPadding : 0.05;
      var zoomDoubleClickSpeed = typeof options.zoomDoubleClickSpeed === 'number' ? options.zoomDoubleClickSpeed : defaultDoubleTapZoomSpeed;
      var beforeWheel = options.beforeWheel || noop;
      var beforeMouseDown = options.beforeMouseDown || noop;
      var speed = typeof options.zoomSpeed === 'number' ? options.zoomSpeed : defaultZoomSpeed;
      var transformOrigin = parseTransformOrigin(options.transformOrigin);
      var textSelection = options.enableTextSelection ? fakeTextSelectorInterceptor : domTextSelectionInterceptor;

      validateBounds(bounds);

      if (options.autocenter) {
        autocenter();
      }

      var frameAnimation;
      var lastTouchEndTime = 0;
      var lastSingleFingerOffset;
      var touchInProgress = false;

      // We only need to fire panstart when actual move happens
      var panstartFired = false;

      // cache mouse coordinates here
      var mouseX;
      var mouseY;

      var pinchZoomLength;

      var smoothScroll;
      if ('smoothScroll' in options && !options.smoothScroll) {
        // If user explicitly asked us not to use smooth scrolling, we obey
        smoothScroll = rigidScroll();
      } else {
        // otherwise we use forward smoothScroll settings to kinetic API
        // which makes scroll smoothing.
        smoothScroll = kinetic(getPoint, scroll, options.smoothScroll);
      }

      var moveByAnimation;
      var zoomToAnimation;

      var multiTouch;
      var paused = false;

      listenForEvents();

      var api = {
        dispose: dispose,
        moveBy: internalMoveBy,
        moveTo: moveTo,
        smoothMoveTo: smoothMoveTo, 
        centerOn: centerOn,
        zoomTo: publicZoomTo,
        zoomAbs: zoomAbs,
        smoothZoom: smoothZoom,
        smoothZoomAbs: smoothZoomAbs,
        showRectangle: showRectangle,

        pause: pause,
        resume: resume,
        isPaused: isPaused,

        getTransform: getTransformModel,

        getMinZoom: getMinZoom,
        setMinZoom: setMinZoom,

        getMaxZoom: getMaxZoom,
        setMaxZoom: setMaxZoom,

        getTransformOrigin: getTransformOrigin,
        setTransformOrigin: setTransformOrigin,

        getZoomSpeed: getZoomSpeed,
        setZoomSpeed: setZoomSpeed
      };

      eventify(api);
      
      var initialX = typeof options.initialX === 'number' ? options.initialX : transform.x;
      var initialY = typeof options.initialY === 'number' ? options.initialY : transform.y;
      var initialZoom = typeof options.initialZoom === 'number' ? options.initialZoom : transform.scale;

      if(initialX != transform.x || initialY != transform.y || initialZoom != transform.scale){
        zoomAbs(initialX, initialY, initialZoom);
      }

      return api;

      function pause() {
        releaseEvents();
        paused = true;
      }

      function resume() {
        if (paused) {
          listenForEvents();
          paused = false;
        }
      }

      function isPaused() {
        return paused;
      }

      function showRectangle(rect) {
        // TODO: this duplicates autocenter. I think autocenter should go.
        var clientRect = owner.getBoundingClientRect();
        var size = transformToScreen(clientRect.width, clientRect.height);

        var rectWidth = rect.right - rect.left;
        var rectHeight = rect.bottom - rect.top;
        if (!Number.isFinite(rectWidth) || !Number.isFinite(rectHeight)) {
          throw new Error('Invalid rectangle');
        }

        var dw = size.x / rectWidth;
        var dh = size.y / rectHeight;
        var scale = Math.min(dw, dh);
        transform.x = -(rect.left + rectWidth / 2) * scale + size.x / 2;
        transform.y = -(rect.top + rectHeight / 2) * scale + size.y / 2;
        transform.scale = scale;
      }

      function transformToScreen(x, y) {
        if (panController.getScreenCTM) {
          var parentCTM = panController.getScreenCTM();
          var parentScaleX = parentCTM.a;
          var parentScaleY = parentCTM.d;
          var parentOffsetX = parentCTM.e;
          var parentOffsetY = parentCTM.f;
          storedCTMResult.x = x * parentScaleX - parentOffsetX;
          storedCTMResult.y = y * parentScaleY - parentOffsetY;
        } else {
          storedCTMResult.x = x;
          storedCTMResult.y = y;
        }

        return storedCTMResult;
      }

      function autocenter() {
        var w; // width of the parent
        var h; // height of the parent
        var left = 0;
        var top = 0;
        var sceneBoundingBox = getBoundingBox();
        if (sceneBoundingBox) {
          // If we have bounding box - use it.
          left = sceneBoundingBox.left;
          top = sceneBoundingBox.top;
          w = sceneBoundingBox.right - sceneBoundingBox.left;
          h = sceneBoundingBox.bottom - sceneBoundingBox.top;
        } else {
          // otherwise just use whatever space we have
          var ownerRect = owner.getBoundingClientRect();
          w = ownerRect.width;
          h = ownerRect.height;
        }
        var bbox = panController.getBBox();
        if (bbox.width === 0 || bbox.height === 0) {
          // we probably do not have any elements in the SVG
          // just bail out;
          return;
        }
        var dh = h / bbox.height;
        var dw = w / bbox.width;
        var scale = Math.min(dw, dh);
        transform.x = -(bbox.left + bbox.width / 2) * scale + w / 2 + left;
        transform.y = -(bbox.top + bbox.height / 2) * scale + h / 2 + top;
        transform.scale = scale;
      }

      function getTransformModel() {
        // TODO: should this be read only?
        return transform;
      }

      function getMinZoom() {
        return minZoom;
      }

      function setMinZoom(newMinZoom) {
        minZoom = newMinZoom;
      }

      function getMaxZoom() {
        return maxZoom;
      }

      function setMaxZoom(newMaxZoom) {
        maxZoom = newMaxZoom;
      }

      function getTransformOrigin() {
        return transformOrigin;
      }

      function setTransformOrigin(newTransformOrigin) {
        transformOrigin = parseTransformOrigin(newTransformOrigin);
      }

      function getZoomSpeed() {
        return speed;
      }

      function setZoomSpeed(newSpeed) {
        if (!Number.isFinite(newSpeed)) {
          throw new Error('Zoom speed should be a number');
        }
        speed = newSpeed;
      }

      function getPoint() {
        return {
          x: transform.x,
          y: transform.y
        };
      }

      function moveTo(x, y) {
        transform.x = x;
        transform.y = y;

        keepTransformInsideBounds();

        triggerEvent('pan');
        makeDirty();
      }

      function moveBy(dx, dy) {
        moveTo(transform.x + dx, transform.y + dy);
      }

      function keepTransformInsideBounds() {
        var boundingBox = getBoundingBox();
        if (!boundingBox) return;

        var adjusted = false;
        var clientRect = getClientRect();

        var diff = boundingBox.left - clientRect.right;
        if (diff > 0) {
          transform.x += diff;
          adjusted = true;
        }
        // check the other side:
        diff = boundingBox.right - clientRect.left;
        if (diff < 0) {
          transform.x += diff;
          adjusted = true;
        }

        // y axis:
        diff = boundingBox.top - clientRect.bottom;
        if (diff > 0) {
          // we adjust transform, so that it matches exactly our bounding box:
          // transform.y = boundingBox.top - (boundingBox.height + boundingBox.y) * transform.scale =>
          // transform.y = boundingBox.top - (clientRect.bottom - transform.y) =>
          // transform.y = diff + transform.y =>
          transform.y += diff;
          adjusted = true;
        }

        diff = boundingBox.bottom - clientRect.top;
        if (diff < 0) {
          transform.y += diff;
          adjusted = true;
        }
        return adjusted;
      }

      /**
       * Returns bounding box that should be used to restrict scene movement.
       */
      function getBoundingBox() {
        if (!bounds) return; // client does not want to restrict movement

        if (typeof bounds === 'boolean') {
          // for boolean type we use parent container bounds
          var ownerRect = owner.getBoundingClientRect();
          var sceneWidth = ownerRect.width;
          var sceneHeight = ownerRect.height;

          return {
            left: sceneWidth * boundsPadding,
            top: sceneHeight * boundsPadding,
            right: sceneWidth * (1 - boundsPadding),
            bottom: sceneHeight * (1 - boundsPadding)
          };
        }

        return bounds;
      }

      function getClientRect() {
        var bbox = panController.getBBox();
        var leftTop = client(bbox.left, bbox.top);

        return {
          left: leftTop.x,
          top: leftTop.y,
          right: bbox.width * transform.scale + leftTop.x,
          bottom: bbox.height * transform.scale + leftTop.y
        };
      }

      function client(x, y) {
        return {
          x: x * transform.scale + transform.x,
          y: y * transform.scale + transform.y
        };
      }

      function makeDirty() {
        isDirty = true;
        frameAnimation = window.requestAnimationFrame(frame);
      }

      function zoomByRatio(clientX, clientY, ratio) {
        if (isNaN$1(clientX) || isNaN$1(clientY) || isNaN$1(ratio)) {
          throw new Error('zoom requires valid numbers');
        }

        var newScale = transform.scale * ratio;

        if (newScale < minZoom) {
          if (transform.scale === minZoom) return;

          ratio = minZoom / transform.scale;
        }
        if (newScale > maxZoom) {
          if (transform.scale === maxZoom) return;

          ratio = maxZoom / transform.scale;
        }

        var size = transformToScreen(clientX, clientY);

        transform.x = size.x - ratio * (size.x - transform.x);
        transform.y = size.y - ratio * (size.y - transform.y);

        // TODO: https://github.com/anvaka/panzoom/issues/112
        if (bounds && boundsPadding === 1 && minZoom === 1) {
          transform.scale *= ratio;
          keepTransformInsideBounds();
        } else {
          var transformAdjusted = keepTransformInsideBounds();
          if (!transformAdjusted) transform.scale *= ratio;
        }

        triggerEvent('zoom');

        makeDirty();
      }

      function zoomAbs(clientX, clientY, zoomLevel) {
        var ratio = zoomLevel / transform.scale;
        zoomByRatio(clientX, clientY, ratio);
      }

      function centerOn(ui) {
        var parent = ui.ownerSVGElement;
        if (!parent)
          throw new Error('ui element is required to be within the scene');

        // TODO: should i use controller's screen CTM?
        var clientRect = ui.getBoundingClientRect();
        var cx = clientRect.left + clientRect.width / 2;
        var cy = clientRect.top + clientRect.height / 2;

        var container = parent.getBoundingClientRect();
        var dx = container.width / 2 - cx;
        var dy = container.height / 2 - cy;

        internalMoveBy(dx, dy, true);
      }

      function smoothMoveTo(x, y){
        internalMoveBy(x - transform.x, y - transform.y, true);
      }

      function internalMoveBy(dx, dy, smooth) {
        if (!smooth) {
          return moveBy(dx, dy);
        }

        if (moveByAnimation) moveByAnimation.cancel();

        var from = { x: 0, y: 0 };
        var to = { x: dx, y: dy };
        var lastX = 0;
        var lastY = 0;

        moveByAnimation = animate(from, to, {
          step: function (v) {
            moveBy(v.x - lastX, v.y - lastY);

            lastX = v.x;
            lastY = v.y;
          }
        });
      }

      function scroll(x, y) {
        cancelZoomAnimation();
        moveTo(x, y);
      }

      function dispose() {
        releaseEvents();
      }

      function listenForEvents() {
        owner.addEventListener('mousedown', onMouseDown, { passive: false });
        owner.addEventListener('dblclick', onDoubleClick, { passive: false });
        owner.addEventListener('touchstart', onTouch, { passive: false });
        owner.addEventListener('keydown', onKeyDown, { passive: false });

        // Need to listen on the owner container, so that we are not limited
        // by the size of the scrollable domElement
        wheel.addWheelListener(owner, onMouseWheel, { passive: false });

        makeDirty();
      }

      function releaseEvents() {
        wheel.removeWheelListener(owner, onMouseWheel);
        owner.removeEventListener('mousedown', onMouseDown);
        owner.removeEventListener('keydown', onKeyDown);
        owner.removeEventListener('dblclick', onDoubleClick);
        owner.removeEventListener('touchstart', onTouch);

        if (frameAnimation) {
          window.cancelAnimationFrame(frameAnimation);
          frameAnimation = 0;
        }

        smoothScroll.cancel();

        releaseDocumentMouse();
        releaseTouches();
        textSelection.release();

        triggerPanEnd();
      }

      function frame() {
        if (isDirty) applyTransform();
      }

      function applyTransform() {
        isDirty = false;

        // TODO: Should I allow to cancel this?
        panController.applyTransform(transform);

        triggerEvent('transform');
        frameAnimation = 0;
      }

      function onKeyDown(e) {
        var x = 0,
          y = 0,
          z = 0;
        if (e.keyCode === 38) {
          y = 1; // up
        } else if (e.keyCode === 40) {
          y = -1; // down
        } else if (e.keyCode === 37) {
          x = 1; // left
        } else if (e.keyCode === 39) {
          x = -1; // right
        } else if (e.keyCode === 189 || e.keyCode === 109) {
          // DASH or SUBTRACT
          z = 1; // `-` -  zoom out
        } else if (e.keyCode === 187 || e.keyCode === 107) {
          // EQUAL SIGN or ADD
          z = -1; // `=` - zoom in (equal sign on US layout is under `+`)
        }

        if (filterKey(e, x, y, z)) {
          // They don't want us to handle the key: https://github.com/anvaka/panzoom/issues/45
          return;
        }

        if (x || y) {
          e.preventDefault();
          e.stopPropagation();

          var clientRect = owner.getBoundingClientRect();
          // movement speed should be the same in both X and Y direction:
          var offset = Math.min(clientRect.width, clientRect.height);
          var moveSpeedRatio = 0.05;
          var dx = offset * moveSpeedRatio * x;
          var dy = offset * moveSpeedRatio * y;

          // TODO: currently we do not animate this. It could be better to have animation
          internalMoveBy(dx, dy);
        }

        if (z) {
          var scaleMultiplier = getScaleMultiplier(z * 100);
          var offset = transformOrigin ? getTransformOriginOffset() : midPoint();
          publicZoomTo(offset.x, offset.y, scaleMultiplier);
        }
      }

      function midPoint() {
        var ownerRect = owner.getBoundingClientRect();
        return {
          x: ownerRect.width / 2,
          y: ownerRect.height / 2
        };
      }

      function onTouch(e) {
        // let the override the touch behavior
        beforeTouch(e);

        if (e.touches.length === 1) {
          return handleSingleFingerTouch(e, e.touches[0]);
        } else if (e.touches.length === 2) {
          // handleTouchMove() will care about pinch zoom.
          pinchZoomLength = getPinchZoomLength(e.touches[0], e.touches[1]);
          multiTouch = true;
          startTouchListenerIfNeeded();
        }
      }

      function beforeTouch(e) {
        // TODO: Need to unify this filtering names. E.g. use `beforeTouch`
        if (options.onTouch && !options.onTouch(e)) {
          // if they return `false` from onTouch, we don't want to stop
          // events propagation. Fixes https://github.com/anvaka/panzoom/issues/12
          return;
        }

        e.stopPropagation();
        e.preventDefault();
      }

      function beforeDoubleClick(e) {
        // TODO: Need to unify this filtering names. E.g. use `beforeDoubleClick``
        if (options.onDoubleClick && !options.onDoubleClick(e)) {
          // if they return `false` from onTouch, we don't want to stop
          // events propagation. Fixes https://github.com/anvaka/panzoom/issues/46
          return;
        }

        e.preventDefault();
        e.stopPropagation();
      }

      function handleSingleFingerTouch(e) {
        var touch = e.touches[0];
        var offset = getOffsetXY(touch);
        lastSingleFingerOffset = offset;
        var point = transformToScreen(offset.x, offset.y);
        mouseX = point.x;
        mouseY = point.y;

        smoothScroll.cancel();
        startTouchListenerIfNeeded();
      }

      function startTouchListenerIfNeeded() {
        if (touchInProgress) {
          // no need to do anything, as we already listen to events;
          return;
        }

        touchInProgress = true;
        document.addEventListener('touchmove', handleTouchMove);
        document.addEventListener('touchend', handleTouchEnd);
        document.addEventListener('touchcancel', handleTouchEnd);
      }

      function handleTouchMove(e) {
        if (e.touches.length === 1) {
          e.stopPropagation();
          var touch = e.touches[0];

          var offset = getOffsetXY(touch);
          var point = transformToScreen(offset.x, offset.y);

          var dx = point.x - mouseX;
          var dy = point.y - mouseY;

          if (dx !== 0 && dy !== 0) {
            triggerPanStart();
          }
          mouseX = point.x;
          mouseY = point.y;
          internalMoveBy(dx, dy);
        } else if (e.touches.length === 2) {
          // it's a zoom, let's find direction
          multiTouch = true;
          var t1 = e.touches[0];
          var t2 = e.touches[1];
          var currentPinchLength = getPinchZoomLength(t1, t2);

          // since the zoom speed is always based on distance from 1, we need to apply
          // pinch speed only on that distance from 1:
          var scaleMultiplier =
            1 + (currentPinchLength / pinchZoomLength - 1) * pinchSpeed;

          var firstTouchPoint = getOffsetXY(t1);
          var secondTouchPoint = getOffsetXY(t2);
          mouseX = (firstTouchPoint.x + secondTouchPoint.x) / 2;
          mouseY = (firstTouchPoint.y + secondTouchPoint.y) / 2;
          if (transformOrigin) {
            var offset = getTransformOriginOffset();
            mouseX = offset.x;
            mouseY = offset.y;
          }

          publicZoomTo(mouseX, mouseY, scaleMultiplier);

          pinchZoomLength = currentPinchLength;
          e.stopPropagation();
          e.preventDefault();
        }
      }

      function handleTouchEnd(e) {
        if (e.touches.length > 0) {
          var offset = getOffsetXY(e.touches[0]);
          var point = transformToScreen(offset.x, offset.y);
          mouseX = point.x;
          mouseY = point.y;
        } else {
          var now = new Date();
          if (now - lastTouchEndTime < doubleTapSpeedInMS) {
            if (transformOrigin) {
              var offset = getTransformOriginOffset();
              smoothZoom(offset.x, offset.y, zoomDoubleClickSpeed);
            } else {
              // We want untransformed x/y here.
              smoothZoom(lastSingleFingerOffset.x, lastSingleFingerOffset.y, zoomDoubleClickSpeed);
            }
          }

          lastTouchEndTime = now;

          triggerPanEnd();
          releaseTouches();
        }
      }

      function getPinchZoomLength(finger1, finger2) {
        var dx = finger1.clientX - finger2.clientX;
        var dy = finger1.clientY - finger2.clientY;
        return Math.sqrt(dx * dx + dy * dy);
      }

      function onDoubleClick(e) {
        beforeDoubleClick(e);
        var offset = getOffsetXY(e);
        if (transformOrigin) {
          // TODO: looks like this is duplicated in the file.
          // Need to refactor
          offset = getTransformOriginOffset();
        }
        smoothZoom(offset.x, offset.y, zoomDoubleClickSpeed);
      }

      function onMouseDown(e) {
        // if client does not want to handle this event - just ignore the call
        if (beforeMouseDown(e)) return;

        if (touchInProgress) {
          // modern browsers will fire mousedown for touch events too
          // we do not want this: touch is handled separately.
          e.stopPropagation();
          return false;
        }
        // for IE, left click == 1
        // for Firefox, left click == 0
        var isLeftButton =
          (e.button === 1 && window.event !== null) || e.button === 0;
        if (!isLeftButton) return;

        smoothScroll.cancel();

        var offset = getOffsetXY(e);
        var point = transformToScreen(offset.x, offset.y);
        mouseX = point.x;
        mouseY = point.y;

        // We need to listen on document itself, since mouse can go outside of the
        // window, and we will loose it
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        textSelection.capture(e.target || e.srcElement);

        return false;
      }

      function onMouseMove(e) {
        // no need to worry about mouse events when touch is happening
        if (touchInProgress) return;

        triggerPanStart();

        var offset = getOffsetXY(e);
        var point = transformToScreen(offset.x, offset.y);
        var dx = point.x - mouseX;
        var dy = point.y - mouseY;

        mouseX = point.x;
        mouseY = point.y;

        internalMoveBy(dx, dy);
      }

      function onMouseUp() {
        textSelection.release();
        triggerPanEnd();
        releaseDocumentMouse();
      }

      function releaseDocumentMouse() {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        panstartFired = false;
      }

      function releaseTouches() {
        document.removeEventListener('touchmove', handleTouchMove);
        document.removeEventListener('touchend', handleTouchEnd);
        document.removeEventListener('touchcancel', handleTouchEnd);
        panstartFired = false;
        multiTouch = false;
        touchInProgress = false;
      }

      function onMouseWheel(e) {
        // if client does not want to handle this event - just ignore the call
        if (beforeWheel(e)) return;

        smoothScroll.cancel();

        var delta = e.deltaY;
        if (e.deltaMode > 0) delta *= 100;

        var scaleMultiplier = getScaleMultiplier(delta);

        if (scaleMultiplier !== 1) {
          var offset = transformOrigin
            ? getTransformOriginOffset()
            : getOffsetXY(e);
          publicZoomTo(offset.x, offset.y, scaleMultiplier);
          e.preventDefault();
        }
      }

      function getOffsetXY(e) {
        var offsetX, offsetY;
        // I tried using e.offsetX, but that gives wrong results for svg, when user clicks on a path.
        var ownerRect = owner.getBoundingClientRect();
        offsetX = e.clientX - ownerRect.left;
        offsetY = e.clientY - ownerRect.top;

        return { x: offsetX, y: offsetY };
      }

      function smoothZoom(clientX, clientY, scaleMultiplier) {
        var fromValue = transform.scale;
        var from = { scale: fromValue };
        var to = { scale: scaleMultiplier * fromValue };

        smoothScroll.cancel();
        cancelZoomAnimation();

        zoomToAnimation = animate(from, to, {
          step: function (v) {
            zoomAbs(clientX, clientY, v.scale);
          },
          done: triggerZoomEnd
        });
      }

      function smoothZoomAbs(clientX, clientY, toScaleValue) {
        var fromValue = transform.scale;
        var from = { scale: fromValue };
        var to = { scale: toScaleValue };

        smoothScroll.cancel();
        cancelZoomAnimation();

        zoomToAnimation = animate(from, to, {
          step: function (v) {
            zoomAbs(clientX, clientY, v.scale);
          }
        });
      }

      function getTransformOriginOffset() {
        var ownerRect = owner.getBoundingClientRect();
        return {
          x: ownerRect.width * transformOrigin.x,
          y: ownerRect.height * transformOrigin.y
        };
      }

      function publicZoomTo(clientX, clientY, scaleMultiplier) {
        smoothScroll.cancel();
        cancelZoomAnimation();
        return zoomByRatio(clientX, clientY, scaleMultiplier);
      }

      function cancelZoomAnimation() {
        if (zoomToAnimation) {
          zoomToAnimation.cancel();
          zoomToAnimation = null;
        }
      }

      function getScaleMultiplier(delta) {
        var sign = Math.sign(delta);
        var deltaAdjustedSpeed = Math.min(0.25, Math.abs(speed * delta / 128));
        return 1 - sign * deltaAdjustedSpeed;
      }

      function triggerPanStart() {
        if (!panstartFired) {
          triggerEvent('panstart');
          panstartFired = true;
          smoothScroll.start();
        }
      }

      function triggerPanEnd() {
        if (panstartFired) {
          // we should never run smooth scrolling if it was multiTouch (pinch zoom animation):
          if (!multiTouch) smoothScroll.stop();
          triggerEvent('panend');
        }
      }

      function triggerZoomEnd() {
        triggerEvent('zoomend');
      }

      function triggerEvent(name) {
        api.fire(name, api);
      }
    }

    function parseTransformOrigin(options) {
      if (!options) return;
      if (typeof options === 'object') {
        if (!isNumber$1(options.x) || !isNumber$1(options.y))
          failTransformOrigin(options);
        return options;
      }

      failTransformOrigin();
    }

    function failTransformOrigin(options) {
      console.error(options);
      throw new Error(
        [
          'Cannot parse transform origin.',
          'Some good examples:',
          '  "center center" can be achieved with {x: 0.5, y: 0.5}',
          '  "top center" can be achieved with {x: 0.5, y: 0}',
          '  "bottom right" can be achieved with {x: 1, y: 1}'
        ].join('\n')
      );
    }

    function noop() { }

    function validateBounds(bounds) {
      var boundsType = typeof bounds;
      if (boundsType === 'undefined' || boundsType === 'boolean') return; // this is okay
      // otherwise need to be more thorough:
      var validBounds =
        isNumber$1(bounds.left) &&
        isNumber$1(bounds.top) &&
        isNumber$1(bounds.bottom) &&
        isNumber$1(bounds.right);

      if (!validBounds)
        throw new Error(
          'Bounds object is not valid. It can be: ' +
          'undefined, boolean (true|false) or an object {left, top, right, bottom}'
        );
    }

    function isNumber$1(x) {
      return Number.isFinite(x);
    }

    // IE 11 does not support isNaN:
    function isNaN$1(value) {
      if (Number.isNaN) {
        return Number.isNaN(value);
      }

      return value !== value;
    }

    function rigidScroll() {
      return {
        start: noop,
        stop: noop,
        cancel: noop
      };
    }

    function autoRun() {
      if (typeof document === 'undefined') return;

      var scripts = document.getElementsByTagName('script');
      if (!scripts) return;
      var panzoomScript;

      for (var i = 0; i < scripts.length; ++i) {
        var x = scripts[i];
        if (x.src && x.src.match(/\bpanzoom(\.min)?\.js/)) {
          panzoomScript = x;
          break;
        }
      }

      if (!panzoomScript) return;

      var query = panzoomScript.getAttribute('query');
      if (!query) return;

      var globalName = panzoomScript.getAttribute('name') || 'pz';
      var started = Date.now();

      tryAttach();

      function tryAttach() {
        var el = document.querySelector(query);
        if (!el) {
          var now = Date.now();
          var elapsed = now - started;
          if (elapsed < 2000) {
            // Let's wait a bit
            setTimeout(tryAttach, 100);
            return;
          }
          // If we don't attach within 2 seconds to the target element, consider it a failure
          console.error('Cannot find the panzoom element', globalName);
          return;
        }
        var options = collectOptions(panzoomScript);
        console.log(options);
        window[globalName] = createPanZoom(el, options);
      }

      function collectOptions(script) {
        var attrs = script.attributes;
        var options = {};
        for (var j = 0; j < attrs.length; ++j) {
          var attr = attrs[j];
          var nameValue = getPanzoomAttributeNameValue(attr);
          if (nameValue) {
            options[nameValue.name] = nameValue.value;
          }
        }

        return options;
      }

      function getPanzoomAttributeNameValue(attr) {
        if (!attr.name) return;
        var isPanZoomAttribute =
          attr.name[0] === 'p' && attr.name[1] === 'z' && attr.name[2] === '-';

        if (!isPanZoomAttribute) return;

        var name = attr.name.substr(3);
        var value = JSON.parse(attr.value);
        return { name: name, value: value };
      }
    }

    autoRun();

    var build = {};

    var Validate = {};

    var Types = {};

    Object.defineProperty(Types, "__esModule", { value: true });
    Types.Node = Types.DisconnectedNode = Types.OPTypes = void 0;
    Types.OPTypes = ["TOP", "CHOP", "MAT", "SOP", "COMP", "DAT"];
    class DisconnectedNode {
        constructor(revConnect) {
            this.revConnect = revConnect;
        }
        connect(n) {
            return new DisconnectedNode(inputs => n.run([this.run(inputs)]));
        }
        c(n) {
            return this.connect(n);
        }
        run(inputs) {
            return this.revConnect(inputs.map(n => n.runT()));
        }
        runT() {
            return this.run([]);
        }
        out() {
            return this.runT().node;
        }
    }
    Types.DisconnectedNode = DisconnectedNode;
    class Node {
        constructor(node) {
            this.node = node;
        }
        connect(n) {
            return n.run([this]);
        }
        c(n) {
            return this.connect(n);
        }
        runT() {
            return this;
        }
        out() { return this.node; }
    }
    Types.Node = Node;

    var glslTOP = {
    	maxInputs: 3,
    	pars: {
    		chopuniname1: {
    			type: "string"
    		},
    		value17: {
    			type: "xyzw"
    		},
    		value16: {
    			type: "xyzw"
    		},
    		dispatchsizey: {
    			type: "number"
    		},
    		acsize2: {
    			type: "number"
    		},
    		uniname27: {
    			type: "string"
    		},
    		pixeldat: {
    			type: "DAT"
    		},
    		uniname12: {
    			type: "string"
    		},
    		uniname24: {
    			type: "string"
    		},
    		value12: {
    			type: "xyzw"
    		},
    		outputaccess: {
    			type: "menu",
    			menuitems: [
    				"writeonly",
    				"readonly",
    				"readwrite"
    			]
    		},
    		acsingleval1: {
    			type: "number"
    		},
    		uniname8: {
    			type: "string"
    		},
    		value28: {
    			type: "xyzw"
    		},
    		matvalue4: {
    			type: "OP"
    		},
    		acchopval1: {
    			type: "CHOP"
    		},
    		uniname7: {
    			type: "string"
    		},
    		depth: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"custom"
    			]
    		},
    		matvalue9: {
    			type: "OP"
    		},
    		chopuniname4: {
    			type: "string"
    		},
    		acsingleval3: {
    			type: "number"
    		},
    		chopuniname9: {
    			type: "string"
    		},
    		value18: {
    			type: "xyzw"
    		},
    		chopuniname3: {
    			type: "string"
    		},
    		nval: {
    			type: "number"
    		},
    		mode: {
    			type: "menu",
    			menuitems: [
    				"vertexpixel",
    				"compute"
    			]
    		},
    		chopunitype8: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		uniname17: {
    			type: "string"
    		},
    		uniname10: {
    			type: "string"
    		},
    		choparraytype7: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		choparraytype2: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		chopunitype6: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		chopunitype4: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		matvalue0: {
    			type: "OP"
    		},
    		uniname26: {
    			type: "string"
    		},
    		numcolorbufs: {
    			type: "number"
    		},
    		value10: {
    			type: "xyzw"
    		},
    		value11: {
    			type: "xyzw"
    		},
    		matvalue7: {
    			type: "OP"
    		},
    		uniname4: {
    			type: "string"
    		},
    		uniname15: {
    			type: "string"
    		},
    		uniname16: {
    			type: "string"
    		},
    		computedat: {
    			type: "DAT"
    		},
    		value13: {
    			type: "xyzw"
    		},
    		matvalue1: {
    			type: "OP"
    		},
    		acsize3: {
    			type: "number"
    		},
    		chop1: {
    			type: "CHOP"
    		},
    		matuniname6: {
    			type: "string"
    		},
    		chopuniname6: {
    			type: "string"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		value24: {
    			type: "xyzw"
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"texture2d",
    				"texture2darray",
    				"texture3d"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		glslversion: {
    			type: "menu",
    			menuitems: [
    				"glsl120",
    				"glsl330",
    				"glsl400",
    				"glsl410",
    				"glsl420",
    				"glsl430",
    				"glsl440",
    				"glsl450",
    				"glsl460"
    			]
    		},
    		value19: {
    			type: "xyzw"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		chop6: {
    			type: "CHOP"
    		},
    		chopuniname7: {
    			type: "string"
    		},
    		matvalue3: {
    			type: "OP"
    		},
    		value0: {
    			type: "xyzw"
    		},
    		acinitval1: {
    			type: "menu",
    			menuitems: [
    				"val",
    				"chop"
    			]
    		},
    		chopunitype2: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		acsize1: {
    			type: "number"
    		},
    		value8: {
    			type: "xyzw"
    		},
    		matuniname7: {
    			type: "string"
    		},
    		value14: {
    			type: "xyzw"
    		},
    		acinitval2: {
    			type: "menu",
    			menuitems: [
    				"val",
    				"chop"
    			]
    		},
    		choparraytype4: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		acbinding3: {
    			type: "number"
    		},
    		value7: {
    			type: "xyzw"
    		},
    		acinitval3: {
    			type: "menu",
    			menuitems: [
    				"val",
    				"chop"
    			]
    		},
    		choparraytype6: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		chopuniname0: {
    			type: "string"
    		},
    		chopunitype7: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		uniname13: {
    			type: "string"
    		},
    		uniname23: {
    			type: "string"
    		},
    		value29: {
    			type: "xyzw"
    		},
    		value21: {
    			type: "xyzw"
    		},
    		uniname20: {
    			type: "string"
    		},
    		aspect2: {
    			type: "float"
    		},
    		choparraytype8: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		value27: {
    			type: "xyzw"
    		},
    		uniname5: {
    			type: "string"
    		},
    		inputmapping: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"ninputs"
    			]
    		},
    		chop9: {
    			type: "CHOP"
    		},
    		matvalue8: {
    			type: "OP"
    		},
    		matvalue5: {
    			type: "OP"
    		},
    		chop5: {
    			type: "CHOP"
    		},
    		uniname25: {
    			type: "string"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		value4: {
    			type: "xyzw"
    		},
    		chopunitype3: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		uniname2: {
    			type: "string"
    		},
    		value22: {
    			type: "xyzw"
    		},
    		acsingleval2: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		vertexdat: {
    			type: "DAT"
    		},
    		chopunitype0: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		matvalue6: {
    			type: "OP"
    		},
    		clearvalue: {
    			type: "rgba"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		matuniname9: {
    			type: "string"
    		},
    		value9: {
    			type: "xyzw"
    		},
    		value6: {
    			type: "xyzw"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		dispatchsizez: {
    			type: "number"
    		},
    		inputextenduv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		uniname18: {
    			type: "string"
    		},
    		chop3: {
    			type: "CHOP"
    		},
    		customdepth: {
    			type: "number"
    		},
    		matuniname8: {
    			type: "string"
    		},
    		uniname19: {
    			type: "string"
    		},
    		chop7: {
    			type: "CHOP"
    		},
    		chopuniname2: {
    			type: "string"
    		},
    		matuniname3: {
    			type: "string"
    		},
    		acbinding1: {
    			type: "number"
    		},
    		uniname1: {
    			type: "string"
    		},
    		uniname22: {
    			type: "string"
    		},
    		uniname3: {
    			type: "string"
    		},
    		uniname6: {
    			type: "string"
    		},
    		uniname9: {
    			type: "string"
    		},
    		value26: {
    			type: "xyzw"
    		},
    		chopuniname5: {
    			type: "string"
    		},
    		dispatchsizex: {
    			type: "number"
    		},
    		value3: {
    			type: "xyzw"
    		},
    		choparraytype9: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		chop2: {
    			type: "CHOP"
    		},
    		acchopval3: {
    			type: "CHOP"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		acchopval2: {
    			type: "CHOP"
    		},
    		value25: {
    			type: "xyzw"
    		},
    		inputextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		value15: {
    			type: "xyzw"
    		},
    		value23: {
    			type: "xyzw"
    		},
    		matuniname0: {
    			type: "string"
    		},
    		loaduniformnames: {
    			type: "pulse"
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		choparraytype0: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		value1: {
    			type: "xyzw"
    		},
    		enablevectorpage3: {
    			type: "toggle"
    		},
    		chop0: {
    			type: "CHOP"
    		},
    		aspect1: {
    			type: "float"
    		},
    		choparraytype5: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		acchopval0: {
    			type: "CHOP"
    		},
    		uniname14: {
    			type: "string"
    		},
    		matuniname5: {
    			type: "string"
    		},
    		value20: {
    			type: "xyzw"
    		},
    		chopunitype9: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		matuniname1: {
    			type: "string"
    		},
    		value2: {
    			type: "xyzw"
    		},
    		uniname11: {
    			type: "string"
    		},
    		chopuniname8: {
    			type: "string"
    		},
    		acbinding2: {
    			type: "number"
    		},
    		uniname0: {
    			type: "string"
    		},
    		resolutionw: {
    			type: "number"
    		},
    		chop8: {
    			type: "CHOP"
    		},
    		choparraytype3: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		choparraytype1: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		acsingleval0: {
    			type: "number"
    		},
    		clearoutputs: {
    			type: "toggle"
    		},
    		uniname28: {
    			type: "string"
    		},
    		acbinding0: {
    			type: "number"
    		},
    		matvalue2: {
    			type: "OP"
    		},
    		acsize0: {
    			type: "number"
    		},
    		acinitval0: {
    			type: "menu",
    			menuitems: [
    				"val",
    				"chop"
    			]
    		},
    		value5: {
    			type: "xyzw"
    		},
    		chop4: {
    			type: "CHOP"
    		},
    		matuniname4: {
    			type: "string"
    		},
    		matuniname2: {
    			type: "string"
    		},
    		uniname29: {
    			type: "string"
    		},
    		chopunitype5: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		chopunitype1: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		uniname21: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var packTOP = {
    	maxInputs: 1,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		packtype: {
    			type: "menu",
    			menuitems: [
    				"pack",
    				"unpackr",
    				"unpackrg",
    				"unpackrgb",
    				"unpackrgbA"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var channelmixTOP = {
    	maxInputs: 1,
    	pars: {
    		red1: {
    			type: "float"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		alpha1: {
    			type: "float"
    		},
    		blue3: {
    			type: "float"
    		},
    		green2: {
    			type: "float"
    		},
    		resolutionw: {
    			type: "number"
    		},
    		constant4: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		red2: {
    			type: "float"
    		},
    		blue2: {
    			type: "float"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		alpha2: {
    			type: "float"
    		},
    		green1: {
    			type: "float"
    		},
    		alpha4: {
    			type: "float"
    		},
    		constant1: {
    			type: "float"
    		},
    		constant3: {
    			type: "float"
    		},
    		aspect2: {
    			type: "float"
    		},
    		red3: {
    			type: "float"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		blue4: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		green3: {
    			type: "float"
    		},
    		blue1: {
    			type: "float"
    		},
    		red4: {
    			type: "float"
    		},
    		constant2: {
    			type: "float"
    		},
    		green4: {
    			type: "float"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		alpha3: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var convolveTOP = {
    	maxInputs: 1,
    	pars: {
    		applytoalpha: {
    			type: "toggle"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		normalize: {
    			type: "toggle"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		offset: {
    			type: "float"
    		},
    		dat: {
    			type: "DAT"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var videodeviceinTOP = {
    	maxInputs: 0,
    	pars: {
    		resolutionh: {
    			type: "number"
    		},
    		exposure: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		gain: {
    			type: "float"
    		},
    		limitfps: {
    			type: "toggle"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		capturepulse: {
    			type: "pulse"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		lgamma: {
    			type: "float"
    		},
    		channel: {
    			type: "number"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		signalformat: {
    			type: "string"
    		},
    		npasses: {
    			type: "number"
    		},
    		deinterlace: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"even",
    				"odd",
    				"bob"
    			]
    		},
    		inputpixelformat: {
    			type: "menu",
    			menuitems: [
    				"fixed8",
    				"fixed10",
    				"fixed16"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		autowb: {
    			type: "toggle"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		capture: {
    			type: "toggle"
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		cgamma: {
    			type: "float"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		autoge: {
    			type: "toggle"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		specifyip: {
    			type: "toggle"
    		},
    		limitedfps: {
    			type: "float"
    		},
    		syncinputs: {
    			type: "toggle"
    		},
    		syncgroupindex: {
    			type: "number"
    		},
    		wbcoeffs: {
    			type: "rgb"
    		},
    		synctimeout: {
    			type: "number"
    		},
    		active: {
    			type: "toggle"
    		},
    		options: {
    			type: "menu",
    			menuitems: [
    			]
    		},
    		library: {
    			type: "menu",
    			menuitems: [
    				"directshow",
    				"mediafoundation",
    				"imagingsource",
    				"datapath",
    				"blackmagic",
    				"alliedvisiongige",
    				"ids",
    				"pointgreyflycapture",
    				"pointgreyspinnaker",
    				"avfoundation",
    				"bluefish444",
    				"aja",
    				"ximea"
    			]
    		},
    		transfermode: {
    			type: "menu",
    			menuitems: [
    				"automatic",
    				"asynccpu",
    				"synccpu",
    				"gpudirect"
    			]
    		},
    		autogebias: {
    			type: "float"
    		},
    		aspect2: {
    			type: "float"
    		},
    		quadlink: {
    			type: "toggle"
    		},
    		precedence: {
    			type: "menu",
    			menuitems: [
    				"even",
    				"odd"
    			]
    		},
    		maxsyncoffset: {
    			type: "float"
    		},
    		ip: {
    			type: "string"
    		},
    		aspect1: {
    			type: "float"
    		},
    		device: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var embossTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		midpoint: {
    			type: "float"
    		},
    		direction: {
    			type: "float"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		offsetunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		select: {
    			type: "menu",
    			menuitems: [
    				"luminance",
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"rgbaverage",
    				"average"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		strength: {
    			type: "float"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"prevcur",
    				"curnext",
    				"prevnext"
    			]
    		},
    		offset1: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		offset2: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var videostreaminTOP = {
    	maxInputs: 0,
    	pars: {
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		networkqueuesize: {
    			type: "number"
    		},
    		asyncupload: {
    			type: "toggle"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		reload: {
    			type: "toggle"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		bottomhalfalpha: {
    			type: "toggle"
    		},
    		deinterlace: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"even",
    				"odd",
    				"bob"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		url: {
    			type: "string"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		prereadframes: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		precedence: {
    			type: "menu",
    			menuitems: [
    				"even",
    				"odd"
    			]
    		},
    		maxdecodecpus: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		play: {
    			type: "toggle"
    		},
    		reloadpulse: {
    			type: "pulse"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		networkbuffersize: {
    			type: "float"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var webrenderTOP = {
    	maxInputs: 0,
    	pars: {
    		transparent: {
    			type: "toggle"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		reload: {
    			type: "pulse"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		dat: {
    			type: "DAT"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		updatewhenloaded: {
    			type: "toggle"
    		},
    		resetcount: {
    			type: "pulse"
    		},
    		autorestartpulse: {
    			type: "pulse"
    		},
    		audio: {
    			type: "toggle"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		options: {
    			type: "string"
    		},
    		url: {
    			type: "string"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		usedat: {
    			type: "toggle"
    		},
    		autorestart: {
    			type: "toggle"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		aspect1: {
    			type: "float"
    		},
    		maxrenderrate: {
    			type: "number"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var layoutTOP = {
    	maxInputs: 9999,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		top: {
    			type: "TOP"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		maxcols: {
    			type: "number"
    		},
    		scaleres: {
    			type: "toggle"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		align: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"horizlr",
    				"horizrl",
    				"verttb",
    				"vertbt",
    				"gridrows",
    				"gridcols"
    			]
    		},
    		bgcolor: {
    			type: "rgba"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		maxrows: {
    			type: "number"
    		},
    		fit: {
    			type: "menu",
    			menuitems: [
    				"fill",
    				"fithorz",
    				"fitvert",
    				"fitbest",
    				"fitoutside",
    				"nativeres"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		fillbg: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var projectionTOP = {
    	maxInputs: 1,
    	pars: {
    		npasses: {
    			type: "number"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		output: {
    			type: "menu",
    			menuitems: [
    				"cubemap",
    				"equirectangular",
    				"fisheye"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		fov: {
    			type: "float"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		r: {
    			type: "xyz"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		input: {
    			type: "menu",
    			menuitems: [
    				"cubemap",
    				"equirectangular",
    				"fisheye",
    				"dualparaboloid"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var cubemapTOP = {
    	maxInputs: 6,
    	pars: {
    		npasses: {
    			type: "number"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		mode: {
    			type: "menu",
    			menuitems: [
    				"onepersidetocubemap",
    				"verticalcrosstocubemap",
    				"cubemaptoverticalcross",
    				"horizontalcrosstocubemap",
    				"cubemaptohorizontalcross"
    			]
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var rampTOP = {
    	maxInputs: 1,
    	pars: {
    		color3: {
    			type: "float"
    		},
    		position2: {
    			type: "float"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		extendleft: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"blockclamptoblack",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		color1: {
    			type: "float"
    		},
    		resolutionw: {
    			type: "number"
    		},
    		color2: {
    			type: "float"
    		},
    		extendright: {
    			type: "menu",
    			menuitems: [
    				"sameasleft",
    				"hold",
    				"black",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		fitaspect: {
    			type: "menu",
    			menuitems: [
    				"fill",
    				"fithorz",
    				"fitvert",
    				"fitbest"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"vertical",
    				"horizontal",
    				"radial",
    				"circular"
    			]
    		},
    		position1: {
    			type: "float"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		phase: {
    			type: "float"
    		},
    		period: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		multrgbbyalpha: {
    			type: "toggle"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		dat: {
    			type: "DAT"
    		},
    		aspect2: {
    			type: "float"
    		},
    		color4: {
    			type: "float"
    		},
    		dither: {
    			type: "toggle"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		tension: {
    			type: "float"
    		},
    		antialias: {
    			type: "number"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		interp: {
    			type: "menu",
    			menuitems: [
    				"step",
    				"linear",
    				"easeineaseout",
    				"hermite"
    			]
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var blurTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		size: {
    			type: "number"
    		},
    		offsetunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"catmull",
    				"gaussian",
    				"box",
    				"bartlette",
    				"sinc",
    				"hanning",
    				"blackman"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		extend: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"repeat",
    				"mirror"
    			]
    		},
    		rotate: {
    			type: "float"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		dither: {
    			type: "toggle"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"horzandvert",
    				"horz",
    				"vert"
    			]
    		},
    		offset1: {
    			type: "float"
    		},
    		preshrink: {
    			type: "number"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		offset2: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var substanceselectTOP = {
    	maxInputs: 0,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		substance: {
    			type: "TOP"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		output: {
    			type: "string"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var overTOP = {
    	maxInputs: 2,
    	pars: {
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		t: {
    			type: "xy"
    		},
    		size: {
    			type: "menu",
    			menuitems: [
    				"input1",
    				"input2"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"left",
    				"center",
    				"right"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		extend: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"bottom",
    				"center",
    				"top"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		s: {
    			type: "xy"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		punit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		p: {
    			type: "xy"
    		},
    		tunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		r: {
    			type: "float"
    		},
    		prefit: {
    			type: "menu",
    			menuitems: [
    				"fill",
    				"fithorz",
    				"fitvert",
    				"fitbest",
    				"fitoutside",
    				"nativeres"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 2,
    	type: "TOP"
    };
    var analyzeTOP = {
    	maxInputs: 1,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		select: {
    			type: "menu",
    			menuitems: [
    				"luminance",
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"rgbaverage",
    				"average"
    			]
    		},
    		op: {
    			type: "menu",
    			menuitems: [
    				"average",
    				"minimum",
    				"maximum"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		scope: {
    			type: "menu",
    			menuitems: [
    				"image",
    				"rows",
    				"columns"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var antialiasTOP = {
    	maxInputs: 1,
    	pars: {
    		maxsearchsteps: {
    			type: "number"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		edgedetectsource: {
    			type: "menu",
    			menuitems: [
    				"lum",
    				"rgb"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		quality: {
    			type: "menu",
    			menuitems: [
    				"low",
    				"medium",
    				"high",
    				"ultra",
    				"custom"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		outputedges: {
    			type: "toggle"
    		},
    		maxdiagsearchsteps: {
    			type: "number"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		edgethreshold: {
    			type: "float"
    		},
    		cornerrounding: {
    			type: "number"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var syphonspoutinTOP = {
    	maxInputs: 0,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		usespoutactivesender: {
    			type: "toggle"
    		},
    		npasses: {
    			type: "number"
    		},
    		sendername: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var scalabledisplayTOP = {
    	maxInputs: 1,
    	pars: {
    		configfile: {
    			type: "string"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		near: {
    			type: "float"
    		},
    		far: {
    			type: "float"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var multiplyTOP = {
    	maxInputs: 2,
    	pars: {
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		t: {
    			type: "xy"
    		},
    		size: {
    			type: "menu",
    			menuitems: [
    				"input1",
    				"input2"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"left",
    				"center",
    				"right"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		extend: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"bottom",
    				"center",
    				"top"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		s: {
    			type: "xy"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		punit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		p: {
    			type: "xy"
    		},
    		tunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		r: {
    			type: "float"
    		},
    		prefit: {
    			type: "menu",
    			menuitems: [
    				"fill",
    				"fithorz",
    				"fitvert",
    				"fitbest",
    				"fitoutside",
    				"nativeres"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 2,
    	type: "TOP"
    };
    var reorderTOP = {
    	maxInputs: 4,
    	pars: {
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		outputblue: {
    			type: "menu",
    			menuitems: [
    				"input1",
    				"input2",
    				"input3",
    				"input4"
    			]
    		},
    		outputred: {
    			type: "menu",
    			menuitems: [
    				"input1",
    				"input2",
    				"input3",
    				"input4"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		outputalpha: {
    			type: "menu",
    			menuitems: [
    				"input1",
    				"input2",
    				"input3",
    				"input4"
    			]
    		},
    		outputgreenchan: {
    			type: "menu",
    			menuitems: [
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"one",
    				"zero",
    				"luminance"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		outputredchan: {
    			type: "menu",
    			menuitems: [
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"one",
    				"zero",
    				"luminance"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		outputgreen: {
    			type: "menu",
    			menuitems: [
    				"input1",
    				"input2",
    				"input3",
    				"input4"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		outputbluechan: {
    			type: "menu",
    			menuitems: [
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"one",
    				"zero",
    				"luminance"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		outputalphachan: {
    			type: "menu",
    			menuitems: [
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"one",
    				"zero",
    				"luminance"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var edgeTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		offsetunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		select: {
    			type: "menu",
    			menuitems: [
    				"luminance",
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"rgbaverage",
    				"average"
    			]
    		},
    		alphaoutputmenu: {
    			type: "menu",
    			menuitems: [
    				"edge",
    				"one",
    				"zero"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		strength: {
    			type: "float"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		edgecolor: {
    			type: "rgba"
    		},
    		aspect2: {
    			type: "float"
    		},
    		compinput: {
    			type: "toggle"
    		},
    		blacklevel: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		offset1: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		offset2: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var openvrTOP = {
    	maxInputs: 2,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		active: {
    			type: "toggle"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		}
    	},
    	minInputs: 2,
    	type: "TOP"
    };
    var cornerpinTOP = {
    	maxInputs: 1,
    	pars: {
    		pinp12: {
    			type: "float"
    		},
    		extractp32: {
    			type: "float"
    		},
    		pinp11: {
    			type: "float"
    		},
    		extractp2unit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		pinp21: {
    			type: "float"
    		},
    		resolutionw: {
    			type: "number"
    		},
    		pinp1unit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		extractp41: {
    			type: "float"
    		},
    		extractp1unit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		extractp42: {
    			type: "float"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		extractp3unit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		bgcolor: {
    			type: "rgba"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		extend: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"repeat",
    				"mirror"
    			]
    		},
    		pinp3unit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		pinp32: {
    			type: "float"
    		},
    		pinp31: {
    			type: "float"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		extractp22: {
    			type: "float"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		gridrefine: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		extractp11: {
    			type: "float"
    		},
    		pinp4unit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		extractp31: {
    			type: "float"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		extractp12: {
    			type: "float"
    		},
    		pinp2unit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		extractp21: {
    			type: "float"
    		},
    		pinp42: {
    			type: "float"
    		},
    		extractp4unit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		pinp41: {
    			type: "float"
    		},
    		pinp22: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var opencolorioTOP = {
    	maxInputs: 1,
    	pars: {
    		resmult: {
    			type: "toggle"
    		},
    		saturation: {
    			type: "float"
    		},
    		config: {
    			type: "string"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		filedirection: {
    			type: "menu",
    			menuitems: [
    				"forward",
    				"inverse"
    			]
    		},
    		offset: {
    			type: "xyz"
    		},
    		resolutionw: {
    			type: "number"
    		},
    		precision: {
    			type: "menu",
    			menuitems: [
    				"auto",
    				"fixed8",
    				"fixed10",
    				"fixed16",
    				"float16",
    				"float32"
    			]
    		},
    		ccfile: {
    			type: "string"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		usecolorspacetransform: {
    			type: "toggle"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		slope: {
    			type: "xyz"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		cdlmode: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"values",
    				"ccfile"
    			]
    		},
    		useoutput: {
    			type: "toggle"
    		},
    		gain: {
    			type: "float"
    		},
    		filesource: {
    			type: "string"
    		},
    		lutsize: {
    			type: "number"
    		},
    		interpolation: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"tetrahedral",
    				"best"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		reloadconfig: {
    			type: "pulse"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		cdldirection: {
    			type: "menu",
    			menuitems: [
    				"forward",
    				"inverse"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		usefiletransform: {
    			type: "toggle"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		incolorspace: {
    			type: "string"
    		},
    		colorspace: {
    			type: "string"
    		},
    		view: {
    			type: "string"
    		},
    		gamma: {
    			type: "float"
    		},
    		outcolorspace: {
    			type: "string"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		power: {
    			type: "xyz"
    		},
    		display: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var sharedmeminTOP = {
    	maxInputs: 0,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		memtype: {
    			type: "menu",
    			menuitems: [
    				"local",
    				"global"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		name: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var glslmultiTOP = {
    	maxInputs: 9999,
    	pars: {
    		chopuniname1: {
    			type: "string"
    		},
    		value17: {
    			type: "xyzw"
    		},
    		value16: {
    			type: "xyzw"
    		},
    		dispatchsizey: {
    			type: "number"
    		},
    		acsize2: {
    			type: "number"
    		},
    		uniname27: {
    			type: "string"
    		},
    		pixeldat: {
    			type: "DAT"
    		},
    		uniname12: {
    			type: "string"
    		},
    		uniname24: {
    			type: "string"
    		},
    		value12: {
    			type: "xyzw"
    		},
    		outputaccess: {
    			type: "menu",
    			menuitems: [
    				"writeonly",
    				"readonly",
    				"readwrite"
    			]
    		},
    		acsingleval1: {
    			type: "number"
    		},
    		uniname8: {
    			type: "string"
    		},
    		value28: {
    			type: "xyzw"
    		},
    		matvalue4: {
    			type: "OP"
    		},
    		acchopval1: {
    			type: "CHOP"
    		},
    		uniname7: {
    			type: "string"
    		},
    		depth: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"custom"
    			]
    		},
    		matvalue9: {
    			type: "OP"
    		},
    		chopuniname4: {
    			type: "string"
    		},
    		acsingleval3: {
    			type: "number"
    		},
    		chopuniname9: {
    			type: "string"
    		},
    		value18: {
    			type: "xyzw"
    		},
    		chopuniname3: {
    			type: "string"
    		},
    		nval: {
    			type: "number"
    		},
    		mode: {
    			type: "menu",
    			menuitems: [
    				"vertexpixel",
    				"compute"
    			]
    		},
    		chopunitype8: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		uniname17: {
    			type: "string"
    		},
    		uniname10: {
    			type: "string"
    		},
    		choparraytype7: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		choparraytype2: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		chopunitype6: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		chopunitype4: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		matvalue0: {
    			type: "OP"
    		},
    		uniname26: {
    			type: "string"
    		},
    		numcolorbufs: {
    			type: "number"
    		},
    		value10: {
    			type: "xyzw"
    		},
    		value11: {
    			type: "xyzw"
    		},
    		matvalue7: {
    			type: "OP"
    		},
    		uniname4: {
    			type: "string"
    		},
    		uniname15: {
    			type: "string"
    		},
    		uniname16: {
    			type: "string"
    		},
    		computedat: {
    			type: "DAT"
    		},
    		value13: {
    			type: "xyzw"
    		},
    		matvalue1: {
    			type: "OP"
    		},
    		acsize3: {
    			type: "number"
    		},
    		chop1: {
    			type: "CHOP"
    		},
    		matuniname6: {
    			type: "string"
    		},
    		chopuniname6: {
    			type: "string"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		value24: {
    			type: "xyzw"
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"texture2d",
    				"texture2darray",
    				"texture3d"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		glslversion: {
    			type: "menu",
    			menuitems: [
    				"glsl120",
    				"glsl330",
    				"glsl400",
    				"glsl410",
    				"glsl420",
    				"glsl430",
    				"glsl440",
    				"glsl450",
    				"glsl460"
    			]
    		},
    		value19: {
    			type: "xyzw"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		chop6: {
    			type: "CHOP"
    		},
    		chopuniname7: {
    			type: "string"
    		},
    		matvalue3: {
    			type: "OP"
    		},
    		value0: {
    			type: "xyzw"
    		},
    		acinitval1: {
    			type: "menu",
    			menuitems: [
    				"val",
    				"chop"
    			]
    		},
    		chopunitype2: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		acsize1: {
    			type: "number"
    		},
    		value8: {
    			type: "xyzw"
    		},
    		matuniname7: {
    			type: "string"
    		},
    		value14: {
    			type: "xyzw"
    		},
    		acinitval2: {
    			type: "menu",
    			menuitems: [
    				"val",
    				"chop"
    			]
    		},
    		choparraytype4: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		acbinding3: {
    			type: "number"
    		},
    		value7: {
    			type: "xyzw"
    		},
    		acinitval3: {
    			type: "menu",
    			menuitems: [
    				"val",
    				"chop"
    			]
    		},
    		choparraytype6: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		chopuniname0: {
    			type: "string"
    		},
    		chopunitype7: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		uniname13: {
    			type: "string"
    		},
    		uniname23: {
    			type: "string"
    		},
    		value29: {
    			type: "xyzw"
    		},
    		value21: {
    			type: "xyzw"
    		},
    		uniname20: {
    			type: "string"
    		},
    		aspect2: {
    			type: "float"
    		},
    		choparraytype8: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		value27: {
    			type: "xyzw"
    		},
    		uniname5: {
    			type: "string"
    		},
    		inputmapping: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"ninputs"
    			]
    		},
    		chop9: {
    			type: "CHOP"
    		},
    		matvalue8: {
    			type: "OP"
    		},
    		matvalue5: {
    			type: "OP"
    		},
    		chop5: {
    			type: "CHOP"
    		},
    		uniname25: {
    			type: "string"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		value4: {
    			type: "xyzw"
    		},
    		chopunitype3: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		uniname2: {
    			type: "string"
    		},
    		value22: {
    			type: "xyzw"
    		},
    		acsingleval2: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		vertexdat: {
    			type: "DAT"
    		},
    		chopunitype0: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		matvalue6: {
    			type: "OP"
    		},
    		clearvalue: {
    			type: "rgba"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		matuniname9: {
    			type: "string"
    		},
    		value9: {
    			type: "xyzw"
    		},
    		value6: {
    			type: "xyzw"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		dispatchsizez: {
    			type: "number"
    		},
    		inputextenduv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		uniname18: {
    			type: "string"
    		},
    		chop3: {
    			type: "CHOP"
    		},
    		customdepth: {
    			type: "number"
    		},
    		matuniname8: {
    			type: "string"
    		},
    		uniname19: {
    			type: "string"
    		},
    		chop7: {
    			type: "CHOP"
    		},
    		chopuniname2: {
    			type: "string"
    		},
    		matuniname3: {
    			type: "string"
    		},
    		acbinding1: {
    			type: "number"
    		},
    		uniname1: {
    			type: "string"
    		},
    		uniname22: {
    			type: "string"
    		},
    		uniname3: {
    			type: "string"
    		},
    		uniname6: {
    			type: "string"
    		},
    		uniname9: {
    			type: "string"
    		},
    		value26: {
    			type: "xyzw"
    		},
    		chopuniname5: {
    			type: "string"
    		},
    		dispatchsizex: {
    			type: "number"
    		},
    		value3: {
    			type: "xyzw"
    		},
    		choparraytype9: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		chop2: {
    			type: "CHOP"
    		},
    		acchopval3: {
    			type: "CHOP"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		acchopval2: {
    			type: "CHOP"
    		},
    		value25: {
    			type: "xyzw"
    		},
    		inputextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		value15: {
    			type: "xyzw"
    		},
    		value23: {
    			type: "xyzw"
    		},
    		matuniname0: {
    			type: "string"
    		},
    		loaduniformnames: {
    			type: "pulse"
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		choparraytype0: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		value1: {
    			type: "xyzw"
    		},
    		enablevectorpage3: {
    			type: "toggle"
    		},
    		chop0: {
    			type: "CHOP"
    		},
    		aspect1: {
    			type: "float"
    		},
    		choparraytype5: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		acchopval0: {
    			type: "CHOP"
    		},
    		uniname14: {
    			type: "string"
    		},
    		matuniname5: {
    			type: "string"
    		},
    		value20: {
    			type: "xyzw"
    		},
    		chopunitype9: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		matuniname1: {
    			type: "string"
    		},
    		value2: {
    			type: "xyzw"
    		},
    		uniname11: {
    			type: "string"
    		},
    		chopuniname8: {
    			type: "string"
    		},
    		acbinding2: {
    			type: "number"
    		},
    		uniname0: {
    			type: "string"
    		},
    		resolutionw: {
    			type: "number"
    		},
    		chop8: {
    			type: "CHOP"
    		},
    		choparraytype3: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		choparraytype1: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		acsingleval0: {
    			type: "number"
    		},
    		clearoutputs: {
    			type: "toggle"
    		},
    		uniname28: {
    			type: "string"
    		},
    		acbinding0: {
    			type: "number"
    		},
    		matvalue2: {
    			type: "OP"
    		},
    		acsize0: {
    			type: "number"
    		},
    		acinitval0: {
    			type: "menu",
    			menuitems: [
    				"val",
    				"chop"
    			]
    		},
    		value5: {
    			type: "xyzw"
    		},
    		chop4: {
    			type: "CHOP"
    		},
    		matuniname4: {
    			type: "string"
    		},
    		matuniname2: {
    			type: "string"
    		},
    		uniname29: {
    			type: "string"
    		},
    		chopunitype5: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		chopunitype1: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		uniname21: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var compositeTOP = {
    	maxInputs: 9999,
    	pars: {
    		npasses: {
    			type: "number"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		top: {
    			type: "TOP"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		t: {
    			type: "xy"
    		},
    		size: {
    			type: "menu",
    			menuitems: [
    				"input1",
    				"input2"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		tstepunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"left",
    				"center",
    				"right"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		extend: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		inputindex: {
    			type: "number"
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"bottom",
    				"center",
    				"top"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		swaporder: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		punit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		s: {
    			type: "xy"
    		},
    		operand: {
    			type: "menu",
    			menuitems: [
    				"add",
    				"atop",
    				"average",
    				"brightest",
    				"burncolor",
    				"burnlinear",
    				"chromadifference",
    				"color",
    				"darkercolor",
    				"difference",
    				"dimmest",
    				"divide",
    				"dodge",
    				"exclude",
    				"freeze",
    				"glow",
    				"hardlight",
    				"hardmix",
    				"heat",
    				"hue",
    				"inside",
    				"insideluminance",
    				"inverse",
    				"lightercolor",
    				"luminancedifference",
    				"maximum",
    				"minimum",
    				"multiply",
    				"negate",
    				"outside",
    				"outsideluminance",
    				"over",
    				"overlay",
    				"pinlight",
    				"reflect",
    				"screen",
    				"softlight",
    				"linearlight",
    				"stencilluminance",
    				"subtract",
    				"subtractive",
    				"under",
    				"vividlight",
    				"xor",
    				"yfilm",
    				"zfilm"
    			]
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		p: {
    			type: "xy"
    		},
    		tunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		r: {
    			type: "float"
    		},
    		prefit: {
    			type: "menu",
    			menuitems: [
    				"fill",
    				"fithorz",
    				"fitvert",
    				"fitbest",
    				"fitoutside",
    				"nativeres"
    			]
    		},
    		previewgrid: {
    			type: "toggle"
    		},
    		selectinput: {
    			type: "toggle"
    		},
    		tstep: {
    			type: "xy"
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var substanceTOP = {
    	maxInputs: 0,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		graph: {
    			type: "string"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		reloadconfig: {
    			type: "pulse"
    		},
    		output: {
    			type: "string"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		file: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var cacheselectTOP = {
    	maxInputs: 0,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		cachetop: {
    			type: "TOP"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		index: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var inTOP = {
    	maxInputs: 1,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		label: {
    			type: "string"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var underTOP = {
    	maxInputs: 2,
    	pars: {
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		t: {
    			type: "xy"
    		},
    		size: {
    			type: "menu",
    			menuitems: [
    				"input1",
    				"input2"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"left",
    				"center",
    				"right"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		extend: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"bottom",
    				"center",
    				"top"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		s: {
    			type: "xy"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		punit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		p: {
    			type: "xy"
    		},
    		tunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		r: {
    			type: "float"
    		},
    		prefit: {
    			type: "menu",
    			menuitems: [
    				"fill",
    				"fithorz",
    				"fitvert",
    				"fitbest",
    				"fitoutside",
    				"nativeres"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 2,
    	type: "TOP"
    };
    var timemachineTOP = {
    	maxInputs: 2,
    	pars: {
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		blackoffset: {
    			type: "float"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		blackoffsetunit: {
    			type: "menu",
    			menuitems: [
    				"indices",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		whiteoffset: {
    			type: "float"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		whiteoffsetunit: {
    			type: "menu",
    			menuitems: [
    				"indices",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		}
    	},
    	minInputs: 2,
    	type: "TOP"
    };
    var addTOP = {
    	maxInputs: 2,
    	pars: {
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		t: {
    			type: "xy"
    		},
    		size: {
    			type: "menu",
    			menuitems: [
    				"input1",
    				"input2"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"left",
    				"center",
    				"right"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		extend: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"bottom",
    				"center",
    				"top"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		s: {
    			type: "xy"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		punit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		p: {
    			type: "xy"
    		},
    		tunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		r: {
    			type: "float"
    		},
    		prefit: {
    			type: "menu",
    			menuitems: [
    				"fill",
    				"fithorz",
    				"fitvert",
    				"fitbest",
    				"fitoutside",
    				"nativeres"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 2,
    	type: "TOP"
    };
    var remapTOP = {
    	maxInputs: 2,
    	pars: {
    		npasses: {
    			type: "number"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		flipvert: {
    			type: "toggle"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		horzsource: {
    			type: "menu",
    			menuitems: [
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"none"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		fliphorz: {
    			type: "toggle"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		vertsource: {
    			type: "menu",
    			menuitems: [
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"none"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		extend: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		}
    	},
    	minInputs: 2,
    	type: "TOP"
    };
    var oculusriftTOP = {
    	maxInputs: 2,
    	pars: {
    		debugperfhud: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"latency",
    				"render"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 2,
    	type: "TOP"
    };
    var circleTOP = {
    	maxInputs: 1,
    	pars: {
    		npasses: {
    			type: "number"
    		},
    		antialias: {
    			type: "toggle"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		ispolygon: {
    			type: "toggle"
    		},
    		bgcolor: {
    			type: "rgb"
    		},
    		borderwidthunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		radius: {
    			type: "xy"
    		},
    		centerunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		softness: {
    			type: "float"
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		borderalpha: {
    			type: "float"
    		},
    		center: {
    			type: "xy"
    		},
    		multrgbbyalpha: {
    			type: "toggle"
    		},
    		radiusunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		rotate: {
    			type: "float"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		sides: {
    			type: "number"
    		},
    		aspect1: {
    			type: "float"
    		},
    		beginarcangle: {
    			type: "float"
    		},
    		aspect2: {
    			type: "float"
    		},
    		endarcangle: {
    			type: "float"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		bgalpha: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		borderoffset: {
    			type: "float"
    		},
    		borderwidth: {
    			type: "float"
    		},
    		softnessunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		fillalpha: {
    			type: "float"
    		},
    		fillcolor: {
    			type: "rgb"
    		},
    		border: {
    			type: "rgb"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var svgTOP = {
    	maxInputs: 0,
    	pars: {
    		npasses: {
    			type: "number"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		r: {
    			type: "xyz"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		t: {
    			type: "xy"
    		},
    		reload: {
    			type: "toggle"
    		},
    		dat: {
    			type: "DAT"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		bgcolor: {
    			type: "rgb"
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		s: {
    			type: "xy"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		punit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		bgalpha: {
    			type: "float"
    		},
    		p: {
    			type: "xy"
    		},
    		antialias: {
    			type: "menu",
    			menuitems: [
    				"aa1",
    				"aa2",
    				"aa4",
    				"aa8mid",
    				"aa8high",
    				"aa16low",
    				"aa16mid",
    				"aa16high",
    				"aa32"
    			]
    		},
    		tunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		file: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var touchoutTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		fps: {
    			type: "number"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		videocodec: {
    			type: "menu",
    			menuitems: [
    				"uncompressed",
    				"hapq",
    				"hapqalpha"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		port: {
    			type: "number"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		alwayscook: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var directxoutTOP = {
    	maxInputs: 1,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		active: {
    			type: "toggle"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		queuesize: {
    			type: "number"
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var screengrabTOP = {
    	maxInputs: 0,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		delayed: {
    			type: "toggle"
    		},
    		top: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		leftunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		topunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		left: {
    			type: "float"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		aspect1: {
    			type: "float"
    		},
    		bottom: {
    			type: "float"
    		},
    		rightunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		activepulse: {
    			type: "pulse"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		bottomunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		right: {
    			type: "float"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var differenceTOP = {
    	maxInputs: 2,
    	pars: {
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		t: {
    			type: "xy"
    		},
    		size: {
    			type: "menu",
    			menuitems: [
    				"input1",
    				"input2"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"left",
    				"center",
    				"right"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		extend: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"bottom",
    				"center",
    				"top"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		s: {
    			type: "xy"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		punit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		p: {
    			type: "xy"
    		},
    		tunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		r: {
    			type: "float"
    		},
    		prefit: {
    			type: "menu",
    			menuitems: [
    				"fill",
    				"fithorz",
    				"fitvert",
    				"fitbest",
    				"fitoutside",
    				"nativeres"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 2,
    	type: "TOP"
    };
    var normalmapTOP = {
    	maxInputs: 1,
    	pars: {
    		npasses: {
    			type: "number"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		heightmap: {
    			type: "toggle"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		offsetunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"prevcur",
    				"curnext",
    				"prevnext"
    			]
    		},
    		offset1: {
    			type: "float"
    		},
    		source: {
    			type: "menu",
    			menuitems: [
    				"luminance",
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"rgbaverage",
    				"average"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		offset2: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var lumablurTOP = {
    	maxInputs: 2,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"catmull",
    				"gaussian",
    				"box",
    				"bartlette",
    				"sinc",
    				"hanning",
    				"blackman"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		whitevalue: {
    			type: "float"
    		},
    		blackvalue: {
    			type: "float"
    		},
    		whitewidth: {
    			type: "number"
    		},
    		extend: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		widthchan: {
    			type: "menu",
    			menuitems: [
    				"luminance",
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"rgbaverage",
    				"average"
    			]
    		},
    		blackwidth: {
    			type: "number"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 2,
    	type: "TOP"
    };
    var feedbackTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		top: {
    			type: "TOP"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		reset: {
    			type: "toggle"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var directxinTOP = {
    	maxInputs: 0,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		handle: {
    			type: "string"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var nullTOP = {
    	maxInputs: 1,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var noiseTOP = {
    	maxInputs: 2,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		mono: {
    			type: "toggle"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		harmon: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		offset: {
    			type: "float"
    		},
    		resolutionw: {
    			type: "number"
    		},
    		gain: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		aspectcorrect: {
    			type: "toggle"
    		},
    		inputscale: {
    			type: "float"
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"perlin2d",
    				"perlin3d",
    				"perlin4d",
    				"simplex2d",
    				"simplex3d",
    				"simplex4d",
    				"randomgpu",
    				"sparse",
    				"hermite",
    				"harmonic",
    				"random",
    				"alligator"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		rgb: {
    			type: "menu",
    			menuitems: [
    				"noise",
    				"multiply",
    				"add",
    				"subtract"
    			]
    		},
    		period: {
    			type: "float"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		t4d: {
    			type: "float"
    		},
    		noisescale: {
    			type: "float"
    		},
    		spread: {
    			type: "float"
    		},
    		aspect1: {
    			type: "float"
    		},
    		p: {
    			type: "xyz"
    		},
    		r: {
    			type: "xyz"
    		},
    		s: {
    			type: "xyz"
    		},
    		alpha: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"one",
    				"random",
    				"input",
    				"multiply",
    				"add",
    				"addclamp"
    			]
    		},
    		dither: {
    			type: "toggle"
    		},
    		seed: {
    			type: "float"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		exp: {
    			type: "float"
    		},
    		rough: {
    			type: "float"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		amp: {
    			type: "float"
    		},
    		t: {
    			type: "xyz"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		s4d: {
    			type: "float"
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var constantTOP = {
    	maxInputs: 1,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		alpha: {
    			type: "float"
    		},
    		color: {
    			type: "rgb"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		rgbaunit: {
    			type: "menu",
    			menuitems: [
    				"u1",
    				"u256",
    				"u65536"
    			]
    		},
    		multrgbbyalpha: {
    			type: "toggle"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var touchinTOP = {
    	maxInputs: 0,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		maxqueue: {
    			type: "float"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		address: {
    			type: "string"
    		},
    		mintarget: {
    			type: "float"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		port: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		targetdelay: {
    			type: "float"
    		},
    		maxtarget: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var kinectTOP = {
    	maxInputs: 0,
    	pars: {
    		unknownvalue: {
    			type: "float"
    		},
    		sensor: {
    			type: "string"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		unknownpointvalue: {
    			type: "menu",
    			menuitems: [
    				"onehundred",
    				"neginfinite"
    			]
    		},
    		skeleton: {
    			type: "menu",
    			menuitems: [
    				"full",
    				"seated"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		neardepthmode: {
    			type: "toggle"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		hwversion: {
    			type: "menu",
    			menuitems: [
    				"version1",
    				"version2"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		image: {
    			type: "menu",
    			menuitems: [
    				"color",
    				"depth",
    				"rawdepth",
    				"infrared",
    				"playerindex",
    				"colorpointcloud"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		tooclosevalue: {
    			type: "float"
    		},
    		camerares: {
    			type: "menu",
    			menuitems: [
    				"80x60",
    				"320x240",
    				"640x480"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		mirrorimage: {
    			type: "toggle"
    		},
    		remap: {
    			type: "toggle"
    		},
    		resolutionw: {
    			type: "number"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		toofarvalue: {
    			type: "float"
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var blobtrackTOP = {
    	maxInputs: 1,
    	pars: {
    		resmult: {
    			type: "toggle"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		maxblobsize: {
    			type: "float"
    		},
    		maxmovedistance: {
    			type: "float"
    		},
    		blobcolor: {
    			type: "rgb"
    		},
    		resolutionw: {
    			type: "number"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		drawblobs: {
    			type: "toggle"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		revivedistance: {
    			type: "float"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		deletenearbytol: {
    			type: "float"
    		},
    		revivetime: {
    			type: "float"
    		},
    		deleteoverlap: {
    			type: "toggle"
    		},
    		monosource: {
    			type: "menu",
    			menuitems: [
    				"luminance",
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"rgbaverage",
    				"average"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		deleteoverlaptol: {
    			type: "float"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		revivearea: {
    			type: "float"
    		},
    		deletenearby: {
    			type: "toggle"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		minblobsize: {
    			type: "float"
    		},
    		aspect2: {
    			type: "float"
    		},
    		reviveblobs: {
    			type: "toggle"
    		},
    		deletedist: {
    			type: "float"
    		},
    		reset: {
    			type: "toggle"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var chromakeyTOP = {
    	maxInputs: 1,
    	pars: {
    		satmin: {
    			type: "float"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		hsofthigh: {
    			type: "float"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		huemin: {
    			type: "float"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		hsoftlow: {
    			type: "float"
    		},
    		rgbout: {
    			type: "menu",
    			menuitems: [
    				"multalpha",
    				"newalpha"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		vsofthigh: {
    			type: "float"
    		},
    		ssoftlow: {
    			type: "float"
    		},
    		huemax: {
    			type: "float"
    		},
    		alphaout: {
    			type: "menu",
    			menuitems: [
    				"newalpha1",
    				"multnewalpha"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		vsoftlow: {
    			type: "float"
    		},
    		valmin: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		invert: {
    			type: "float"
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		ssofthigh: {
    			type: "float"
    		},
    		valmax: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		satmax: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var selectTOP = {
    	maxInputs: 0,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		top: {
    			type: "TOP"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var ssaoTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		ssaoradius: {
    			type: "float"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		surfaceavoid: {
    			type: "float"
    		},
    		blursharpness: {
    			type: "float"
    		},
    		combinewithcolor: {
    			type: "toggle"
    		},
    		quality: {
    			type: "menu",
    			menuitems: [
    				"low",
    				"medium"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		attenuation: {
    			type: "float"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		contrast: {
    			type: "float"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		samplesteps: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		sampledirs: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		ssaopassres: {
    			type: "menu",
    			menuitems: [
    				"full",
    				"half",
    				"quarter"
    			]
    		},
    		blurradius: {
    			type: "float"
    		},
    		edgethresh: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var prefiltermapTOP = {
    	maxInputs: 1,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		output: {
    			type: "menu",
    			menuitems: [
    				"envlightdiffuse",
    				"envlightspecular"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var viosoTOP = {
    	maxInputs: 1,
    	pars: {
    		projectorindex: {
    			type: "number"
    		},
    		filter: {
    			type: "menu",
    			menuitems: [
    				"linear",
    				"cubic"
    			]
    		},
    		configfile: {
    			type: "string"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var cropTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		cropleftunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		croptop: {
    			type: "float"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		croprightunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		cropbottomunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		extend: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		cropleft: {
    			type: "float"
    		},
    		cropbottom: {
    			type: "float"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		cropright: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		croptopunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var rgbtohsvTOP = {
    	maxInputs: 1,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var videodeviceoutTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		library: {
    			type: "menu",
    			menuitems: [
    				"blackmagic",
    				"bluefish444",
    				"aja"
    			]
    		},
    		audiobitdepth: {
    			type: "menu",
    			menuitems: [
    				"16bit",
    				"32bit"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		bufferlength: {
    			type: "float"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		firstfield: {
    			type: "toggle"
    		},
    		manualfield: {
    			type: "toggle"
    		},
    		chop: {
    			type: "CHOP"
    		},
    		active: {
    			type: "toggle"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		transfermode: {
    			type: "menu",
    			menuitems: [
    				"automatic",
    				"async",
    				"gpudirect"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		signalformat: {
    			type: "string"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		outputpixelformat: {
    			type: "menu",
    			menuitems: [
    				"fixed8",
    				"fixed8key8",
    				"fixed10"
    			]
    		},
    		device: {
    			type: "string"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var transformTOP = {
    	maxInputs: 1,
    	pars: {
    		npasses: {
    			type: "number"
    		},
    		compover: {
    			type: "toggle"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		t: {
    			type: "xy"
    		},
    		growshrink: {
    			type: "xy"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		tilev2: {
    			type: "float"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		bgcolor: {
    			type: "rgba"
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		extend: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		tilev1: {
    			type: "float"
    		},
    		rotate: {
    			type: "float"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		mipmapbias: {
    			type: "float"
    		},
    		s: {
    			type: "xy"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		punit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		p: {
    			type: "xy"
    		},
    		tunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		limittiles: {
    			type: "toggle"
    		},
    		tileu2: {
    			type: "float"
    		},
    		tileu1: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var opviewerTOP = {
    	maxInputs: 1,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		allowpanel: {
    			type: "toggle"
    		},
    		aspect2: {
    			type: "float"
    		},
    		preservealpha: {
    			type: "toggle"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		opviewer: {
    			type: "OP"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var matteTOP = {
    	maxInputs: 3,
    	pars: {
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		switchinputs: {
    			type: "float"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		mattechannel: {
    			type: "menu",
    			menuitems: [
    				"luminance",
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"rgbaverage",
    				"average"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 3,
    	type: "TOP"
    };
    var hsvadjustTOP = {
    	maxInputs: 1,
    	pars: {
    		valuefalloff: {
    			type: "float"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		saturationrange: {
    			type: "float"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		huefalloff: {
    			type: "float"
    		},
    		hueoffset: {
    			type: "float"
    		},
    		saturationfalloff: {
    			type: "float"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		huerange: {
    			type: "float"
    		},
    		valuemult: {
    			type: "float"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		valuerange: {
    			type: "float"
    		},
    		saturationmult: {
    			type: "float"
    		},
    		startcolor: {
    			type: "rgb"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var rgbkeyTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		gsofthigh: {
    			type: "float"
    		},
    		rsoftlow: {
    			type: "float"
    		},
    		gsoftlow: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		redmin: {
    			type: "float"
    		},
    		bsoftlow: {
    			type: "float"
    		},
    		bluemin: {
    			type: "float"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		greenmax: {
    			type: "float"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		rgbout: {
    			type: "menu",
    			menuitems: [
    				"multalpha",
    				"newalpha"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		greenmin: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		alphaout: {
    			type: "menu",
    			menuitems: [
    				"newalpha1",
    				"multnewalpha"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		rsofthigh: {
    			type: "float"
    		},
    		redmax: {
    			type: "float"
    		},
    		aspect2: {
    			type: "float"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		bsofthigh: {
    			type: "float"
    		},
    		bluemax: {
    			type: "float"
    		},
    		resolutionw: {
    			type: "number"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		invert: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var fitTOP = {
    	maxInputs: 1,
    	pars: {
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		t: {
    			type: "xy"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		bgcolor: {
    			type: "rgba"
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		fit: {
    			type: "menu",
    			menuitems: [
    				"fill",
    				"fithorz",
    				"fitvert",
    				"fitbest",
    				"fitoutside",
    				"nativeres"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		s: {
    			type: "xy"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		punit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		tunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		r: {
    		},
    		p: {
    			type: "xy"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var texture3dTOP = {
    	maxInputs: 1,
    	pars: {
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		replaceindex: {
    			type: "number"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"texture3d",
    				"texture2darray"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		resetsinglepulse: {
    			type: "pulse"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		step: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		replacesingle: {
    			type: "toggle"
    		},
    		npasses: {
    			type: "number"
    		},
    		prefillpulse: {
    			type: "pulse"
    		},
    		prefill: {
    			type: "toggle"
    		},
    		reset: {
    			type: "toggle"
    		},
    		cachesize: {
    			type: "number"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var crossTOP = {
    	maxInputs: 2,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		t: {
    			type: "xy"
    		},
    		size: {
    			type: "menu",
    			menuitems: [
    				"input1",
    				"input2"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		cross: {
    			type: "float"
    		},
    		extend: {
    			type: "menu",
    			menuitems: [
    				"clamp",
    				"hold",
    				"repeat",
    				"mirror"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		s: {
    			type: "xy"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		punit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		p: {
    			type: "xy"
    		},
    		tunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		r: {
    			type: "float"
    		},
    		prefit: {
    			type: "menu",
    			menuitems: [
    				"fill",
    				"fithorz",
    				"fitvert",
    				"fitbest",
    				"fitworst",
    				"nativeres"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 2,
    	type: "TOP"
    };
    var monochromeTOP = {
    	maxInputs: 1,
    	pars: {
    		mono: {
    			type: "float"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		alpha: {
    			type: "menu",
    			menuitems: [
    				"luminance",
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"rgbaverage",
    				"average"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		rgb: {
    			type: "menu",
    			menuitems: [
    				"luminance",
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"rgbaverage",
    				"average"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var leapmotionTOP = {
    	maxInputs: 0,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		correction: {
    			type: "toggle"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		flipx: {
    			type: "toggle"
    		},
    		camera: {
    			type: "string"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		hmd: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"on",
    				"off"
    			]
    		},
    		flipy: {
    			type: "toggle"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var resolutionTOP = {
    	maxInputs: 1,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		highqualresize: {
    			type: "toggle"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var thresholdTOP = {
    	maxInputs: 1,
    	pars: {
    		npasses: {
    			type: "number"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		comparator: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"greater",
    				"lessorequal",
    				"greaterorequal",
    				"equal",
    				"notequal"
    			]
    		},
    		alpha: {
    			type: "menu",
    			menuitems: [
    				"same",
    				"one"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		soften: {
    			type: "float"
    		},
    		aspect2: {
    			type: "float"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		rgb: {
    			type: "menu",
    			menuitems: [
    				"luminance",
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"rgbaverage",
    				"average"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		threshold: {
    			type: "float"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var subtractTOP = {
    	maxInputs: 2,
    	pars: {
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		t: {
    			type: "xy"
    		},
    		size: {
    			type: "menu",
    			menuitems: [
    				"input1",
    				"input2"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"left",
    				"center",
    				"right"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		extend: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"bottom",
    				"center",
    				"top"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		s: {
    			type: "xy"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		punit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		p: {
    			type: "xy"
    		},
    		tunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		r: {
    			type: "float"
    		},
    		prefit: {
    			type: "menu",
    			menuitems: [
    				"fill",
    				"fithorz",
    				"fitvert",
    				"fitbest",
    				"fitoutside",
    				"nativeres"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 2,
    	type: "TOP"
    };
    var outsideTOP = {
    	maxInputs: 2,
    	pars: {
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		t: {
    			type: "xy"
    		},
    		size: {
    			type: "menu",
    			menuitems: [
    				"input1",
    				"input2"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"left",
    				"center",
    				"right"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		extend: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"bottom",
    				"center",
    				"top"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		s: {
    			type: "xy"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		punit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		p: {
    			type: "xy"
    		},
    		tunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		r: {
    			type: "float"
    		},
    		prefit: {
    			type: "menu",
    			menuitems: [
    				"fill",
    				"fithorz",
    				"fitvert",
    				"fitbest",
    				"fitoutside",
    				"nativeres"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 2,
    	type: "TOP"
    };
    var lumalevelTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		opacity: {
    			type: "float"
    		},
    		clamplow: {
    			type: "float"
    		},
    		brightness2: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		stepsize: {
    			type: "float"
    		},
    		clamphigh: {
    			type: "float"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		soften: {
    			type: "float"
    		},
    		inhigh: {
    			type: "float"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		gamma2: {
    			type: "float"
    		},
    		threshold: {
    			type: "float"
    		},
    		outlow: {
    			type: "float"
    		},
    		brightness1: {
    			type: "float"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		contrast: {
    			type: "float"
    		},
    		gamma1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		source: {
    			type: "menu",
    			menuitems: [
    				"luminance",
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"rgbaverage",
    				"average"
    			]
    		},
    		invert: {
    			type: "float"
    		},
    		aspect2: {
    			type: "float"
    		},
    		blacklevel: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		outhigh: {
    			type: "float"
    		},
    		inlow: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var cacheTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		replaceindex: {
    			type: "number"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		cacheonce: {
    			type: "toggle"
    		},
    		outputindex: {
    			type: "float"
    		},
    		interp: {
    			type: "toggle"
    		},
    		alwayscook: {
    			type: "toggle"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		step: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		activepulse: {
    			type: "pulse"
    		},
    		npasses: {
    			type: "number"
    		},
    		prefillpulse: {
    			type: "pulse"
    		},
    		outputindexunit: {
    			type: "menu",
    			menuitems: [
    				"indices",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		replacespulse: {
    			type: "pulse"
    		},
    		reset: {
    			type: "toggle"
    		},
    		cachesize: {
    			type: "number"
    		},
    		replace: {
    			type: "toggle"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		prefill: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var flipTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		flop: {
    			type: "menu",
    			menuitems: [
    				"noflop",
    				"bottomleft",
    				"topleft"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		flipx: {
    			type: "toggle"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		flipy: {
    			type: "toggle"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var mathTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		postop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"negate",
    				"pos",
    				"root",
    				"square",
    				"inverse"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		preoff: {
    			type: "float"
    		},
    		inputmask: {
    			type: "menu",
    			menuitems: null
    		},
    		fromrange1: {
    			type: "float"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		postoff: {
    			type: "float"
    		},
    		chanop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"add",
    				"sub",
    				"mul",
    				"div",
    				"avg",
    				"min",
    				"max",
    				"len"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		fromrange2: {
    			type: "float"
    		},
    		integer: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"ceiling",
    				"floor",
    				"round"
    			]
    		},
    		preop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"negate",
    				"pos",
    				"root",
    				"square",
    				"inverse"
    			]
    		},
    		outputchannels: {
    			type: "menu",
    			menuitems: null
    		},
    		aspect2: {
    			type: "float"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		torange1: {
    			type: "float"
    		},
    		torange2: {
    			type: "float"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		op: {
    			type: "menu",
    			menuitems: [
    				"no_op",
    				"rgbmultalpha",
    				"rgbdivalpha",
    				"rgbdivalphafill"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		gain: {
    			type: "float"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var tileTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		reflectx: {
    			type: "toggle"
    		},
    		flop: {
    			type: "toggle"
    		},
    		cropleftunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		croptop: {
    			type: "float"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		flipx: {
    			type: "toggle"
    		},
    		croprightunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		repeaty: {
    			type: "number"
    		},
    		overlapu: {
    			type: "float"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		flipy: {
    			type: "toggle"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		cropleft: {
    			type: "float"
    		},
    		croptopunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		cropbottom: {
    			type: "float"
    		},
    		overlapuunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		repeatx: {
    			type: "number"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		cropbottomunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		cropright: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		reflecty: {
    			type: "toggle"
    		},
    		overlapvunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		overlapv: {
    			type: "float"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var renderTOP = {
    	maxInputs: 0,
    	pars: {
    		top2extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		overridemat: {
    			type: "MAT"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		top2anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		value4: {
    			type: "xyzw"
    		},
    		uniname2: {
    			type: "string"
    		},
    		top2filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		top4extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		cropbottomunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		top4filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		cropbottom: {
    			type: "float"
    		},
    		sampler2: {
    			type: "string"
    		},
    		top1extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		top0extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		sampler4: {
    			type: "string"
    		},
    		rendermode: {
    			type: "menu",
    			menuitems: [
    				"render2d",
    				"cubemap",
    				"fisheye180",
    				"dualparaboloid"
    			]
    		},
    		top0filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		alphatocoverage: {
    			type: "toggle"
    		},
    		croptopunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		sampler3: {
    			type: "string"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		lights: {
    			type: "COMP"
    		},
    		orderindtrans: {
    			type: "toggle"
    		},
    		top3extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		top4: {
    			type: "TOP"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		top3filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		top3anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		polygonoffsetunits: {
    			type: "float"
    		},
    		polygonoffsetfactor: {
    			type: "float"
    		},
    		numcolorbufs: {
    			type: "number"
    		},
    		cropleft: {
    			type: "float"
    		},
    		top4extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		polygonoffset: {
    			type: "toggle"
    		},
    		uniname3: {
    			type: "string"
    		},
    		top0anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		allowbufblending: {
    			type: "toggle"
    		},
    		top1extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		render: {
    			type: "toggle"
    		},
    		uniname4: {
    			type: "string"
    		},
    		value3: {
    			type: "xyzw"
    		},
    		top4anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		multicamerahint: {
    			type: "menu",
    			menuitems: [
    				"automatic",
    				"off",
    				"stereocameras"
    			]
    		},
    		cullface: {
    			type: "menu",
    			menuitems: [
    				"neither",
    				"backfaces",
    				"frontfaces",
    				"bothfaces"
    			]
    		},
    		geometry: {
    			type: "OP"
    		},
    		croptop: {
    			type: "float"
    		},
    		top1filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		top3: {
    			type: "TOP"
    		},
    		top0extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		uniname0: {
    			type: "string"
    		},
    		drawdepthonly: {
    			type: "toggle"
    		},
    		top1anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		top0extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		value1: {
    			type: "xyzw"
    		},
    		top0: {
    			type: "TOP"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		transpeellayers: {
    			type: "number"
    		},
    		value0: {
    			type: "xyzw"
    		},
    		depthpeel: {
    			type: "toggle"
    		},
    		dither: {
    			type: "toggle"
    		},
    		coloroutputneeded: {
    			type: "toggle"
    		},
    		depthformat: {
    			type: "menu",
    			menuitems: [
    				"fixed24",
    				"float32"
    			]
    		},
    		overdraw: {
    			type: "toggle"
    		},
    		top2: {
    			type: "TOP"
    		},
    		value2: {
    			type: "xyzw"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		antialias: {
    			type: "menu",
    			menuitems: [
    				"aa1",
    				"aa2",
    				"aa4",
    				"aa8mid",
    				"aa8high",
    				"aa16low",
    				"aa16mid",
    				"aa16high",
    				"aa32"
    			]
    		},
    		top3extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		cropleftunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		top3extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		camera: {
    			type: "COMP"
    		},
    		croprightunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		top2extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top1: {
    			type: "TOP"
    		},
    		overdrawlimit: {
    			type: "number"
    		},
    		uniname1: {
    			type: "string"
    		},
    		aspect2: {
    			type: "float"
    		},
    		cropright: {
    			type: "float"
    		},
    		sampler0: {
    			type: "string"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		top4extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top1extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		sampler1: {
    			type: "string"
    		},
    		top2extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var slopeTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		offsetunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		red: {
    			type: "menu",
    			menuitems: [
    				"hluminance",
    				"hred",
    				"hgreen",
    				"hblue",
    				"halpha",
    				"hrgbaverage",
    				"haverage",
    				"vluminance",
    				"vred",
    				"vgreen",
    				"vblue",
    				"valpha",
    				"vrgbaverage",
    				"vaverage",
    				"neutral",
    				"one",
    				"zero"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		blue: {
    			type: "menu",
    			menuitems: [
    				"hluminance",
    				"hred",
    				"hgreen",
    				"hblue",
    				"halpha",
    				"hrgbaverage",
    				"haverage",
    				"vluminance",
    				"vred",
    				"vgreen",
    				"vblue",
    				"valpha",
    				"vrgbaverage",
    				"vaverage",
    				"neutral",
    				"one",
    				"zero"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		strength: {
    			type: "float"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		alpha: {
    			type: "menu",
    			menuitems: [
    				"hluminance",
    				"hred",
    				"hgreen",
    				"hblue",
    				"halpha",
    				"hrgbaverage",
    				"haverage",
    				"vluminance",
    				"vred",
    				"vgreen",
    				"vblue",
    				"valpha",
    				"vrgbaverage",
    				"vaverage",
    				"neutral",
    				"one",
    				"zero"
    			]
    		},
    		zeropoint: {
    			type: "float"
    		},
    		green: {
    			type: "menu",
    			menuitems: [
    				"hluminance",
    				"hred",
    				"hgreen",
    				"hblue",
    				"halpha",
    				"hrgbaverage",
    				"haverage",
    				"vluminance",
    				"vred",
    				"vgreen",
    				"vblue",
    				"valpha",
    				"vrgbaverage",
    				"vaverage",
    				"neutral",
    				"one",
    				"zero"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"prevcur",
    				"curnext",
    				"prevnext"
    			]
    		},
    		offset1: {
    			type: "float"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		offset2: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var depthTOP = {
    	maxInputs: 0,
    	pars: {
    		rendertop: {
    			type: "OP"
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		rangeto2: {
    			type: "float"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		rangefrom1: {
    			type: "float"
    		},
    		cameraindex: {
    			type: "number"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		rangefrom2: {
    			type: "float"
    		},
    		rangeto1: {
    			type: "float"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		clamp: {
    			type: "toggle"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		peellayerindex: {
    			type: "number"
    		},
    		depthspace: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"cameraspace",
    				"reranged"
    			]
    		},
    		pixelformat: {
    			type: "menu",
    			menuitems: [
    				"depth",
    				"rgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgb11",
    				"r8fixed",
    				"r16fixed",
    				"r16float",
    				"r32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16float",
    				"a32float"
    			]
    		},
    		gamma: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var hsvtorgbTOP = {
    	maxInputs: 1,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var videostreamoutTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		quality: {
    			type: "menu",
    			menuitems: [
    				"lowlatencylow",
    				"lowlatencymedium",
    				"lowlatencyhigh",
    				"highlatencylow",
    				"highlatencyhigh"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		profile: {
    			type: "menu",
    			menuitems: [
    				"baseline",
    				"main",
    				"high"
    			]
    		},
    		audiochop: {
    			type: "CHOP"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		fps: {
    			type: "float"
    		},
    		streamname: {
    			type: "string"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		port: {
    			type: "number"
    		},
    		numslices: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		bitrate: {
    			type: "float"
    		},
    		forceidr: {
    			type: "pulse"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		multicast: {
    			type: "toggle"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var moviefileoutTOP = {
    	maxInputs: 1,
    	pars: {
    		resmult: {
    			type: "toggle"
    		},
    		audiocodec: {
    			type: "menu",
    			menuitems: [
    				"alac",
    				"mp3",
    				"pcm16",
    				"pcm24",
    				"pcm32"
    			]
    		},
    		quality: {
    			type: "float"
    		},
    		stallforopen: {
    			type: "toggle"
    		},
    		videocodec: {
    			type: "menu",
    			menuitems: [
    				"rle",
    				"mjpa",
    				"mpeg4",
    				"h264nvgpu",
    				"cineform",
    				"hap",
    				"hapq",
    				"h265nvgpu"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		profile: {
    			type: "menu",
    			menuitems: [
    				"autoselect",
    				"baseline",
    				"main",
    				"high"
    			]
    		},
    		moviepixelformat: {
    			type: "menu",
    			menuitems: [
    				"yuv420",
    				"yuv422"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"movie",
    				"image",
    				"imagesequence"
    			]
    		},
    		addframe: {
    			type: "pulse"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		pause: {
    			type: "toggle"
    		},
    		audiochop: {
    			type: "CHOP"
    		},
    		maxthread: {
    			type: "number"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		bitratemode: {
    			type: "menu",
    			menuitems: [
    				"constant",
    				"variable",
    				"constanthq",
    				"variablehq"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		audiobitrate: {
    			type: "menu",
    			menuitems: [
    				"b96",
    				"b128",
    				"b192",
    				"b256",
    				"b320"
    			]
    		},
    		record: {
    			type: "toggle"
    		},
    		n: {
    			type: "number"
    		},
    		imagefiletype: {
    			type: "menu",
    			menuitems: [
    				"tiff",
    				"jpeg",
    				"bmp",
    				"exr",
    				"png",
    				"dds"
    			]
    		},
    		peakbitrate: {
    			type: "float"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		mipmaps: {
    			type: "toggle"
    		},
    		keyframeinterval: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		entropymode: {
    			type: "menu",
    			menuitems: [
    				"autoselect",
    				"cabac",
    				"cavlc"
    			]
    		},
    		hapsecondarycompression: {
    			type: "toggle"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		encodetestmode: {
    			type: "toggle"
    		},
    		avgbitrate: {
    			type: "float"
    		},
    		fps: {
    			type: "float"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		file: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var levelTOP = {
    	maxInputs: 1,
    	pars: {
    		clamplow: {
    			type: "float"
    		},
    		brightness2: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		lowa: {
    			type: "float"
    		},
    		soften: {
    			type: "float"
    		},
    		inhigh: {
    			type: "float"
    		},
    		blacklevel: {
    			type: "float"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		gamma2: {
    			type: "float"
    		},
    		threshold: {
    			type: "float"
    		},
    		opacity: {
    			type: "float"
    		},
    		clamphigh2: {
    			type: "float"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		invert: {
    			type: "float"
    		},
    		highg: {
    			type: "float"
    		},
    		stepping: {
    			type: "toggle"
    		},
    		npasses: {
    			type: "number"
    		},
    		higha: {
    			type: "float"
    		},
    		resolutionw: {
    			type: "number"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		lowr: {
    			type: "float"
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		lowg: {
    			type: "float"
    		},
    		stepsize: {
    			type: "float"
    		},
    		clamphigh: {
    			type: "float"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		clampinput: {
    			type: "toggle"
    		},
    		outhigh: {
    			type: "float"
    		},
    		outlow: {
    			type: "float"
    		},
    		brightness1: {
    			type: "float"
    		},
    		highb: {
    			type: "float"
    		},
    		contrast: {
    			type: "float"
    		},
    		gamma1: {
    			type: "float"
    		},
    		aspect2: {
    			type: "float"
    		},
    		lowb: {
    			type: "float"
    		},
    		clamp: {
    			type: "toggle"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		clamplow2: {
    			type: "float"
    		},
    		inlow: {
    			type: "float"
    		},
    		highr: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var outTOP = {
    	maxInputs: 1,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		label: {
    			type: "string"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var displaceTOP = {
    	maxInputs: 2,
    	pars: {
    		resolutionh: {
    			type: "number"
    		},
    		midpoint1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		horzsource: {
    			type: "menu",
    			menuitems: [
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"none"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		displaceweight2: {
    			type: "float"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		extend: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		offsetweight: {
    			type: "float"
    		},
    		midpoint2: {
    			type: "float"
    		},
    		aspect2: {
    			type: "float"
    		},
    		uvweight: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		vertsource: {
    			type: "menu",
    			menuitems: [
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"none"
    			]
    		},
    		offset1: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		offset2: {
    			type: "float"
    		},
    		displaceweight1: {
    			type: "float"
    		}
    	},
    	minInputs: 2,
    	type: "TOP"
    };
    var renderpassTOP = {
    	maxInputs: 1,
    	pars: {
    		top2extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		overridemat: {
    			type: "MAT"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		top2anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		top0extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		value4: {
    			type: "xyzw"
    		},
    		uniname2: {
    			type: "string"
    		},
    		top2filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		top4extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		cropbottomunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		top4filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		cropbottom: {
    			type: "float"
    		},
    		sampler2: {
    			type: "string"
    		},
    		top1extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		cleardepth: {
    			type: "toggle"
    		},
    		npasses: {
    			type: "number"
    		},
    		sampler4: {
    			type: "string"
    		},
    		top0filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		alphatocoverage: {
    			type: "toggle"
    		},
    		croptopunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		sampler3: {
    			type: "string"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		lights: {
    			type: "COMP"
    		},
    		orderindtrans: {
    			type: "toggle"
    		},
    		top3extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		top4: {
    			type: "TOP"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		top3filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		top3anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		polygonoffsetunits: {
    			type: "float"
    		},
    		polygonoffsetfactor: {
    			type: "float"
    		},
    		uniname1: {
    			type: "string"
    		},
    		cropleft: {
    			type: "float"
    		},
    		top4extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		polygonoffset: {
    			type: "toggle"
    		},
    		uniname3: {
    			type: "string"
    		},
    		top0anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		allowbufblending: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"useinput"
    			]
    		},
    		top1extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		render: {
    			type: "toggle"
    		},
    		uniname4: {
    			type: "string"
    		},
    		resolutionw: {
    			type: "number"
    		},
    		value3: {
    			type: "xyzw"
    		},
    		top4anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		cullface: {
    			type: "menu",
    			menuitems: [
    				"neither",
    				"backfaces",
    				"frontfaces",
    				"bothfaces"
    			]
    		},
    		geometry: {
    			type: "OP"
    		},
    		croptop: {
    			type: "float"
    		},
    		top1filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		top3: {
    			type: "TOP"
    		},
    		top0extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		uniname0: {
    			type: "string"
    		},
    		drawdepthonly: {
    			type: "toggle"
    		},
    		top1anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		top0extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		value1: {
    			type: "xyzw"
    		},
    		top0: {
    			type: "TOP"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		transpeellayers: {
    			type: "number"
    		},
    		value0: {
    			type: "xyzw"
    		},
    		depthpeel: {
    			type: "toggle"
    		},
    		dither: {
    			type: "toggle"
    		},
    		coloroutputneeded: {
    			type: "toggle"
    		},
    		overdraw: {
    			type: "toggle"
    		},
    		top2: {
    			type: "TOP"
    		},
    		value2: {
    			type: "xyzw"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		top3extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		cropleftunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		top3extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top4extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		renderinput: {
    			type: "TOP"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		camera: {
    			type: "COMP"
    		},
    		croprightunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		top2extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top1: {
    			type: "TOP"
    		},
    		overdrawlimit: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		cropright: {
    			type: "float"
    		},
    		sampler0: {
    			type: "string"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		top1extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		sampler1: {
    			type: "string"
    		},
    		cleartocamcolor: {
    			type: "toggle"
    		},
    		top2extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var switchTOP = {
    	maxInputs: 9999,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		blend: {
    			type: "toggle"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		index: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var ndioutTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		grouptable: {
    			type: "DAT"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		fps: {
    			type: "float"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		includealpha: {
    			type: "toggle"
    		},
    		failovername: {
    			type: "string"
    		},
    		aspect2: {
    			type: "float"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		name: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var insideTOP = {
    	maxInputs: 2,
    	pars: {
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		t: {
    			type: "xy"
    		},
    		size: {
    			type: "menu",
    			menuitems: [
    				"input1",
    				"input2"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"left",
    				"center",
    				"right"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		extend: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"bottom",
    				"center",
    				"top"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		s: {
    			type: "xy"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		punit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		p: {
    			type: "xy"
    		},
    		tunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		r: {
    			type: "float"
    		},
    		prefit: {
    			type: "menu",
    			menuitems: [
    				"fill",
    				"fithorz",
    				"fitvert",
    				"fitbest",
    				"fitoutside",
    				"nativeres"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 2,
    	type: "TOP"
    };
    var photoshopinTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		update: {
    			type: "pulse"
    		},
    		imageformat: {
    			type: "menu",
    			menuitems: [
    				"jpeg",
    				"uncompressed"
    			]
    		},
    		lockeddocument: {
    			type: "string"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		unlock: {
    			type: "pulse"
    		},
    		locktocurrent: {
    			type: "pulse"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		maxupdaterate: {
    			type: "float"
    		},
    		aspect1: {
    			type: "float"
    		},
    		password: {
    			type: "string"
    		},
    		aspect2: {
    			type: "float"
    		},
    		updatemode: {
    			type: "menu",
    			menuitems: [
    				"automatic",
    				"manual"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		address: {
    			type: "string"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var textTOP = {
    	maxInputs: 1,
    	pars: {
    		rowindex: {
    			type: "number"
    		},
    		appendvalue: {
    			type: "toggle"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		leftborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		bold: {
    			type: "toggle"
    		},
    		fontsizex: {
    			type: "float"
    		},
    		readingdirection: {
    			type: "menu",
    			menuitems: [
    				"lefttoright",
    				"righttoleft"
    			]
    		},
    		bottomborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		italic: {
    			type: "toggle"
    		},
    		positionunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		field: {
    			type: "PanelCOMP"
    		},
    		font: {
    			type: "string"
    		},
    		bgcolor: {
    			type: "rgb"
    		},
    		text: {
    			type: "string"
    		},
    		kerning2: {
    			type: "float"
    		},
    		borderbalpha: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		multrgbbyalpha: {
    			type: "toggle"
    		},
    		valuetouse: {
    			type: "float"
    		},
    		borderaalpha: {
    			type: "float"
    		},
    		bgalpha: {
    			type: "float"
    		},
    		specdat: {
    			type: "DAT"
    		},
    		fontfile: {
    			type: "string"
    		},
    		dispmethod: {
    			type: "menu",
    			menuitems: [
    				"automatic",
    				"polygon",
    				"stroke",
    				"bitmap",
    				"texture"
    			]
    		},
    		topborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		borderspace2: {
    			type: "float"
    		},
    		linespacing: {
    			type: "float"
    		},
    		kerning1: {
    			type: "float"
    		},
    		charset: {
    			type: "menu",
    			menuitems: [
    				"unicode",
    				"symbol"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		antialias: {
    			type: "string"
    		},
    		bordera: {
    			type: "rgb"
    		},
    		fontsizexunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fract",
    				"relfract",
    				"points"
    			]
    		},
    		fontalpha: {
    			type: "float"
    		},
    		rightborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		fontsizey: {
    			type: "float"
    		},
    		dat: {
    			type: "DAT"
    		},
    		strokewidth: {
    			type: "number"
    		},
    		posttext: {
    			type: "string"
    		},
    		rightborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		position2: {
    			type: "float"
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		fontautosize: {
    			type: "menu",
    			menuitems: [
    				"nofit",
    				"alwaysfit",
    				"fitiffat"
    			]
    		},
    		topborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		linespacingunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		aligny: {
    			type: "menu",
    			menuitems: [
    				"bottom",
    				"center",
    				"top"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		language: {
    			type: "string"
    		},
    		alignx: {
    			type: "menu",
    			menuitems: [
    				"left",
    				"center",
    				"right"
    			]
    		},
    		wordwrap: {
    			type: "toggle"
    		},
    		chop: {
    			type: "CHOP"
    		},
    		legacyparsing: {
    			type: "toggle"
    		},
    		decimaldigits: {
    			type: "number"
    		},
    		totaldigits: {
    			type: "number"
    		},
    		borderb: {
    			type: "rgb"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		aspect1: {
    			type: "float"
    		},
    		leftborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		keepfontratio: {
    			type: "toggle"
    		},
    		aspect2: {
    			type: "float"
    		},
    		position1: {
    			type: "float"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		chopvaluereplace: {
    			type: "toggle"
    		},
    		fontcolor: {
    			type: "rgb"
    		},
    		colindex: {
    			type: "number"
    		},
    		leadingzero: {
    			type: "toggle"
    		},
    		fontsizeyunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fract",
    				"relfract",
    				"points"
    			]
    		},
    		compoverinput: {
    			type: "toggle"
    		},
    		borderspace1: {
    			type: "float"
    		},
    		bottomborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var choptoTOP = {
    	maxInputs: 0,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		dataformat: {
    			type: "menu",
    			menuitems: [
    				"r",
    				"rg",
    				"rgb",
    				"rgba",
    				"a",
    				"legacy"
    			]
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		chop: {
    			type: "CHOP"
    		},
    		npasses: {
    			type: "number"
    		},
    		clamp: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var sharedmemoutTOP = {
    	maxInputs: 1,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		downloadtype: {
    			type: "menu",
    			menuitems: [
    				"immediate",
    				"nextframe"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		memtype: {
    			type: "menu",
    			menuitems: [
    				"local",
    				"global"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		name: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var rectangleTOP = {
    	maxInputs: 1,
    	pars: {
    		sizeunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		bgcolor: {
    			type: "rgb"
    		},
    		size: {
    			type: "xy"
    		},
    		borderwidthunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		centerunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		softness: {
    			type: "float"
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		borderalpha: {
    			type: "float"
    		},
    		center: {
    			type: "xy"
    		},
    		multrgbbyalpha: {
    			type: "toggle"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		rotate: {
    			type: "float"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		antialias: {
    			type: "toggle"
    		},
    		npasses: {
    			type: "number"
    		},
    		bgalpha: {
    			type: "float"
    		},
    		borderoffset: {
    			type: "float"
    		},
    		cornerradius: {
    			type: "float"
    		},
    		borderwidth: {
    			type: "float"
    		},
    		softnessunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		fillalpha: {
    			type: "float"
    		},
    		fillcolor: {
    			type: "rgb"
    		},
    		border: {
    			type: "rgb"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		cornerradiusunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var ndiinTOP = {
    	maxInputs: 0,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		grouptable: {
    			type: "DAT"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		bandwidth: {
    			type: "menu",
    			menuitems: [
    				"high",
    				"low"
    			]
    		},
    		extraips: {
    			type: "string"
    		},
    		aspect2: {
    			type: "float"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		name: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var cplusplusTOP = {
    	maxInputs: 999,
    	pars: {
    		resolutionh: {
    			type: "number"
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		plugin: {
    			type: "string"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		depthbuffer: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"fixed24",
    				"float32"
    			]
    		},
    		unloadplugin: {
    			type: "toggle"
    		},
    		reinitpulse: {
    			type: "pulse"
    		},
    		numcolorbufs: {
    			type: "number"
    		},
    		aspect1: {
    			type: "float"
    		},
    		reinit: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		antialias: {
    			type: "menu",
    			menuitems: [
    				"aa1",
    				"aa2",
    				"aa4",
    				"aa8",
    				"aa16",
    				"aa32"
    			]
    		},
    		stencilbuffer: {
    			type: "toggle"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var lookupTOP = {
    	maxInputs: 2,
    	pars: {
    		lightuv2: {
    			type: "float"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		lightuv1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		clampchopvalues: {
    			type: "toggle"
    		},
    		lightuvunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		darkuv2: {
    			type: "float"
    		},
    		darkuv1: {
    			type: "float"
    		},
    		usesourceluminance: {
    			type: "toggle"
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		darkuvunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		chop: {
    			type: "CHOP"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		displaylookup: {
    			type: "toggle"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"secondinput",
    				"chop"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		resolutionw: {
    			type: "number"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var screenTOP = {
    	maxInputs: 2,
    	pars: {
    		resolutionh: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		t: {
    			type: "xy"
    		},
    		size: {
    			type: "menu",
    			menuitems: [
    				"input1",
    				"input2"
    			]
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"left",
    				"center",
    				"right"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		extend: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"bottom",
    				"center",
    				"top"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		s: {
    			type: "xy"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		punit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		aspect2: {
    			type: "float"
    		},
    		npasses: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		p: {
    			type: "xy"
    		},
    		tunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"fraction",
    				"fractionaspect"
    			]
    		},
    		r: {
    			type: "float"
    		},
    		prefit: {
    			type: "menu",
    			menuitems: [
    				"fill",
    				"fithorz",
    				"fitvert",
    				"fitbest",
    				"fitoutside",
    				"nativeres"
    			]
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 2,
    	type: "TOP"
    };
    var renderselectTOP = {
    	maxInputs: 0,
    	pars: {
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		resolutionh: {
    			type: "number"
    		},
    		top: {
    			type: "TOP"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		peellayerindex: {
    			type: "number"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		cameraindex: {
    			type: "number"
    		},
    		npasses: {
    			type: "number"
    		},
    		colorbufindex: {
    			type: "number"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var realsenseTOP = {
    	maxInputs: 0,
    	pars: {
    		defaulttradeoff: {
    			type: "toggle"
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		tradeoff: {
    			type: "number"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		api: {
    			type: "menu",
    			menuitems: [
    				"winrsense",
    				"librealsense"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		npasses: {
    			type: "number"
    		},
    		image: {
    			type: "menu",
    			menuitems: [
    				"color",
    				"depth",
    				"rawdepth",
    				"depthalignedtocolor",
    				"coloralignedtodepth",
    				"infrared",
    				"pointcloud",
    				"pointcloudcoloruv"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		colorres: {
    			type: "string"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		sensor: {
    			type: "string"
    		},
    		aspect2: {
    			type: "float"
    		},
    		model: {
    			type: "menu",
    			menuitems: [
    				"f200",
    				"r200",
    				"zr300",
    				"sr300",
    				"d415",
    				"d435"
    			]
    		},
    		maxdepth: {
    			type: "float"
    		},
    		mirrorimage: {
    			type: "toggle"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var moviefileinTOP = {
    	maxInputs: 0,
    	pars: {
    		resolutionh: {
    			type: "number"
    		},
    		speed: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		frametimeout: {
    			type: "number"
    		},
    		opentimeout: {
    			type: "number"
    		},
    		overridesample: {
    			type: "toggle"
    		},
    		asyncupload: {
    			type: "toggle"
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		inputsrgb: {
    			type: "toggle"
    		},
    		npasses: {
    			type: "number"
    		},
    		interp: {
    			type: "toggle"
    		},
    		tstartunit: {
    			type: "menu",
    			menuitems: [
    				"indices",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		cuepoint: {
    			type: "float"
    		},
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		imageindexing: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"filename"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		prereadframes: {
    			type: "number"
    		},
    		bottomhalfalpha: {
    			type: "toggle"
    		},
    		loadingerrorimage: {
    			type: "menu",
    			menuitems: [
    				"coloredbottomright",
    				"zero"
    			]
    		},
    		deinterlace: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"even",
    				"odd",
    				"bob"
    			]
    		},
    		frametimeoutstrat: {
    			type: "menu",
    			menuitems: [
    				"keep",
    				"advance",
    				"closest"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		alwaysloadinitial: {
    			type: "toggle"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		highperfreadfactor: {
    			type: "float"
    		},
    		audioloop: {
    			type: "menu",
    			menuitems: [
    				"silence",
    				"fade",
    				"match"
    			]
    		},
    		usecpucache: {
    			type: "toggle"
    		},
    		multalpha: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"automatic"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		trim: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		indexunit: {
    			type: "menu",
    			menuitems: [
    				"indices",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		stepsize: {
    			type: "number"
    		},
    		tstart: {
    			type: "float"
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		reload: {
    			type: "toggle"
    		},
    		loopcrossfade: {
    			type: "float"
    		},
    		updateimage: {
    			type: "toggle"
    		},
    		tend: {
    			type: "float"
    		},
    		tendunit: {
    			type: "menu",
    			menuitems: [
    				"indices",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		textendleft: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"cycle",
    				"mirror",
    				"black",
    				"zero"
    			]
    		},
    		index: {
    			type: "float"
    		},
    		file: {
    			type: "string"
    		},
    		playmode: {
    			type: "menu",
    			menuitems: [
    				"locked",
    				"specify",
    				"sequential"
    			]
    		},
    		cuepulse: {
    			type: "pulse"
    		},
    		aspect2: {
    			type: "float"
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		precedence: {
    			type: "menu",
    			menuitems: [
    				"even",
    				"odd"
    			]
    		},
    		maxdecodecpus: {
    			type: "number"
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		highperfread: {
    			type: "toggle"
    		},
    		play: {
    			type: "toggle"
    		},
    		reloadpulse: {
    			type: "pulse"
    		},
    		samplerate: {
    			type: "float"
    		},
    		cuepointunit: {
    			type: "menu",
    			menuitems: [
    				"indices",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		textendright: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"cycle",
    				"mirror",
    				"black",
    				"zero"
    			]
    		},
    		loopcrossfadeunit: {
    			type: "menu",
    			menuitems: [
    				"indices",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		cue: {
    			type: "toggle"
    		},
    		cuebehavior: {
    			type: "menu",
    			menuitems: [
    				"repeat",
    				"play"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "TOP"
    };
    var syphonspoutoutTOP = {
    	maxInputs: 1,
    	pars: {
    		outputaspect: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"resolution",
    				"custom"
    			]
    		},
    		armenu: {
    			type: "menu",
    			menuitems: [
    				"1x1",
    				"4x3",
    				"16x9",
    				"16x10"
    			]
    		},
    		aspect1: {
    			type: "float"
    		},
    		resmult: {
    			type: "toggle"
    		},
    		resmenu: {
    			type: "menu",
    			menuitems: [
    				"400x300",
    				"640x480",
    				"800x600",
    				"1024x768",
    				"1280x720",
    				"1920x1080",
    				"1920x1200",
    				"3940x2160",
    				"4096x2160",
    				"256x256",
    				"512x512",
    				"1024x1024"
    			]
    		},
    		resolutionw: {
    			type: "number"
    		},
    		resolutionh: {
    			type: "number"
    		},
    		aspect2: {
    			type: "float"
    		},
    		chanmask: {
    			type: "menu",
    			menuitems: null
    		},
    		outputresolution: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"eighth",
    				"quarter",
    				"half",
    				"2x",
    				"4x",
    				"8x",
    				"fit",
    				"limit",
    				"custom"
    			]
    		},
    		filtertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"rgba8fixed",
    				"srgba8fixed",
    				"rgba16float",
    				"rgba32float",
    				"_separator_",
    				"rgb10a2fixed",
    				"rgba16fixed",
    				"rgba11float",
    				"rgb16float",
    				"rgb32float",
    				"mono8fixed",
    				"mono16fixed",
    				"mono16float",
    				"mono32float",
    				"rg8fixed",
    				"rg16fixed",
    				"rg16float",
    				"rg32float",
    				"a8fixed",
    				"a16fixed",
    				"a16float",
    				"a32float",
    				"monoalpha8fixed",
    				"monoalpha16fixed",
    				"monoalpha16float",
    				"monoalpha32float"
    			]
    		},
    		inputfiltertype: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmap"
    			]
    		},
    		fillmode: {
    			type: "menu",
    			menuitems: [
    				"useinput",
    				"fill",
    				"width",
    				"height",
    				"best",
    				"outside",
    				"nativeres"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		npasses: {
    			type: "number"
    		},
    		sendername: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "TOP"
    };
    var revolveSOP = {
    	maxInputs: 1,
    	pars: {
    		order: {
    			type: "number"
    		},
    		imperfect: {
    			type: "toggle"
    		},
    		origin: {
    			type: "xyz"
    		},
    		group: {
    			type: "string"
    		},
    		endangle: {
    			type: "float"
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"closed",
    				"openarc",
    				"closedarc"
    			]
    		},
    		surftype: {
    			type: "menu",
    			menuitems: [
    				"rows",
    				"cols",
    				"rowcol",
    				"triangles",
    				"quads",
    				"alttriangles"
    			]
    		},
    		beginangle: {
    			type: "float"
    		},
    		dir: {
    			type: "xyz"
    		},
    		cap: {
    			type: "toggle"
    		},
    		polys: {
    			type: "toggle"
    		},
    		divs: {
    			type: "number"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var basisSOP = {
    	maxInputs: 1,
    	pars: {
    		uknots: {
    			type: "string"
    		},
    		vorigin: {
    			type: "float"
    		},
    		vbias: {
    			type: "float"
    		},
    		urange1: {
    			type: "float"
    		},
    		vlength: {
    			type: "float"
    		},
    		uconcat: {
    			type: "toggle"
    		},
    		udolength: {
    			type: "toggle"
    		},
    		ulength: {
    			type: "float"
    		},
    		vread: {
    			type: "pulse"
    		},
    		vrange2: {
    			type: "float"
    		},
    		uscale: {
    			type: "float"
    		},
    		udoscale: {
    			type: "toggle"
    		},
    		uorigin: {
    			type: "float"
    		},
    		vknots: {
    			type: "string"
    		},
    		uraise: {
    			type: "toggle"
    		},
    		orderv: {
    			type: "number"
    		},
    		urange2: {
    			type: "float"
    		},
    		vconcat: {
    			type: "toggle"
    		},
    		uparmtype: {
    			type: "menu",
    			menuitems: [
    				"nochange",
    				"uniform",
    				"chord",
    				"centripetal",
    				"manualone",
    				"manualall",
    				"slide"
    			]
    		},
    		vrange1: {
    			type: "float"
    		},
    		vbasis: {
    			type: "toggle"
    		},
    		uread: {
    			type: "pulse"
    		},
    		vdoscale: {
    			type: "toggle"
    		},
    		group: {
    			type: "string"
    		},
    		vdolength: {
    			type: "toggle"
    		},
    		vscale: {
    			type: "float"
    		},
    		orderu: {
    			type: "number"
    		},
    		vdoorigin: {
    			type: "toggle"
    		},
    		ubias: {
    			type: "float"
    		},
    		ubasis: {
    			type: "toggle"
    		},
    		vraise: {
    			type: "toggle"
    		},
    		vparmtype: {
    			type: "menu",
    			menuitems: [
    				"nochange",
    				"uniform",
    				"chord",
    				"centripetal",
    				"manualone",
    				"manualall",
    				"slide"
    			]
    		},
    		udoorigin: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var trailSOP = {
    	maxInputs: 1,
    	pars: {
    		surftype: {
    			type: "menu",
    			menuitems: [
    				"rows",
    				"cols",
    				"rowcol",
    				"triangles",
    				"quads",
    				"alttriangles"
    			]
    		},
    		close: {
    			type: "toggle"
    		},
    		length: {
    			type: "number"
    		},
    		inc: {
    			type: "number"
    		},
    		reset: {
    			type: "toggle"
    		},
    		evalframe: {
    			type: "toggle"
    		},
    		result: {
    			type: "menu",
    			menuitems: [
    				"preserve",
    				"mesh",
    				"poly",
    				"velocity"
    			]
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		velscale: {
    			type: "float"
    		},
    		accurate: {
    			type: "toggle"
    		},
    		cache: {
    			type: "number"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var openvrSOP = {
    	maxInputs: 0,
    	pars: {
    		model: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var rectangleSOP = {
    	maxInputs: 1,
    	pars: {
    		camera: {
    			type: "COMP"
    		},
    		camz: {
    			type: "float"
    		},
    		orient: {
    			type: "menu",
    			menuitems: [
    				"xy",
    				"yz",
    				"zx",
    				"cam"
    			]
    		},
    		modifybounds: {
    			type: "toggle"
    		},
    		t: {
    			type: "xyz"
    		},
    		normals: {
    			type: "toggle"
    		},
    		size: {
    			type: "xy"
    		},
    		texture: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"face"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var choptoSOP = {
    	maxInputs: 1,
    	pars: {
    		comptang: {
    			type: "toggle"
    		},
    		endpos: {
    			type: "xyz"
    		},
    		chop: {
    			type: "CHOP"
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"static",
    				"animated"
    			]
    		},
    		chanscope: {
    			type: "string"
    		},
    		attscope: {
    			type: "string"
    		},
    		organize: {
    			type: "string"
    		},
    		group: {
    			type: "string"
    		},
    		startpos: {
    			type: "xyz"
    		},
    		compnml: {
    			type: "toggle"
    		},
    		mapping: {
    			type: "menu",
    			menuitems: [
    				"onetoone",
    				"scale"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var fractalSOP = {
    	maxInputs: 1,
    	pars: {
    		seed: {
    			type: "number"
    		},
    		fixed: {
    			type: "toggle"
    		},
    		vtxnms: {
    			type: "toggle"
    		},
    		smooth: {
    			type: "float"
    		},
    		dir: {
    			type: "xyz"
    		},
    		scale: {
    			type: "float"
    		},
    		group: {
    			type: "string"
    		},
    		divs: {
    			type: "number"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var carveSOP = {
    	maxInputs: 1,
    	pars: {
    		extractop: {
    			type: "menu",
    			menuitems: [
    				"xisoparm",
    				"xpoint",
    				"xprofile"
    			]
    		},
    		domainu2: {
    			type: "float"
    		},
    		divsu: {
    			type: "number"
    		},
    		domainv1: {
    			type: "float"
    		},
    		group: {
    			type: "string"
    		},
    		secondv: {
    			type: "toggle"
    		},
    		domainu1: {
    			type: "float"
    		},
    		keepout: {
    			type: "toggle"
    		},
    		keeporiginal: {
    			type: "toggle"
    		},
    		firstv: {
    			type: "toggle"
    		},
    		domainv2: {
    			type: "float"
    		},
    		divsv: {
    			type: "number"
    		},
    		allubreakpoints: {
    			type: "toggle"
    		},
    		allvbreakpoints: {
    			type: "toggle"
    		},
    		secondu: {
    			type: "toggle"
    		},
    		firstu: {
    			type: "toggle"
    		},
    		keepin: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var isosurfaceSOP = {
    	maxInputs: 0,
    	pars: {
    		max: {
    			type: "xyz"
    		},
    		divsx: {
    			type: "number"
    		},
    		normals: {
    			type: "toggle"
    		},
    		divsz: {
    			type: "number"
    		},
    		divsy: {
    			type: "number"
    		},
    		func: {
    			type: "float"
    		},
    		min: {
    			type: "xyz"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var fitSOP = {
    	maxInputs: 1,
    	pars: {
    		multipleu: {
    			type: "toggle"
    		},
    		closev: {
    			type: "menu",
    			menuitems: [
    				"nonewv",
    				"wv",
    				"ifprimwv"
    			]
    		},
    		group: {
    			type: "string"
    		},
    		multiplev: {
    			type: "toggle"
    		},
    		orderu: {
    			type: "number"
    		},
    		dataparmu: {
    			type: "menu",
    			menuitems: [
    				"uniform",
    				"chrdlen",
    				"centrip"
    			]
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"nurbs",
    				"bezier"
    			]
    		},
    		surftype: {
    			type: "menu",
    			menuitems: [
    				"rows",
    				"cols",
    				"rowcol",
    				"triangles",
    				"quads",
    				"alttriangles"
    			]
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"approx",
    				"interp"
    			]
    		},
    		tol: {
    			type: "float"
    		},
    		smooth: {
    			type: "float"
    		},
    		orderv: {
    			type: "number"
    		},
    		corners: {
    			type: "toggle"
    		},
    		closeu: {
    			type: "menu",
    			menuitems: [
    				"nonewu",
    				"wu",
    				"ifprimwu"
    			]
    		},
    		dataparmv: {
    			type: "menu",
    			menuitems: [
    				"uniform",
    				"chrdlen",
    				"centrip"
    			]
    		},
    		scope: {
    			type: "menu",
    			menuitems: [
    				"global",
    				"local",
    				"breakpnt"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var claySOP = {
    	maxInputs: 2,
    	pars: {
    		uusebias: {
    			type: "toggle"
    		},
    		vbias: {
    			type: "float"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		dist: {
    			type: "float"
    		},
    		v: {
    			type: "float"
    		},
    		t: {
    			type: "xyz"
    		},
    		u: {
    			type: "float"
    		},
    		vusebias: {
    			type: "toggle"
    		},
    		uvsnap1: {
    			type: "float"
    		},
    		normal: {
    			type: "toggle"
    		},
    		coord: {
    			type: "xyz"
    		},
    		vwarp: {
    			type: "toggle"
    		},
    		usharp: {
    			type: "float"
    		},
    		uvsnap2: {
    			type: "float"
    		},
    		s: {
    			type: "xyz"
    		},
    		group: {
    			type: "string"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		vsharp: {
    			type: "float"
    		},
    		ubias: {
    			type: "float"
    		},
    		r: {
    			type: "xyz"
    		},
    		dir: {
    			type: "xyz"
    		},
    		p: {
    			type: "xyz"
    		},
    		uwarp: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var booleanSOP = {
    	maxInputs: 2,
    	pars: {
    		booleanop: {
    			type: "menu",
    			menuitems: [
    				"union",
    				"intersect",
    				"aminusb",
    				"bminusa",
    				"aedge",
    				"bedge"
    			]
    		},
    		groupb: {
    			type: "string"
    		},
    		accattrib: {
    			type: "toggle"
    		},
    		groupa: {
    			type: "string"
    		},
    		creategroup: {
    			type: "toggle"
    		}
    	},
    	minInputs: 2,
    	type: "SOP"
    };
    var alignSOP = {
    	maxInputs: 2,
    	pars: {
    		rightuvend1: {
    			type: "float"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		dorotate: {
    			type: "toggle"
    		},
    		inc: {
    			type: "number"
    		},
    		leftuv2: {
    			type: "float"
    		},
    		individual: {
    			type: "toggle"
    		},
    		t: {
    			type: "xyz"
    		},
    		s: {
    			type: "xyz"
    		},
    		group: {
    			type: "string"
    		},
    		rightuvend2: {
    			type: "float"
    		},
    		rightuv1: {
    			type: "float"
    		},
    		rightuv2: {
    			type: "float"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		align: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"group",
    				"skip"
    			]
    		},
    		dotrans: {
    			type: "toggle"
    		},
    		p: {
    			type: "xyz"
    		},
    		bias: {
    			type: "float"
    		},
    		r: {
    			type: "xyz"
    		},
    		leftuv1: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var resampleSOP = {
    	maxInputs: 1,
    	pars: {
    		dolength: {
    			type: "toggle"
    		},
    		measure: {
    			type: "menu",
    			menuitems: [
    				"arc",
    				"chord"
    			]
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"dist",
    				"x",
    				"y",
    				"z"
    			]
    		},
    		length: {
    			type: "float"
    		},
    		dosegs: {
    			type: "toggle"
    		},
    		edge: {
    			type: "toggle"
    		},
    		group: {
    			type: "string"
    		},
    		lod: {
    			type: "float"
    		},
    		segs: {
    			type: "number"
    		},
    		last: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var dattoSOP = {
    	maxInputs: 1,
    	pars: {
    		float: {
    			type: "string"
    		},
    		prtype: {
    			type: "menu",
    			menuitems: [
    				"lines",
    				"pointsprites"
    			]
    		},
    		build: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"all",
    				"pts2",
    				"pts3",
    				"pts4",
    				"ptsn",
    				"polyrow",
    				"polycol",
    				"meshrow",
    				"meshcol",
    				"particleall"
    			]
    		},
    		closedv: {
    			type: "toggle"
    		},
    		connect: {
    			type: "menu",
    			menuitems: [
    				"rows",
    				"cols",
    				"rowcol",
    				"triangles",
    				"quads",
    				"alttriangles"
    			]
    		},
    		n: {
    			type: "number"
    		},
    		string: {
    			type: "string"
    		},
    		pointsdat: {
    			type: "DAT"
    		},
    		merge: {
    			type: "menu",
    			menuitems: [
    				"points",
    				"vertices",
    				"primitives",
    				"detail"
    			]
    		},
    		primsdat: {
    			type: "DAT"
    		},
    		verticesdat: {
    			type: "DAT"
    		},
    		detaildat: {
    			type: "DAT"
    		},
    		closed: {
    			type: "toggle"
    		},
    		int: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var materialSOP = {
    	maxInputs: 1,
    	pars: {
    		mat: {
    			type: "MAT"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var objectmergeSOP = {
    	maxInputs: 0,
    	pars: {
    		sop8: {
    			type: "SOP"
    		},
    		sop1: {
    			type: "SOP"
    		},
    		sop5: {
    			type: "SOP"
    		},
    		xform: {
    			type: "COMP"
    		},
    		sop10: {
    			type: "SOP"
    		},
    		sop2: {
    			type: "SOP"
    		},
    		sop9: {
    			type: "SOP"
    		},
    		sop3: {
    			type: "SOP"
    		},
    		sop4: {
    			type: "SOP"
    		},
    		sop6: {
    			type: "SOP"
    		},
    		sop7: {
    			type: "SOP"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var transformSOP = {
    	maxInputs: 2,
    	pars: {
    		fromz: {
    			type: "menu",
    			menuitems: [
    				"min",
    				"center",
    				"max"
    			]
    		},
    		postty: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"origin",
    				"reference"
    			]
    		},
    		posttz: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"origin",
    				"reference"
    			]
    		},
    		vlength: {
    			type: "toggle"
    		},
    		lookat: {
    			type: "COMP"
    		},
    		t: {
    			type: "xyz"
    		},
    		posttx: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"origin",
    				"reference"
    			]
    		},
    		tox: {
    			type: "menu",
    			menuitems: [
    				"min",
    				"center",
    				"max"
    			]
    		},
    		postscale: {
    			type: "menu",
    			menuitems: [
    				"peraxis",
    				"unity",
    				"reference"
    			]
    		},
    		toy: {
    			type: "menu",
    			menuitems: [
    				"min",
    				"center",
    				"max"
    			]
    		},
    		toz: {
    			type: "menu",
    			menuitems: [
    				"min",
    				"center",
    				"max"
    			]
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		postscalez: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"unity",
    				"reference",
    				"unityprop",
    				"referenceprop"
    			]
    		},
    		s: {
    			type: "xyz"
    		},
    		group: {
    			type: "string"
    		},
    		fromy: {
    			type: "menu",
    			menuitems: [
    				"min",
    				"center",
    				"max"
    			]
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		postscaley: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"unity",
    				"reference",
    				"unityprop",
    				"referenceprop"
    			]
    		},
    		p: {
    			type: "xyz"
    		},
    		fromx: {
    			type: "menu",
    			menuitems: [
    				"min",
    				"center",
    				"max"
    			]
    		},
    		r: {
    			type: "xyz"
    		},
    		postscalex: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"unity",
    				"reference",
    				"unityprop",
    				"referenceprop"
    			]
    		},
    		scale: {
    			type: "float"
    		},
    		upvector: {
    			type: "xyz"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var inSOP = {
    	maxInputs: 1,
    	pars: {
    		label: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var lsystemSOP = {
    	maxInputs: 4,
    	pars: {
    		generations: {
    			type: "float"
    		},
    		gravity: {
    			type: "float"
    		},
    		varc: {
    			type: "float"
    		},
    		colormap: {
    			type: "TOP"
    		},
    		rules: {
    			type: "DAT"
    		},
    		cols: {
    			type: "number"
    		},
    		contwidth: {
    			type: "toggle"
    		},
    		vertinc: {
    			type: "float"
    		},
    		stepscale: {
    			type: "float"
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"skel",
    				"tube"
    			]
    		},
    		thickinit: {
    			type: "float"
    		},
    		thickscale: {
    			type: "float"
    		},
    		pointwidth: {
    			type: "toggle"
    		},
    		randscale: {
    			type: "float"
    		},
    		anglescale: {
    			type: "float"
    		},
    		pictop: {
    			type: "TOP"
    		},
    		docolor: {
    			type: "toggle"
    		},
    		stepinit: {
    			type: "float"
    		},
    		grpprefix: {
    			type: "string"
    		},
    		chanprefix: {
    			type: "string"
    		},
    		inc: {
    			type: "uv"
    		},
    		stampb: {
    			type: "string"
    		},
    		dotexture: {
    			type: "toggle"
    		},
    		contlength: {
    			type: "toggle"
    		},
    		randseed: {
    			type: "number"
    		},
    		stampa: {
    			type: "string"
    		},
    		tension: {
    			type: "float"
    		},
    		rows: {
    			type: "number"
    		},
    		angleinit: {
    			type: "float"
    		},
    		smooth: {
    			type: "float"
    		},
    		varb: {
    			type: "float"
    		},
    		vard: {
    			type: "float"
    		},
    		contangl: {
    			type: "toggle"
    		},
    		stampc: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var spriteSOP = {
    	maxInputs: 0,
    	pars: {
    		constantwitdhfar: {
    			type: "float"
    		},
    		widthchop: {
    			type: "CHOP"
    		},
    		camera: {
    			type: "COMP"
    		},
    		colorchop: {
    			type: "CHOP"
    		},
    		falloffstart: {
    			type: "float"
    		},
    		falloffend: {
    			type: "float"
    		},
    		constantwidth: {
    			type: "float"
    		},
    		perspectivewidth: {
    			type: "float"
    		},
    		xyzchop: {
    			type: "CHOP"
    		},
    		constantwidthnear: {
    			type: "float"
    		},
    		alphachop: {
    			type: "CHOP"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var polystitchSOP = {
    	maxInputs: 1,
    	pars: {
    		stitch: {
    			type: "string"
    		},
    		consolidate: {
    			type: "toggle"
    		},
    		tol3d: {
    			type: "float"
    		},
    		corners: {
    			type: "string"
    		},
    		angle: {
    			type: "float"
    		},
    		findcorner: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var fontSOP = {
    	maxInputs: 0,
    	pars: {
    		s: {
    			type: "xy"
    		},
    		hole: {
    			type: "toggle"
    		},
    		t: {
    			type: "xyz"
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"bezierpoly",
    				"bezier",
    				"poly"
    			]
    		},
    		italic: {
    			type: "float"
    		},
    		hcenter: {
    			type: "toggle"
    		},
    		vcenter: {
    			type: "toggle"
    		},
    		text: {
    			type: "string"
    		},
    		kern: {
    			type: "xy"
    		},
    		lod: {
    			type: "float"
    		},
    		texture: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"ortho"
    			]
    		},
    		file: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var textSOP = {
    	maxInputs: 0,
    	pars: {
    		r: {
    			type: "xyz"
    		},
    		p: {
    			type: "xyz"
    		},
    		t: {
    			type: "xyz"
    		},
    		bold: {
    			type: "toggle"
    		},
    		fontsizex: {
    			type: "float"
    		},
    		readingdirection: {
    			type: "menu",
    			menuitems: [
    				"lefttoright",
    				"righttoleft"
    			]
    		},
    		alignx: {
    			type: "menu",
    			menuitems: [
    				"reading",
    				"left",
    				"center",
    				"right"
    			]
    		},
    		wordwrap: {
    			type: "toggle"
    		},
    		font: {
    			type: "string"
    		},
    		legacyparsing: {
    			type: "toggle"
    		},
    		text: {
    			type: "string"
    		},
    		kerning2: {
    			type: "float"
    		},
    		language: {
    			type: "string"
    		},
    		fontfile: {
    			type: "string"
    		},
    		wordwrapsize: {
    			type: "float"
    		},
    		levelofdetail: {
    			type: "number"
    		},
    		keepfontratio: {
    			type: "toggle"
    		},
    		s: {
    			type: "xyz"
    		},
    		italic: {
    			type: "toggle"
    		},
    		linespacing: {
    			type: "float"
    		},
    		kerning1: {
    			type: "float"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		fontsizey: {
    			type: "float"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var captureSOP = {
    	maxInputs: 2,
    	pars: {
    		weightfrom: {
    			type: "menu",
    			menuitems: [
    				"surface",
    				"cv"
    			]
    		},
    		captframe: {
    			type: "number"
    		},
    		savesel: {
    			type: "pulse"
    		},
    		autoincr: {
    			type: "toggle"
    		},
    		group: {
    			type: "string"
    		},
    		captfile: {
    			type: "string"
    		},
    		savecaptfile: {
    			type: "pulse"
    		},
    		rootbone: {
    			type: "COMP"
    		},
    		color: {
    			type: "menu",
    			menuitems: [
    				"coldefault",
    				"colregion"
    			]
    		},
    		savefile: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var scriptSOP = {
    	maxInputs: 9999,
    	pars: {
    		setuppars: {
    			type: "pulse"
    		},
    		callbacks: {
    			type: "DAT"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var deleteSOP = {
    	maxInputs: 1,
    	pars: {
    		select1: {
    			type: "number"
    		},
    		boundtype: {
    			type: "menu",
    			menuitems: [
    				"usebbox",
    				"usebsphere"
    			]
    		},
    		rangestart: {
    			type: "number"
    		},
    		keeppoints: {
    			type: "toggle"
    		},
    		t: {
    			type: "xyz"
    		},
    		size: {
    			type: "xyz"
    		},
    		pattern: {
    			type: "string"
    		},
    		camera: {
    			type: "COMP"
    		},
    		geotype: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"bezierc",
    				"bezier",
    				"circle",
    				"mesh",
    				"meta",
    				"nurbc",
    				"nurb",
    				"part",
    				"poly",
    				"sphere",
    				"tube",
    				"tristrip",
    				"trifan"
    			]
    		},
    		removegrp: {
    			type: "toggle"
    		},
    		usenormal: {
    			type: "toggle"
    		},
    		filter: {
    			type: "number"
    		},
    		usenumber: {
    			type: "toggle"
    		},
    		entity: {
    			type: "menu",
    			menuitems: [
    				"primitive",
    				"point"
    			]
    		},
    		rangeend: {
    			type: "number"
    		},
    		select2: {
    			type: "number"
    		},
    		group: {
    			type: "string"
    		},
    		groupop: {
    			type: "menu",
    			menuitems: [
    				"pattern",
    				"range",
    				"filter"
    			]
    		},
    		negate: {
    			type: "menu",
    			menuitems: [
    				"dele",
    				"keep"
    			]
    		},
    		dir: {
    			type: "xyz"
    		},
    		usebounds: {
    			type: "toggle"
    		},
    		angle: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var tristripSOP = {
    	maxInputs: 1,
    	pars: {
    		constrainstriplength: {
    			type: "toggle"
    		},
    		group: {
    			type: "string"
    		},
    		maxstriplength: {
    			type: "number"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var gridSOP = {
    	maxInputs: 1,
    	pars: {
    		normals: {
    			type: "toggle"
    		},
    		cols: {
    			type: "number"
    		},
    		modifybounds: {
    			type: "toggle"
    		},
    		orderu: {
    			type: "number"
    		},
    		t: {
    			type: "xyz"
    		},
    		orient: {
    			type: "menu",
    			menuitems: [
    				"xy",
    				"yz",
    				"zx"
    			]
    		},
    		interpu: {
    			type: "toggle"
    		},
    		size: {
    			type: "xy"
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"poly",
    				"mesh",
    				"nurbs",
    				"bezier"
    			]
    		},
    		surftype: {
    			type: "menu",
    			menuitems: [
    				"rows",
    				"cols",
    				"rowcol",
    				"triangles",
    				"quads",
    				"alttriangles"
    			]
    		},
    		rows: {
    			type: "number"
    		},
    		orderv: {
    			type: "number"
    		},
    		interpv: {
    			type: "toggle"
    		},
    		texture: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"rowcol"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var textureSOP = {
    	maxInputs: 1,
    	pars: {
    		axis: {
    			type: "menu",
    			menuitems: [
    				"x",
    				"y",
    				"z"
    			]
    		},
    		r: {
    			type: "xyz"
    		},
    		s: {
    			type: "uvw"
    		},
    		offset: {
    			type: "uvw"
    		},
    		p: {
    			type: "xyz"
    		},
    		fixseams: {
    			type: "toggle"
    		},
    		group: {
    			type: "string"
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"texture",
    				"xyzposition",
    				"equirectangularin",
    				"equirectangularout",
    				"cylin",
    				"rowcol",
    				"face",
    				"modify",
    				"suniform",
    				"saverage",
    				"sarclen",
    				"edgelength",
    				"persp",
    				"equiazimuth",
    				"equiazimuth360"
    			]
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		camera: {
    			type: "COMP"
    		},
    		t: {
    			type: "xyz"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		scaletwo: {
    			type: "xyz"
    		},
    		angle: {
    			type: "float"
    		},
    		texlayer: {
    			type: "number"
    		},
    		coord: {
    			type: "menu",
    			menuitems: [
    				"natural",
    				"point",
    				"vertex"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var magnetSOP = {
    	maxInputs: 2,
    	pars: {
    		position: {
    			type: "toggle"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		s: {
    			type: "xyz"
    		},
    		p: {
    			type: "xyz"
    		},
    		t: {
    			type: "xyz"
    		},
    		velocity: {
    			type: "toggle"
    		},
    		color: {
    			type: "toggle"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		nml: {
    			type: "toggle"
    		},
    		r: {
    			type: "xyz"
    		},
    		magnetgrp: {
    			type: "string"
    		},
    		deformgrp: {
    			type: "string"
    		}
    	},
    	minInputs: 2,
    	type: "SOP"
    };
    var curvesectSOP = {
    	maxInputs: 2,
    	pars: {
    		affect: {
    			type: "menu",
    			menuitems: [
    				"left",
    				"right",
    				"both"
    			]
    		},
    		left: {
    			type: "menu",
    			menuitems: [
    				"lkeepall",
    				"lkeepodd",
    				"lkeepeven",
    				"lkeepnone"
    			]
    		},
    		right: {
    			type: "menu",
    			menuitems: [
    				"rkeepall",
    				"rkeepodd",
    				"rkeepeven",
    				"rkeepnone"
    			]
    		},
    		tolerance: {
    			type: "float"
    		},
    		xsect: {
    			type: "toggle"
    		},
    		leftgroup: {
    			type: "string"
    		},
    		extractpt: {
    			type: "toggle"
    		},
    		keeporiginal: {
    			type: "toggle"
    		},
    		rightgroup: {
    			type: "string"
    		}
    	},
    	minInputs: 2,
    	type: "SOP"
    };
    var polyreduceSOP = {
    	maxInputs: 2,
    	pars: {
    		keepedges: {
    			type: "toggle"
    		},
    		meshinvert: {
    			type: "toggle"
    		},
    		lengthweight: {
    			type: "float"
    		},
    		percentage: {
    			type: "float"
    		},
    		distance: {
    			type: "float"
    		},
    		creaseweight: {
    			type: "float"
    		},
    		reduce: {
    			type: "string"
    		},
    		triangulate: {
    			type: "toggle"
    		},
    		borderweight: {
    			type: "float"
    		},
    		obj: {
    			type: "COMP"
    		},
    		minpercent: {
    			type: "float"
    		},
    		creases: {
    			type: "string"
    		},
    		originalpoints: {
    			type: "toggle"
    		},
    		numpolys: {
    			type: "number"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var fileinSOP = {
    	maxInputs: 0,
    	pars: {
    		refreshpulse: {
    			type: "pulse"
    		},
    		flipfacing: {
    			type: "toggle"
    		},
    		refresh: {
    			type: "toggle"
    		},
    		normals: {
    			type: "toggle"
    		},
    		file: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var circleSOP = {
    	maxInputs: 1,
    	pars: {
    		rad: {
    			type: "xy"
    		},
    		order: {
    			type: "number"
    		},
    		imperfect: {
    			type: "toggle"
    		},
    		modifybounds: {
    			type: "toggle"
    		},
    		t: {
    			type: "xyz"
    		},
    		normals: {
    			type: "toggle"
    		},
    		endangle: {
    			type: "float"
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"prim",
    				"poly",
    				"nurbs",
    				"bezier"
    			]
    		},
    		beginangle: {
    			type: "float"
    		},
    		orient: {
    			type: "menu",
    			menuitems: [
    				"xy",
    				"yz",
    				"zx"
    			]
    		},
    		arc: {
    			type: "menu",
    			menuitems: [
    				"closed",
    				"openarc",
    				"closedarc",
    				"slicedarc"
    			]
    		},
    		texture: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"face"
    			]
    		},
    		divs: {
    			type: "number"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var creepSOP = {
    	maxInputs: 2,
    	pars: {
    		resetmethod: {
    			type: "menu",
    			menuitems: [
    				"fillpath",
    				"keepproportions"
    			]
    		},
    		reset: {
    			type: "pulse"
    		},
    		t: {
    			type: "xyz"
    		},
    		r: {
    			type: "xyz"
    		},
    		s: {
    			type: "xyz"
    		}
    	},
    	minInputs: 2,
    	type: "SOP"
    };
    var holeSOP = {
    	maxInputs: 1,
    	pars: {
    		unbridge: {
    			type: "toggle"
    		},
    		snap: {
    			type: "toggle"
    		},
    		angle: {
    			type: "float"
    		},
    		group: {
    			type: "string"
    		},
    		dist: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var raySOP = {
    	maxInputs: 2,
    	pars: {
    		lookfar: {
    			type: "toggle"
    		},
    		putdist: {
    			type: "toggle"
    		},
    		jitter: {
    			type: "float"
    		},
    		newgrp: {
    			type: "toggle"
    		},
    		hitgrp: {
    			type: "string"
    		},
    		bouncegeo: {
    			type: "toggle"
    		},
    		bounces: {
    			type: "number"
    		},
    		group: {
    			type: "string"
    		},
    		seed: {
    			type: "number"
    		},
    		sample: {
    			type: "number"
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"minimum",
    				"project"
    			]
    		},
    		dotrans: {
    			type: "toggle"
    		},
    		normal: {
    			type: "menu",
    			menuitems: [
    				"source",
    				"collision",
    				"reflect"
    			]
    		},
    		scale: {
    			type: "float"
    		},
    		lift: {
    			type: "float"
    		}
    	},
    	minInputs: 2,
    	type: "SOP"
    };
    var extrudeSOP = {
    	maxInputs: 2,
    	pars: {
    		frontgrp: {
    			type: "string"
    		},
    		sharefaces: {
    			type: "toggle"
    		},
    		xsectiongrp: {
    			type: "string"
    		},
    		cuspangle: {
    			type: "float"
    		},
    		vertex: {
    			type: "number"
    		},
    		thickscale: {
    			type: "float"
    		},
    		initextrude: {
    			type: "pulse"
    		},
    		sidegrp: {
    			type: "string"
    		},
    		fronttype: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"face",
    				"convex"
    			]
    		},
    		sidetype: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"rows",
    				"cols",
    				"rowcol",
    				"triangles",
    				"quads",
    				"alttriangles"
    			]
    		},
    		thickxlate: {
    			type: "float"
    		},
    		docusp: {
    			type: "toggle"
    		},
    		sourcegrp: {
    			type: "string"
    		},
    		depthscale: {
    			type: "float"
    		},
    		backgrp: {
    			type: "string"
    		},
    		removesharedsides: {
    			type: "toggle"
    		},
    		depthxlate: {
    			type: "float"
    		},
    		dofuse: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"all",
    				"min",
    				"on",
    				"straight"
    			]
    		},
    		newg: {
    			type: "toggle"
    		},
    		backtype: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"face",
    				"convex"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var copySOP = {
    	maxInputs: 2,
    	pars: {
    		param6: {
    			type: "string"
    		},
    		ncy: {
    			type: "number"
    		},
    		setprim: {
    			type: "string"
    		},
    		param5: {
    			type: "string"
    		},
    		doattr: {
    			type: "toggle"
    		},
    		nprims: {
    			type: "number"
    		},
    		val7: {
    			type: "float"
    		},
    		sourcegrp: {
    			type: "string"
    		},
    		templategrp: {
    			type: "string"
    		},
    		val9: {
    			type: "float"
    		},
    		val3: {
    			type: "float"
    		},
    		subprim: {
    			type: "string"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		subpt: {
    			type: "string"
    		},
    		mulprim: {
    			type: "string"
    		},
    		param10: {
    			type: "string"
    		},
    		cum: {
    			type: "toggle"
    		},
    		param1: {
    			type: "string"
    		},
    		val1: {
    			type: "float"
    		},
    		addvtx: {
    			type: "string"
    		},
    		param8: {
    			type: "string"
    		},
    		p: {
    			type: "xyz"
    		},
    		nml: {
    			type: "toggle"
    		},
    		param4: {
    			type: "string"
    		},
    		param9: {
    			type: "string"
    		},
    		addprim: {
    			type: "string"
    		},
    		r: {
    			type: "xyz"
    		},
    		val8: {
    			type: "float"
    		},
    		setvtx: {
    			type: "string"
    		},
    		param2: {
    			type: "string"
    		},
    		val5: {
    			type: "float"
    		},
    		scale: {
    			type: "float"
    		},
    		mulvtx: {
    			type: "string"
    		},
    		t: {
    			type: "xyz"
    		},
    		newg: {
    			type: "toggle"
    		},
    		addpt: {
    			type: "string"
    		},
    		param3: {
    			type: "string"
    		},
    		mulpt: {
    			type: "string"
    		},
    		val2: {
    			type: "float"
    		},
    		param7: {
    			type: "string"
    		},
    		setpt: {
    			type: "string"
    		},
    		subvtx: {
    			type: "string"
    		},
    		val10: {
    			type: "float"
    		},
    		s: {
    			type: "xyz"
    		},
    		val6: {
    			type: "float"
    		},
    		vlength: {
    			type: "toggle"
    		},
    		lookat: {
    			type: "COMP"
    		},
    		val4: {
    			type: "float"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		copyg: {
    			type: "string"
    		},
    		stamp: {
    			type: "toggle"
    		},
    		upvector: {
    			type: "xyz"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var subdivideSOP = {
    	maxInputs: 2,
    	pars: {
    		creaseweight: {
    			type: "float"
    		},
    		outcreasegroup: {
    			type: "string"
    		},
    		iterations: {
    			type: "number"
    		},
    		overridecrease: {
    			type: "toggle"
    		},
    		creases: {
    			type: "string"
    		},
    		outputcrease: {
    			type: "toggle"
    		},
    		bias: {
    			type: "float"
    		},
    		closeholes: {
    			type: "menu",
    			menuitems: [
    				"noclose",
    				"pull",
    				"stitch"
    			]
    		},
    		subdivide: {
    			type: "string"
    		},
    		surroundpoly: {
    			type: "menu",
    			menuitems: [
    				"nodiv",
    				"edges",
    				"triangulate"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var stitchSOP = {
    	maxInputs: 2,
    	pars: {
    		dostitch: {
    			type: "toggle"
    		},
    		stitchop: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"group",
    				"skip"
    			]
    		},
    		leftuv2: {
    			type: "float"
    		},
    		lrscale2: {
    			type: "float"
    		},
    		inc: {
    			type: "number"
    		},
    		group: {
    			type: "string"
    		},
    		dotangent: {
    			type: "toggle"
    		},
    		rightuv1: {
    			type: "float"
    		},
    		rightuv2: {
    			type: "float"
    		},
    		fixed: {
    			type: "toggle"
    		},
    		sharp: {
    			type: "toggle"
    		},
    		loop: {
    			type: "toggle"
    		},
    		leftuv1: {
    			type: "float"
    		},
    		tolerance: {
    			type: "float"
    		},
    		dir: {
    			type: "menu",
    			menuitems: [
    				"ujoin",
    				"vjoin"
    			]
    		},
    		bias: {
    			type: "float"
    		},
    		lrscale1: {
    			type: "float"
    		},
    		lrwidth1: {
    			type: "float"
    		},
    		lrwidth2: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var cplusplusSOP = {
    	maxInputs: 1,
    	pars: {
    		plugin: {
    			type: "string"
    		},
    		reinitpulse: {
    			type: "pulse"
    		},
    		unloadplugin: {
    			type: "toggle"
    		},
    		reinit: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var facetSOP = {
    	maxInputs: 1,
    	pars: {
    		dist: {
    			type: "float"
    		},
    		orientpolys: {
    			type: "toggle"
    		},
    		cons: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"points",
    				"fpoints",
    				"normals",
    				"fnormals"
    			]
    		},
    		group: {
    			type: "string"
    		},
    		inlinedist: {
    			type: "float"
    		},
    		unit: {
    			type: "toggle"
    		},
    		cusp: {
    			type: "toggle"
    		},
    		remove: {
    			type: "toggle"
    		},
    		prenml: {
    			type: "toggle"
    		},
    		inline: {
    			type: "toggle"
    		},
    		unique: {
    			type: "toggle"
    		},
    		postnml: {
    			type: "toggle"
    		},
    		angle: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var forceSOP = {
    	maxInputs: 1,
    	pars: {
    		radial: {
    			type: "float"
    		},
    		vortex: {
    			type: "float"
    		},
    		axial: {
    			type: "float"
    		},
    		dir: {
    			type: "xyz"
    		},
    		doaxis: {
    			type: "toggle"
    		},
    		spiral: {
    			type: "float"
    		},
    		doradial: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var sweepSOP = {
    	maxInputs: 3,
    	pars: {
    		usevtx: {
    			type: "toggle"
    		},
    		aimatref: {
    			type: "toggle"
    		},
    		skin: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		twist: {
    			type: "float"
    		},
    		xgrp: {
    			type: "string"
    		},
    		vertex: {
    			type: "number"
    		},
    		cycle: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"each",
    				"cycle"
    			]
    		},
    		newg: {
    			type: "toggle"
    		},
    		roll: {
    			type: "float"
    		},
    		noflip: {
    			type: "toggle"
    		},
    		sweepgrp: {
    			type: "string"
    		},
    		refgrp: {
    			type: "string"
    		},
    		skipcoin: {
    			type: "toggle"
    		},
    		pathgrp: {
    			type: "string"
    		},
    		angle: {
    			type: "toggle"
    		},
    		scale: {
    			type: "float"
    		},
    		fast: {
    			type: "toggle"
    		}
    	},
    	minInputs: 2,
    	type: "SOP"
    };
    var polypatchSOP = {
    	maxInputs: 1,
    	pars: {
    		closev: {
    			type: "menu",
    			menuitems: [
    				"nonewv",
    				"wv",
    				"ifprimwv"
    			]
    		},
    		divisionsy: {
    			type: "number"
    		},
    		group: {
    			type: "string"
    		},
    		divisionsx: {
    			type: "number"
    		},
    		firstvclamp: {
    			type: "menu",
    			menuitems: [
    				"firstvclampoff",
    				"firstvclampon",
    				"firstvclampifprim"
    			]
    		},
    		connecttype: {
    			type: "menu",
    			menuitems: [
    				"rows",
    				"cols",
    				"rowcol",
    				"triangles",
    				"quads",
    				"alttriangles",
    				"inheritconnect"
    			]
    		},
    		lastvclamp: {
    			type: "menu",
    			menuitems: [
    				"lastvclampoff",
    				"lastvclampon",
    				"lastvclampifprim"
    			]
    		},
    		basis: {
    			type: "menu",
    			menuitems: [
    				"cardinal",
    				"bspline"
    			]
    		},
    		lastuclamp: {
    			type: "menu",
    			menuitems: [
    				"lastuclampoff",
    				"lastuclampon",
    				"lastuclampifprim"
    			]
    		},
    		closeu: {
    			type: "menu",
    			menuitems: [
    				"nonewu",
    				"wu",
    				"ifprimwu"
    			]
    		},
    		firstuclamp: {
    			type: "menu",
    			menuitems: [
    				"firstuclampoff",
    				"firstuclampon",
    				"firstuclampifprim"
    			]
    		},
    		polys: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var outSOP = {
    	maxInputs: 1,
    	pars: {
    		label: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var switchSOP = {
    	maxInputs: 9999,
    	pars: {
    		input: {
    			type: "number"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var profileSOP = {
    	maxInputs: 1,
    	pars: {
    		urange1: {
    			type: "float"
    		},
    		order: {
    			type: "number"
    		},
    		tolerance: {
    			type: "float"
    		},
    		group: {
    			type: "string"
    		},
    		delprof: {
    			type: "toggle"
    		},
    		vrange2: {
    			type: "float"
    		},
    		sdivs: {
    			type: "number"
    		},
    		urange2: {
    			type: "float"
    		},
    		smooth: {
    			type: "toggle"
    		},
    		maptype: {
    			type: "menu",
    			menuitems: [
    				"unif",
    				"chordlen"
    			]
    		},
    		parametric: {
    			type: "toggle"
    		},
    		vrange1: {
    			type: "float"
    		},
    		csharp: {
    			type: "toggle"
    		},
    		keepsurf: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var vertexSOP = {
    	maxInputs: 2,
    	pars: {
    		crease: {
    			type: "float"
    		},
    		custom4type: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4",
    				"int",
    				"ivec2",
    				"ivec3",
    				"ivec4"
    			]
    		},
    		custom1val4: {
    			type: "float"
    		},
    		diff: {
    			type: "rgb"
    		},
    		custom4val1: {
    			type: "float"
    		},
    		custom3val3: {
    			type: "float"
    		},
    		douvw: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		custom2val3: {
    			type: "float"
    		},
    		custom4val4: {
    			type: "float"
    		},
    		doclr: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		custom4: {
    			type: "string"
    		},
    		alpha: {
    			type: "float"
    		},
    		custom2type: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4",
    				"int",
    				"ivec2",
    				"ivec3",
    				"ivec4"
    			]
    		},
    		docrease: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		custom1val2: {
    			type: "float"
    		},
    		custom1val1: {
    			type: "float"
    		},
    		custom3val4: {
    			type: "float"
    		},
    		custom3type: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4",
    				"int",
    				"ivec2",
    				"ivec3",
    				"ivec4"
    			]
    		},
    		custom1val3: {
    			type: "float"
    		},
    		custom3: {
    			type: "string"
    		},
    		custom3val1: {
    			type: "float"
    		},
    		custom2val4: {
    			type: "float"
    		},
    		custom4val2: {
    			type: "float"
    		},
    		custom3val2: {
    			type: "float"
    		},
    		group: {
    			type: "string"
    		},
    		custom2val2: {
    			type: "float"
    		},
    		custom2val1: {
    			type: "float"
    		},
    		custom1: {
    			type: "string"
    		},
    		custom4val3: {
    			type: "float"
    		},
    		custom2: {
    			type: "string"
    		},
    		custom1type: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4",
    				"int",
    				"ivec2",
    				"ivec3",
    				"ivec4"
    			]
    		},
    		map: {
    			type: "uvw"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var mergeSOP = {
    	maxInputs: 9999,
    	pars: {
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var divideSOP = {
    	maxInputs: 1,
    	pars: {
    		group: {
    			type: "string"
    		},
    		offset: {
    			type: "xyz"
    		},
    		brick: {
    			type: "toggle"
    		},
    		size: {
    			type: "xyz"
    		},
    		planar: {
    			type: "toggle"
    		},
    		convex: {
    			type: "toggle"
    		},
    		weight1: {
    			type: "float"
    		},
    		dual: {
    			type: "toggle"
    		},
    		smooth: {
    			type: "toggle"
    		},
    		weight2: {
    			type: "float"
    		},
    		numsides: {
    			type: "number"
    		},
    		angle: {
    			type: "xyz"
    		},
    		removesh: {
    			type: "toggle"
    		},
    		divs: {
    			type: "number"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var captureregionSOP = {
    	maxInputs: 0,
    	pars: {
    		weight1: {
    			type: "float"
    		},
    		tcap: {
    			type: "xyz"
    		},
    		weight2: {
    			type: "float"
    		},
    		theight: {
    			type: "float"
    		},
    		orient: {
    			type: "menu",
    			menuitems: [
    				"x",
    				"y",
    				"z"
    			]
    		},
    		bheight: {
    			type: "float"
    		},
    		t: {
    			type: "xyz"
    		},
    		bcap: {
    			type: "xyz"
    		},
    		color: {
    			type: "rgb"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var clipSOP = {
    	maxInputs: 1,
    	pars: {
    		below: {
    			type: "string"
    		},
    		clipop: {
    			type: "menu",
    			menuitems: [
    				"above",
    				"below",
    				"both"
    			]
    		},
    		dir: {
    			type: "xyz"
    		},
    		dist: {
    			type: "float"
    		},
    		group: {
    			type: "string"
    		},
    		newg: {
    			type: "toggle"
    		},
    		above: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var linethickSOP = {
    	maxInputs: 1,
    	pars: {
    		divisions: {
    			type: "number"
    		},
    		rows: {
    			type: "number"
    		},
    		startwidth1: {
    			type: "float"
    		},
    		endwidth2: {
    			type: "float"
    		},
    		domain2: {
    			type: "float"
    		},
    		symmetric: {
    			type: "toggle"
    		},
    		endwidth1: {
    			type: "float"
    		},
    		startwidth2: {
    			type: "float"
    		},
    		shape: {
    			type: "menu",
    			menuitems: [
    				"linear",
    				"easein",
    				"easeout",
    				"ease",
    				"cubic"
    			]
    		},
    		group: {
    			type: "string"
    		},
    		domain1: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var selectSOP = {
    	maxInputs: 0,
    	pars: {
    		sop: {
    			type: "SOP"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var inversecurveSOP = {
    	maxInputs: 0,
    	pars: {
    		chop: {
    			type: "CHOP"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var pointSOP = {
    	maxInputs: 2,
    	pars: {
    		pscale: {
    			type: "float"
    		},
    		custom1val4: {
    			type: "float"
    		},
    		custom4val1: {
    			type: "float"
    		},
    		custom3val3: {
    			type: "float"
    		},
    		douvw: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		radialf: {
    			type: "float"
    		},
    		doradialf: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		custom4: {
    			type: "string"
    		},
    		doradius: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		custom2type: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4",
    				"int",
    				"ivec2",
    				"ivec3",
    				"ivec4"
    			]
    		},
    		custom4type: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4",
    				"int",
    				"ivec2",
    				"ivec3",
    				"ivec4"
    			]
    		},
    		custom1val2: {
    			type: "float"
    		},
    		custom1val1: {
    			type: "float"
    		},
    		custom3val4: {
    			type: "float"
    		},
    		custom1val3: {
    			type: "float"
    		},
    		scalef: {
    			type: "float"
    		},
    		custom3: {
    			type: "string"
    		},
    		custom3val1: {
    			type: "float"
    		},
    		doup: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		doscale: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		custom4val2: {
    			type: "float"
    		},
    		mass: {
    			type: "float"
    		},
    		doweight: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on"
    			]
    		},
    		custom3val2: {
    			type: "float"
    		},
    		v: {
    			type: "xyz"
    		},
    		custom2val1: {
    			type: "float"
    		},
    		tension: {
    			type: "float"
    		},
    		custom1: {
    			type: "string"
    		},
    		dotension: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		custom2: {
    			type: "string"
    		},
    		donml: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		custom2val3: {
    			type: "float"
    		},
    		map: {
    			type: "uvw"
    		},
    		group: {
    			type: "string"
    		},
    		diff: {
    			type: "rgb"
    		},
    		dovel: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		t: {
    			type: "xyz"
    		},
    		doedgef: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		weight: {
    			type: "float"
    		},
    		doclr: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		dirf: {
    			type: "xyz"
    		},
    		normalf: {
    			type: "float"
    		},
    		drag: {
    			type: "float"
    		},
    		custom3type: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4",
    				"int",
    				"ivec2",
    				"ivec3",
    				"ivec4"
    			]
    		},
    		domass: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		custom2val4: {
    			type: "float"
    		},
    		n: {
    			type: "xyz"
    		},
    		dodirf: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		dopscale: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		alpha: {
    			type: "float"
    		},
    		edgef: {
    			type: "float"
    		},
    		radiusf: {
    			type: "float"
    		},
    		custom2val2: {
    			type: "float"
    		},
    		dospringk: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		custom4val3: {
    			type: "float"
    		},
    		custom4val4: {
    			type: "float"
    		},
    		donormalf: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		custom1type: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4",
    				"int",
    				"ivec2",
    				"ivec3",
    				"ivec4"
    			]
    		},
    		springk: {
    			type: "float"
    		},
    		up: {
    			type: "xyz"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var superquadSOP = {
    	maxInputs: 1,
    	pars: {
    		rad: {
    			type: "xyz"
    		},
    		normals: {
    			type: "toggle"
    		},
    		expz: {
    			type: "float"
    		},
    		cols: {
    			type: "number"
    		},
    		modifybounds: {
    			type: "toggle"
    		},
    		t: {
    			type: "xyz"
    		},
    		expxy: {
    			type: "float"
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"poly",
    				"mesh"
    			]
    		},
    		surftype: {
    			type: "menu",
    			menuitems: [
    				"rows",
    				"cols",
    				"rowcol",
    				"triangles",
    				"quads",
    				"alttriangles"
    			]
    		},
    		rows: {
    			type: "number"
    		},
    		cusp: {
    			type: "toggle"
    		},
    		orient: {
    			type: "menu",
    			menuitems: [
    				"x",
    				"y",
    				"z"
    			]
    		},
    		upole: {
    			type: "toggle"
    		},
    		angle: {
    			type: "float"
    		},
    		texture: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"rowcol"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var railsSOP = {
    	maxInputs: 2,
    	pars: {
    		usevtx: {
    			type: "toggle"
    		},
    		xsectgrp: {
    			type: "string"
    		},
    		usedir: {
    			type: "toggle"
    		},
    		vertex2: {
    			type: "number"
    		},
    		roll: {
    			type: "float"
    		},
    		railname: {
    			type: "string"
    		},
    		cycle: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"each",
    				"cycle"
    			]
    		},
    		vertex1: {
    			type: "number"
    		},
    		newg: {
    			type: "toggle"
    		},
    		railgrp: {
    			type: "string"
    		},
    		stretch: {
    			type: "toggle"
    		},
    		dir: {
    			type: "xyz"
    		},
    		noflip: {
    			type: "toggle"
    		},
    		scale: {
    			type: "float"
    		},
    		pairs: {
    			type: "toggle"
    		},
    		firstl: {
    			type: "toggle"
    		}
    	},
    	minInputs: 2,
    	type: "SOP"
    };
    var filletSOP = {
    	maxInputs: 2,
    	pars: {
    		cut: {
    			type: "toggle"
    		},
    		seamless: {
    			type: "toggle"
    		},
    		order: {
    			type: "number"
    		},
    		inc: {
    			type: "number"
    		},
    		leftuv2: {
    			type: "float"
    		},
    		lrscale2: {
    			type: "float"
    		},
    		fillet: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"group",
    				"skip"
    			]
    		},
    		group: {
    			type: "string"
    		},
    		primtype: {
    			type: "menu",
    			menuitems: [
    			]
    		},
    		rightuv1: {
    			type: "float"
    		},
    		rightuv2: {
    			type: "float"
    		},
    		fillettype: {
    			type: "menu",
    			menuitems: [
    				"freeform",
    				"convex",
    				"circular"
    			]
    		},
    		lroffset2: {
    			type: "float"
    		},
    		loop: {
    			type: "toggle"
    		},
    		leftuv1: {
    			type: "float"
    		},
    		dir: {
    			type: "menu",
    			menuitems: [
    				"ujoin",
    				"vjoin"
    			]
    		},
    		lrscale1: {
    			type: "float"
    		},
    		lrwidth1: {
    			type: "float"
    		},
    		lrwidth2: {
    			type: "float"
    		},
    		lroffset1: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var armSOP = {
    	maxInputs: 0,
    	pars: {
    		elbow3t: {
    			type: "xyz"
    		},
    		elbow4t: {
    			type: "xyz"
    		},
    		handlength: {
    			type: "float"
    		},
    		autoelbow: {
    			type: "toggle"
    		},
    		humlength: {
    			type: "float"
    		},
    		flipelbow: {
    			type: "toggle"
    		},
    		rotatehand: {
    			type: "toggle"
    		},
    		elbow5t: {
    			type: "xyz"
    		},
    		elbowtwist: {
    			type: "float"
    		},
    		shoulder2t: {
    			type: "xyz"
    		},
    		elbow2t: {
    			type: "xyz"
    		},
    		wrist: {
    			type: "float"
    		},
    		t: {
    			type: "xyz"
    		},
    		wrist5t: {
    			type: "xyz"
    		},
    		affector: {
    			type: "COMP"
    		},
    		wrist2t: {
    			type: "xyz"
    		},
    		bonerad: {
    			type: "float"
    		},
    		shoulder4t: {
    			type: "xyz"
    		},
    		shoulder1t: {
    			type: "xyz"
    		},
    		s: {
    			type: "xyz"
    		},
    		wrist1t: {
    			type: "xyz"
    		},
    		axis: {
    			type: "menu",
    			menuitems: [
    				"posx",
    				"negx"
    			]
    		},
    		shoulder3t: {
    			type: "xyz"
    		},
    		shoulder: {
    			type: "float"
    		},
    		clavlength: {
    			type: "float"
    		},
    		wrist4t: {
    			type: "xyz"
    		},
    		wrist3t: {
    			type: "xyz"
    		},
    		r: {
    			type: "xyz"
    		},
    		elbow: {
    			type: "float"
    		},
    		capttype: {
    			type: "menu",
    			menuitems: [
    				"ellipses",
    				"cregions"
    			]
    		},
    		shoulder5t: {
    			type: "xyz"
    		},
    		elbow1t: {
    			type: "xyz"
    		},
    		ulnalength: {
    			type: "float"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var bridgeSOP = {
    	maxInputs: 1,
    	pars: {
    		bridge: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"group",
    				"skip"
    			]
    		},
    		scalet1: {
    			type: "float"
    		},
    		circular: {
    			type: "toggle"
    		},
    		order: {
    			type: "number"
    		},
    		scalet2: {
    			type: "float"
    		},
    		rotatet2: {
    			type: "float"
    		},
    		inc: {
    			type: "number"
    		},
    		rotatet3: {
    			type: "float"
    		},
    		rotatet1: {
    			type: "float"
    		},
    		group: {
    			type: "string"
    		},
    		sdivs: {
    			type: "number"
    		},
    		frenet: {
    			type: "menu",
    			menuitems: [
    				"frenet",
    				"normal"
    			]
    		},
    		tolerance: {
    			type: "float"
    		},
    		scalec1: {
    			type: "float"
    		},
    		isodivs: {
    			type: "number"
    		},
    		scalec2: {
    			type: "float"
    		},
    		scalet3: {
    			type: "float"
    		},
    		csharp: {
    			type: "toggle"
    		},
    		curvature: {
    			type: "toggle"
    		},
    		scalec3: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var wireframeSOP = {
    	maxInputs: 1,
    	pars: {
    		fast: {
    			type: "toggle"
    		},
    		caps: {
    			type: "toggle"
    		},
    		corners: {
    			type: "toggle"
    		},
    		group: {
    			type: "string"
    		},
    		remove: {
    			type: "toggle"
    		},
    		radius: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var projectSOP = {
    	maxInputs: 2,
    	pars: {
    		surfgroup: {
    			type: "string"
    		},
    		order: {
    			type: "number"
    		},
    		rtolerance: {
    			type: "float"
    		},
    		cycle: {
    			type: "menu",
    			menuitems: [
    				"allseq",
    				"allover",
    				"oneeach",
    				"cycled"
    			]
    		},
    		ftolerance: {
    			type: "float"
    		},
    		vector2: {
    			type: "float"
    		},
    		sdivs: {
    			type: "number"
    		},
    		vrange2: {
    			type: "float"
    		},
    		facegroup: {
    			type: "string"
    		},
    		uvgap: {
    			type: "float"
    		},
    		urange1: {
    			type: "float"
    		},
    		maptype: {
    			type: "menu",
    			menuitems: [
    				"unif",
    				"chordlen"
    			]
    		},
    		urange2: {
    			type: "float"
    		},
    		vector1: {
    			type: "float"
    		},
    		vrange1: {
    			type: "float"
    		},
    		ufrom: {
    			type: "menu",
    			menuitems: [
    				"uvx",
    				"uvy",
    				"uvz"
    			]
    		},
    		csharp: {
    			type: "toggle"
    		},
    		axis: {
    			type: "menu",
    			menuitems: [
    				"xaxis",
    				"yaxis",
    				"zaxis",
    				"fnorm",
    				"mindist",
    				"other"
    			]
    		},
    		userange: {
    			type: "toggle"
    		},
    		accurate: {
    			type: "toggle"
    		},
    		vfrom: {
    			type: "menu",
    			menuitems: [
    				"uvx",
    				"uvy",
    				"uvz"
    			]
    		},
    		projside: {
    			type: "menu",
    			menuitems: [
    				"closest",
    				"farthest"
    			]
    		},
    		vector3: {
    			type: "float"
    		}
    	},
    	minInputs: 2,
    	type: "SOP"
    };
    var modelSOP = {
    	maxInputs: 0,
    	pars: {
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var curveclaySOP = {
    	maxInputs: 3,
    	pars: {
    		projdir1: {
    			type: "float"
    		},
    		surfgroup: {
    			type: "string"
    		},
    		deformop: {
    			type: "menu",
    			menuitems: [
    				"snormal",
    				"xaxis",
    				"yaxis",
    				"zaxis",
    				"other"
    			]
    		},
    		deformlen: {
    			type: "float"
    		},
    		deforminside: {
    			type: "toggle"
    		},
    		deformdir1: {
    			type: "float"
    		},
    		deformdir2: {
    			type: "float"
    		},
    		facegroup: {
    			type: "string"
    		},
    		projop: {
    			type: "menu",
    			menuitems: [
    				"xaxis",
    				"yaxis",
    				"zaxis",
    				"mindist",
    				"other"
    			]
    		},
    		projdir2: {
    			type: "float"
    		},
    		sharp: {
    			type: "float"
    		},
    		individual: {
    			type: "toggle"
    		},
    		projdir3: {
    			type: "float"
    		},
    		refine: {
    			type: "float"
    		},
    		deformdir3: {
    			type: "float"
    		},
    		divs: {
    			type: "number"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var limitSOP = {
    	maxInputs: 0,
    	pars: {
    		dorotate: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"cum"
    			]
    		},
    		chanradx: {
    			type: "string"
    		},
    		output: {
    			type: "menu",
    			menuitems: [
    				"line",
    				"polys",
    				"circles",
    				"spheres",
    				"polyspheres",
    				"tubes",
    				"strips"
    			]
    		},
    		chanr: {
    			type: "string"
    		},
    		customattrib0chan0: {
    			type: "string"
    		},
    		chanrz: {
    			type: "string"
    		},
    		rad: {
    			type: "float"
    		},
    		flipsmooth: {
    			type: "float"
    		},
    		customattrib1: {
    			type: "string"
    		},
    		ylimitmin: {
    			type: "float"
    		},
    		chanz: {
    			type: "string"
    		},
    		customattrib0chan1: {
    			type: "string"
    		},
    		customattrib1chan1: {
    			type: "string"
    		},
    		rotate: {
    			type: "xyz"
    		},
    		chop: {
    			type: "CHOP"
    		},
    		xlimitmin: {
    			type: "float"
    		},
    		customattrib1chan3: {
    			type: "string"
    		},
    		zlimitmin: {
    			type: "float"
    		},
    		customattrib0: {
    			type: "string"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		customattrib1chan2: {
    			type: "string"
    		},
    		chanalpha: {
    			type: "string"
    		},
    		texscale2: {
    			type: "float"
    		},
    		normals: {
    			type: "toggle"
    		},
    		zlimitmax: {
    			type: "float"
    		},
    		chanradz: {
    			type: "string"
    		},
    		chanry: {
    			type: "string"
    		},
    		chanrady: {
    			type: "string"
    		},
    		texture: {
    			type: "toggle"
    		},
    		dolimit: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"clamp",
    				"loop",
    				"zigzag"
    			]
    		},
    		customattrib1chan0: {
    			type: "string"
    		},
    		ylimitmax: {
    			type: "float"
    		},
    		texturew: {
    			type: "string"
    		},
    		chany: {
    			type: "string"
    		},
    		customattrib0chan3: {
    			type: "string"
    		},
    		chanb: {
    			type: "string"
    		},
    		orient: {
    			type: "toggle"
    		},
    		chanrx: {
    			type: "string"
    		},
    		divisions: {
    			type: "number"
    		},
    		chanx: {
    			type: "string"
    		},
    		texscale1: {
    			type: "float"
    		},
    		lookat: {
    			type: "COMP"
    		},
    		customattrib0chan2: {
    			type: "string"
    		},
    		texoffset1: {
    			type: "float"
    		},
    		xlimitmax: {
    			type: "float"
    		},
    		chanrad: {
    			type: "string"
    		},
    		texoffset2: {
    			type: "float"
    		},
    		chang: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var trimSOP = {
    	maxInputs: 1,
    	pars: {
    		group: {
    			type: "string"
    		},
    		trimtol: {
    			type: "float"
    		},
    		altitude: {
    			type: "number"
    		},
    		individual: {
    			type: "toggle"
    		},
    		bigloop: {
    			type: "toggle"
    		},
    		optype: {
    			type: "menu",
    			menuitems: [
    				"keepout",
    				"keepin",
    				"keepnatural",
    				"untrim",
    				"chgalt"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var alembicSOP = {
    	maxInputs: 0,
    	pars: {
    		loadfile: {
    			type: "pulse"
    		},
    		xform: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"staticlocalxform",
    				"staticworldxform",
    				"dynamicxform"
    			]
    		},
    		straightgpu: {
    			type: "toggle"
    		},
    		compnml: {
    			type: "toggle"
    		},
    		file: {
    			type: "string"
    		},
    		objectpath: {
    			type: "string"
    		},
    		interp: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"interp"
    			]
    		},
    		timeunit: {
    			type: "menu",
    			menuitems: [
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		time: {
    			type: "float"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var deformSOP = {
    	maxInputs: 1,
    	pars: {
    		delcaptatr: {
    			type: "toggle"
    		},
    		group: {
    			type: "string"
    		},
    		delcolatr: {
    			type: "toggle"
    		},
    		donormal: {
    			type: "toggle"
    		},
    		skelrootpath: {
    			type: "COMP"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var latticeSOP = {
    	maxInputs: 3,
    	pars: {
    		divsx: {
    			type: "number"
    		},
    		kernel: {
    			type: "string"
    		},
    		group: {
    			type: "string"
    		},
    		divsz: {
    			type: "number"
    		},
    		divsy: {
    			type: "number"
    		},
    		radius: {
    			type: "float"
    		}
    	},
    	minInputs: 3,
    	type: "SOP"
    };
    var addSOP = {
    	maxInputs: 1,
    	pars: {
    		closedall: {
    			type: "toggle"
    		},
    		usept0: {
    			type: "toggle"
    		},
    		closed1: {
    			type: "toggle"
    		},
    		polydat: {
    			type: "DAT"
    		},
    		pointdat: {
    			type: "DAT"
    		},
    		usept2: {
    			type: "toggle"
    		},
    		weight2: {
    			type: "float"
    		},
    		usept5: {
    			type: "toggle"
    		},
    		normals: {
    			type: "toggle"
    		},
    		inc: {
    			type: "number"
    		},
    		usept3: {
    			type: "toggle"
    		},
    		usept4: {
    			type: "toggle"
    		},
    		weight1: {
    			type: "float"
    		},
    		prim4: {
    			type: "string"
    		},
    		weight0: {
    			type: "float"
    		},
    		closed0: {
    			type: "toggle"
    		},
    		pt3: {
    			type: "xyz"
    		},
    		prim0: {
    			type: "string"
    		},
    		closed3: {
    			type: "toggle"
    		},
    		pt2: {
    			type: "xyz"
    		},
    		add: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"group",
    				"skip",
    				"sep"
    			]
    		},
    		weight4: {
    			type: "float"
    		},
    		pt1: {
    			type: "xyz"
    		},
    		keep: {
    			type: "toggle"
    		},
    		prim5: {
    			type: "string"
    		},
    		pt0: {
    			type: "xyz"
    		},
    		closed4: {
    			type: "toggle"
    		},
    		namedattribs: {
    			type: "toggle"
    		},
    		prim2: {
    			type: "string"
    		},
    		group: {
    			type: "string"
    		},
    		weight5: {
    			type: "float"
    		},
    		pt5: {
    			type: "xyz"
    		},
    		prim1: {
    			type: "string"
    		},
    		pt4: {
    			type: "xyz"
    		},
    		closed2: {
    			type: "toggle"
    		},
    		weight3: {
    			type: "float"
    		},
    		closed5: {
    			type: "toggle"
    		},
    		usept1: {
    			type: "toggle"
    		},
    		remove: {
    			type: "toggle"
    		},
    		prim3: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var tubeSOP = {
    	maxInputs: 1,
    	pars: {
    		height: {
    			type: "float"
    		},
    		modifybounds: {
    			type: "toggle"
    		},
    		normals: {
    			type: "toggle"
    		},
    		imperfect: {
    			type: "toggle"
    		},
    		cols: {
    			type: "number"
    		},
    		rad2: {
    			type: "float"
    		},
    		t: {
    			type: "xyz"
    		},
    		orderv: {
    			type: "number"
    		},
    		orderu: {
    			type: "number"
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"prim",
    				"poly",
    				"mesh",
    				"nurbs",
    				"bezier"
    			]
    		},
    		surftype: {
    			type: "menu",
    			menuitems: [
    				"rows",
    				"cols",
    				"rowcol",
    				"triangles",
    				"quads",
    				"alttriangles"
    			]
    		},
    		rows: {
    			type: "number"
    		},
    		rad1: {
    			type: "float"
    		},
    		orient: {
    			type: "menu",
    			menuitems: [
    				"x",
    				"y",
    				"z"
    			]
    		},
    		cap: {
    			type: "toggle"
    		},
    		texture: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"rowcol"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var jointSOP = {
    	maxInputs: 1,
    	pars: {
    		mintwist: {
    			type: "toggle"
    		},
    		preserve1: {
    			type: "toggle"
    		},
    		group: {
    			type: "string"
    		},
    		smoothtwist: {
    			type: "toggle"
    		},
    		majoraxes: {
    			type: "toggle"
    		},
    		preserve2: {
    			type: "toggle"
    		},
    		lroffset2: {
    			type: "float"
    		},
    		orient: {
    			type: "toggle"
    		},
    		smoothpath: {
    			type: "toggle"
    		},
    		lrscale1: {
    			type: "float"
    		},
    		lrscale2: {
    			type: "float"
    		},
    		lroffset1: {
    			type: "float"
    		},
    		divs: {
    			type: "number"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var attributeSOP = {
    	maxInputs: 1,
    	pars: {
    		todtl2: {
    			type: "string"
    		},
    		fromvtx0: {
    			type: "string"
    		},
    		fromvtx4: {
    			type: "string"
    		},
    		topt4: {
    			type: "string"
    		},
    		fromdtl4: {
    			type: "string"
    		},
    		topr0: {
    			type: "string"
    		},
    		topr3: {
    			type: "string"
    		},
    		todtl1: {
    			type: "string"
    		},
    		frompt3: {
    			type: "string"
    		},
    		frompr3: {
    			type: "string"
    		},
    		frompr0: {
    			type: "string"
    		},
    		topt2: {
    			type: "string"
    		},
    		frompr2: {
    			type: "string"
    		},
    		ptdel: {
    			type: "string"
    		},
    		frompt0: {
    			type: "string"
    		},
    		frompr1: {
    			type: "string"
    		},
    		topt1: {
    			type: "string"
    		},
    		fromdtl3: {
    			type: "string"
    		},
    		topt0: {
    			type: "string"
    		},
    		frompt4: {
    			type: "string"
    		},
    		fromvtx3: {
    			type: "string"
    		},
    		dtldel: {
    			type: "string"
    		},
    		topr2: {
    			type: "string"
    		},
    		topr1: {
    			type: "string"
    		},
    		fromvtx1: {
    			type: "string"
    		},
    		tovtx1: {
    			type: "string"
    		},
    		todtl4: {
    			type: "string"
    		},
    		tovtx3: {
    			type: "string"
    		},
    		frompt1: {
    			type: "string"
    		},
    		tovtx0: {
    			type: "string"
    		},
    		fromdtl1: {
    			type: "string"
    		},
    		tovtx4: {
    			type: "string"
    		},
    		frompr4: {
    			type: "string"
    		},
    		tovtx2: {
    			type: "string"
    		},
    		fromdtl2: {
    			type: "string"
    		},
    		topr4: {
    			type: "string"
    		},
    		primdel: {
    			type: "string"
    		},
    		todtl3: {
    			type: "string"
    		},
    		frompt2: {
    			type: "string"
    		},
    		vtxdel: {
    			type: "string"
    		},
    		fromdtl0: {
    			type: "string"
    		},
    		todtl0: {
    			type: "string"
    		},
    		topt3: {
    			type: "string"
    		},
    		fromvtx2: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var particleSOP = {
    	maxInputs: 4,
    	pars: {
    		ptreuse: {
    			type: "menu",
    			menuitems: [
    				"loop",
    				"unused",
    				"none"
    			]
    		},
    		jitter: {
    			type: "toggle"
    		},
    		splitmin: {
    			type: "number"
    		},
    		splitvel: {
    			type: "xyz"
    		},
    		life: {
    			type: "float"
    		},
    		limitneg: {
    			type: "xyz"
    		},
    		turb: {
    			type: "xyz"
    		},
    		normals: {
    			type: "toggle"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		attractmode: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"single"
    			]
    		},
    		drag: {
    			type: "float"
    		},
    		timeinc: {
    			type: "float"
    		},
    		sourcegrp: {
    			type: "string"
    		},
    		maxsteps: {
    			type: "number"
    		},
    		period: {
    			type: "float"
    		},
    		wind: {
    			type: "xyz"
    		},
    		domass: {
    			type: "toggle"
    		},
    		lifevar: {
    			type: "float"
    		},
    		doid: {
    			type: "toggle"
    		},
    		hit: {
    			type: "menu",
    			menuitems: [
    				"die",
    				"bounce",
    				"stick"
    			]
    		},
    		prtype: {
    			type: "menu",
    			menuitems: [
    				"lines",
    				"pointsprites"
    			]
    		},
    		limitpos: {
    			type: "xyz"
    		},
    		gaintan: {
    			type: "float"
    		},
    		mass: {
    			type: "float"
    		},
    		rmunused: {
    			type: "toggle"
    		},
    		splittype: {
    			type: "menu",
    			menuitems: [
    				"no",
    				"bounce",
    				"die"
    			]
    		},
    		birth: {
    			type: "float"
    		},
    		alpha: {
    			type: "float"
    		},
    		accurate: {
    			type: "toggle"
    		},
    		splitvar: {
    			type: "xyz"
    		},
    		seed: {
    			type: "number"
    		},
    		dodrag: {
    			type: "toggle"
    		},
    		splitmax: {
    			type: "number"
    		},
    		behave: {
    			type: "menu",
    			menuitems: [
    				"psystem",
    				"modify"
    			]
    		},
    		timepreroll: {
    			type: "float"
    		},
    		reset: {
    			type: "toggle"
    		},
    		gainnorm: {
    			type: "float"
    		},
    		external: {
    			type: "xyz"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var noiseSOP = {
    	maxInputs: 1,
    	pars: {
    		numint: {
    			type: "number"
    		},
    		seed: {
    			type: "float"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		spread: {
    			type: "float"
    		},
    		attribute: {
    			type: "menu",
    			menuitems: [
    				"pos",
    				"n",
    				"cd",
    				"alpha",
    				"uv",
    				"w"
    			]
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		r: {
    			type: "xyz"
    		},
    		p: {
    			type: "xyz"
    		},
    		t: {
    			type: "xyz"
    		},
    		s: {
    			type: "xyz"
    		},
    		group: {
    			type: "string"
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"sparse",
    				"hermite",
    				"harmonic",
    				"brownian",
    				"random",
    				"alligator"
    			]
    		},
    		rough: {
    			type: "float"
    		},
    		exp: {
    			type: "float"
    		},
    		harmon: {
    			type: "number"
    		},
    		period: {
    			type: "float"
    		},
    		amp: {
    			type: "float"
    		},
    		keepnormals: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var polyloftSOP = {
    	maxInputs: 2,
    	pars: {
    		closev: {
    			type: "menu",
    			menuitems: [
    				"nonewv",
    				"wv",
    				"ifprimwv"
    			]
    		},
    		pointgroup4: {
    			type: "string"
    		},
    		consolidate: {
    			type: "toggle"
    		},
    		dist: {
    			type: "float"
    		},
    		pointgroup2: {
    			type: "string"
    		},
    		group: {
    			type: "string"
    		},
    		creategroup: {
    			type: "toggle"
    		},
    		prim: {
    			type: "toggle"
    		},
    		pointgroup0: {
    			type: "string"
    		},
    		polygroup: {
    			type: "string"
    		},
    		pointgroup3: {
    			type: "string"
    		},
    		closeu: {
    			type: "menu",
    			menuitems: [
    				"nonewu",
    				"wu",
    				"ifprimwu"
    			]
    		},
    		minimize: {
    			type: "menu",
    			menuitems: [
    				"point2",
    				"point3"
    			]
    		},
    		pointgroup5: {
    			type: "string"
    		},
    		pointgroup1: {
    			type: "string"
    		},
    		proximity: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var nullSOP = {
    	maxInputs: 1,
    	pars: {
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var cacheSOP = {
    	maxInputs: 1,
    	pars: {
    		reset: {
    			type: "toggle"
    		},
    		active: {
    			type: "toggle"
    		},
    		prefill: {
    			type: "toggle"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		cachepoints: {
    			type: "toggle"
    		},
    		outputindex: {
    			type: "float"
    		},
    		cachesize: {
    			type: "number"
    		},
    		step: {
    			type: "number"
    		},
    		blendpos: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var blendSOP = {
    	maxInputs: 16,
    	pars: {
    		blend3v3: {
    			type: "float"
    		},
    		blend3v4: {
    			type: "float"
    		},
    		blend4v2: {
    			type: "float"
    		},
    		diff: {
    			type: "toggle"
    		},
    		group: {
    			type: "string"
    		},
    		blend2v1: {
    			type: "float"
    		},
    		doclr: {
    			type: "toggle"
    		},
    		douvw: {
    			type: "toggle"
    		},
    		blend2v4: {
    			type: "float"
    		},
    		blend1v4: {
    			type: "float"
    		},
    		blend1v1: {
    			type: "float"
    		},
    		dopos: {
    			type: "toggle"
    		},
    		doup: {
    			type: "toggle"
    		},
    		blend3v1: {
    			type: "float"
    		},
    		blend3v2: {
    			type: "float"
    		},
    		blend4v3: {
    			type: "float"
    		},
    		blend2v3: {
    			type: "float"
    		},
    		blend4v1: {
    			type: "float"
    		},
    		blend1v3: {
    			type: "float"
    		},
    		blend4v4: {
    			type: "float"
    		},
    		donml: {
    			type: "toggle"
    		},
    		blend1v2: {
    			type: "float"
    		},
    		blend2v2: {
    			type: "float"
    		}
    	},
    	minInputs: 2,
    	type: "SOP"
    };
    var groupSOP = {
    	maxInputs: 2,
    	pars: {
    		select1: {
    			type: "number"
    		},
    		rangestart: {
    			type: "number"
    		},
    		useedges: {
    			type: "toggle"
    		},
    		grp4: {
    			type: "string"
    		},
    		size: {
    			type: "xyz"
    		},
    		dodepth: {
    			type: "toggle"
    		},
    		not1: {
    			type: "toggle"
    		},
    		op2: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"or",
    				"and",
    				"xor",
    				"sub"
    			]
    		},
    		edgeangle: {
    			type: "float"
    		},
    		convertg: {
    			type: "string"
    		},
    		filter: {
    			type: "number"
    		},
    		not2: {
    			type: "toggle"
    		},
    		edgestep: {
    			type: "number"
    		},
    		not3: {
    			type: "toggle"
    		},
    		op3: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"or",
    				"and",
    				"xor",
    				"sub"
    			]
    		},
    		select2: {
    			type: "number"
    		},
    		unshared: {
    			type: "toggle"
    		},
    		doangle: {
    			type: "toggle"
    		},
    		usebounds: {
    			type: "toggle"
    		},
    		cnvtname: {
    			type: "string"
    		},
    		angle: {
    			type: "float"
    		},
    		ordered: {
    			type: "toggle"
    		},
    		crname: {
    			type: "string"
    		},
    		boundtype: {
    			type: "menu",
    			menuitems: [
    				"usebbox",
    				"usebsphere",
    				"usebobject"
    			]
    		},
    		oldname: {
    			type: "string"
    		},
    		preserve: {
    			type: "toggle"
    		},
    		t: {
    			type: "xyz"
    		},
    		point: {
    			type: "number"
    		},
    		transfer: {
    			type: "pulse"
    		},
    		destroyname: {
    			type: "string"
    		},
    		pattern: {
    			type: "string"
    		},
    		camera: {
    			type: "COMP"
    		},
    		geotype: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"bezierc",
    				"bezier",
    				"circle",
    				"mesh",
    				"meta",
    				"nurbc",
    				"nurb",
    				"part",
    				"poly",
    				"sphere",
    				"tube",
    				"tristrip",
    				"trifan"
    			]
    		},
    		newname: {
    			type: "string"
    		},
    		grp2: {
    			type: "string"
    		},
    		usenormal: {
    			type: "toggle"
    		},
    		grpequal: {
    			type: "string"
    		},
    		boundarygroups: {
    			type: "toggle"
    		},
    		usenumber: {
    			type: "toggle"
    		},
    		entity: {
    			type: "menu",
    			menuitems: [
    				"primitive",
    				"point"
    			]
    		},
    		grp1: {
    			type: "string"
    		},
    		grp3: {
    			type: "string"
    		},
    		groupop: {
    			type: "menu",
    			menuitems: [
    				"grppattern",
    				"grprange",
    				"grpexpression"
    			]
    		},
    		cnvtype: {
    			type: "menu",
    			menuitems: [
    				"toprim",
    				"topoint"
    			]
    		},
    		rangeend: {
    			type: "number"
    		},
    		op1: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"or",
    				"and",
    				"xor",
    				"sub"
    			]
    		},
    		dir: {
    			type: "xyz"
    		},
    		not4: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var kinectSOP = {
    	maxInputs: 0,
    	pars: {
    		normals: {
    			type: "toggle"
    		},
    		neardepthmode: {
    			type: "toggle"
    		},
    		sensor: {
    			type: "string"
    		},
    		hwversion: {
    			type: "menu",
    			menuitems: [
    				"version1"
    			]
    		},
    		skeleton: {
    			type: "menu",
    			menuitems: [
    				"full",
    				"seated"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var refineSOP = {
    	maxInputs: 1,
    	pars: {
    		domainu2: {
    			type: "float"
    		},
    		refinev: {
    			type: "number"
    		},
    		divsu: {
    			type: "number"
    		},
    		refinespace: {
    			type: "menu",
    			menuitems: [
    				"domain",
    				"arc"
    			]
    		},
    		domainv1: {
    			type: "float"
    		},
    		group: {
    			type: "string"
    		},
    		secondv: {
    			type: "toggle"
    		},
    		domainu1: {
    			type: "float"
    		},
    		tolv: {
    			type: "float"
    		},
    		firstv: {
    			type: "toggle"
    		},
    		domainv2: {
    			type: "float"
    		},
    		divsv: {
    			type: "number"
    		},
    		subdivspace: {
    			type: "menu",
    			menuitems: [
    				"domain",
    				"arc"
    			]
    		},
    		tolu: {
    			type: "float"
    		},
    		refineu: {
    			type: "number"
    		},
    		secondu: {
    			type: "toggle"
    		},
    		firstu: {
    			type: "toggle"
    		},
    		unrefineu: {
    			type: "number"
    		},
    		unrefinev: {
    			type: "number"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var metaballSOP = {
    	maxInputs: 1,
    	pars: {
    		rad: {
    			type: "xyz"
    		},
    		kernel: {
    			type: "string"
    		},
    		expz: {
    			type: "float"
    		},
    		metaweight: {
    			type: "float"
    		},
    		expxy: {
    			type: "float"
    		},
    		modifybounds: {
    			type: "toggle"
    		},
    		t: {
    			type: "xyz"
    		},
    		normals: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var capSOP = {
    	maxInputs: 1,
    	pars: {
    		firstv: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"facet",
    				"share",
    				"round",
    				"tangent"
    			]
    		},
    		divsv2: {
    			type: "number"
    		},
    		scalev1: {
    			type: "float"
    		},
    		divsu1: {
    			type: "number"
    		},
    		lastv: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"facet",
    				"share",
    				"round",
    				"tangent"
    			]
    		},
    		firstu: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"facet",
    				"share",
    				"round",
    				"tangent"
    			]
    		},
    		group: {
    			type: "string"
    		},
    		pshapeu: {
    			type: "toggle"
    		},
    		scaleu2: {
    			type: "float"
    		},
    		divsv1: {
    			type: "number"
    		},
    		lastu: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"facet",
    				"share",
    				"round",
    				"tangent"
    			]
    		},
    		scaleu1: {
    			type: "float"
    		},
    		scalev2: {
    			type: "float"
    		},
    		divsu2: {
    			type: "number"
    		},
    		pshapev: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var joinSOP = {
    	maxInputs: 1,
    	pars: {
    		prim: {
    			type: "toggle"
    		},
    		loop: {
    			type: "toggle"
    		},
    		tolerance: {
    			type: "float"
    		},
    		blend: {
    			type: "toggle"
    		},
    		bias: {
    			type: "float"
    		},
    		joinop: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"group",
    				"skip"
    			]
    		},
    		dir: {
    			type: "menu",
    			menuitems: [
    				"ujoin",
    				"vjoin"
    			]
    		},
    		group: {
    			type: "string"
    		},
    		inc: {
    			type: "number"
    		},
    		knotmult: {
    			type: "toggle"
    		},
    		proximity: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var traceSOP = {
    	maxInputs: 0,
    	pars: {
    		delborder: {
    			type: "toggle"
    		},
    		fitcurve: {
    			type: "toggle"
    		},
    		top: {
    			type: "TOP"
    		},
    		hole: {
    			type: "toggle"
    		},
    		normals: {
    			type: "toggle"
    		},
    		bordwidth: {
    			type: "number"
    		},
    		step: {
    			type: "float"
    		},
    		corner: {
    			type: "float"
    		},
    		dosmooth: {
    			type: "toggle"
    		},
    		thresh: {
    			type: "float"
    		},
    		convpoly: {
    			type: "toggle"
    		},
    		doresample: {
    			type: "toggle"
    		},
    		lod: {
    			type: "float"
    		},
    		addtexture: {
    			type: "toggle"
    		},
    		error: {
    			type: "float"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var sortSOP = {
    	maxInputs: 1,
    	pars: {
    		partsort: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"byx",
    				"byy",
    				"byz",
    				"rev",
    				"shift",
    				"prox",
    				"vector",
    				"object"
    			]
    		},
    		pointobj: {
    			type: "COMP"
    		},
    		partdir: {
    			type: "xyz"
    		},
    		primseed: {
    			type: "number"
    		},
    		primprox: {
    			type: "xyz"
    		},
    		ptsort: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"vtxord",
    				"byx",
    				"byy",
    				"byz",
    				"rev",
    				"seed",
    				"shift",
    				"prox",
    				"vector",
    				"object",
    				"neighbour"
    			]
    		},
    		partprox: {
    			type: "xyz"
    		},
    		pointoffset: {
    			type: "number"
    		},
    		primsort: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"byx",
    				"byy",
    				"byz",
    				"bytype",
    				"rev",
    				"seed",
    				"shift",
    				"prox",
    				"vector",
    				"object"
    			]
    		},
    		pointprox: {
    			type: "xyz"
    		},
    		pointseed: {
    			type: "number"
    		},
    		primdir: {
    			type: "xyz"
    		},
    		partobj: {
    			type: "COMP"
    		},
    		primobj: {
    			type: "COMP"
    		},
    		primoffset: {
    			type: "number"
    		},
    		partoffset: {
    			type: "number"
    		},
    		partreverse: {
    			type: "toggle"
    		},
    		pointdir: {
    			type: "xyz"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var sequenceblendSOP = {
    	maxInputs: 9999,
    	pars: {
    		dopos: {
    			type: "toggle"
    		},
    		doup: {
    			type: "toggle"
    		},
    		blend: {
    			type: "float"
    		},
    		douvw: {
    			type: "toggle"
    		},
    		donml: {
    			type: "toggle"
    		},
    		doclr: {
    			type: "toggle"
    		}
    	},
    	minInputs: 2,
    	type: "SOP"
    };
    var convertSOP = {
    	maxInputs: 1,
    	pars: {
    		lodu: {
    			type: "float"
    		},
    		divv: {
    			type: "number"
    		},
    		divtrim: {
    			type: "number"
    		},
    		group: {
    			type: "string"
    		},
    		"new": {
    			type: "toggle"
    		},
    		orderv: {
    			type: "number"
    		},
    		orderu: {
    			type: "number"
    		},
    		prtype: {
    			type: "menu",
    			menuitems: [
    				"lines",
    				"pointsprites"
    			]
    		},
    		divu: {
    			type: "number"
    		},
    		fromtype: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"sphere",
    				"tube",
    				"part",
    				"metaball",
    				"poly",
    				"mesh",
    				"bezcurve",
    				"bezsurf",
    				"nurbcurve",
    				"nurbsurf",
    				"circle",
    				"tristrip",
    				"trifan"
    			]
    		},
    		lodtrim: {
    			type: "float"
    		},
    		surftype: {
    			type: "menu",
    			menuitems: [
    				"rows",
    				"cols",
    				"rowcol",
    				"triangles",
    				"quads",
    				"alttriangles"
    			]
    		},
    		totype: {
    			type: "menu",
    			menuitems: [
    				"poly",
    				"mesh",
    				"bezcurve",
    				"bezsurf",
    				"nurbcurve",
    				"nurbsurf",
    				"circle",
    				"trimbezsurf",
    				"trimnurbsurf",
    				"part"
    			]
    		},
    		interphull: {
    			type: "toggle"
    		},
    		lodv: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var sphereSOP = {
    	maxInputs: 1,
    	pars: {
    		rad: {
    			type: "xyz"
    		},
    		normals: {
    			type: "toggle"
    		},
    		upole: {
    			type: "toggle"
    		},
    		imperfect: {
    			type: "toggle"
    		},
    		cols: {
    			type: "number"
    		},
    		modifybounds: {
    			type: "toggle"
    		},
    		t: {
    			type: "xyz"
    		},
    		orderv: {
    			type: "number"
    		},
    		orderu: {
    			type: "number"
    		},
    		freq: {
    			type: "number"
    		},
    		accurate: {
    			type: "toggle"
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"prim",
    				"poly",
    				"mesh",
    				"nurbs",
    				"bezier"
    			]
    		},
    		surftype: {
    			type: "menu",
    			menuitems: [
    				"rows",
    				"cols",
    				"rowcol",
    				"triangles",
    				"quads",
    				"alttriangles"
    			]
    		},
    		rows: {
    			type: "number"
    		},
    		orient: {
    			type: "menu",
    			menuitems: [
    				"x",
    				"y",
    				"z"
    			]
    		},
    		texture: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"byprimtype",
    				"equirectangularin",
    				"equirectangularout",
    				"equiazimuth",
    				"equiazimuth360"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var boxSOP = {
    	maxInputs: 1,
    	pars: {
    		s: {
    			type: "float"
    		},
    		modifybounds: {
    			type: "toggle"
    		},
    		texture: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"boxinside",
    				"faceinside",
    				"cubemapinside",
    				"boxoutside",
    				"faceoutside",
    				"cubemapoutside"
    			]
    		},
    		normals: {
    			type: "toggle"
    		},
    		size: {
    			type: "xyz"
    		},
    		consolidatepts: {
    			type: "toggle"
    		},
    		divsy: {
    			type: "number"
    		},
    		divsx: {
    			type: "number"
    		},
    		dodivs: {
    			type: "toggle"
    		},
    		divsz: {
    			type: "number"
    		},
    		t: {
    			type: "xyz"
    		},
    		rebar: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var skinSOP = {
    	maxInputs: 2,
    	pars: {
    		closev: {
    			type: "menu",
    			menuitems: [
    				"nonewv",
    				"wv",
    				"ifprimwv"
    			]
    		},
    		surftype: {
    			type: "menu",
    			menuitems: [
    				"rows",
    				"cols",
    				"rowcol",
    				"triangles",
    				"quads",
    				"alttriangles"
    			]
    		},
    		uprims: {
    			type: "string"
    		},
    		polys: {
    			type: "toggle"
    		},
    		skinops: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"group",
    				"skip"
    			]
    		},
    		orderv: {
    			type: "number"
    		},
    		keepshape: {
    			type: "toggle"
    		},
    		inc: {
    			type: "number"
    		},
    		vprims: {
    			type: "string"
    		},
    		force: {
    			type: "toggle"
    		},
    		prim: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var lineSOP = {
    	maxInputs: 0,
    	pars: {
    		pb: {
    			type: "xyz"
    		},
    		texture: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"unit"
    			]
    		},
    		points: {
    			type: "number"
    		},
    		pa: {
    			type: "xyz"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var surfsectSOP = {
    	maxInputs: 2,
    	pars: {
    		join: {
    			type: "toggle"
    		},
    		profilesb: {
    			type: "string"
    		},
    		tol2d: {
    			type: "float"
    		},
    		step: {
    			type: "number"
    		},
    		insidea: {
    			type: "toggle"
    		},
    		tol3d: {
    			type: "float"
    		},
    		insideb: {
    			type: "toggle"
    		},
    		creategroupb: {
    			type: "toggle"
    		},
    		outsidea: {
    			type: "toggle"
    		},
    		boolop: {
    			type: "menu",
    			menuitems: [
    				"union",
    				"intersect",
    				"aminusb",
    				"bminusa",
    				"other"
    			]
    		},
    		target: {
    			type: "menu",
    			menuitems: [
    				"a",
    				"b",
    				"both"
    			]
    		},
    		profilesa: {
    			type: "string"
    		},
    		mindholes: {
    			type: "toggle"
    		},
    		creategroupa: {
    			type: "toggle"
    		},
    		outsideb: {
    			type: "toggle"
    		},
    		groupb: {
    			type: "string"
    		},
    		groupa: {
    			type: "string"
    		}
    	},
    	minInputs: 2,
    	type: "SOP"
    };
    var primitiveSOP = {
    	maxInputs: 2,
    	pars: {
    		crease: {
    			type: "float"
    		},
    		closev: {
    			type: "menu",
    			menuitems: [
    				"sameclosure",
    				"open",
    				"closesharp",
    				"closeround",
    				"unroll"
    			]
    		},
    		templategrp: {
    			type: "string"
    		},
    		r: {
    			type: "xyz"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		t: {
    			type: "xyz"
    		},
    		custom2: {
    			type: "string"
    		},
    		pshapeu: {
    			type: "toggle"
    		},
    		doclr: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		alpha: {
    			type: "float"
    		},
    		vtxvoff: {
    			type: "number"
    		},
    		docrease: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"remove"
    			]
    		},
    		doprender: {
    			type: "toggle"
    		},
    		custom1val2: {
    			type: "float"
    		},
    		custom1val1: {
    			type: "float"
    		},
    		custom1val4: {
    			type: "float"
    		},
    		clampu: {
    			type: "menu",
    			menuitems: [
    				"sameclamp",
    				"clamp",
    				"unclamp"
    			]
    		},
    		custom1val3: {
    			type: "float"
    		},
    		vtxsort: {
    			type: "menu",
    			menuitems: [
    				"samevertex",
    				"reverse",
    				"reverseu",
    				"reversev",
    				"swapuv",
    				"shift",
    				"flipfacing"
    			]
    		},
    		diff: {
    			type: "rgb"
    		},
    		custom2val4: {
    			type: "float"
    		},
    		doweight: {
    			type: "float"
    		},
    		prtype: {
    			type: "menu",
    			menuitems: [
    				"lines",
    				"pointsprites"
    			]
    		},
    		custom1size: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		s: {
    			type: "xyz"
    		},
    		clampv: {
    			type: "menu",
    			menuitems: [
    				"sameclamp",
    				"clamp",
    				"unclamp"
    			]
    		},
    		group: {
    			type: "string"
    		},
    		custom2val2: {
    			type: "float"
    		},
    		custom2val3: {
    			type: "float"
    		},
    		dorot: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"match"
    			]
    		},
    		p: {
    			type: "xyz"
    		},
    		custom2val1: {
    			type: "float"
    		},
    		custom1: {
    			type: "string"
    		},
    		metaweight: {
    			type: "toggle"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		doxform: {
    			type: "toggle"
    		},
    		vtxuoff: {
    			type: "number"
    		},
    		closeu: {
    			type: "menu",
    			menuitems: [
    				"sameclosure",
    				"open",
    				"closesharp",
    				"closeround",
    				"unroll"
    			]
    		},
    		custom2size: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		upvector: {
    			type: "xyz"
    		},
    		lookat: {
    			type: "COMP"
    		},
    		pshapev: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var springSOP = {
    	maxInputs: 3,
    	pars: {
    		attractmode: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"single"
    			]
    		},
    		revertfixed: {
    			type: "toggle"
    		},
    		limitneg: {
    			type: "xyz"
    		},
    		turb: {
    			type: "xyz"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		fixed: {
    			type: "string"
    		},
    		timepreroll: {
    			type: "float"
    		},
    		drag: {
    			type: "float"
    		},
    		copygroups: {
    			type: "toggle"
    		},
    		period: {
    			type: "float"
    		},
    		wind: {
    			type: "xyz"
    		},
    		domass: {
    			type: "toggle"
    		},
    		gainnorm: {
    			type: "float"
    		},
    		hit: {
    			type: "menu",
    			menuitems: [
    				"bounce",
    				"stick"
    			]
    		},
    		limitpos: {
    			type: "xyz"
    		},
    		gaintan: {
    			type: "float"
    		},
    		mass: {
    			type: "float"
    		},
    		tension: {
    			type: "float"
    		},
    		springbehavior: {
    			type: "menu",
    			menuitems: [
    				"hooke",
    				"normalize"
    			]
    		},
    		accurate: {
    			type: "toggle"
    		},
    		seed: {
    			type: "number"
    		},
    		dodrag: {
    			type: "toggle"
    		},
    		timeinc: {
    			type: "float"
    		},
    		external: {
    			type: "xyz"
    		},
    		reset: {
    			type: "toggle"
    		},
    		springk: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var twistSOP = {
    	maxInputs: 1,
    	pars: {
    		paxis: {
    			type: "menu",
    			menuitems: [
    				"x",
    				"y",
    				"z"
    			]
    		},
    		p: {
    			type: "xyz"
    		},
    		strength: {
    			type: "float"
    		},
    		op: {
    			type: "menu",
    			menuitems: [
    				"twist",
    				"bend",
    				"shear",
    				"taper",
    				"ltaper",
    				"squash"
    			]
    		},
    		saxis: {
    			type: "menu",
    			menuitems: [
    				"x",
    				"y",
    				"z"
    			]
    		},
    		roll: {
    			type: "float"
    		},
    		group: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var attributecreateSOP = {
    	maxInputs: 1,
    	pars: {
    		comptang: {
    			type: "toggle"
    		},
    		compnml: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var lodSOP = {
    	maxInputs: 2,
    	pars: {
    		polysonly: {
    			type: "toggle"
    		},
    		steppercent: {
    			type: "float"
    		},
    		triangulate: {
    			type: "toggle"
    		},
    		lengthweight: {
    			type: "float"
    		},
    		tstrips: {
    			type: "toggle"
    		},
    		minpercent: {
    			type: "float"
    		},
    		distance: {
    			type: "float"
    		},
    		borderweight: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var bonegroupSOP = {
    	maxInputs: 1,
    	pars: {
    		bonespergroup: {
    			type: "number"
    		},
    		bonesperpoint: {
    			type: "number"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var polysplineSOP = {
    	maxInputs: 1,
    	pars: {
    		first: {
    			type: "number"
    		},
    		basis: {
    			type: "menu",
    			menuitems: [
    				"bezier",
    				"sbezier",
    				"c1bezier",
    				"degree2",
    				"bspline",
    				"cardinal",
    				"linear"
    			]
    		},
    		closure: {
    			type: "menu",
    			menuitems: [
    				"cnone",
    				"calways",
    				"cifpoly"
    			]
    		},
    		last: {
    			type: "number"
    		},
    		segsize: {
    			type: "float"
    		},
    		polydivs: {
    			type: "number"
    		},
    		edgedivs: {
    			type: "number"
    		},
    		group: {
    			type: "string"
    		},
    		divide: {
    			type: "menu",
    			menuitems: [
    				"standard",
    				"evenlen",
    				"evenx",
    				"eveny",
    				"evenz"
    			]
    		},
    		tension: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "SOP"
    };
    var torusSOP = {
    	maxInputs: 1,
    	pars: {
    		angleoffset: {
    			type: "float"
    		},
    		normals: {
    			type: "toggle"
    		},
    		imperfect: {
    			type: "toggle"
    		},
    		endanglev: {
    			type: "float"
    		},
    		modifybounds: {
    			type: "toggle"
    		},
    		t: {
    			type: "xyz"
    		},
    		orient: {
    			type: "menu",
    			menuitems: [
    				"x",
    				"y",
    				"z"
    			]
    		},
    		beginangleu: {
    			type: "float"
    		},
    		rad: {
    			type: "xy"
    		},
    		surftype: {
    			type: "menu",
    			menuitems: [
    				"rows",
    				"cols",
    				"rowcol",
    				"triangles",
    				"quads",
    				"alttriangles"
    			]
    		},
    		endangleu: {
    			type: "float"
    		},
    		closev: {
    			type: "toggle"
    		},
    		capu: {
    			type: "toggle"
    		},
    		cols: {
    			type: "number"
    		},
    		orderu: {
    			type: "number"
    		},
    		rows: {
    			type: "number"
    		},
    		capv: {
    			type: "toggle"
    		},
    		orderv: {
    			type: "number"
    		},
    		closeu: {
    			type: "toggle"
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"poly",
    				"mesh",
    				"nurbs",
    				"bezier"
    			]
    		},
    		texture: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"rowcol"
    			]
    		},
    		beginanglev: {
    			type: "float"
    		}
    	},
    	minInputs: 0,
    	type: "SOP"
    };
    var buttonCOMP = {
    	maxInputs: 1,
    	pars: {
    		resizer: {
    			type: "toggle"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		top: {
    			type: "TOP"
    		},
    		offset: {
    			type: "xy"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		resizel: {
    			type: "toggle"
    		},
    		topoffset: {
    			type: "float"
    		},
    		helpdat: {
    			type: "DAT"
    		},
    		clone: {
    			type: "COMP"
    		},
    		mouserel: {
    			type: "toggle"
    		},
    		topanchor: {
    			type: "float"
    		},
    		align: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"horizlr",
    				"horizrl",
    				"verttb",
    				"vertbt",
    				"gridrows",
    				"gridcols",
    				"nodes"
    			]
    		},
    		bgcolor: {
    			type: "rgb"
    		},
    		repositionxmin: {
    			type: "float"
    		},
    		bottomanchor: {
    			type: "float"
    		},
    		paneldragop: {
    			type: "OP"
    		},
    		uvbuttonsmiddle: {
    			type: "toggle"
    		},
    		leftborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		opacity: {
    			type: "float"
    		},
    		w: {
    			type: "number"
    		},
    		chop: {
    			type: "CHOP"
    		},
    		rightoffset: {
    			type: "float"
    		},
    		buttontype: {
    			type: "menu",
    			menuitems: [
    				"momentary",
    				"momentaryup",
    				"toggledown",
    				"toggleup",
    				"toggleupany",
    				"radiodown",
    				"radioup",
    				"radionupany",
    				"exclusivedown",
    				"exclusiveup",
    				"exclusivenupany"
    			]
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		multitouch: {
    			type: "menu",
    			menuitems: [
    				"mtouchparent",
    				"mtouchyes",
    				"mtouchno"
    			]
    		},
    		hmode: {
    			type: "menu",
    			menuitems: [
    				"fixed",
    				"fill",
    				"anchors"
    			]
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		pvscrollbar: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		bgalpha: {
    			type: "float"
    		},
    		alignallow: {
    			type: "menu",
    			menuitems: [
    				"allow",
    				"ignore",
    				"ignoremargin"
    			]
    		},
    		buttongroup: {
    			type: "string"
    		},
    		bordera: {
    			type: "rgb"
    		},
    		clickthrough: {
    			type: "toggle"
    		},
    		dropdestscript: {
    			type: "DAT"
    		},
    		multrgb: {
    			type: "toggle"
    		},
    		disablecolor: {
    			type: "rgb"
    		},
    		leftborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		crop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"never"
    			]
    		},
    		spacing: {
    			type: "float"
    		},
    		vfillweight: {
    			type: "float"
    		},
    		bottomborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		postoffset: {
    			type: "xy"
    		},
    		horigin: {
    			type: "float"
    		},
    		topborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		borderbalpha: {
    			type: "float"
    		},
    		bottomoffset: {
    			type: "float"
    		},
    		layer: {
    			type: "float"
    		},
    		extension4: {
    			type: "string"
    		},
    		extname1: {
    			type: "string"
    		},
    		dragdropcallbacks: {
    			type: "DAT"
    		},
    		drag: {
    			type: "menu",
    			menuitems: [
    				"dragparent",
    				"legacy",
    				"dragno",
    				"usecallbacks"
    			]
    		},
    		rightborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		scale: {
    			type: "xy"
    		},
    		fit: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"best"
    			]
    		},
    		keepmemory: {
    			type: "toggle"
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		dragscript: {
    			type: "DAT"
    		},
    		fixedaspect: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical"
    			]
    		},
    		resizewmin: {
    			type: "float"
    		},
    		borderover: {
    			type: "toggle"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		disablealpha: {
    			type: "float"
    		},
    		anchordrag: {
    			type: "menu",
    			menuitems: [
    				"anchors",
    				"offsets"
    			]
    		},
    		scrolloverlay: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"ignore",
    				"ignoreover"
    			]
    		},
    		vmode: {
    			type: "menu",
    			menuitems: [
    				"fixed",
    				"fill",
    				"anchors"
    			]
    		},
    		marginb: {
    			type: "float"
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		vorigin: {
    			type: "float"
    		},
    		enable: {
    			type: "toggle"
    		},
    		namedchop: {
    			type: "toggle"
    		},
    		subcompname: {
    			type: "string"
    		},
    		marginr: {
    			type: "float"
    		},
    		scrollbarthickness: {
    			type: "number"
    		},
    		reposition: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"window",
    				"component"
    			]
    		},
    		bottomborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		mousewheel: {
    			type: "toggle"
    		},
    		leftoffset: {
    			type: "float"
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"left",
    				"center",
    				"right"
    			]
    		},
    		resizehmax: {
    			type: "float"
    		},
    		aspect: {
    			type: "float"
    		},
    		cursor: {
    			type: "menu",
    			menuitems: [
    				"pointer",
    				"linkselect",
    				"ibeam",
    				"cross",
    				"busy",
    				"activate",
    				"invisible"
    			]
    		},
    		repocomp: {
    			type: "PanelCOMP"
    		},
    		overlay: {
    			type: "toggle"
    		},
    		droptypescript: {
    			type: "DAT"
    		},
    		topborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		composite: {
    			type: "menu",
    			menuitems: [
    				"over",
    				"under",
    				"inside",
    				"outside",
    				"add",
    				"subtract",
    				"multiply"
    			]
    		},
    		phscrollbar: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		externaltox: {
    			type: "string"
    		},
    		uvbuttonsright: {
    			type: "toggle"
    		},
    		extension1: {
    			type: "string"
    		},
    		y: {
    			type: "number"
    		},
    		resizeb: {
    			type: "toggle"
    		},
    		resizehmin: {
    			type: "float"
    		},
    		topfill: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"best",
    				"native"
    			]
    		},
    		drop: {
    			type: "menu",
    			menuitems: [
    				"dropparent",
    				"legacy",
    				"dropno",
    				"usecallbacks"
    			]
    		},
    		extension2: {
    			type: "string"
    		},
    		rightborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		repositionymin: {
    			type: "float"
    		},
    		borderaalpha: {
    			type: "float"
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"top",
    				"center",
    				"bottom"
    			]
    		},
    		leftanchor: {
    			type: "float"
    		},
    		repositionymax: {
    			type: "float"
    		},
    		dodisablecolor: {
    			type: "toggle"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		},
    		alignmax: {
    			type: "number"
    		},
    		alignorder: {
    			type: "float"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		extname2: {
    			type: "string"
    		},
    		buttongroupdat: {
    			type: "DAT"
    		},
    		x: {
    			type: "number"
    		},
    		extname3: {
    			type: "string"
    		},
    		overridemethod: {
    			type: "menu",
    			menuitems: [
    				"trigger",
    				"always"
    			]
    		},
    		uvbuttonsleft: {
    			type: "toggle"
    		},
    		borderb: {
    			type: "rgb"
    		},
    		vieweraspect: {
    			type: "menu",
    			menuitems: [
    				"proportional",
    				"unconstrained"
    			]
    		},
    		sizefromwindow: {
    			type: "toggle"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		resizewmax: {
    			type: "float"
    		},
    		margint: {
    			type: "float"
    		},
    		extension3: {
    			type: "string"
    		},
    		repositionxmax: {
    			type: "float"
    		},
    		marginl: {
    			type: "float"
    		},
    		hfillweight: {
    			type: "float"
    		},
    		extname4: {
    			type: "string"
    		},
    		resizet: {
    			type: "toggle"
    		},
    		rightanchor: {
    			type: "float"
    		},
    		dropscript: {
    			type: "DAT"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		h: {
    			type: "number"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		display: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var geometryCOMP = {
    	maxInputs: 1,
    	pars: {
    		instancety: {
    			type: "string"
    		},
    		instancesz: {
    			type: "string"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		pxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		instancerottoz: {
    			type: "string"
    		},
    		instancemode: {
    			type: "menu",
    			menuitems: [
    				"manual",
    				"oplength"
    			]
    		},
    		instancetz: {
    			type: "string"
    		},
    		material: {
    			type: "MAT"
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		instancetx: {
    			type: "string"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		instxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		extension4: {
    			type: "string"
    		},
    		pr: {
    			type: "xyz"
    		},
    		numinstances: {
    			type: "number"
    		},
    		pathorient: {
    			type: "toggle"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		pathsop: {
    			type: "SOP"
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		pt: {
    			type: "xyz"
    		},
    		bank: {
    			type: "float"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		instancerz: {
    			type: "string"
    		},
    		instanceop: {
    			type: "OP"
    		},
    		instancetexextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		instancea: {
    			type: "string"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		pos: {
    			type: "float"
    		},
    		prord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		instancerotupy: {
    			type: "string"
    		},
    		xformmatrixop: {
    			type: "OP"
    		},
    		wcolor: {
    			type: "rgb"
    		},
    		instancetexextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		instancev: {
    			type: "string"
    		},
    		extname1: {
    			type: "string"
    		},
    		instancetexs: {
    			type: "TOP"
    		},
    		lightmask: {
    			type: "COMP"
    		},
    		preset: {
    			type: "pulse"
    		},
    		instancerotupz: {
    			type: "string"
    		},
    		lookup: {
    			type: "string"
    		},
    		instancerottoorder: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"prerot",
    				"postrot"
    			]
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		instancer: {
    			type: "string"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		s: {
    			type: "xyz"
    		},
    		render: {
    			type: "toggle"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		prioritymethod: {
    			type: "menu",
    			menuitems: [
    				"custom",
    				"camdist"
    			]
    		},
    		instancetexindex: {
    			type: "string"
    		},
    		pcommit: {
    			type: "pulse"
    		},
    		instanceb: {
    			type: "string"
    		},
    		up: {
    			type: "xyz"
    		},
    		pscale: {
    		},
    		drawpriority: {
    			type: "float"
    		},
    		subcompname: {
    			type: "string"
    		},
    		instanceu: {
    			type: "string"
    		},
    		roll: {
    			type: "float"
    		},
    		instancetexfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		instrord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		instancerottoy: {
    			type: "string"
    		},
    		instancing: {
    			type: "toggle"
    		},
    		pickpriority: {
    			type: "float"
    		},
    		instancesy: {
    			type: "string"
    		},
    		instancepy: {
    			type: "string"
    		},
    		instancetexextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		extname4: {
    			type: "string"
    		},
    		instancery: {
    			type: "string"
    		},
    		externaltox: {
    			type: "string"
    		},
    		constrain: {
    			type: "COMP"
    		},
    		clone: {
    			type: "COMP"
    		},
    		pp: {
    			type: "xyz"
    		},
    		p: {
    			type: "xyz"
    		},
    		instancepz: {
    			type: "string"
    		},
    		instancecolormode: {
    			type: "menu",
    			menuitems: [
    				"replace",
    				"multiply",
    				"add",
    				"subtract"
    			]
    		},
    		instancerottox: {
    			type: "string"
    		},
    		scale: {
    			type: "float"
    		},
    		instancerotupx: {
    			type: "string"
    		},
    		t: {
    			type: "xyz"
    		},
    		pxform: {
    			type: "toggle"
    		},
    		extension1: {
    			type: "string"
    		},
    		instancew: {
    			type: "string"
    		},
    		extension2: {
    			type: "string"
    		},
    		instancetexmode: {
    			type: "menu",
    			menuitems: [
    				"replace",
    				"offset"
    			]
    		},
    		instanceg: {
    			type: "string"
    		},
    		instancerx: {
    			type: "string"
    		},
    		instancetexanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		instancesx: {
    			type: "string"
    		},
    		extname2: {
    			type: "string"
    		},
    		instanceorder: {
    			type: "menu",
    			menuitems: [
    				"instanceworld",
    				"worldinstance"
    			]
    		},
    		ps: {
    			type: "xyz"
    		},
    		extname3: {
    			type: "string"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		r: {
    			type: "xyz"
    		},
    		lookat: {
    			type: "COMP"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		instancepx: {
    			type: "string"
    		},
    		instancefirstrow: {
    			type: "menu",
    			menuitems: [
    				"ignored",
    				"names",
    				"values"
    			]
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		extension3: {
    			type: "string"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var handleCOMP = {
    	maxInputs: 1,
    	pars: {
    		instancety: {
    			type: "string"
    		},
    		instancesz: {
    			type: "string"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		pxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		instancerottoz: {
    			type: "string"
    		},
    		lrzmax: {
    			type: "float"
    		},
    		instancemode: {
    			type: "menu",
    			menuitems: [
    				"manual",
    				"oplength"
    			]
    		},
    		instancetz: {
    			type: "string"
    		},
    		material: {
    			type: "MAT"
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		instancetx: {
    			type: "string"
    		},
    		instancecolormode: {
    			type: "menu",
    			menuitems: [
    				"replace",
    				"multiply",
    				"add",
    				"subtract"
    			]
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		instxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		instancerotupz: {
    			type: "string"
    		},
    		extension4: {
    			type: "string"
    		},
    		pr: {
    			type: "xyz"
    		},
    		numinstances: {
    			type: "number"
    		},
    		pathorient: {
    			type: "toggle"
    		},
    		pathsop: {
    			type: "SOP"
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		pt: {
    			type: "xyz"
    		},
    		bank: {
    			type: "float"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		instancerz: {
    			type: "string"
    		},
    		instanceop: {
    			type: "OP"
    		},
    		instancetexextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		instancea: {
    			type: "string"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		pos: {
    			type: "float"
    		},
    		prord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		extension1: {
    			type: "string"
    		},
    		xformmatrixop: {
    			type: "OP"
    		},
    		wcolor: {
    			type: "rgb"
    		},
    		t: {
    			type: "xyz"
    		},
    		weight: {
    			type: "float"
    		},
    		instancev: {
    			type: "string"
    		},
    		lrxmin: {
    			type: "float"
    		},
    		extname1: {
    			type: "string"
    		},
    		lrymax: {
    			type: "float"
    		},
    		instancetexs: {
    			type: "TOP"
    		},
    		lightmask: {
    			type: "COMP"
    		},
    		preset: {
    			type: "pulse"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		instancetexextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		lookup: {
    			type: "string"
    		},
    		instancerottoorder: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"prerot",
    				"postrot"
    			]
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		instancer: {
    			type: "string"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		instancetexextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		render: {
    			type: "toggle"
    		},
    		instancery: {
    			type: "string"
    		},
    		prioritymethod: {
    			type: "menu",
    			menuitems: [
    				"custom",
    				"camdist"
    			]
    		},
    		instancetexindex: {
    			type: "string"
    		},
    		pcommit: {
    			type: "pulse"
    		},
    		instanceb: {
    			type: "string"
    		},
    		falloff: {
    			type: "float"
    		},
    		up: {
    			type: "xyz"
    		},
    		pscale: {
    		},
    		drawpriority: {
    			type: "float"
    		},
    		lrxmax: {
    			type: "float"
    		},
    		subcompname: {
    			type: "string"
    		},
    		instanceu: {
    			type: "string"
    		},
    		roll: {
    			type: "float"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		dorylimit: {
    			type: "toggle"
    		},
    		lrzmin: {
    			type: "float"
    		},
    		dorzlimit: {
    			type: "toggle"
    		},
    		instrord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		instancerottoy: {
    			type: "string"
    		},
    		instancing: {
    			type: "toggle"
    		},
    		pickpriority: {
    			type: "float"
    		},
    		instancesy: {
    			type: "string"
    		},
    		instancepy: {
    			type: "string"
    		},
    		instancerotupy: {
    			type: "string"
    		},
    		extname4: {
    			type: "string"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		externaltox: {
    			type: "string"
    		},
    		constrain: {
    			type: "COMP"
    		},
    		clone: {
    			type: "COMP"
    		},
    		ps: {
    			type: "xyz"
    		},
    		p: {
    			type: "xyz"
    		},
    		instancepz: {
    			type: "string"
    		},
    		r: {
    			type: "xyz"
    		},
    		instancetexfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		instancerottox: {
    			type: "string"
    		},
    		scale: {
    		},
    		instancerotupx: {
    			type: "string"
    		},
    		lrymin: {
    			type: "float"
    		},
    		pxform: {
    			type: "toggle"
    		},
    		instancew: {
    			type: "string"
    		},
    		extension2: {
    			type: "string"
    		},
    		instancetexmode: {
    			type: "menu",
    			menuitems: [
    				"replace",
    				"offset"
    			]
    		},
    		instanceg: {
    			type: "string"
    		},
    		instancerx: {
    			type: "string"
    		},
    		target: {
    			type: "COMP"
    		},
    		instancetexanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		extname2: {
    			type: "string"
    		},
    		instanceorder: {
    			type: "menu",
    			menuitems: [
    				"instanceworld",
    				"worldinstance"
    			]
    		},
    		dorxlimit: {
    			type: "toggle"
    		},
    		extname3: {
    			type: "string"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		s: {
    			type: "xyz"
    		},
    		lookat: {
    			type: "COMP"
    		},
    		instancesx: {
    			type: "string"
    		},
    		instancepx: {
    			type: "string"
    		},
    		twistonly: {
    			type: "toggle"
    		},
    		instancefirstrow: {
    			type: "menu",
    			menuitems: [
    				"ignored",
    				"names",
    				"values"
    			]
    		},
    		pp: {
    			type: "xyz"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		extension3: {
    			type: "string"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "COMP"
    };
    var tableCOMP = {
    	maxInputs: 1,
    	pars: {
    		resizer: {
    			type: "toggle"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		top: {
    			type: "TOP"
    		},
    		offset: {
    			type: "xy"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		resizel: {
    			type: "toggle"
    		},
    		topoffset: {
    			type: "float"
    		},
    		subcompname: {
    			type: "string"
    		},
    		mouserel: {
    			type: "toggle"
    		},
    		topanchor: {
    			type: "float"
    		},
    		align: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"horizlr",
    				"horizrl",
    				"verttb",
    				"vertbt",
    				"gridrows",
    				"gridcols",
    				"nodes"
    			]
    		},
    		bgcolor: {
    			type: "rgb"
    		},
    		repositionxmin: {
    			type: "float"
    		},
    		bottomanchor: {
    			type: "float"
    		},
    		paneldragop: {
    			type: "OP"
    		},
    		tablecols: {
    			type: "number"
    		},
    		leftborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		opacity: {
    			type: "float"
    		},
    		w: {
    			type: "number"
    		},
    		tableattributes: {
    			type: "DAT"
    		},
    		rightoffset: {
    			type: "float"
    		},
    		alignallow: {
    			type: "menu",
    			menuitems: [
    				"allow",
    				"ignore",
    				"ignoremargin"
    			]
    		},
    		tablereset: {
    			type: "pulse"
    		},
    		multitouch: {
    			type: "menu",
    			menuitems: [
    				"mtouchparent",
    				"mtouchyes",
    				"mtouchno"
    			]
    		},
    		hmode: {
    			type: "menu",
    			menuitems: [
    				"fixed",
    				"fill",
    				"anchors"
    			]
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		pvscrollbar: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		bgalpha: {
    			type: "float"
    		},
    		values: {
    			type: "DAT"
    		},
    		bordera: {
    			type: "rgb"
    		},
    		clickthrough: {
    			type: "toggle"
    		},
    		multrgb: {
    			type: "toggle"
    		},
    		dropdestscript: {
    			type: "DAT"
    		},
    		rightborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		disablecolor: {
    			type: "rgb"
    		},
    		leftborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		crop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"never"
    			]
    		},
    		helpdat: {
    			type: "DAT"
    		},
    		vfillweight: {
    			type: "float"
    		},
    		bottomborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		postoffset: {
    			type: "xy"
    		},
    		topborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		tableoffsety: {
    			type: "number"
    		},
    		borderbalpha: {
    			type: "float"
    		},
    		disablealpha: {
    			type: "float"
    		},
    		bottomoffset: {
    			type: "float"
    		},
    		layer: {
    			type: "float"
    		},
    		tableoffsetx: {
    			type: "number"
    		},
    		extname1: {
    			type: "string"
    		},
    		dragdropcallbacks: {
    			type: "DAT"
    		},
    		tablealign: {
    			type: "menu",
    			menuitems: [
    				"horizlr",
    				"horizrl",
    				"verttb",
    				"vertbt"
    			]
    		},
    		drag: {
    			type: "menu",
    			menuitems: [
    				"dragparent",
    				"legacy",
    				"dragno",
    				"usecallbacks"
    			]
    		},
    		rowattributes: {
    			type: "DAT"
    		},
    		chop: {
    			type: "CHOP"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		attributes: {
    			type: "DAT"
    		},
    		scale: {
    			type: "xy"
    		},
    		fit: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"best"
    			]
    		},
    		keepmemory: {
    			type: "toggle"
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		dragscript: {
    			type: "DAT"
    		},
    		fixedaspect: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical"
    			]
    		},
    		resizewmin: {
    			type: "float"
    		},
    		borderover: {
    			type: "toggle"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		infoformat: {
    			type: "menu",
    			menuitems: [
    				"statecol",
    				"stategrid"
    			]
    		},
    		alignmax: {
    			type: "number"
    		},
    		anchordrag: {
    			type: "menu",
    			menuitems: [
    				"anchors",
    				"offsets"
    			]
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		scrolloverlay: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"ignore",
    				"ignoreover"
    			]
    		},
    		vmode: {
    			type: "menu",
    			menuitems: [
    				"fixed",
    				"fill",
    				"anchors"
    			]
    		},
    		extension4: {
    			type: "string"
    		},
    		rightanchor: {
    			type: "float"
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		vorigin: {
    			type: "float"
    		},
    		colattributes: {
    			type: "DAT"
    		},
    		enable: {
    			type: "toggle"
    		},
    		namedchop: {
    			type: "toggle"
    		},
    		spacing: {
    			type: "float"
    		},
    		marginr: {
    			type: "float"
    		},
    		scrollbarthickness: {
    			type: "number"
    		},
    		reposition: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"window",
    				"component"
    			]
    		},
    		bottomborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		mousewheel: {
    			type: "toggle"
    		},
    		leftoffset: {
    			type: "float"
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"left",
    				"center",
    				"right"
    			]
    		},
    		resizehmax: {
    			type: "float"
    		},
    		aspect: {
    			type: "float"
    		},
    		cursor: {
    			type: "menu",
    			menuitems: [
    				"pointer",
    				"linkselect",
    				"ibeam",
    				"cross",
    				"busy",
    				"activate",
    				"invisible"
    			]
    		},
    		repocomp: {
    			type: "PanelCOMP"
    		},
    		uvbuttonsmiddle: {
    			type: "toggle"
    		},
    		droptypescript: {
    			type: "DAT"
    		},
    		topborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		composite: {
    			type: "menu",
    			menuitems: [
    				"over",
    				"under",
    				"inside",
    				"outside",
    				"add",
    				"subtract",
    				"multiply"
    			]
    		},
    		phscrollbar: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		externaltox: {
    			type: "string"
    		},
    		clone: {
    			type: "COMP"
    		},
    		tablerows: {
    			type: "number"
    		},
    		extension1: {
    			type: "string"
    		},
    		y: {
    			type: "number"
    		},
    		resizeb: {
    			type: "toggle"
    		},
    		resizehmin: {
    			type: "float"
    		},
    		topfill: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"best",
    				"native"
    			]
    		},
    		drop: {
    			type: "menu",
    			menuitems: [
    				"dropparent",
    				"legacy",
    				"dropno",
    				"usecallbacks"
    			]
    		},
    		extension2: {
    			type: "string"
    		},
    		rightborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		repositionymin: {
    			type: "float"
    		},
    		borderaalpha: {
    			type: "float"
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"top",
    				"center",
    				"bottom"
    			]
    		},
    		leftanchor: {
    			type: "float"
    		},
    		repositionymax: {
    			type: "float"
    		},
    		dodisablecolor: {
    			type: "toggle"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		},
    		fontsizeunit: {
    			type: "menu",
    			menuitems: [
    				"pixels",
    				"points"
    			]
    		},
    		alignorder: {
    			type: "float"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		extname2: {
    			type: "string"
    		},
    		uvbuttonsright: {
    			type: "toggle"
    		},
    		x: {
    			type: "number"
    		},
    		extname3: {
    			type: "string"
    		},
    		overridemethod: {
    			type: "menu",
    			menuitems: [
    				"trigger",
    				"always"
    			]
    		},
    		uvbuttonsleft: {
    			type: "toggle"
    		},
    		horigin: {
    			type: "float"
    		},
    		vieweraspect: {
    			type: "menu",
    			menuitems: [
    				"proportional",
    				"unconstrained"
    			]
    		},
    		sizefromwindow: {
    			type: "toggle"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		resizewmax: {
    			type: "float"
    		},
    		margint: {
    			type: "float"
    		},
    		extension3: {
    			type: "string"
    		},
    		overlay: {
    			type: "toggle"
    		},
    		repositionxmax: {
    			type: "float"
    		},
    		borderb: {
    			type: "rgb"
    		},
    		marginl: {
    			type: "float"
    		},
    		hfillweight: {
    			type: "float"
    		},
    		extname4: {
    			type: "string"
    		},
    		resizet: {
    			type: "toggle"
    		},
    		marginb: {
    			type: "float"
    		},
    		dropscript: {
    			type: "DAT"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		h: {
    			type: "number"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		display: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var camerablendCOMP = {
    	maxInputs: 9999,
    	pars: {
    		axesorient: {
    			type: "toggle"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		blendm2: {
    			type: "number"
    		},
    		parenttype: {
    			type: "menu",
    			menuitems: [
    				"blend",
    				"sequence",
    				"constrain"
    			]
    		},
    		preset: {
    			type: "pulse"
    		},
    		blendm3: {
    			type: "number"
    		},
    		material: {
    			type: "MAT"
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		bgcolor: {
    			type: "rgba"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		pp: {
    			type: "xyz"
    		},
    		blendw2: {
    			type: "float"
    		},
    		extension4: {
    			type: "string"
    		},
    		pr: {
    			type: "xyz"
    		},
    		pxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		pathorient: {
    			type: "toggle"
    		},
    		pathsop: {
    			type: "SOP"
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		orthowidth: {
    			type: "float"
    		},
    		pt: {
    			type: "xyz"
    		},
    		fognear: {
    			type: "float"
    		},
    		bank: {
    			type: "float"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		near: {
    			type: "float"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		pos: {
    			type: "float"
    		},
    		prord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		extension1: {
    			type: "string"
    		},
    		xformmatrixop: {
    			type: "OP"
    		},
    		wcolor: {
    			type: "rgb"
    		},
    		t: {
    			type: "xyz"
    		},
    		extname1: {
    			type: "string"
    		},
    		winroll: {
    		},
    		sequence: {
    			type: "float"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		projmatrixop: {
    			type: "OP"
    		},
    		lookup: {
    			type: "string"
    		},
    		aperture: {
    			type: "float"
    		},
    		blendm1: {
    			type: "number"
    		},
    		fog: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"linear",
    				"exp",
    				"exp2"
    			]
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		shortrot: {
    			type: "toggle"
    		},
    		fogcolor: {
    			type: "rgb"
    		},
    		render: {
    			type: "toggle"
    		},
    		fov: {
    			type: "float"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		prioritymethod: {
    			type: "menu",
    			menuitems: [
    				"custom",
    				"camdist"
    			]
    		},
    		blendw3: {
    			type: "float"
    		},
    		pcommit: {
    			type: "pulse"
    		},
    		fogfar: {
    			type: "float"
    		},
    		projection: {
    			type: "menu",
    			menuitems: [
    				"perspective",
    				"ortho",
    				"persporthoblend",
    				"custommatrix"
    			]
    		},
    		up: {
    			type: "xyz"
    		},
    		pscale: {
    		},
    		drawpriority: {
    			type: "float"
    		},
    		fogmap: {
    			type: "TOP"
    		},
    		subcompname: {
    			type: "string"
    		},
    		fogdensity: {
    			type: "float"
    		},
    		focal: {
    			type: "float"
    		},
    		roll: {
    			type: "float"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		projectionblend: {
    			type: "float"
    		},
    		far: {
    			type: "float"
    		},
    		pickpriority: {
    			type: "float"
    		},
    		extname4: {
    			type: "string"
    		},
    		noffset: {
    			type: "float"
    		},
    		ipdshift: {
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		externaltox: {
    			type: "string"
    		},
    		viewanglemethod: {
    			type: "menu",
    			menuitems: [
    				"horzfov",
    				"vertfov",
    				"focalaperture"
    			]
    		},
    		constrain: {
    			type: "COMP"
    		},
    		clone: {
    			type: "COMP"
    		},
    		ps: {
    			type: "xyz"
    		},
    		p: {
    			type: "xyz"
    		},
    		blendw4: {
    			type: "float"
    		},
    		r: {
    			type: "xyz"
    		},
    		winsize: {
    		},
    		reset: {
    			type: "float"
    		},
    		scale: {
    		},
    		camlightmask: {
    			type: "COMP"
    		},
    		pxform: {
    			type: "toggle"
    		},
    		extension2: {
    			type: "string"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		extname2: {
    			type: "string"
    		},
    		blendw1: {
    			type: "float"
    		},
    		customproj: {
    			type: "DAT"
    		},
    		extname3: {
    			type: "string"
    		},
    		fogalpha: {
    			type: "float"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		s: {
    			type: "xyz"
    		},
    		lookat: {
    			type: "COMP"
    		},
    		win: {
    			type: "xy"
    		},
    		blendm4: {
    			type: "number"
    		},
    		extension3: {
    			type: "string"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var opviewerCOMP = {
    	maxInputs: 1,
    	pars: {
    		resizer: {
    			type: "toggle"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		top: {
    			type: "TOP"
    		},
    		offset: {
    			type: "xy"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		resizel: {
    			type: "toggle"
    		},
    		topoffset: {
    			type: "float"
    		},
    		helpdat: {
    			type: "DAT"
    		},
    		mouserel: {
    			type: "toggle"
    		},
    		topanchor: {
    			type: "float"
    		},
    		align: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"horizlr",
    				"horizrl",
    				"verttb",
    				"vertbt",
    				"gridrows",
    				"gridcols",
    				"nodes"
    			]
    		},
    		bgcolor: {
    			type: "rgb"
    		},
    		repositionxmin: {
    			type: "float"
    		},
    		bottomanchor: {
    			type: "float"
    		},
    		paneldragop: {
    			type: "OP"
    		},
    		uvbuttonsmiddle: {
    			type: "toggle"
    		},
    		leftborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		opacity: {
    			type: "float"
    		},
    		w: {
    			type: "number"
    		},
    		chop: {
    			type: "CHOP"
    		},
    		rightoffset: {
    			type: "float"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		multitouch: {
    			type: "menu",
    			menuitems: [
    				"mtouchparent",
    				"mtouchyes",
    				"mtouchno"
    			]
    		},
    		hmode: {
    			type: "menu",
    			menuitems: [
    				"fixed",
    				"fill",
    				"anchors"
    			]
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		pvscrollbar: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		bgalpha: {
    			type: "float"
    		},
    		alignallow: {
    			type: "menu",
    			menuitems: [
    				"allow",
    				"ignore",
    				"ignoremargin"
    			]
    		},
    		bordera: {
    			type: "rgb"
    		},
    		clickthrough: {
    			type: "toggle"
    		},
    		dropdestscript: {
    			type: "DAT"
    		},
    		multrgb: {
    			type: "toggle"
    		},
    		disablecolor: {
    			type: "rgb"
    		},
    		leftborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		crop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"never"
    			]
    		},
    		spacing: {
    			type: "float"
    		},
    		vfillweight: {
    			type: "float"
    		},
    		bottomborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		postoffset: {
    			type: "xy"
    		},
    		horigin: {
    			type: "float"
    		},
    		topborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		borderbalpha: {
    			type: "float"
    		},
    		bottomoffset: {
    			type: "float"
    		},
    		layer: {
    			type: "float"
    		},
    		extension4: {
    			type: "string"
    		},
    		extname1: {
    			type: "string"
    		},
    		dragdropcallbacks: {
    			type: "DAT"
    		},
    		drag: {
    			type: "menu",
    			menuitems: [
    				"dragparent",
    				"legacy",
    				"dragno",
    				"usecallbacks"
    			]
    		},
    		rightborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		scale: {
    			type: "xy"
    		},
    		fit: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"best"
    			]
    		},
    		keepmemory: {
    			type: "toggle"
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		dragscript: {
    			type: "DAT"
    		},
    		fixedaspect: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical"
    			]
    		},
    		opviewer: {
    			type: "OP"
    		},
    		borderover: {
    			type: "toggle"
    		},
    		resizewmin: {
    			type: "float"
    		},
    		disablealpha: {
    			type: "float"
    		},
    		anchordrag: {
    			type: "menu",
    			menuitems: [
    				"anchors",
    				"offsets"
    			]
    		},
    		scrolloverlay: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"ignore",
    				"ignoreover"
    			]
    		},
    		vmode: {
    			type: "menu",
    			menuitems: [
    				"fixed",
    				"fill",
    				"anchors"
    			]
    		},
    		marginb: {
    			type: "float"
    		},
    		vorigin: {
    			type: "float"
    		},
    		enable: {
    			type: "toggle"
    		},
    		namedchop: {
    			type: "toggle"
    		},
    		subcompname: {
    			type: "string"
    		},
    		marginr: {
    			type: "float"
    		},
    		scrollbarthickness: {
    			type: "number"
    		},
    		reposition: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"window",
    				"component"
    			]
    		},
    		bottomborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		mousewheel: {
    			type: "toggle"
    		},
    		leftoffset: {
    			type: "float"
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"left",
    				"center",
    				"right"
    			]
    		},
    		resizehmax: {
    			type: "float"
    		},
    		aspect: {
    			type: "float"
    		},
    		cursor: {
    			type: "menu",
    			menuitems: [
    				"pointer",
    				"linkselect",
    				"ibeam",
    				"cross",
    				"busy",
    				"activate",
    				"invisible"
    			]
    		},
    		repocomp: {
    			type: "PanelCOMP"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		droptypescript: {
    			type: "DAT"
    		},
    		topborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		composite: {
    			type: "menu",
    			menuitems: [
    				"over",
    				"under",
    				"inside",
    				"outside",
    				"add",
    				"subtract",
    				"multiply"
    			]
    		},
    		phscrollbar: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		externaltox: {
    			type: "string"
    		},
    		clone: {
    			type: "COMP"
    		},
    		extension1: {
    			type: "string"
    		},
    		y: {
    			type: "number"
    		},
    		resizeb: {
    			type: "toggle"
    		},
    		resizehmin: {
    			type: "float"
    		},
    		topfill: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"best",
    				"native"
    			]
    		},
    		drop: {
    			type: "menu",
    			menuitems: [
    				"dropparent",
    				"legacy",
    				"dropno",
    				"usecallbacks"
    			]
    		},
    		extension2: {
    			type: "string"
    		},
    		rightborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		repositionymin: {
    			type: "float"
    		},
    		borderaalpha: {
    			type: "float"
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"top",
    				"center",
    				"bottom"
    			]
    		},
    		leftanchor: {
    			type: "float"
    		},
    		repositionymax: {
    			type: "float"
    		},
    		dodisablecolor: {
    			type: "toggle"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		},
    		alignmax: {
    			type: "number"
    		},
    		alignorder: {
    			type: "float"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		extname2: {
    			type: "string"
    		},
    		uvbuttonsright: {
    			type: "toggle"
    		},
    		x: {
    			type: "number"
    		},
    		extname3: {
    			type: "string"
    		},
    		overridemethod: {
    			type: "menu",
    			menuitems: [
    				"trigger",
    				"always"
    			]
    		},
    		uvbuttonsleft: {
    			type: "toggle"
    		},
    		borderb: {
    			type: "rgb"
    		},
    		vieweraspect: {
    			type: "menu",
    			menuitems: [
    				"proportional",
    				"unconstrained"
    			]
    		},
    		sizefromwindow: {
    			type: "toggle"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		resizewmax: {
    			type: "float"
    		},
    		margint: {
    			type: "float"
    		},
    		extension3: {
    			type: "string"
    		},
    		overlay: {
    			type: "toggle"
    		},
    		repositionxmax: {
    			type: "float"
    		},
    		marginl: {
    			type: "float"
    		},
    		hfillweight: {
    			type: "float"
    		},
    		extname4: {
    			type: "string"
    		},
    		resizet: {
    			type: "toggle"
    		},
    		rightanchor: {
    			type: "float"
    		},
    		dropscript: {
    			type: "DAT"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		h: {
    			type: "number"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		display: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var fieldCOMP = {
    	maxInputs: 1,
    	pars: {
    		savebackup: {
    			type: "toggle"
    		},
    		resizer: {
    			type: "toggle"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		top: {
    			type: "TOP"
    		},
    		offset: {
    			type: "xy"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		extension3: {
    			type: "string"
    		},
    		resizel: {
    			type: "toggle"
    		},
    		topoffset: {
    			type: "float"
    		},
    		mouserel: {
    			type: "toggle"
    		},
    		topanchor: {
    			type: "float"
    		},
    		align: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"horizlr",
    				"horizrl",
    				"verttb",
    				"vertbt",
    				"gridrows",
    				"gridcols",
    				"nodes"
    			]
    		},
    		bgcolor: {
    			type: "rgb"
    		},
    		repositionxmin: {
    			type: "float"
    		},
    		bottomanchor: {
    			type: "float"
    		},
    		paneldragop: {
    			type: "OP"
    		},
    		uvbuttonsmiddle: {
    			type: "toggle"
    		},
    		extname2: {
    			type: "string"
    		},
    		leftborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		opacity: {
    			type: "float"
    		},
    		w: {
    			type: "number"
    		},
    		chop: {
    			type: "CHOP"
    		},
    		rightoffset: {
    			type: "float"
    		},
    		fieldexpand: {
    			type: "toggle"
    		},
    		multitouch: {
    			type: "menu",
    			menuitems: [
    				"mtouchparent",
    				"mtouchyes",
    				"mtouchno"
    			]
    		},
    		hmode: {
    			type: "menu",
    			menuitems: [
    				"fixed",
    				"fill",
    				"anchors"
    			]
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		fieldtype: {
    			type: "menu",
    			menuitems: [
    				"string",
    				"float",
    				"integer"
    			]
    		},
    		bgalpha: {
    			type: "float"
    		},
    		alignallow: {
    			type: "menu",
    			menuitems: [
    				"allow",
    				"ignore",
    				"ignoremargin"
    			]
    		},
    		multrgb: {
    			type: "toggle"
    		},
    		clickthrough: {
    			type: "toggle"
    		},
    		dropdestscript: {
    			type: "DAT"
    		},
    		bordera: {
    			type: "rgb"
    		},
    		disablecolor: {
    			type: "rgb"
    		},
    		leftborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		fieldcursor: {
    			type: "toggle"
    		},
    		crop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"never"
    			]
    		},
    		helpdat: {
    			type: "DAT"
    		},
    		vfillweight: {
    			type: "float"
    		},
    		bottomborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		postoffset: {
    			type: "xy"
    		},
    		topborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		borderbalpha: {
    			type: "float"
    		},
    		subcompname: {
    			type: "string"
    		},
    		bottomoffset: {
    			type: "float"
    		},
    		layer: {
    			type: "float"
    		},
    		extension4: {
    			type: "string"
    		},
    		extname1: {
    			type: "string"
    		},
    		dragdropcallbacks: {
    			type: "DAT"
    		},
    		drag: {
    			type: "menu",
    			menuitems: [
    				"dragparent",
    				"legacy",
    				"dragno",
    				"usecallbacks"
    			]
    		},
    		rightborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		scale: {
    			type: "xy"
    		},
    		fit: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"best"
    			]
    		},
    		keepmemory: {
    			type: "toggle"
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		dragscript: {
    			type: "DAT"
    		},
    		fixedaspect: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical"
    			]
    		},
    		resizewmin: {
    			type: "float"
    		},
    		borderover: {
    			type: "toggle"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		extension1: {
    			type: "string"
    		},
    		disablealpha: {
    			type: "float"
    		},
    		alignmax: {
    			type: "number"
    		},
    		anchordrag: {
    			type: "menu",
    			menuitems: [
    				"anchors",
    				"offsets"
    			]
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		scrolloverlay: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"ignore",
    				"ignoreover"
    			]
    		},
    		fieldconspaces: {
    			type: "toggle"
    		},
    		rightanchor: {
    			type: "float"
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		vorigin: {
    			type: "float"
    		},
    		enable: {
    			type: "toggle"
    		},
    		namedchop: {
    			type: "toggle"
    		},
    		spacing: {
    			type: "float"
    		},
    		marginr: {
    			type: "float"
    		},
    		fieldnoshift: {
    			type: "toggle"
    		},
    		reposition: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"window",
    				"component"
    			]
    		},
    		bottomborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		mousewheel: {
    			type: "toggle"
    		},
    		leftoffset: {
    			type: "float"
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"left",
    				"center",
    				"right"
    			]
    		},
    		resizehmax: {
    			type: "float"
    		},
    		aspect: {
    			type: "float"
    		},
    		cursor: {
    			type: "menu",
    			menuitems: [
    				"pointer",
    				"linkselect",
    				"ibeam",
    				"cross",
    				"busy",
    				"activate",
    				"invisible"
    			]
    		},
    		repocomp: {
    			type: "PanelCOMP"
    		},
    		overlay: {
    			type: "toggle"
    		},
    		droptypescript: {
    			type: "DAT"
    		},
    		topborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		composite: {
    			type: "menu",
    			menuitems: [
    				"over",
    				"under",
    				"inside",
    				"outside",
    				"add",
    				"subtract",
    				"multiply"
    			]
    		},
    		phscrollbar: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		externaltox: {
    			type: "string"
    		},
    		scrollbarthickness: {
    			type: "number"
    		},
    		clone: {
    			type: "COMP"
    		},
    		fieldfocus: {
    			type: "DAT"
    		},
    		y: {
    			type: "number"
    		},
    		resizeb: {
    			type: "toggle"
    		},
    		resizehmin: {
    			type: "float"
    		},
    		topfill: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"best",
    				"native"
    			]
    		},
    		drop: {
    			type: "menu",
    			menuitems: [
    				"dropparent",
    				"legacy",
    				"dropno",
    				"usecallbacks"
    			]
    		},
    		extension2: {
    			type: "string"
    		},
    		rightborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		repositionymin: {
    			type: "float"
    		},
    		borderaalpha: {
    			type: "float"
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"top",
    				"center",
    				"bottom"
    			]
    		},
    		leftanchor: {
    			type: "float"
    		},
    		repositionymax: {
    			type: "float"
    		},
    		dodisablecolor: {
    			type: "toggle"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		},
    		borderb: {
    			type: "rgb"
    		},
    		alignorder: {
    			type: "float"
    		},
    		fieldprotected: {
    			type: "toggle"
    		},
    		pvscrollbar: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		uvbuttonsright: {
    			type: "toggle"
    		},
    		x: {
    			type: "number"
    		},
    		extname3: {
    			type: "string"
    		},
    		overridemethod: {
    			type: "menu",
    			menuitems: [
    				"trigger",
    				"always"
    			]
    		},
    		uvbuttonsleft: {
    			type: "toggle"
    		},
    		horigin: {
    			type: "float"
    		},
    		vieweraspect: {
    			type: "menu",
    			menuitems: [
    				"proportional",
    				"unconstrained"
    			]
    		},
    		sizefromwindow: {
    			type: "toggle"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		resizewmax: {
    			type: "float"
    		},
    		margint: {
    			type: "float"
    		},
    		vmode: {
    			type: "menu",
    			menuitems: [
    				"fixed",
    				"fill",
    				"anchors"
    			]
    		},
    		repositionxmax: {
    			type: "float"
    		},
    		fieldlock: {
    			type: "toggle"
    		},
    		hfillweight: {
    			type: "float"
    		},
    		extname4: {
    			type: "string"
    		},
    		marginl: {
    			type: "float"
    		},
    		resizet: {
    			type: "toggle"
    		},
    		marginb: {
    			type: "float"
    		},
    		dropscript: {
    			type: "DAT"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		h: {
    			type: "number"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		display: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var blendCOMP = {
    	maxInputs: 9999,
    	pars: {
    		axesorient: {
    			type: "toggle"
    		},
    		instancety: {
    			type: "string"
    		},
    		instancesz: {
    			type: "string"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		blendm2: {
    			type: "number"
    		},
    		instancerottoz: {
    			type: "string"
    		},
    		parenttype: {
    			type: "menu",
    			menuitems: [
    				"blend",
    				"sequence",
    				"constrain"
    			]
    		},
    		preset: {
    			type: "pulse"
    		},
    		blendm3: {
    			type: "number"
    		},
    		instancetz: {
    			type: "string"
    		},
    		material: {
    			type: "MAT"
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		instancetx: {
    			type: "string"
    		},
    		instancecolormode: {
    			type: "menu",
    			menuitems: [
    				"replace",
    				"multiply",
    				"add",
    				"subtract"
    			]
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		pp: {
    			type: "xyz"
    		},
    		instancerotupz: {
    			type: "string"
    		},
    		blendw2: {
    			type: "float"
    		},
    		extension4: {
    			type: "string"
    		},
    		pr: {
    			type: "xyz"
    		},
    		pxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		pathorient: {
    			type: "toggle"
    		},
    		pathsop: {
    			type: "SOP"
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		pt: {
    			type: "xyz"
    		},
    		bank: {
    			type: "float"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		instancerz: {
    			type: "string"
    		},
    		instanceop: {
    			type: "OP"
    		},
    		instancemode: {
    			type: "menu",
    			menuitems: [
    				"manual",
    				"oplength"
    			]
    		},
    		instancetexextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		instancea: {
    			type: "string"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		prord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		extension1: {
    			type: "string"
    		},
    		xformmatrixop: {
    			type: "OP"
    		},
    		wcolor: {
    			type: "rgb"
    		},
    		t: {
    			type: "xyz"
    		},
    		instancev: {
    			type: "string"
    		},
    		extname1: {
    			type: "string"
    		},
    		instancetexs: {
    			type: "TOP"
    		},
    		lightmask: {
    			type: "COMP"
    		},
    		sequence: {
    			type: "float"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		instancetexextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		lookup: {
    			type: "string"
    		},
    		instancerottoorder: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"prerot",
    				"postrot"
    			]
    		},
    		blendm1: {
    			type: "number"
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		instancer: {
    			type: "string"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		shortrot: {
    			type: "toggle"
    		},
    		render: {
    			type: "toggle"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		prioritymethod: {
    			type: "menu",
    			menuitems: [
    				"custom",
    				"camdist"
    			]
    		},
    		blendw3: {
    			type: "float"
    		},
    		instancetexindex: {
    			type: "string"
    		},
    		pcommit: {
    			type: "pulse"
    		},
    		instanceb: {
    			type: "string"
    		},
    		up: {
    			type: "xyz"
    		},
    		pscale: {
    		},
    		drawpriority: {
    			type: "float"
    		},
    		subcompname: {
    			type: "string"
    		},
    		instanceu: {
    			type: "string"
    		},
    		roll: {
    			type: "float"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		pos: {
    			type: "float"
    		},
    		instrord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		instancerottoy: {
    			type: "string"
    		},
    		instancing: {
    			type: "toggle"
    		},
    		pickpriority: {
    			type: "float"
    		},
    		instancesy: {
    			type: "string"
    		},
    		instancepy: {
    			type: "string"
    		},
    		instancerotupy: {
    			type: "string"
    		},
    		extname4: {
    			type: "string"
    		},
    		noffset: {
    			type: "float"
    		},
    		instxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		instancery: {
    			type: "string"
    		},
    		externaltox: {
    			type: "string"
    		},
    		constrain: {
    			type: "COMP"
    		},
    		clone: {
    			type: "COMP"
    		},
    		ps: {
    			type: "xyz"
    		},
    		p: {
    			type: "xyz"
    		},
    		blendw4: {
    			type: "float"
    		},
    		instancepz: {
    			type: "string"
    		},
    		r: {
    			type: "xyz"
    		},
    		instancetexfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		reset: {
    			type: "float"
    		},
    		scale: {
    		},
    		instancerotupx: {
    			type: "string"
    		},
    		instancetexextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		pxform: {
    			type: "toggle"
    		},
    		instancew: {
    			type: "string"
    		},
    		extension2: {
    			type: "string"
    		},
    		instancetexmode: {
    			type: "menu",
    			menuitems: [
    				"replace",
    				"offset"
    			]
    		},
    		instanceg: {
    			type: "string"
    		},
    		instancerx: {
    			type: "string"
    		},
    		instancetexanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		extname2: {
    			type: "string"
    		},
    		instanceorder: {
    			type: "menu",
    			menuitems: [
    				"instanceworld",
    				"worldinstance"
    			]
    		},
    		blendw1: {
    			type: "float"
    		},
    		extname3: {
    			type: "string"
    		},
    		numinstances: {
    			type: "number"
    		},
    		blendm4: {
    			type: "number"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		s: {
    			type: "xyz"
    		},
    		lookat: {
    			type: "COMP"
    		},
    		instancesx: {
    			type: "string"
    		},
    		instancepx: {
    			type: "string"
    		},
    		instancerottox: {
    			type: "string"
    		},
    		instancefirstrow: {
    			type: "menu",
    			menuitems: [
    				"ignored",
    				"names",
    				"values"
    			]
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		extension3: {
    			type: "string"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var parameterCOMP = {
    	maxInputs: 1,
    	pars: {
    		resizer: {
    			type: "toggle"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		top: {
    			type: "TOP"
    		},
    		offset: {
    			type: "xy"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		resizel: {
    			type: "toggle"
    		},
    		topoffset: {
    			type: "float"
    		},
    		mouserel: {
    			type: "toggle"
    		},
    		topanchor: {
    			type: "float"
    		},
    		align: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"horizlr",
    				"horizrl",
    				"verttb",
    				"vertbt",
    				"gridrows",
    				"gridcols",
    				"nodes"
    			]
    		},
    		bgcolor: {
    			type: "rgb"
    		},
    		repositionxmin: {
    			type: "float"
    		},
    		bottomanchor: {
    			type: "float"
    		},
    		paneldragop: {
    			type: "OP"
    		},
    		uvbuttonsmiddle: {
    			type: "toggle"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		leftborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		opacity: {
    			type: "float"
    		},
    		w: {
    			type: "number"
    		},
    		chop: {
    			type: "CHOP"
    		},
    		rightoffset: {
    			type: "float"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		multitouch: {
    			type: "menu",
    			menuitems: [
    				"mtouchparent",
    				"mtouchyes",
    				"mtouchno"
    			]
    		},
    		hmode: {
    			type: "menu",
    			menuitems: [
    				"fixed",
    				"fill",
    				"anchors"
    			]
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		pvscrollbar: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		bgalpha: {
    			type: "float"
    		},
    		alignallow: {
    			type: "menu",
    			menuitems: [
    				"allow",
    				"ignore",
    				"ignoremargin"
    			]
    		},
    		bordera: {
    			type: "rgb"
    		},
    		clickthrough: {
    			type: "toggle"
    		},
    		dropdestscript: {
    			type: "DAT"
    		},
    		multrgb: {
    			type: "toggle"
    		},
    		disablecolor: {
    			type: "rgb"
    		},
    		leftborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		crop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"never"
    			]
    		},
    		helpdat: {
    			type: "DAT"
    		},
    		vfillweight: {
    			type: "float"
    		},
    		bottomborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		postoffset: {
    			type: "xy"
    		},
    		topborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		borderbalpha: {
    			type: "float"
    		},
    		subcompname: {
    			type: "string"
    		},
    		bottomoffset: {
    			type: "float"
    		},
    		layer: {
    			type: "float"
    		},
    		extension4: {
    			type: "string"
    		},
    		extname1: {
    			type: "string"
    		},
    		dragdropcallbacks: {
    			type: "DAT"
    		},
    		drag: {
    			type: "menu",
    			menuitems: [
    				"dragparent",
    				"legacy",
    				"dragno",
    				"usecallbacks"
    			]
    		},
    		pagenames: {
    			type: "toggle"
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		custom: {
    			type: "toggle"
    		},
    		scale: {
    			type: "xy"
    		},
    		fit: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"best"
    			]
    		},
    		rightborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		keepmemory: {
    			type: "toggle"
    		},
    		enable: {
    			type: "toggle"
    		},
    		dragscript: {
    			type: "DAT"
    		},
    		fixedaspect: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical"
    			]
    		},
    		resizewmin: {
    			type: "float"
    		},
    		borderover: {
    			type: "toggle"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		header: {
    			type: "toggle"
    		},
    		disablealpha: {
    			type: "float"
    		},
    		alignmax: {
    			type: "number"
    		},
    		anchordrag: {
    			type: "menu",
    			menuitems: [
    				"anchors",
    				"offsets"
    			]
    		},
    		scrolloverlay: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"ignore",
    				"ignoreover"
    			]
    		},
    		vmode: {
    			type: "menu",
    			menuitems: [
    				"fixed",
    				"fill",
    				"anchors"
    			]
    		},
    		rightanchor: {
    			type: "float"
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		vorigin: {
    			type: "float"
    		},
    		parscope: {
    			type: "string"
    		},
    		namedchop: {
    			type: "toggle"
    		},
    		inputeditor: {
    			type: "toggle"
    		},
    		spacing: {
    			type: "float"
    		},
    		marginr: {
    			type: "float"
    		},
    		scrollbarthickness: {
    			type: "number"
    		},
    		reposition: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"window",
    				"component"
    			]
    		},
    		bottomborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		mousewheel: {
    			type: "toggle"
    		},
    		leftoffset: {
    			type: "float"
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"left",
    				"center",
    				"right"
    			]
    		},
    		resizehmax: {
    			type: "float"
    		},
    		builtin: {
    			type: "toggle"
    		},
    		aspect: {
    			type: "float"
    		},
    		cursor: {
    			type: "menu",
    			menuitems: [
    				"pointer",
    				"linkselect",
    				"ibeam",
    				"cross",
    				"busy",
    				"activate",
    				"invisible"
    			]
    		},
    		repocomp: {
    			type: "PanelCOMP"
    		},
    		overlay: {
    			type: "toggle"
    		},
    		droptypescript: {
    			type: "DAT"
    		},
    		topborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		composite: {
    			type: "menu",
    			menuitems: [
    				"over",
    				"under",
    				"inside",
    				"outside",
    				"add",
    				"subtract",
    				"multiply"
    			]
    		},
    		phscrollbar: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		externaltox: {
    			type: "string"
    		},
    		combinescopes: {
    			type: "menu",
    			menuitems: [
    				"any",
    				"all"
    			]
    		},
    		clone: {
    			type: "COMP"
    		},
    		pagescope: {
    			type: "string"
    		},
    		op: {
    			type: "OP"
    		},
    		extension1: {
    			type: "string"
    		},
    		scopeorder: {
    			type: "toggle"
    		},
    		y: {
    			type: "number"
    		},
    		resizeb: {
    			type: "toggle"
    		},
    		resizehmin: {
    			type: "float"
    		},
    		topfill: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"best",
    				"native"
    			]
    		},
    		drop: {
    			type: "menu",
    			menuitems: [
    				"dropparent",
    				"legacy",
    				"dropno",
    				"usecallbacks"
    			]
    		},
    		extension2: {
    			type: "string"
    		},
    		rightborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		repositionymin: {
    			type: "float"
    		},
    		borderaalpha: {
    			type: "float"
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"top",
    				"center",
    				"bottom"
    			]
    		},
    		leftanchor: {
    			type: "float"
    		},
    		repositionymax: {
    			type: "float"
    		},
    		dodisablecolor: {
    			type: "toggle"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		},
    		borderb: {
    			type: "rgb"
    		},
    		alignorder: {
    			type: "float"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		extname2: {
    			type: "string"
    		},
    		uvbuttonsright: {
    			type: "toggle"
    		},
    		x: {
    			type: "number"
    		},
    		extname3: {
    			type: "string"
    		},
    		overridemethod: {
    			type: "menu",
    			menuitems: [
    				"trigger",
    				"always"
    			]
    		},
    		uvbuttonsleft: {
    			type: "toggle"
    		},
    		horigin: {
    			type: "float"
    		},
    		vieweraspect: {
    			type: "menu",
    			menuitems: [
    				"proportional",
    				"unconstrained"
    			]
    		},
    		sizefromwindow: {
    			type: "toggle"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		resizewmax: {
    			type: "float"
    		},
    		margint: {
    			type: "float"
    		},
    		extension3: {
    			type: "string"
    		},
    		repositionxmax: {
    			type: "float"
    		},
    		marginl: {
    			type: "float"
    		},
    		hfillweight: {
    			type: "float"
    		},
    		extname4: {
    			type: "string"
    		},
    		resizet: {
    			type: "toggle"
    		},
    		marginb: {
    			type: "float"
    		},
    		dropscript: {
    			type: "DAT"
    		},
    		oversize: {
    			type: "float"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		h: {
    			type: "number"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		display: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var ambientlightCOMP = {
    	maxInputs: 1,
    	pars: {
    		roll: {
    			type: "float"
    		},
    		pathorient: {
    			type: "toggle"
    		},
    		drawpriority: {
    			type: "float"
    		},
    		viewanglemethod: {
    			type: "menu",
    			menuitems: [
    				"horzfov",
    				"vertfov",
    				"focalaperture"
    			]
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		fogmap: {
    			type: "TOP"
    		},
    		pxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		subcompname: {
    			type: "string"
    		},
    		c: {
    			type: "rgb"
    		},
    		fogdensity: {
    			type: "float"
    		},
    		focal: {
    			type: "float"
    		},
    		aperture: {
    			type: "float"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		up: {
    			type: "xyz"
    		},
    		projectionblend: {
    			type: "float"
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		far: {
    			type: "float"
    		},
    		bgcolor: {
    			type: "rgba"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		pickpriority: {
    			type: "float"
    		},
    		pos: {
    			type: "float"
    		},
    		pscale: {
    		},
    		dimmer: {
    			type: "float"
    		},
    		extension4: {
    			type: "string"
    		},
    		extname4: {
    			type: "string"
    		},
    		ipdshift: {
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		r: {
    			type: "xyz"
    		},
    		pathsop: {
    			type: "SOP"
    		},
    		externaltox: {
    			type: "string"
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		constrain: {
    			type: "COMP"
    		},
    		clone: {
    			type: "COMP"
    		},
    		orthowidth: {
    			type: "float"
    		},
    		ps: {
    			type: "xyz"
    		},
    		p: {
    			type: "xyz"
    		},
    		fognear: {
    			type: "float"
    		},
    		near: {
    			type: "float"
    		},
    		bank: {
    			type: "float"
    		},
    		extension1: {
    			type: "string"
    		},
    		winsize: {
    		},
    		scale: {
    		},
    		fogalpha: {
    			type: "float"
    		},
    		t: {
    			type: "xyz"
    		},
    		pxform: {
    			type: "toggle"
    		},
    		pcommit: {
    			type: "pulse"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		prord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		xformmatrixop: {
    			type: "OP"
    		},
    		pr: {
    			type: "xyz"
    		},
    		wcolor: {
    			type: "rgb"
    		},
    		extension2: {
    			type: "string"
    		},
    		fog: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"linear",
    				"exp",
    				"exp2"
    			]
    		},
    		extname1: {
    			type: "string"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		extname2: {
    			type: "string"
    		},
    		preset: {
    			type: "pulse"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		customproj: {
    			type: "DAT"
    		},
    		extname3: {
    			type: "string"
    		},
    		projmatrixop: {
    			type: "OP"
    		},
    		lookup: {
    			type: "string"
    		},
    		material: {
    			type: "MAT"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		s: {
    			type: "xyz"
    		},
    		lookat: {
    			type: "COMP"
    		},
    		fogcolor: {
    			type: "rgb"
    		},
    		render: {
    			type: "toggle"
    		},
    		fov: {
    			type: "float"
    		},
    		camlightmask: {
    			type: "COMP"
    		},
    		prioritymethod: {
    			type: "menu",
    			menuitems: [
    				"custom",
    				"camdist"
    			]
    		},
    		win: {
    			type: "xy"
    		},
    		pt: {
    			type: "xyz"
    		},
    		pp: {
    			type: "xyz"
    		},
    		fogfar: {
    			type: "float"
    		},
    		winroll: {
    		},
    		projection: {
    			type: "menu",
    			menuitems: [
    				"perspective",
    				"ortho",
    				"persporthoblend",
    				"custommatrix"
    			]
    		},
    		extension3: {
    			type: "string"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var baseCOMP = {
    	maxInputs: 0,
    	pars: {
    		reinitextensions: {
    			type: "pulse"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		subcompname: {
    			type: "string"
    		},
    		extension2: {
    			type: "string"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		extname2: {
    			type: "string"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		extname3: {
    			type: "string"
    		},
    		extension4: {
    			type: "string"
    		},
    		extname4: {
    			type: "string"
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		externaltox: {
    			type: "string"
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		clone: {
    			type: "COMP"
    		},
    		extname1: {
    			type: "string"
    		},
    		extension1: {
    			type: "string"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		extension3: {
    			type: "string"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var listCOMP = {
    	maxInputs: 1,
    	pars: {
    		extension2: {
    			type: "string"
    		},
    		resizer: {
    			type: "toggle"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		top: {
    			type: "TOP"
    		},
    		offset: {
    			type: "xy"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		resizel: {
    			type: "toggle"
    		},
    		topoffset: {
    			type: "float"
    		},
    		mouserel: {
    			type: "toggle"
    		},
    		topanchor: {
    			type: "float"
    		},
    		align: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"horizlr",
    				"horizrl",
    				"verttb",
    				"vertbt",
    				"gridrows",
    				"gridcols",
    				"nodes"
    			]
    		},
    		bgcolor: {
    			type: "rgb"
    		},
    		repositionxmin: {
    			type: "float"
    		},
    		bottomanchor: {
    			type: "float"
    		},
    		paneldragop: {
    			type: "OP"
    		},
    		uvbuttonsmiddle: {
    			type: "toggle"
    		},
    		leftborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		opacity: {
    			type: "float"
    		},
    		w: {
    			type: "number"
    		},
    		chop: {
    			type: "CHOP"
    		},
    		rightoffset: {
    			type: "float"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		multitouch: {
    			type: "menu",
    			menuitems: [
    				"mtouchparent",
    				"mtouchyes",
    				"mtouchno"
    			]
    		},
    		hmode: {
    			type: "menu",
    			menuitems: [
    				"fixed",
    				"fill",
    				"anchors"
    			]
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		pvscrollbar: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		bgalpha: {
    			type: "float"
    		},
    		alignallow: {
    			type: "menu",
    			menuitems: [
    				"allow",
    				"ignore",
    				"ignoremargin"
    			]
    		},
    		rows: {
    			type: "number"
    		},
    		bordera: {
    			type: "rgb"
    		},
    		clickthrough: {
    			type: "toggle"
    		},
    		dropdestscript: {
    			type: "DAT"
    		},
    		rightborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		lockfirstcol: {
    			type: "toggle"
    		},
    		disablecolor: {
    			type: "rgb"
    		},
    		leftborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		crop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"never"
    			]
    		},
    		helpdat: {
    			type: "DAT"
    		},
    		vfillweight: {
    			type: "float"
    		},
    		bottomborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		postoffset: {
    			type: "xy"
    		},
    		topborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		borderbalpha: {
    			type: "float"
    		},
    		subcompname: {
    			type: "string"
    		},
    		bottomoffset: {
    			type: "float"
    		},
    		layer: {
    			type: "float"
    		},
    		extension4: {
    			type: "string"
    		},
    		extname1: {
    			type: "string"
    		},
    		dragdropcallbacks: {
    			type: "DAT"
    		},
    		drag: {
    			type: "menu",
    			menuitems: [
    				"dragparent",
    				"legacy",
    				"dragno",
    				"usecallbacks"
    			]
    		},
    		reset: {
    			type: "pulse"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		scale: {
    			type: "xy"
    		},
    		fit: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"best"
    			]
    		},
    		keepmemory: {
    			type: "toggle"
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		dragscript: {
    			type: "DAT"
    		},
    		fixedaspect: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical"
    			]
    		},
    		multrgb: {
    			type: "toggle"
    		},
    		borderover: {
    			type: "toggle"
    		},
    		cols: {
    			type: "number"
    		},
    		disablealpha: {
    			type: "float"
    		},
    		alignmax: {
    			type: "number"
    		},
    		resizewmin: {
    			type: "float"
    		},
    		anchordrag: {
    			type: "menu",
    			menuitems: [
    				"anchors",
    				"offsets"
    			]
    		},
    		scrolloverlay: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"ignore",
    				"ignoreover"
    			]
    		},
    		vmode: {
    			type: "menu",
    			menuitems: [
    				"fixed",
    				"fill",
    				"anchors"
    			]
    		},
    		rightanchor: {
    			type: "float"
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		vorigin: {
    			type: "float"
    		},
    		enable: {
    			type: "toggle"
    		},
    		namedchop: {
    			type: "toggle"
    		},
    		spacing: {
    			type: "float"
    		},
    		marginr: {
    			type: "float"
    		},
    		scrollbarthickness: {
    			type: "number"
    		},
    		reposition: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"window",
    				"component"
    			]
    		},
    		bottomborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		mousewheel: {
    			type: "toggle"
    		},
    		leftoffset: {
    			type: "float"
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"left",
    				"center",
    				"right"
    			]
    		},
    		resizehmax: {
    			type: "float"
    		},
    		aspect: {
    			type: "float"
    		},
    		cursor: {
    			type: "menu",
    			menuitems: [
    				"pointer",
    				"linkselect",
    				"ibeam",
    				"cross",
    				"busy",
    				"activate",
    				"invisible"
    			]
    		},
    		repocomp: {
    			type: "PanelCOMP"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		droptypescript: {
    			type: "DAT"
    		},
    		topborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		composite: {
    			type: "menu",
    			menuitems: [
    				"over",
    				"under",
    				"inside",
    				"outside",
    				"add",
    				"subtract",
    				"multiply"
    			]
    		},
    		phscrollbar: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		externaltox: {
    			type: "string"
    		},
    		clone: {
    			type: "COMP"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		extension1: {
    			type: "string"
    		},
    		y: {
    			type: "number"
    		},
    		resizeb: {
    			type: "toggle"
    		},
    		resizehmin: {
    			type: "float"
    		},
    		topfill: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"best",
    				"native"
    			]
    		},
    		drop: {
    			type: "menu",
    			menuitems: [
    				"dropparent",
    				"legacy",
    				"dropno",
    				"usecallbacks"
    			]
    		},
    		vscrollbar: {
    			type: "toggle"
    		},
    		rightborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		repositionymin: {
    			type: "float"
    		},
    		borderaalpha: {
    			type: "float"
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"top",
    				"center",
    				"bottom"
    			]
    		},
    		offcellcallbacks: {
    			type: "toggle"
    		},
    		leftanchor: {
    			type: "float"
    		},
    		repositionymax: {
    			type: "float"
    		},
    		dodisablecolor: {
    			type: "toggle"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		},
    		borderb: {
    			type: "rgb"
    		},
    		alignorder: {
    			type: "float"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		extname2: {
    			type: "string"
    		},
    		uvbuttonsright: {
    			type: "toggle"
    		},
    		x: {
    			type: "number"
    		},
    		hscrollbar: {
    			type: "toggle"
    		},
    		extname3: {
    			type: "string"
    		},
    		overridemethod: {
    			type: "menu",
    			menuitems: [
    				"trigger",
    				"always"
    			]
    		},
    		uvbuttonsleft: {
    			type: "toggle"
    		},
    		horigin: {
    			type: "float"
    		},
    		vieweraspect: {
    			type: "menu",
    			menuitems: [
    				"proportional",
    				"unconstrained"
    			]
    		},
    		sizefromwindow: {
    			type: "toggle"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		resizewmax: {
    			type: "float"
    		},
    		margint: {
    			type: "float"
    		},
    		extension3: {
    			type: "string"
    		},
    		overlay: {
    			type: "toggle"
    		},
    		repositionxmax: {
    			type: "float"
    		},
    		marginl: {
    			type: "float"
    		},
    		hfillweight: {
    			type: "float"
    		},
    		extname4: {
    			type: "string"
    		},
    		resizet: {
    			type: "toggle"
    		},
    		marginb: {
    			type: "float"
    		},
    		dropscript: {
    			type: "DAT"
    		},
    		lockfirstrow: {
    			type: "toggle"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		h: {
    			type: "number"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		display: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var sharedmemoutCOMP = {
    	maxInputs: 1,
    	pars: {
    		instancety: {
    			type: "string"
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		pxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		instancerottoz: {
    			type: "string"
    		},
    		instancemode: {
    			type: "menu",
    			menuitems: [
    				"manual",
    				"oplength"
    			]
    		},
    		instancetz: {
    			type: "string"
    		},
    		instancerottoorder: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"prerot",
    				"postrot"
    			]
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		instancetx: {
    			type: "string"
    		},
    		instancecolormode: {
    			type: "menu",
    			menuitems: [
    				"replace",
    				"multiply",
    				"add",
    				"subtract"
    			]
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		ps: {
    			type: "xyz"
    		},
    		instancerotupz: {
    			type: "string"
    		},
    		extension4: {
    			type: "string"
    		},
    		pr: {
    			type: "xyz"
    		},
    		numinstances: {
    			type: "number"
    		},
    		pathorient: {
    			type: "toggle"
    		},
    		pathsop: {
    			type: "SOP"
    		},
    		instancesz: {
    			type: "string"
    		},
    		pt: {
    			type: "xyz"
    		},
    		bank: {
    			type: "float"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		instancerz: {
    			type: "string"
    		},
    		instanceop: {
    			type: "OP"
    		},
    		instancetexextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		instancea: {
    			type: "string"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		pos: {
    			type: "float"
    		},
    		prord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		extension1: {
    			type: "string"
    		},
    		xformmatrixop: {
    			type: "OP"
    		},
    		wcolor: {
    			type: "rgb"
    		},
    		t: {
    			type: "xyz"
    		},
    		instancev: {
    			type: "string"
    		},
    		extname1: {
    			type: "string"
    		},
    		instancetexs: {
    			type: "TOP"
    		},
    		lightmask: {
    			type: "COMP"
    		},
    		preset: {
    			type: "pulse"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		instancetexextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		lookup: {
    			type: "string"
    		},
    		material: {
    			type: "MAT"
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		instancer: {
    			type: "string"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		render: {
    			type: "toggle"
    		},
    		instancery: {
    			type: "string"
    		},
    		prioritymethod: {
    			type: "menu",
    			menuitems: [
    				"custom",
    				"camdist"
    			]
    		},
    		instancetexindex: {
    			type: "string"
    		},
    		pcommit: {
    			type: "pulse"
    		},
    		instanceb: {
    			type: "string"
    		},
    		up: {
    			type: "xyz"
    		},
    		pscale: {
    		},
    		drawpriority: {
    			type: "float"
    		},
    		subcompname: {
    			type: "string"
    		},
    		instanceu: {
    			type: "string"
    		},
    		roll: {
    			type: "float"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		instrord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		instancerottoy: {
    			type: "string"
    		},
    		instancing: {
    			type: "toggle"
    		},
    		pickpriority: {
    			type: "float"
    		},
    		instancesy: {
    			type: "string"
    		},
    		instancepy: {
    			type: "string"
    		},
    		instancerotupy: {
    			type: "string"
    		},
    		extname4: {
    			type: "string"
    		},
    		instxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		externaltox: {
    			type: "string"
    		},
    		constrain: {
    			type: "COMP"
    		},
    		clone: {
    			type: "COMP"
    		},
    		pp: {
    			type: "xyz"
    		},
    		p: {
    			type: "xyz"
    		},
    		instancepz: {
    			type: "string"
    		},
    		r: {
    			type: "xyz"
    		},
    		instancetexfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		instancerottox: {
    			type: "string"
    		},
    		scale: {
    		},
    		instancerotupx: {
    			type: "string"
    		},
    		instancetexextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		pxform: {
    			type: "toggle"
    		},
    		instancew: {
    			type: "string"
    		},
    		extension2: {
    			type: "string"
    		},
    		instancetexmode: {
    			type: "menu",
    			menuitems: [
    				"replace",
    				"offset"
    			]
    		},
    		instanceg: {
    			type: "string"
    		},
    		instancerx: {
    			type: "string"
    		},
    		instancetexanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		instancesx: {
    			type: "string"
    		},
    		extname2: {
    			type: "string"
    		},
    		instanceorder: {
    			type: "menu",
    			menuitems: [
    				"instanceworld",
    				"worldinstance"
    			]
    		},
    		extname3: {
    			type: "string"
    		},
    		name: {
    			type: "string"
    		},
    		active: {
    			type: "toggle"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		s: {
    			type: "xyz"
    		},
    		lookat: {
    			type: "COMP"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		instancepx: {
    			type: "string"
    		},
    		instancefirstrow: {
    			type: "menu",
    			menuitems: [
    				"ignored",
    				"names",
    				"values"
    			]
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		extension3: {
    			type: "string"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "COMP"
    };
    var sharedmeminCOMP = {
    	maxInputs: 0,
    	pars: {
    		instancety: {
    			type: "string"
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		pxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		instancerottoz: {
    			type: "string"
    		},
    		instancemode: {
    			type: "menu",
    			menuitems: [
    				"manual",
    				"oplength"
    			]
    		},
    		instancetz: {
    			type: "string"
    		},
    		instancerottoorder: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"prerot",
    				"postrot"
    			]
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		instancetx: {
    			type: "string"
    		},
    		instancecolormode: {
    			type: "menu",
    			menuitems: [
    				"replace",
    				"multiply",
    				"add",
    				"subtract"
    			]
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		ps: {
    			type: "xyz"
    		},
    		instancerotupz: {
    			type: "string"
    		},
    		extension4: {
    			type: "string"
    		},
    		pr: {
    			type: "xyz"
    		},
    		numinstances: {
    			type: "number"
    		},
    		pathorient: {
    			type: "toggle"
    		},
    		pathsop: {
    			type: "SOP"
    		},
    		instancesz: {
    			type: "string"
    		},
    		pt: {
    			type: "xyz"
    		},
    		bank: {
    			type: "float"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		instancerz: {
    			type: "string"
    		},
    		instanceop: {
    			type: "OP"
    		},
    		instancetexextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		instancea: {
    			type: "string"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		pos: {
    			type: "float"
    		},
    		prord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		extension1: {
    			type: "string"
    		},
    		xformmatrixop: {
    			type: "OP"
    		},
    		wcolor: {
    			type: "rgb"
    		},
    		t: {
    			type: "xyz"
    		},
    		instancev: {
    			type: "string"
    		},
    		extname1: {
    			type: "string"
    		},
    		instancetexs: {
    			type: "TOP"
    		},
    		lightmask: {
    			type: "COMP"
    		},
    		preset: {
    			type: "pulse"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		instancetexextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		lookup: {
    			type: "string"
    		},
    		material: {
    			type: "MAT"
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		instancer: {
    			type: "string"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		render: {
    			type: "toggle"
    		},
    		instancery: {
    			type: "string"
    		},
    		prioritymethod: {
    			type: "menu",
    			menuitems: [
    				"custom",
    				"camdist"
    			]
    		},
    		instancetexindex: {
    			type: "string"
    		},
    		pcommit: {
    			type: "pulse"
    		},
    		instanceb: {
    			type: "string"
    		},
    		up: {
    			type: "xyz"
    		},
    		pscale: {
    		},
    		drawpriority: {
    			type: "float"
    		},
    		subcompname: {
    			type: "string"
    		},
    		instanceu: {
    			type: "string"
    		},
    		roll: {
    			type: "float"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		instrord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		instancerottoy: {
    			type: "string"
    		},
    		instancing: {
    			type: "toggle"
    		},
    		pickpriority: {
    			type: "float"
    		},
    		instancesy: {
    			type: "string"
    		},
    		instancepy: {
    			type: "string"
    		},
    		instancerotupy: {
    			type: "string"
    		},
    		extname4: {
    			type: "string"
    		},
    		instxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		externaltox: {
    			type: "string"
    		},
    		constrain: {
    			type: "COMP"
    		},
    		clone: {
    			type: "COMP"
    		},
    		pp: {
    			type: "xyz"
    		},
    		p: {
    			type: "xyz"
    		},
    		instancepz: {
    			type: "string"
    		},
    		r: {
    			type: "xyz"
    		},
    		instancetexfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		instancerottox: {
    			type: "string"
    		},
    		scale: {
    		},
    		instancerotupx: {
    			type: "string"
    		},
    		instancetexextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		pxform: {
    			type: "toggle"
    		},
    		instancew: {
    			type: "string"
    		},
    		extension2: {
    			type: "string"
    		},
    		instancetexmode: {
    			type: "menu",
    			menuitems: [
    				"replace",
    				"offset"
    			]
    		},
    		instanceg: {
    			type: "string"
    		},
    		instancerx: {
    			type: "string"
    		},
    		instancetexanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		instancesx: {
    			type: "string"
    		},
    		extname2: {
    			type: "string"
    		},
    		instanceorder: {
    			type: "menu",
    			menuitems: [
    				"instanceworld",
    				"worldinstance"
    			]
    		},
    		extname3: {
    			type: "string"
    		},
    		name: {
    			type: "string"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		s: {
    			type: "xyz"
    		},
    		lookat: {
    			type: "COMP"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		instancepx: {
    			type: "string"
    		},
    		instancefirstrow: {
    			type: "menu",
    			menuitems: [
    				"ignored",
    				"names",
    				"values"
    			]
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		extension3: {
    			type: "string"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var cameraCOMP = {
    	maxInputs: 1,
    	pars: {
    		pscale: {
    		},
    		drawpriority: {
    			type: "float"
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		fogmap: {
    			type: "TOP"
    		},
    		pxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		subcompname: {
    			type: "string"
    		},
    		p: {
    			type: "xyz"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		fogdensity: {
    			type: "float"
    		},
    		focal: {
    			type: "float"
    		},
    		aperture: {
    			type: "float"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		projectionblend: {
    			type: "float"
    		},
    		extname4: {
    			type: "string"
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		far: {
    			type: "float"
    		},
    		bgcolor: {
    			type: "rgba"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		pp: {
    			type: "xyz"
    		},
    		extname2: {
    			type: "string"
    		},
    		extension4: {
    			type: "string"
    		},
    		pr: {
    			type: "xyz"
    		},
    		ipdshift: {
    		},
    		pathorient: {
    			type: "toggle"
    		},
    		pathsop: {
    			type: "SOP"
    		},
    		externaltox: {
    			type: "string"
    		},
    		viewanglemethod: {
    			type: "menu",
    			menuitems: [
    				"horzfov",
    				"vertfov",
    				"focalaperture"
    			]
    		},
    		constrain: {
    			type: "COMP"
    		},
    		clone: {
    			type: "COMP"
    		},
    		orthowidth: {
    			type: "float"
    		},
    		ps: {
    			type: "xyz"
    		},
    		pt: {
    			type: "xyz"
    		},
    		fognear: {
    			type: "float"
    		},
    		near: {
    			type: "float"
    		},
    		bank: {
    			type: "float"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		winsize: {
    		},
    		scale: {
    		},
    		fogalpha: {
    			type: "float"
    		},
    		extension2: {
    			type: "string"
    		},
    		pxform: {
    			type: "toggle"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		pos: {
    			type: "float"
    		},
    		prord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		r: {
    			type: "xyz"
    		},
    		xformmatrixop: {
    			type: "OP"
    		},
    		extension1: {
    			type: "string"
    		},
    		wcolor: {
    			type: "rgb"
    		},
    		t: {
    			type: "xyz"
    		},
    		camlightmask: {
    			type: "COMP"
    		},
    		material: {
    			type: "MAT"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		},
    		extname1: {
    			type: "string"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		winroll: {
    		},
    		preset: {
    			type: "pulse"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		pickpriority: {
    			type: "float"
    		},
    		customproj: {
    			type: "DAT"
    		},
    		extname3: {
    			type: "string"
    		},
    		projmatrixop: {
    			type: "OP"
    		},
    		lookup: {
    			type: "string"
    		},
    		roll: {
    			type: "float"
    		},
    		fog: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"linear",
    				"exp",
    				"exp2"
    			]
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		s: {
    			type: "xyz"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		lookat: {
    			type: "COMP"
    		},
    		fogcolor: {
    			type: "rgb"
    		},
    		render: {
    			type: "toggle"
    		},
    		fov: {
    			type: "float"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		prioritymethod: {
    			type: "menu",
    			menuitems: [
    				"custom",
    				"camdist"
    			]
    		},
    		win: {
    			type: "xy"
    		},
    		pcommit: {
    			type: "pulse"
    		},
    		fogfar: {
    			type: "float"
    		},
    		projection: {
    			type: "menu",
    			menuitems: [
    				"perspective",
    				"ortho",
    				"persporthoblend",
    				"custommatrix"
    			]
    		},
    		extension3: {
    			type: "string"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		up: {
    			type: "xyz"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var windowCOMP = {
    	maxInputs: 0,
    	pars: {
    		setperform: {
    			type: "pulse"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		subcompname: {
    			type: "string"
    		},
    		size: {
    			type: "menu",
    			menuitems: [
    				"automatic",
    				"fill",
    				"custom"
    			]
    		},
    		openglstereo: {
    			type: "toggle"
    		},
    		monitor: {
    			type: "number"
    		},
    		externaltox: {
    			type: "string"
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"left",
    				"center",
    				"right",
    				"mouse"
    			]
    		},
    		alwaysontop: {
    			type: "toggle"
    		},
    		winoffsetx: {
    			type: "number"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		winopen: {
    			type: "pulse"
    		},
    		extension4: {
    			type: "string"
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"top",
    				"center",
    				"bottom",
    				"mouse"
    			]
    		},
    		drawwindow: {
    			type: "toggle"
    		},
    		performance: {
    			type: "pulse"
    		},
    		winclose: {
    			type: "pulse"
    		},
    		bordersinsize: {
    			type: "toggle"
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		clone: {
    			type: "COMP"
    		},
    		winoffsety: {
    			type: "number"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		extension1: {
    			type: "string"
    		},
    		ignoretaskbar: {
    			type: "toggle"
    		},
    		update: {
    			type: "pulse"
    		},
    		hwframelock: {
    			type: "toggle"
    		},
    		single: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"singlemonitor",
    				"cursormonitor"
    			]
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		borders: {
    			type: "toggle"
    		},
    		extname4: {
    			type: "string"
    		},
    		extension2: {
    			type: "string"
    		},
    		extname1: {
    			type: "string"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		extname2: {
    			type: "string"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		winrightop: {
    			type: "OP"
    		},
    		extname3: {
    			type: "string"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		justifyoffsetto: {
    			type: "menu",
    			menuitems: [
    				"primarymonitor",
    				"specifymonitor",
    				"allmonitors"
    			]
    		},
    		interact: {
    			type: "toggle"
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		winw: {
    			type: "number"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		includedialog: {
    			type: "toggle"
    		},
    		opendialog: {
    			type: "pulse"
    		},
    		winh: {
    			type: "number"
    		},
    		closeescape: {
    			type: "toggle"
    		},
    		winop: {
    			type: "OP"
    		},
    		vsyncmode: {
    			type: "menu",
    			menuitems: [
    				"disabled",
    				"enabled",
    				"halfmonitorrate"
    			]
    		},
    		dpiscaling: {
    			type: "menu",
    			menuitems: [
    				"native",
    				"usedpiscale"
    			]
    		},
    		title: {
    			type: "string"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		extension3: {
    			type: "string"
    		},
    		cursorvisible: {
    			type: "menu",
    			menuitems: [
    				"nocursor",
    				"cursoronmove",
    				"alwaysvisible"
    			]
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var environmentlightCOMP = {
    	maxInputs: 1,
    	pars: {
    		loadondemand: {
    			type: "toggle"
    		},
    		pxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		material: {
    			type: "MAT"
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		bgcolor: {
    			type: "rgba"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		ps: {
    			type: "xyz"
    		},
    		extension4: {
    			type: "string"
    		},
    		pr: {
    			type: "xyz"
    		},
    		pathorient: {
    			type: "toggle"
    		},
    		pathsop: {
    			type: "SOP"
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		orthowidth: {
    			type: "float"
    		},
    		pt: {
    			type: "xyz"
    		},
    		fognear: {
    			type: "float"
    		},
    		bank: {
    			type: "float"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		pos: {
    			type: "float"
    		},
    		prord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		extension1: {
    			type: "string"
    		},
    		xformmatrixop: {
    			type: "OP"
    		},
    		envlightmaptype2d: {
    			type: "menu",
    			menuitems: [
    				"equirect"
    			]
    		},
    		t: {
    			type: "xyz"
    		},
    		winsize: {
    		},
    		extname1: {
    			type: "string"
    		},
    		winroll: {
    		},
    		envlightmaprotate: {
    			type: "xyz"
    		},
    		preset: {
    			type: "pulse"
    		},
    		envlightdiffusemap: {
    			type: "TOP"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		projmatrixop: {
    			type: "OP"
    		},
    		lookup: {
    			type: "string"
    		},
    		aperture: {
    			type: "float"
    		},
    		fog: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"linear",
    				"exp",
    				"exp2"
    			]
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		envlightmap: {
    			type: "TOP"
    		},
    		fogcolor: {
    			type: "rgb"
    		},
    		render: {
    			type: "toggle"
    		},
    		fov: {
    			type: "float"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		prioritymethod: {
    			type: "menu",
    			menuitems: [
    				"custom",
    				"camdist"
    			]
    		},
    		pcommit: {
    			type: "pulse"
    		},
    		fogfar: {
    			type: "float"
    		},
    		projection: {
    			type: "menu",
    			menuitems: [
    				"perspective",
    				"ortho",
    				"persporthoblend",
    				"custommatrix"
    			]
    		},
    		up: {
    			type: "xyz"
    		},
    		pscale: {
    		},
    		drawpriority: {
    			type: "float"
    		},
    		fogmap: {
    			type: "TOP"
    		},
    		subcompname: {
    			type: "string"
    		},
    		c: {
    			type: "rgb"
    		},
    		fogdensity: {
    			type: "float"
    		},
    		focal: {
    			type: "float"
    		},
    		roll: {
    			type: "float"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		projectionblend: {
    			type: "float"
    		},
    		far: {
    			type: "float"
    		},
    		envlightmapquality: {
    			type: "float"
    		},
    		pickpriority: {
    			type: "float"
    		},
    		dimmer: {
    			type: "float"
    		},
    		extname4: {
    			type: "string"
    		},
    		ipdshift: {
    		},
    		externaltox: {
    			type: "string"
    		},
    		viewanglemethod: {
    			type: "menu",
    			menuitems: [
    				"horzfov",
    				"vertfov",
    				"focalaperture"
    			]
    		},
    		constrain: {
    			type: "COMP"
    		},
    		clone: {
    			type: "COMP"
    		},
    		envlightspecmap: {
    			type: "TOP"
    		},
    		p: {
    			type: "xyz"
    		},
    		near: {
    			type: "float"
    		},
    		r: {
    			type: "xyz"
    		},
    		wcolor: {
    			type: "rgb"
    		},
    		scale: {
    		},
    		camlightmask: {
    			type: "COMP"
    		},
    		pxform: {
    			type: "toggle"
    		},
    		extension2: {
    			type: "string"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		extname2: {
    			type: "string"
    		},
    		envlightmapprefilter: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"automatic",
    				"useprefiltertop"
    			]
    		},
    		customproj: {
    			type: "DAT"
    		},
    		extname3: {
    			type: "string"
    		},
    		fogalpha: {
    			type: "float"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		s: {
    			type: "xyz"
    		},
    		lookat: {
    			type: "COMP"
    		},
    		win: {
    			type: "xy"
    		},
    		pp: {
    			type: "xyz"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		extension3: {
    			type: "string"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var nullCOMP = {
    	maxInputs: 1,
    	pars: {
    		instancety: {
    			type: "string"
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		pxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		instancerottoz: {
    			type: "string"
    		},
    		instancemode: {
    			type: "menu",
    			menuitems: [
    				"manual",
    				"oplength"
    			]
    		},
    		instancetz: {
    			type: "string"
    		},
    		material: {
    			type: "MAT"
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		instancetx: {
    			type: "string"
    		},
    		instancecolormode: {
    			type: "menu",
    			menuitems: [
    				"replace",
    				"multiply",
    				"add",
    				"subtract"
    			]
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		instxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		instancerotupz: {
    			type: "string"
    		},
    		extension4: {
    			type: "string"
    		},
    		pr: {
    			type: "xyz"
    		},
    		numinstances: {
    			type: "number"
    		},
    		pathorient: {
    			type: "toggle"
    		},
    		pathsop: {
    			type: "SOP"
    		},
    		instancesz: {
    			type: "string"
    		},
    		pt: {
    			type: "xyz"
    		},
    		bank: {
    			type: "float"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		instancerz: {
    			type: "string"
    		},
    		instanceop: {
    			type: "OP"
    		},
    		instancetexextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		instancea: {
    			type: "string"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		prord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		extension1: {
    			type: "string"
    		},
    		xformmatrixop: {
    			type: "OP"
    		},
    		wcolor: {
    			type: "rgb"
    		},
    		t: {
    			type: "xyz"
    		},
    		instancev: {
    			type: "string"
    		},
    		extname1: {
    			type: "string"
    		},
    		instancetexs: {
    			type: "TOP"
    		},
    		lightmask: {
    			type: "COMP"
    		},
    		preset: {
    			type: "pulse"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		instancetexextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		lookup: {
    			type: "string"
    		},
    		instancerottoorder: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"prerot",
    				"postrot"
    			]
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		instancer: {
    			type: "string"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		render: {
    			type: "toggle"
    		},
    		instancery: {
    			type: "string"
    		},
    		prioritymethod: {
    			type: "menu",
    			menuitems: [
    				"custom",
    				"camdist"
    			]
    		},
    		instancetexindex: {
    			type: "string"
    		},
    		pcommit: {
    			type: "pulse"
    		},
    		instanceb: {
    			type: "string"
    		},
    		up: {
    			type: "xyz"
    		},
    		pscale: {
    		},
    		drawpriority: {
    			type: "float"
    		},
    		subcompname: {
    			type: "string"
    		},
    		instanceu: {
    			type: "string"
    		},
    		roll: {
    			type: "float"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		pos: {
    			type: "float"
    		},
    		instrord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		instancerottoy: {
    			type: "string"
    		},
    		instancing: {
    			type: "toggle"
    		},
    		pickpriority: {
    			type: "float"
    		},
    		instancesy: {
    			type: "string"
    		},
    		instancepy: {
    			type: "string"
    		},
    		instancerotupy: {
    			type: "string"
    		},
    		extname4: {
    			type: "string"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		externaltox: {
    			type: "string"
    		},
    		constrain: {
    			type: "COMP"
    		},
    		clone: {
    			type: "COMP"
    		},
    		ps: {
    			type: "xyz"
    		},
    		p: {
    			type: "xyz"
    		},
    		instancepz: {
    			type: "string"
    		},
    		r: {
    			type: "xyz"
    		},
    		instancetexfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		instancerottox: {
    			type: "string"
    		},
    		scale: {
    		},
    		instancerotupx: {
    			type: "string"
    		},
    		instancetexextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		pxform: {
    			type: "toggle"
    		},
    		instancew: {
    			type: "string"
    		},
    		extension2: {
    			type: "string"
    		},
    		instancetexmode: {
    			type: "menu",
    			menuitems: [
    				"replace",
    				"offset"
    			]
    		},
    		instanceg: {
    			type: "string"
    		},
    		instancerx: {
    			type: "string"
    		},
    		instancetexanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		instancesx: {
    			type: "string"
    		},
    		extname2: {
    			type: "string"
    		},
    		instanceorder: {
    			type: "menu",
    			menuitems: [
    				"instanceworld",
    				"worldinstance"
    			]
    		},
    		extname3: {
    			type: "string"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		s: {
    			type: "xyz"
    		},
    		lookat: {
    			type: "COMP"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		instancepx: {
    			type: "string"
    		},
    		instancefirstrow: {
    			type: "menu",
    			menuitems: [
    				"ignored",
    				"names",
    				"values"
    			]
    		},
    		pp: {
    			type: "xyz"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		extension3: {
    			type: "string"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var lightCOMP = {
    	maxInputs: 1,
    	pars: {
    		attenuated: {
    			type: "toggle"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		pxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		wcolor: {
    			type: "rgb"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		aspectcorrect: {
    			type: "toggle"
    		},
    		aperture: {
    			type: "float"
    		},
    		lightsize1: {
    			type: "float"
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		bgcolor: {
    			type: "rgba"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		ps: {
    			type: "xyz"
    		},
    		attenuationend: {
    			type: "float"
    		},
    		extension4: {
    			type: "string"
    		},
    		pr: {
    			type: "xyz"
    		},
    		projmapmode: {
    			type: "menu",
    			menuitems: [
    				"simplehorzfov",
    				"useview"
    			]
    		},
    		pathorient: {
    			type: "toggle"
    		},
    		shadowresolution2: {
    			type: "number"
    		},
    		pathsop: {
    			type: "SOP"
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		orthowidth: {
    			type: "float"
    		},
    		pt: {
    			type: "xyz"
    		},
    		projmapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		fognear: {
    			type: "float"
    		},
    		bank: {
    			type: "float"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		shadowresolution1: {
    			type: "number"
    		},
    		filtersamples: {
    			type: "number"
    		},
    		coneangle: {
    			type: "float"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		attenuationstart: {
    			type: "float"
    		},
    		coneroll: {
    			type: "float"
    		},
    		extension1: {
    			type: "string"
    		},
    		xbounds2: {
    			type: "float"
    		},
    		conedelta: {
    			type: "float"
    		},
    		t: {
    			type: "xyz"
    		},
    		winsize: {
    		},
    		projangle: {
    			type: "float"
    		},
    		extname1: {
    			type: "string"
    		},
    		maxshadowsoftness: {
    			type: "float"
    		},
    		winroll: {
    		},
    		polygonoffsetunits: {
    			type: "float"
    		},
    		preset: {
    			type: "pulse"
    		},
    		polygonoffsetfactor: {
    			type: "float"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		scale: {
    		},
    		projmatrixop: {
    			type: "OP"
    		},
    		lookup: {
    			type: "string"
    		},
    		material: {
    			type: "MAT"
    		},
    		fog: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"linear",
    				"exp",
    				"exp2"
    			]
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		frontfacelit: {
    			type: "menu",
    			menuitems: [
    				"frontlit",
    				"backlit"
    			]
    		},
    		projmap: {
    			type: "TOP"
    		},
    		render: {
    			type: "toggle"
    		},
    		fov: {
    			type: "float"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		prioritymethod: {
    			type: "menu",
    			menuitems: [
    				"custom",
    				"camdist"
    			]
    		},
    		projectionblend: {
    			type: "float"
    		},
    		pcommit: {
    			type: "pulse"
    		},
    		attenuationexp: {
    			type: "float"
    		},
    		fogfar: {
    			type: "float"
    		},
    		projection: {
    			type: "menu",
    			menuitems: [
    				"perspective",
    				"ortho",
    				"shadowproj",
    				"custommatrix"
    			]
    		},
    		shadowmap: {
    			type: "TOP"
    		},
    		ybounds2: {
    			type: "float"
    		},
    		pscale: {
    		},
    		drawpriority: {
    			type: "float"
    		},
    		fogmap: {
    			type: "TOP"
    		},
    		subcompname: {
    			type: "string"
    		},
    		c: {
    			type: "rgb"
    		},
    		fogdensity: {
    			type: "float"
    		},
    		focal: {
    			type: "float"
    		},
    		fogcolor: {
    			type: "rgb"
    		},
    		roll: {
    			type: "float"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		lighttype: {
    			type: "menu",
    			menuitems: [
    				"point",
    				"cone",
    				"distant"
    			]
    		},
    		pos: {
    			type: "float"
    		},
    		shadowtype: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"hard2d",
    				"soft2d",
    				"custom"
    			]
    		},
    		ybounds1: {
    			type: "float"
    		},
    		far: {
    			type: "float"
    		},
    		prord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		pickpriority: {
    			type: "float"
    		},
    		dimmer: {
    			type: "float"
    		},
    		extname4: {
    			type: "string"
    		},
    		ipdshift: {
    		},
    		xformmatrixop: {
    			type: "OP"
    		},
    		externaltox: {
    			type: "string"
    		},
    		viewanglemethod: {
    			type: "menu",
    			menuitems: [
    				"horzfov",
    				"vertfov",
    				"focalaperture"
    			]
    		},
    		constrain: {
    			type: "COMP"
    		},
    		clone: {
    			type: "COMP"
    		},
    		pp: {
    			type: "xyz"
    		},
    		p: {
    			type: "xyz"
    		},
    		win: {
    			type: "xy"
    		},
    		near: {
    			type: "float"
    		},
    		r: {
    			type: "xyz"
    		},
    		searchsteps: {
    			type: "number"
    		},
    		zbounds2: {
    			type: "float"
    		},
    		projmapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		camlightmask: {
    			type: "COMP"
    		},
    		shadowcasters: {
    			type: "OP"
    		},
    		pxform: {
    			type: "toggle"
    		},
    		lightsize2: {
    			type: "float"
    		},
    		xbounds1: {
    			type: "float"
    		},
    		extension2: {
    			type: "string"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		projmapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		backfacelit: {
    			type: "menu",
    			menuitems: [
    				"frontlit",
    				"backlit"
    			]
    		},
    		customproj: {
    			type: "DAT"
    		},
    		extname3: {
    			type: "string"
    		},
    		fogalpha: {
    			type: "float"
    		},
    		zbounds1: {
    			type: "float"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		s: {
    			type: "xyz"
    		},
    		lookat: {
    			type: "COMP"
    		},
    		projmapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		scenecamera: {
    			type: "COMP"
    		},
    		extname2: {
    			type: "string"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		projmapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		up: {
    			type: "xyz"
    		},
    		extension3: {
    			type: "string"
    		},
    		useconeforfov: {
    			type: "toggle"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var replicatorCOMP = {
    	maxInputs: 0,
    	pars: {
    		tscript: {
    			type: "string"
    		},
    		domaxops: {
    			type: "toggle"
    		},
    		subcompname: {
    			type: "string"
    		},
    		repsuffixstart: {
    			type: "number"
    		},
    		layoutorigin2: {
    			type: "number"
    		},
    		maxops: {
    			type: "number"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		colname: {
    			type: "string"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		numreplicants: {
    			type: "number"
    		},
    		template: {
    			type: "DAT"
    		},
    		opprefix: {
    			type: "string"
    		},
    		extension4: {
    			type: "string"
    		},
    		scriptmenu: {
    			type: "menu",
    			menuitems: [
    				"s1",
    				"s2",
    				"s3"
    			]
    		},
    		extname4: {
    			type: "string"
    		},
    		destination: {
    			type: "COMP"
    		},
    		externaltox: {
    			type: "string"
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		clone: {
    			type: "COMP"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		extension1: {
    			type: "string"
    		},
    		namefromtable: {
    			type: "menu",
    			menuitems: [
    				"rowindex",
    				"colbyindex",
    				"colbyname"
    			]
    		},
    		layout: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"grid"
    			]
    		},
    		recreateall: {
    			type: "pulse"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		increment: {
    			type: "number"
    		},
    		extension2: {
    			type: "string"
    		},
    		extname1: {
    			type: "string"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		extname2: {
    			type: "string"
    		},
    		layoutorigin1: {
    			type: "number"
    		},
    		recreatemissing: {
    			type: "pulse"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		master: {
    			type: "OP"
    		},
    		extname3: {
    			type: "string"
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		ignorefirstrow: {
    			type: "toggle"
    		},
    		doincremental: {
    			type: "toggle"
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"bynum",
    				"bytable"
    			]
    		},
    		colindex: {
    			type: "number"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		extension3: {
    			type: "string"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var timeCOMP = {
    	maxInputs: 0,
    	pars: {
    		reinitextensions: {
    			type: "pulse"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		rangestart: {
    			type: "number"
    		},
    		signature2: {
    			type: "number"
    		},
    		subcompname: {
    			type: "string"
    		},
    		extension2: {
    			type: "string"
    		},
    		extname1: {
    			type: "string"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		extname2: {
    			type: "string"
    		},
    		signature1: {
    			type: "number"
    		},
    		end: {
    			type: "number"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		extname3: {
    			type: "string"
    		},
    		extension4: {
    			type: "string"
    		},
    		extname4: {
    			type: "string"
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		rangelimit: {
    			type: "menu",
    			menuitems: [
    				"loop",
    				"hold"
    			]
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		rangeend: {
    			type: "number"
    		},
    		externaltox: {
    			type: "string"
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		resetframe: {
    			type: "number"
    		},
    		clone: {
    			type: "COMP"
    		},
    		independent: {
    			type: "toggle"
    		},
    		play: {
    			type: "number"
    		},
    		extension1: {
    			type: "string"
    		},
    		rate: {
    			type: "float"
    		},
    		tempo: {
    			type: "float"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		start: {
    			type: "number"
    		},
    		extension3: {
    			type: "string"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var boneCOMP = {
    	maxInputs: 1,
    	pars: {
    		instancety: {
    			type: "string"
    		},
    		instancesz: {
    			type: "string"
    		},
    		endxrange: {
    			type: "float"
    		},
    		pxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		instancerottoz: {
    			type: "string"
    		},
    		instancemode: {
    			type: "menu",
    			menuitems: [
    				"manual",
    				"oplength"
    			]
    		},
    		instancetz: {
    			type: "string"
    		},
    		material: {
    			type: "MAT"
    		},
    		endyrange: {
    			type: "float"
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		instancetx: {
    			type: "string"
    		},
    		instancecolormode: {
    			type: "menu",
    			menuitems: [
    				"replace",
    				"multiply",
    				"add",
    				"subtract"
    			]
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		ps: {
    			type: "xyz"
    		},
    		instancerotupz: {
    			type: "string"
    		},
    		extension4: {
    			type: "string"
    		},
    		pr: {
    			type: "xyz"
    		},
    		numinstances: {
    			type: "number"
    		},
    		pathorient: {
    			type: "toggle"
    		},
    		pathsop: {
    			type: "SOP"
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		pt: {
    			type: "xyz"
    		},
    		bank: {
    			type: "float"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		crtopheight: {
    			type: "float"
    		},
    		instancerz: {
    			type: "string"
    		},
    		instanceop: {
    			type: "OP"
    		},
    		instancetexextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		instancea: {
    			type: "string"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		prord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		extension1: {
    			type: "string"
    		},
    		xformmatrixop: {
    			type: "OP"
    		},
    		wcolor: {
    			type: "rgb"
    		},
    		t: {
    			type: "xyz"
    		},
    		instanceu: {
    			type: "string"
    		},
    		extname1: {
    			type: "string"
    		},
    		instancetexs: {
    			type: "TOP"
    		},
    		lightmask: {
    			type: "COMP"
    		},
    		preset: {
    			type: "pulse"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		instancetexextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		lookup: {
    			type: "string"
    		},
    		instancerottoorder: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"prerot",
    				"postrot"
    			]
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		instancer: {
    			type: "string"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		instancerotupx: {
    			type: "string"
    		},
    		displaycapture: {
    			type: "toggle"
    		},
    		render: {
    			type: "toggle"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		prioritymethod: {
    			type: "menu",
    			menuitems: [
    				"custom",
    				"camdist"
    			]
    		},
    		instancetexindex: {
    			type: "string"
    		},
    		pcommit: {
    			type: "pulse"
    		},
    		instanceb: {
    			type: "string"
    		},
    		up: {
    			type: "xyz"
    		},
    		pscale: {
    		},
    		drawpriority: {
    			type: "float"
    		},
    		length: {
    			type: "float"
    		},
    		subcompname: {
    			type: "string"
    		},
    		restangles: {
    			type: "xyz"
    		},
    		yrolloff: {
    			type: "float"
    		},
    		displaylink: {
    			type: "toggle"
    		},
    		roll: {
    			type: "float"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		pos: {
    			type: "float"
    		},
    		instrord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		instancerottoy: {
    			type: "string"
    		},
    		instancing: {
    			type: "toggle"
    		},
    		pickpriority: {
    			type: "float"
    		},
    		xrolloff: {
    			type: "float"
    		},
    		instancepy: {
    			type: "string"
    		},
    		ydamp: {
    			type: "float"
    		},
    		extname4: {
    			type: "string"
    		},
    		instxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		instancery: {
    			type: "string"
    		},
    		externaltox: {
    			type: "string"
    		},
    		constrain: {
    			type: "COMP"
    		},
    		clone: {
    			type: "COMP"
    		},
    		pp: {
    			type: "xyz"
    		},
    		p: {
    			type: "xyz"
    		},
    		instancepz: {
    			type: "string"
    		},
    		r: {
    			type: "xyz"
    		},
    		instancetexfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		instancerottox: {
    			type: "string"
    		},
    		scale: {
    		},
    		crbotcap: {
    			type: "xyz"
    		},
    		instancetexextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		pxform: {
    			type: "toggle"
    		},
    		instancerotupy: {
    			type: "string"
    		},
    		instancew: {
    			type: "string"
    		},
    		extension2: {
    			type: "string"
    		},
    		instancetexmode: {
    			type: "menu",
    			menuitems: [
    				"replace",
    				"offset"
    			]
    		},
    		instanceg: {
    			type: "string"
    		},
    		instancerx: {
    			type: "string"
    		},
    		instancetexanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		ikdamp: {
    			type: "float"
    		},
    		instancesy: {
    			type: "string"
    		},
    		instancev: {
    			type: "string"
    		},
    		xdamp: {
    			type: "float"
    		},
    		extname3: {
    			type: "string"
    		},
    		instanceorder: {
    			type: "menu",
    			menuitems: [
    				"instanceworld",
    				"worldinstance"
    			]
    		},
    		opshortcut: {
    			type: "string"
    		},
    		s: {
    			type: "xyz"
    		},
    		beginyrange: {
    			type: "float"
    		},
    		crtopcap: {
    			type: "xyz"
    		},
    		lookat: {
    			type: "COMP"
    		},
    		instancesx: {
    			type: "string"
    		},
    		instancepx: {
    			type: "string"
    		},
    		extname2: {
    			type: "string"
    		},
    		instancefirstrow: {
    			type: "menu",
    			menuitems: [
    				"ignored",
    				"names",
    				"values"
    			]
    		},
    		crcenter: {
    			type: "xyz"
    		},
    		beginxrange: {
    			type: "float"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		extension3: {
    			type: "string"
    		},
    		crbotheight: {
    			type: "float"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var animationCOMP = {
    	maxInputs: 0,
    	pars: {
    		loadondemand: {
    			type: "toggle"
    		},
    		speed: {
    			type: "float"
    		},
    		subcompname: {
    			type: "string"
    		},
    		rangetype: {
    			type: "menu",
    			menuitems: [
    				"timeline",
    				"custom"
    			]
    		},
    		editorigin: {
    			type: "float"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		tleft: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		specifyedit: {
    			type: "toggle"
    		},
    		extension4: {
    			type: "string"
    		},
    		extname4: {
    			type: "string"
    		},
    		tright: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		externaltox: {
    			type: "string"
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		clone: {
    			type: "COMP"
    		},
    		cyclic: {
    			type: "menu",
    			menuitems: [
    				"auto",
    				"yes",
    				"no"
    			]
    		},
    		startunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		extension1: {
    			type: "string"
    		},
    		tdefault: {
    			type: "float"
    		},
    		inputindexunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction",
    				"xunits"
    			]
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		endunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		extension2: {
    			type: "string"
    		},
    		cuepoint: {
    			type: "float"
    		},
    		extname1: {
    			type: "string"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		extname2: {
    			type: "string"
    		},
    		end: {
    			type: "float"
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		timeref: {
    			type: "OP"
    		},
    		extname3: {
    			type: "string"
    		},
    		playmode: {
    			type: "menu",
    			menuitems: [
    				"locked",
    				"input",
    				"sequential",
    				"outputrange"
    			]
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		cuepulse: {
    			type: "pulse"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		start: {
    			type: "float"
    		},
    		editanimation: {
    			type: "pulse"
    		},
    		editrate: {
    			type: "float"
    		},
    		play: {
    			type: "toggle"
    		},
    		cuepointunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction",
    				"xunits"
    			]
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		extension3: {
    			type: "string"
    		},
    		cue: {
    			type: "toggle"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var selectCOMP = {
    	maxInputs: 1,
    	pars: {
    		resizer: {
    			type: "toggle"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		top: {
    			type: "TOP"
    		},
    		offset: {
    			type: "xy"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		resizel: {
    			type: "toggle"
    		},
    		topoffset: {
    			type: "float"
    		},
    		mouserel: {
    			type: "toggle"
    		},
    		topanchor: {
    			type: "float"
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		spacing: {
    			type: "float"
    		},
    		bgcolor: {
    			type: "rgb"
    		},
    		repositionxmin: {
    			type: "float"
    		},
    		bottomanchor: {
    			type: "float"
    		},
    		paneldragop: {
    			type: "OP"
    		},
    		uvbuttonsmiddle: {
    			type: "toggle"
    		},
    		leftborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		opacity: {
    			type: "float"
    		},
    		w: {
    			type: "number"
    		},
    		chop: {
    			type: "CHOP"
    		},
    		rightoffset: {
    			type: "float"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		multitouch: {
    			type: "menu",
    			menuitems: [
    				"mtouchparent",
    				"mtouchyes",
    				"mtouchno"
    			]
    		},
    		hmode: {
    			type: "menu",
    			menuitems: [
    				"fixed",
    				"fill",
    				"anchors"
    			]
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		mousewheel: {
    			type: "toggle"
    		},
    		bgalpha: {
    			type: "float"
    		},
    		alignallow: {
    			type: "menu",
    			menuitems: [
    				"allow",
    				"ignore",
    				"ignoremargin"
    			]
    		},
    		bordera: {
    			type: "rgb"
    		},
    		clickthrough: {
    			type: "toggle"
    		},
    		dropdestscript: {
    			type: "DAT"
    		},
    		multrgb: {
    			type: "toggle"
    		},
    		disablecolor: {
    			type: "rgb"
    		},
    		leftborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		marginr: {
    			type: "float"
    		},
    		crop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"never"
    			]
    		},
    		uvbuttonsleft: {
    			type: "toggle"
    		},
    		vfillweight: {
    			type: "float"
    		},
    		bottomborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		postoffset: {
    			type: "xy"
    		},
    		horigin: {
    			type: "float"
    		},
    		topborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		borderbalpha: {
    			type: "float"
    		},
    		bottomoffset: {
    			type: "float"
    		},
    		layer: {
    			type: "float"
    		},
    		extension4: {
    			type: "string"
    		},
    		extname1: {
    			type: "string"
    		},
    		dragdropcallbacks: {
    			type: "DAT"
    		},
    		pvscrollbar: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		drag: {
    			type: "menu",
    			menuitems: [
    				"dragparent",
    				"legacy",
    				"dragno",
    				"usecallbacks"
    			]
    		},
    		rightborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		scale: {
    			type: "xy"
    		},
    		fit: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"best"
    			]
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		dragscript: {
    			type: "DAT"
    		},
    		fixedaspect: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical"
    			]
    		},
    		resizewmin: {
    			type: "float"
    		},
    		borderover: {
    			type: "toggle"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"top",
    				"center",
    				"bottom"
    			]
    		},
    		disablealpha: {
    			type: "float"
    		},
    		alignmax: {
    			type: "number"
    		},
    		anchordrag: {
    			type: "menu",
    			menuitems: [
    				"anchors",
    				"offsets"
    			]
    		},
    		scrolloverlay: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"ignore",
    				"ignoreover"
    			]
    		},
    		vmode: {
    			type: "menu",
    			menuitems: [
    				"fixed",
    				"fill",
    				"anchors"
    			]
    		},
    		rightanchor: {
    			type: "float"
    		},
    		align: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"horizlr",
    				"horizrl",
    				"verttb",
    				"vertbt",
    				"gridrows",
    				"gridcols",
    				"nodes"
    			]
    		},
    		vorigin: {
    			type: "float"
    		},
    		enable: {
    			type: "toggle"
    		},
    		namedchop: {
    			type: "toggle"
    		},
    		subcompname: {
    			type: "string"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		reposition: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"window",
    				"component"
    			]
    		},
    		bottomborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		matchsize: {
    			type: "toggle"
    		},
    		leftoffset: {
    			type: "float"
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"left",
    				"center",
    				"right"
    			]
    		},
    		resizehmax: {
    			type: "float"
    		},
    		aspect: {
    			type: "float"
    		},
    		cursor: {
    			type: "menu",
    			menuitems: [
    				"pointer",
    				"linkselect",
    				"ibeam",
    				"cross",
    				"busy",
    				"activate",
    				"invisible"
    			]
    		},
    		repocomp: {
    			type: "PanelCOMP"
    		},
    		overlay: {
    			type: "toggle"
    		},
    		topborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		composite: {
    			type: "menu",
    			menuitems: [
    				"over",
    				"under",
    				"inside",
    				"outside",
    				"add",
    				"subtract",
    				"multiply"
    			]
    		},
    		phscrollbar: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		externaltox: {
    			type: "string"
    		},
    		scrollbarthickness: {
    			type: "number"
    		},
    		clone: {
    			type: "COMP"
    		},
    		extension1: {
    			type: "string"
    		},
    		y: {
    			type: "number"
    		},
    		resizeb: {
    			type: "toggle"
    		},
    		resizehmin: {
    			type: "float"
    		},
    		topfill: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"best",
    				"native"
    			]
    		},
    		drop: {
    			type: "menu",
    			menuitems: [
    				"dropparent",
    				"legacy",
    				"dropno",
    				"usecallbacks"
    			]
    		},
    		extension2: {
    			type: "string"
    		},
    		rightborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		followselection: {
    			type: "toggle"
    		},
    		repositionymin: {
    			type: "float"
    		},
    		borderaalpha: {
    			type: "float"
    		},
    		extname4: {
    			type: "string"
    		},
    		leftanchor: {
    			type: "float"
    		},
    		repositionymax: {
    			type: "float"
    		},
    		dodisablecolor: {
    			type: "toggle"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		},
    		droptypescript: {
    			type: "DAT"
    		},
    		alignorder: {
    			type: "float"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		selectpanel: {
    			type: "PanelCOMP"
    		},
    		uvbuttonsright: {
    			type: "toggle"
    		},
    		x: {
    			type: "number"
    		},
    		extname3: {
    			type: "string"
    		},
    		overridemethod: {
    			type: "menu",
    			menuitems: [
    				"trigger",
    				"always"
    			]
    		},
    		helpdat: {
    			type: "DAT"
    		},
    		borderb: {
    			type: "rgb"
    		},
    		vieweraspect: {
    			type: "menu",
    			menuitems: [
    				"proportional",
    				"unconstrained"
    			]
    		},
    		sizefromwindow: {
    			type: "toggle"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		resizewmax: {
    			type: "float"
    		},
    		margint: {
    			type: "float"
    		},
    		keepmemory: {
    			type: "toggle"
    		},
    		repositionxmax: {
    			type: "float"
    		},
    		marginl: {
    			type: "float"
    		},
    		hfillweight: {
    			type: "float"
    		},
    		extname2: {
    			type: "string"
    		},
    		resizet: {
    			type: "toggle"
    		},
    		marginb: {
    			type: "float"
    		},
    		dropscript: {
    			type: "DAT"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		extension3: {
    			type: "string"
    		},
    		h: {
    			type: "number"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		display: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var sliderCOMP = {
    	maxInputs: 1,
    	pars: {
    		resizer: {
    			type: "toggle"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		top: {
    			type: "TOP"
    		},
    		offset: {
    			type: "xy"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		slidertype: {
    			type: "menu",
    			menuitems: [
    				"slideru",
    				"sliderv",
    				"slideruv"
    			]
    		},
    		zonel: {
    			type: "float"
    		},
    		clone: {
    			type: "COMP"
    		},
    		mouserel: {
    			type: "toggle"
    		},
    		keepmemory: {
    			type: "toggle"
    		},
    		topanchor: {
    			type: "float"
    		},
    		align: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"horizlr",
    				"horizrl",
    				"verttb",
    				"vertbt",
    				"gridrows",
    				"gridcols",
    				"nodes"
    			]
    		},
    		bgcolor: {
    			type: "rgb"
    		},
    		repositionxmin: {
    			type: "float"
    		},
    		bottomanchor: {
    			type: "float"
    		},
    		paneldragop: {
    			type: "OP"
    		},
    		uvbuttonsmiddle: {
    			type: "toggle"
    		},
    		leftborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		opacity: {
    			type: "float"
    		},
    		w: {
    			type: "number"
    		},
    		chop: {
    			type: "CHOP"
    		},
    		rightoffset: {
    			type: "float"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		multitouch: {
    			type: "menu",
    			menuitems: [
    				"mtouchparent",
    				"mtouchyes",
    				"mtouchno"
    			]
    		},
    		hmode: {
    			type: "menu",
    			menuitems: [
    				"fixed",
    				"fill",
    				"anchors"
    			]
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		pvscrollbar: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		bgalpha: {
    			type: "float"
    		},
    		alignallow: {
    			type: "menu",
    			menuitems: [
    				"allow",
    				"ignore",
    				"ignoremargin"
    			]
    		},
    		bordera: {
    			type: "rgb"
    		},
    		clickthrough: {
    			type: "toggle"
    		},
    		dropdestscript: {
    			type: "DAT"
    		},
    		multrgb: {
    			type: "toggle"
    		},
    		disablecolor: {
    			type: "rgb"
    		},
    		leftborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		crop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"never"
    			]
    		},
    		helpdat: {
    			type: "DAT"
    		},
    		vfillweight: {
    			type: "float"
    		},
    		resizel: {
    			type: "toggle"
    		},
    		postoffset: {
    			type: "xy"
    		},
    		topborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		topoffset: {
    			type: "float"
    		},
    		borderbalpha: {
    			type: "float"
    		},
    		subcompname: {
    			type: "string"
    		},
    		bottomoffset: {
    			type: "float"
    		},
    		layer: {
    			type: "float"
    		},
    		extension4: {
    			type: "string"
    		},
    		extname1: {
    			type: "string"
    		},
    		dragdropcallbacks: {
    			type: "DAT"
    		},
    		drag: {
    			type: "menu",
    			menuitems: [
    				"dragparent",
    				"legacy",
    				"dragno",
    				"usecallbacks"
    			]
    		},
    		rightborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		scale: {
    			type: "xy"
    		},
    		fit: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"best"
    			]
    		},
    		dodisablecolor: {
    			type: "toggle"
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		dragscript: {
    			type: "DAT"
    		},
    		fixedaspect: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical"
    			]
    		},
    		resizewmin: {
    			type: "float"
    		},
    		borderover: {
    			type: "toggle"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		clampvh: {
    			type: "toggle"
    		},
    		disablealpha: {
    			type: "float"
    		},
    		alignmax: {
    			type: "number"
    		},
    		anchordrag: {
    			type: "menu",
    			menuitems: [
    				"anchors",
    				"offsets"
    			]
    		},
    		clampvl: {
    			type: "toggle"
    		},
    		scrolloverlay: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"ignore",
    				"ignoreover"
    			]
    		},
    		vmode: {
    			type: "menu",
    			menuitems: [
    				"fixed",
    				"fill",
    				"anchors"
    			]
    		},
    		rightanchor: {
    			type: "float"
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		vorigin: {
    			type: "float"
    		},
    		enable: {
    			type: "toggle"
    		},
    		namedchop: {
    			type: "toggle"
    		},
    		spacing: {
    			type: "float"
    		},
    		marginr: {
    			type: "float"
    		},
    		scrollbarthickness: {
    			type: "number"
    		},
    		reposition: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"window",
    				"component"
    			]
    		},
    		bottomborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		mousewheel: {
    			type: "toggle"
    		},
    		leftoffset: {
    			type: "float"
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"left",
    				"center",
    				"right"
    			]
    		},
    		resizehmax: {
    			type: "float"
    		},
    		aspect: {
    			type: "float"
    		},
    		borderaalpha: {
    			type: "float"
    		},
    		cursor: {
    			type: "menu",
    			menuitems: [
    				"pointer",
    				"linkselect",
    				"ibeam",
    				"cross",
    				"busy",
    				"activate",
    				"invisible"
    			]
    		},
    		repocomp: {
    			type: "PanelCOMP"
    		},
    		zoner: {
    			type: "float"
    		},
    		droptypescript: {
    			type: "DAT"
    		},
    		topborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		composite: {
    			type: "menu",
    			menuitems: [
    				"over",
    				"under",
    				"inside",
    				"outside",
    				"add",
    				"subtract",
    				"multiply"
    			]
    		},
    		phscrollbar: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		externaltox: {
    			type: "string"
    		},
    		zonet: {
    			type: "float"
    		},
    		extension1: {
    			type: "string"
    		},
    		clampuh: {
    			type: "toggle"
    		},
    		y: {
    			type: "number"
    		},
    		resizeb: {
    			type: "toggle"
    		},
    		resizehmin: {
    			type: "float"
    		},
    		topfill: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"best",
    				"native"
    			]
    		},
    		drop: {
    			type: "menu",
    			menuitems: [
    				"dropparent",
    				"legacy",
    				"dropno",
    				"usecallbacks"
    			]
    		},
    		extension2: {
    			type: "string"
    		},
    		rightborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		repositionymin: {
    			type: "float"
    		},
    		zoneb: {
    			type: "float"
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"top",
    				"center",
    				"bottom"
    			]
    		},
    		leftanchor: {
    			type: "float"
    		},
    		repositionymax: {
    			type: "float"
    		},
    		clampul: {
    			type: "toggle"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		},
    		borderb: {
    			type: "rgb"
    		},
    		alignorder: {
    			type: "float"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		extname2: {
    			type: "string"
    		},
    		uvbuttonsright: {
    			type: "toggle"
    		},
    		x: {
    			type: "number"
    		},
    		extname3: {
    			type: "string"
    		},
    		overridemethod: {
    			type: "menu",
    			menuitems: [
    				"trigger",
    				"always"
    			]
    		},
    		uvbuttonsleft: {
    			type: "toggle"
    		},
    		horigin: {
    			type: "float"
    		},
    		vieweraspect: {
    			type: "menu",
    			menuitems: [
    				"proportional",
    				"unconstrained"
    			]
    		},
    		sizefromwindow: {
    			type: "toggle"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		resizewmax: {
    			type: "float"
    		},
    		margint: {
    			type: "float"
    		},
    		extension3: {
    			type: "string"
    		},
    		overlay: {
    			type: "toggle"
    		},
    		repositionxmax: {
    			type: "float"
    		},
    		marginl: {
    			type: "float"
    		},
    		hfillweight: {
    			type: "float"
    		},
    		extname4: {
    			type: "string"
    		},
    		resizet: {
    			type: "toggle"
    		},
    		marginb: {
    			type: "float"
    		},
    		dropscript: {
    			type: "DAT"
    		},
    		bottomborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		h: {
    			type: "number"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		display: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var containerCOMP = {
    	maxInputs: 1,
    	pars: {
    		resizer: {
    			type: "toggle"
    		},
    		loadondemand: {
    			type: "toggle"
    		},
    		top: {
    			type: "TOP"
    		},
    		offset: {
    			type: "xy"
    		},
    		opviewer: {
    			type: "OP"
    		},
    		promoteextension4: {
    			type: "toggle"
    		},
    		resizel: {
    			type: "toggle"
    		},
    		topoffset: {
    			type: "float"
    		},
    		helpdat: {
    			type: "DAT"
    		},
    		mouserel: {
    			type: "toggle"
    		},
    		topanchor: {
    			type: "float"
    		},
    		align: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"horizlr",
    				"horizrl",
    				"verttb",
    				"vertbt",
    				"gridrows",
    				"gridcols",
    				"nodes"
    			]
    		},
    		bgcolor: {
    			type: "rgb"
    		},
    		repositionxmin: {
    			type: "float"
    		},
    		bottomanchor: {
    			type: "float"
    		},
    		paneldragop: {
    			type: "OP"
    		},
    		uvbuttonsmiddle: {
    			type: "toggle"
    		},
    		leftborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		opacity: {
    			type: "float"
    		},
    		w: {
    			type: "number"
    		},
    		chop: {
    			type: "CHOP"
    		},
    		rightoffset: {
    			type: "float"
    		},
    		reinitextensions: {
    			type: "pulse"
    		},
    		multitouch: {
    			type: "menu",
    			menuitems: [
    				"mtouchparent",
    				"mtouchyes",
    				"mtouchno"
    			]
    		},
    		hmode: {
    			type: "menu",
    			menuitems: [
    				"fixed",
    				"fill",
    				"anchors"
    			]
    		},
    		promoteextension1: {
    			type: "toggle"
    		},
    		pvscrollbar: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		bgalpha: {
    			type: "float"
    		},
    		alignallow: {
    			type: "menu",
    			menuitems: [
    				"allow",
    				"ignore",
    				"ignoremargin"
    			]
    		},
    		bordera: {
    			type: "rgb"
    		},
    		clickthrough: {
    			type: "toggle"
    		},
    		dropdestscript: {
    			type: "DAT"
    		},
    		multrgb: {
    			type: "toggle"
    		},
    		disablecolor: {
    			type: "rgb"
    		},
    		leftborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		crop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"never"
    			]
    		},
    		spacing: {
    			type: "float"
    		},
    		vfillweight: {
    			type: "float"
    		},
    		bottomborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		postoffset: {
    			type: "xy"
    		},
    		horigin: {
    			type: "float"
    		},
    		topborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		borderbalpha: {
    			type: "float"
    		},
    		bottomoffset: {
    			type: "float"
    		},
    		layer: {
    			type: "float"
    		},
    		extension4: {
    			type: "string"
    		},
    		extname1: {
    			type: "string"
    		},
    		dragdropcallbacks: {
    			type: "DAT"
    		},
    		drag: {
    			type: "menu",
    			menuitems: [
    				"dragparent",
    				"legacy",
    				"dragno",
    				"usecallbacks"
    			]
    		},
    		rightborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		promoteextension3: {
    			type: "toggle"
    		},
    		scale: {
    			type: "xy"
    		},
    		fit: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"best"
    			]
    		},
    		keepmemory: {
    			type: "toggle"
    		},
    		enablecloningpulse: {
    			type: "pulse"
    		},
    		dragscript: {
    			type: "DAT"
    		},
    		fixedaspect: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical"
    			]
    		},
    		resizewmin: {
    			type: "float"
    		},
    		borderover: {
    			type: "toggle"
    		},
    		parentshortcut: {
    			type: "string"
    		},
    		disablealpha: {
    			type: "float"
    		},
    		anchordrag: {
    			type: "menu",
    			menuitems: [
    				"anchors",
    				"offsets"
    			]
    		},
    		scrolloverlay: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"ignore",
    				"ignoreover"
    			]
    		},
    		vmode: {
    			type: "menu",
    			menuitems: [
    				"fixed",
    				"fill",
    				"anchors"
    			]
    		},
    		marginb: {
    			type: "float"
    		},
    		nodeview: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"opviewer"
    			]
    		},
    		vorigin: {
    			type: "float"
    		},
    		enable: {
    			type: "toggle"
    		},
    		namedchop: {
    			type: "toggle"
    		},
    		subcompname: {
    			type: "string"
    		},
    		marginr: {
    			type: "float"
    		},
    		scrollbarthickness: {
    			type: "number"
    		},
    		reposition: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"window",
    				"component"
    			]
    		},
    		bottomborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		mousewheel: {
    			type: "toggle"
    		},
    		leftoffset: {
    			type: "float"
    		},
    		justifyh: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"left",
    				"center",
    				"right"
    			]
    		},
    		resizehmax: {
    			type: "float"
    		},
    		aspect: {
    			type: "float"
    		},
    		cursor: {
    			type: "menu",
    			menuitems: [
    				"pointer",
    				"linkselect",
    				"ibeam",
    				"cross",
    				"busy",
    				"activate",
    				"invisible"
    			]
    		},
    		repocomp: {
    			type: "PanelCOMP"
    		},
    		overlay: {
    			type: "toggle"
    		},
    		droptypescript: {
    			type: "DAT"
    		},
    		topborderi: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		composite: {
    			type: "menu",
    			menuitems: [
    				"over",
    				"under",
    				"inside",
    				"outside",
    				"add",
    				"subtract",
    				"multiply"
    			]
    		},
    		phscrollbar: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"auto"
    			]
    		},
    		externaltox: {
    			type: "string"
    		},
    		clone: {
    			type: "COMP"
    		},
    		extension1: {
    			type: "string"
    		},
    		y: {
    			type: "number"
    		},
    		resizeb: {
    			type: "toggle"
    		},
    		resizehmin: {
    			type: "float"
    		},
    		topfill: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"horizontal",
    				"vertical",
    				"best",
    				"native"
    			]
    		},
    		drop: {
    			type: "menu",
    			menuitems: [
    				"dropparent",
    				"legacy",
    				"dropno",
    				"usecallbacks"
    			]
    		},
    		extension2: {
    			type: "string"
    		},
    		rightborder: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"bordera",
    				"borderb"
    			]
    		},
    		repositionymin: {
    			type: "float"
    		},
    		borderaalpha: {
    			type: "float"
    		},
    		justifyv: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"top",
    				"center",
    				"bottom"
    			]
    		},
    		leftanchor: {
    			type: "float"
    		},
    		repositionymax: {
    			type: "float"
    		},
    		dodisablecolor: {
    			type: "toggle"
    		},
    		reloadtoxonstart: {
    			type: "toggle"
    		},
    		alignmax: {
    			type: "number"
    		},
    		alignorder: {
    			type: "float"
    		},
    		savebackup: {
    			type: "toggle"
    		},
    		extname2: {
    			type: "string"
    		},
    		uvbuttonsright: {
    			type: "toggle"
    		},
    		x: {
    			type: "number"
    		},
    		extname3: {
    			type: "string"
    		},
    		overridemethod: {
    			type: "menu",
    			menuitems: [
    				"trigger",
    				"always"
    			]
    		},
    		uvbuttonsleft: {
    			type: "toggle"
    		},
    		borderb: {
    			type: "rgb"
    		},
    		vieweraspect: {
    			type: "menu",
    			menuitems: [
    				"proportional",
    				"unconstrained"
    			]
    		},
    		sizefromwindow: {
    			type: "toggle"
    		},
    		opshortcut: {
    			type: "string"
    		},
    		resizewmax: {
    			type: "float"
    		},
    		margint: {
    			type: "float"
    		},
    		extension3: {
    			type: "string"
    		},
    		repositionxmax: {
    			type: "float"
    		},
    		marginl: {
    			type: "float"
    		},
    		hfillweight: {
    			type: "float"
    		},
    		extname4: {
    			type: "string"
    		},
    		resizet: {
    			type: "toggle"
    		},
    		rightanchor: {
    			type: "float"
    		},
    		dropscript: {
    			type: "DAT"
    		},
    		enablecloning: {
    			type: "toggle"
    		},
    		promoteextension2: {
    			type: "toggle"
    		},
    		h: {
    			type: "number"
    		},
    		reinitnet: {
    			type: "pulse"
    		},
    		display: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "COMP"
    };
    var websocketDAT = {
    	maxInputs: 1,
    	pars: {
    		maxlines: {
    			type: "number"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		socketioaddress: {
    			type: "string"
    		},
    		port: {
    			type: "number"
    		},
    		fromop: {
    			type: "OP"
    		},
    		clear: {
    			type: "pulse"
    		},
    		clamp: {
    			type: "toggle"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		socketio: {
    			type: "toggle"
    		},
    		customext: {
    			type: "string"
    		},
    		netaddress: {
    			type: "string"
    		},
    		bytes: {
    			type: "toggle"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"callbacks",
    				"op"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var fileoutDAT = {
    	maxInputs: 1,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		n: {
    			type: "number"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		append: {
    			type: "toggle"
    		},
    		customext: {
    			type: "string"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		write: {
    			type: "pulse"
    		},
    		file: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var substituteDAT = {
    	maxInputs: 2,
    	pars: {
    		xfirstrow: {
    			type: "toggle"
    		},
    		"case": {
    			type: "toggle"
    		},
    		match: {
    			type: "menu",
    			menuitems: [
    				"anywhere",
    				"exact",
    				"start",
    				"end"
    			]
    		},
    		rowindexstart: {
    			type: "number"
    		},
    		colnamestart: {
    			type: "string"
    		},
    		rownameend: {
    			type: "string"
    		},
    		expand: {
    			type: "toggle"
    		},
    		rowexpr: {
    			type: "string"
    		},
    		fromcol: {
    			type: "number"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		rowindexend: {
    			type: "number"
    		},
    		expandto: {
    			type: "toggle"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		colindexend: {
    			type: "number"
    		},
    		colexpr: {
    			type: "string"
    		},
    		customext: {
    			type: "string"
    		},
    		colnames: {
    			type: "string"
    		},
    		after: {
    			type: "string"
    		},
    		colindexstart: {
    			type: "number"
    		},
    		rownames: {
    			type: "string"
    		},
    		rownamestart: {
    			type: "string"
    		},
    		first: {
    			type: "toggle"
    		},
    		extractrows: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"byname",
    				"byindex",
    				"bynameindex",
    				"byindexname",
    				"bynames",
    				"byexpr"
    			]
    		},
    		xfirstcol: {
    			type: "toggle"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		extractcols: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"byname",
    				"byindex",
    				"bynameindex",
    				"byindexname",
    				"bynames",
    				"byexpr"
    			]
    		},
    		fromrow: {
    			type: "number"
    		},
    		before: {
    			type: "string"
    		},
    		colnameend: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "DAT"
    };
    var xmlDAT = {
    	maxInputs: 2,
    	pars: {
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		customext: {
    			type: "string"
    		},
    		plabel: {
    			type: "string"
    		},
    		pvalue: {
    			type: "string"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		merge: {
    			type: "menu",
    			menuitems: [
    				"before",
    				"after",
    				"inside",
    				"replace"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		text: {
    			type: "string"
    		},
    		pname: {
    			type: "string"
    		},
    		mlabel: {
    			type: "string"
    		},
    		sgml: {
    			type: "toggle"
    		},
    		type: {
    			type: "string"
    		},
    		ptype: {
    			type: "string"
    		},
    		label: {
    			type: "string"
    		},
    		oclabel: {
    			type: "string"
    		},
    		value: {
    			type: "string"
    		},
    		ptext: {
    			type: "string"
    		},
    		oavalue: {
    			type: "string"
    		},
    		lprefix: {
    			type: "toggle"
    		},
    		oaname: {
    			type: "string"
    		},
    		show: {
    			type: "menu",
    			menuitems: [
    				"sumtable",
    				"sumtree",
    				"xml",
    				"attribs",
    				"attribscol",
    				"children",
    				"text"
    			]
    		},
    		name: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "DAT"
    };
    var insertDAT = {
    	maxInputs: 1,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		customext: {
    			type: "string"
    		},
    		contents: {
    			type: "string"
    		},
    		at: {
    			type: "menu",
    			menuitems: [
    				"start",
    				"end",
    				"index"
    			]
    		},
    		insert: {
    			type: "menu",
    			menuitems: [
    				"row",
    				"col"
    			]
    		},
    		index: {
    			type: "number"
    		}
    	},
    	minInputs: 1,
    	type: "DAT"
    };
    var monitorsDAT = {
    	maxInputs: 0,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		customext: {
    			type: "string"
    		},
    		monitors: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"primary",
    				"nonprimary",
    				"affinity",
    				"none"
    			]
    		},
    		units: {
    			type: "menu",
    			menuitems: [
    				"native",
    				"dpiscaled"
    			]
    		},
    		bounds: {
    			type: "toggle"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var udtoutDAT = {
    	maxInputs: 0,
    	pars: {
    		maxlines: {
    			type: "number"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"perbyte",
    				"perline",
    				"permessage"
    			]
    		},
    		port: {
    			type: "number"
    		},
    		fromop: {
    			type: "OP"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		clear: {
    			type: "pulse"
    		},
    		clamp: {
    			type: "toggle"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		protocol: {
    			type: "menu",
    			menuitems: [
    				"faststreaming",
    				"reliablemsging"
    			]
    		},
    		shared: {
    			type: "toggle"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		customext: {
    			type: "string"
    		},
    		bytes: {
    			type: "toggle"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"callbacks",
    				"op"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var oscinDAT = {
    	maxInputs: 1,
    	pars: {
    		maxlines: {
    			type: "number"
    		},
    		bundletimestamp: {
    			type: "toggle"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		addscope: {
    			type: "string"
    		},
    		port: {
    			type: "number"
    		},
    		fromop: {
    			type: "OP"
    		},
    		typetag: {
    			type: "toggle"
    		},
    		clamp: {
    			type: "toggle"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		clear: {
    			type: "pulse"
    		},
    		splitbundle: {
    			type: "toggle"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		protocol: {
    			type: "menu",
    			menuitems: [
    				"msging",
    				"multicastmsging",
    				"reliablemsging"
    			]
    		},
    		shared: {
    			type: "toggle"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		splitmessage: {
    			type: "toggle"
    		},
    		customext: {
    			type: "string"
    		},
    		bytes: {
    			type: "toggle"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"callbacks",
    				"op"
    			]
    		},
    		address: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var chopexecuteDAT = {
    	maxInputs: 1,
    	pars: {
    		ontooff: {
    			type: "toggle"
    		},
    		chop: {
    			type: "CHOP"
    		},
    		active: {
    			type: "toggle"
    		},
    		offtoon: {
    			type: "toggle"
    		},
    		whileon: {
    			type: "toggle"
    		},
    		fromop: {
    			type: "OP"
    		},
    		whileoff: {
    			type: "toggle"
    		},
    		freq: {
    			type: "menu",
    			menuitems: [
    				"everysample",
    				"onceperframe"
    			]
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		channel: {
    			type: "string"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		valuechange: {
    			type: "toggle"
    		},
    		customext: {
    			type: "string"
    		},
    		edit: {
    			type: "pulse"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"here",
    				"op"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var infoDAT = {
    	maxInputs: 0,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		customext: {
    			type: "string"
    		},
    		op: {
    			type: "OP"
    		},
    		passive: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var evaluateDAT = {
    	maxInputs: 2,
    	pars: {
    		xfirstrow: {
    			type: "toggle"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		rowindexstart: {
    			type: "number"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		output: {
    			type: "string"
    		},
    		rownameend: {
    			type: "string"
    		},
    		rowexpr: {
    			type: "string"
    		},
    		datexpr: {
    			type: "DAT"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		rowindexend: {
    			type: "number"
    		},
    		dat: {
    			type: "DAT"
    		},
    		colindexend: {
    			type: "number"
    		},
    		fromcol: {
    			type: "number"
    		},
    		expr: {
    			type: "string"
    		},
    		customext: {
    			type: "string"
    		},
    		colnames: {
    			type: "string"
    		},
    		colindexstart: {
    			type: "number"
    		},
    		rownames: {
    			type: "string"
    		},
    		rownamestart: {
    			type: "string"
    		},
    		dependency: {
    			type: "toggle"
    		},
    		extractrows: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"byname",
    				"byindex",
    				"bynameindex",
    				"byindexname",
    				"bynames",
    				"byexpr"
    			]
    		},
    		xfirstcol: {
    			type: "toggle"
    		},
    		outputsize: {
    			type: "menu",
    			menuitems: [
    				"in1",
    				"in2"
    			]
    		},
    		extractcols: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"byname",
    				"byindex",
    				"bynameindex",
    				"byindexname",
    				"bynames",
    				"byexpr"
    			]
    		},
    		colnamestart: {
    			type: "string"
    		},
    		fromrow: {
    			type: "number"
    		},
    		backslash: {
    			type: "toggle"
    		},
    		colnameend: {
    			type: "string"
    		},
    		colexpr: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var mqttclientDAT = {
    	maxInputs: 0,
    	pars: {
    		specifyid: {
    			type: "toggle"
    		},
    		usercid: {
    			type: "string"
    		},
    		keepalive: {
    			type: "number"
    		},
    		active: {
    			type: "toggle"
    		},
    		maxlines: {
    			type: "number"
    		},
    		cleansession: {
    			type: "toggle"
    		},
    		fromop: {
    			type: "OP"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		clear: {
    			type: "pulse"
    		},
    		clamp: {
    			type: "toggle"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		reconnect: {
    			type: "pulse"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		bytes: {
    			type: "toggle"
    		},
    		customext: {
    			type: "string"
    		},
    		netaddress: {
    			type: "string"
    		},
    		maxinflight: {
    			type: "number"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"callbacks",
    				"op"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var clipDAT = {
    	maxInputs: 0,
    	pars: {
    		clip: {
    			type: "CHOP"
    		},
    		edit: {
    			type: "pulse"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		customext: {
    			type: "string"
    		},
    		frameloop: {
    			type: "number"
    		},
    		component: {
    			type: "OP"
    		},
    		reload: {
    			type: "pulse"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		framefirst: {
    			type: "number"
    		},
    		file: {
    			type: "string"
    		},
    		printstate: {
    			type: "toggle"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"here",
    				"comp"
    			]
    		},
    		exit: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var tcpipDAT = {
    	maxInputs: 0,
    	pars: {
    		maxlines: {
    			type: "number"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"perbyte",
    				"perline",
    				"all"
    			]
    		},
    		port: {
    			type: "number"
    		},
    		fromop: {
    			type: "OP"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		clear: {
    			type: "pulse"
    		},
    		clamp: {
    			type: "toggle"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		shared: {
    			type: "toggle"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		bytes: {
    			type: "toggle"
    		},
    		address: {
    			type: "string"
    		},
    		customext: {
    			type: "string"
    		},
    		mode: {
    			type: "menu",
    			menuitems: [
    				"client",
    				"server"
    			]
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"callbacks",
    				"op"
    			]
    		},
    		localaddress: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var soptoDAT = {
    	maxInputs: 0,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		sop: {
    			type: "SOP"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		customext: {
    			type: "string"
    		},
    		uvforpts: {
    			type: "toggle"
    		},
    		attrib: {
    			type: "string"
    		},
    		group: {
    			type: "string"
    		},
    		extract: {
    			type: "menu",
    			menuitems: [
    				"points",
    				"vertices",
    				"primitives",
    				"detail"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var errorDAT = {
    	maxInputs: 0,
    	pars: {
    		logcurrent: {
    			type: "pulse"
    		},
    		maxlines: {
    			type: "number"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		source: {
    			type: "string"
    		},
    		fromop: {
    			type: "OP"
    		},
    		clear: {
    			type: "pulse"
    		},
    		clamp: {
    			type: "toggle"
    		},
    		type: {
    			type: "string"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		message: {
    			type: "string"
    		},
    		severity: {
    			type: "string"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		customext: {
    			type: "string"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"callbacks",
    				"op"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var tuioinDAT = {
    	maxInputs: 0,
    	pars: {
    		classid: {
    			type: "toggle"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		velocity: {
    			type: "toggle"
    		},
    		port: {
    			type: "number"
    		},
    		fromop: {
    			type: "OP"
    		},
    		profile: {
    			type: "toggle"
    		},
    		accel: {
    			type: "toggle"
    		},
    		size: {
    			type: "toggle"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		protocol: {
    			type: "menu",
    			menuitems: [
    				"msging",
    				"multicastmsging",
    				"reliablemsging"
    			]
    		},
    		shared: {
    			type: "toggle"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		customext: {
    			type: "string"
    		},
    		angle: {
    			type: "toggle"
    		},
    		timestamp: {
    			type: "toggle"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"callbacks",
    				"op"
    			]
    		},
    		address: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var mergeDAT = {
    	maxInputs: 9999,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		dat: {
    			type: "DAT"
    		},
    		byname: {
    			type: "toggle"
    		},
    		customext: {
    			type: "string"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		unmatched: {
    			type: "toggle"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		how: {
    			type: "menu",
    			menuitems: [
    				"row",
    				"col",
    				"collapsecol",
    				"collapserow",
    				"collapsecells",
    				"repcolcells",
    				"reprowcells"
    			]
    		},
    		spacer: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var oscoutDAT = {
    	maxInputs: 1,
    	pars: {
    		maxlines: {
    			type: "number"
    		},
    		bundletimestamp: {
    			type: "toggle"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		addscope: {
    			type: "string"
    		},
    		port: {
    			type: "number"
    		},
    		fromop: {
    			type: "OP"
    		},
    		typetag: {
    			type: "toggle"
    		},
    		clamp: {
    			type: "toggle"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		clear: {
    			type: "pulse"
    		},
    		splitbundle: {
    			type: "toggle"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		protocol: {
    			type: "menu",
    			menuitems: [
    				"msging",
    				"multicastmsging",
    				"reliablemsging"
    			]
    		},
    		shared: {
    			type: "toggle"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		splitmessage: {
    			type: "toggle"
    		},
    		customext: {
    			type: "string"
    		},
    		bytes: {
    			type: "toggle"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"callbacks",
    				"op"
    			]
    		},
    		address: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var sortDAT = {
    	maxInputs: 1,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		order: {
    			type: "menu",
    			menuitems: [
    				"alpha",
    				"alphanum",
    				"nums",
    				"random"
    			]
    		},
    		unique: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"single",
    				"entire"
    			]
    		},
    		sortmethod: {
    			type: "menu",
    			menuitems: [
    				"colname",
    				"colindex",
    				"colpreserve",
    				"rowname",
    				"rowindex",
    				"rowpreserve"
    			]
    		},
    		seed: {
    			type: "float"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		reverse: {
    			type: "toggle"
    		},
    		preservefirst: {
    			type: "toggle"
    		},
    		customext: {
    			type: "string"
    		},
    		index: {
    			type: "number"
    		},
    		ignorecase: {
    			type: "toggle"
    		},
    		name: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "DAT"
    };
    var outDAT = {
    	maxInputs: 1,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		customext: {
    			type: "string"
    		},
    		label: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "DAT"
    };
    var performDAT = {
    	maxInputs: 0,
    	pars: {
    		logscript: {
    			type: "toggle"
    		},
    		triggerthreshold: {
    			type: "float"
    		},
    		logviewport: {
    			type: "toggle"
    		},
    		logobjectview: {
    			type: "toggle"
    		},
    		active: {
    			type: "toggle"
    		},
    		logmidi: {
    			type: "toggle"
    		},
    		logexport: {
    			type: "toggle"
    		},
    		logrender: {
    			type: "toggle"
    		},
    		customext: {
    			type: "string"
    		},
    		logdrawchannels: {
    			type: "toggle"
    		},
    		activepulse: {
    			type: "pulse"
    		},
    		logmovie: {
    			type: "toggle"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		logcook: {
    			type: "toggle"
    		},
    		triggermode: {
    			type: "menu",
    			menuitems: [
    				"threshold",
    				"droppedframe"
    			]
    		},
    		logcustompanel: {
    			type: "toggle"
    		},
    		logmisc: {
    			type: "toggle"
    		},
    		logframelength: {
    			type: "toggle"
    		},
    		loggraphics: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var fifoDAT = {
    	maxInputs: 0,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		maxlines: {
    			type: "number"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		customext: {
    			type: "string"
    		},
    		firstrow: {
    			type: "toggle"
    		},
    		fromop: {
    			type: "OP"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"callbacks",
    				"op"
    			]
    		},
    		clear: {
    			type: "pulse"
    		},
    		clamp: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var midiinDAT = {
    	maxInputs: 0,
    	pars: {
    		maxlines: {
    			type: "number"
    		},
    		filter: {
    			type: "toggle"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		skiptiming: {
    			type: "toggle"
    		},
    		value: {
    			type: "string"
    		},
    		fromop: {
    			type: "OP"
    		},
    		clamp: {
    			type: "toggle"
    		},
    		clear: {
    			type: "pulse"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"callbacks",
    				"op"
    			]
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		channel: {
    			type: "string"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		id: {
    			type: "string"
    		},
    		message: {
    			type: "string"
    		},
    		customext: {
    			type: "string"
    		},
    		active: {
    			type: "toggle"
    		},
    		device: {
    			type: "DAT"
    		},
    		bytes: {
    			type: "toggle"
    		},
    		skipsense: {
    			type: "toggle"
    		},
    		index: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var udpoutDAT = {
    	maxInputs: 0,
    	pars: {
    		maxlines: {
    			type: "number"
    		},
    		localport: {
    			type: "number"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		localportmode: {
    			type: "menu",
    			menuitems: [
    				"automatic",
    				"manual"
    			]
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"perbyte",
    				"perline",
    				"permessage"
    			]
    		},
    		port: {
    			type: "number"
    		},
    		fromop: {
    			type: "OP"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		clear: {
    			type: "pulse"
    		},
    		clamp: {
    			type: "toggle"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		protocol: {
    			type: "menu",
    			menuitems: [
    				"msging",
    				"multicastmsging"
    			]
    		},
    		shared: {
    			type: "toggle"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		customext: {
    			type: "string"
    		},
    		bytes: {
    			type: "toggle"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"callbacks",
    				"op"
    			]
    		},
    		address: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var folderDAT = {
    	maxInputs: 0,
    	pars: {
    		extensioncol: {
    			type: "toggle"
    		},
    		rootfolder: {
    			type: "string"
    		},
    		imageextensions: {
    			type: "toggle"
    		},
    		movieextensions: {
    			type: "toggle"
    		},
    		dateaccessedcol: {
    			type: "toggle"
    		},
    		refreshpulse: {
    			type: "pulse"
    		},
    		mindepth: {
    			type: "number"
    		},
    		names: {
    			type: "string"
    		},
    		folders: {
    			type: "string"
    		},
    		datecreatedcol: {
    			type: "toggle"
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"files",
    				"folders",
    				"filesandfolders"
    			]
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		limitdepth: {
    			type: "toggle"
    		},
    		sizecol: {
    			type: "toggle"
    		},
    		namecol: {
    			type: "toggle"
    		},
    		refresh: {
    			type: "toggle"
    		},
    		toxextensions: {
    			type: "toggle"
    		},
    		customext: {
    			type: "string"
    		},
    		basenamecol: {
    			type: "toggle"
    		},
    		pathcol: {
    			type: "toggle"
    		},
    		relpathcol: {
    			type: "toggle"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		nameformat: {
    			type: "menu",
    			menuitems: [
    				"extension",
    				"noextension"
    			]
    		},
    		audioextensions: {
    			type: "toggle"
    		},
    		active: {
    			type: "toggle"
    		},
    		foldercol: {
    			type: "toggle"
    		},
    		async: {
    			type: "toggle"
    		},
    		toeextensions: {
    			type: "toggle"
    		},
    		subfolders: {
    			type: "toggle"
    		},
    		maxdepth: {
    			type: "number"
    		},
    		datemodifiedcol: {
    			type: "toggle"
    		},
    		typecol: {
    			type: "toggle"
    		},
    		allextensions: {
    			type: "toggle"
    		},
    		depthcol: {
    			type: "toggle"
    		},
    		extensions: {
    			type: "string"
    		},
    		dateformat: {
    			type: "menu",
    			menuitems: [
    				"std",
    				"epoch"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var panelexecuteDAT = {
    	maxInputs: 1,
    	pars: {
    		ontooff: {
    			type: "toggle"
    		},
    		panel: {
    			type: "COMP"
    		},
    		active: {
    			type: "toggle"
    		},
    		offtoon: {
    			type: "toggle"
    		},
    		whileon: {
    			type: "toggle"
    		},
    		fromop: {
    			type: "OP"
    		},
    		whileoff: {
    			type: "toggle"
    		},
    		edit: {
    			type: "pulse"
    		},
    		panelvalue: {
    			type: "string"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		valuechange: {
    			type: "toggle"
    		},
    		customext: {
    			type: "string"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"here",
    				"op"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var multitouchinDAT = {
    	maxInputs: 0,
    	pars: {
    		maxlines: {
    			type: "number"
    		},
    		contactthresh: {
    			type: "float"
    		},
    		relativepos: {
    			type: "toggle"
    		},
    		panel: {
    			type: "PanelCOMP"
    		},
    		active: {
    			type: "toggle"
    		},
    		outputtype: {
    			type: "menu",
    			menuitems: [
    				"log",
    				"changes"
    			]
    		},
    		mouse: {
    			type: "toggle"
    		},
    		fromop: {
    			type: "OP"
    		},
    		relativeid: {
    			type: "toggle"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		clear: {
    			type: "pulse"
    		},
    		minrows: {
    			type: "number"
    		},
    		posthresh: {
    			type: "float"
    		},
    		clamp: {
    			type: "toggle"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		customext: {
    			type: "string"
    		},
    		doubleclickthresh: {
    			type: "float"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"callbacks",
    				"op"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var executeDAT = {
    	maxInputs: 1,
    	pars: {
    		edit: {
    			type: "pulse"
    		},
    		framestart: {
    			type: "toggle"
    		},
    		active: {
    			type: "toggle"
    		},
    		fromop: {
    			type: "OP"
    		},
    		frameend: {
    			type: "toggle"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		create: {
    			type: "toggle"
    		},
    		exit: {
    			type: "toggle"
    		},
    		devicechange: {
    			type: "toggle"
    		},
    		customext: {
    			type: "string"
    		},
    		playstatechange: {
    			type: "toggle"
    		},
    		projectpostsave: {
    			type: "toggle"
    		},
    		start: {
    			type: "toggle"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"here",
    				"op"
    			]
    		},
    		projectpresave: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var datexecuteDAT = {
    	maxInputs: 1,
    	pars: {
    		edit: {
    			type: "pulse"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		sizechange: {
    			type: "toggle"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		execute: {
    			type: "menu",
    			menuitems: [
    				"start",
    				"end"
    			]
    		},
    		colchange: {
    			type: "toggle"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"here",
    				"op"
    			]
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		dat: {
    			type: "DAT"
    		},
    		fromop: {
    			type: "OP"
    		},
    		customext: {
    			type: "string"
    		},
    		tablechange: {
    			type: "toggle"
    		},
    		cellchange: {
    			type: "toggle"
    		},
    		rowchange: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var nullDAT = {
    	maxInputs: 1,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		customext: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "DAT"
    };
    var touchinDAT = {
    	maxInputs: 0,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		protocol: {
    			type: "menu",
    			menuitems: [
    				"streaming",
    				"msging",
    				"multicastmsging",
    				"_separator_",
    				"faststreaming",
    				"reliablemsging"
    			]
    		},
    		shared: {
    			type: "toggle"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		customext: {
    			type: "string"
    		},
    		port: {
    			type: "number"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		address: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var choptoDAT = {
    	maxInputs: 0,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		chop: {
    			type: "CHOP"
    		},
    		customext: {
    			type: "string"
    		},
    		output: {
    			type: "menu",
    			menuitems: [
    				"rowperchan",
    				"colperchan"
    			]
    		},
    		names: {
    			type: "toggle"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		latestsample: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var webDAT = {
    	maxInputs: 2,
    	pars: {
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		customext: {
    			type: "string"
    		},
    		url: {
    			type: "string"
    		},
    		submitfetch: {
    			type: "pulse"
    		},
    		disconnect: {
    			type: "pulse"
    		},
    		verifypeer: {
    			type: "toggle"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"post"
    			]
    		},
    		includeheader: {
    			type: "toggle"
    		},
    		fetch: {
    			type: "pulse"
    		},
    		timeout: {
    			type: "number"
    		},
    		asyncfetch: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var parameterexecuteDAT = {
    	maxInputs: 1,
    	pars: {
    		edit: {
    			type: "pulse"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		exportchange: {
    			type: "toggle"
    		},
    		expressionchange: {
    			type: "toggle"
    		},
    		customext: {
    			type: "string"
    		},
    		fromop: {
    			type: "OP"
    		},
    		modechange: {
    			type: "toggle"
    		},
    		enablechange: {
    			type: "toggle"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		onpulse: {
    			type: "toggle"
    		},
    		op: {
    			type: "OP"
    		},
    		builtin: {
    			type: "toggle"
    		},
    		valuechange: {
    			type: "toggle"
    		},
    		active: {
    			type: "toggle"
    		},
    		custom: {
    			type: "toggle"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"here",
    				"op"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var convertDAT = {
    	maxInputs: 1,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		customext: {
    			type: "string"
    		},
    		spacers: {
    			type: "string"
    		},
    		delimiters: {
    			type: "string"
    		},
    		how: {
    			type: "menu",
    			menuitems: [
    				"text",
    				"table"
    			]
    		},
    		removeblank: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "DAT"
    };
    var examineDAT = {
    	maxInputs: 0,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		expression: {
    			type: "string"
    		},
    		customext: {
    			type: "string"
    		},
    		expandclasses: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"text",
    				"table"
    			]
    		},
    		maxlevels: {
    			type: "number"
    		},
    		outputtype: {
    			type: "toggle"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		outputlevel: {
    			type: "toggle"
    		},
    		type: {
    			type: "string"
    		},
    		subkey: {
    			type: "string"
    		},
    		level: {
    			type: "string"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		outputvalue: {
    			type: "toggle"
    		},
    		op: {
    			type: "OP"
    		},
    		outputheaders: {
    			type: "toggle"
    		},
    		value: {
    			type: "string"
    		},
    		key: {
    			type: "string"
    		},
    		source: {
    			type: "menu",
    			menuitems: [
    				"storage",
    				"locals",
    				"extensions",
    				"globals",
    				"expression"
    			]
    		},
    		outputkey: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var textDAT = {
    	maxInputs: 1,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		edit: {
    			type: "pulse"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		loadonstartpulse: {
    			type: "pulse"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		customext: {
    			type: "string"
    		},
    		writepulse: {
    			type: "pulse"
    		},
    		loadonstart: {
    			type: "toggle"
    		},
    		write: {
    			type: "toggle"
    		},
    		file: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var midieventDAT = {
    	maxInputs: 0,
    	pars: {
    		maxlines: {
    			type: "number"
    		},
    		filter: {
    			type: "toggle"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		skiptiming: {
    			type: "toggle"
    		},
    		value: {
    			type: "string"
    		},
    		fromop: {
    			type: "OP"
    		},
    		clamp: {
    			type: "toggle"
    		},
    		clear: {
    			type: "pulse"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"callbacks",
    				"op"
    			]
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		channel: {
    			type: "string"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		message: {
    			type: "string"
    		},
    		dir: {
    			type: "string"
    		},
    		customext: {
    			type: "string"
    		},
    		active: {
    			type: "toggle"
    		},
    		index: {
    			type: "string"
    		},
    		bytes: {
    			type: "toggle"
    		},
    		skipsense: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var transposeDAT = {
    	maxInputs: 1,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		customext: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "DAT"
    };
    var inDAT = {
    	maxInputs: 1,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		customext: {
    			type: "string"
    		},
    		label: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var selectDAT = {
    	maxInputs: 1,
    	pars: {
    		firstcol: {
    			type: "toggle"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		rowindexstart: {
    			type: "number"
    		},
    		output: {
    			type: "menu",
    			menuitems: [
    				"data",
    				"string",
    				"expr"
    			]
    		},
    		rownameend: {
    			type: "string"
    		},
    		rowexpr: {
    			type: "string"
    		},
    		fromcol: {
    			type: "number"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		rowindexend: {
    			type: "number"
    		},
    		dat: {
    			type: "DAT"
    		},
    		colindexend: {
    			type: "number"
    		},
    		colexpr: {
    			type: "string"
    		},
    		customext: {
    			type: "string"
    		},
    		colnames: {
    			type: "string"
    		},
    		colindexstart: {
    			type: "number"
    		},
    		rownames: {
    			type: "string"
    		},
    		rownamestart: {
    			type: "string"
    		},
    		extractrows: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"byname",
    				"byindex",
    				"bynameindex",
    				"byindexname",
    				"bynames",
    				"byexpr"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		extractcols: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"byname",
    				"byindex",
    				"bynameindex",
    				"byindexname",
    				"bynames",
    				"byexpr"
    			]
    		},
    		colnamestart: {
    			type: "string"
    		},
    		fromrow: {
    			type: "number"
    		},
    		firstrow: {
    			type: "toggle"
    		},
    		colnameend: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var serialDAT = {
    	maxInputs: 0,
    	pars: {
    		baudrate: {
    			type: "pulse"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		parity: {
    			type: "pulse"
    		},
    		rts: {
    			type: "pulse"
    		},
    		maxlines: {
    			type: "number"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"perbyte",
    				"perline",
    				"permessage"
    			]
    		},
    		port: {
    			type: "string"
    		},
    		fromop: {
    			type: "OP"
    		},
    		stopbits: {
    			type: "pulse"
    		},
    		clear: {
    			type: "pulse"
    		},
    		clamp: {
    			type: "toggle"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		bytes: {
    			type: "toggle"
    		},
    		customext: {
    			type: "string"
    		},
    		dtr: {
    			type: "pulse"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"callbacks",
    				"op"
    			]
    		},
    		databits: {
    			type: "pulse"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var tableDAT = {
    	maxInputs: 0,
    	pars: {
    		edit: {
    			type: "pulse"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		customext: {
    			type: "string"
    		},
    		removeblank: {
    			type: "toggle"
    		},
    		cols: {
    			type: "number"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		loadonstartpulse: {
    			type: "pulse"
    		},
    		write: {
    			type: "toggle"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		rows: {
    			type: "number"
    		},
    		dims: {
    			type: "toggle"
    		},
    		writepulse: {
    			type: "pulse"
    		},
    		loadonstart: {
    			type: "toggle"
    		},
    		file: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var switchDAT = {
    	maxInputs: 9999,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		index: {
    			type: "number"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		customext: {
    			type: "string"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "DAT"
    };
    var opfindDAT = {
    	maxInputs: 1,
    	pars: {
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		mindepth: {
    			type: "number"
    		},
    		pathfilter: {
    			type: "string"
    		},
    		maxops: {
    			type: "number"
    		},
    		parentpath: {
    			type: "toggle"
    		},
    		sops: {
    			type: "toggle"
    		},
    		other: {
    			type: "toggle"
    		},
    		namecol: {
    			type: "toggle"
    		},
    		limitmaxdepth: {
    			type: "toggle"
    		},
    		cookpulse: {
    			type: "pulse"
    		},
    		mats: {
    			type: "toggle"
    		},
    		limitmaxops: {
    			type: "toggle"
    		},
    		includecomponent: {
    			type: "toggle"
    		},
    		parexpressionfilter: {
    			type: "string"
    		},
    		dats: {
    			type: "toggle"
    		},
    		combinefilters: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"any"
    			]
    		},
    		maxdepth: {
    			type: "number"
    		},
    		namefilter: {
    			type: "string"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		tops: {
    			type: "toggle"
    		},
    		commentfilter: {
    			type: "string"
    		},
    		tagsfilter: {
    			type: "string"
    		},
    		tagscol: {
    			type: "toggle"
    		},
    		idcol: {
    			type: "toggle"
    		},
    		objects: {
    			type: "toggle"
    		},
    		customext: {
    			type: "string"
    		},
    		convertnone: {
    			type: "toggle"
    		},
    		component: {
    			type: "COMP"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		typefilter: {
    			type: "string"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		excludefilter: {
    			type: "string"
    		},
    		pathcol: {
    			type: "toggle"
    		},
    		relpathcol: {
    			type: "toggle"
    		},
    		parnamefilter: {
    			type: "string"
    		},
    		convertbool: {
    			type: "toggle"
    		},
    		parentfilter: {
    			type: "string"
    		},
    		casesensitive: {
    			type: "toggle"
    		},
    		chops: {
    			type: "toggle"
    		},
    		cooktimescol: {
    			type: "toggle"
    		},
    		parvaluefilter: {
    			type: "string"
    		},
    		parnondefaultonly: {
    			type: "toggle"
    		},
    		panels: {
    			type: "toggle"
    		},
    		activecook: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"auto",
    				"always"
    			]
    		},
    		typecol: {
    			type: "toggle"
    		},
    		textfilter: {
    			type: "string"
    		},
    		depthcol: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var indicesDAT = {
    	maxInputs: 1,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		level: {
    			type: "number"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		customext: {
    			type: "string"
    		},
    		origin: {
    			type: "float"
    		},
    		end: {
    			type: "float"
    		},
    		start: {
    			type: "float"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var reorderDAT = {
    	maxInputs: 1,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"reverse",
    				"replacenames",
    				"replaceindices",
    				"swapnames",
    				"swapindices",
    				"specifyname",
    				"specifyindex"
    			]
    		},
    		order: {
    			type: "string"
    		},
    		before: {
    			type: "string"
    		},
    		customext: {
    			type: "string"
    		},
    		"delete": {
    			type: "toggle"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		after: {
    			type: "string"
    		},
    		reorder: {
    			type: "menu",
    			menuitems: [
    				"row",
    				"col"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "DAT"
    };
    var udtinDAT = {
    	maxInputs: 0,
    	pars: {
    		maxlines: {
    			type: "number"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"perbyte",
    				"perline",
    				"permessage"
    			]
    		},
    		port: {
    			type: "number"
    		},
    		fromop: {
    			type: "OP"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		clear: {
    			type: "pulse"
    		},
    		clamp: {
    			type: "toggle"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		protocol: {
    			type: "menu",
    			menuitems: [
    				"faststreaming",
    				"reliablemsging"
    			]
    		},
    		shared: {
    			type: "toggle"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		customext: {
    			type: "string"
    		},
    		bytes: {
    			type: "toggle"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"callbacks",
    				"op"
    			]
    		},
    		address: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var renderpickDAT = {
    	maxInputs: 1,
    	pars: {
    		rendertop: {
    			type: "TOP"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		customext: {
    			type: "string"
    		},
    		instanceid: {
    			type: "toggle"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		pickcirstep: {
    			type: "number"
    		},
    		pickradstep: {
    			type: "number"
    		},
    		customattrib4: {
    			type: "string"
    		},
    		color: {
    			type: "toggle"
    		},
    		customattrib4type: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4",
    				"int",
    				"ivec2",
    				"ivec3",
    				"ivec4"
    			]
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		allowmulticamera: {
    			type: "toggle"
    		},
    		normal: {
    			type: "menu",
    			menuitems: [
    				"no",
    				"sopspace",
    				"worldspace",
    				"cameraspace",
    				"relativetoobj"
    			]
    		},
    		customattrib1: {
    			type: "string"
    		},
    		customattrib3type: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4",
    				"int",
    				"ivec2",
    				"ivec3",
    				"ivec4"
    			]
    		},
    		clearprev: {
    			type: "toggle"
    		},
    		pickradius: {
    			type: "number"
    		},
    		customattrib3: {
    			type: "string"
    		},
    		customattrib1type: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4",
    				"int",
    				"ivec2",
    				"ivec3",
    				"ivec4"
    			]
    		},
    		strategy: {
    			type: "menu",
    			menuitems: [
    				"select",
    				"holdfirst",
    				"holdlast",
    				"always"
    			]
    		},
    		position: {
    			type: "menu",
    			menuitems: [
    				"no",
    				"sopspace",
    				"worldspace",
    				"cameraspace",
    				"relativetoobj"
    			]
    		},
    		usepickableflags: {
    			type: "toggle"
    		},
    		depth: {
    			type: "toggle"
    		},
    		customattrib2: {
    			type: "string"
    		},
    		includenonpickable: {
    			type: "toggle"
    		},
    		uv: {
    			type: "toggle"
    		},
    		referenceobj: {
    			type: "COMP"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		activatecallbacks: {
    			type: "toggle"
    		},
    		custompickcameras: {
    			type: "COMP"
    		},
    		responsetime: {
    			type: "menu",
    			menuitems: [
    				"nextcook",
    				"thiscook"
    			]
    		},
    		customattrib2type: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4",
    				"int",
    				"ivec2",
    				"ivec3",
    				"ivec4"
    			]
    		},
    		mergeinputdat: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "DAT"
    };
    var fileinDAT = {
    	maxInputs: 0,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		customext: {
    			type: "string"
    		},
    		refresh: {
    			type: "toggle"
    		},
    		refreshpulse: {
    			type: "pulse"
    		},
    		converttable: {
    			type: "toggle"
    		},
    		file: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var opexecuteDAT = {
    	maxInputs: 1,
    	pars: {
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		edit: {
    			type: "pulse"
    		},
    		precook: {
    			type: "toggle"
    		},
    		active: {
    			type: "toggle"
    		},
    		childrename: {
    			type: "toggle"
    		},
    		namechange: {
    			type: "toggle"
    		},
    		fromop: {
    			type: "OP"
    		},
    		pathchange: {
    			type: "toggle"
    		},
    		opdelete: {
    			type: "toggle"
    		},
    		currentchildchange: {
    			type: "toggle"
    		},
    		postcook: {
    			type: "toggle"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		numchildrenchange: {
    			type: "toggle"
    		},
    		op: {
    			type: "OP"
    		},
    		extensionchange: {
    			type: "toggle"
    		},
    		customext: {
    			type: "string"
    		},
    		uichange: {
    			type: "toggle"
    		},
    		flagchange: {
    			type: "toggle"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"here",
    				"op"
    			]
    		},
    		wirechange: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var artnetDAT = {
    	maxInputs: 0,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		customext: {
    			type: "string"
    		},
    		columns: {
    			type: "string"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		poll: {
    			type: "pulse"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var touchoutDAT = {
    	maxInputs: 1,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		protocol: {
    			type: "menu",
    			menuitems: [
    				"streaming",
    				"msging",
    				"multicastmsging",
    				"_separator_",
    				"faststreaming",
    				"reliablemsging"
    			]
    		},
    		shared: {
    			type: "toggle"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		resend: {
    			type: "pulse"
    		},
    		redendantsends: {
    			type: "number"
    		},
    		customext: {
    			type: "string"
    		},
    		port: {
    			type: "number"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		address: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "DAT"
    };
    var scriptDAT = {
    	maxInputs: 9999,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		setuppars: {
    			type: "pulse"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		customext: {
    			type: "string"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var keyboardinDAT = {
    	maxInputs: 1,
    	pars: {
    		maxlines: {
    			type: "number"
    		},
    		lrmodifiers: {
    			type: "toggle"
    		},
    		active: {
    			type: "toggle"
    		},
    		keys: {
    			type: "string"
    		},
    		fromop: {
    			type: "OP"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		clear: {
    			type: "pulse"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"callbacks",
    				"op"
    			]
    		},
    		panels: {
    			type: "PanelCOMP"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		customext: {
    			type: "string"
    		},
    		shortcuts: {
    			type: "string"
    		},
    		clamp: {
    			type: "toggle"
    		},
    		perform: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var etherdreamDAT = {
    	maxInputs: 0,
    	pars: {
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		customext: {
    			type: "string"
    		},
    		columns: {
    			type: "string"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		poll: {
    			type: "pulse"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var udpinDAT = {
    	maxInputs: 0,
    	pars: {
    		maxlines: {
    			type: "number"
    		},
    		extension: {
    			type: "menu",
    			menuitems: [
    				"dat",
    				"frag",
    				"glsl",
    				"html",
    				"md",
    				"py",
    				"rtf",
    				"tsv",
    				"txt",
    				"vert",
    				"xml",
    				"languageext",
    				"customext"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"perbyte",
    				"perline",
    				"permessage"
    			]
    		},
    		port: {
    			type: "number"
    		},
    		fromop: {
    			type: "OP"
    		},
    		wordwrap: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"on",
    				"off"
    			]
    		},
    		clear: {
    			type: "pulse"
    		},
    		clamp: {
    			type: "toggle"
    		},
    		language: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"node"
    			]
    		},
    		protocol: {
    			type: "menu",
    			menuitems: [
    				"msging",
    				"multicastmsging"
    			]
    		},
    		shared: {
    			type: "toggle"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		customext: {
    			type: "string"
    		},
    		bytes: {
    			type: "toggle"
    		},
    		executeloc: {
    			type: "menu",
    			menuitems: [
    				"current",
    				"callbacks",
    				"op"
    			]
    		},
    		address: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "DAT"
    };
    var audiobandeqCHOP = {
    	maxInputs: 1,
    	pars: {
    		band12: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		band3: {
    			type: "float"
    		},
    		band10: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		band11: {
    			type: "float"
    		},
    		band2: {
    			type: "float"
    		},
    		band9: {
    			type: "float"
    		},
    		band16: {
    			type: "float"
    		},
    		band8: {
    			type: "float"
    		},
    		band5: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		drywet: {
    			type: "float"
    		},
    		band15: {
    			type: "float"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		band13: {
    			type: "float"
    		},
    		band4: {
    			type: "float"
    		},
    		band14: {
    			type: "float"
    		},
    		band6: {
    			type: "float"
    		},
    		band7: {
    			type: "float"
    		},
    		band1: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var performCHOP = {
    	maxInputs: 0,
    	pars: {
    		cookrate: {
    			type: "toggle"
    		},
    		cook: {
    			type: "toggle"
    		},
    		activeexpressions: {
    			type: "toggle"
    		},
    		cachedexpressions: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		deactivatedops: {
    			type: "toggle"
    		},
    		activeops: {
    			type: "toggle"
    		},
    		fps: {
    			type: "toggle"
    		},
    		totalgpumem: {
    			type: "toggle"
    		},
    		timeslicemsec: {
    			type: "toggle"
    		},
    		cpumemused: {
    			type: "toggle"
    		},
    		cookstate: {
    			type: "toggle"
    		},
    		cookrealtime: {
    			type: "toggle"
    		},
    		msec: {
    			type: "toggle"
    		},
    		mvreadahead: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		aclinestatus: {
    			type: "toggle"
    		},
    		gputemp: {
    			type: "toggle"
    		},
    		batterylife: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		droppedframes: {
    			type: "toggle"
    		},
    		optimizedexpression: {
    			type: "toggle"
    		},
    		gpumemused: {
    			type: "toggle"
    		},
    		batterycharging: {
    			type: "toggle"
    		},
    		batterytime: {
    			type: "toggle"
    		},
    		performfocus: {
    			type: "toggle"
    		},
    		timeslicestep: {
    			type: "toggle"
    		},
    		performmode: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		},
    		totalops: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var compositeCHOP = {
    	maxInputs: 3,
    	pars: {
    		fallfunc: {
    			type: "menu",
    			menuitems: [
    				"lin",
    				"ei",
    				"eo",
    				"cos",
    				"cub",
    				"add",
    				"holdprev"
    			]
    		},
    		match: {
    			type: "menu",
    			menuitems: [
    				"index",
    				"name",
    				"union"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		risefunc: {
    			type: "menu",
    			menuitems: [
    				"lin",
    				"ei",
    				"eo",
    				"cos",
    				"cub",
    				"add",
    				"holdprev"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		relative: {
    			type: "menu",
    			menuitems: [
    				"abs",
    				"rel",
    				"cur"
    			]
    		},
    		effect: {
    			type: "float"
    		},
    		release: {
    			type: "float"
    		},
    		end: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		peak: {
    			type: "float"
    		},
    		endunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		quatrot: {
    			type: "toggle"
    		},
    		cyclelen: {
    			type: "float"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		releaseunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		shortrot: {
    			type: "toggle"
    		},
    		rotscope: {
    			type: "string"
    		},
    		startunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		peakunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		base: {
    			type: "float"
    		},
    		start: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 2,
    	type: "CHOP"
    };
    var audiorenderCHOP = {
    	maxInputs: 1,
    	pars: {
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		outputformat: {
    			type: "menu",
    			menuitems: [
    				"Binaural",
    				"stereo",
    				"quadraphonic",
    				"fiveone",
    				"sevenone",
    				"custom",
    				"ambix"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		sourceobject: {
    			type: "COMP"
    		},
    		attenuation: {
    			type: "toggle"
    		},
    		mappingtable: {
    			type: "DAT"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		listenerobject: {
    			type: "COMP"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var transformCHOP = {
    	maxInputs: 1,
    	pars: {
    		outxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		outrord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		hint: {
    			type: "xyz"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		usehint: {
    			type: "toggle"
    		},
    		t: {
    			type: "xyz"
    		},
    		inrord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		custinputorders: {
    			type: "toggle"
    		},
    		out: {
    			type: "menu",
    			menuitems: [
    				"trs",
    				"mat"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		invertoutput: {
    			type: "toggle"
    		},
    		matop: {
    			type: "menu",
    			menuitems: [
    				"transform",
    				"pretransform"
    			]
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		invertinput: {
    			type: "toggle"
    		},
    		s: {
    			type: "xyz"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		p: {
    			type: "xyz"
    		},
    		custoutputorders: {
    			type: "toggle"
    		},
    		r: {
    			type: "xyz"
    		},
    		inxord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		invert: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var analyzeCHOP = {
    	maxInputs: 1,
    	pars: {
    		nopeakvalue: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		allowend: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		allowstart: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		valleys: {
    			type: "toggle"
    		},
    		"function": {
    			type: "menu",
    			menuitems: [
    				"average",
    				"maximum",
    				"minimum",
    				"maximumindex",
    				"minimumindex",
    				"sum",
    				"rmspower",
    				"firstpeakvalue",
    				"firstpeakindex",
    				"lastpeakvalue",
    				"lastpeakindex",
    				"highestpeakvalue",
    				"highestpeakindex",
    				"lowestpeakvalue",
    				"lowestpeakindex",
    				"totalpeaks",
    				"duplicates"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var keyframeCHOP = {
    	maxInputs: 1,
    	pars: {
    		left: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		animation: {
    			type: "COMP"
    		},
    		defval: {
    			type: "float"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		rate: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		right: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var pipeinCHOP = {
    	maxInputs: 0,
    	pars: {
    		echo: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"raw"
    			]
    		},
    		adjusttime: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		maxqueue: {
    			type: "float"
    		},
    		queued: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		maxqueueunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		address: {
    			type: "string"
    		},
    		mintarget: {
    			type: "float"
    		},
    		maxtargetunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		port: {
    			type: "number"
    		},
    		adjusttimeunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		reset: {
    			type: "pulse"
    		},
    		maxtarget: {
    			type: "float"
    		},
    		mode: {
    			type: "menu",
    			menuitems: [
    				"client",
    				"server"
    			]
    		},
    		allowscripts: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		},
    		mintargetunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var inversekinCHOP = {
    	maxInputs: 0,
    	pars: {
    		iktwist: {
    			type: "float"
    		},
    		curve: {
    			type: "SOP"
    		},
    		twistaffector: {
    			type: "COMP"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		solvertype: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"rest",
    				"capture",
    				"inverse",
    				"constraint",
    				"curve"
    			]
    		},
    		endaffector: {
    			type: "COMP"
    		},
    		boneend: {
    			type: "COMP"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		boneroot: {
    			type: "COMP"
    		},
    		scope: {
    			type: "string"
    		},
    		ikdampen: {
    			type: "float"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var extendCHOP = {
    	maxInputs: 1,
    	pars: {
    		left: {
    			type: "menu",
    			menuitems: [
    				"asis",
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		defval: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		right: {
    			type: "menu",
    			menuitems: [
    				"asis",
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var trailCHOP = {
    	maxInputs: 4,
    	pars: {
    		capture: {
    			type: "menu",
    			menuitems: [
    				"timeslice",
    				"inputcooks"
    			]
    		},
    		growlength: {
    			type: "toggle"
    		},
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		wlengthunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		setrate: {
    			type: "toggle"
    		},
    		rate: {
    			type: "float"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		wlength: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		},
    		resample: {
    			type: "toggle"
    		},
    		reset: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		samples: {
    			type: "number"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var gestureCHOP = {
    	maxInputs: 3,
    	pars: {
    		playmode: {
    			type: "menu",
    			menuitems: [
    				"locked",
    				"sequential"
    			]
    		},
    		stepreset: {
    			type: "toggle"
    		},
    		blendunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		speedunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		speed: {
    			type: "float"
    		},
    		resetcondition: {
    			type: "menu",
    			menuitems: [
    				"offtoon",
    				"on",
    				"ontooff",
    				"off"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		step: {
    			type: "toggle"
    		},
    		numbeats: {
    			type: "number"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		blend: {
    			type: "float"
    		},
    		reset: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		interp: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		},
    		fitmethod: {
    			type: "toggle"
    		}
    	},
    	minInputs: 2,
    	type: "CHOP"
    };
    var angleCHOP = {
    	maxInputs: 1,
    	pars: {
    		inunit: {
    			type: "menu",
    			menuitems: [
    				"degrees",
    				"radians",
    				"quaternions",
    				"twovectors"
    			]
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		inorder: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		outorder: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		outunit: {
    			type: "menu",
    			menuitems: [
    				"degrees",
    				"radians",
    				"quaternions",
    				"twovectors"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var trimCHOP = {
    	maxInputs: 2,
    	pars: {
    		endunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		discard: {
    			type: "menu",
    			menuitems: [
    				"exterior",
    				"interior"
    			]
    		},
    		relative: {
    			type: "menu",
    			menuitems: [
    				"abs",
    				"rel",
    				"cur",
    				"slice"
    			]
    		},
    		startunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		end: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		start: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var speedCHOP = {
    	maxInputs: 2,
    	pars: {
    		max: {
    			type: "float"
    		},
    		order: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"second",
    				"third"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		resetcondition: {
    			type: "menu",
    			menuitems: [
    				"offtoon",
    				"on",
    				"ontooff",
    				"off"
    			]
    		},
    		resetonstart: {
    			type: "toggle"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		min: {
    			type: "float"
    		},
    		limittype: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"clamp",
    				"loop",
    				"zigzag"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		resetvalue: {
    			type: "float"
    		},
    		reset: {
    			type: "toggle"
    		},
    		constant2: {
    			type: "float"
    		},
    		constant1: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		constant3: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var inversecurveCHOP = {
    	maxInputs: 1,
    	pars: {
    		guide: {
    			type: "COMP"
    		},
    		interpolation: {
    			type: "menu",
    			menuitems: [
    				"polygon",
    				"bezier",
    				"nurbs"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		mapexports: {
    			type: "toggle"
    		},
    		span1: {
    			type: "float"
    		},
    		span2: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		boneend: {
    			type: "COMP"
    		},
    		order: {
    			type: "number"
    		},
    		upvector: {
    			type: "xyz"
    		},
    		bonestart: {
    			type: "COMP"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var ltcoutCHOP = {
    	maxInputs: 0,
    	pars: {
    		exporttable: {
    			type: "DAT"
    		},
    		second: {
    			type: "number"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		user6: {
    			type: "number"
    		},
    		user3: {
    			type: "number"
    		},
    		minute: {
    			type: "number"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		frame: {
    			type: "number"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		user4: {
    			type: "number"
    		},
    		framerate: {
    			type: "float"
    		},
    		dropframe: {
    			type: "toggle"
    		},
    		audiorate: {
    			type: "float"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		user7: {
    			type: "number"
    		},
    		user8: {
    			type: "number"
    		},
    		play: {
    			type: "toggle"
    		},
    		fielduser: {
    			type: "toggle"
    		},
    		user2: {
    			type: "number"
    		},
    		reset: {
    			type: "toggle"
    		},
    		user5: {
    			type: "number"
    		},
    		user1: {
    			type: "number"
    		},
    		scope: {
    			type: "string"
    		},
    		hour: {
    			type: "number"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var timelineCHOP = {
    	maxInputs: 0,
    	pars: {
    		autoexportroot: {
    			type: "OP"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		rangestart: {
    			type: "toggle"
    		},
    		signature2: {
    			type: "toggle"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		rangeend: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		bpm: {
    			type: "toggle"
    		},
    		play: {
    			type: "toggle"
    		},
    		signature1: {
    			type: "toggle"
    		},
    		rate: {
    			type: "toggle"
    		},
    		end: {
    			type: "toggle"
    		},
    		frame: {
    			type: "toggle"
    		},
    		absframe: {
    			type: "toggle"
    		},
    		abssecond: {
    			type: "toggle"
    		},
    		start: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		},
    		op: {
    			type: "OP"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var heliosdacCHOP = {
    	maxInputs: 1,
    	pars: {
    		queuetime: {
    			type: "float"
    		},
    		xscale: {
    			type: "float"
    		},
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		redscale: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		bluescale: {
    			type: "float"
    		},
    		intensityscale: {
    			type: "float"
    		},
    		yscale: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		device: {
    			type: "string"
    		},
    		greenscale: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var leuzerod4CHOP = {
    	maxInputs: 0,
    	pars: {
    		rod4porotocol: {
    			type: "menu",
    			menuitems: [
    				"binary",
    				"ascii"
    			]
    		},
    		areaofinterest: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"distancebased",
    				"boundingbox"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		lowerleft1: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		rotate: {
    			type: "float"
    		},
    		maxpointdistance: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		upperright1: {
    			type: "float"
    		},
    		allowmovementoutside: {
    			type: "toggle"
    		},
    		boundingboxmask: {
    			type: "TOP"
    		},
    		active: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		outputmode: {
    			type: "menu",
    			menuitems: [
    				"rawdata",
    				"blobtracking"
    			]
    		},
    		port: {
    			type: "number"
    		},
    		maxdistance: {
    			type: "float"
    		},
    		maxblobmovement: {
    			type: "float"
    		},
    		maxblobs: {
    			type: "number"
    		},
    		upperright2: {
    			type: "float"
    		},
    		inputcoordinate: {
    			type: "menu",
    			menuitems: [
    				"polar",
    				"cartesian"
    			]
    		},
    		netaddress: {
    			type: "string"
    		},
    		lowerleft2: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var expressionCHOP = {
    	maxInputs: 9999,
    	pars: {
    		limitnum: {
    			type: "number"
    		},
    		expr0: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		limitexpr: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		chanperexpr: {
    			type: "number"
    		},
    		expr5: {
    			type: "float"
    		},
    		expr2: {
    			type: "float"
    		},
    		expr4: {
    			type: "float"
    		},
    		expr3: {
    			type: "float"
    		},
    		numexpr: {
    			type: "number"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		expr1: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var shuffleCHOP = {
    	maxInputs: 1,
    	pars: {
    		method: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"swap",
    				"seqname",
    				"seqall",
    				"seqn",
    				"seqeveryn",
    				"sallsamples",
    				"splitall",
    				"splitn",
    				"spliteveryn"
    			]
    		},
    		firstsample: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		nval: {
    			type: "number"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var timerCHOP = {
    	maxInputs: 2,
    	pars: {
    		outcycle: {
    			type: "toggle"
    		},
    		gotodone: {
    			type: "pulse"
    		},
    		length: {
    			type: "float"
    		},
    		speed: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		cycleendalert: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		notifyunits: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		channelcolumns: {
    			type: "string"
    		},
    		outcyclepulse: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		cyclelimit: {
    			type: "toggle"
    		},
    		segunits: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		outdone: {
    			type: "toggle"
    		},
    		outrunningcount: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		cuepoint: {
    			type: "float"
    		},
    		outcumulativecount: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		outsegpulse: {
    			type: "toggle"
    		},
    		outseg: {
    			type: "toggle"
    		},
    		outready: {
    			type: "toggle"
    		},
    		outtimerpulse: {
    			type: "toggle"
    		},
    		outrunning: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		outdonepulse: {
    			type: "toggle"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		rate: {
    			type: "float"
    		},
    		segmethod: {
    			type: "menu",
    			menuitems: [
    				"serial",
    				"parallel"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		datoutput: {
    			type: "toggle"
    		},
    		lengthunits: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		outtimeractive: {
    			type: "toggle"
    		},
    		outreadypulse: {
    			type: "toggle"
    		},
    		cueunits: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		gotoendcycle: {
    			type: "pulse"
    		},
    		gotonextseg: {
    			type: "pulse"
    		},
    		gotoprevseg: {
    			type: "pulse"
    		},
    		outinit: {
    			type: "toggle"
    		},
    		initialize: {
    			type: "pulse"
    		},
    		maxcycles: {
    			type: "number"
    		},
    		active: {
    			type: "toggle"
    		},
    		segdat: {
    			type: "DAT"
    		},
    		playmode: {
    			type: "menu",
    			menuitems: [
    				"lock",
    				"sequential"
    			]
    		},
    		ondone: {
    			type: "menu",
    			menuitems: [
    				"donothing",
    				"reinit",
    				"restart"
    			]
    		},
    		interpolation: {
    			type: "menu",
    			menuitems: [
    				"steptovalue",
    				"lineartovalue",
    				"easeintovalue",
    				"easeouttovalue",
    				"easeinouttovalue"
    			]
    		},
    		delayunits: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		cuepulse: {
    			type: "pulse"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		outcycleplusfraction: {
    			type: "toggle"
    		},
    		start: {
    			type: "pulse"
    		},
    		exitendcycle: {
    			type: "pulse"
    		},
    		cycle: {
    			type: "toggle"
    		},
    		outdelayfraction: {
    			type: "toggle"
    		},
    		infocolumns: {
    			type: "string"
    		},
    		outsegplusfraction: {
    			type: "toggle"
    		},
    		outfraction: {
    			type: "toggle"
    		},
    		play: {
    			type: "toggle"
    		},
    		outdelaycount: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		delay: {
    			type: "float"
    		},
    		outtimercount: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		cue: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var audiospectrumCHOP = {
    	maxInputs: 1,
    	pars: {
    		mode: {
    			type: "menu",
    			menuitems: [
    				"visual",
    				"timetoraw",
    				"rawtotime"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		fftsize: {
    			type: "menu",
    			menuitems: [
    				"64",
    				"128",
    				"256",
    				"512",
    				"1024",
    				"2048",
    				"4096",
    				"8192",
    				"16384"
    			]
    		},
    		highfreqboost: {
    			type: "float"
    		},
    		outputmenu: {
    			type: "menu",
    			menuitems: [
    				"matchtofrequency",
    				"setmanually"
    			]
    		},
    		outlength: {
    			type: "number"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		frequencylog: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var nullCHOP = {
    	maxInputs: 1,
    	pars: {
    		checkrange: {
    			type: "toggle"
    		},
    		checknames: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		cooktype: {
    			type: "menu",
    			menuitems: [
    				"auto",
    				"always",
    				"selective"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		checkvalues: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var natnetinCHOP = {
    	maxInputs: 0,
    	pars: {
    		dataport: {
    			type: "number"
    		},
    		connectiontype: {
    			type: "menu",
    			menuitems: [
    				"mutlicast",
    				"unicast"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		localaddress: {
    			type: "string"
    		},
    		rate: {
    			type: "number"
    		},
    		netaddress: {
    			type: "string"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		commandport: {
    			type: "number"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var audiodynamicsCHOP = {
    	maxInputs: 2,
    	pars: {
    		thresholdcompressor: {
    			type: "float"
    		},
    		enablelimiter: {
    			type: "toggle"
    		},
    		enablecompressor: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		chanlinkinglim: {
    			type: "menu",
    			menuitems: [
    				"compequally",
    				"compindividually"
    			]
    		},
    		releasecompressor: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		drywet: {
    			type: "float"
    		},
    		releaselimiter: {
    			type: "float"
    		},
    		kneelimiter: {
    			type: "float"
    		},
    		chanlinkingcomp: {
    			type: "menu",
    			menuitems: [
    				"compequally",
    				"compindividually"
    			]
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		thresholdlimiter: {
    			type: "float"
    		},
    		compressiontype: {
    			type: "menu",
    			menuitems: [
    				"compagc",
    				"compmus"
    			]
    		},
    		ratiocompressor: {
    			type: "float"
    		},
    		gaincompressor: {
    			type: "float"
    		},
    		kneecompressor: {
    			type: "float"
    		},
    		attackcompressor: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		},
    		inputgain: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var audiostreaminCHOP = {
    	maxInputs: 0,
    	pars: {
    		autoexportroot: {
    			type: "OP"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		videostreamintop: {
    			type: "TOP"
    		},
    		url: {
    			type: "string"
    		},
    		volume: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		opentimeout: {
    			type: "float"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		play: {
    			type: "float"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var renameCHOP = {
    	maxInputs: 2,
    	pars: {
    		renamefrom: {
    			type: "string"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		renameto: {
    			type: "string"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var audiofileinCHOP = {
    	maxInputs: 0,
    	pars: {
    		mono: {
    			type: "toggle"
    		},
    		speed: {
    			type: "float"
    		},
    		trimend: {
    			type: "float"
    		},
    		trim: {
    			type: "toggle"
    		},
    		indexunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		opentimeout: {
    			type: "float"
    		},
    		reloadpulse: {
    			type: "pulse"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		volume: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		repeat: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on"
    			]
    		},
    		index: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		playmode: {
    			type: "menu",
    			menuitems: [
    				"locked",
    				"specify",
    				"sequential"
    			]
    		},
    		cuepoint: {
    			type: "float"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		cuepulse: {
    			type: "pulse"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		prereadlengthunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		trimendunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		play: {
    			type: "toggle"
    		},
    		prereadlength: {
    			type: "float"
    		},
    		cuepointunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		trimstart: {
    			type: "float"
    		},
    		trimstartunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		cue: {
    			type: "toggle"
    		},
    		file: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var scurveCHOP = {
    	maxInputs: 1,
    	pars: {
    		linearize: {
    			type: "float"
    		},
    		append: {
    			type: "number"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		fromrange1: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"halfcosine",
    				"log",
    				"atan"
    			]
    		},
    		steepness: {
    			type: "float"
    		},
    		fromrange2: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		left: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		length: {
    			type: "number"
    		},
    		channelname: {
    			type: "string"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		defval: {
    			type: "float"
    		},
    		torange1: {
    			type: "float"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		torange2: {
    			type: "float"
    		},
    		prepend: {
    			type: "number"
    		},
    		rate: {
    			type: "float"
    		},
    		bias: {
    			type: "float"
    		},
    		right: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var pipeoutCHOP = {
    	maxInputs: 1,
    	pars: {
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		upload: {
    			type: "pulse"
    		},
    		cookalways: {
    			type: "toggle"
    		},
    		sendscript: {
    			type: "pulse"
    		},
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		port: {
    			type: "number"
    		},
    		pulse: {
    			type: "toggle"
    		},
    		echo: {
    			type: "toggle"
    		},
    		sendsingle: {
    			type: "toggle"
    		},
    		sample: {
    			type: "menu",
    			menuitems: [
    				"scur",
    				"sstart"
    			]
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		scope: {
    			type: "string"
    		},
    		script: {
    			type: "string"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		sendinput: {
    			type: "toggle"
    		},
    		mode: {
    			type: "menu",
    			menuitems: [
    				"client",
    				"server"
    			]
    		},
    		address: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var objectCHOP = {
    	maxInputs: 2,
    	pars: {
    		reference: {
    			type: "COMP"
    		},
    		bearing: {
    			type: "xyz"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		endunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		smoothrotate: {
    			type: "toggle"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		target: {
    			type: "COMP"
    		},
    		dat: {
    			type: "DAT"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		end: {
    			type: "float"
    		},
    		cookpast: {
    			type: "toggle"
    		},
    		bearingref: {
    			type: "menu",
    			menuitems: [
    				"x",
    				"y",
    				"z",
    				"vector"
    			]
    		},
    		tscopex: {
    			type: "string"
    		},
    		nameformat: {
    			type: "menu",
    			menuitems: [
    				"channel",
    				"target",
    				"reference"
    			]
    		},
    		tscopey: {
    			type: "string"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		left: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		outputrange: {
    			type: "menu",
    			menuitems: [
    				"currentframe",
    				"timeslice",
    				"startend"
    			]
    		},
    		defval: {
    			type: "float"
    		},
    		tscopez: {
    			type: "string"
    		},
    		compute: {
    			type: "menu",
    			menuitems: [
    				"translate",
    				"rotate",
    				"scale",
    				"transform",
    				"bearing",
    				"singlebear",
    				"distance",
    				"invsqr"
    			]
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		startunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		appendattribs: {
    			type: "toggle"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		right: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		start: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var filterCHOP = {
    	maxInputs: 1,
    	pars: {
    		passes: {
    			type: "number"
    		},
    		ramptolerance: {
    			type: "float"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		filterpersample: {
    			type: "toggle"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		scope: {
    			type: "string"
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"gauss",
    				"halfgauss",
    				"box",
    				"halfbox",
    				"edge",
    				"sharpen",
    				"despike",
    				"ramp"
    			]
    		},
    		spike: {
    			type: "float"
    		},
    		ramprate: {
    			type: "float"
    		},
    		effect: {
    			type: "float"
    		},
    		reset: {
    			type: "toggle"
    		},
    		width: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		widthunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var syncoutCHOP = {
    	maxInputs: 1,
    	pars: {
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		port: {
    			type: "number"
    		},
    		banclients: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		clienttimeouts: {
    			type: "number"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		banclienttimeouts: {
    			type: "number"
    		},
    		clearstats: {
    			type: "pulse"
    		},
    		timeout: {
    			type: "number"
    		},
    		multicastaddress: {
    			type: "string"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var slopeCHOP = {
    	maxInputs: 1,
    	pars: {
    		type: {
    			type: "menu",
    			menuitems: [
    				"slope",
    				"accel",
    				"slacc"
    			]
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"pc",
    				"cn",
    				"pn"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var lagCHOP = {
    	maxInputs: 1,
    	pars: {
    		lagunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		lagsamples: {
    			type: "toggle"
    		},
    		lagmethod: {
    			type: "menu",
    			menuitems: [
    				"value",
    				"amp",
    				"mag",
    				"rotation"
    			]
    		},
    		overshoot2: {
    			type: "float"
    		},
    		slope1: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		lag2: {
    			type: "float"
    		},
    		overshoot1: {
    			type: "float"
    		},
    		accel2: {
    			type: "float"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		aclamp: {
    			type: "toggle"
    		},
    		overshootunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		accel1: {
    			type: "float"
    		},
    		slope2: {
    			type: "float"
    		},
    		lag1: {
    			type: "float"
    		},
    		reset: {
    			type: "toggle"
    		},
    		clamp: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var outCHOP = {
    	maxInputs: 1,
    	pars: {
    		autoexportroot: {
    			type: "OP"
    		},
    		label: {
    			type: "string"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var noiseCHOP = {
    	maxInputs: 1,
    	pars: {
    		harmon: {
    			type: "number"
    		},
    		constrstart: {
    			type: "float"
    		},
    		r: {
    			type: "xyz"
    		},
    		periodunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		left: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		t: {
    			type: "xyz"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"sparse",
    				"hermite",
    				"harmonic",
    				"brownian",
    				"random",
    				"alligator"
    			]
    		},
    		right: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		normal: {
    			type: "toggle"
    		},
    		end: {
    			type: "float"
    		},
    		period: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		numint: {
    			type: "number"
    		},
    		endunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		constraint: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"start",
    				"end",
    				"offset",
    				"endpoints"
    			]
    		},
    		spread: {
    			type: "float"
    		},
    		channelname: {
    			type: "string"
    		},
    		p: {
    			type: "xyz"
    		},
    		start: {
    			type: "float"
    		},
    		s: {
    			type: "xyz"
    		},
    		constrend: {
    			type: "float"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		seed: {
    			type: "float"
    		},
    		xord: {
    			type: "menu",
    			menuitems: [
    				"srt",
    				"str",
    				"rst",
    				"rts",
    				"tsr",
    				"trs"
    			]
    		},
    		defval: {
    			type: "float"
    		},
    		exp: {
    			type: "float"
    		},
    		rough: {
    			type: "float"
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		rate: {
    			type: "float"
    		},
    		reset: {
    			type: "toggle"
    		},
    		amp: {
    			type: "float"
    		},
    		constrmean: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		},
    		startunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var springCHOP = {
    	maxInputs: 1,
    	pars: {
    		autoexportroot: {
    			type: "OP"
    		},
    		mass: {
    			type: "float"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		initspeed: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"disp",
    				"force"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		initpos: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		condfromchan: {
    			type: "toggle"
    		},
    		dampingk: {
    			type: "float"
    		},
    		springk: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var feedbackCHOP = {
    	maxInputs: 2,
    	pars: {
    		autoexportroot: {
    			type: "OP"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		delta: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		output: {
    			type: "menu",
    			menuitems: [
    				"previous",
    				"shift",
    				"sample"
    			]
    		},
    		reset: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var realsenseCHOP = {
    	maxInputs: 0,
    	pars: {
    		personsworldcenterpos: {
    			type: "toggle"
    		},
    		faceexpressions: {
    			type: "toggle"
    		},
    		handsrotation: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"absolute",
    				"relative"
    			]
    		},
    		sensor: {
    			type: "string"
    		},
    		twofingerpinch: {
    			type: "toggle"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		thumbs: {
    			type: "toggle"
    		},
    		personscolorcenterpos: {
    			type: "toggle"
    		},
    		facelandmarkscolor: {
    			type: "toggle"
    		},
    		smoothing: {
    			type: "toggle"
    		},
    		fullpinch: {
    			type: "toggle"
    		},
    		facelandmarksworld: {
    			type: "toggle"
    		},
    		tap: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		model: {
    			type: "menu",
    			menuitems: [
    				"f200",
    				"r200",
    				"sr300"
    			]
    		},
    		personsskelworldpos: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		smoothrad: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		click: {
    			type: "toggle"
    		},
    		personsskelcolorpos: {
    			type: "toggle"
    		},
    		fist: {
    			type: "toggle"
    		},
    		maxperson: {
    			type: "number"
    		},
    		active: {
    			type: "toggle"
    		},
    		handscolorpos: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		markertop: {
    			type: "TOP"
    		},
    		faceworldpos: {
    			type: "toggle"
    		},
    		spreadfingers: {
    			type: "toggle"
    		},
    		handsworldpos: {
    			type: "toggle"
    		},
    		swipe: {
    			type: "toggle"
    		},
    		smoothstrength: {
    			type: "float"
    		},
    		facerotation: {
    			type: "toggle"
    		},
    		smoothtype: {
    			type: "menu",
    			menuitems: [
    				"stabilizer",
    				"weighted",
    				"quadratic",
    				"spring"
    			]
    		},
    		weights: {
    			type: "number"
    		},
    		personscolorbounds: {
    			type: "toggle"
    		},
    		vsign: {
    			type: "toggle"
    		},
    		facebounds: {
    			type: "toggle"
    		},
    		wave: {
    			type: "toggle"
    		},
    		mode: {
    			type: "menu",
    			menuitems: [
    				"fingerface",
    				"marker"
    			]
    		},
    		separatehands: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var fileoutCHOP = {
    	maxInputs: 1,
    	pars: {
    		interval: {
    			type: "number"
    		},
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		write: {
    			type: "pulse"
    		},
    		scope: {
    			type: "string"
    		},
    		file: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var leapmotionCHOP = {
    	maxInputs: 0,
    	pars: {
    		handvelocity: {
    			type: "toggle"
    		},
    		keytapgestures: {
    			type: "number"
    		},
    		grabstrength: {
    			type: "toggle"
    		},
    		hmd: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"on",
    				"off"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		fingersperhand: {
    			type: "number"
    		},
    		statuschannels: {
    			type: "toggle"
    		},
    		fingersize: {
    			type: "toggle"
    		},
    		fingerrotation: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		circlegestures: {
    			type: "number"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		fingerjoints: {
    			type: "toggle"
    		},
    		handsphere: {
    			type: "toggle"
    		},
    		hands: {
    			type: "number"
    		},
    		screentapgestures: {
    			type: "number"
    		},
    		active: {
    			type: "toggle"
    		},
    		namedhands: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		namedfingers: {
    			type: "toggle"
    		},
    		fingerextended: {
    			type: "toggle"
    		},
    		swipegestures: {
    			type: "number"
    		},
    		debugchannels: {
    			type: "toggle"
    		},
    		pinchstrength: {
    			type: "toggle"
    		},
    		righthands: {
    			type: "number"
    		},
    		tools: {
    			type: "number"
    		},
    		scope: {
    			type: "string"
    		},
    		lefthands: {
    			type: "number"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var oscoutCHOP = {
    	maxInputs: 1,
    	pars: {
    		cookalways: {
    			type: "toggle"
    		},
    		active: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		maxsize: {
    			type: "float"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"sample",
    				"timeslice",
    				"transpose"
    			]
    		},
    		port: {
    			type: "number"
    		},
    		sendevents: {
    			type: "toggle"
    		},
    		maxbytes: {
    			type: "number"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		protocol: {
    			type: "menu",
    			menuitems: [
    				"msging",
    				"multicastmsging",
    				"reliablemsging"
    			]
    		},
    		maxsizeunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		numericformat: {
    			type: "menu",
    			menuitems: [
    				"int",
    				"float",
    				"double"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		netaddress: {
    			type: "string"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var serialCHOP = {
    	maxInputs: 1,
    	pars: {
    		autoexportroot: {
    			type: "OP"
    		},
    		script14: {
    			type: "string"
    		},
    		script7: {
    			type: "string"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		stopbits: {
    			type: "menu",
    			menuitems: [
    				"1",
    				"2"
    			]
    		},
    		script10: {
    			type: "string"
    		},
    		script11: {
    			type: "string"
    		},
    		script13: {
    			type: "string"
    		},
    		script5: {
    			type: "string"
    		},
    		script4: {
    			type: "string"
    		},
    		script3: {
    			type: "string"
    		},
    		script8: {
    			type: "string"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		script1: {
    			type: "string"
    		},
    		baudrate: {
    			type: "menu",
    			menuitems: [
    				"1200",
    				"2400",
    				"9600",
    				"19200",
    				"38400",
    				"57600",
    				"115200",
    				"230400",
    				"460800",
    				"921600",
    				"1382400"
    			]
    		},
    		script15: {
    			type: "string"
    		},
    		active: {
    			type: "toggle"
    		},
    		parity: {
    			type: "menu",
    			menuitems: [
    				"even",
    				"odd",
    				"none"
    			]
    		},
    		script6: {
    			type: "string"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		script12: {
    			type: "string"
    		},
    		scope: {
    			type: "string"
    		},
    		state: {
    			type: "menu",
    			menuitems: [
    				"offtoon",
    				"on",
    				"ontooff",
    				"off",
    				"valuechange"
    			]
    		},
    		port: {
    			type: "string"
    		},
    		script0: {
    			type: "string"
    		},
    		script2: {
    			type: "string"
    		},
    		script9: {
    			type: "string"
    		},
    		databits: {
    			type: "menu",
    			menuitems: [
    				"6",
    				"7",
    				"8",
    				"9"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var interpolateCHOP = {
    	maxInputs: 9999,
    	pars: {
    		overlap: {
    			type: "menu",
    			menuitems: [
    				"avg",
    				"first",
    				"last"
    			]
    		},
    		blendfunc: {
    			type: "menu",
    			menuitems: [
    				"lin",
    				"ei",
    				"eo",
    				"cos",
    				"cub",
    				"add",
    				"holdprev"
    			]
    		},
    		match: {
    			type: "menu",
    			menuitems: [
    				"index",
    				"name"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var scriptCHOP = {
    	maxInputs: 9999,
    	pars: {
    		setuppars: {
    			type: "pulse"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var handleCHOP = {
    	maxInputs: 1,
    	pars: {
    		preroll: {
    			type: "number"
    		},
    		iterations: {
    			type: "number"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		source: {
    			type: "COMP"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		fixed: {
    			type: "COMP"
    		},
    		init: {
    			type: "float"
    		},
    		delta: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var syncinCHOP = {
    	maxInputs: 0,
    	pars: {
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		port: {
    			type: "number"
    		},
    		timeout: {
    			type: "number"
    		},
    		multicastaddress: {
    			type: "string"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var clockCHOP = {
    	maxInputs: 1,
    	pars: {
    		autoexportroot: {
    			type: "OP"
    		},
    		ampm: {
    			type: "string"
    		},
    		longitude1: {
    			type: "float"
    		},
    		northsouth: {
    			type: "menu",
    			menuitems: [
    				"north",
    				"south"
    			]
    		},
    		output: {
    			type: "menu",
    			menuitems: [
    				"units",
    				"fractions"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		startref: {
    			type: "menu",
    			menuitems: [
    				"jan1",
    				"program"
    			]
    		},
    		min: {
    			type: "string"
    		},
    		week: {
    			type: "string"
    		},
    		latitude2: {
    			type: "float"
    		},
    		msec: {
    			type: "string"
    		},
    		eastwest: {
    			type: "menu",
    			menuitems: [
    				"east",
    				"west"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		houradjust: {
    			type: "float"
    		},
    		declination: {
    			type: "string"
    		},
    		month: {
    			type: "string"
    		},
    		hourformat: {
    			type: "menu",
    			menuitems: [
    				"12",
    				"24"
    			]
    		},
    		sunphase: {
    			type: "string"
    		},
    		sunrise: {
    			type: "string"
    		},
    		latitude1: {
    			type: "float"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		sec: {
    			type: "string"
    		},
    		longitude2: {
    			type: "float"
    		},
    		day: {
    			type: "string"
    		},
    		year: {
    			type: "string"
    		},
    		yday: {
    			type: "string"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		wday: {
    			type: "string"
    		},
    		sunset: {
    			type: "string"
    		},
    		moonphase: {
    			type: "string"
    		},
    		scope: {
    			type: "string"
    		},
    		hour: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var infoCHOP = {
    	maxInputs: 1,
    	pars: {
    		passive: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		range1: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		values: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"inside",
    				"outside"
    			]
    		},
    		iscope: {
    			type: "string"
    		},
    		op: {
    			type: "OP"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		range2: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var audiomovieCHOP = {
    	maxInputs: 0,
    	pars: {
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		prereadlengthunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		opentimeout: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		moviefileintop: {
    			type: "TOP"
    		},
    		syncoffset: {
    			type: "float"
    		},
    		play: {
    			type: "toggle"
    		},
    		prereadlength: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		index: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		},
    		syncoffsetunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var audiostreamoutCHOP = {
    	maxInputs: 1,
    	pars: {
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		streamname: {
    			type: "string"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		port: {
    			type: "number"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var touchinCHOP = {
    	maxInputs: 0,
    	pars: {
    		queuevariance: {
    			type: "float"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		active: {
    			type: "toggle"
    		},
    		syncports: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on"
    			]
    		},
    		adjusttime: {
    			type: "float"
    		},
    		maxqueue: {
    			type: "float"
    		},
    		queuetarget: {
    			type: "float"
    		},
    		port: {
    			type: "number"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		adjusttimeunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		queuetargetunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		recover: {
    			type: "toggle"
    		},
    		queuevarianceunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		protocol: {
    			type: "menu",
    			menuitems: [
    				"streaming",
    				"msging",
    				"multicastmsging",
    				"_separator_",
    				"faststreaming",
    				"reliablemsging"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		maxqueueunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		address: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var fanCHOP = {
    	maxInputs: 1,
    	pars: {
    		channame: {
    			type: "string"
    		},
    		quantize: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		alloff: {
    			type: "menu",
    			menuitems: [
    				"set0",
    				"setneg"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		fanop: {
    			type: "menu",
    			menuitems: [
    				"out",
    				"in"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		range: {
    			type: "menu",
    			menuitems: [
    				"clamp",
    				"loop",
    				"zero"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var parameterCHOP = {
    	maxInputs: 0,
    	pars: {
    		ops: {
    			type: "OP"
    		},
    		renamefrom: {
    			type: "string"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		parameters: {
    			type: "string"
    		},
    		nameformat: {
    			type: "menu",
    			menuitems: [
    				"parameter",
    				"op",
    				"path"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		renameto: {
    			type: "string"
    		},
    		builtin: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		custom: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var midiinCHOP = {
    	maxInputs: 0,
    	pars: {
    		progname: {
    			type: "string"
    		},
    		exname5: {
    			type: "string"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		pitchname: {
    			type: "string"
    		},
    		notename: {
    			type: "string"
    		},
    		notenorm: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"0to1"
    			]
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		controltype: {
    			type: "menu",
    			menuitems: [
    				"index",
    				"n0",
    				"n1",
    				"n2",
    				"n3",
    				"n4",
    				"n5",
    				"n6",
    				"n7",
    				"n8",
    				"n9",
    				"n10",
    				"n11",
    				"n12",
    				"n13",
    				"n14",
    				"n15",
    				"n16",
    				"n17",
    				"n18",
    				"n19",
    				"n20",
    				"n21",
    				"n22",
    				"n23"
    			]
    		},
    		timerperiod: {
    			type: "string"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		exmsg12: {
    			type: "string"
    		},
    		songpos: {
    			type: "string"
    		},
    		exmsg1: {
    			type: "string"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		exmsg8: {
    			type: "string"
    		},
    		exmsg11: {
    			type: "string"
    		},
    		pulsename: {
    			type: "string"
    		},
    		endunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		rampname: {
    			type: "string"
    		},
    		barperiod: {
    			type: "string"
    		},
    		exmsg7: {
    			type: "string"
    		},
    		prefix: {
    			type: "string"
    		},
    		velocity: {
    			type: "menu",
    			menuitems: [
    				"veloff",
    				"velencode",
    				"velsep"
    			]
    		},
    		barstart: {
    			type: "string"
    		},
    		exname1: {
    			type: "string"
    		},
    		exname6: {
    			type: "string"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"7bit",
    				"14bit"
    			]
    		},
    		exname3: {
    			type: "string"
    		},
    		exname10: {
    			type: "string"
    		},
    		id: {
    			type: "string"
    		},
    		exname9: {
    			type: "string"
    		},
    		rate: {
    			type: "float"
    		},
    		exmsg10: {
    			type: "string"
    		},
    		reset: {
    			type: "toggle"
    		},
    		exmsg5: {
    			type: "string"
    		},
    		timerstart: {
    			type: "string"
    		},
    		onebased: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		},
    		startunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		notemeth: {
    			type: "menu",
    			menuitems: [
    				"mult",
    				"sep"
    			]
    		},
    		exmsg4: {
    			type: "string"
    		},
    		exmsg2: {
    			type: "string"
    		},
    		notescope: {
    			type: "string"
    		},
    		exname7: {
    			type: "string"
    		},
    		simplified: {
    			type: "toggle"
    		},
    		pressname: {
    			type: "string"
    		},
    		exmsg3: {
    			type: "string"
    		},
    		exname2: {
    			type: "string"
    		},
    		end: {
    			type: "float"
    		},
    		exmsg6: {
    			type: "string"
    		},
    		device: {
    			type: "DAT"
    		},
    		barname: {
    			type: "string"
    		},
    		record: {
    			type: "toggle"
    		},
    		left: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		aftername: {
    			type: "string"
    		},
    		right: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		exmsg9: {
    			type: "string"
    		},
    		channel: {
    			type: "string"
    		},
    		source: {
    			type: "menu",
    			menuitems: [
    				"device",
    				"file"
    			]
    		},
    		recordtype: {
    			type: "menu",
    			menuitems: [
    				"single",
    				"current",
    				"ind",
    				"timeline"
    			]
    		},
    		exname8: {
    			type: "string"
    		},
    		controlname: {
    			type: "string"
    		},
    		exname4: {
    			type: "string"
    		},
    		controlind: {
    			type: "string"
    		},
    		barmsg: {
    			type: "string"
    		},
    		exname12: {
    			type: "string"
    		},
    		defval: {
    			type: "float"
    		},
    		entire: {
    			type: "toggle"
    		},
    		ticks: {
    			type: "number"
    		},
    		norm: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"0to1",
    				"-1to1",
    				"onoff"
    			]
    		},
    		unwrap: {
    			type: "toggle"
    		},
    		exname11: {
    			type: "string"
    		},
    		start: {
    			type: "float"
    		},
    		velname: {
    			type: "string"
    		},
    		file: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var functionCHOP = {
    	maxInputs: 2,
    	pars: {
    		expval: {
    			type: "float"
    		},
    		match: {
    			type: "menu",
    			menuitems: [
    				"index",
    				"name"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		ninfval: {
    			type: "float"
    		},
    		func: {
    			type: "menu",
    			menuitems: [
    				"sqrt",
    				"abs",
    				"sign",
    				"cos",
    				"sin",
    				"tan",
    				"acos",
    				"asin",
    				"atan",
    				"atan2",
    				"cosh",
    				"sinh",
    				"tanh",
    				"log",
    				"logb",
    				"ln",
    				"pow10",
    				"exp",
    				"powe",
    				"powb",
    				"pow",
    				"dbtopower",
    				"powertodb",
    				"dbtoamp",
    				"amptodb"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		baseval: {
    			type: "float"
    		},
    		domval: {
    			type: "float"
    		},
    		pinfval: {
    			type: "float"
    		},
    		error: {
    			type: "menu",
    			menuitems: [
    				"abort",
    				"replace",
    				"useprev"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		angunit: {
    			type: "menu",
    			menuitems: [
    				"deg",
    				"rad",
    				"cycle"
    			]
    		},
    		divval: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var selectCHOP = {
    	maxInputs: 1,
    	pars: {
    		renamefrom: {
    			type: "string"
    		},
    		chop: {
    			type: "CHOP"
    		},
    		renameto: {
    			type: "string"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		autoprefix: {
    			type: "toggle"
    		},
    		align: {
    			type: "menu",
    			menuitems: [
    				"auto",
    				"none",
    				"stretch",
    				"start",
    				"end",
    				"shift1",
    				"trim1",
    				"stretch1",
    				"trim",
    				"squash"
    			]
    		},
    		channames: {
    			type: "string"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var ltcinCHOP = {
    	maxInputs: 1,
    	pars: {
    		inputrate: {
    			type: "float"
    		},
    		debugchans: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		userfields: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		exporttable: {
    			type: "DAT"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var joinCHOP = {
    	maxInputs: 9999,
    	pars: {
    		transscopey: {
    			type: "string"
    		},
    		transscopez: {
    			type: "string"
    		},
    		match: {
    			type: "menu",
    			menuitems: [
    				"index",
    				"name"
    			]
    		},
    		stepscope: {
    			type: "string"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		cyclelen: {
    			type: "float"
    		},
    		blendfunc: {
    			type: "menu",
    			menuitems: [
    				"lin",
    				"ei",
    				"eo",
    				"cos",
    				"cub",
    				"add",
    				"holdprev"
    			]
    		},
    		rotscope: {
    			type: "string"
    		},
    		blendbyinput: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		blendbias: {
    			type: "float"
    		},
    		blendmethod: {
    			type: "menu",
    			menuitems: [
    				"pre",
    				"ovl",
    				"ins"
    			]
    		},
    		quatrot: {
    			type: "toggle"
    		},
    		blendregion: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		transscopex: {
    			type: "string"
    		},
    		blendscope: {
    			type: "string"
    		},
    		step: {
    			type: "float"
    		},
    		shortrot: {
    			type: "toggle"
    		},
    		blendregionunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var triggerCHOP = {
    	maxInputs: 1,
    	pars: {
    		release: {
    			type: "float"
    		},
    		triggeron: {
    			type: "menu",
    			menuitems: [
    				"increase",
    				"decrease"
    			]
    		},
    		threshdown: {
    			type: "float"
    		},
    		decay: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		rate: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		mintrigger: {
    			type: "float"
    		},
    		sustain: {
    			type: "float"
    		},
    		retrigger: {
    			type: "float"
    		},
    		multitriggeradd: {
    			type: "toggle"
    		},
    		peaklen: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		peaklenunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		threshold: {
    			type: "toggle"
    		},
    		triggerpulse: {
    			type: "pulse"
    		},
    		minsustainunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		threshup: {
    			type: "float"
    		},
    		releaseunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		mintriggerunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		delay: {
    			type: "float"
    		},
    		dshape: {
    			type: "menu",
    			menuitems: [
    				"linear",
    				"easein",
    				"easeout",
    				"halfcos"
    			]
    		},
    		minsustain: {
    			type: "float"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		clamppeak: {
    			type: "toggle"
    		},
    		specifyrate: {
    			type: "toggle"
    		},
    		channame: {
    			type: "string"
    		},
    		delayunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		attack: {
    			type: "float"
    		},
    		decayunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		attackunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		ashape: {
    			type: "menu",
    			menuitems: [
    				"linear",
    				"easein",
    				"easeout",
    				"halfcos"
    			]
    		},
    		rshape: {
    			type: "menu",
    			menuitems: [
    				"linear",
    				"easein",
    				"easeout",
    				"halfcos"
    			]
    		},
    		retriggerunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		peak: {
    			type: "float"
    		},
    		remainder: {
    			type: "menu",
    			menuitems: [
    				"crop",
    				"extend",
    				"mix"
    			]
    		},
    		complete: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var dattoCHOP = {
    	maxInputs: 0,
    	pars: {
    		rowindexstart: {
    			type: "number"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		output: {
    			type: "menu",
    			menuitems: [
    				"single",
    				"chanperrow",
    				"chanpercol",
    				"chanpervalue"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		rownameend: {
    			type: "string"
    		},
    		rowexpr: {
    			type: "string"
    		},
    		fromcol: {
    			type: "number"
    		},
    		rowindexend: {
    			type: "number"
    		},
    		dat: {
    			type: "DAT"
    		},
    		colindexend: {
    			type: "number"
    		},
    		colexpr: {
    			type: "string"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		colnames: {
    			type: "string"
    		},
    		firstcolumn: {
    			type: "menu",
    			menuitems: [
    				"ignored",
    				"names",
    				"values"
    			]
    		},
    		colindexstart: {
    			type: "number"
    		},
    		rownames: {
    			type: "string"
    		},
    		rownamestart: {
    			type: "string"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		extractrows: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"byname",
    				"byindex",
    				"bynameindex",
    				"byindexname",
    				"bynames",
    				"byexpr"
    			]
    		},
    		extractcols: {
    			type: "menu",
    			menuitems: [
    				"all",
    				"byname",
    				"byindex",
    				"bynameindex",
    				"byindexname",
    				"bynames",
    				"byexpr"
    			]
    		},
    		colnamestart: {
    			type: "string"
    		},
    		fromrow: {
    			type: "number"
    		},
    		firstrow: {
    			type: "menu",
    			menuitems: [
    				"ignored",
    				"names",
    				"values"
    			]
    		},
    		colnameend: {
    			type: "string"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var shiftCHOP = {
    	maxInputs: 2,
    	pars: {
    		reference: {
    			type: "menu",
    			menuitems: [
    				"refstart",
    				"refend"
    			]
    		},
    		endunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		relative: {
    			type: "menu",
    			menuitems: [
    				"abs",
    				"rel",
    				"cur"
    			]
    		},
    		startunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		end: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		scrollunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		start: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		},
    		scroll: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var sharedmeminCHOP = {
    	maxInputs: 0,
    	pars: {
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		memtype: {
    			type: "menu",
    			menuitems: [
    				"local",
    				"global"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		name: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var blendCHOP = {
    	maxInputs: 9999,
    	pars: {
    		method: {
    			type: "menu",
    			menuitems: [
    				"prop",
    				"dif",
    				"quaternion"
    			]
    		},
    		firstweight: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		underflow: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 2,
    	type: "CHOP"
    };
    var dmxoutCHOP = {
    	maxInputs: 1,
    	pars: {
    		priority: {
    			type: "number"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"packetpersample",
    				"packetperchan"
    			]
    		},
    		net: {
    			type: "number"
    		},
    		rate: {
    			type: "number"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		subnet: {
    			type: "number"
    		},
    		serialport: {
    			type: "pulse"
    		},
    		netport: {
    			type: "number"
    		},
    		sendartsync: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		multicast: {
    			type: "toggle"
    		},
    		localport: {
    			type: "number"
    		},
    		active: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		source: {
    			type: "string"
    		},
    		"interface": {
    			type: "menu"
    		},
    		routingtable: {
    			type: "DAT"
    		},
    		universe: {
    			type: "number"
    		},
    		netaddress: {
    			type: "string"
    		},
    		device: {
    			type: "pulse"
    		},
    		customport: {
    			type: "toggle"
    		},
    		localaddress: {
    			type: "string"
    		},
    		cid: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var resampleCHOP = {
    	maxInputs: 2,
    	pars: {
    		endunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		quatrot: {
    			type: "toggle"
    		},
    		cyclelen: {
    			type: "float"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		correct: {
    			type: "toggle"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		relative: {
    			type: "menu",
    			menuitems: [
    				"abs",
    				"rel",
    				"cur"
    			]
    		},
    		constarea: {
    			type: "toggle"
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"strech",
    				"preserve",
    				"index",
    				"newint"
    			]
    		},
    		startunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		rate: {
    			type: "float"
    		},
    		end: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		start: {
    			type: "float"
    		},
    		interp: {
    			type: "menu",
    			menuitems: [
    				"nointerp",
    				"linear",
    				"cubic",
    				"edge"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var lfoCHOP = {
    	maxInputs: 3,
    	pars: {
    		amp: {
    			type: "float"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		channelname: {
    			type: "string"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		offset: {
    			type: "float"
    		},
    		resetcondition: {
    			type: "menu",
    			menuitems: [
    				"offtoon",
    				"on",
    				"ontooff",
    				"off"
    			]
    		},
    		wavetype: {
    			type: "menu",
    			menuitems: [
    				"sin",
    				"normal",
    				"tri",
    				"ramp",
    				"square",
    				"pulse"
    			]
    		},
    		rate: {
    			type: "float"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		frequency: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		play: {
    			type: "toggle"
    		},
    		phase: {
    			type: "float"
    		},
    		reset: {
    			type: "toggle"
    		},
    		bias: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var attributeCHOP = {
    	maxInputs: 1,
    	pars: {
    		autoexportroot: {
    			type: "OP"
    		},
    		slerp: {
    			type: "menu",
    			menuitems: [
    				"pass",
    				"replace",
    				"append",
    				"remove"
    			]
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var warpCHOP = {
    	maxInputs: 2,
    	pars: {
    		scaleindex: {
    			type: "toggle"
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"rate",
    				"index"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 2,
    	type: "CHOP"
    };
    var mergeCHOP = {
    	maxInputs: 9999,
    	pars: {
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		align: {
    			type: "menu",
    			menuitems: [
    				"auto",
    				"none",
    				"stretch",
    				"start",
    				"end",
    				"shift1",
    				"trim1",
    				"stretch1",
    				"trim",
    				"squash"
    			]
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		duplicate: {
    			type: "menu",
    			menuitems: [
    				"unique",
    				"first",
    				"last",
    				"replace"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var tabletCHOP = {
    	maxInputs: 0,
    	pars: {
    		pressure: {
    			type: "string"
    		},
    		tanpressure: {
    			type: "string"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		button4: {
    			type: "string"
    		},
    		rate: {
    			type: "float"
    		},
    		tanpressure2: {
    			type: "string"
    		},
    		button22: {
    			type: "string"
    		},
    		rotation: {
    			type: "string"
    		},
    		ytilt: {
    			type: "string"
    		},
    		xcoord: {
    			type: "string"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		button23: {
    			type: "string"
    		},
    		button21: {
    			type: "string"
    		},
    		button5: {
    			type: "string"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		zcoord: {
    			type: "string"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		xcoord2: {
    			type: "string"
    		},
    		pressure2: {
    			type: "string"
    		},
    		left: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		button1: {
    			type: "string"
    		},
    		defval: {
    			type: "float"
    		},
    		active: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"play"
    			]
    		},
    		rotation2: {
    			type: "string"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		button24: {
    			type: "string"
    		},
    		xtilt2: {
    			type: "string"
    		},
    		button25: {
    			type: "string"
    		},
    		ycoord: {
    			type: "string"
    		},
    		button2: {
    			type: "string"
    		},
    		xtilt: {
    			type: "string"
    		},
    		zcoord2: {
    			type: "string"
    		},
    		scope: {
    			type: "string"
    		},
    		ycoord2: {
    			type: "string"
    		},
    		button3: {
    			type: "string"
    		},
    		right: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		ytilt2: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var audioparaeqCHOP = {
    	maxInputs: 4,
    	pars: {
    		boost2: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		bandwidth3: {
    			type: "float"
    		},
    		units: {
    			type: "menu",
    			menuitems: [
    				"logarithmic",
    				"frequency"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		drywet: {
    			type: "float"
    		},
    		enableeq2: {
    			type: "toggle"
    		},
    		enableeq3: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		boost3: {
    			type: "float"
    		},
    		boost1: {
    			type: "float"
    		},
    		frequencylog3: {
    			type: "float"
    		},
    		frequencyhz3: {
    			type: "float"
    		},
    		enableeq1: {
    			type: "toggle"
    		},
    		frequencylog2: {
    			type: "float"
    		},
    		bandwidth2: {
    			type: "float"
    		},
    		frequencylog1: {
    			type: "float"
    		},
    		frequencyhz2: {
    			type: "float"
    		},
    		frequencyhz1: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		},
    		bandwidth1: {
    			type: "float"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var midiinmapCHOP = {
    	maxInputs: 0,
    	pars: {
    		left: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		bvelocity: {
    			type: "toggle"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		defval: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		buttons: {
    			type: "string"
    		},
    		id: {
    			type: "string"
    		},
    		scope: {
    			type: "string"
    		},
    		rate: {
    			type: "float"
    		},
    		squeue: {
    			type: "toggle"
    		},
    		device: {
    			type: "DAT"
    		},
    		right: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		sliders: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var panelCHOP = {
    	maxInputs: 0,
    	pars: {
    		select: {
    			type: "string"
    		},
    		queue: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		component: {
    			type: "PanelCOMP"
    		},
    		rename: {
    			type: "string"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		queuesize: {
    			type: "number"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var reorderCHOP = {
    	maxInputs: 2,
    	pars: {
    		orderref: {
    			type: "menu",
    			menuitems: [
    				"byname",
    				"byindex"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		charpattern: {
    			type: "string"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		seed: {
    			type: "float"
    		},
    		numpattern: {
    			type: "string"
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"numeric",
    				"character",
    				"basename",
    				"numsuffix",
    				"chanvalueup",
    				"chanvaluedown",
    				"reverse",
    				"random",
    				"group",
    				"split"
    			]
    		},
    		rempos: {
    			type: "menu",
    			menuitems: [
    				"begin",
    				"end"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		nvalue: {
    			type: "number"
    		},
    		scope: {
    			type: "string"
    		},
    		remorder: {
    			type: "menu",
    			menuitems: [
    				"input",
    				"alpha"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var patternCHOP = {
    	maxInputs: 1,
    	pars: {
    		taper1: {
    			type: "float"
    		},
    		length: {
    			type: "number"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		offset: {
    			type: "float"
    		},
    		taper2: {
    			type: "float"
    		},
    		wavetype: {
    			type: "menu",
    			menuitems: [
    				"const",
    				"sin",
    				"cos",
    				"tri",
    				"ramp",
    				"rampsamples",
    				"square",
    				"pulse",
    				"random",
    				"randomcycle"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		integer: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"ceiling",
    				"floor",
    				"round"
    			]
    		},
    		phasestep: {
    			type: "float"
    		},
    		reverse: {
    			type: "toggle"
    		},
    		combine: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"append",
    				"insert",
    				"replace",
    				"add",
    				"multiply"
    			]
    		},
    		phase: {
    			type: "float"
    		},
    		taperdecay: {
    			type: "float"
    		},
    		fromrange2: {
    			type: "float"
    		},
    		left: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		right: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		channelname: {
    			type: "string"
    		},
    		defval: {
    			type: "float"
    		},
    		torange1: {
    			type: "float"
    		},
    		numcycles: {
    			type: "float"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		torange2: {
    			type: "float"
    		},
    		seed: {
    			type: "float"
    		},
    		rate: {
    			type: "float"
    		},
    		bias: {
    			type: "float"
    		},
    		amp: {
    			type: "float"
    		},
    		fromrange1: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var waveCHOP = {
    	maxInputs: 0,
    	pars: {
    		decay: {
    			type: "float"
    		},
    		periodunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		left: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		offset: {
    			type: "float"
    		},
    		wavetype: {
    			type: "menu",
    			menuitems: [
    				"const",
    				"sin",
    				"normal",
    				"tri",
    				"ramp",
    				"square",
    				"pulse",
    				"expr"
    			]
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		rampunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		phase: {
    			type: "float"
    		},
    		end: {
    			type: "float"
    		},
    		period: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		endunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		amp: {
    			type: "float"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		channelname: {
    			type: "string"
    		},
    		ramp: {
    			type: "float"
    		},
    		defval: {
    			type: "float"
    		},
    		exprs: {
    			type: "float"
    		},
    		startunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		decayunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		rate: {
    			type: "float"
    		},
    		bias: {
    			type: "float"
    		},
    		right: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		start: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var mouseinCHOP = {
    	maxInputs: 0,
    	pars: {
    		mbuttonname: {
    			type: "string"
    		},
    		wheel: {
    			type: "string"
    		},
    		right: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		active: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"play"
    			]
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		left: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		posxname: {
    			type: "string"
    		},
    		lbuttonname: {
    			type: "string"
    		},
    		defval: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		monitor: {
    			type: "string"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		output: {
    			type: "menu",
    			menuitems: [
    				"normal",
    				"aspect",
    				"absolute"
    			]
    		},
    		rbuttonname: {
    			type: "string"
    		},
    		wheelinc: {
    			type: "float"
    		},
    		rate: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		posyname: {
    			type: "string"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var limitCHOP = {
    	maxInputs: 1,
    	pars: {
    		max: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		istepunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		positive: {
    			type: "toggle"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		},
    		voffset: {
    			type: "float"
    		},
    		vstep: {
    			type: "float"
    		},
    		min: {
    			type: "float"
    		},
    		type: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"clamp",
    				"loop",
    				"zigzag"
    			]
    		},
    		istep: {
    			type: "float"
    		},
    		ioffsetunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		norm: {
    			type: "toggle"
    		},
    		ioffset: {
    			type: "float"
    		},
    		quantvalue: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"ceiling",
    				"floor",
    				"round"
    			]
    		},
    		underflow: {
    			type: "toggle"
    		},
    		quantindex: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"relstart",
    				"relzero"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var cplusplusCHOP = {
    	maxInputs: 999,
    	pars: {
    		reinitpulse: {
    			type: "pulse"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		plugin: {
    			type: "string"
    		},
    		unloadplugin: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		reinit: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var holdCHOP = {
    	maxInputs: 2,
    	pars: {
    		sample: {
    			type: "menu",
    			menuitems: [
    				"offtoon",
    				"whileon",
    				"ontooff",
    				"whileoff",
    				"valuechange"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		pulse: {
    			type: "pulse"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var posistagenetCHOP = {
    	maxInputs: 0,
    	pars: {
    		accel: {
    			type: "toggle"
    		},
    		pos: {
    			type: "toggle"
    		},
    		active: {
    			type: "toggle"
    		},
    		speed: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		port: {
    			type: "number"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		ori: {
    			type: "toggle"
    		},
    		netaddress: {
    			type: "string"
    		},
    		samplerate: {
    			type: "number"
    		},
    		reset: {
    			type: "pulse"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		targetpos: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var countCHOP = {
    	maxInputs: 3,
    	pars: {
    		triggeron: {
    			type: "menu",
    			menuitems: [
    				"increase",
    				"decrease"
    			]
    		},
    		threshdown: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		output: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"loop",
    				"min",
    				"lc",
    				"cl"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		limitmin: {
    			type: "float"
    		},
    		limitmax: {
    			type: "float"
    		},
    		retrigger: {
    			type: "float"
    		},
    		on: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"inc",
    				"dec",
    				"inctime",
    				"dectime",
    				"reset"
    			]
    		},
    		retriggerunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		resetvalue: {
    			type: "float"
    		},
    		threshold: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		ontooff: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"inc",
    				"dec",
    				"inctime",
    				"dectime",
    				"reset"
    			]
    		},
    		threshup: {
    			type: "float"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		offtoon: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"inc",
    				"dec",
    				"inctime",
    				"dectime",
    				"reset"
    			]
    		},
    		off: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"inc",
    				"dec",
    				"inctime",
    				"dectime",
    				"reset"
    			]
    		},
    		resetcondition: {
    			type: "menu",
    			menuitems: [
    				"offtoon",
    				"on",
    				"ontooff",
    				"off"
    			]
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		reset: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var oculusriftCHOP = {
    	maxInputs: 0,
    	pars: {
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		output: {
    			type: "menu",
    			menuitems: [
    				"hmd",
    				"leftcontroller",
    				"rightcontroller",
    				"leftmatrix",
    				"rightmatrix"
    			]
    		},
    		velocity: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		near: {
    			type: "float"
    		},
    		recenter: {
    			type: "pulse"
    		},
    		far: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		acceleration: {
    			type: "toggle"
    		},
    		orientation: {
    			type: "toggle"
    		},
    		deviceinfo: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		},
    		controllerbuttons: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var kinectCHOP = {
    	maxInputs: 0,
    	pars: {
    		relbonerotations: {
    			type: "toggle"
    		},
    		correction: {
    			type: "float"
    		},
    		flipfaceu: {
    			type: "toggle"
    		},
    		smoothing: {
    			type: "float"
    		},
    		skeleton: {
    			type: "menu",
    			menuitems: [
    				"full",
    				"seated",
    				"off"
    			]
    		},
    		interactions: {
    			type: "toggle"
    		},
    		neardepthmode: {
    			type: "toggle"
    		},
    		maxdevrad: {
    			type: "float"
    		},
    		flipskelu: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		worldspace: {
    			type: "toggle"
    		},
    		statuschans: {
    			type: "toggle"
    		},
    		rotationsmoothing: {
    			type: "float"
    		},
    		hwversion: {
    			type: "menu",
    			menuitems: [
    				"version1",
    				"version2"
    			]
    		},
    		bonelengths: {
    			type: "toggle"
    		},
    		jitterrad: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		unrollbones: {
    			type: "toggle"
    		},
    		absbonerotations: {
    			type: "toggle"
    		},
    		colorspace: {
    			type: "toggle"
    		},
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		facetracking: {
    			type: "toggle"
    		},
    		sensor: {
    			type: "string"
    		},
    		depthspace: {
    			type: "toggle"
    		},
    		jointsmoothing: {
    			type: "toggle"
    		},
    		maxplayers: {
    			type: "number"
    		},
    		prediction: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var blacktraxCHOP = {
    	maxInputs: 0,
    	pars: {
    		mappingtable: {
    			type: "DAT"
    		},
    		reset: {
    			type: "toggle"
    		},
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		velocity: {
    			type: "toggle"
    		},
    		outputformat: {
    			type: "menu",
    			menuitems: [
    				"fromtable",
    				"frombeacons"
    			]
    		},
    		port: {
    			type: "number"
    		},
    		maxbeacons: {
    			type: "number"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		protocol: {
    			type: "menu",
    			menuitems: [
    				"msging",
    				"multicastmsging"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		leds: {
    			type: "toggle"
    		},
    		netaddress: {
    			type: "string"
    		},
    		samplerate: {
    			type: "number"
    		},
    		acceleration: {
    			type: "toggle"
    		},
    		centroid: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var oculusaudioCHOP = {
    	maxInputs: 1,
    	pars: {
    		headobject: {
    			type: "COMP"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		roombackrelfect: {
    			type: "float"
    		},
    		diameter: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		roomtoprelfect: {
    			type: "float"
    		},
    		attenuationscale: {
    			type: "float"
    		},
    		attenuation: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"fixed",
    				"inversesequare"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		bandhint: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"wide",
    				"narrow"
    			]
    		},
    		roomfrontrelfect: {
    			type: "float"
    		},
    		active: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		roomleftrelfect: {
    			type: "float"
    		},
    		reflectrevert: {
    			type: "toggle"
    		},
    		roombottomrelfect: {
    			type: "float"
    		},
    		sourceobject: {
    			type: "COMP"
    		},
    		roomrightrelfect: {
    			type: "float"
    		},
    		boxroommode: {
    			type: "toggle"
    		},
    		minrange: {
    			type: "float"
    		},
    		maxrange: {
    			type: "float"
    		},
    		roomsize: {
    			type: "xyz"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var mouseoutCHOP = {
    	maxInputs: 1,
    	pars: {
    		mbuttonname: {
    			type: "string"
    		},
    		posv: {
    			type: "string"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		rbuttonname: {
    			type: "string"
    		},
    		lbuttonname: {
    			type: "string"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		cookalways: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		posu: {
    			type: "string"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var hokuyoCHOP = {
    	maxInputs: 0,
    	pars: {
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		output: {
    			type: "menu",
    			menuitems: [
    				"polarcoords",
    				"cartesiancoords"
    			]
    		},
    		port: {
    			type: "string"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		highsensitivity: {
    			type: "toggle"
    		},
    		"interface": {
    			type: "menu",
    			menuitems: [
    				"serial",
    				"ethernet"
    			]
    		},
    		endstep: {
    			type: "number"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		netaddress: {
    			type: "string"
    		},
    		startstep: {
    			type: "number"
    		},
    		scope: {
    			type: "string"
    		},
    		motorspeed: {
    			type: "number"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var overrideCHOP = {
    	maxInputs: 9999,
    	pars: {
    		cookmonitor: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		match: {
    			type: "menu",
    			menuitems: [
    				"index",
    				"name"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		indexname: {
    			type: "string"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		makeindex: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var logicCHOP = {
    	maxInputs: 9999,
    	pars: {
    		match: {
    			type: "menu",
    			menuitems: [
    				"index",
    				"name"
    			]
    		},
    		boundmax: {
    			type: "float"
    		},
    		chopop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"and",
    				"or",
    				"xor",
    				"nand",
    				"nor",
    				"eqv",
    				"lowest",
    				"highest"
    			]
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		boundmin: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		convert: {
    			type: "menu",
    			menuitems: [
    				"nonzero",
    				"pos",
    				"bound",
    				"valchange",
    				"namechange"
    			]
    		},
    		chanop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"and",
    				"or",
    				"xor",
    				"nand",
    				"nor",
    				"eqv",
    				"lowest",
    				"highest"
    			]
    		},
    		align: {
    			type: "menu",
    			menuitems: [
    				"auto",
    				"none",
    				"stretch",
    				"start",
    				"end",
    				"shift1",
    				"trim1",
    				"stretch1",
    				"trim",
    				"squash"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		preop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"invert",
    				"toggle",
    				"radio",
    				"radio2",
    				"rise",
    				"fall"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var replaceCHOP = {
    	maxInputs: 2,
    	pars: {
    		length: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"second"
    			]
    		},
    		notify: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var stretchCHOP = {
    	maxInputs: 2,
    	pars: {
    		endunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		relative: {
    			type: "menu",
    			menuitems: [
    				"abs",
    				"rel",
    				"cur"
    			]
    		},
    		constarea: {
    			type: "toggle"
    		},
    		startunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		reverse: {
    			type: "toggle"
    		},
    		end: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		scale: {
    			type: "float"
    		},
    		start: {
    			type: "float"
    		},
    		interp: {
    			type: "menu",
    			menuitems: [
    				"nointerp",
    				"linear",
    				"cubic",
    				"edge"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var audioplayCHOP = {
    	maxInputs: 3,
    	pars: {
    		frontleft: {
    			type: "number"
    		},
    		cookalways: {
    			type: "toggle"
    		},
    		specifydevice: {
    			type: "toggle"
    		},
    		stereo: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		topbackright: {
    			type: "number"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		frontrightcenter: {
    			type: "number"
    		},
    		topfrontleft: {
    			type: "number"
    		},
    		backright: {
    			type: "number"
    		},
    		topbackcenter: {
    			type: "number"
    		},
    		sideleft: {
    			type: "number"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		errormissing: {
    			type: "toggle"
    		},
    		frontleftcenter: {
    			type: "number"
    		},
    		mode: {
    			type: "menu",
    			menuitems: [
    				"on",
    				"trigger",
    				"loop"
    			]
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		lowfrequency: {
    			type: "number"
    		},
    		outputs: {
    			type: "string"
    		},
    		trigger: {
    			type: "pulse"
    		},
    		backcenter: {
    			type: "number"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		topfrontright: {
    			type: "number"
    		},
    		topbackleft: {
    			type: "number"
    		},
    		topcenter: {
    			type: "number"
    		},
    		frontright: {
    			type: "number"
    		},
    		frontcenter: {
    			type: "number"
    		},
    		volume: {
    			type: "float"
    		},
    		topfrontcenter: {
    			type: "number"
    		},
    		datlist: {
    			type: "DAT"
    		},
    		device: {
    			type: "string"
    		},
    		backleft: {
    			type: "number"
    		},
    		sideright: {
    			type: "number"
    		},
    		scope: {
    			type: "string"
    		},
    		file: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var midioutCHOP = {
    	maxInputs: 1,
    	pars: {
    		cookalways: {
    			type: "toggle"
    		},
    		controlformat: {
    			type: "menu",
    			menuitems: [
    				"7bit",
    				"14bit"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		pitchname: {
    			type: "string"
    		},
    		notename: {
    			type: "string"
    		},
    		aftername: {
    			type: "string"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		pressname: {
    			type: "string"
    		},
    		writefile: {
    			type: "pulse"
    		},
    		notenorm: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"0to1"
    			]
    		},
    		progname: {
    			type: "string"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		barname: {
    			type: "string"
    		},
    		startstop: {
    			type: "toggle"
    		},
    		destination: {
    			type: "menu",
    			menuitems: [
    				"device",
    				"file"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		prefix: {
    			type: "string"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		barticks: {
    			type: "number"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		controlname: {
    			type: "string"
    		},
    		volumeoff: {
    			type: "pulse"
    		},
    		id: {
    			type: "string"
    		},
    		controlnorm: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"0to1",
    				"-1to1",
    				"onoff"
    			]
    		},
    		autonoteoff: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"start",
    				"end",
    				"both"
    			]
    		},
    		reset: {
    			type: "pulse"
    		},
    		device: {
    			type: "DAT"
    		},
    		file: {
    			type: "string"
    		},
    		onebased: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		},
    		volumeon: {
    			type: "pulse"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var sharedmemoutCHOP = {
    	maxInputs: 1,
    	pars: {
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		memtype: {
    			type: "menu",
    			menuitems: [
    				"local",
    				"global"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		name: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var eventCHOP = {
    	maxInputs: 3,
    	pars: {
    		decaytime: {
    			type: "float"
    		},
    		sustainmax: {
    			type: "float"
    		},
    		speed: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		sustainmin: {
    			type: "float"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		sustaintunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		reset: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		decaytunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		releaselevel: {
    			type: "float"
    		},
    		releasetunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		active: {
    			type: "string"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		input: {
    			type: "string"
    		},
    		resetcondition: {
    			type: "menu",
    			menuitems: [
    				"offtoon",
    				"on",
    				"ontooff",
    				"off"
    			]
    		},
    		sustaintime: {
    			type: "float"
    		},
    		globalspeed: {
    			type: "float"
    		},
    		attacktime: {
    			type: "float"
    		},
    		attacktunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		id: {
    			type: "string"
    		},
    		state: {
    			type: "string"
    		},
    		attacklevel: {
    			type: "float"
    		},
    		releasetime: {
    			type: "float"
    		},
    		index: {
    			type: "string"
    		},
    		adsr: {
    			type: "string"
    		},
    		scope: {
    			type: "string"
    		},
    		time: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var constantCHOP = {
    	maxInputs: 2,
    	pars: {
    		value17: {
    			type: "float"
    		},
    		name12: {
    			type: "string"
    		},
    		name16: {
    			type: "string"
    		},
    		value16: {
    			type: "float"
    		},
    		name28: {
    			type: "string"
    		},
    		value4: {
    			type: "float"
    		},
    		value22: {
    			type: "float"
    		},
    		name21: {
    			type: "string"
    		},
    		name4: {
    			type: "string"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		value12: {
    			type: "float"
    		},
    		name35: {
    			type: "string"
    		},
    		name1: {
    			type: "string"
    		},
    		value28: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		name9: {
    			type: "string"
    		},
    		value31: {
    			type: "float"
    		},
    		snap: {
    			type: "pulse"
    		},
    		name20: {
    			type: "string"
    		},
    		value25: {
    			type: "float"
    		},
    		value34: {
    			type: "float"
    		},
    		name30: {
    			type: "string"
    		},
    		value6: {
    			type: "float"
    		},
    		value18: {
    			type: "float"
    		},
    		startunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		value38: {
    			type: "float"
    		},
    		name14: {
    			type: "string"
    		},
    		value32: {
    			type: "float"
    		},
    		name3: {
    			type: "string"
    		},
    		name11: {
    			type: "string"
    		},
    		left: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		value15: {
    			type: "float"
    		},
    		value37: {
    			type: "float"
    		},
    		name24: {
    			type: "string"
    		},
    		first: {
    			type: "number"
    		},
    		value21: {
    			type: "float"
    		},
    		name34: {
    			type: "string"
    		},
    		name15: {
    			type: "string"
    		},
    		name23: {
    			type: "string"
    		},
    		name22: {
    			type: "string"
    		},
    		value10: {
    			type: "float"
    		},
    		value11: {
    			type: "float"
    		},
    		name33: {
    			type: "string"
    		},
    		name18: {
    			type: "string"
    		},
    		defval: {
    			type: "float"
    		},
    		value26: {
    			type: "float"
    		},
    		value3: {
    			type: "float"
    		},
    		name17: {
    			type: "string"
    		},
    		value33: {
    			type: "float"
    		},
    		value13: {
    			type: "float"
    		},
    		start: {
    			type: "float"
    		},
    		name36: {
    			type: "string"
    		},
    		name10: {
    			type: "string"
    		},
    		name29: {
    			type: "string"
    		},
    		value9: {
    			type: "float"
    		},
    		value35: {
    			type: "float"
    		},
    		name26: {
    			type: "string"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		name2: {
    			type: "string"
    		},
    		value24: {
    			type: "float"
    		},
    		value23: {
    			type: "float"
    		},
    		value39: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		name6: {
    			type: "string"
    		},
    		name7: {
    			type: "string"
    		},
    		value1: {
    			type: "float"
    		},
    		value19: {
    			type: "float"
    		},
    		name31: {
    			type: "string"
    		},
    		name8: {
    			type: "string"
    		},
    		name38: {
    			type: "string"
    		},
    		value0: {
    			type: "float"
    		},
    		value20: {
    			type: "float"
    		},
    		value8: {
    			type: "float"
    		},
    		value14: {
    			type: "float"
    		},
    		rate: {
    			type: "float"
    		},
    		value2: {
    			type: "float"
    		},
    		value27: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		},
    		name5: {
    			type: "string"
    		},
    		name25: {
    			type: "string"
    		},
    		single: {
    			type: "toggle"
    		},
    		value7: {
    			type: "float"
    		},
    		endunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		name19: {
    			type: "string"
    		},
    		current: {
    			type: "toggle"
    		},
    		name32: {
    			type: "string"
    		},
    		end: {
    			type: "float"
    		},
    		name0: {
    			type: "string"
    		},
    		name27: {
    			type: "string"
    		},
    		value29: {
    			type: "float"
    		},
    		right: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		name39: {
    			type: "string"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		name13: {
    			type: "string"
    		},
    		value5: {
    			type: "float"
    		},
    		value36: {
    			type: "float"
    		},
    		name37: {
    			type: "string"
    		},
    		value30: {
    			type: "float"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var timesliceCHOP = {
    	maxInputs: 1,
    	pars: {
    		quatrot: {
    			type: "toggle"
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"linear",
    				"trim"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var inCHOP = {
    	maxInputs: 1,
    	pars: {
    		autoexportroot: {
    			type: "OP"
    		},
    		label: {
    			type: "string"
    		},
    		channames: {
    			type: "string"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		numchannels: {
    			type: "number"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		specifynum: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var dmxinCHOP = {
    	maxInputs: 0,
    	pars: {
    		universename: {
    			type: "string"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		netname: {
    			type: "string"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"packetpersample",
    				"packetperchan",
    				"packetperchanall"
    			]
    		},
    		subnetname: {
    			type: "string"
    		},
    		universe: {
    			type: "number"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		subnet: {
    			type: "number"
    		},
    		"interface": {
    			type: "pulse"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		device: {
    			type: "pulse"
    		},
    		startcodes: {
    			type: "string"
    		},
    		active: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		serialport: {
    			type: "pulse"
    		},
    		filterdat: {
    			type: "DAT"
    		},
    		rate: {
    			type: "number"
    		},
    		multicast: {
    			type: "toggle"
    		},
    		net: {
    			type: "number"
    		},
    		scope: {
    			type: "string"
    		},
    		queuesize: {
    			type: "number"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var recordCHOP = {
    	maxInputs: 3,
    	pars: {
    		segment1: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		output: {
    			type: "menu",
    			menuitems: [
    				"full",
    				"curframe",
    				"frame1",
    				"slice",
    				"segment"
    			]
    		},
    		resetcondition: {
    			type: "menu",
    			menuitems: [
    				"offtoon",
    				"on",
    				"ontooff",
    				"off"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		segment2: {
    			type: "float"
    		},
    		sample: {
    			type: "menu",
    			menuitems: [
    				"scur",
    				"sslice"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		reset: {
    			type: "pulse"
    		},
    		segmentunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		interp: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"linear",
    				"cubic"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		record: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"add",
    				"auto"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var audiodeviceoutCHOP = {
    	maxInputs: 2,
    	pars: {
    		frontleft: {
    			type: "toggle"
    		},
    		cookalways: {
    			type: "toggle"
    		},
    		pan: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		topbackright: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		frontrightcenter: {
    			type: "toggle"
    		},
    		clampoutput: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		bufferlength: {
    			type: "float"
    		},
    		backright: {
    			type: "toggle"
    		},
    		topbackcenter: {
    			type: "toggle"
    		},
    		sideleft: {
    			type: "toggle"
    		},
    		errormissing: {
    			type: "toggle"
    		},
    		frontleftcenter: {
    			type: "toggle"
    		},
    		active: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		lowfrequency: {
    			type: "toggle"
    		},
    		outputs: {
    			type: "string"
    		},
    		topcenter: {
    			type: "toggle"
    		},
    		backcenter: {
    			type: "toggle"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		topfrontright: {
    			type: "toggle"
    		},
    		topbackleft: {
    			type: "toggle"
    		},
    		frontright: {
    			type: "toggle"
    		},
    		frontcenter: {
    			type: "toggle"
    		},
    		driver: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"asio"
    			]
    		},
    		volume: {
    			type: "float"
    		},
    		topfrontcenter: {
    			type: "toggle"
    		},
    		topfrontleft: {
    			type: "toggle"
    		},
    		device: {
    			type: "string"
    		},
    		backleft: {
    			type: "toggle"
    		},
    		sideright: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var copyCHOP = {
    	maxInputs: 2,
    	pars: {
    		cook: {
    			type: "toggle"
    		},
    		val5: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		param6: {
    			type: "string"
    		},
    		output: {
    			type: "menu",
    			menuitems: [
    				"match",
    				"accum"
    			]
    		},
    		param2: {
    			type: "string"
    		},
    		param5: {
    			type: "string"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		val8: {
    			type: "float"
    		},
    		param3: {
    			type: "string"
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"trigger",
    				"convolve"
    			]
    		},
    		val7: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		threshold: {
    			type: "float"
    		},
    		val9: {
    			type: "float"
    		},
    		val3: {
    			type: "float"
    		},
    		param7: {
    			type: "string"
    		},
    		val4: {
    			type: "float"
    		},
    		keep: {
    			type: "toggle"
    		},
    		val10: {
    			type: "float"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		val6: {
    			type: "float"
    		},
    		param1: {
    			type: "string"
    		},
    		param8: {
    			type: "string"
    		},
    		val1: {
    			type: "float"
    		},
    		param4: {
    			type: "string"
    		},
    		param9: {
    			type: "string"
    		},
    		scope: {
    			type: "string"
    		},
    		param10: {
    			type: "string"
    		},
    		val2: {
    			type: "float"
    		},
    		remainder: {
    			type: "menu",
    			menuitems: [
    				"crop",
    				"extend",
    				"mix"
    			]
    		}
    	},
    	minInputs: 2,
    	type: "CHOP"
    };
    var switchCHOP = {
    	maxInputs: 9999,
    	pars: {
    		indexfirst: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		index: {
    			type: "number"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var envelopeCHOP = {
    	maxInputs: 1,
    	pars: {
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"exp",
    				"window"
    			]
    		},
    		widthunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		norm: {
    			type: "toggle"
    		},
    		samplerate: {
    			type: "float"
    		},
    		resample: {
    			type: "toggle"
    		},
    		bounds: {
    			type: "menu",
    			menuitems: [
    				"mag",
    				"power",
    				"min",
    				"max"
    			]
    		},
    		width: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		interp: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"linear",
    				"cubic"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var deleteCHOP = {
    	maxInputs: 2,
    	pars: {
    		delscope: {
    			type: "string"
    		},
    		selnumbers: {
    			type: "string"
    		},
    		delsamples: {
    			type: "toggle"
    		},
    		condition: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"greater",
    				"equal",
    				"notequal",
    				"inside",
    				"outside"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		discard: {
    			type: "menu",
    			menuitems: [
    				"scoped",
    				"nonscoped"
    			]
    		},
    		compnums: {
    			type: "string"
    		},
    		select: {
    			type: "menu",
    			menuitems: [
    				"byname",
    				"bynum"
    			]
    		},
    		compchans: {
    			type: "menu",
    			menuitems: [
    				"firstchan",
    				"lastchan",
    				"byname",
    				"bynum"
    			]
    		},
    		inclvalue1: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		value1: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		selconst: {
    			type: "toggle"
    		},
    		onesample: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		inclvalue2: {
    			type: "toggle"
    		},
    		selrange1: {
    			type: "float"
    		},
    		deletecomp: {
    			type: "toggle"
    		},
    		compmulti: {
    			type: "menu",
    			menuitems: [
    				"any",
    				"all",
    				"add",
    				"sub",
    				"mul",
    				"div",
    				"avg",
    				"min",
    				"max",
    				"len"
    			]
    		},
    		chanvalue: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"complete",
    				"partial",
    				"outside"
    			]
    		},
    		selrange2: {
    			type: "float"
    		},
    		compnames: {
    			type: "string"
    		},
    		value2: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		},
    		delchannels: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var spliceCHOP = {
    	maxInputs: 2,
    	pars: {
    		match: {
    			type: "menu",
    			menuitems: [
    				"index",
    				"name"
    			]
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		direction: {
    			type: "menu",
    			menuitems: [
    				"firsttolast",
    				"lasttofirst"
    			]
    		},
    		trimlength: {
    			type: "float"
    		},
    		trimlengthunits: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		insertinterp: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"linear",
    				"cubic"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		insertlength: {
    			type: "float"
    		},
    		trimmethod: {
    			type: "menu",
    			menuitems: [
    				"trimlength",
    				"insertlength"
    			]
    		},
    		outputtrimmed: {
    			type: "toggle"
    		},
    		insertunits: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		units: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		insertmethod: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"natural",
    				"stretchtrim",
    				"insertlength",
    				"stretchinsert"
    			]
    		},
    		start: {
    			type: "float"
    		},
    		unmatchedinterp: {
    			type: "menu",
    			menuitems: [
    				"none",
    				"linear",
    				"cubic"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var touchoutCHOP = {
    	maxInputs: 1,
    	pars: {
    		autoexportroot: {
    			type: "OP"
    		},
    		cookalways: {
    			type: "toggle"
    		},
    		active: {
    			type: "toggle"
    		},
    		syncports: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on"
    			]
    		},
    		maxsize: {
    			type: "float"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		port: {
    			type: "number"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		resendnames: {
    			type: "pulse"
    		},
    		protocol: {
    			type: "menu",
    			menuitems: [
    				"streaming",
    				"msging",
    				"multicastmsging",
    				"_separator_",
    				"faststreaming",
    				"reliablemsging"
    			]
    		},
    		maxsizeunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		scope: {
    			type: "string"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		address: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var joystickCHOP = {
    	maxInputs: 0,
    	pars: {
    		connected: {
    			type: "string"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		left: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		axisrange: {
    			type: "menu",
    			menuitems: [
    				"negoneone",
    				"zeroone"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		yrotinvert: {
    			type: "toggle"
    		},
    		slider0: {
    			type: "string"
    		},
    		yaxisinvert: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		buttonarray: {
    			type: "string"
    		},
    		povstatearray: {
    			type: "string"
    		},
    		yrot: {
    			type: "string"
    		},
    		slider1: {
    			type: "string"
    		},
    		xrot: {
    			type: "string"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		defval: {
    			type: "float"
    		},
    		zrot: {
    			type: "string"
    		},
    		source: {
    			type: "string"
    		},
    		xaxis: {
    			type: "string"
    		},
    		povarrray: {
    			type: "string"
    		},
    		yaxis: {
    			type: "string"
    		},
    		rate: {
    			type: "float"
    		},
    		right: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		axisdeadzone: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		},
    		zaxis: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var sequencerCHOP = {
    	maxInputs: 1,
    	pars: {
    		queue: {
    			type: "string"
    		},
    		addscope: {
    			type: "string"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		trigger: {
    			type: "pulse"
    		},
    		blendscope: {
    			type: "string"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		reset: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		},
    		datlist: {
    			type: "DAT"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var etherdreamCHOP = {
    	maxInputs: 1,
    	pars: {
    		queuetime: {
    			type: "float"
    		},
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		port: {
    			type: "number"
    		},
    		xscale: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		bluescale: {
    			type: "float"
    		},
    		redscale: {
    			type: "float"
    		},
    		queueunits: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		yscale: {
    			type: "float"
    		},
    		netaddress: {
    			type: "string"
    		},
    		greenscale: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var fileinCHOP = {
    	maxInputs: 0,
    	pars: {
    		left: {
    			type: "menu",
    			menuitems: [
    				"asis",
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		renamefrom: {
    			type: "string"
    		},
    		refresh: {
    			type: "toggle"
    		},
    		refreshpulse: {
    			type: "pulse"
    		},
    		defval: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		overridpattern: {
    			type: "string"
    		},
    		overridevalue: {
    			type: "float"
    		},
    		renameto: {
    			type: "string"
    		},
    		rate: {
    			type: "float"
    		},
    		nameoption: {
    			type: "menu",
    			menuitems: [
    				"infile",
    				"new",
    				"filename"
    			]
    		},
    		rateoption: {
    			type: "menu",
    			menuitems: [
    				"nochange",
    				"override",
    				"resample"
    			]
    		},
    		right: {
    			type: "menu",
    			menuitems: [
    				"asis",
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		name: {
    			type: "string"
    		},
    		file: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var lookupCHOP = {
    	maxInputs: 2,
    	pars: {
    		index1: {
    			type: "float"
    		},
    		match: {
    			type: "menu",
    			menuitems: [
    				"index",
    				"name"
    			]
    		},
    		index2: {
    			type: "float"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		chanmatch: {
    			type: "menu",
    			menuitems: [
    				"onetoone",
    				"onetomany"
    			]
    		},
    		interp: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		cyclic: {
    			type: "menu",
    			menuitems: [
    				"auto",
    				"yes",
    				"no"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 2,
    	type: "CHOP"
    };
    var soptoCHOP = {
    	maxInputs: 0,
    	pars: {
    		sop: {
    			type: "SOP"
    		},
    		transobj: {
    			type: "COMP"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		group: {
    			type: "string"
    		},
    		organize: {
    			type: "string"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"static",
    				"animated"
    			]
    		},
    		rate: {
    			type: "float"
    		},
    		renamescope: {
    			type: "string"
    		},
    		attribscope: {
    			type: "string"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var renderpickCHOP = {
    	maxInputs: 0,
    	pars: {
    		rendertop: {
    			type: "TOP"
    		},
    		panel: {
    			type: "PanelCOMP"
    		},
    		instanceid: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		pickcirstep: {
    			type: "number"
    		},
    		pickradstep: {
    			type: "number"
    		},
    		customattrib4: {
    			type: "string"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		color: {
    			type: "toggle"
    		},
    		customattrib4type: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4",
    				"int",
    				"ivec2",
    				"ivec3",
    				"ivec4"
    			]
    		},
    		select: {
    			type: "toggle"
    		},
    		pickv: {
    			type: "float"
    		},
    		uv: {
    			type: "toggle"
    		},
    		normal: {
    			type: "menu",
    			menuitems: [
    				"no",
    				"sopspace",
    				"worldspace",
    				"cameraspace",
    				"relativetoobj"
    			]
    		},
    		customattrib1: {
    			type: "string"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		customattrib3type: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4",
    				"int",
    				"ivec2",
    				"ivec3",
    				"ivec4"
    			]
    		},
    		clearprev: {
    			type: "toggle"
    		},
    		pickradius: {
    			type: "number"
    		},
    		customattrib3: {
    			type: "string"
    		},
    		customattrib1type: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4",
    				"int",
    				"ivec2",
    				"ivec3",
    				"ivec4"
    			]
    		},
    		strategy: {
    			type: "menu",
    			menuitems: [
    				"select",
    				"holdfirst",
    				"holdlast",
    				"always"
    			]
    		},
    		position: {
    			type: "menu",
    			menuitems: [
    				"no",
    				"sopspace",
    				"worldspace",
    				"cameraspace",
    				"relativetoobj"
    			]
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		usepickableflags: {
    			type: "toggle"
    		},
    		path: {
    			type: "toggle"
    		},
    		depth: {
    			type: "toggle"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		customattrib2: {
    			type: "string"
    		},
    		includenonpickable: {
    			type: "toggle"
    		},
    		panelvalue: {
    			type: "string"
    		},
    		referenceobj: {
    			type: "COMP"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		activatecallbacks: {
    			type: "toggle"
    		},
    		picku: {
    			type: "float"
    		},
    		responsetime: {
    			type: "menu",
    			menuitems: [
    				"nextcook",
    				"thiscook"
    			]
    		},
    		customattrib2type: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4",
    				"int",
    				"ivec2",
    				"ivec3",
    				"ivec4"
    			]
    		},
    		pickingby: {
    			type: "menu",
    			menuitems: [
    				"panel",
    				"parameters"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var audiofilterCHOP = {
    	maxInputs: 2,
    	pars: {
    		filter: {
    			type: "menu",
    			menuitems: [
    				"lowpass",
    				"highpass",
    				"bandpass",
    				"bandreject"
    			]
    		},
    		cutofffrequency: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		rolloff: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		resonance: {
    			type: "float"
    		},
    		cutofflog: {
    			type: "float"
    		},
    		units: {
    			type: "menu",
    			menuitems: [
    				"logarithmic",
    				"frequency"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		drywet: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var crossCHOP = {
    	maxInputs: 9999,
    	pars: {
    		cross: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var oscinCHOP = {
    	maxInputs: 0,
    	pars: {
    		adjusttimeunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		adjusttime: {
    			type: "float"
    		},
    		netaddress: {
    			type: "string"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		maxqueue: {
    			type: "float"
    		},
    		oscaddressscope: {
    			type: "string"
    		},
    		queued: {
    			type: "toggle"
    		},
    		maxqueueunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		mintarget: {
    			type: "float"
    		},
    		maxtargetunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		port: {
    			type: "number"
    		},
    		stripsegments: {
    			type: "number"
    		},
    		useglobalrate: {
    			type: "toggle"
    		},
    		protocol: {
    			type: "menu",
    			menuitems: [
    				"msging",
    				"multicastmsging",
    				"reliablemsging"
    			]
    		},
    		samplerate: {
    			type: "number"
    		},
    		reset: {
    			type: "toggle"
    		},
    		maxtarget: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		},
    		mintargetunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var pulseCHOP = {
    	maxInputs: 1,
    	pars: {
    		max: {
    			type: "float"
    		},
    		pulse18: {
    			type: "float"
    		},
    		pulse8: {
    			type: "float"
    		},
    		pulse13: {
    			type: "float"
    		},
    		pulse0: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		pulse26: {
    			type: "float"
    		},
    		lastpulse: {
    			type: "toggle"
    		},
    		end: {
    			type: "float"
    		},
    		pulse3: {
    			type: "float"
    		},
    		pulse7: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		width: {
    			type: "float"
    		},
    		interp: {
    			type: "menu",
    			menuitems: [
    				"nointerp",
    				"linear",
    				"easein",
    				"easeout",
    				"cosine",
    				"cubic"
    			]
    		},
    		widthunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		endunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		pulse15: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		pulse28: {
    			type: "float"
    		},
    		pulse6: {
    			type: "float"
    		},
    		pulse19: {
    			type: "float"
    		},
    		pulse23: {
    			type: "float"
    		},
    		pulse22: {
    			type: "float"
    		},
    		pulse31: {
    			type: "float"
    		},
    		pulse10: {
    			type: "float"
    		},
    		startunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		limit: {
    			type: "menu",
    			menuitems: [
    				"nolimit",
    				"clamp"
    			]
    		},
    		rate: {
    			type: "float"
    		},
    		number: {
    			type: "number"
    		},
    		scope: {
    			type: "string"
    		},
    		pulse11: {
    			type: "float"
    		},
    		pulse27: {
    			type: "float"
    		},
    		pulse4: {
    			type: "float"
    		},
    		pulse9: {
    			type: "float"
    		},
    		min: {
    			type: "float"
    		},
    		pulse16: {
    			type: "float"
    		},
    		pulse2: {
    			type: "float"
    		},
    		pulse17: {
    			type: "float"
    		},
    		pulse20: {
    			type: "float"
    		},
    		pulse21: {
    			type: "float"
    		},
    		left: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		pulse14: {
    			type: "float"
    		},
    		channelname: {
    			type: "string"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		defval: {
    			type: "float"
    		},
    		pulse1: {
    			type: "float"
    		},
    		pulse24: {
    			type: "float"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		pulse5: {
    			type: "float"
    		},
    		pulse12: {
    			type: "float"
    		},
    		pulse29: {
    			type: "float"
    		},
    		right: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		start: {
    			type: "float"
    		},
    		pulse25: {
    			type: "float"
    		},
    		pulse30: {
    			type: "float"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var cycleCHOP = {
    	maxInputs: 1,
    	pars: {
    		blendmethod: {
    			type: "menu",
    			menuitems: [
    				"pre",
    				"ovl",
    				"ins"
    			]
    		},
    		mirror: {
    			type: "toggle"
    		},
    		blendregion: {
    			type: "float"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		stepscope: {
    			type: "string"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		step: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		blendfunc: {
    			type: "menu",
    			menuitems: [
    				"lin",
    				"ei",
    				"eo",
    				"cos",
    				"cub",
    				"add",
    				"holdprev"
    			]
    		},
    		blendregionunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		before: {
    			type: "float"
    		},
    		extremes: {
    			type: "toggle"
    		},
    		blendbias: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		after: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var audiooscillatorCHOP = {
    	maxInputs: 3,
    	pars: {
    		amp: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		offset: {
    			type: "float"
    		},
    		resetcondition: {
    			type: "menu",
    			menuitems: [
    				"offtoon",
    				"on",
    				"ontooff",
    				"off"
    			]
    		},
    		wavetype: {
    			type: "menu",
    			menuitems: [
    				"sin",
    				"normal",
    				"tri",
    				"ramp",
    				"square",
    				"pulse",
    				"whitenoise"
    			]
    		},
    		rate: {
    			type: "float"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		frequency: {
    			type: "float"
    		},
    		octave: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		smooth: {
    			type: "toggle"
    		},
    		phase: {
    			type: "float"
    		},
    		reset: {
    			type: "toggle"
    		},
    		bias: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var beatCHOP = {
    	maxInputs: 2,
    	pars: {
    		multiples: {
    			type: "number"
    		},
    		resetwait: {
    			type: "toggle"
    		},
    		updateglobal: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		sixteenths: {
    			type: "toggle"
    		},
    		beat: {
    			type: "toggle"
    		},
    		pulse: {
    			type: "toggle"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		resetbarvalue: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		countramp: {
    			type: "toggle"
    		},
    		bar: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		period: {
    			type: "float"
    		},
    		sine: {
    			type: "toggle"
    		},
    		shiftstep: {
    			type: "float"
    		},
    		rampbar: {
    			type: "toggle"
    		},
    		playmode: {
    			type: "menu",
    			menuitems: [
    				"locked",
    				"global",
    				"local"
    			]
    		},
    		rampbeat: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		ramp: {
    			type: "toggle"
    		},
    		resetcondition: {
    			type: "menu",
    			menuitems: [
    				"offtoon",
    				"on",
    				"ontooff",
    				"off"
    			]
    		},
    		setperiod: {
    			type: "menu",
    			menuitems: [
    				"0.25",
    				"0.5",
    				"1",
    				"2",
    				"4",
    				"8",
    				"16",
    				"32"
    			]
    		},
    		reftimeslice: {
    			type: "toggle"
    		},
    		randseed: {
    			type: "float"
    		},
    		shiftoffset: {
    			type: "float"
    		},
    		bpm: {
    			type: "toggle"
    		},
    		op: {
    			type: "OP"
    		},
    		reset: {
    			type: "toggle"
    		},
    		randoffset: {
    			type: "float"
    		},
    		count: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var openvrCHOP = {
    	maxInputs: 0,
    	pars: {
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		output: {
    			type: "menu",
    			menuitems: [
    				"sensor",
    				"projmatrices",
    				"controllers",
    				"frametimings"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		maxbuttons: {
    			type: "number"
    		},
    		firstcontroller: {
    			type: "number"
    		},
    		generalinfo: {
    			type: "toggle"
    		},
    		buttons: {
    			type: "toggle"
    		},
    		unitscale: {
    			type: "float"
    		},
    		near: {
    			type: "float"
    		},
    		far: {
    			type: "float"
    		},
    		maxcontrollers: {
    			type: "number"
    		},
    		maxanalogs: {
    			type: "number"
    		},
    		orientation: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var mathCHOP = {
    	maxInputs: 9999,
    	pars: {
    		postop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"negate",
    				"pos",
    				"root",
    				"square",
    				"inverse"
    			]
    		},
    		match: {
    			type: "menu",
    			menuitems: [
    				"index",
    				"name"
    			]
    		},
    		chopop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"add",
    				"sub",
    				"mul",
    				"div",
    				"avg",
    				"min",
    				"max",
    				"len"
    			]
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		preoff: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		fromrange1: {
    			type: "float"
    		},
    		torange2: {
    			type: "float"
    		},
    		preop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"negate",
    				"pos",
    				"root",
    				"square",
    				"inverse"
    			]
    		},
    		torange1: {
    			type: "float"
    		},
    		postoff: {
    			type: "float"
    		},
    		chanop: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"add",
    				"sub",
    				"mul",
    				"div",
    				"avg",
    				"min",
    				"max",
    				"len"
    			]
    		},
    		align: {
    			type: "menu",
    			menuitems: [
    				"auto",
    				"none",
    				"stretch",
    				"start",
    				"end",
    				"shift1",
    				"trim1",
    				"stretch1",
    				"trim",
    				"squash"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		fromrange2: {
    			type: "float"
    		},
    		integer: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"ceiling",
    				"floor",
    				"round"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		gain: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var hogCHOP = {
    	maxInputs: 0,
    	pars: {
    		cookalways: {
    			type: "toggle"
    		},
    		delayunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		active: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		delay: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var abletonlinkCHOP = {
    	maxInputs: 0,
    	pars: {
    		enable: {
    			type: "toggle"
    		},
    		signature1: {
    			type: "number"
    		},
    		signature2: {
    			type: "number"
    		},
    		sixteenths: {
    			type: "toggle"
    		},
    		beat: {
    			type: "toggle"
    		},
    		pulse: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		countramp: {
    			type: "toggle"
    		},
    		bar: {
    			type: "toggle"
    		},
    		phase: {
    			type: "toggle"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		sine: {
    			type: "toggle"
    		},
    		rampbar: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		beats: {
    			type: "toggle"
    		},
    		active: {
    			type: "toggle"
    		},
    		rampbeat: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		ramp: {
    			type: "toggle"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		status: {
    			type: "toggle"
    		},
    		tempo: {
    			type: "toggle"
    		},
    		count: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var scanCHOP = {
    	maxInputs: 0,
    	pars: {
    		interleave: {
    			type: "menu",
    			menuitems: [
    				"sweep",
    				"evenodd",
    				"max"
    			]
    		},
    		layered: {
    			type: "toggle"
    		},
    		stepsize: {
    			type: "float"
    		},
    		xscale: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		color: {
    			type: "toggle"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		height: {
    			type: "number"
    		},
    		camera: {
    			type: "COMP"
    		},
    		vertexorder: {
    			type: "toggle"
    		},
    		trimval: {
    			type: "float"
    		},
    		blankingcount: {
    			type: "number"
    		},
    		yscale: {
    			type: "float"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		width: {
    			type: "number"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		trimunits: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		sop: {
    			type: "SOP"
    		},
    		rotate: {
    			type: "float"
    		},
    		chop: {
    			type: "CHOP"
    		},
    		top: {
    			type: "TOP"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		redscale: {
    			type: "float"
    		},
    		swap: {
    			type: "toggle"
    		},
    		source: {
    			type: "menu",
    			menuitems: [
    				"top",
    				"sop",
    				"chop"
    			]
    		},
    		vertexrepeat: {
    			type: "number"
    		},
    		trim: {
    			type: "toggle"
    		},
    		bluescale: {
    			type: "float"
    		},
    		triggerval: {
    			type: "float"
    		},
    		randomize: {
    			type: "toggle"
    		},
    		trigger: {
    			type: "toggle"
    		},
    		level: {
    			type: "number"
    		},
    		limit: {
    			type: "toggle"
    		},
    		rate: {
    			type: "float"
    		},
    		greenscale: {
    			type: "float"
    		},
    		limitstep: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var clipblenderCHOP = {
    	maxInputs: 3,
    	pars: {
    		logpulse: {
    			type: "pulse"
    		},
    		ytrans: {
    			type: "string"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		doxform: {
    			type: "toggle"
    		},
    		t: {
    			type: "xyz"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		resetpulse: {
    			type: "pulse"
    		},
    		prerotate: {
    			type: "toggle"
    		},
    		xtrans: {
    			type: "string"
    		},
    		qtrigger: {
    			type: "toggle"
    		},
    		datlist: {
    			type: "DAT"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		target: {
    			type: "xyz"
    		},
    		stepforward: {
    			type: "toggle"
    		},
    		fixjump: {
    			type: "toggle"
    		},
    		jumpmax: {
    		},
    		yrot: {
    			type: "string"
    		},
    		xrot: {
    			type: "string"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		jumpmin: {
    		},
    		zrot: {
    			type: "string"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		aend: {
    			type: "string"
    		},
    		jumpxy: {
    		},
    		logjumps: {
    			type: "toggle"
    		},
    		timeremaining: {
    			type: "string"
    		},
    		"default": {
    			type: "CHOP"
    		},
    		ztrans: {
    			type: "string"
    		},
    		qenable: {
    			type: "string"
    		},
    		r: {
    			type: "xyz"
    		},
    		stepbackward: {
    			type: "toggle"
    		},
    		reset: {
    			type: "toggle"
    		},
    		playspeed: {
    			type: "float"
    		},
    		printstate: {
    			type: "toggle"
    		},
    		delay: {
    			type: "number"
    		},
    		scope: {
    			type: "string"
    		},
    		timechannel: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var audiodeviceinCHOP = {
    	maxInputs: 0,
    	pars: {
    		frontcenter: {
    			type: "toggle"
    		},
    		topbackcenter: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		frontleft: {
    			type: "toggle"
    		},
    		format: {
    			type: "menu",
    			menuitems: [
    				"mono",
    				"stereo",
    				"multichannel"
    			]
    		},
    		topbackright: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		frontrightcenter: {
    			type: "toggle"
    		},
    		inputs: {
    			type: "string"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		bufferlength: {
    			type: "float"
    		},
    		backright: {
    			type: "toggle"
    		},
    		sideleft: {
    			type: "toggle"
    		},
    		errormissing: {
    			type: "toggle"
    		},
    		frontleftcenter: {
    			type: "toggle"
    		},
    		active: {
    			type: "toggle"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		lowfrequency: {
    			type: "toggle"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		topcenter: {
    			type: "toggle"
    		},
    		backcenter: {
    			type: "toggle"
    		},
    		topfrontright: {
    			type: "toggle"
    		},
    		topbackleft: {
    			type: "toggle"
    		},
    		frontright: {
    			type: "toggle"
    		},
    		driver: {
    			type: "menu",
    			menuitems: [
    				"default",
    				"asio",
    				"datapath"
    			]
    		},
    		rate: {
    			type: "float"
    		},
    		topfrontcenter: {
    			type: "toggle"
    		},
    		topfrontleft: {
    			type: "toggle"
    		},
    		device: {
    			type: "string"
    		},
    		backleft: {
    			type: "toggle"
    		},
    		sideright: {
    			type: "toggle"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var delayCHOP = {
    	maxInputs: 1,
    	pars: {
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		maxdelay: {
    			type: "float"
    		},
    		maxdelayunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		delay: {
    			type: "float"
    		},
    		delayunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds",
    				"fraction"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var toptoCHOP = {
    	maxInputs: 1,
    	pars: {
    		crop: {
    			type: "menu",
    			menuitems: [
    				"pixel",
    				"row",
    				"col",
    				"block",
    				"full"
    			]
    		},
    		uend: {
    			type: "float"
    		},
    		imageleft: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		imageright: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		defcolor: {
    			type: "rgba"
    		},
    		top: {
    			type: "TOP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		g: {
    			type: "string"
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		uvunits: {
    			type: "menu",
    			menuitems: [
    				"norm",
    				"pixel"
    			]
    		},
    		b: {
    			type: "string"
    		},
    		interp: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear"
    			]
    		},
    		left: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		vstart: {
    			type: "float"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		defval: {
    			type: "float"
    		},
    		ustart: {
    			type: "float"
    		},
    		rgbaunit: {
    			type: "menu",
    			menuitems: [
    				"u1",
    				"u256",
    				"u65536"
    			]
    		},
    		imagetop: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		a: {
    			type: "string"
    		},
    		downloadtype: {
    			type: "menu",
    			menuitems: [
    				"immediate",
    				"nextframe"
    			]
    		},
    		vend: {
    			type: "float"
    		},
    		r: {
    			type: "string"
    		},
    		rate: {
    			type: "float"
    		},
    		imagebottom: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		right: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		start: {
    			type: "float"
    		},
    		scope: {
    			type: "string"
    		},
    		startunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var clipCHOP = {
    	maxInputs: 3,
    	pars: {
    		nblendtimeunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		rord: {
    			type: "menu",
    			menuitems: [
    				"xyz",
    				"xzy",
    				"yxz",
    				"yzx",
    				"zxy",
    				"zyx"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		abspos: {
    			type: "menu",
    			menuitems: [
    				"override",
    				"blendend",
    				"blendtarget",
    				"add"
    			]
    		},
    		pauseend: {
    			type: "toggle"
    		},
    		looprelease: {
    			type: "string"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		reload: {
    			type: "pulse"
    		},
    		nblendtime: {
    			type: "float"
    		},
    		blendtimeunit: {
    			type: "menu",
    			menuitems: [
    				"samples",
    				"frames",
    				"seconds"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		loopactive: {
    			type: "toggle"
    		},
    		indexchannel: {
    			type: "string"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		rdat: {
    			type: "DAT"
    		},
    		blendtime: {
    			type: "float"
    		},
    		callbacks: {
    			type: "DAT"
    		},
    		transtion: {
    			type: "menu",
    			menuitems: [
    				"blend",
    				"waitend"
    			]
    		},
    		next: {
    			type: "string"
    		},
    		rottype: {
    			type: "menu",
    			menuitems: [
    				"same",
    				"override",
    				"blendend",
    				"blendtarget",
    				"add"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var keyboardinCHOP = {
    	maxInputs: 0,
    	pars: {
    		left: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		order: {
    			type: "menu",
    			menuitems: [
    				"qwerty",
    				"alphabetic",
    				"1qaz"
    			]
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		defval: {
    			type: "float"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		channelnames: {
    			type: "menu",
    			menuitems: [
    				"key",
    				"number"
    			]
    		},
    		rate: {
    			type: "float"
    		},
    		active: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"on",
    				"play"
    			]
    		},
    		firstkey: {
    			type: "menu",
    			menuitems: [
    				"0",
    				"1",
    				"2",
    				"3",
    				"4",
    				"5",
    				"6",
    				"7",
    				"8",
    				"9",
    				"a",
    				"b",
    				"c",
    				"d",
    				"e",
    				"f",
    				"g",
    				"h",
    				"i",
    				"j",
    				"k",
    				"l",
    				"m",
    				"n",
    				"o",
    				"p",
    				"q",
    				"r",
    				"s",
    				"t",
    				"u",
    				"v",
    				"w",
    				"x",
    				"y",
    				"z",
    				"keycomma",
    				"keyperiod",
    				"keypad0",
    				"keypad1",
    				"keypad2",
    				"keypad3",
    				"keypad4",
    				"keypad5",
    				"keypad6",
    				"keypad7",
    				"keypad8",
    				"keypad9",
    				"keypadperiod"
    			]
    		},
    		right: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"slope",
    				"cycle",
    				"mirror",
    				"default"
    			]
    		},
    		modifiers: {
    			type: "menu",
    			menuitems: [
    				"ignore",
    				"none",
    				"ctrl",
    				"alt",
    				"ctrlalt"
    			]
    		},
    		number: {
    			type: "number"
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "CHOP"
    };
    var sortCHOP = {
    	maxInputs: 1,
    	pars: {
    		indexchannel: {
    			type: "toggle"
    		},
    		exporttable: {
    			type: "DAT"
    		},
    		autoexportroot: {
    			type: "OP"
    		},
    		indices: {
    			type: "string"
    		},
    		names: {
    			type: "string"
    		},
    		timeslice: {
    			type: "toggle"
    		},
    		srselect: {
    			type: "menu",
    			menuitems: [
    				"first",
    				"max",
    				"min",
    				"err"
    			]
    		},
    		seed: {
    			type: "float"
    		},
    		select: {
    			type: "menu",
    			menuitems: [
    				"byindices",
    				"byname"
    			]
    		},
    		method: {
    			type: "menu",
    			menuitems: [
    				"increasing",
    				"decreasing",
    				"random"
    			]
    		},
    		exportmethod: {
    			type: "menu",
    			menuitems: [
    				"datindex",
    				"datname",
    				"autoname"
    			]
    		},
    		scope: {
    			type: "string"
    		}
    	},
    	minInputs: 1,
    	type: "CHOP"
    };
    var wireframeMAT = {
    	maxInputs: 0,
    	pars: {
    		linewidth: {
    			type: "float"
    		},
    		wireframemode: {
    			type: "menu",
    			menuitems: [
    				"tesselatedwireframe",
    				"topologywireframe"
    			]
    		},
    		alphafunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"greater",
    				"greaterorequal"
    			]
    		},
    		depthwriting: {
    			type: "toggle"
    		},
    		color: {
    			type: "rgb"
    		},
    		targetsop: {
    			type: "SOP"
    		},
    		polygonoffsetunits: {
    			type: "float"
    		},
    		polygonoffsetfactor: {
    			type: "float"
    		},
    		cullface: {
    			type: "menu",
    			menuitems: [
    				"userender",
    				"neither",
    				"backfaces",
    				"frontfaces",
    				"bothfaces"
    			]
    		},
    		destblend: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		depthfunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"equal",
    				"greater",
    				"greaterorequal",
    				"notequal",
    				"always"
    			]
    		},
    		depthtest: {
    			type: "toggle"
    		},
    		wireframe: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"tesselated",
    				"topology"
    			]
    		},
    		polygonoffset: {
    			type: "toggle"
    		},
    		skelrootpath: {
    			type: "string"
    		},
    		srcblend: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		dodeform: {
    			type: "toggle"
    		},
    		pcaptpath: {
    			type: "string"
    		},
    		wirewidth: {
    			type: "float"
    		},
    		alpha: {
    			type: "float"
    		},
    		separatealphafunc: {
    			type: "toggle"
    		},
    		mat: {
    			type: "MAT"
    		},
    		alphatest: {
    			type: "toggle"
    		},
    		blending: {
    			type: "toggle"
    		},
    		alphathreshold: {
    			type: "float"
    		},
    		srcblenda: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		deformdata: {
    			type: "menu",
    			menuitems: [
    				"sop",
    				"mat",
    				"deformin"
    			]
    		},
    		pcaptdata: {
    			type: "string"
    		},
    		destblenda: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "MAT"
    };
    var pointspriteMAT = {
    	maxInputs: 0,
    	pars: {
    		cullface: {
    			type: "menu",
    			menuitems: [
    				"userender",
    				"neither",
    				"backfaces",
    				"frontfaces",
    				"bothfaces"
    			]
    		},
    		colormap: {
    			type: "TOP"
    		},
    		alpha: {
    			type: "float"
    		},
    		attensizefar: {
    			type: "float"
    		},
    		colormapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		deformdata: {
    			type: "menu",
    			menuitems: [
    				"sop",
    				"mat",
    				"deformin"
    			]
    		},
    		colormapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		destblend: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		mat: {
    			type: "MAT"
    		},
    		pointscale: {
    			type: "float"
    		},
    		attenfar: {
    			type: "float"
    		},
    		skelrootpath: {
    			type: "string"
    		},
    		srcblend: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		dodeform: {
    			type: "toggle"
    		},
    		wirewidth: {
    			type: "float"
    		},
    		colormapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		attenpscale: {
    			type: "float"
    		},
    		offsetbottom: {
    			type: "float"
    		},
    		blending: {
    			type: "toggle"
    		},
    		offsettop: {
    			type: "float"
    		},
    		depthtest: {
    			type: "toggle"
    		},
    		destblenda: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		colormapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		depthwriting: {
    			type: "toggle"
    		},
    		color: {
    			type: "rgb"
    		},
    		offsetright: {
    			type: "float"
    		},
    		targetsop: {
    			type: "SOP"
    		},
    		polygonoffsetunits: {
    			type: "float"
    		},
    		polygonoffsetfactor: {
    			type: "float"
    		},
    		depthfunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"equal",
    				"greater",
    				"greaterorequal",
    				"notequal",
    				"always"
    			]
    		},
    		attensizenear: {
    			type: "float"
    		},
    		wireframe: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"tesselated",
    				"topology"
    			]
    		},
    		polygonoffset: {
    			type: "toggle"
    		},
    		offsetleft: {
    			type: "float"
    		},
    		pcaptpath: {
    			type: "string"
    		},
    		alphafunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"greater",
    				"greaterorequal"
    			]
    		},
    		separatealphafunc: {
    			type: "toggle"
    		},
    		colormapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		alphatest: {
    			type: "toggle"
    		},
    		alphathreshold: {
    			type: "float"
    		},
    		srcblenda: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		postmultalpha: {
    			type: "toggle"
    		},
    		pcaptdata: {
    			type: "string"
    		},
    		attennear: {
    			type: "float"
    		}
    	},
    	minInputs: 0,
    	type: "MAT"
    };
    var outMAT = {
    	maxInputs: 1,
    	pars: {
    		cullface: {
    			type: "menu",
    			menuitems: [
    				"userender",
    				"neither",
    				"backfaces",
    				"frontfaces",
    				"bothfaces"
    			]
    		},
    		depthwriting: {
    			type: "toggle"
    		},
    		targetsop: {
    			type: "SOP"
    		},
    		polygonoffsetunits: {
    			type: "float"
    		},
    		polygonoffsetfactor: {
    			type: "float"
    		},
    		destblend: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		depthfunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"equal",
    				"greater",
    				"greaterorequal",
    				"notequal",
    				"always"
    			]
    		},
    		depthtest: {
    			type: "toggle"
    		},
    		wireframe: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"tesselated",
    				"topology"
    			]
    		},
    		skelrootpath: {
    			type: "string"
    		},
    		label: {
    			type: "string"
    		},
    		srcblend: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		dodeform: {
    			type: "toggle"
    		},
    		pcaptpath: {
    			type: "string"
    		},
    		wirewidth: {
    			type: "float"
    		},
    		alphafunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"greater",
    				"greaterorequal"
    			]
    		},
    		separatealphafunc: {
    			type: "toggle"
    		},
    		mat: {
    			type: "MAT"
    		},
    		alphatest: {
    			type: "toggle"
    		},
    		blending: {
    			type: "toggle"
    		},
    		alphathreshold: {
    			type: "float"
    		},
    		srcblenda: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		deformdata: {
    			type: "menu",
    			menuitems: [
    				"sop",
    				"mat",
    				"deformin"
    			]
    		},
    		pcaptdata: {
    			type: "string"
    		},
    		destblenda: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		polygonoffset: {
    			type: "toggle"
    		}
    	},
    	minInputs: 1,
    	type: "MAT"
    };
    var pbrMAT = {
    	maxInputs: 0,
    	pars: {
    		emit: {
    			type: "rgb"
    		},
    		specularlevelmapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		basecolormapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		darknessemitmapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		emitmapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		applypointcolor: {
    			type: "toggle"
    		},
    		normalmapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		basecolormapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		metallicmapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		heightmapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		wirewidth: {
    			type: "float"
    		},
    		alphaside: {
    			type: "float"
    		},
    		heightmap: {
    			type: "TOP"
    		},
    		metallicmap: {
    			type: "TOP"
    		},
    		roughnessmapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		rim1strength: {
    			type: "float"
    		},
    		basecolormapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		alphamultlight: {
    			type: "toggle"
    		},
    		colorbuffer4rgb: {
    			type: "string"
    		},
    		rolloff: {
    			type: "float"
    		},
    		depthwriting: {
    			type: "toggle"
    		},
    		roughnessmapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		emitmap: {
    			type: "TOP"
    		},
    		rim1width: {
    			type: "float"
    		},
    		specularlevelmapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		roughness: {
    			type: "float"
    		},
    		polygonoffsetunits: {
    			type: "float"
    		},
    		emitmapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		polygonoffsetfactor: {
    			type: "float"
    		},
    		depthfunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"equal",
    				"greater",
    				"greaterorequal",
    				"notequal",
    				"always"
    			]
    		},
    		emitmapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		polygonoffset: {
    			type: "toggle"
    		},
    		heightmapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		rim2mapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		basecolor: {
    			type: "rgb"
    		},
    		specularlevel: {
    			type: "float"
    		},
    		heightmapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		rim2width: {
    			type: "float"
    		},
    		normalmapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		shadowcolor: {
    			type: "rgb"
    		},
    		rim1mapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		metalnessmapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		specularlevelmapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		cullface: {
    			type: "menu",
    			menuitems: [
    				"userender",
    				"neither",
    				"backfaces",
    				"frontfaces",
    				"bothfaces"
    			]
    		},
    		emitmapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		ambientocclusionmapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		metalnessmapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		specularlevelmapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		roughnessmapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		basecolormapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		rim2strength: {
    			type: "float"
    		},
    		heightmapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		darknessemitmap: {
    			type: "TOP"
    		},
    		darknessemitmapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		darknessemitmapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		roughnessmap: {
    			type: "TOP"
    		},
    		metallicmapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		alphatest: {
    			type: "toggle"
    		},
    		rim1map: {
    			type: "TOP"
    		},
    		rim2map: {
    			type: "TOP"
    		},
    		mat: {
    			type: "MAT"
    		},
    		heightmapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		normalmapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		deformdata: {
    			type: "menu",
    			menuitems: [
    				"sop",
    				"mat",
    				"deformin"
    			]
    		},
    		darknessemitmapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		normalmapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		rim1mapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		normalmap: {
    			type: "TOP"
    		},
    		specularlevelmap: {
    			type: "TOP"
    		},
    		rim1mapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		rim1strengthramp: {
    			type: "TOP"
    		},
    		envlightquality: {
    			type: "float"
    		},
    		srcblenda: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		backfacelit: {
    			type: "menu",
    			menuitems: [
    				"uselight",
    				"frontlit",
    				"backlit"
    			]
    		},
    		postmultalpha: {
    			type: "toggle"
    		},
    		rim1mapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		frontfacelit: {
    			type: "menu",
    			menuitems: [
    				"uselight",
    				"frontlit",
    				"backlit"
    			]
    		},
    		alphamapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		pcaptpath: {
    			type: "string"
    		},
    		basecolormapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		alphafunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"greater",
    				"greaterorequal"
    			]
    		},
    		rim2strengthramp: {
    			type: "TOP"
    		},
    		colorbuffer6rgb: {
    			type: "string"
    		},
    		rim1enable: {
    			type: "toggle"
    		},
    		roughnessmapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		normalmapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		alphamap: {
    			type: "TOP"
    		},
    		alphathreshold: {
    			type: "float"
    		},
    		colorbuffer2rgb: {
    			type: "string"
    		},
    		metalnessmapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		rim2mapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		emitmapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		ambientocclusion: {
    			type: "float"
    		},
    		bumpscale: {
    			type: "float"
    		},
    		parallaxclamp: {
    			type: "float"
    		},
    		dodeform: {
    			type: "toggle"
    		},
    		emitmapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		rim2center: {
    			type: "float"
    		},
    		rim1color: {
    			type: "rgb"
    		},
    		substance: {
    			type: "TOP"
    		},
    		srcblend: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		ambientocclusionmapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		rim2enable: {
    			type: "toggle"
    		},
    		normalmapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		specularlevelmapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		basecolormap: {
    			type: "TOP"
    		},
    		darknessemitmapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		shadowstrength: {
    			type: "float"
    		},
    		alphamapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		basecolormapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		rim2mapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		alphamapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		normalmapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		rim2mapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		roughnessmapchannelsource: {
    			type: "menu",
    			menuitems: [
    				"luminance",
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"rgbaverage",
    				"average"
    			]
    		},
    		alphamapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		targetsop: {
    			type: "SOP"
    		},
    		constant: {
    			type: "rgb"
    		},
    		metallic: {
    			type: "float"
    		},
    		darknessemitmapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		depthtest: {
    			type: "toggle"
    		},
    		wireframe: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"tesselated",
    				"topology"
    			]
    		},
    		specularlevelmapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		separatealphafunc: {
    			type: "toggle"
    		},
    		instancetexture: {
    			type: "string"
    		},
    		darknessemit: {
    			type: "toggle"
    		},
    		rim1center: {
    			type: "float"
    		},
    		writecameradepthtoalpha: {
    			type: "toggle"
    		},
    		ambientocclusionmapchannelsource: {
    			type: "menu",
    			menuitems: [
    				"luminance",
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"rgbaverage",
    				"average"
    			]
    		},
    		alphamapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		outputshader: {
    			type: "pulse"
    		},
    		pcaptdata: {
    			type: "string"
    		},
    		alphamode: {
    			type: "toggle"
    		},
    		metalnessmapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		roughnessmapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		specularlevelmapchannelsource: {
    			type: "menu",
    			menuitems: [
    				"luminance",
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"rgbaverage",
    				"average"
    			]
    		},
    		ambientocclusionmapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		specularlevelmapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		emitmapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		alphamapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		rim1mapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		metallicmapchannelsource: {
    			type: "menu",
    			menuitems: [
    				"luminance",
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"rgbaverage",
    				"average"
    			]
    		},
    		destblend: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		destblenda: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		ambientocclusionmapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		rim2mapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		heightmapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		alphamapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		rim1mapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		darknessemitmapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		blending: {
    			type: "toggle"
    		},
    		parallaxmapping: {
    			type: "toggle"
    		},
    		rim2mapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		darknessemitcolor: {
    			type: "rgb"
    		},
    		basecolormapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		ambientocclusionmapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		colorbuffer1rgb: {
    			type: "string"
    		},
    		rim2color: {
    			type: "rgb"
    		},
    		heightmapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		ambientocclusionmapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		roughnessmapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		ambientocclusionmapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		alphafront: {
    			type: "float"
    		},
    		metalnessmapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		colorbuffer5rgb: {
    			type: "string"
    		},
    		colorbuffer7rgb: {
    			type: "string"
    		},
    		colorbuffer3rgb: {
    			type: "string"
    		},
    		skelrootpath: {
    			type: "string"
    		},
    		rim1mapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		ambientocclusionmap: {
    			type: "TOP"
    		},
    		heightmapchannelsource: {
    			type: "menu",
    			menuitems: [
    				"luminance",
    				"red",
    				"green",
    				"blue",
    				"alpha",
    				"rgbaverage",
    				"average"
    			]
    		},
    		rim2mapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		roughnessmapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "MAT"
    };
    var phongMAT = {
    	maxInputs: 0,
    	pars: {
    		envmapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		emit: {
    			type: "rgb"
    		},
    		texture2coord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		rim1map: {
    			type: "TOP"
    		},
    		spec: {
    			type: "rgb"
    		},
    		darknessemitmapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		emitmapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		alphamapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		applypointcolor: {
    			type: "toggle"
    		},
    		mat: {
    			type: "MAT"
    		},
    		multitexturing: {
    			type: "toggle"
    		},
    		specmapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		texture1mapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		wirewidth: {
    			type: "float"
    		},
    		colormapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		alphaside: {
    			type: "float"
    		},
    		depthfunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"equal",
    				"greater",
    				"greaterorequal",
    				"notequal",
    				"always"
    			]
    		},
    		darknessemitmapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		rim2mapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		rim1strength: {
    			type: "float"
    		},
    		envmapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		alphamultlight: {
    			type: "toggle"
    		},
    		amb: {
    			type: "rgb"
    		},
    		diffusemapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		diffusemap: {
    			type: "TOP"
    		},
    		colorbuffer4rgb: {
    			type: "string"
    		},
    		wireframe: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"tesselated",
    				"topology"
    			]
    		},
    		rolloff: {
    			type: "float"
    		},
    		depthwriting: {
    			type: "toggle"
    		},
    		normalmapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		emitmap: {
    			type: "TOP"
    		},
    		rim1width: {
    			type: "float"
    		},
    		diffusemapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		polygonoffsetunits: {
    			type: "float"
    		},
    		emitmapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		polygonoffsetfactor: {
    			type: "float"
    		},
    		texture2mapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		emitmapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		polygonoffset: {
    			type: "toggle"
    		},
    		rim2mapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		rim1mapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		texture1coordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		rim2width: {
    			type: "float"
    		},
    		normalmapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		shadowcolor: {
    			type: "rgb"
    		},
    		texture3coord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		texture2: {
    			type: "TOP"
    		},
    		postmultalpha: {
    			type: "toggle"
    		},
    		parallaxclamp: {
    			type: "float"
    		},
    		multitexexpr: {
    			type: "string"
    		},
    		colormapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		writecameradepthtoalpha: {
    			type: "toggle"
    		},
    		texture2coordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		envmaprotate: {
    			type: "xyz"
    		},
    		darknessemitmap: {
    			type: "TOP"
    		},
    		darknessemitmapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		colormapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		darknessemitmapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		skelrootpath: {
    			type: "string"
    		},
    		texture4coord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		specmapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		texture3mapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		envmap: {
    			type: "TOP"
    		},
    		rim2map: {
    			type: "TOP"
    		},
    		normalmapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		shininess2: {
    			type: "float"
    		},
    		envmapcolor: {
    			type: "rgb"
    		},
    		deformdata: {
    			type: "menu",
    			menuitems: [
    				"sop",
    				"mat",
    				"deformin"
    			]
    		},
    		darknessemitmapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		normalmapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		rim1mapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		normalmap: {
    			type: "TOP"
    		},
    		texture4mapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		rim1mapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		texture1mapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		specmapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		texture2mapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		specmapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		rim1strengthramp: {
    			type: "TOP"
    		},
    		srcblenda: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		backfacelit: {
    			type: "menu",
    			menuitems: [
    				"uselight",
    				"frontlit",
    				"backlit"
    			]
    		},
    		diffusemapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		rim1mapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		texture3mapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		texture4mapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		frontfacelit: {
    			type: "menu",
    			menuitems: [
    				"uselight",
    				"frontlit",
    				"backlit"
    			]
    		},
    		alphamapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		pcaptpath: {
    			type: "string"
    		},
    		alphatest: {
    			type: "toggle"
    		},
    		emitmapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		rim2strengthramp: {
    			type: "TOP"
    		},
    		colorbuffer6rgb: {
    			type: "string"
    		},
    		rim1enable: {
    			type: "toggle"
    		},
    		normalmapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		alphamap: {
    			type: "TOP"
    		},
    		alphathreshold: {
    			type: "float"
    		},
    		colorbuffer2rgb: {
    			type: "string"
    		},
    		rim2mapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		emitmapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		specmapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		envmapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		texture1mapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		texture4mapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		colormapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		bumpscale: {
    			type: "float"
    		},
    		texture1coord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		shininess: {
    			type: "float"
    		},
    		colormapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		dodeform: {
    			type: "toggle"
    		},
    		emitmapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		texture2mapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		rim2center: {
    			type: "float"
    		},
    		rim1color: {
    			type: "rgb"
    		},
    		texture3mapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		srcblend: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		specmap: {
    			type: "TOP"
    		},
    		normalmapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		emitmapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		envmaptype2d: {
    			type: "menu",
    			menuitems: [
    				"spheremap",
    				"equirect"
    			]
    		},
    		ambdiff: {
    			type: "toggle"
    		},
    		shadowstrength: {
    			type: "float"
    		},
    		alphamapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		destblenda: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		alphamapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		diff: {
    			type: "rgb"
    		},
    		normalmapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		texture4mapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		texture3mapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		rim2mapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		texture4mapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		alphamapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		targetsop: {
    			type: "SOP"
    		},
    		cullface: {
    			type: "menu",
    			menuitems: [
    				"userender",
    				"neither",
    				"backfaces",
    				"frontfaces",
    				"bothfaces"
    			]
    		},
    		darknessemitmapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		depthtest: {
    			type: "toggle"
    		},
    		texture1: {
    			type: "TOP"
    		},
    		separatealphafunc: {
    			type: "toggle"
    		},
    		instancetexture: {
    			type: "string"
    		},
    		colormapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		rim1mapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		rim1center: {
    			type: "float"
    		},
    		alphamapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		envmapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		outputshader: {
    			type: "pulse"
    		},
    		pcaptdata: {
    			type: "string"
    		},
    		alphamode: {
    			type: "toggle"
    		},
    		specmapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		colormap: {
    			type: "TOP"
    		},
    		alphafunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"greater",
    				"greaterorequal"
    			]
    		},
    		rim2strength: {
    			type: "float"
    		},
    		diffusemapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		alphamapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		texture3mapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		rim1mapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		diffusemapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		destblend: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		texture1mapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		rim2enable: {
    			type: "toggle"
    		},
    		diffusemapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		rim2mapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		texture1mapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		rim1mapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		darknessemitmapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		blending: {
    			type: "toggle"
    		},
    		parallaxmapping: {
    			type: "toggle"
    		},
    		rim2mapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		darknessemitcolor: {
    			type: "rgb"
    		},
    		colormapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		texture2mapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		colorbuffer1rgb: {
    			type: "string"
    		},
    		rim2color: {
    			type: "rgb"
    		},
    		texture4coordnterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		spec2: {
    			type: "rgb"
    		},
    		specmapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		alphafront: {
    			type: "float"
    		},
    		colorbuffer5rgb: {
    			type: "string"
    		},
    		colorbuffer7rgb: {
    			type: "string"
    		},
    		texture4: {
    			type: "TOP"
    		},
    		colorbuffer3rgb: {
    			type: "string"
    		},
    		texture3: {
    			type: "TOP"
    		},
    		darknessemit: {
    			type: "toggle"
    		},
    		texture2mapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		texture3coordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		diffusemapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		rim2mapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		constant: {
    			type: "rgb"
    		},
    		envmapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "MAT"
    };
    var constantMAT = {
    	maxInputs: 0,
    	pars: {
    		colormapextendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		cullface: {
    			type: "menu",
    			menuitems: [
    				"userender",
    				"neither",
    				"backfaces",
    				"frontfaces",
    				"bothfaces"
    			]
    		},
    		colormap: {
    			type: "TOP"
    		},
    		colormapcoordinterp: {
    			type: "menu",
    			menuitems: [
    				"perspectivecorrect",
    				"linear"
    			]
    		},
    		alphafunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"greater",
    				"greaterorequal"
    			]
    		},
    		depthwriting: {
    			type: "toggle"
    		},
    		mat: {
    			type: "MAT"
    		},
    		color: {
    			type: "rgb"
    		},
    		colormapextendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		colormapextendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		targetsop: {
    			type: "SOP"
    		},
    		polygonoffsetunits: {
    			type: "float"
    		},
    		polygonoffsetfactor: {
    			type: "float"
    		},
    		colormapanisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		dodeform: {
    			type: "toggle"
    		},
    		deformdata: {
    			type: "menu",
    			menuitems: [
    				"sop",
    				"mat",
    				"deformin"
    			]
    		},
    		depthtest: {
    			type: "toggle"
    		},
    		wireframe: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"tesselated",
    				"topology"
    			]
    		},
    		polygonoffset: {
    			type: "toggle"
    		},
    		skelrootpath: {
    			type: "string"
    		},
    		separatealphafunc: {
    			type: "toggle"
    		},
    		srcblend: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		destblend: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		pcaptpath: {
    			type: "string"
    		},
    		wirewidth: {
    			type: "float"
    		},
    		alpha: {
    			type: "float"
    		},
    		applyprojmaps: {
    			type: "toggle"
    		},
    		depthfunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"equal",
    				"greater",
    				"greaterorequal",
    				"notequal",
    				"always"
    			]
    		},
    		colormapcoord: {
    			type: "menu",
    			menuitems: [
    				"uv0",
    				"uv1",
    				"uv2",
    				"uv3",
    				"uv4",
    				"uv5",
    				"uv6",
    				"uv7",
    				"screenspace"
    			]
    		},
    		colormapfilter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		alphatest: {
    			type: "toggle"
    		},
    		blending: {
    			type: "toggle"
    		},
    		alphathreshold: {
    			type: "float"
    		},
    		srcblenda: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		postmultalpha: {
    			type: "toggle"
    		},
    		pcaptdata: {
    			type: "string"
    		},
    		destblenda: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "MAT"
    };
    var nullMAT = {
    	maxInputs: 1,
    	pars: {
    		cullface: {
    			type: "menu",
    			menuitems: [
    				"userender",
    				"neither",
    				"backfaces",
    				"frontfaces",
    				"bothfaces"
    			]
    		},
    		depthwriting: {
    			type: "toggle"
    		},
    		targetsop: {
    			type: "SOP"
    		},
    		polygonoffsetunits: {
    			type: "float"
    		},
    		polygonoffsetfactor: {
    			type: "float"
    		},
    		destblend: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		depthfunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"equal",
    				"greater",
    				"greaterorequal",
    				"notequal",
    				"always"
    			]
    		},
    		depthtest: {
    			type: "toggle"
    		},
    		wireframe: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"tesselated",
    				"topology"
    			]
    		},
    		polygonoffset: {
    			type: "toggle"
    		},
    		skelrootpath: {
    			type: "string"
    		},
    		srcblend: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		dodeform: {
    			type: "toggle"
    		},
    		pcaptpath: {
    			type: "string"
    		},
    		wirewidth: {
    			type: "float"
    		},
    		alphafunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"greater",
    				"greaterorequal"
    			]
    		},
    		separatealphafunc: {
    			type: "toggle"
    		},
    		mat: {
    			type: "MAT"
    		},
    		alphatest: {
    			type: "toggle"
    		},
    		blending: {
    			type: "toggle"
    		},
    		alphathreshold: {
    			type: "float"
    		},
    		srcblenda: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		deformdata: {
    			type: "menu",
    			menuitems: [
    				"sop",
    				"mat",
    				"deformin"
    			]
    		},
    		pcaptdata: {
    			type: "string"
    		},
    		destblenda: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		}
    	},
    	minInputs: 1,
    	type: "MAT"
    };
    var inMAT = {
    	maxInputs: 1,
    	pars: {
    		cullface: {
    			type: "menu",
    			menuitems: [
    				"userender",
    				"neither",
    				"backfaces",
    				"frontfaces",
    				"bothfaces"
    			]
    		},
    		depthwriting: {
    			type: "toggle"
    		},
    		targetsop: {
    			type: "SOP"
    		},
    		polygonoffsetunits: {
    			type: "float"
    		},
    		polygonoffsetfactor: {
    			type: "float"
    		},
    		destblend: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		depthfunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"equal",
    				"greater",
    				"greaterorequal",
    				"notequal",
    				"always"
    			]
    		},
    		depthtest: {
    			type: "toggle"
    		},
    		wireframe: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"tesselated",
    				"topology"
    			]
    		},
    		skelrootpath: {
    			type: "string"
    		},
    		label: {
    			type: "string"
    		},
    		srcblend: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		dodeform: {
    			type: "toggle"
    		},
    		pcaptpath: {
    			type: "string"
    		},
    		wirewidth: {
    			type: "float"
    		},
    		alphafunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"greater",
    				"greaterorequal"
    			]
    		},
    		separatealphafunc: {
    			type: "toggle"
    		},
    		mat: {
    			type: "MAT"
    		},
    		alphatest: {
    			type: "toggle"
    		},
    		blending: {
    			type: "toggle"
    		},
    		alphathreshold: {
    			type: "float"
    		},
    		srcblenda: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		deformdata: {
    			type: "menu",
    			menuitems: [
    				"sop",
    				"mat",
    				"deformin"
    			]
    		},
    		pcaptdata: {
    			type: "string"
    		},
    		destblenda: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		polygonoffset: {
    			type: "toggle"
    		}
    	},
    	minInputs: 0,
    	type: "MAT"
    };
    var glslMAT = {
    	maxInputs: 0,
    	pars: {
    		pdat: {
    			type: "DAT"
    		},
    		chopuniname1: {
    			type: "string"
    		},
    		top2extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top13filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		value17: {
    			type: "xyzw"
    		},
    		value0: {
    			type: "xyzw"
    		},
    		value16: {
    			type: "xyzw"
    		},
    		chopunitype6: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		polygonoffsetfactor: {
    			type: "float"
    		},
    		top2filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		top14extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top4extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		uniname12: {
    			type: "string"
    		},
    		clearuniformnames: {
    			type: "pulse"
    		},
    		sampler5: {
    			type: "string"
    		},
    		value12: {
    			type: "xyzw"
    		},
    		mat: {
    			type: "MAT"
    		},
    		uniname8: {
    			type: "string"
    		},
    		skelrootpath: {
    			type: "string"
    		},
    		top15filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		top1extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top12extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		uniname7: {
    			type: "string"
    		},
    		wirewidth: {
    			type: "float"
    		},
    		top0extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		chopuniname4: {
    			type: "string"
    		},
    		top14anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		vdat: {
    			type: "DAT"
    		},
    		top0filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		top5extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		chopuniname9: {
    			type: "string"
    		},
    		value18: {
    			type: "xyzw"
    		},
    		chop7: {
    			type: "CHOP"
    		},
    		sampler3: {
    			type: "string"
    		},
    		chopunitype8: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		polygonoffsetunits: {
    			type: "float"
    		},
    		top5extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		fromcomp3: {
    			type: "COMP"
    		},
    		tocomp1: {
    			type: "COMP"
    		},
    		top3extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		uniname17: {
    			type: "string"
    		},
    		top4: {
    			type: "TOP"
    		},
    		uniname10: {
    			type: "string"
    		},
    		glslversion: {
    			type: "menu",
    			menuitems: [
    				"glsl120",
    				"glsl330",
    				"glsl400",
    				"glsl410",
    				"glsl420",
    				"glsl430",
    				"glsl440",
    				"glsl450",
    				"glsl460"
    			]
    		},
    		top7extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top3filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		top3anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		choparraytype4: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		top9filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		top15extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		chopunitype4: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		chanscope6: {
    			type: "string"
    		},
    		depthfunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"equal",
    				"greater",
    				"greaterorequal",
    				"notequal",
    				"always"
    			]
    		},
    		polygonoffset: {
    			type: "toggle"
    		},
    		top5anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		top14: {
    			type: "TOP"
    		},
    		top4extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		value10: {
    			type: "xyzw"
    		},
    		value11: {
    			type: "xyzw"
    		},
    		uniname4: {
    			type: "string"
    		},
    		top9anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		depthwriting: {
    			type: "toggle"
    		},
    		uniname15: {
    			type: "string"
    		},
    		top1extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		chopuniname8: {
    			type: "string"
    		},
    		tocomp0: {
    			type: "COMP"
    		},
    		top7anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		top13extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		unimatrixname4: {
    			type: "string"
    		},
    		uniname5: {
    			type: "string"
    		},
    		chop1: {
    			type: "CHOP"
    		},
    		cullface: {
    			type: "menu",
    			menuitems: [
    				"userender",
    				"neither",
    				"backfaces",
    				"frontfaces",
    				"bothfaces"
    			]
    		},
    		chanscope8: {
    			type: "string"
    		},
    		unimatrixname3: {
    			type: "string"
    		},
    		chopuniname6: {
    			type: "string"
    		},
    		top12filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		top12extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		choparraytype7: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		top7extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top0extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		chanscope2: {
    			type: "string"
    		},
    		top1anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		numout: {
    			type: "number"
    		},
    		top8extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top0: {
    			type: "TOP"
    		},
    		choparraytype3: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		destblend: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		chop6: {
    			type: "CHOP"
    		},
    		fromcomp4: {
    			type: "COMP"
    		},
    		chopuniname7: {
    			type: "string"
    		},
    		top12anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		gdat: {
    			type: "DAT"
    		},
    		blending: {
    			type: "toggle"
    		},
    		chopunitype2: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		value8: {
    			type: "xyzw"
    		},
    		unimatrixname0: {
    			type: "string"
    		},
    		value14: {
    			type: "xyzw"
    		},
    		twocolor: {
    			type: "toggle"
    		},
    		lightingspace: {
    			type: "menu",
    			menuitems: [
    				"worldspace",
    				"cameraspace"
    			]
    		},
    		deformdata: {
    			type: "menu",
    			menuitems: [
    				"sop",
    				"mat",
    				"deformin"
    			]
    		},
    		value13: {
    			type: "xyzw"
    		},
    		value7: {
    			type: "xyzw"
    		},
    		uniname16: {
    			type: "string"
    		},
    		top10anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		chanscope7: {
    			type: "string"
    		},
    		top9extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		choparraytype9: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		choparraytype6: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		chop8: {
    			type: "CHOP"
    		},
    		unimatrixname2: {
    			type: "string"
    		},
    		uniname18: {
    			type: "string"
    		},
    		top8filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		top14filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		chopunitype7: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		chanscope0: {
    			type: "string"
    		},
    		top13extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		uniname13: {
    			type: "string"
    		},
    		sampler14: {
    			type: "string"
    		},
    		top6anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		top10filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		top1: {
    			type: "TOP"
    		},
    		top15extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		value21: {
    			type: "xyzw"
    		},
    		sampler7: {
    			type: "string"
    		},
    		outprim: {
    			type: "menu",
    			menuitems: [
    				"points",
    				"linestrip",
    				"tristrip"
    			]
    		},
    		pcaptdata: {
    			type: "string"
    		},
    		pcaptpath: {
    			type: "string"
    		},
    		uniname20: {
    			type: "string"
    		},
    		alphafunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"greater",
    				"greaterorequal"
    			]
    		},
    		top14extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		sampler0: {
    			type: "string"
    		},
    		top13anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		sampler10: {
    			type: "string"
    		},
    		tocomp4: {
    			type: "COMP"
    		},
    		alphathreshold: {
    			type: "float"
    		},
    		srcblenda: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		unimatrixname1: {
    			type: "string"
    		},
    		chanscope1: {
    			type: "string"
    		},
    		sampler11: {
    			type: "string"
    		},
    		top9: {
    			type: "TOP"
    		},
    		choparraytype1: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		targetsop: {
    			type: "SOP"
    		},
    		chopuniname0: {
    			type: "string"
    		},
    		chanscope3: {
    			type: "string"
    		},
    		value4: {
    			type: "xyzw"
    		},
    		chopunitype3: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		uniname2: {
    			type: "string"
    		},
    		top12: {
    			type: "TOP"
    		},
    		dodeform: {
    			type: "toggle"
    		},
    		chopunitype0: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		top15: {
    			type: "TOP"
    		},
    		sampler2: {
    			type: "string"
    		},
    		srcblend: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		top10extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top6extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		sampler4: {
    			type: "string"
    		},
    		top15anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		top8extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		chanscope9: {
    			type: "string"
    		},
    		top11anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		top10extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		fromcomp0: {
    			type: "COMP"
    		},
    		tocomp3: {
    			type: "COMP"
    		},
    		value6: {
    			type: "xyzw"
    		},
    		top9extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top15extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		chopunitype9: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		chop3: {
    			type: "CHOP"
    		},
    		sampler1: {
    			type: "string"
    		},
    		sampler9: {
    			type: "string"
    		},
    		top5extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top13: {
    			type: "TOP"
    		},
    		top1filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		fromcomp1: {
    			type: "COMP"
    		},
    		top8: {
    			type: "TOP"
    		},
    		depthtest: {
    			type: "toggle"
    		},
    		top8extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		wireframe: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"tesselated",
    				"topology"
    			]
    		},
    		uniname1: {
    			type: "string"
    		},
    		uniname3: {
    			type: "string"
    		},
    		top0anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		uniname6: {
    			type: "string"
    		},
    		inprim: {
    			type: "menu",
    			menuitems: [
    				"points",
    				"lines",
    				"triangles"
    			]
    		},
    		uniname9: {
    			type: "string"
    		},
    		top14extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top6extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		destblenda: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		chopuniname5: {
    			type: "string"
    		},
    		top11filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		fromcomp2: {
    			type: "COMP"
    		},
    		sampler15: {
    			type: "string"
    		},
    		top4anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		chop2: {
    			type: "CHOP"
    		},
    		top6extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top12extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top13extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		inherit: {
    			type: "MAT"
    		},
    		loaduniformnames: {
    			type: "pulse"
    		},
    		top6: {
    			type: "TOP"
    		},
    		value9: {
    			type: "xyzw"
    		},
    		value15: {
    			type: "xyzw"
    		},
    		uniname19: {
    			type: "string"
    		},
    		top6filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		sampler8: {
    			type: "string"
    		},
    		top3: {
    			type: "TOP"
    		},
    		top5: {
    			type: "TOP"
    		},
    		uniname0: {
    			type: "string"
    		},
    		top0extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		choparraytype0: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		value1: {
    			type: "xyzw"
    		},
    		top7extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top11extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		choparraytype8: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		chop0: {
    			type: "CHOP"
    		},
    		value3: {
    			type: "xyzw"
    		},
    		sampler6: {
    			type: "string"
    		},
    		choparraytype5: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		top2extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top2anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		uniname14: {
    			type: "string"
    		},
    		top8anisotropy: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"2x",
    				"4x",
    				"8x",
    				"16x"
    			]
    		},
    		top4filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		value20: {
    			type: "xyzw"
    		},
    		top10extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		chopuniname3: {
    			type: "string"
    		},
    		top2: {
    			type: "TOP"
    		},
    		value2: {
    			type: "xyzw"
    		},
    		uniname11: {
    			type: "string"
    		},
    		top11extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		sampler12: {
    			type: "string"
    		},
    		top3extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top10: {
    			type: "TOP"
    		},
    		top3extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top4extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		chanscope4: {
    			type: "string"
    		},
    		top7: {
    			type: "TOP"
    		},
    		top5filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		top9extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		top11extendw: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		chop5: {
    			type: "CHOP"
    		},
    		sampler13: {
    			type: "string"
    		},
    		value19: {
    			type: "xyzw"
    		},
    		tocomp2: {
    			type: "COMP"
    		},
    		chopuniname2: {
    			type: "string"
    		},
    		value5: {
    			type: "xyzw"
    		},
    		separatealphafunc: {
    			type: "toggle"
    		},
    		top11: {
    			type: "TOP"
    		},
    		chop4: {
    			type: "CHOP"
    		},
    		choparraytype2: {
    			type: "menu",
    			menuitems: [
    				"uniformarray",
    				"texturebuffer"
    			]
    		},
    		alphatest: {
    			type: "toggle"
    		},
    		top1extendu: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		chop9: {
    			type: "CHOP"
    		},
    		top7filter: {
    			type: "menu",
    			menuitems: [
    				"nearest",
    				"linear",
    				"mipmaplinear"
    			]
    		},
    		top2extendv: {
    			type: "menu",
    			menuitems: [
    				"hold",
    				"zero",
    				"repeat",
    				"mirror"
    			]
    		},
    		chopunitype5: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		chanscope5: {
    			type: "string"
    		},
    		chopunitype1: {
    			type: "menu",
    			menuitems: [
    				"float",
    				"vec2",
    				"vec3",
    				"vec4"
    			]
    		},
    		uniname21: {
    			type: "string"
    		}
    	},
    	minInputs: 0,
    	type: "MAT"
    };
    var switchMAT = {
    	maxInputs: 9999,
    	pars: {
    		cullface: {
    			type: "menu",
    			menuitems: [
    				"userender",
    				"neither",
    				"backfaces",
    				"frontfaces",
    				"bothfaces"
    			]
    		},
    		depthwriting: {
    			type: "toggle"
    		},
    		targetsop: {
    			type: "SOP"
    		},
    		polygonoffsetunits: {
    			type: "float"
    		},
    		polygonoffsetfactor: {
    			type: "float"
    		},
    		destblend: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		depthfunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"equal",
    				"greater",
    				"greaterorequal",
    				"notequal",
    				"always"
    			]
    		},
    		depthtest: {
    			type: "toggle"
    		},
    		wireframe: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"tesselated",
    				"topology"
    			]
    		},
    		polygonoffset: {
    			type: "toggle"
    		},
    		skelrootpath: {
    			type: "string"
    		},
    		srcblend: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		dodeform: {
    			type: "toggle"
    		},
    		pcaptpath: {
    			type: "string"
    		},
    		wirewidth: {
    			type: "float"
    		},
    		alphafunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"greater",
    				"greaterorequal"
    			]
    		},
    		separatealphafunc: {
    			type: "toggle"
    		},
    		mat: {
    			type: "MAT"
    		},
    		alphatest: {
    			type: "toggle"
    		},
    		blending: {
    			type: "toggle"
    		},
    		alphathreshold: {
    			type: "float"
    		},
    		srcblenda: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		deformdata: {
    			type: "menu",
    			menuitems: [
    				"sop",
    				"mat",
    				"deformin"
    			]
    		},
    		pcaptdata: {
    			type: "string"
    		},
    		destblenda: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		index: {
    			type: "number"
    		}
    	},
    	minInputs: 1,
    	type: "MAT"
    };
    var selectMAT = {
    	maxInputs: 0,
    	pars: {
    		cullface: {
    			type: "menu",
    			menuitems: [
    				"userender",
    				"neither",
    				"backfaces",
    				"frontfaces",
    				"bothfaces"
    			]
    		},
    		depthwriting: {
    			type: "toggle"
    		},
    		selectmat: {
    			type: "MAT"
    		},
    		targetsop: {
    			type: "SOP"
    		},
    		polygonoffsetunits: {
    			type: "float"
    		},
    		polygonoffsetfactor: {
    			type: "float"
    		},
    		dodeform: {
    			type: "toggle"
    		},
    		depthfunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"equal",
    				"greater",
    				"greaterorequal",
    				"notequal",
    				"always"
    			]
    		},
    		depthtest: {
    			type: "toggle"
    		},
    		wireframe: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"tesselated",
    				"topology"
    			]
    		},
    		polygonoffset: {
    			type: "toggle"
    		},
    		skelrootpath: {
    			type: "string"
    		},
    		srcblend: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		destblend: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		pcaptpath: {
    			type: "string"
    		},
    		wirewidth: {
    			type: "float"
    		},
    		alphafunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"greater",
    				"greaterorequal"
    			]
    		},
    		separatealphafunc: {
    			type: "toggle"
    		},
    		mat: {
    			type: "MAT"
    		},
    		alphatest: {
    			type: "toggle"
    		},
    		blending: {
    			type: "toggle"
    		},
    		alphathreshold: {
    			type: "float"
    		},
    		srcblenda: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		deformdata: {
    			type: "menu",
    			menuitems: [
    				"sop",
    				"mat",
    				"deformin"
    			]
    		},
    		pcaptdata: {
    			type: "string"
    		},
    		destblenda: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "MAT"
    };
    var depthMAT = {
    	maxInputs: 0,
    	pars: {
    		cullface: {
    			type: "menu",
    			menuitems: [
    				"userender",
    				"neither",
    				"backfaces",
    				"frontfaces",
    				"bothfaces"
    			]
    		},
    		depthwriting: {
    			type: "toggle"
    		},
    		targetsop: {
    			type: "SOP"
    		},
    		polygonoffsetunits: {
    			type: "float"
    		},
    		polygonoffsetfactor: {
    			type: "float"
    		},
    		destblend: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		},
    		depthfunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"equal",
    				"greater",
    				"greaterorequal",
    				"notequal",
    				"always"
    			]
    		},
    		depthtest: {
    			type: "toggle"
    		},
    		wireframe: {
    			type: "menu",
    			menuitems: [
    				"off",
    				"tesselated",
    				"topology"
    			]
    		},
    		polygonoffset: {
    			type: "toggle"
    		},
    		skelrootpath: {
    			type: "string"
    		},
    		srcblend: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		dodeform: {
    			type: "toggle"
    		},
    		pcaptpath: {
    			type: "string"
    		},
    		wirewidth: {
    			type: "float"
    		},
    		alphafunc: {
    			type: "menu",
    			menuitems: [
    				"less",
    				"lessorequal",
    				"greater",
    				"greaterorequal"
    			]
    		},
    		separatealphafunc: {
    			type: "toggle"
    		},
    		mat: {
    			type: "MAT"
    		},
    		alphatest: {
    			type: "toggle"
    		},
    		blending: {
    			type: "toggle"
    		},
    		alphathreshold: {
    			type: "float"
    		},
    		srcblenda: {
    			type: "menu",
    			menuitems: [
    				"zero",
    				"dcol",
    				"omdcol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"sas",
    				"one"
    			]
    		},
    		deformdata: {
    			type: "menu",
    			menuitems: [
    				"sop",
    				"mat",
    				"deformin"
    			]
    		},
    		pcaptdata: {
    			type: "string"
    		},
    		destblenda: {
    			type: "menu",
    			menuitems: [
    				"one",
    				"scol",
    				"omscol",
    				"sa",
    				"omsa",
    				"da",
    				"omda",
    				"zero"
    			]
    		}
    	},
    	minInputs: 0,
    	type: "MAT"
    };
    var require$$5 = {
    	glslTOP: glslTOP,
    	packTOP: packTOP,
    	channelmixTOP: channelmixTOP,
    	convolveTOP: convolveTOP,
    	videodeviceinTOP: videodeviceinTOP,
    	embossTOP: embossTOP,
    	videostreaminTOP: videostreaminTOP,
    	webrenderTOP: webrenderTOP,
    	layoutTOP: layoutTOP,
    	projectionTOP: projectionTOP,
    	cubemapTOP: cubemapTOP,
    	rampTOP: rampTOP,
    	blurTOP: blurTOP,
    	substanceselectTOP: substanceselectTOP,
    	overTOP: overTOP,
    	analyzeTOP: analyzeTOP,
    	antialiasTOP: antialiasTOP,
    	syphonspoutinTOP: syphonspoutinTOP,
    	scalabledisplayTOP: scalabledisplayTOP,
    	multiplyTOP: multiplyTOP,
    	reorderTOP: reorderTOP,
    	edgeTOP: edgeTOP,
    	openvrTOP: openvrTOP,
    	cornerpinTOP: cornerpinTOP,
    	opencolorioTOP: opencolorioTOP,
    	sharedmeminTOP: sharedmeminTOP,
    	glslmultiTOP: glslmultiTOP,
    	compositeTOP: compositeTOP,
    	substanceTOP: substanceTOP,
    	cacheselectTOP: cacheselectTOP,
    	inTOP: inTOP,
    	underTOP: underTOP,
    	timemachineTOP: timemachineTOP,
    	addTOP: addTOP,
    	remapTOP: remapTOP,
    	oculusriftTOP: oculusriftTOP,
    	circleTOP: circleTOP,
    	svgTOP: svgTOP,
    	touchoutTOP: touchoutTOP,
    	directxoutTOP: directxoutTOP,
    	screengrabTOP: screengrabTOP,
    	differenceTOP: differenceTOP,
    	normalmapTOP: normalmapTOP,
    	lumablurTOP: lumablurTOP,
    	feedbackTOP: feedbackTOP,
    	directxinTOP: directxinTOP,
    	nullTOP: nullTOP,
    	noiseTOP: noiseTOP,
    	constantTOP: constantTOP,
    	touchinTOP: touchinTOP,
    	kinectTOP: kinectTOP,
    	blobtrackTOP: blobtrackTOP,
    	chromakeyTOP: chromakeyTOP,
    	selectTOP: selectTOP,
    	ssaoTOP: ssaoTOP,
    	prefiltermapTOP: prefiltermapTOP,
    	viosoTOP: viosoTOP,
    	cropTOP: cropTOP,
    	rgbtohsvTOP: rgbtohsvTOP,
    	videodeviceoutTOP: videodeviceoutTOP,
    	transformTOP: transformTOP,
    	opviewerTOP: opviewerTOP,
    	matteTOP: matteTOP,
    	hsvadjustTOP: hsvadjustTOP,
    	rgbkeyTOP: rgbkeyTOP,
    	fitTOP: fitTOP,
    	texture3dTOP: texture3dTOP,
    	crossTOP: crossTOP,
    	monochromeTOP: monochromeTOP,
    	leapmotionTOP: leapmotionTOP,
    	resolutionTOP: resolutionTOP,
    	thresholdTOP: thresholdTOP,
    	subtractTOP: subtractTOP,
    	outsideTOP: outsideTOP,
    	lumalevelTOP: lumalevelTOP,
    	cacheTOP: cacheTOP,
    	flipTOP: flipTOP,
    	mathTOP: mathTOP,
    	tileTOP: tileTOP,
    	renderTOP: renderTOP,
    	slopeTOP: slopeTOP,
    	depthTOP: depthTOP,
    	hsvtorgbTOP: hsvtorgbTOP,
    	videostreamoutTOP: videostreamoutTOP,
    	moviefileoutTOP: moviefileoutTOP,
    	levelTOP: levelTOP,
    	outTOP: outTOP,
    	displaceTOP: displaceTOP,
    	renderpassTOP: renderpassTOP,
    	switchTOP: switchTOP,
    	ndioutTOP: ndioutTOP,
    	insideTOP: insideTOP,
    	photoshopinTOP: photoshopinTOP,
    	textTOP: textTOP,
    	choptoTOP: choptoTOP,
    	sharedmemoutTOP: sharedmemoutTOP,
    	rectangleTOP: rectangleTOP,
    	ndiinTOP: ndiinTOP,
    	cplusplusTOP: cplusplusTOP,
    	lookupTOP: lookupTOP,
    	screenTOP: screenTOP,
    	renderselectTOP: renderselectTOP,
    	realsenseTOP: realsenseTOP,
    	moviefileinTOP: moviefileinTOP,
    	syphonspoutoutTOP: syphonspoutoutTOP,
    	revolveSOP: revolveSOP,
    	basisSOP: basisSOP,
    	trailSOP: trailSOP,
    	openvrSOP: openvrSOP,
    	rectangleSOP: rectangleSOP,
    	choptoSOP: choptoSOP,
    	fractalSOP: fractalSOP,
    	carveSOP: carveSOP,
    	isosurfaceSOP: isosurfaceSOP,
    	fitSOP: fitSOP,
    	claySOP: claySOP,
    	booleanSOP: booleanSOP,
    	alignSOP: alignSOP,
    	resampleSOP: resampleSOP,
    	dattoSOP: dattoSOP,
    	materialSOP: materialSOP,
    	objectmergeSOP: objectmergeSOP,
    	transformSOP: transformSOP,
    	inSOP: inSOP,
    	lsystemSOP: lsystemSOP,
    	spriteSOP: spriteSOP,
    	polystitchSOP: polystitchSOP,
    	fontSOP: fontSOP,
    	textSOP: textSOP,
    	captureSOP: captureSOP,
    	scriptSOP: scriptSOP,
    	deleteSOP: deleteSOP,
    	tristripSOP: tristripSOP,
    	gridSOP: gridSOP,
    	textureSOP: textureSOP,
    	magnetSOP: magnetSOP,
    	curvesectSOP: curvesectSOP,
    	polyreduceSOP: polyreduceSOP,
    	fileinSOP: fileinSOP,
    	circleSOP: circleSOP,
    	creepSOP: creepSOP,
    	holeSOP: holeSOP,
    	raySOP: raySOP,
    	extrudeSOP: extrudeSOP,
    	copySOP: copySOP,
    	subdivideSOP: subdivideSOP,
    	stitchSOP: stitchSOP,
    	cplusplusSOP: cplusplusSOP,
    	facetSOP: facetSOP,
    	forceSOP: forceSOP,
    	sweepSOP: sweepSOP,
    	polypatchSOP: polypatchSOP,
    	outSOP: outSOP,
    	switchSOP: switchSOP,
    	profileSOP: profileSOP,
    	vertexSOP: vertexSOP,
    	mergeSOP: mergeSOP,
    	divideSOP: divideSOP,
    	captureregionSOP: captureregionSOP,
    	clipSOP: clipSOP,
    	linethickSOP: linethickSOP,
    	selectSOP: selectSOP,
    	inversecurveSOP: inversecurveSOP,
    	pointSOP: pointSOP,
    	superquadSOP: superquadSOP,
    	railsSOP: railsSOP,
    	filletSOP: filletSOP,
    	armSOP: armSOP,
    	bridgeSOP: bridgeSOP,
    	wireframeSOP: wireframeSOP,
    	projectSOP: projectSOP,
    	modelSOP: modelSOP,
    	curveclaySOP: curveclaySOP,
    	limitSOP: limitSOP,
    	trimSOP: trimSOP,
    	alembicSOP: alembicSOP,
    	deformSOP: deformSOP,
    	latticeSOP: latticeSOP,
    	addSOP: addSOP,
    	tubeSOP: tubeSOP,
    	jointSOP: jointSOP,
    	attributeSOP: attributeSOP,
    	particleSOP: particleSOP,
    	noiseSOP: noiseSOP,
    	polyloftSOP: polyloftSOP,
    	nullSOP: nullSOP,
    	cacheSOP: cacheSOP,
    	blendSOP: blendSOP,
    	groupSOP: groupSOP,
    	kinectSOP: kinectSOP,
    	refineSOP: refineSOP,
    	metaballSOP: metaballSOP,
    	capSOP: capSOP,
    	joinSOP: joinSOP,
    	traceSOP: traceSOP,
    	sortSOP: sortSOP,
    	sequenceblendSOP: sequenceblendSOP,
    	convertSOP: convertSOP,
    	sphereSOP: sphereSOP,
    	boxSOP: boxSOP,
    	skinSOP: skinSOP,
    	lineSOP: lineSOP,
    	surfsectSOP: surfsectSOP,
    	primitiveSOP: primitiveSOP,
    	springSOP: springSOP,
    	twistSOP: twistSOP,
    	attributecreateSOP: attributecreateSOP,
    	lodSOP: lodSOP,
    	bonegroupSOP: bonegroupSOP,
    	polysplineSOP: polysplineSOP,
    	torusSOP: torusSOP,
    	buttonCOMP: buttonCOMP,
    	geometryCOMP: geometryCOMP,
    	handleCOMP: handleCOMP,
    	tableCOMP: tableCOMP,
    	camerablendCOMP: camerablendCOMP,
    	opviewerCOMP: opviewerCOMP,
    	fieldCOMP: fieldCOMP,
    	blendCOMP: blendCOMP,
    	parameterCOMP: parameterCOMP,
    	ambientlightCOMP: ambientlightCOMP,
    	baseCOMP: baseCOMP,
    	listCOMP: listCOMP,
    	sharedmemoutCOMP: sharedmemoutCOMP,
    	sharedmeminCOMP: sharedmeminCOMP,
    	cameraCOMP: cameraCOMP,
    	windowCOMP: windowCOMP,
    	environmentlightCOMP: environmentlightCOMP,
    	nullCOMP: nullCOMP,
    	lightCOMP: lightCOMP,
    	replicatorCOMP: replicatorCOMP,
    	timeCOMP: timeCOMP,
    	boneCOMP: boneCOMP,
    	animationCOMP: animationCOMP,
    	selectCOMP: selectCOMP,
    	sliderCOMP: sliderCOMP,
    	containerCOMP: containerCOMP,
    	websocketDAT: websocketDAT,
    	fileoutDAT: fileoutDAT,
    	substituteDAT: substituteDAT,
    	xmlDAT: xmlDAT,
    	insertDAT: insertDAT,
    	monitorsDAT: monitorsDAT,
    	udtoutDAT: udtoutDAT,
    	oscinDAT: oscinDAT,
    	chopexecuteDAT: chopexecuteDAT,
    	infoDAT: infoDAT,
    	evaluateDAT: evaluateDAT,
    	mqttclientDAT: mqttclientDAT,
    	clipDAT: clipDAT,
    	tcpipDAT: tcpipDAT,
    	soptoDAT: soptoDAT,
    	errorDAT: errorDAT,
    	tuioinDAT: tuioinDAT,
    	mergeDAT: mergeDAT,
    	oscoutDAT: oscoutDAT,
    	sortDAT: sortDAT,
    	outDAT: outDAT,
    	performDAT: performDAT,
    	fifoDAT: fifoDAT,
    	midiinDAT: midiinDAT,
    	udpoutDAT: udpoutDAT,
    	folderDAT: folderDAT,
    	panelexecuteDAT: panelexecuteDAT,
    	multitouchinDAT: multitouchinDAT,
    	executeDAT: executeDAT,
    	datexecuteDAT: datexecuteDAT,
    	nullDAT: nullDAT,
    	touchinDAT: touchinDAT,
    	choptoDAT: choptoDAT,
    	webDAT: webDAT,
    	parameterexecuteDAT: parameterexecuteDAT,
    	convertDAT: convertDAT,
    	examineDAT: examineDAT,
    	textDAT: textDAT,
    	midieventDAT: midieventDAT,
    	transposeDAT: transposeDAT,
    	inDAT: inDAT,
    	selectDAT: selectDAT,
    	serialDAT: serialDAT,
    	tableDAT: tableDAT,
    	switchDAT: switchDAT,
    	opfindDAT: opfindDAT,
    	indicesDAT: indicesDAT,
    	reorderDAT: reorderDAT,
    	udtinDAT: udtinDAT,
    	renderpickDAT: renderpickDAT,
    	fileinDAT: fileinDAT,
    	opexecuteDAT: opexecuteDAT,
    	artnetDAT: artnetDAT,
    	touchoutDAT: touchoutDAT,
    	scriptDAT: scriptDAT,
    	keyboardinDAT: keyboardinDAT,
    	etherdreamDAT: etherdreamDAT,
    	udpinDAT: udpinDAT,
    	audiobandeqCHOP: audiobandeqCHOP,
    	performCHOP: performCHOP,
    	compositeCHOP: compositeCHOP,
    	audiorenderCHOP: audiorenderCHOP,
    	transformCHOP: transformCHOP,
    	analyzeCHOP: analyzeCHOP,
    	keyframeCHOP: keyframeCHOP,
    	pipeinCHOP: pipeinCHOP,
    	inversekinCHOP: inversekinCHOP,
    	extendCHOP: extendCHOP,
    	trailCHOP: trailCHOP,
    	gestureCHOP: gestureCHOP,
    	angleCHOP: angleCHOP,
    	trimCHOP: trimCHOP,
    	speedCHOP: speedCHOP,
    	inversecurveCHOP: inversecurveCHOP,
    	ltcoutCHOP: ltcoutCHOP,
    	timelineCHOP: timelineCHOP,
    	heliosdacCHOP: heliosdacCHOP,
    	leuzerod4CHOP: leuzerod4CHOP,
    	expressionCHOP: expressionCHOP,
    	shuffleCHOP: shuffleCHOP,
    	timerCHOP: timerCHOP,
    	audiospectrumCHOP: audiospectrumCHOP,
    	nullCHOP: nullCHOP,
    	natnetinCHOP: natnetinCHOP,
    	audiodynamicsCHOP: audiodynamicsCHOP,
    	audiostreaminCHOP: audiostreaminCHOP,
    	renameCHOP: renameCHOP,
    	audiofileinCHOP: audiofileinCHOP,
    	scurveCHOP: scurveCHOP,
    	pipeoutCHOP: pipeoutCHOP,
    	objectCHOP: objectCHOP,
    	filterCHOP: filterCHOP,
    	syncoutCHOP: syncoutCHOP,
    	slopeCHOP: slopeCHOP,
    	lagCHOP: lagCHOP,
    	outCHOP: outCHOP,
    	noiseCHOP: noiseCHOP,
    	springCHOP: springCHOP,
    	feedbackCHOP: feedbackCHOP,
    	realsenseCHOP: realsenseCHOP,
    	fileoutCHOP: fileoutCHOP,
    	leapmotionCHOP: leapmotionCHOP,
    	oscoutCHOP: oscoutCHOP,
    	serialCHOP: serialCHOP,
    	interpolateCHOP: interpolateCHOP,
    	scriptCHOP: scriptCHOP,
    	handleCHOP: handleCHOP,
    	syncinCHOP: syncinCHOP,
    	clockCHOP: clockCHOP,
    	infoCHOP: infoCHOP,
    	audiomovieCHOP: audiomovieCHOP,
    	audiostreamoutCHOP: audiostreamoutCHOP,
    	touchinCHOP: touchinCHOP,
    	fanCHOP: fanCHOP,
    	parameterCHOP: parameterCHOP,
    	midiinCHOP: midiinCHOP,
    	functionCHOP: functionCHOP,
    	selectCHOP: selectCHOP,
    	ltcinCHOP: ltcinCHOP,
    	joinCHOP: joinCHOP,
    	triggerCHOP: triggerCHOP,
    	dattoCHOP: dattoCHOP,
    	shiftCHOP: shiftCHOP,
    	sharedmeminCHOP: sharedmeminCHOP,
    	blendCHOP: blendCHOP,
    	dmxoutCHOP: dmxoutCHOP,
    	resampleCHOP: resampleCHOP,
    	lfoCHOP: lfoCHOP,
    	attributeCHOP: attributeCHOP,
    	warpCHOP: warpCHOP,
    	mergeCHOP: mergeCHOP,
    	tabletCHOP: tabletCHOP,
    	audioparaeqCHOP: audioparaeqCHOP,
    	midiinmapCHOP: midiinmapCHOP,
    	panelCHOP: panelCHOP,
    	reorderCHOP: reorderCHOP,
    	patternCHOP: patternCHOP,
    	waveCHOP: waveCHOP,
    	mouseinCHOP: mouseinCHOP,
    	limitCHOP: limitCHOP,
    	cplusplusCHOP: cplusplusCHOP,
    	holdCHOP: holdCHOP,
    	posistagenetCHOP: posistagenetCHOP,
    	countCHOP: countCHOP,
    	oculusriftCHOP: oculusriftCHOP,
    	kinectCHOP: kinectCHOP,
    	blacktraxCHOP: blacktraxCHOP,
    	oculusaudioCHOP: oculusaudioCHOP,
    	mouseoutCHOP: mouseoutCHOP,
    	hokuyoCHOP: hokuyoCHOP,
    	overrideCHOP: overrideCHOP,
    	logicCHOP: logicCHOP,
    	replaceCHOP: replaceCHOP,
    	stretchCHOP: stretchCHOP,
    	audioplayCHOP: audioplayCHOP,
    	midioutCHOP: midioutCHOP,
    	sharedmemoutCHOP: sharedmemoutCHOP,
    	eventCHOP: eventCHOP,
    	constantCHOP: constantCHOP,
    	timesliceCHOP: timesliceCHOP,
    	inCHOP: inCHOP,
    	dmxinCHOP: dmxinCHOP,
    	recordCHOP: recordCHOP,
    	audiodeviceoutCHOP: audiodeviceoutCHOP,
    	copyCHOP: copyCHOP,
    	switchCHOP: switchCHOP,
    	envelopeCHOP: envelopeCHOP,
    	deleteCHOP: deleteCHOP,
    	spliceCHOP: spliceCHOP,
    	touchoutCHOP: touchoutCHOP,
    	joystickCHOP: joystickCHOP,
    	sequencerCHOP: sequencerCHOP,
    	etherdreamCHOP: etherdreamCHOP,
    	fileinCHOP: fileinCHOP,
    	lookupCHOP: lookupCHOP,
    	soptoCHOP: soptoCHOP,
    	renderpickCHOP: renderpickCHOP,
    	audiofilterCHOP: audiofilterCHOP,
    	crossCHOP: crossCHOP,
    	oscinCHOP: oscinCHOP,
    	pulseCHOP: pulseCHOP,
    	cycleCHOP: cycleCHOP,
    	audiooscillatorCHOP: audiooscillatorCHOP,
    	beatCHOP: beatCHOP,
    	openvrCHOP: openvrCHOP,
    	mathCHOP: mathCHOP,
    	hogCHOP: hogCHOP,
    	abletonlinkCHOP: abletonlinkCHOP,
    	scanCHOP: scanCHOP,
    	clipblenderCHOP: clipblenderCHOP,
    	audiodeviceinCHOP: audiodeviceinCHOP,
    	delayCHOP: delayCHOP,
    	toptoCHOP: toptoCHOP,
    	clipCHOP: clipCHOP,
    	keyboardinCHOP: keyboardinCHOP,
    	sortCHOP: sortCHOP,
    	wireframeMAT: wireframeMAT,
    	pointspriteMAT: pointspriteMAT,
    	outMAT: outMAT,
    	pbrMAT: pbrMAT,
    	phongMAT: phongMAT,
    	constantMAT: constantMAT,
    	nullMAT: nullMAT,
    	inMAT: inMAT,
    	glslMAT: glslMAT,
    	switchMAT: switchMAT,
    	selectMAT: selectMAT,
    	depthMAT: depthMAT
    };

    function altAll$1(F) {
        return function (startWith) { return function (as) { return as.reduce(function (acc, a) { return F.alt(acc, function () { return a; }); }, startWith); }; };
    }

    var Alt$d = /*#__PURE__*/Object.freeze({
        __proto__: null,
        altAll: altAll$1
    });

    /**
     * The `Alternative` type class extends the `Alt` type class with a value that should be the left and right identity for `alt`.
     *
     * It is similar to `Monoid`, except that it applies to types of kind `* -> *`, like `Array` or `Option`, rather than
     * concrete types like `string` or `number`.
     *
     * `Alternative` instances should satisfy the following laws:
     *
     * 1. Left identity: `A.alt(zero, fa) <-> fa`
     * 2. Right identity: `A.alt(fa, zero) <-> fa`
     * 3. Annihilation: `A.map(zero, f) <-> zero`
     * 4. Distributivity: `A.ap(A.alt(fab, gab), fa) <-> A.alt(A.ap(fab, fa), A.ap(gab, fa))`
     * 5. Annihilation: `A.ap(zero, fa) <-> zero`
     *
     * @since 2.0.0
     */
    function altAll(F) {
        return altAll$1(F)(F.zero());
    }

    var Alternative$4 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        altAll: altAll
    });

    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.10.0
     */
    var getBooleanAlgebra$1 = function (B) { return function () { return ({
        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },
        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },
        zero: function () { return B.zero; },
        one: function () { return B.one; },
        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },
        not: function (x) { return function (a) { return B.not(x(a)); }; }
    }); }; };
    /**
     * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.
     *
     * @example
     * import { Predicate, getSemigroup } from 'fp-ts/function'
     * import * as B from 'fp-ts/boolean'
     *
     * const f: Predicate<number> = (n) => n <= 2
     * const g: Predicate<number> = (n) => n >= 0
     *
     * const S1 = getSemigroup(B.SemigroupAll)<number>()
     *
     * assert.deepStrictEqual(S1.concat(f, g)(1), true)
     * assert.deepStrictEqual(S1.concat(f, g)(3), false)
     *
     * const S2 = getSemigroup(B.SemigroupAny)<number>()
     *
     * assert.deepStrictEqual(S2.concat(f, g)(1), true)
     * assert.deepStrictEqual(S2.concat(f, g)(3), true)
     *
     * @category instances
     * @since 2.10.0
     */
    var getSemigroup$j = function (S) { return function () { return ({
        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }
    }); }; };
    /**
     * Unary functions form a monoid as long as you can provide a monoid for the codomain.
     *
     * @example
     * import { Predicate } from 'fp-ts/Predicate'
     * import { getMonoid } from 'fp-ts/function'
     * import * as B from 'fp-ts/boolean'
     *
     * const f: Predicate<number> = (n) => n <= 2
     * const g: Predicate<number> = (n) => n >= 0
     *
     * const M1 = getMonoid(B.MonoidAll)<number>()
     *
     * assert.deepStrictEqual(M1.concat(f, g)(1), true)
     * assert.deepStrictEqual(M1.concat(f, g)(3), false)
     *
     * const M2 = getMonoid(B.MonoidAny)<number>()
     *
     * assert.deepStrictEqual(M2.concat(f, g)(1), true)
     * assert.deepStrictEqual(M2.concat(f, g)(3), true)
     *
     * @category instances
     * @since 2.10.0
     */
    var getMonoid$f = function (M) {
        var getSemigroupM = getSemigroup$j(M);
        return function () { return ({
            concat: getSemigroupM().concat,
            empty: function () { return M.empty; }
        }); };
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var getSemiring$1 = function (S) { return ({
        add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },
        zero: function () { return S.zero; },
        mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },
        one: function () { return S.one; }
    }); };
    /**
     * @category instances
     * @since 2.10.0
     */
    var getRing$1 = function (R) {
        var S = getSemiring$1(R);
        return {
            add: S.add,
            mul: S.mul,
            one: S.one,
            zero: S.zero,
            sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }
        };
    };
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var apply = function (a) { return function (f) { return f(a); }; };
    /**
     * @since 2.0.0
     */
    function identity$1(a) {
        return a;
    }
    /**
     * @since 2.0.0
     */
    var unsafeCoerce = identity$1;
    /**
     * @since 2.0.0
     */
    function constant$1(a) {
        return function () { return a; };
    }
    /**
     * A thunk that returns always `true`.
     *
     * @since 2.0.0
     */
    var constTrue = 
    /*#__PURE__*/
    constant$1(true);
    /**
     * A thunk that returns always `false`.
     *
     * @since 2.0.0
     */
    var constFalse = 
    /*#__PURE__*/
    constant$1(false);
    /**
     * A thunk that returns always `null`.
     *
     * @since 2.0.0
     */
    var constNull = 
    /*#__PURE__*/
    constant$1(null);
    /**
     * A thunk that returns always `undefined`.
     *
     * @since 2.0.0
     */
    var constUndefined = 
    /*#__PURE__*/
    constant$1(undefined);
    /**
     * A thunk that returns always `void`.
     *
     * @since 2.0.0
     */
    var constVoid = constUndefined;
    /**
     * Flips the order of the arguments of a function of two arguments.
     *
     * @since 2.0.0
     */
    function flip(f) {
        return function (b, a) { return f(a, b); };
    }
    function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
        switch (arguments.length) {
            case 1:
                return ab;
            case 2:
                return function () {
                    return bc(ab.apply(this, arguments));
                };
            case 3:
                return function () {
                    return cd(bc(ab.apply(this, arguments)));
                };
            case 4:
                return function () {
                    return de(cd(bc(ab.apply(this, arguments))));
                };
            case 5:
                return function () {
                    return ef(de(cd(bc(ab.apply(this, arguments)))));
                };
            case 6:
                return function () {
                    return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
                };
            case 7:
                return function () {
                    return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
                };
            case 8:
                return function () {
                    return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
                };
            case 9:
                return function () {
                    return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
                };
        }
        return;
    }
    /**
     * @since 2.0.0
     */
    function tuple$7() {
        var t = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            t[_i] = arguments[_i];
        }
        return t;
    }
    /**
     * @since 2.0.0
     */
    function increment(n) {
        return n + 1;
    }
    /**
     * @since 2.0.0
     */
    function decrement(n) {
        return n - 1;
    }
    /**
     * @since 2.0.0
     */
    function absurd(_) {
        throw new Error('Called `absurd` function which should be uncallable');
    }
    /**
     * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.
     *
     * @example
     * import { tupled } from 'fp-ts/function'
     *
     * const add = tupled((x: number, y: number): number => x + y)
     *
     * assert.strictEqual(add([1, 2]), 3)
     *
     * @since 2.4.0
     */
    function tupled(f) {
        return function (a) { return f.apply(void 0, a); };
    }
    /**
     * Inverse function of `tupled`
     *
     * @since 2.4.0
     */
    function untupled(f) {
        return function () {
            var a = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                a[_i] = arguments[_i];
            }
            return f(a);
        };
    }
    function pipe$1(a, ab, bc, cd, de, ef, fg, gh, hi) {
        switch (arguments.length) {
            case 1:
                return a;
            case 2:
                return ab(a);
            case 3:
                return bc(ab(a));
            case 4:
                return cd(bc(ab(a)));
            case 5:
                return de(cd(bc(ab(a))));
            case 6:
                return ef(de(cd(bc(ab(a)))));
            case 7:
                return fg(ef(de(cd(bc(ab(a))))));
            case 8:
                return gh(fg(ef(de(cd(bc(ab(a)))))));
            case 9:
                return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
            default:
                var ret = arguments[0];
                for (var i = 1; i < arguments.length; i++) {
                    ret = arguments[i](ret);
                }
                return ret;
        }
    }
    /**
     * Type hole simulation
     *
     * @since 2.7.0
     */
    var hole = absurd;
    /**
     * @since 2.11.0
     */
    var SK = function (_, b) { return b; };
    /**
     * Use `Predicate` module instead.
     *
     * @since 2.0.0
     * @deprecated
     */
    function not$2(predicate) {
        return function (a) { return !predicate(a); };
    }
    /**
     * Use `Endomorphism` module instead.
     *
     * @category instances
     * @since 2.10.0
     * @deprecated
     */
    var getEndomorphismMonoid$1 = function () { return ({
        concat: function (first, second) { return flow(first, second); },
        empty: identity$1
    }); };

    var _function$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getBooleanAlgebra: getBooleanAlgebra$1,
        getSemigroup: getSemigroup$j,
        getMonoid: getMonoid$f,
        getSemiring: getSemiring$1,
        getRing: getRing$1,
        apply: apply,
        identity: identity$1,
        unsafeCoerce: unsafeCoerce,
        constant: constant$1,
        constTrue: constTrue,
        constFalse: constFalse,
        constNull: constNull,
        constUndefined: constUndefined,
        constVoid: constVoid,
        flip: flip,
        flow: flow,
        tuple: tuple$7,
        increment: increment,
        decrement: decrement,
        absurd: absurd,
        tupled: tupled,
        untupled: untupled,
        pipe: pipe$1,
        hole: hole,
        SK: SK,
        not: not$2,
        getEndomorphismMonoid: getEndomorphismMonoid$1
    });

    function ap$p(F, G) {
        return function (fa) { return function (fab) {
            return F.ap(F.map(fab, function (gab) { return function (ga) { return G.ap(gab, ga); }; }), fa);
        }; };
    }
    function apFirst$k(A) {
        return function (second) { return function (first) {
            return A.ap(A.map(first, function (a) { return function () { return a; }; }), second);
        }; };
    }
    function apSecond$k(A) {
        return function (second) { return function (first) {
            return A.ap(A.map(first, function () { return function (b) { return b; }; }), second);
        }; };
    }
    function apS$k(F) {
        return function (name, fb) { return function (fa) {
            return F.ap(F.map(fa, function (a) { return function (b) {
                var _a;
                return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
            }; }), fb);
        }; };
    }
    function getApplySemigroup$7(F) {
        return function (S) { return ({
            concat: function (first, second) {
                return F.ap(F.map(first, function (x) { return function (y) { return S.concat(x, y); }; }), second);
            }
        }); };
    }
    function curried$1(f, n, acc) {
        return function (x) {
            var combined = Array(acc.length + 1);
            for (var i = 0; i < acc.length; i++) {
                combined[i] = acc[i];
            }
            combined[acc.length] = x;
            return n === 0 ? f.apply(null, combined) : curried$1(f, n - 1, combined);
        };
    }
    var tupleConstructors$1 = {
        1: function (a) { return [a]; },
        2: function (a) { return function (b) { return [a, b]; }; },
        3: function (a) { return function (b) { return function (c) { return [a, b, c]; }; }; },
        4: function (a) { return function (b) { return function (c) { return function (d) { return [a, b, c, d]; }; }; }; },
        5: function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return [a, b, c, d, e]; }; }; }; }; }
    };
    function getTupleConstructor$1(len) {
        if (!tupleConstructors$1.hasOwnProperty(len)) {
            tupleConstructors$1[len] = curried$1(tuple$7, len - 1, []);
        }
        return tupleConstructors$1[len];
    }
    function sequenceT$1(F) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var len = args.length;
            var f = getTupleConstructor$1(len);
            var fas = F.map(args[0], f);
            for (var i = 1; i < len; i++) {
                fas = F.ap(fas, args[i]);
            }
            return fas;
        };
    }
    function getRecordConstructor$1(keys) {
        var len = keys.length;
        switch (len) {
            case 1:
                return function (a) {
                    var _a;
                    return (_a = {}, _a[keys[0]] = a, _a);
                };
            case 2:
                return function (a) { return function (b) {
                    var _a;
                    return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a);
                }; };
            case 3:
                return function (a) { return function (b) { return function (c) {
                    var _a;
                    return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a);
                }; }; };
            case 4:
                return function (a) { return function (b) { return function (c) { return function (d) {
                    var _a;
                    return (_a = {},
                        _a[keys[0]] = a,
                        _a[keys[1]] = b,
                        _a[keys[2]] = c,
                        _a[keys[3]] = d,
                        _a);
                }; }; }; };
            case 5:
                return function (a) { return function (b) { return function (c) { return function (d) { return function (e) {
                    var _a;
                    return (_a = {},
                        _a[keys[0]] = a,
                        _a[keys[1]] = b,
                        _a[keys[2]] = c,
                        _a[keys[3]] = d,
                        _a[keys[4]] = e,
                        _a);
                }; }; }; }; };
            default:
                return curried$1(function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var r = {};
                    for (var i = 0; i < len; i++) {
                        r[keys[i]] = args[i];
                    }
                    return r;
                }, len - 1, []);
        }
    }
    function sequenceS$1(F) {
        return function (r) {
            var keys = Object.keys(r);
            var len = keys.length;
            var f = getRecordConstructor$1(keys);
            var fr = F.map(r[keys[0]], f);
            for (var i = 1; i < len; i++) {
                fr = F.ap(fr, r[keys[i]]);
            }
            return fr;
        };
    }

    var Apply$e = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ap: ap$p,
        apFirst: apFirst$k,
        apSecond: apSecond$k,
        apS: apS$k,
        getApplySemigroup: getApplySemigroup$7,
        sequenceT: sequenceT$1,
        sequenceS: sequenceS$1
    });

    /**
     * A `Functor` is a type constructor which supports a mapping operation `map`.
     *
     * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type
     * constructor `f` to represent some computational context.
     *
     * Instances must satisfy the following laws:
     *
     * 1. Identity: `F.map(fa, a => a) <-> fa`
     * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`
     *
     * @since 2.0.0
     */
    function map$E(F, G) {
        return function (f) { return function (fa) { return F.map(fa, function (ga) { return G.map(ga, f); }); }; };
    }
    function flap$x(F) {
        return function (a) { return function (fab) { return F.map(fab, function (f) { return f(a); }); }; };
    }
    function bindTo$k(F) {
        return function (name) { return function (fa) { return F.map(fa, function (a) {
            var _a;
            return (_a = {}, _a[name] = a, _a);
        }); }; };
    }
    /** @deprecated */
    function getFunctorComposition$1(F, G) {
        var _map = map$E(F, G);
        return {
            map: function (fga, f) { return pipe$1(fga, _map(f)); }
        };
    }

    var Functor$x = /*#__PURE__*/Object.freeze({
        __proto__: null,
        map: map$E,
        flap: flap$x,
        bindTo: bindTo$k,
        getFunctorComposition: getFunctorComposition$1
    });

    /**
     * The `Applicative` type class extends the `Apply` type class with a `of` function, which can be used to create values
     * of type `f a` from values of type `a`.
     *
     * Where `Apply` provides the ability to lift functions of two or more arguments to functions whose arguments are
     * wrapped using `f`, and `Functor` provides the ability to lift functions of one argument, `pure` can be seen as the
     * function which lifts functions of _zero_ arguments. That is, `Applicative` functors support a lifting operation for
     * any number of function arguments.
     *
     * Instances must satisfy the following laws in addition to the `Apply` laws:
     *
     * 1. Identity: `A.ap(A.of(a => a), fa) <-> fa`
     * 2. Homomorphism: `A.ap(A.of(ab), A.of(a)) <-> A.of(ab(a))`
     * 3. Interchange: `A.ap(fab, A.of(a)) <-> A.ap(A.of(ab => ab(a)), fab)`
     *
     * Note. `Functor`'s `map` can be derived: `A.map(x, f) = A.ap(A.of(f), x)`
     *
     * @since 2.0.0
     */
    function getApplicativeMonoid$1(F) {
        var f = getApplySemigroup$7(F);
        return function (M) { return ({
            concat: f(M).concat,
            empty: F.of(M.empty)
        }); };
    }
    /** @deprecated */
    function getApplicativeComposition$1(F, G) {
        var map = getFunctorComposition$1(F, G).map;
        var _ap = ap$p(F, G);
        return {
            map: map,
            of: function (a) { return F.of(G.of(a)); },
            ap: function (fgab, fga) { return pipe$1(fgab, _ap(fga)); }
        };
    }

    var Applicative$f = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getApplicativeMonoid: getApplicativeMonoid$1,
        getApplicativeComposition: getApplicativeComposition$1
    });

    function chainFirst$k(M) {
        return function (f) { return function (first) { return M.chain(first, function (a) { return M.map(f(a), function () { return a; }); }); }; };
    }
    function bind$m(M) {
        return function (name, f) { return function (ma) { return M.chain(ma, function (a) { return M.map(f(a), function (b) {
            var _a;
            return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
        }); }); }; };
    }

    var Chain$l = /*#__PURE__*/Object.freeze({
        __proto__: null,
        chainFirst: chainFirst$k,
        bind: bind$m
    });

    var __spreadArray$4 = (undefined && undefined.__spreadArray) || function (to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    };
    // -------------------------------------------------------------------------------------
    // Option
    // -------------------------------------------------------------------------------------
    /** @internal */
    var isNone$2 = function (fa) { return fa._tag === 'None'; };
    /** @internal */
    var isSome$2 = function (fa) { return fa._tag === 'Some'; };
    /** @internal */
    var none$2 = { _tag: 'None' };
    /** @internal */
    var some$a = function (a) { return ({ _tag: 'Some', value: a }); };
    // -------------------------------------------------------------------------------------
    // Either
    // -------------------------------------------------------------------------------------
    /** @internal */
    var isLeft$3 = function (ma) { return ma._tag === 'Left'; };
    /** @internal */
    var isRight$3 = function (ma) { return ma._tag === 'Right'; };
    /** @internal */
    var left$d = function (e) { return ({ _tag: 'Left', left: e }); };
    /** @internal */
    var right$d = function (a) { return ({ _tag: 'Right', right: a }); };
    // -------------------------------------------------------------------------------------
    // ReadonlyNonEmptyArray
    // -------------------------------------------------------------------------------------
    /** @internal */
    var singleton$7 = function (a) { return [a]; };
    /** @internal */
    var isNonEmpty$5 = function (as) { return as.length > 0; };
    /** @internal */
    var head$5 = function (as) { return as[0]; };
    /** @internal */
    var tail$5 = function (as) { return as.slice(1); };
    // -------------------------------------------------------------------------------------
    // empty
    // -------------------------------------------------------------------------------------
    /** @internal */
    var emptyReadonlyArray = [];
    /** @internal */
    var emptyRecord = {};
    // -------------------------------------------------------------------------------------
    // Record
    // -------------------------------------------------------------------------------------
    /** @internal */
    var has$4 = Object.prototype.hasOwnProperty;
    // -------------------------------------------------------------------------------------
    // NonEmptyArray
    // -------------------------------------------------------------------------------------
    /** @internal */
    var fromReadonlyNonEmptyArray$2 = function (as) { return __spreadArray$4([as[0]], as.slice(1)); };

    /**
     * The `FromEither` type class represents those data types which support errors.
     *
     * @since 2.10.0
     */
    function fromOption$c(F) {
        return function (onNone) { return function (ma) { return F.fromEither(isNone$2(ma) ? left$d(onNone()) : right$d(ma.value)); }; };
    }
    function fromPredicate$d(F) {
        return function (predicate, onFalse) { return function (a) {
            return F.fromEither(predicate(a) ? right$d(a) : left$d(onFalse(a)));
        }; };
    }
    function fromOptionK$e(F) {
        var fromOptionF = fromOption$c(F);
        return function (onNone) {
            var from = fromOptionF(onNone);
            return function (f) { return flow(f, from); };
        };
    }
    function chainOptionK$9(F, M) {
        var fromOptionKF = fromOptionK$e(F);
        return function (onNone) {
            var from = fromOptionKF(onNone);
            return function (f) { return function (ma) { return M.chain(ma, from(f)); }; };
        };
    }
    function fromEitherK$a(F) {
        return function (f) { return flow(f, F.fromEither); };
    }
    function chainEitherK$7(F, M) {
        var fromEitherKF = fromEitherK$a(F);
        return function (f) { return function (ma) { return M.chain(ma, fromEitherKF(f)); }; };
    }
    function filterOrElse$7(F, M) {
        return function (predicate, onFalse) { return function (ma) {
            return M.chain(ma, function (a) { return F.fromEither(predicate(a) ? right$d(a) : left$d(onFalse(a))); });
        }; };
    }

    var FromEither$d = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fromOption: fromOption$c,
        fromPredicate: fromPredicate$d,
        fromOptionK: fromOptionK$e,
        chainOptionK: chainOptionK$9,
        fromEitherK: fromEitherK$a,
        chainEitherK: chainEitherK$7,
        filterOrElse: filterOrElse$7
    });

    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * @category constructors
     * @since 2.0.0
     */
    var fromEquals = function (equals) { return ({
        equals: function (x, y) { return x === y || equals(x, y); }
    }); };
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * @category combinators
     * @since 2.10.0
     */
    var struct$4 = function (eqs) {
        return fromEquals(function (first, second) {
            for (var key in eqs) {
                if (!eqs[key].equals(first[key], second[key])) {
                    return false;
                }
            }
            return true;
        });
    };
    /**
     * Given a tuple of `Eq`s returns a `Eq` for the tuple
     *
     * @example
     * import { tuple } from 'fp-ts/Eq'
     * import * as S from 'fp-ts/string'
     * import * as N from 'fp-ts/number'
     * import * as B from 'fp-ts/boolean'
     *
     * const E = tuple(S.Eq, N.Eq, B.Eq)
     * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, true]), true)
     * assert.strictEqual(E.equals(['a', 1, true], ['b', 1, true]), false)
     * assert.strictEqual(E.equals(['a', 1, true], ['a', 2, true]), false)
     * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, false]), false)
     *
     * @category combinators
     * @since 2.10.0
     */
    var tuple$6 = function () {
        var eqs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            eqs[_i] = arguments[_i];
        }
        return fromEquals(function (first, second) { return eqs.every(function (E, i) { return E.equals(first[i], second[i]); }); });
    };
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    /* istanbul ignore next */
    var contramap_$2 = function (fa, f) { return pipe$1(fa, contramap$3(f)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * @category Contravariant
     * @since 2.0.0
     */
    var contramap$3 = function (f) { return function (fa) {
        return fromEquals(function (x, y) { return fa.equals(f(x), f(y)); });
    }; };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$A = 'Eq';
    /**
     * @category instances
     * @since 2.5.0
     */
    var eqStrict = {
        equals: function (a, b) { return a === b; }
    };
    var empty$a = {
        equals: function () { return true; }
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var getSemigroup$i = function () { return ({
        concat: function (x, y) { return fromEquals(function (a, b) { return x.equals(a, b) && y.equals(a, b); }); }
    }); };
    /**
     * @category instances
     * @since 2.6.0
     */
    var getMonoid$e = function () { return ({
        concat: getSemigroup$i().concat,
        empty: empty$a
    }); };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Contravariant$4 = {
        URI: URI$A,
        contramap: contramap_$2
    };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use [`tuple`](#tuple) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    var getTupleEq = tuple$6;
    /**
     * Use [`struct`](#struct) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    var getStructEq = struct$4;
    /**
     * Use [`eqStrict`](#eqstrict) instead
     *
     * @since 2.0.0
     * @deprecated
     */
    var strictEqual = eqStrict.equals;
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var eq = Contravariant$4;
    /**
     * Use [`Eq`](./boolean.ts.html#eq) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var eqBoolean = eqStrict;
    /**
     * Use [`Eq`](./string.ts.html#eq) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var eqString = eqStrict;
    /**
     * Use [`Eq`](./number.ts.html#eq) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var eqNumber = eqStrict;
    /**
     * Use [`Eq`](./Date.ts.html#eq) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var eqDate$1 = {
        equals: function (first, second) { return first.valueOf() === second.valueOf(); }
    };

    var Eq$6 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fromEquals: fromEquals,
        struct: struct$4,
        tuple: tuple$6,
        contramap: contramap$3,
        URI: URI$A,
        eqStrict: eqStrict,
        getSemigroup: getSemigroup$i,
        getMonoid: getMonoid$e,
        Contravariant: Contravariant$4,
        getTupleEq: getTupleEq,
        getStructEq: getStructEq,
        strictEqual: strictEqual,
        eq: eq,
        eqBoolean: eqBoolean,
        eqString: eqString,
        eqNumber: eqNumber,
        eqDate: eqDate$1
    });

    // -------------------------------------------------------------------------------------
    // defaults
    // -------------------------------------------------------------------------------------
    /**
     * @category defaults
     * @since 2.10.0
     */
    var equalsDefault = function (compare) { return function (first, second) {
        return first === second || compare(first, second) === 0;
    }; };
    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * @category constructors
     * @since 2.0.0
     */
    var fromCompare = function (compare) { return ({
        equals: equalsDefault(compare),
        compare: function (first, second) { return (first === second ? 0 : compare(first, second)); }
    }); };
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * Given a tuple of `Ord`s returns an `Ord` for the tuple.
     *
     * @example
     * import { tuple } from 'fp-ts/Ord'
     * import * as B from 'fp-ts/boolean'
     * import * as S from 'fp-ts/string'
     * import * as N from 'fp-ts/number'
     *
     * const O = tuple(S.Ord, N.Ord, B.Ord)
     * assert.strictEqual(O.compare(['a', 1, true], ['b', 2, true]), -1)
     * assert.strictEqual(O.compare(['a', 1, true], ['a', 2, true]), -1)
     * assert.strictEqual(O.compare(['a', 1, true], ['a', 1, false]), 1)
     *
     * @category combinators
     * @since 2.10.0
     */
    var tuple$5 = function () {
        var ords = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            ords[_i] = arguments[_i];
        }
        return fromCompare(function (first, second) {
            var i = 0;
            for (; i < ords.length - 1; i++) {
                var r = ords[i].compare(first[i], second[i]);
                if (r !== 0) {
                    return r;
                }
            }
            return ords[i].compare(first[i], second[i]);
        });
    };
    /**
     * @category combinators
     * @since 2.10.0
     */
    var reverse$a = function (O) { return fromCompare(function (first, second) { return O.compare(second, first); }); };
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    /* istanbul ignore next */
    var contramap_$1 = function (fa, f) { return pipe$1(fa, contramap$2(f)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * @category Contravariant
     * @since 2.0.0
     */
    var contramap$2 = function (f) { return function (fa) {
        return fromCompare(function (first, second) { return fa.compare(f(first), f(second)); });
    }; };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$z = 'Ord';
    /**
     * @category instances
     * @since 2.0.0
     */
    var getSemigroup$h = function () { return ({
        concat: function (first, second) {
            return fromCompare(function (a, b) {
                var ox = first.compare(a, b);
                return ox !== 0 ? ox : second.compare(a, b);
            });
        }
    }); };
    /**
     * Returns a `Monoid` such that:
     *
     * - its `concat(ord1, ord2)` operation will order first by `ord1`, and then by `ord2`
     * - its `empty` value is an `Ord` that always considers compared elements equal
     *
     * @example
     * import { sort } from 'fp-ts/Array'
     * import { contramap, reverse, getMonoid } from 'fp-ts/Ord'
     * import * as S from 'fp-ts/string'
     * import * as B from 'fp-ts/boolean'
     * import { pipe } from 'fp-ts/function'
     * import { concatAll } from 'fp-ts/Monoid'
     * import * as N from 'fp-ts/number'
     *
     * interface User {
     *   readonly id: number
     *   readonly name: string
     *   readonly age: number
     *   readonly rememberMe: boolean
     * }
     *
     * const byName = pipe(
     *   S.Ord,
     *   contramap((p: User) => p.name)
     * )
     *
     * const byAge = pipe(
     *   N.Ord,
     *   contramap((p: User) => p.age)
     * )
     *
     * const byRememberMe = pipe(
     *   B.Ord,
     *   contramap((p: User) => p.rememberMe)
     * )
     *
     * const M = getMonoid<User>()
     *
     * const users: Array<User> = [
     *   { id: 1, name: 'Guido', age: 47, rememberMe: false },
     *   { id: 2, name: 'Guido', age: 46, rememberMe: true },
     *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },
     *   { id: 4, name: 'Giulio', age: 44, rememberMe: true }
     * ]
     *
     * // sort by name, then by age, then by `rememberMe`
     * const O1 = concatAll(M)([byName, byAge, byRememberMe])
     * assert.deepStrictEqual(sort(O1)(users), [
     *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },
     *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },
     *   { id: 2, name: 'Guido', age: 46, rememberMe: true },
     *   { id: 1, name: 'Guido', age: 47, rememberMe: false }
     * ])
     *
     * // now `rememberMe = true` first, then by name, then by age
     * const O2 = concatAll(M)([reverse(byRememberMe), byName, byAge])
     * assert.deepStrictEqual(sort(O2)(users), [
     *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },
     *   { id: 2, name: 'Guido', age: 46, rememberMe: true },
     *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },
     *   { id: 1, name: 'Guido', age: 47, rememberMe: false }
     * ])
     *
     * @category instances
     * @since 2.4.0
     */
    var getMonoid$d = function () { return ({
        concat: getSemigroup$h().concat,
        empty: fromCompare(function () { return 0; })
    }); };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Contravariant$3 = {
        URI: URI$z,
        contramap: contramap_$1
    };
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var trivial = {
        equals: constTrue,
        compare: 
        /*#__PURE__*/
        constant$1(0)
    };
    /**
     * @since 2.11.0
     */
    var equals = function (O) { return function (second) { return function (first) {
        return first === second || O.compare(first, second) === 0;
    }; }; };
    // TODO: curry in v3
    /**
     * Test whether one value is _strictly less than_ another
     *
     * @since 2.0.0
     */
    var lt = function (O) { return function (first, second) { return O.compare(first, second) === -1; }; };
    // TODO: curry in v3
    /**
     * Test whether one value is _strictly greater than_ another
     *
     * @since 2.0.0
     */
    var gt = function (O) { return function (first, second) { return O.compare(first, second) === 1; }; };
    // TODO: curry in v3
    /**
     * Test whether one value is _non-strictly less than_ another
     *
     * @since 2.0.0
     */
    var leq = function (O) { return function (first, second) { return O.compare(first, second) !== 1; }; };
    // TODO: curry in v3
    /**
     * Test whether one value is _non-strictly greater than_ another
     *
     * @since 2.0.0
     */
    var geq = function (O) { return function (first, second) { return O.compare(first, second) !== -1; }; };
    // TODO: curry in v3
    /**
     * Take the minimum of two values. If they are considered equal, the first argument is chosen
     *
     * @since 2.0.0
     */
    var min$4 = function (O) { return function (first, second) {
        return first === second || O.compare(first, second) < 1 ? first : second;
    }; };
    // TODO: curry in v3
    /**
     * Take the maximum of two values. If they are considered equal, the first argument is chosen
     *
     * @since 2.0.0
     */
    var max$4 = function (O) { return function (first, second) {
        return first === second || O.compare(first, second) > -1 ? first : second;
    }; };
    /**
     * Clamp a value between a minimum and a maximum
     *
     * @since 2.0.0
     */
    var clamp = function (O) {
        var minO = min$4(O);
        var maxO = max$4(O);
        return function (low, hi) { return function (a) { return maxO(minO(a, hi), low); }; };
    };
    /**
     * Test whether a value is between a minimum and a maximum (inclusive)
     *
     * @since 2.0.0
     */
    var between = function (O) {
        var ltO = lt(O);
        var gtO = gt(O);
        return function (low, hi) { return function (a) { return (ltO(a, low) || gtO(a, hi) ? false : true); }; };
    };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use [`tuple`](#tuple) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    var getTupleOrd = tuple$5;
    /**
     * Use [`reverse`](#reverse) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    var getDualOrd = reverse$a;
    /**
     * Use [`Contravariant`](#contravariant) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var ord = Contravariant$3;
    // default compare for primitive types
    function compare$1(first, second) {
        return first < second ? -1 : first > second ? 1 : 0;
    }
    var strictOrd = {
        equals: eqStrict.equals,
        compare: compare$1
    };
    /**
     * Use [`Ord`](./boolean.ts.html#ord) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var ordBoolean = strictOrd;
    /**
     * Use [`Ord`](./string.ts.html#ord) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var ordString = strictOrd;
    /**
     * Use [`Ord`](./number.ts.html#ord) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var ordNumber = strictOrd;
    /**
     * Use [`Ord`](./Date.ts.html#ord) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var ordDate = 
    /*#__PURE__*/
    pipe$1(ordNumber, 
    /*#__PURE__*/
    contramap$2(function (date) { return date.valueOf(); }));

    var Ord$5 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        equalsDefault: equalsDefault,
        fromCompare: fromCompare,
        tuple: tuple$5,
        reverse: reverse$a,
        contramap: contramap$2,
        URI: URI$z,
        getSemigroup: getSemigroup$h,
        getMonoid: getMonoid$d,
        Contravariant: Contravariant$3,
        trivial: trivial,
        equals: equals,
        lt: lt,
        gt: gt,
        leq: leq,
        geq: geq,
        min: min$4,
        max: max$4,
        clamp: clamp,
        between: between,
        getTupleOrd: getTupleOrd,
        getDualOrd: getDualOrd,
        ord: ord,
        ordBoolean: ordBoolean,
        ordString: ordString,
        ordNumber: ordNumber,
        ordDate: ordDate
    });

    /**
     * A `Magma` is a pair `(A, concat)` in which `A` is a non-empty set and `concat` is a binary operation on `A`
     *
     * See [Semigroup](https://gcanti.github.io/fp-ts/modules/Semigroup.ts.html) for some instances.
     *
     * @since 2.0.0
     */
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * The dual of a `Magma`, obtained by swapping the arguments of `concat`.
     *
     * @example
     * import { reverse, concatAll } from 'fp-ts/Magma'
     * import * as N from 'fp-ts/number'
     *
     * const subAll = concatAll(reverse(N.MagmaSub))(0)
     *
     * assert.deepStrictEqual(subAll([1, 2, 3]), 2)
     *
     * @category combinators
     * @since 2.11.0
     */
    var reverse$9 = function (M) { return ({
        concat: function (first, second) { return M.concat(second, first); }
    }); };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var filterFirst$1 = function (predicate) { return function (M) { return ({
        concat: function (first, second) { return (predicate(first) ? M.concat(first, second) : second); }
    }); }; };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var filterSecond$1 = function (predicate) { return function (M) { return ({
        concat: function (first, second) { return (predicate(second) ? M.concat(first, second) : first); }
    }); }; };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var endo$1 = function (f) { return function (M) { return ({
        concat: function (first, second) { return M.concat(f(first), f(second)); }
    }); }; };
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * Given a sequence of `as`, concat them and return the total.
     *
     * If `as` is empty, return the provided `startWith` value.
     *
     * @example
     * import { concatAll } from 'fp-ts/Magma'
     * import * as N from 'fp-ts/number'
     *
     * const subAll = concatAll(N.MagmaSub)(0)
     *
     * assert.deepStrictEqual(subAll([1, 2, 3]), -6)
     *
     * @since 2.11.0
     */
    var concatAll$5 = function (M) { return function (startWith) { return function (as) {
        return as.reduce(function (a, acc) { return M.concat(a, acc); }, startWith);
    }; }; };

    var Magma$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        reverse: reverse$9,
        filterFirst: filterFirst$1,
        filterSecond: filterSecond$1,
        endo: endo$1,
        concatAll: concatAll$5
    });

    /**
     * If a type `A` can form a `Semigroup` it has an **associative** binary operation.
     *
     * ```ts
     * interface Semigroup<A> {
     *   readonly concat: (x: A, y: A) => A
     * }
     * ```
     *
     * Associativity means the following equality must hold for any choice of `x`, `y`, and `z`.
     *
     * ```ts
     * concat(x, concat(y, z)) = concat(concat(x, y), z)
     * ```
     *
     * A common example of a semigroup is the type `string` with the operation `+`.
     *
     * ```ts
     * import { Semigroup } from 'fp-ts/Semigroup'
     *
     * const semigroupString: Semigroup<string> = {
     *   concat: (x, y) => x + y
     * }
     *
     * const x = 'x'
     * const y = 'y'
     * const z = 'z'
     *
     * semigroupString.concat(x, y) // 'xy'
     *
     * semigroupString.concat(x, semigroupString.concat(y, z)) // 'xyz'
     *
     * semigroupString.concat(semigroupString.concat(x, y), z) // 'xyz'
     * ```
     *
     * *Adapted from https://typelevel.org/cats*
     *
     * @since 2.0.0
     */
    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * Get a semigroup where `concat` will return the minimum, based on the provided order.
     *
     * @example
     * import * as N from 'fp-ts/number'
     * import * as S from 'fp-ts/Semigroup'
     *
     * const S1 = S.min(N.Ord)
     *
     * assert.deepStrictEqual(S1.concat(1, 2), 1)
     *
     * @category constructors
     * @since 2.10.0
     */
    var min$3 = function (O) { return ({
        concat: min$4(O)
    }); };
    /**
     * Get a semigroup where `concat` will return the maximum, based on the provided order.
     *
     * @example
     * import * as N from 'fp-ts/number'
     * import * as S from 'fp-ts/Semigroup'
     *
     * const S1 = S.max(N.Ord)
     *
     * assert.deepStrictEqual(S1.concat(1, 2), 2)
     *
     * @category constructors
     * @since 2.10.0
     */
    var max$3 = function (O) { return ({
        concat: max$4(O)
    }); };
    /**
     * @category constructors
     * @since 2.10.0
     */
    var constant = function (a) { return ({
        concat: function () { return a; }
    }); };
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * The dual of a `Semigroup`, obtained by swapping the arguments of `concat`.
     *
     * @example
     * import { reverse } from 'fp-ts/Semigroup'
     * import * as S from 'fp-ts/string'
     *
     * assert.deepStrictEqual(reverse(S.Semigroup).concat('a', 'b'), 'ba')
     *
     * @category combinators
     * @since 2.10.0
     */
    var reverse$8 = reverse$9;
    /**
     * Given a struct of semigroups returns a semigroup for the struct.
     *
     * @example
     * import { struct } from 'fp-ts/Semigroup'
     * import * as N from 'fp-ts/number'
     *
     * interface Point {
     *   readonly x: number
     *   readonly y: number
     * }
     *
     * const S = struct<Point>({
     *   x: N.SemigroupSum,
     *   y: N.SemigroupSum
     * })
     *
     * assert.deepStrictEqual(S.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })
     *
     * @category combinators
     * @since 2.10.0
     */
    var struct$3 = function (semigroups) { return ({
        concat: function (first, second) {
            var r = {};
            for (var k in semigroups) {
                if (has$4.call(semigroups, k)) {
                    r[k] = semigroups[k].concat(first[k], second[k]);
                }
            }
            return r;
        }
    }); };
    /**
     * Given a tuple of semigroups returns a semigroup for the tuple.
     *
     * @example
     * import { tuple } from 'fp-ts/Semigroup'
     * import * as B from 'fp-ts/boolean'
     * import * as N from 'fp-ts/number'
     * import * as S from 'fp-ts/string'
     *
     * const S1 = tuple(S.Semigroup, N.SemigroupSum)
     * assert.deepStrictEqual(S1.concat(['a', 1], ['b', 2]), ['ab', 3])
     *
     * const S2 = tuple(S.Semigroup, N.SemigroupSum, B.SemigroupAll)
     * assert.deepStrictEqual(S2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])
     *
     * @category combinators
     * @since 2.10.0
     */
    var tuple$4 = function () {
        var semigroups = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            semigroups[_i] = arguments[_i];
        }
        return ({
            concat: function (first, second) { return semigroups.map(function (s, i) { return s.concat(first[i], second[i]); }); }
        });
    };
    /**
     * Between each pair of elements insert `middle`.
     *
     * @example
     * import { intercalate } from 'fp-ts/Semigroup'
     * import * as S from 'fp-ts/string'
     * import { pipe } from 'fp-ts/function'
     *
     * const S1 = pipe(S.Semigroup, intercalate(' + '))
     *
     * assert.strictEqual(S1.concat('a', 'b'), 'a + b')
     *
     * @category combinators
     * @since 2.10.0
     */
    var intercalate$1 = function (middle) { return function (S) { return ({
        concat: function (x, y) { return S.concat(x, S.concat(middle, y)); }
    }); }; };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * Always return the first argument.
     *
     * @example
     * import * as S from 'fp-ts/Semigroup'
     *
     * assert.deepStrictEqual(S.first<number>().concat(1, 2), 1)
     *
     * @category instances
     * @since 2.10.0
     */
    var first$1 = function () { return ({ concat: identity$1 }); };
    /**
     * Always return the last argument.
     *
     * @example
     * import * as S from 'fp-ts/Semigroup'
     *
     * assert.deepStrictEqual(S.last<number>().concat(1, 2), 2)
     *
     * @category instances
     * @since 2.10.0
     */
    var last$4 = function () { return ({ concat: function (_, y) { return y; } }); };
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * Given a sequence of `as`, concat them and return the total.
     *
     * If `as` is empty, return the provided `startWith` value.
     *
     * @example
     * import { concatAll } from 'fp-ts/Semigroup'
     * import * as N from 'fp-ts/number'
     *
     * const sum = concatAll(N.SemigroupSum)(0)
     *
     * assert.deepStrictEqual(sum([1, 2, 3]), 6)
     * assert.deepStrictEqual(sum([]), 0)
     *
     * @since 2.10.0
     */
    var concatAll$4 = concatAll$5;
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use `void` module instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var semigroupVoid = constant(undefined);
    /**
     * Use [`getAssignSemigroup`](./struct.ts.html#getAssignSemigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getObjectSemigroup = function () { return ({
        concat: function (first, second) { return Object.assign({}, first, second); }
    }); };
    /**
     * Use [`last`](#last) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getLastSemigroup = last$4;
    /**
     * Use [`first`](#first) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getFirstSemigroup = first$1;
    /**
     * Use [`tuple`](#tuple) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    var getTupleSemigroup = tuple$4;
    /**
     * Use [`struct`](#struct) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    var getStructSemigroup = struct$3;
    /**
     * Use [`reverse`](#reverse) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    var getDualSemigroup = reverse$8;
    /**
     * Use [`max`](#max) instead.
     *
     * @category constructors
     * @since 2.0.0
     * @deprecated
     */
    var getJoinSemigroup = max$3;
    /**
     * Use [`min`](#min) instead.
     *
     * @category constructors
     * @since 2.0.0
     * @deprecated
     */
    var getMeetSemigroup = min$3;
    /**
     * Use [`intercalate`](#intercalate) instead.
     *
     * @category combinators
     * @since 2.5.0
     * @deprecated
     */
    var getIntercalateSemigroup = intercalate$1;
    function fold$e(S) {
        var concatAllS = concatAll$4(S);
        return function (startWith, as) { return (as === undefined ? concatAllS(startWith) : concatAllS(startWith)(as)); };
    }
    /**
     * Use [`SemigroupAll`](./boolean.ts.html#SemigroupAll) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var semigroupAll = {
        concat: function (x, y) { return x && y; }
    };
    /**
     * Use [`SemigroupAny`](./boolean.ts.html#SemigroupAny) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var semigroupAny = {
        concat: function (x, y) { return x || y; }
    };
    /**
     * Use [`getSemigroup`](./function.ts.html#getSemigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getFunctionSemigroup = getSemigroup$j;
    /**
     * Use [`Semigroup`](./string.ts.html#Semigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var semigroupString = {
        concat: function (x, y) { return x + y; }
    };
    /**
     * Use [`SemigroupSum`](./number.ts.html#SemigroupSum) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var semigroupSum = {
        concat: function (x, y) { return x + y; }
    };
    /**
     * Use [`SemigroupProduct`](./number.ts.html#SemigroupProduct) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var semigroupProduct = {
        concat: function (x, y) { return x * y; }
    };

    var Se = /*#__PURE__*/Object.freeze({
        __proto__: null,
        min: min$3,
        max: max$3,
        constant: constant,
        reverse: reverse$8,
        struct: struct$3,
        tuple: tuple$4,
        intercalate: intercalate$1,
        first: first$1,
        last: last$4,
        concatAll: concatAll$4,
        semigroupVoid: semigroupVoid,
        getObjectSemigroup: getObjectSemigroup,
        getLastSemigroup: getLastSemigroup,
        getFirstSemigroup: getFirstSemigroup,
        getTupleSemigroup: getTupleSemigroup,
        getStructSemigroup: getStructSemigroup,
        getDualSemigroup: getDualSemigroup,
        getJoinSemigroup: getJoinSemigroup,
        getMeetSemigroup: getMeetSemigroup,
        getIntercalateSemigroup: getIntercalateSemigroup,
        fold: fold$e,
        semigroupAll: semigroupAll,
        semigroupAny: semigroupAny,
        getFunctionSemigroup: getFunctionSemigroup,
        semigroupString: semigroupString,
        semigroupSum: semigroupSum,
        semigroupProduct: semigroupProduct
    });

    var __spreadArray$3 = (undefined && undefined.__spreadArray) || function (to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    };
    // -------------------------------------------------------------------------------------
    // internal
    // -------------------------------------------------------------------------------------
    /**
     * @internal
     */
    var empty$9 = emptyReadonlyArray;
    /**
     * @internal
     */
    var isNonEmpty$4 = isNonEmpty$5;
    /**
     * @internal
     */
    var isOutOfBound$3 = function (i, as) { return i < 0 || i >= as.length; };
    /**
     * @internal
     */
    var prependW$3 = function (head) { return function (tail) { return __spreadArray$3([head], tail); }; };
    /**
     * @internal
     */
    var prepend$3 = prependW$3;
    /**
     * @internal
     */
    var appendW$3 = function (end) { return function (init) { return __spreadArray$3(__spreadArray$3([], init), [end]); }; };
    /**
     * @internal
     */
    var append$3 = appendW$3;
    /**
     * @internal
     */
    var unsafeInsertAt$3 = function (i, a, as) {
        if (isNonEmpty$4(as)) {
            var xs = fromReadonlyNonEmptyArray$2(as);
            xs.splice(i, 0, a);
            return xs;
        }
        return [a];
    };
    /**
     * @internal
     */
    var unsafeUpdateAt$3 = function (i, a, as) {
        if (as[i] === a) {
            return as;
        }
        else {
            var xs = fromReadonlyNonEmptyArray$2(as);
            xs[i] = a;
            return xs;
        }
    };
    /**
     * Remove duplicates from a `ReadonlyNonEmptyArray`, keeping the first occurrence of an element.
     *
     * @example
     * import { uniq } from 'fp-ts/ReadonlyNonEmptyArray'
     * import * as N from 'fp-ts/number'
     *
     * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])
     *
     * @category combinators
     * @since 2.11.0
     */
    var uniq$3 = function (E) { return function (as) {
        if (as.length === 1) {
            return as;
        }
        var out = [head$4(as)];
        var rest = tail$4(as);
        var _loop_1 = function (a) {
            if (out.every(function (o) { return !E.equals(o, a); })) {
                out.push(a);
            }
        };
        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {
            var a = rest_1[_i];
            _loop_1(a);
        }
        return out;
    }; };
    /**
     * Sort the elements of a `ReadonlyNonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,
     * etc...
     *
     * @example
     * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'
     * import { contramap } from 'fp-ts/Ord'
     * import * as S from 'fp-ts/string'
     * import * as N from 'fp-ts/number'
     * import { pipe } from 'fp-ts/function'
     *
     * interface Person {
     *   name: string
     *   age: number
     * }
     *
     * const byName = pipe(S.Ord, contramap((p: Person) => p.name))
     *
     * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))
     *
     * const sortByNameByAge = RNEA.sortBy([byName, byAge])
     *
     * const persons: RNEA.ReadonlyNonEmptyArray<Person> = [
     *   { name: 'a', age: 1 },
     *   { name: 'b', age: 3 },
     *   { name: 'c', age: 2 },
     *   { name: 'b', age: 2 }
     * ]
     *
     * assert.deepStrictEqual(sortByNameByAge(persons), [
     *   { name: 'a', age: 1 },
     *   { name: 'b', age: 2 },
     *   { name: 'b', age: 3 },
     *   { name: 'c', age: 2 }
     * ])
     *
     * @category combinators
     * @since 2.11.0
     */
    var sortBy$3 = function (ords) {
        if (isNonEmpty$4(ords)) {
            var M = getMonoid$d();
            return sort$3(ords.reduce(M.concat, M.empty));
        }
        return identity$1;
    };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var union$9 = function (E) {
        var uniqE = uniq$3(E);
        return function (second) { return function (first) { return uniqE(pipe$1(first, concat$4(second))); }; };
    };
    /**
     * Rotate a `ReadonlyNonEmptyArray` by `n` steps.
     *
     * @example
     * import { rotate } from 'fp-ts/ReadonlyNonEmptyArray'
     *
     * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])
     * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])
     *
     * @category combinators
     * @since 2.11.0
     */
    var rotate$4 = function (n) { return function (as) {
        var len = as.length;
        var m = Math.round(n) % len;
        if (isOutOfBound$3(Math.abs(m), as) || m === 0) {
            return as;
        }
        if (m < 0) {
            var _a = splitAt$3(-m)(as), f = _a[0], s = _a[1];
            return pipe$1(s, concat$4(f));
        }
        else {
            return rotate$4(m - len)(as);
        }
    }; };
    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * Return a `ReadonlyNonEmptyArray` from a `ReadonlyArray` returning `none` if the input is empty.
     *
     * @category constructors
     * @since 2.5.0
     */
    var fromReadonlyArray$1 = function (as) {
        return isNonEmpty$4(as) ? some$a(as) : none$2;
    };
    /**
     * Return a `ReadonlyNonEmptyArray` of length `n` with element `i` initialized with `f(i)`.
     *
     * **Note**. `n` is normalized to a natural number.
     *
     * @example
     * import { makeBy } from 'fp-ts/ReadonlyNonEmptyArray'
     * import { pipe } from 'fp-ts/function'
     *
     * const double = (n: number): number => n * 2
     * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])
     *
     * @category constructors
     * @since 2.11.0
     */
    var makeBy$3 = function (f) { return function (n) {
        var j = Math.max(0, Math.floor(n));
        var out = [f(0)];
        for (var i = 1; i < j; i++) {
            out.push(f(i));
        }
        return out;
    }; };
    /**
     * Create a `ReadonlyNonEmptyArray` containing a value repeated the specified number of times.
     *
     * **Note**. `n` is normalized to a natural number.
     *
     * @example
     * import { replicate } from 'fp-ts/ReadonlyNonEmptyArray'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])
     *
     * @category constructors
     * @since 2.11.0
     */
    var replicate$3 = function (a) { return makeBy$3(function () { return a; }); };
    /**
     * Create a `ReadonlyNonEmptyArray` containing a range of integers, including both endpoints.
     *
     * @example
     * import { range } from 'fp-ts/ReadonlyNonEmptyArray'
     *
     * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])
     *
     * @category constructors
     * @since 2.11.0
     */
    var range$3 = function (start, end) {
        return start <= end ? makeBy$3(function (i) { return start + i; })(end - start + 1) : [start];
    };
    // -------------------------------------------------------------------------------------
    // destructors
    // -------------------------------------------------------------------------------------
    /**
     * Return the tuple of the `head` and the `tail`.
     *
     * @example
     * import { unprepend } from 'fp-ts/ReadonlyNonEmptyArray'
     *
     * assert.deepStrictEqual(unprepend([1, 2, 3, 4]), [1, [2, 3, 4]])
     *
     * @category destructors
     * @since 2.9.0
     */
    var unprepend$1 = function (as) { return [head$4(as), tail$4(as)]; };
    /**
     * Return the tuple of the `init` and the `last`.
     *
     * @example
     * import { unappend } from 'fp-ts/ReadonlyNonEmptyArray'
     *
     * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])
     *
     * @category destructors
     * @since 2.9.0
     */
    var unappend$1 = function (as) { return [init$3(as), last$3(as)]; };
    // -------------------------------------------------------------------------------------
    // interop
    // -------------------------------------------------------------------------------------
    /**
     * @category interop
     * @since 2.5.0
     */
    var fromArray$4 = function (as) { return fromReadonlyArray$1(as.slice()); };
    function concatW$3(second) {
        return function (first) { return first.concat(second); };
    }
    function concat$4(x, y) {
        return y ? x.concat(y) : function (y) { return y.concat(x); };
    }
    /**
     * @category combinators
     * @since 2.5.0
     */
    var reverse$7 = function (as) {
        return as.length === 1 ? as : __spreadArray$3([last$3(as)], as.slice(0, -1).reverse());
    };
    function group$1(E) {
        return function (as) {
            var len = as.length;
            if (len === 0) {
                return empty$9;
            }
            var out = [];
            var head = as[0];
            var nea = [head];
            for (var i = 1; i < len; i++) {
                var a = as[i];
                if (E.equals(a, head)) {
                    nea.push(a);
                }
                else {
                    out.push(nea);
                    head = a;
                    nea = [head];
                }
            }
            out.push(nea);
            return out;
        };
    }
    /**
     * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning
     * function on each element, and grouping the results according to values returned
     *
     * @example
     * import { groupBy } from 'fp-ts/ReadonlyNonEmptyArray'
     *
     * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {
     *   '1': ['a', 'b'],
     *   '2': ['ab']
     * })
     *
     * @category combinators
     * @since 2.5.0
     */
    var groupBy$1 = function (f) { return function (as) {
        var out = {};
        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
            var a = as_1[_i];
            var k = f(a);
            if (out.hasOwnProperty(k)) {
                out[k].push(a);
            }
            else {
                out[k] = [a];
            }
        }
        return out;
    }; };
    /**
     * @category combinators
     * @since 2.5.0
     */
    var sort$3 = function (O) { return function (as) {
        return as.length === 1 ? as : as.slice().sort(O.compare);
    }; };
    /**
     * @category combinators
     * @since 2.5.0
     */
    var updateAt$7 = function (i, a) {
        return modifyAt$7(i, function () { return a; });
    };
    /**
     * @category combinators
     * @since 2.5.0
     */
    var modifyAt$7 = function (i, f) { return function (as) { return (isOutOfBound$3(i, as) ? none$2 : some$a(unsafeUpdateAt$3(i, f(as[i]), as))); }; };
    /**
     * @category combinators
     * @since 2.5.1
     */
    var zipWith$3 = function (as, bs, f) {
        var cs = [f(as[0], bs[0])];
        var len = Math.min(as.length, bs.length);
        for (var i = 1; i < len; i++) {
            cs[i] = f(as[i], bs[i]);
        }
        return cs;
    };
    function zip$4(as, bs) {
        if (bs === undefined) {
            return function (bs) { return zip$4(bs, as); };
        }
        return zipWith$3(as, bs, function (a, b) { return [a, b]; });
    }
    /**
     * @category combinators
     * @since 2.5.1
     */
    var unzip$3 = function (abs) {
        var fa = [abs[0][0]];
        var fb = [abs[0][1]];
        for (var i = 1; i < abs.length; i++) {
            fa[i] = abs[i][0];
            fb[i] = abs[i][1];
        }
        return [fa, fb];
    };
    /**
     * Prepend an element to every member of a `ReadonlyNonEmptyArray`.
     *
     * @example
     * import { prependAll } from 'fp-ts/ReadonlyNonEmptyArray'
     *
     * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])
     *
     * @category combinators
     * @since 2.10.0
     */
    var prependAll$3 = function (middle) { return function (as) {
        var out = [middle, as[0]];
        for (var i = 1; i < as.length; i++) {
            out.push(middle, as[i]);
        }
        return out;
    }; };
    /**
     * Places an element in between members of a `ReadonlyNonEmptyArray`.
     *
     * @example
     * import { intersperse } from 'fp-ts/ReadonlyNonEmptyArray'
     *
     * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])
     *
     * @category combinators
     * @since 2.9.0
     */
    var intersperse$3 = function (middle) { return function (as) {
        var rest = tail$4(as);
        return isNonEmpty$4(rest) ? pipe$1(rest, prependAll$3(middle), prepend$3(head$4(as))) : as;
    }; };
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainWithIndex$3 = function (f) { return function (as) {
        var out = fromReadonlyNonEmptyArray$2(f(0, head$4(as)));
        for (var i = 1; i < as.length; i++) {
            out.push.apply(out, f(i, as[i]));
        }
        return out;
    }; };
    /**
     * A useful recursion pattern for processing a `ReadonlyNonEmptyArray` to produce a new `ReadonlyNonEmptyArray`, often used for "chopping" up the input
     * `ReadonlyNonEmptyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyNonEmptyArray` and produce a
     * value and the tail of the `ReadonlyNonEmptyArray`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var chop$3 = function (f) { return function (as) {
        var _a = f(as), b = _a[0], rest = _a[1];
        var out = [b];
        var next = rest;
        while (isNonEmpty$4(next)) {
            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];
            out.push(b_1);
            next = rest_2;
        }
        return out;
    }; };
    /**
     * Splits a `ReadonlyNonEmptyArray` into two pieces, the first piece has max `n` elements.
     *
     * @category combinators
     * @since 2.10.0
     */
    var splitAt$3 = function (n) { return function (as) {
        var m = Math.max(1, n);
        return m >= as.length ? [as, empty$9] : [pipe$1(as.slice(1, m), prepend$3(head$4(as))), as.slice(m)];
    }; };
    /**
     * Splits a `ReadonlyNonEmptyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
     * the `ReadonlyNonEmptyArray`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var chunksOf$3 = function (n) { return chop$3(splitAt$3(n)); };
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _map$v = function (fa, f) { return pipe$1(fa, map$D(f)); };
    /* istanbul ignore next */
    var _mapWithIndex$7 = function (fa, f) { return pipe$1(fa, mapWithIndex$8(f)); };
    var _ap$e = function (fab, fa) { return pipe$1(fab, ap$o(fa)); };
    var _chain$i = function (ma, f) { return pipe$1(ma, chain$p(f)); };
    /* istanbul ignore next */
    var _extend$a = function (wa, f) { return pipe$1(wa, extend$a(f)); };
    /* istanbul ignore next */
    var _reduce$c = function (fa, b, f) { return pipe$1(fa, reduce$h(b, f)); };
    /* istanbul ignore next */
    var _foldMap$c = function (M) {
        var foldMapM = foldMap$h(M);
        return function (fa, f) { return pipe$1(fa, foldMapM(f)); };
    };
    /* istanbul ignore next */
    var _reduceRight$c = function (fa, b, f) { return pipe$1(fa, reduceRight$h(b, f)); };
    /* istanbul ignore next */
    var _traverse$c = function (F) {
        var traverseF = traverse$d(F);
        return function (ta, f) { return pipe$1(ta, traverseF(f)); };
    };
    /* istanbul ignore next */
    var _alt$c = function (fa, that) { return pipe$1(fa, alt$e(that)); };
    /* istanbul ignore next */
    var _reduceWithIndex$5 = function (fa, b, f) {
        return pipe$1(fa, reduceWithIndex$8(b, f));
    };
    /* istanbul ignore next */
    var _foldMapWithIndex$5 = function (M) {
        var foldMapWithIndexM = foldMapWithIndex$8(M);
        return function (fa, f) { return pipe$1(fa, foldMapWithIndexM(f)); };
    };
    /* istanbul ignore next */
    var _reduceRightWithIndex$5 = function (fa, b, f) {
        return pipe$1(fa, reduceRightWithIndex$8(b, f));
    };
    /* istanbul ignore next */
    var _traverseWithIndex$5 = function (F) {
        var traverseWithIndexF = traverseWithIndex$5(F);
        return function (ta, f) { return pipe$1(ta, traverseWithIndexF(f)); };
    };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * @category Pointed
     * @since 2.5.0
     */
    var of$o = singleton$7;
    /**
     * Less strict version of [`alt`](#alt).
     *
     * @category Alt
     * @since 2.9.0
     */
    var altW$c = function (that) { return function (as) { return pipe$1(as, concatW$3(that())); }; };
    /**
     * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
     * types of kind `* -> *`.
     *
     * @category Alt
     * @since 2.6.2
     */
    var alt$e = altW$c;
    /**
     * @category Apply
     * @since 2.5.0
     */
    var ap$o = function (as) { return chain$p(function (f) { return pipe$1(as, map$D(f)); }); };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category Monad
     * @since 2.5.0
     */
    var chain$p = function (f) { return chainWithIndex$3(function (_, a) { return f(a); }); };
    /**
     * @category Extend
     * @since 2.5.0
     */
    var extend$a = function (f) { return function (as) {
        var next = tail$4(as);
        var out = [f(as)];
        while (isNonEmpty$4(next)) {
            out.push(f(next));
            next = tail$4(next);
        }
        return out;
    }; };
    /**
     * Derivable from `Extend`.
     *
     * @category combinators
     * @since 2.5.0
     */
    var duplicate$a = 
    /*#__PURE__*/
    extend$a(identity$1);
    /**
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.5.0
     */
    var flatten$i = 
    /*#__PURE__*/
    chain$p(identity$1);
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.5.0
     */
    var map$D = function (f) {
        return mapWithIndex$8(function (_, a) { return f(a); });
    };
    /**
     * @category FunctorWithIndex
     * @since 2.5.0
     */
    var mapWithIndex$8 = function (f) { return function (as) {
        var out = [f(0, head$4(as))];
        for (var i = 1; i < as.length; i++) {
            out.push(f(i, as[i]));
        }
        return out;
    }; };
    /**
     * @category Foldable
     * @since 2.5.0
     */
    var reduce$h = function (b, f) {
        return reduceWithIndex$8(b, function (_, b, a) { return f(b, a); });
    };
    /**
     * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.
     *
     * @category Foldable
     * @since 2.5.0
     */
    var foldMap$h = function (S) { return function (f) { return function (as) {
        return as.slice(1).reduce(function (s, a) { return S.concat(s, f(a)); }, f(as[0]));
    }; }; };
    /**
     * @category Foldable
     * @since 2.5.0
     */
    var reduceRight$h = function (b, f) {
        return reduceRightWithIndex$8(b, function (_, b, a) { return f(b, a); });
    };
    /**
     * @category FoldableWithIndex
     * @since 2.5.0
     */
    var reduceWithIndex$8 = function (b, f) { return function (as) {
        return as.reduce(function (b, a, i) { return f(i, b, a); }, b);
    }; };
    /**
     * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.
     *
     * @category FoldableWithIndex
     * @since 2.5.0
     */
    var foldMapWithIndex$8 = function (S) { return function (f) { return function (as) { return as.slice(1).reduce(function (s, a, i) { return S.concat(s, f(i + 1, a)); }, f(0, as[0])); }; }; };
    /**
     * @category FoldableWithIndex
     * @since 2.5.0
     */
    var reduceRightWithIndex$8 = function (b, f) { return function (as) { return as.reduceRight(function (b, a, i) { return f(i, a, b); }, b); }; };
    /**
     * @category Traversable
     * @since 2.6.3
     */
    var traverse$d = function (F) {
        var traverseWithIndexF = traverseWithIndex$5(F);
        return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };
    };
    /**
     * @category Traversable
     * @since 2.6.3
     */
    var sequence$d = function (F) { return traverseWithIndex$5(F)(SK); };
    /**
     * @category TraversableWithIndex
     * @since 2.6.3
     */
    var traverseWithIndex$5 = function (F) { return function (f) { return function (as) {
        var out = F.map(f(0, head$4(as)), of$o);
        for (var i = 1; i < as.length; i++) {
            out = F.ap(F.map(out, function (bs) { return function (b) { return pipe$1(bs, append$3(b)); }; }), f(i, as[i]));
        }
        return out;
    }; }; };
    /**
     * @category Comonad
     * @since 2.6.3
     */
    var extract$6 = head$5;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.5.0
     */
    var URI$y = 'ReadonlyNonEmptyArray';
    /**
     * @category instances
     * @since 2.5.0
     */
    var getShow$f = function (S) { return ({
        show: function (as) { return "[" + as.map(S.show).join(', ') + "]"; }
    }); };
    /**
     * Builds a `Semigroup` instance for `ReadonlyNonEmptyArray`
     *
     * @category instances
     * @since 2.5.0
     */
    var getSemigroup$g = function () { return ({
        concat: concat$4
    }); };
    /**
     * @example
     * import { getEq } from 'fp-ts/ReadonlyNonEmptyArray'
     * import * as N from 'fp-ts/number'
     *
     * const E = getEq(N.Eq)
     * assert.strictEqual(E.equals([1, 2], [1, 2]), true)
     * assert.strictEqual(E.equals([1, 2], [1, 3]), false)
     *
     * @category instances
     * @since 2.5.0
     */
    var getEq$f = function (E) {
        return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });
    };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var getUnionSemigroup$9 = function (E) {
        var unionE = union$9(E);
        return {
            concat: function (first, second) { return unionE(second)(first); }
        };
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$w = {
        URI: URI$y,
        map: _map$v
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$w = 
    /*#__PURE__*/
    flap$x(Functor$w);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$l = {
        URI: URI$y,
        of: of$o
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var FunctorWithIndex$6 = {
        URI: URI$y,
        map: _map$v,
        mapWithIndex: _mapWithIndex$7
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Apply$d = {
        URI: URI$y,
        map: _map$v,
        ap: _ap$e
    };
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.5.0
     */
    var apFirst$j = 
    /*#__PURE__*/
    apFirst$k(Apply$d);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.5.0
     */
    var apSecond$j = 
    /*#__PURE__*/
    apSecond$k(Apply$d);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Applicative$e = {
        URI: URI$y,
        map: _map$v,
        ap: _ap$e,
        of: of$o
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$k = {
        URI: URI$y,
        map: _map$v,
        ap: _ap$e,
        chain: _chain$i
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.5.0
     */
    var chainFirst$j = 
    /*#__PURE__*/
    chainFirst$k(Chain$k);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Monad$j = {
        URI: URI$y,
        map: _map$v,
        ap: _ap$e,
        of: of$o,
        chain: _chain$i
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Foldable$d = {
        URI: URI$y,
        reduce: _reduce$c,
        foldMap: _foldMap$c,
        reduceRight: _reduceRight$c
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var FoldableWithIndex$6 = {
        URI: URI$y,
        reduce: _reduce$c,
        foldMap: _foldMap$c,
        reduceRight: _reduceRight$c,
        reduceWithIndex: _reduceWithIndex$5,
        foldMapWithIndex: _foldMapWithIndex$5,
        reduceRightWithIndex: _reduceRightWithIndex$5
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Traversable$d = {
        URI: URI$y,
        map: _map$v,
        reduce: _reduce$c,
        foldMap: _foldMap$c,
        reduceRight: _reduceRight$c,
        traverse: _traverse$c,
        sequence: sequence$d
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var TraversableWithIndex$6 = {
        URI: URI$y,
        map: _map$v,
        mapWithIndex: _mapWithIndex$7,
        reduce: _reduce$c,
        foldMap: _foldMap$c,
        reduceRight: _reduceRight$c,
        traverse: _traverse$c,
        sequence: sequence$d,
        reduceWithIndex: _reduceWithIndex$5,
        foldMapWithIndex: _foldMapWithIndex$5,
        reduceRightWithIndex: _reduceRightWithIndex$5,
        traverseWithIndex: _traverseWithIndex$5
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Alt$c = {
        URI: URI$y,
        map: _map$v,
        alt: _alt$c
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Comonad$7 = {
        URI: URI$y,
        map: _map$v,
        extend: _extend$a,
        extract: extract$6
    };
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.9.0
     */
    var Do$g = 
    /*#__PURE__*/
    of$o(emptyRecord);
    /**
     * @since 2.8.0
     */
    var bindTo$j = 
    /*#__PURE__*/
    bindTo$k(Functor$w);
    /**
     * @since 2.8.0
     */
    var bind$l = 
    /*#__PURE__*/
    bind$m(Chain$k);
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var apS$j = 
    /*#__PURE__*/
    apS$k(Apply$d);
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.5.0
     */
    var head$4 = extract$6;
    /**
     * @since 2.5.0
     */
    var tail$4 = tail$5;
    /**
     * @since 2.5.0
     */
    var last$3 = function (as) { return as[as.length - 1]; };
    /**
     * Get all but the last element of a non empty array, creating a new array.
     *
     * @example
     * import { init } from 'fp-ts/ReadonlyNonEmptyArray'
     *
     * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])
     * assert.deepStrictEqual(init([1]), [])
     *
     * @since 2.5.0
     */
    var init$3 = function (as) { return as.slice(0, -1); };
    /**
     * @since 2.5.0
     */
    var min$2 = function (O) {
        var S = min$3(O);
        return function (as) { return as.reduce(S.concat); };
    };
    /**
     * @since 2.5.0
     */
    var max$2 = function (O) {
        var S = max$3(O);
        return function (as) { return as.reduce(S.concat); };
    };
    /**
     * @since 2.10.0
     */
    var concatAll$3 = function (S) { return function (as) { return as.reduce(S.concat); }; };
    /**
     * Break a `ReadonlyArray` into its first element and remaining elements.
     *
     * @category destructors
     * @since 2.11.0
     */
    var matchLeft$3 = function (f) { return function (as) {
        return f(head$4(as), tail$4(as));
    }; };
    /**
     * Break a `ReadonlyArray` into its initial elements and the last element.
     *
     * @category destructors
     * @since 2.11.0
     */
    var matchRight$3 = function (f) { return function (as) {
        return f(init$3(as), last$3(as));
    }; };
    /**
     * Apply a function to the head, creating a new `ReadonlyNonEmptyArray`.
     *
     * @since 2.11.0
     */
    var modifyHead$1 = function (f) { return function (as) { return __spreadArray$3([
        f(head$4(as))
    ], tail$4(as)); }; };
    /**
     * Change the head, creating a new `ReadonlyNonEmptyArray`.
     *
     * @category combinators
     * @since 2.11.0
     */
    var updateHead$1 = function (a) { return modifyHead$1(function () { return a; }); };
    /**
     * Apply a function to the last element, creating a new `ReadonlyNonEmptyArray`.
     *
     * @since 2.11.0
     */
    var modifyLast$1 = function (f) { return function (as) {
        return pipe$1(init$3(as), append$3(f(last$3(as))));
    }; };
    /**
     * Change the last element, creating a new `ReadonlyNonEmptyArray`.
     *
     * @category combinators
     * @since 2.11.0
     */
    var updateLast$1 = function (a) { return modifyLast$1(function () { return a; }); };
    function groupSort$1(O) {
        var sortO = sort$3(O);
        var groupO = group$1(O);
        return function (as) { return (isNonEmpty$4(as) ? groupO(sortO(as)) : empty$9); };
    }
    function filter$c(predicate) {
        return filterWithIndex$7(function (_, a) { return predicate(a); });
    }
    /**
     * Use [`filterWithIndex`](./ReadonlyArray.ts.html#filterwithindex) instead.
     *
     * @category combinators
     * @since 2.5.0
     * @deprecated
     */
    var filterWithIndex$7 = function (predicate) { return function (as) { return fromReadonlyArray$1(as.filter(function (a, i) { return predicate(i, a); })); }; };
    /**
     * Use [`unprepend`](#unprepend) instead.
     *
     * @category destructors
     * @since 2.10.0
     * @deprecated
     */
    var uncons$1 = unprepend$1;
    /**
     * Use [`unappend`](#unappend) instead.
     *
     * @category destructors
     * @since 2.10.0
     * @deprecated
     */
    var unsnoc$1 = unappend$1;
    function cons$3(head, tail) {
        return tail === undefined ? prepend$3(head) : pipe$1(tail, prepend$3(head));
    }
    /**
     * Use [`append`](./ReadonlyArray.ts.html#append) instead.
     *
     * @category constructors
     * @since 2.5.0
     * @deprecated
     */
    var snoc$3 = function (init, end) { return pipe$1(init, concat$4([end])); };
    /**
     * Use [`insertAt`](./ReadonlyArray.ts.html#insertat) instead.
     *
     * @category combinators
     * @since 2.5.0
     * @deprecated
     */
    var insertAt$7 = function (i, a) { return function (as) {
        return i < 0 || i > as.length ? none$2 : some$a(unsafeInsertAt$3(i, a, as));
    }; };
    /**
     * Use [`prependAll`](#prependall) instead.
     *
     * @category combinators
     * @since 2.9.0
     * @deprecated
     */
    var prependToAll$3 = prependAll$3;
    /**
     * Use [`concatAll`](#concatall) instead.
     *
     * @since 2.5.0
     * @deprecated
     */
    var fold$d = concatAll$3;
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.5.0
     * @deprecated
     */
    var readonlyNonEmptyArray = {
        URI: URI$y,
        of: of$o,
        map: _map$v,
        mapWithIndex: _mapWithIndex$7,
        ap: _ap$e,
        chain: _chain$i,
        extend: _extend$a,
        extract: extract$6,
        reduce: _reduce$c,
        foldMap: _foldMap$c,
        reduceRight: _reduceRight$c,
        traverse: _traverse$c,
        sequence: sequence$d,
        reduceWithIndex: _reduceWithIndex$5,
        foldMapWithIndex: _foldMapWithIndex$5,
        reduceRightWithIndex: _reduceRightWithIndex$5,
        traverseWithIndex: _traverseWithIndex$5,
        alt: _alt$c
    };

    var ReadonlyNonEmptyArray = /*#__PURE__*/Object.freeze({
        __proto__: null,
        empty: empty$9,
        isNonEmpty: isNonEmpty$4,
        isOutOfBound: isOutOfBound$3,
        prependW: prependW$3,
        prepend: prepend$3,
        appendW: appendW$3,
        append: append$3,
        unsafeInsertAt: unsafeInsertAt$3,
        unsafeUpdateAt: unsafeUpdateAt$3,
        uniq: uniq$3,
        sortBy: sortBy$3,
        union: union$9,
        rotate: rotate$4,
        fromReadonlyArray: fromReadonlyArray$1,
        makeBy: makeBy$3,
        replicate: replicate$3,
        range: range$3,
        unprepend: unprepend$1,
        unappend: unappend$1,
        fromArray: fromArray$4,
        concatW: concatW$3,
        concat: concat$4,
        reverse: reverse$7,
        group: group$1,
        groupBy: groupBy$1,
        sort: sort$3,
        updateAt: updateAt$7,
        modifyAt: modifyAt$7,
        zipWith: zipWith$3,
        zip: zip$4,
        unzip: unzip$3,
        prependAll: prependAll$3,
        intersperse: intersperse$3,
        chainWithIndex: chainWithIndex$3,
        chop: chop$3,
        splitAt: splitAt$3,
        chunksOf: chunksOf$3,
        of: of$o,
        altW: altW$c,
        alt: alt$e,
        ap: ap$o,
        chain: chain$p,
        extend: extend$a,
        duplicate: duplicate$a,
        flatten: flatten$i,
        map: map$D,
        mapWithIndex: mapWithIndex$8,
        reduce: reduce$h,
        foldMap: foldMap$h,
        reduceRight: reduceRight$h,
        reduceWithIndex: reduceWithIndex$8,
        foldMapWithIndex: foldMapWithIndex$8,
        reduceRightWithIndex: reduceRightWithIndex$8,
        traverse: traverse$d,
        sequence: sequence$d,
        traverseWithIndex: traverseWithIndex$5,
        extract: extract$6,
        URI: URI$y,
        getShow: getShow$f,
        getSemigroup: getSemigroup$g,
        getEq: getEq$f,
        getUnionSemigroup: getUnionSemigroup$9,
        Functor: Functor$w,
        flap: flap$w,
        Pointed: Pointed$l,
        FunctorWithIndex: FunctorWithIndex$6,
        Apply: Apply$d,
        apFirst: apFirst$j,
        apSecond: apSecond$j,
        Applicative: Applicative$e,
        Chain: Chain$k,
        chainFirst: chainFirst$j,
        Monad: Monad$j,
        Foldable: Foldable$d,
        FoldableWithIndex: FoldableWithIndex$6,
        Traversable: Traversable$d,
        TraversableWithIndex: TraversableWithIndex$6,
        Alt: Alt$c,
        Comonad: Comonad$7,
        Do: Do$g,
        bindTo: bindTo$j,
        bind: bind$l,
        apS: apS$j,
        head: head$4,
        tail: tail$4,
        last: last$3,
        init: init$3,
        min: min$2,
        max: max$2,
        concatAll: concatAll$3,
        matchLeft: matchLeft$3,
        matchRight: matchRight$3,
        modifyHead: modifyHead$1,
        updateHead: updateHead$1,
        modifyLast: modifyLast$1,
        updateLast: updateLast$1,
        groupSort: groupSort$1,
        filter: filter$c,
        filterWithIndex: filterWithIndex$7,
        uncons: uncons$1,
        unsnoc: unsnoc$1,
        cons: cons$3,
        snoc: snoc$3,
        insertAt: insertAt$7,
        prependToAll: prependToAll$3,
        fold: fold$d,
        readonlyNonEmptyArray: readonlyNonEmptyArray
    });

    var __spreadArray$2 = (undefined && undefined.__spreadArray) || function (to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    };
    // -------------------------------------------------------------------------------------
    // internal
    // -------------------------------------------------------------------------------------
    /**
     * @internal
     */
    var isNonEmpty$3 = function (as) { return as.length > 0; };
    /**
     * @internal
     */
    var isOutOfBound$2 = function (i, as) { return i < 0 || i >= as.length; };
    /**
     * @internal
     */
    var prependW$2 = function (head) { return function (tail) { return __spreadArray$2([head], tail); }; };
    /**
     * @internal
     */
    var prepend$2 = prependW$2;
    /**
     * @internal
     */
    var appendW$2 = function (end) { return function (init) { return __spreadArray$2(__spreadArray$2([], init), [end]); }; };
    /**
     * @internal
     */
    var append$2 = appendW$2;
    /**
     * @internal
     */
    var unsafeInsertAt$2 = function (i, a, as) {
        if (isNonEmpty$3(as)) {
            var xs = fromReadonlyNonEmptyArray$1(as);
            xs.splice(i, 0, a);
            return xs;
        }
        return [a];
    };
    /**
     * @internal
     */
    var unsafeUpdateAt$2 = function (i, a, as) {
        var xs = fromReadonlyNonEmptyArray$1(as);
        xs[i] = a;
        return xs;
    };
    /**
     * Remove duplicates from a `NonEmptyArray`, keeping the first occurrence of an element.
     *
     * @example
     * import { uniq } from 'fp-ts/NonEmptyArray'
     * import * as N from 'fp-ts/number'
     *
     * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])
     *
     * @category combinators
     * @since 2.11.0
     */
    var uniq$2 = function (E) { return function (as) {
        if (as.length === 1) {
            return copy$2(as);
        }
        var out = [head$3(as)];
        var rest = tail$3(as);
        var _loop_1 = function (a) {
            if (out.every(function (o) { return !E.equals(o, a); })) {
                out.push(a);
            }
        };
        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {
            var a = rest_1[_i];
            _loop_1(a);
        }
        return out;
    }; };
    /**
     * Sort the elements of a `NonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,
     * etc...
     *
     * @example
     * import * as NEA from 'fp-ts/NonEmptyArray'
     * import { contramap } from 'fp-ts/Ord'
     * import * as S from 'fp-ts/string'
     * import * as N from 'fp-ts/number'
     * import { pipe } from 'fp-ts/function'
     *
     * interface Person {
     *   name: string
     *   age: number
     * }
     *
     * const byName = pipe(S.Ord, contramap((p: Person) => p.name))
     *
     * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))
     *
     * const sortByNameByAge = NEA.sortBy([byName, byAge])
     *
     * const persons: NEA.NonEmptyArray<Person> = [
     *   { name: 'a', age: 1 },
     *   { name: 'b', age: 3 },
     *   { name: 'c', age: 2 },
     *   { name: 'b', age: 2 }
     * ]
     *
     * assert.deepStrictEqual(sortByNameByAge(persons), [
     *   { name: 'a', age: 1 },
     *   { name: 'b', age: 2 },
     *   { name: 'b', age: 3 },
     *   { name: 'c', age: 2 }
     * ])
     *
     * @category combinators
     * @since 2.11.0
     */
    var sortBy$2 = function (ords) {
        if (isNonEmpty$3(ords)) {
            var M = getMonoid$d();
            return sort$2(ords.reduce(M.concat, M.empty));
        }
        return copy$2;
    };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var union$8 = function (E) {
        var uniqE = uniq$2(E);
        return function (second) { return function (first) { return uniqE(pipe$1(first, concat$3(second))); }; };
    };
    /**
     * Rotate a `NonEmptyArray` by `n` steps.
     *
     * @example
     * import { rotate } from 'fp-ts/NonEmptyArray'
     *
     * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])
     * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])
     *
     * @category combinators
     * @since 2.11.0
     */
    var rotate$3 = function (n) { return function (as) {
        var len = as.length;
        var m = Math.round(n) % len;
        if (isOutOfBound$2(Math.abs(m), as) || m === 0) {
            return copy$2(as);
        }
        if (m < 0) {
            var _a = splitAt$2(-m)(as), f = _a[0], s = _a[1];
            return pipe$1(s, concat$3(f));
        }
        else {
            return rotate$3(m - len)(as);
        }
    }; };
    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * @category constructors
     * @since 2.10.0
     */
    var fromReadonlyNonEmptyArray$1 = fromReadonlyNonEmptyArray$2;
    /**
     * Builds a `NonEmptyArray` from an `Array` returning `none` if `as` is an empty array
     *
     * @category constructors
     * @since 2.0.0
     */
    var fromArray$3 = function (as) { return (isNonEmpty$3(as) ? some$a(as) : none$2); };
    /**
     * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.
     *
     * **Note**. `n` is normalized to a natural number.
     *
     * @example
     * import { makeBy } from 'fp-ts/NonEmptyArray'
     * import { pipe } from 'fp-ts/function'
     *
     * const double = (n: number): number => n * 2
     * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])
     *
     * @category constructors
     * @since 2.11.0
     */
    var makeBy$2 = function (f) { return function (n) {
        var j = Math.max(0, Math.floor(n));
        var out = [f(0)];
        for (var i = 1; i < j; i++) {
            out.push(f(i));
        }
        return out;
    }; };
    /**
     * Create a `NonEmptyArray` containing a value repeated the specified number of times.
     *
     * **Note**. `n` is normalized to a natural number.
     *
     * @example
     * import { replicate } from 'fp-ts/NonEmptyArray'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])
     *
     * @category constructors
     * @since 2.11.0
     */
    var replicate$2 = function (a) { return makeBy$2(function () { return a; }); };
    /**
     * Create a `NonEmptyArray` containing a range of integers, including both endpoints.
     *
     * @example
     * import { range } from 'fp-ts/NonEmptyArray'
     *
     * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])
     *
     * @category constructors
     * @since 2.11.0
     */
    var range$2 = function (start, end) {
        return start <= end ? makeBy$2(function (i) { return start + i; })(end - start + 1) : [start];
    };
    // -------------------------------------------------------------------------------------
    // destructors
    // -------------------------------------------------------------------------------------
    /**
     * Return the tuple of the `head` and the `tail`.
     *
     * @example
     * import { unprepend } from 'fp-ts/NonEmptyArray'
     *
     * assert.deepStrictEqual(unprepend([1, 2, 3]), [1, [2, 3]])
     *
     * @category destructors
     * @since 2.9.0
     */
    var unprepend = function (as) { return [head$3(as), tail$3(as)]; };
    /**
     * Return the tuple of the `init` and the `last`.
     *
     * @example
     * import { unappend } from 'fp-ts/NonEmptyArray'
     *
     * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])
     *
     * @category destructors
     * @since 2.9.0
     */
    var unappend = function (as) { return [init$2(as), last$2(as)]; };
    function concatW$2(second) {
        return function (first) { return first.concat(second); };
    }
    function concat$3(x, y) {
        return y ? x.concat(y) : function (y) { return y.concat(x); };
    }
    /**
     * @category combinators
     * @since 2.0.0
     */
    var reverse$6 = function (as) { return __spreadArray$2([last$2(as)], as.slice(0, -1).reverse()); };
    function group(E) {
        return function (as) {
            var len = as.length;
            if (len === 0) {
                return [];
            }
            var out = [];
            var head = as[0];
            var nea = [head];
            for (var i = 1; i < len; i++) {
                var a = as[i];
                if (E.equals(a, head)) {
                    nea.push(a);
                }
                else {
                    out.push(nea);
                    head = a;
                    nea = [head];
                }
            }
            out.push(nea);
            return out;
        };
    }
    /**
     * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning
     * function on each element, and grouping the results according to values returned
     *
     * @example
     * import { groupBy } from 'fp-ts/NonEmptyArray'
     *
     * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {
     *   '1': ['a', 'b'],
     *   '2': ['ab']
     * })
     *
     * @category combinators
     * @since 2.0.0
     */
    var groupBy = function (f) { return function (as) {
        var out = {};
        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
            var a = as_1[_i];
            var k = f(a);
            if (out.hasOwnProperty(k)) {
                out[k].push(a);
            }
            else {
                out[k] = [a];
            }
        }
        return out;
    }; };
    /**
     * @category combinators
     * @since 2.0.0
     */
    var sort$2 = function (O) { return function (as) {
        return as.slice().sort(O.compare);
    }; };
    /**
     * @category combinators
     * @since 2.0.0
     */
    var insertAt$6 = function (i, a) { return function (as) {
        return i < 0 || i > as.length ? none$2 : some$a(unsafeInsertAt$2(i, a, as));
    }; };
    /**
     * @category combinators
     * @since 2.0.0
     */
    var updateAt$6 = function (i, a) {
        return modifyAt$6(i, function () { return a; });
    };
    /**
     * @category combinators
     * @since 2.0.0
     */
    var modifyAt$6 = function (i, f) { return function (as) {
        return isOutOfBound$2(i, as) ? none$2 : some$a(unsafeUpdateAt$2(i, f(as[i]), as));
    }; };
    /**
     * @category combinators
     * @since 2.0.0
     */
    var copy$2 = fromReadonlyNonEmptyArray$1;
    /**
     * @category Pointed
     * @since 2.0.0
     */
    var of$n = function (a) { return [a]; };
    /**
     * @category combinators
     * @since 2.5.1
     */
    var zipWith$2 = function (as, bs, f) {
        var cs = [f(as[0], bs[0])];
        var len = Math.min(as.length, bs.length);
        for (var i = 1; i < len; i++) {
            cs[i] = f(as[i], bs[i]);
        }
        return cs;
    };
    function zip$3(as, bs) {
        if (bs === undefined) {
            return function (bs) { return zip$3(bs, as); };
        }
        return zipWith$2(as, bs, function (a, b) { return [a, b]; });
    }
    /**
     * @category combinators
     * @since 2.5.1
     */
    var unzip$2 = function (abs) {
        var fa = [abs[0][0]];
        var fb = [abs[0][1]];
        for (var i = 1; i < abs.length; i++) {
            fa[i] = abs[i][0];
            fb[i] = abs[i][1];
        }
        return [fa, fb];
    };
    /**
     * Prepend an element to every member of an array
     *
     * @example
     * import { prependAll } from 'fp-ts/NonEmptyArray'
     *
     * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])
     *
     * @category combinators
     * @since 2.10.0
     */
    var prependAll$2 = function (middle) { return function (as) {
        var out = [middle, as[0]];
        for (var i = 1; i < as.length; i++) {
            out.push(middle, as[i]);
        }
        return out;
    }; };
    /**
     * Places an element in between members of an array
     *
     * @example
     * import { intersperse } from 'fp-ts/NonEmptyArray'
     *
     * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])
     *
     * @category combinators
     * @since 2.9.0
     */
    var intersperse$2 = function (middle) { return function (as) {
        var rest = tail$3(as);
        return isNonEmpty$3(rest) ? pipe$1(rest, prependAll$2(middle), prepend$2(head$3(as))) : copy$2(as);
    }; };
    /**
     * @category combinators
     * @since 2.0.0
     */
    var foldMapWithIndex$7 = foldMapWithIndex$8;
    /**
     * @category combinators
     * @since 2.0.0
     */
    var foldMap$g = foldMap$h;
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainWithIndex$2 = function (f) { return function (as) {
        var out = fromReadonlyNonEmptyArray$1(f(0, head$3(as)));
        for (var i = 1; i < as.length; i++) {
            out.push.apply(out, f(i, as[i]));
        }
        return out;
    }; };
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chop$2 = function (f) { return function (as) {
        var _a = f(as), b = _a[0], rest = _a[1];
        var out = [b];
        var next = rest;
        while (isNonEmpty$3(next)) {
            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];
            out.push(b_1);
            next = rest_2;
        }
        return out;
    }; };
    /**
     * Splits a `NonEmptyArray` into two pieces, the first piece has max `n` elements.
     *
     * @category combinators
     * @since 2.10.0
     */
    var splitAt$2 = function (n) { return function (as) {
        var m = Math.max(1, n);
        return m >= as.length ? [copy$2(as), []] : [pipe$1(as.slice(1, m), prepend$2(head$3(as))), as.slice(m)];
    }; };
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chunksOf$2 = function (n) { return chop$2(splitAt$2(n)); };
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    /* istanbul ignore next */
    var _map$u = function (fa, f) { return pipe$1(fa, map$C(f)); };
    /* istanbul ignore next */
    var _mapWithIndex$6 = function (fa, f) { return pipe$1(fa, mapWithIndex$7(f)); };
    /* istanbul ignore next */
    var _ap$d = function (fab, fa) { return pipe$1(fab, ap$n(fa)); };
    /* istanbul ignore next */
    var _chain$h = function (ma, f) { return pipe$1(ma, chain$o(f)); };
    /* istanbul ignore next */
    var _extend$9 = function (wa, f) { return pipe$1(wa, extend$9(f)); };
    /* istanbul ignore next */
    var _reduce$b = function (fa, b, f) { return pipe$1(fa, reduce$g(b, f)); };
    /* istanbul ignore next */
    var _foldMap$b = function (M) {
        var foldMapM = foldMap$g(M);
        return function (fa, f) { return pipe$1(fa, foldMapM(f)); };
    };
    /* istanbul ignore next */
    var _reduceRight$b = function (fa, b, f) { return pipe$1(fa, reduceRight$g(b, f)); };
    /* istanbul ignore next */
    var _traverse$b = function (F) {
        var traverseF = traverse$c(F);
        return function (ta, f) { return pipe$1(ta, traverseF(f)); };
    };
    /* istanbul ignore next */
    var _alt$b = function (fa, that) { return pipe$1(fa, alt$d(that)); };
    /* istanbul ignore next */
    var _reduceWithIndex$4 = function (fa, b, f) {
        return pipe$1(fa, reduceWithIndex$7(b, f));
    };
    /* istanbul ignore next */
    var _foldMapWithIndex$4 = function (M) {
        var foldMapWithIndexM = foldMapWithIndex$7(M);
        return function (fa, f) { return pipe$1(fa, foldMapWithIndexM(f)); };
    };
    /* istanbul ignore next */
    var _reduceRightWithIndex$4 = function (fa, b, f) {
        return pipe$1(fa, reduceRightWithIndex$7(b, f));
    };
    /* istanbul ignore next */
    var _traverseWithIndex$4 = function (F) {
        var traverseWithIndexF = traverseWithIndex$4(F);
        return function (ta, f) { return pipe$1(ta, traverseWithIndexF(f)); };
    };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * Less strict version of [`alt`](#alt).
     *
     * @category Alt
     * @since 2.9.0
     */
    var altW$b = function (that) { return function (as) {
        return pipe$1(as, concatW$2(that()));
    }; };
    /**
     * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
     * types of kind `* -> *`.
     *
     * @category Alt
     * @since 2.6.2
     */
    var alt$d = altW$b;
    /**
     * Apply a function to an argument under a type constructor.
     *
     * @category Apply
     * @since 2.0.0
     */
    var ap$n = function (as) {
        return chain$o(function (f) { return pipe$1(as, map$C(f)); });
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category Monad
     * @since 2.0.0
     */
    var chain$o = function (f) {
        return chainWithIndex$2(function (_, a) { return f(a); });
    };
    /**
     * @category Extend
     * @since 2.0.0
     */
    var extend$9 = function (f) { return function (as) {
        var next = tail$3(as);
        var out = [f(as)];
        while (isNonEmpty$3(next)) {
            out.push(f(next));
            next = tail$3(next);
        }
        return out;
    }; };
    /**
     * Derivable from `Extend`.
     *
     * @category combinators
     * @since 2.5.0
     */
    var duplicate$9 = 
    /*#__PURE__*/
    extend$9(identity$1);
    /**
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.5.0
     */
    var flatten$h = 
    /*#__PURE__*/
    chain$o(identity$1);
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$C = function (f) { return mapWithIndex$7(function (_, a) { return f(a); }); };
    /**
     * @category FunctorWithIndex
     * @since 2.0.0
     */
    var mapWithIndex$7 = function (f) { return function (as) {
        var out = [f(0, head$3(as))];
        for (var i = 1; i < as.length; i++) {
            out.push(f(i, as[i]));
        }
        return out;
    }; };
    /**
     * @category Foldable
     * @since 2.0.0
     */
    var reduce$g = reduce$h;
    /**
     * @category FoldableWithIndex
     * @since 2.0.0
     */
    var reduceWithIndex$7 = reduceWithIndex$8;
    /**
     * @category Foldable
     * @since 2.0.0
     */
    var reduceRight$g = reduceRight$h;
    /**
     * @category FoldableWithIndex
     * @since 2.0.0
     */
    var reduceRightWithIndex$7 = reduceRightWithIndex$8;
    /**
     * @since 2.6.3
     */
    var traverse$c = function (F) {
        var traverseWithIndexF = traverseWithIndex$4(F);
        return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };
    };
    /**
     * @since 2.6.3
     */
    var sequence$c = function (F) { return traverseWithIndex$4(F)(function (_, a) { return a; }); };
    /**
     * @since 2.6.3
     */
    var traverseWithIndex$4 = function (F) { return function (f) { return function (as) {
        var out = F.map(f(0, head$3(as)), of$n);
        for (var i = 1; i < as.length; i++) {
            out = F.ap(F.map(out, function (bs) { return function (b) { return pipe$1(bs, append$2(b)); }; }), f(i, as[i]));
        }
        return out;
    }; }; };
    /**
     * @since 2.7.0
     */
    var extract$5 = head$4;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$x = 'NonEmptyArray';
    /**
     * @category instances
     * @since 2.0.0
     */
    var getShow$e = getShow$f;
    /**
     * Builds a `Semigroup` instance for `NonEmptyArray`
     *
     * @category instances
     * @since 2.0.0
     */
    var getSemigroup$f = function () { return ({
        concat: concat$3
    }); };
    /**
     * @example
     * import { getEq } from 'fp-ts/NonEmptyArray'
     * import * as N from 'fp-ts/number'
     *
     * const E = getEq(N.Eq)
     * assert.strictEqual(E.equals([1, 2], [1, 2]), true)
     * assert.strictEqual(E.equals([1, 2], [1, 3]), false)
     *
     * @category instances
     * @since 2.0.0
     */
    var getEq$e = getEq$f;
    /**
     * @category combinators
     * @since 2.11.0
     */
    var getUnionSemigroup$8 = function (E) {
        var unionE = union$8(E);
        return {
            concat: function (first, second) { return unionE(second)(first); }
        };
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$v = {
        URI: URI$x,
        map: _map$u
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$v = 
    /*#__PURE__*/
    flap$x(Functor$v);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$k = {
        URI: URI$x,
        of: of$n
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var FunctorWithIndex$5 = {
        URI: URI$x,
        map: _map$u,
        mapWithIndex: _mapWithIndex$6
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Apply$c = {
        URI: URI$x,
        map: _map$u,
        ap: _ap$d
    };
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.5.0
     */
    var apFirst$i = 
    /*#__PURE__*/
    apFirst$k(Apply$c);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.5.0
     */
    var apSecond$i = 
    /*#__PURE__*/
    apSecond$k(Apply$c);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Applicative$d = {
        URI: URI$x,
        map: _map$u,
        ap: _ap$d,
        of: of$n
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$j = {
        URI: URI$x,
        map: _map$u,
        ap: _ap$d,
        chain: _chain$h
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.5.0
     */
    var chainFirst$i = 
    /*#__PURE__*/
    chainFirst$k(Chain$j);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Monad$i = {
        URI: URI$x,
        map: _map$u,
        ap: _ap$d,
        of: of$n,
        chain: _chain$h
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Foldable$c = {
        URI: URI$x,
        reduce: _reduce$b,
        foldMap: _foldMap$b,
        reduceRight: _reduceRight$b
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var FoldableWithIndex$5 = {
        URI: URI$x,
        reduce: _reduce$b,
        foldMap: _foldMap$b,
        reduceRight: _reduceRight$b,
        reduceWithIndex: _reduceWithIndex$4,
        foldMapWithIndex: _foldMapWithIndex$4,
        reduceRightWithIndex: _reduceRightWithIndex$4
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Traversable$c = {
        URI: URI$x,
        map: _map$u,
        reduce: _reduce$b,
        foldMap: _foldMap$b,
        reduceRight: _reduceRight$b,
        traverse: _traverse$b,
        sequence: sequence$c
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var TraversableWithIndex$5 = {
        URI: URI$x,
        map: _map$u,
        mapWithIndex: _mapWithIndex$6,
        reduce: _reduce$b,
        foldMap: _foldMap$b,
        reduceRight: _reduceRight$b,
        traverse: _traverse$b,
        sequence: sequence$c,
        reduceWithIndex: _reduceWithIndex$4,
        foldMapWithIndex: _foldMapWithIndex$4,
        reduceRightWithIndex: _reduceRightWithIndex$4,
        traverseWithIndex: _traverseWithIndex$4
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Alt$b = {
        URI: URI$x,
        map: _map$u,
        alt: _alt$b
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Comonad$6 = {
        URI: URI$x,
        map: _map$u,
        extend: _extend$9,
        extract: extract$5
    };
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.9.0
     */
    var Do$f = 
    /*#__PURE__*/
    of$n(emptyRecord);
    /**
     * @since 2.8.0
     */
    var bindTo$i = 
    /*#__PURE__*/
    bindTo$k(Functor$v);
    /**
     * @since 2.8.0
     */
    var bind$k = 
    /*#__PURE__*/
    bind$m(Chain$j);
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var apS$i = 
    /*#__PURE__*/
    apS$k(Apply$c);
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.0.0
     */
    var head$3 = head$4;
    /**
     * @since 2.0.0
     */
    var tail$3 = function (as) { return as.slice(1); };
    /**
     * @since 2.0.0
     */
    var last$2 = last$3;
    /**
     * Get all but the last element of a non empty array, creating a new array.
     *
     * @example
     * import { init } from 'fp-ts/NonEmptyArray'
     *
     * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])
     * assert.deepStrictEqual(init([1]), [])
     *
     * @since 2.2.0
     */
    var init$2 = function (as) { return as.slice(0, -1); };
    /**
     * @since 2.0.0
     */
    var min$1 = min$2;
    /**
     * @since 2.0.0
     */
    var max$1 = max$2;
    /**
     * @since 2.10.0
     */
    var concatAll$2 = function (S) { return function (as) { return as.reduce(S.concat); }; };
    /**
     * Break an `Array` into its first element and remaining elements.
     *
     * @category destructors
     * @since 2.11.0
     */
    var matchLeft$2 = function (f) { return function (as) { return f(head$3(as), tail$3(as)); }; };
    /**
     * Break an `Array` into its initial elements and the last element.
     *
     * @category destructors
     * @since 2.11.0
     */
    var matchRight$2 = function (f) { return function (as) {
        return f(init$2(as), last$2(as));
    }; };
    /**
     * Apply a function to the head, creating a new `NonEmptyArray`.
     *
     * @since 2.11.0
     */
    var modifyHead = function (f) { return function (as) { return __spreadArray$2([
        f(head$3(as))
    ], tail$3(as)); }; };
    /**
     * Change the head, creating a new `NonEmptyArray`.
     *
     * @category combinators
     * @since 2.11.0
     */
    var updateHead = function (a) { return modifyHead(function () { return a; }); };
    /**
     * Apply a function to the last element, creating a new `NonEmptyArray`.
     *
     * @since 2.11.0
     */
    var modifyLast = function (f) { return function (as) {
        return pipe$1(init$2(as), append$2(f(last$2(as))));
    }; };
    /**
     * Change the last element, creating a new `NonEmptyArray`.
     *
     * @category combinators
     * @since 2.11.0
     */
    var updateLast = function (a) { return modifyLast(function () { return a; }); };
    function groupSort(O) {
        var sortO = sort$2(O);
        var groupO = group(O);
        return function (as) { return (isNonEmpty$3(as) ? groupO(sortO(as)) : []); };
    }
    function filter$b(predicate) {
        return filterWithIndex$6(function (_, a) { return predicate(a); });
    }
    /**
     * Use [`filterWithIndex`](./Array.ts.html#filterwithindex) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    var filterWithIndex$6 = function (predicate) { return function (as) { return fromArray$3(as.filter(function (a, i) { return predicate(i, a); })); }; };
    /**
     * Use [`unprepend`](#unprepend) instead.
     *
     * @category destructors
     * @since 2.9.0
     * @deprecated
     */
    var uncons = unprepend;
    /**
     * Use [`unappend`](#unappend) instead.
     *
     * @category destructors
     * @since 2.9.0
     * @deprecated
     */
    var unsnoc = unappend;
    function cons$2(head, tail) {
        return tail === undefined ? prepend$2(head) : pipe$1(tail, prepend$2(head));
    }
    /**
     * Use [`append`](./Array.ts.html#append) instead.
     *
     * @category constructors
     * @since 2.0.0
     * @deprecated
     */
    var snoc$2 = function (init, end) { return pipe$1(init, append$2(end)); };
    /**
     * Use [`prependAll`](#prependall) instead.
     *
     * @category combinators
     * @since 2.9.0
     * @deprecated
     */
    var prependToAll$2 = prependAll$2;
    /**
     * Use [`concatAll`](#concatall) instead.
     *
     * @since 2.5.0
     * @deprecated
     */
    var fold$c = concatAll$3;
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var nonEmptyArray = {
        URI: URI$x,
        of: of$n,
        map: _map$u,
        mapWithIndex: _mapWithIndex$6,
        ap: _ap$d,
        chain: _chain$h,
        extend: _extend$9,
        extract: extract$5,
        reduce: _reduce$b,
        foldMap: _foldMap$b,
        reduceRight: _reduceRight$b,
        traverse: _traverse$b,
        sequence: sequence$c,
        reduceWithIndex: _reduceWithIndex$4,
        foldMapWithIndex: _foldMapWithIndex$4,
        reduceRightWithIndex: _reduceRightWithIndex$4,
        traverseWithIndex: _traverseWithIndex$4,
        alt: _alt$b
    };

    var NonEmptyArray = /*#__PURE__*/Object.freeze({
        __proto__: null,
        isNonEmpty: isNonEmpty$3,
        isOutOfBound: isOutOfBound$2,
        prependW: prependW$2,
        prepend: prepend$2,
        appendW: appendW$2,
        append: append$2,
        unsafeInsertAt: unsafeInsertAt$2,
        unsafeUpdateAt: unsafeUpdateAt$2,
        uniq: uniq$2,
        sortBy: sortBy$2,
        union: union$8,
        rotate: rotate$3,
        fromReadonlyNonEmptyArray: fromReadonlyNonEmptyArray$1,
        fromArray: fromArray$3,
        makeBy: makeBy$2,
        replicate: replicate$2,
        range: range$2,
        unprepend: unprepend,
        unappend: unappend,
        concatW: concatW$2,
        concat: concat$3,
        reverse: reverse$6,
        group: group,
        groupBy: groupBy,
        sort: sort$2,
        insertAt: insertAt$6,
        updateAt: updateAt$6,
        modifyAt: modifyAt$6,
        copy: copy$2,
        of: of$n,
        zipWith: zipWith$2,
        zip: zip$3,
        unzip: unzip$2,
        prependAll: prependAll$2,
        intersperse: intersperse$2,
        foldMapWithIndex: foldMapWithIndex$7,
        foldMap: foldMap$g,
        chainWithIndex: chainWithIndex$2,
        chop: chop$2,
        splitAt: splitAt$2,
        chunksOf: chunksOf$2,
        altW: altW$b,
        alt: alt$d,
        ap: ap$n,
        chain: chain$o,
        extend: extend$9,
        duplicate: duplicate$9,
        flatten: flatten$h,
        map: map$C,
        mapWithIndex: mapWithIndex$7,
        reduce: reduce$g,
        reduceWithIndex: reduceWithIndex$7,
        reduceRight: reduceRight$g,
        reduceRightWithIndex: reduceRightWithIndex$7,
        traverse: traverse$c,
        sequence: sequence$c,
        traverseWithIndex: traverseWithIndex$4,
        extract: extract$5,
        URI: URI$x,
        getShow: getShow$e,
        getSemigroup: getSemigroup$f,
        getEq: getEq$e,
        getUnionSemigroup: getUnionSemigroup$8,
        Functor: Functor$v,
        flap: flap$v,
        Pointed: Pointed$k,
        FunctorWithIndex: FunctorWithIndex$5,
        Apply: Apply$c,
        apFirst: apFirst$i,
        apSecond: apSecond$i,
        Applicative: Applicative$d,
        Chain: Chain$j,
        chainFirst: chainFirst$i,
        Monad: Monad$i,
        Foldable: Foldable$c,
        FoldableWithIndex: FoldableWithIndex$5,
        Traversable: Traversable$c,
        TraversableWithIndex: TraversableWithIndex$5,
        Alt: Alt$b,
        Comonad: Comonad$6,
        Do: Do$f,
        bindTo: bindTo$i,
        bind: bind$k,
        apS: apS$i,
        head: head$3,
        tail: tail$3,
        last: last$2,
        init: init$2,
        min: min$1,
        max: max$1,
        concatAll: concatAll$2,
        matchLeft: matchLeft$2,
        matchRight: matchRight$2,
        modifyHead: modifyHead,
        updateHead: updateHead,
        modifyLast: modifyLast,
        updateLast: updateLast,
        groupSort: groupSort,
        filter: filter$b,
        filterWithIndex: filterWithIndex$6,
        uncons: uncons,
        unsnoc: unsnoc,
        cons: cons$2,
        snoc: snoc$2,
        prependToAll: prependToAll$2,
        fold: fold$c,
        nonEmptyArray: nonEmptyArray
    });

    // -------------------------------------------------------------------------------------
    // refinements
    // -------------------------------------------------------------------------------------
    /**
     * @category refinements
     * @since 2.11.0
     */
    var isNumber = function (u) { return typeof u === 'number'; };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.10.0
     */
    var Eq$5 = {
        equals: function (first, second) { return first === second; }
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Ord$4 = {
        equals: Eq$5.equals,
        compare: function (first, second) { return (first < second ? -1 : first > second ? 1 : 0); }
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Bounded$1 = {
        equals: Eq$5.equals,
        compare: Ord$4.compare,
        top: Infinity,
        bottom: -Infinity
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Show$3 = {
        show: function (n) { return JSON.stringify(n); }
    };
    /**
     * @category instances
     * @since 2.11.0
     */
    var MagmaSub = {
        concat: function (first, second) { return first - second; }
    };
    /**
     * `number` semigroup under addition.
     *
     * @example
     * import { SemigroupSum } from 'fp-ts/number'
     *
     * assert.deepStrictEqual(SemigroupSum.concat(2, 3), 5)
     *
     * @category instances
     * @since 2.10.0
     */
    var SemigroupSum = {
        concat: function (first, second) { return first + second; }
    };
    /**
     * `number` semigroup under multiplication.
     *
     * @example
     * import { SemigroupProduct } from 'fp-ts/number'
     *
     * assert.deepStrictEqual(SemigroupProduct.concat(2, 3), 6)
     *
     * @category instances
     * @since 2.10.0
     */
    var SemigroupProduct = {
        concat: function (first, second) { return first * second; }
    };
    /**
     * `number` monoid under addition.
     *
     * The `empty` value is `0`.
     *
     * @example
     * import { MonoidSum } from 'fp-ts/number'
     *
     * assert.deepStrictEqual(MonoidSum.concat(2, MonoidSum.empty), 2)
     *
     * @category instances
     * @since 2.10.0
     */
    var MonoidSum = {
        concat: SemigroupSum.concat,
        empty: 0
    };
    /**
     * `number` monoid under multiplication.
     *
     * The `empty` value is `1`.
     *
     * @example
     * import { MonoidProduct } from 'fp-ts/number'
     *
     * assert.deepStrictEqual(MonoidProduct.concat(2, MonoidProduct.empty), 2)
     *
     * @category instances
     * @since 2.10.0
     */
    var MonoidProduct = {
        concat: SemigroupProduct.concat,
        empty: 1
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Field$1 = {
        add: SemigroupSum.concat,
        zero: 0,
        mul: SemigroupProduct.concat,
        one: 1,
        sub: MagmaSub.concat,
        degree: function (_) { return 1; },
        div: function (first, second) { return first / second; },
        mod: function (first, second) { return first % second; }
    };

    var number = /*#__PURE__*/Object.freeze({
        __proto__: null,
        isNumber: isNumber,
        Eq: Eq$5,
        Ord: Ord$4,
        Bounded: Bounded$1,
        Show: Show$3,
        MagmaSub: MagmaSub,
        SemigroupSum: SemigroupSum,
        SemigroupProduct: SemigroupProduct,
        MonoidSum: MonoidSum,
        MonoidProduct: MonoidProduct,
        Field: Field$1
    });

    /**
     * ```ts
     * interface Separated<E, A> {
     *    readonly left: E
     *    readonly right: A
     * }
     * ```
     *
     * Represents a result of separating a whole into two parts.
     *
     * @since 2.10.0
     */
    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * @category constructors
     * @since 2.10.0
     */
    var separated = function (left, right) { return ({ left: left, right: right }); };
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _map$t = function (fa, f) { return pipe$1(fa, map$B(f)); };
    var _mapLeft$b = function (fa, f) { return pipe$1(fa, mapLeft$d(f)); };
    var _bimap$b = function (fa, g, f) { return pipe$1(fa, bimap$d(g, f)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.10.0
     */
    var map$B = function (f) { return function (fa) {
        return separated(left$c(fa), f(right$c(fa)));
    }; };
    /**
     * Map a function over the first type argument of a bifunctor.
     *
     * @category Bifunctor
     * @since 2.10.0
     */
    var mapLeft$d = function (f) { return function (fa) {
        return separated(f(left$c(fa)), right$c(fa));
    }; };
    /**
     * Map a pair of functions over the two type arguments of the bifunctor.
     *
     * @category Bifunctor
     * @since 2.10.0
     */
    var bimap$d = function (f, g) { return function (fa) {
        return separated(f(left$c(fa)), g(right$c(fa)));
    }; };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.10.0
     */
    var URI$w = 'Separated';
    /**
     * @category instances
     * @since 2.10.0
     */
    var Bifunctor$c = {
        URI: URI$w,
        mapLeft: _mapLeft$b,
        bimap: _bimap$b
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Functor$u = {
        URI: URI$w,
        map: _map$t
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$u = 
    /*#__PURE__*/
    flap$x(Functor$u);
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.10.0
     */
    var left$c = function (s) { return s.left; };
    /**
     * @since 2.10.0
     */
    var right$c = function (s) { return s.right; };

    var Separated$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        separated: separated,
        map: map$B,
        mapLeft: mapLeft$d,
        bimap: bimap$d,
        URI: URI$w,
        Bifunctor: Bifunctor$c,
        Functor: Functor$u,
        flap: flap$u,
        left: left$c,
        right: right$c
    });

    function wiltDefault$1(T, C) {
        return function (F) {
            var traverseF = T.traverse(F);
            return function (wa, f) { return F.map(traverseF(wa, f), C.separate); };
        };
    }
    function witherDefault$1(T, C) {
        return function (F) {
            var traverseF = T.traverse(F);
            return function (wa, f) { return F.map(traverseF(wa, f), C.compact); };
        };
    }
    function filterE$3(W) {
        return function (F) {
            var witherF = W.wither(F);
            return function (predicate) { return function (ga) { return witherF(ga, function (a) { return F.map(predicate(a), function (b) { return (b ? some$a(a) : none$2); }); }); }; };
        };
    }

    var Witherable$6 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        wiltDefault: wiltDefault$1,
        witherDefault: witherDefault$1,
        filterE: filterE$3
    });

    function guard$5(F, P) {
        return function (b) { return (b ? P.of(undefined) : F.zero()); };
    }

    var Zero$5 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        guard: guard$5
    });

    var __spreadArray$1 = (undefined && undefined.__spreadArray) || function (to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    };
    // -------------------------------------------------------------------------------------
    // refinements
    // -------------------------------------------------------------------------------------
    /**
     * Test whether a `ReadonlyArray` is empty.
     *
     * @example
     * import { isEmpty } from 'fp-ts/ReadonlyArray'
     *
     * assert.strictEqual(isEmpty([]), true)
     *
     * @category refinements
     * @since 2.5.0
     */
    var isEmpty$8 = function (as) { return as.length === 0; };
    /**
     * Test whether a `ReadonlyArray` is non empty.
     *
     * @category refinements
     * @since 2.5.0
     */
    var isNonEmpty$2 = isNonEmpty$4;
    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.
     *
     * @example
     * import { prepend } from 'fp-ts/ReadonlyArray'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])
     *
     * @category constructors
     * @since 2.10.0
     */
    var prepend$1 = prepend$3;
    /**
     * Less strict version of [`prepend`](#prepend).
     *
     * @category constructors
     * @since 2.11.0
     */
    var prependW$1 = prependW$3;
    /**
     * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.
     *
     * @example
     * import { append } from 'fp-ts/ReadonlyArray'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])
     *
     * @category constructors
     * @since 2.10.0
     */
    var append$1 = append$3;
    /**
     * Less strict version of [`append`](#append).
     *
     * @category constructors
     * @since 2.11.0
     */
    var appendW$1 = appendW$3;
    /**
     * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.
     *
     * **Note**. `n` is normalized to a non negative integer.
     *
     * @example
     * import { makeBy } from 'fp-ts/ReadonlyArray'
     *
     * const double = (n: number): number => n * 2
     * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])
     *
     * @category constructors
     * @since 2.5.0
     */
    var makeBy$1 = function (n, f) { return (n <= 0 ? empty$8 : makeBy$3(f)(n)); };
    /**
     * Create a `ReadonlyArray` containing a value repeated the specified number of times.
     *
     * **Note**. `n` is normalized to a non negative integer.
     *
     * @example
     * import { replicate } from 'fp-ts/ReadonlyArray'
     *
     * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])
     *
     * @category constructors
     * @since 2.5.0
     */
    var replicate$1 = function (n, a) { return makeBy$1(n, function () { return a; }); };
    function fromPredicate$c(predicate) {
        return function (a) { return (predicate(a) ? [a] : empty$8); };
    }
    // -------------------------------------------------------------------------------------
    // natural transformations
    // -------------------------------------------------------------------------------------
    /**
     * @category natural transformations
     * @since 2.11.0
     */
    var fromOption$b = function (ma) { return (isNone$2(ma) ? empty$8 : [ma.value]); };
    /**
     * Transforms an `Either` to a `ReadonlyArray`.
     *
     * @category natural transformations
     * @since 2.11.0
     */
    var fromEither$a = function (e) { return (isLeft$3(e) ? empty$8 : [e.right]); };
    // -------------------------------------------------------------------------------------
    // destructors
    // -------------------------------------------------------------------------------------
    /**
     * Less strict version of [`match`](#match).
     *
     * @category destructors
     * @since 2.11.0
     */
    var matchW$b = function (onEmpty, onNonEmpty) { return function (as) { return (isNonEmpty$2(as) ? onNonEmpty(as) : onEmpty()); }; };
    /**
     * @category destructors
     * @since 2.11.0
     */
    var match$f = matchW$b;
    /**
     * Less strict version of [`matchLeft`](#matchleft).
     *
     * @category destructors
     * @since 2.11.0
     */
    var matchLeftW$1 = function (onEmpty, onNonEmpty) { return function (as) { return (isNonEmpty$2(as) ? onNonEmpty(head$4(as), tail$4(as)) : onEmpty()); }; };
    /**
     * Break a `ReadonlyArray` into its first element and remaining elements.
     *
     * @example
     * import { matchLeft } from 'fp-ts/ReadonlyArray'
     *
     * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))
     * assert.strictEqual(len([1, 2, 3]), 3)
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchLeft$1 = matchLeftW$1;
    /**
     * Alias of [`matchLeft`](#matchleft).
     *
     * @category destructors
     * @since 2.5.0
     */
    var foldLeft$1 = matchLeft$1;
    /**
     * Less strict version of [`matchRight`](#matchright).
     *
     * @category destructors
     * @since 2.11.0
     */
    var matchRightW$1 = function (onEmpty, onNonEmpty) { return function (as) { return (isNonEmpty$2(as) ? onNonEmpty(init$3(as), last$3(as)) : onEmpty()); }; };
    /**
     * Break a `ReadonlyArray` into its initial elements and the last element.
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchRight$1 = matchRightW$1;
    /**
     * Alias of [`matchRight`](#matchright).
     *
     * @category destructors
     * @since 2.5.0
     */
    var foldRight$1 = matchRight$1;
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * @category combinators
     * @since 2.7.0
     */
    var chainWithIndex$1 = function (f) { return function (as) {
        if (isEmpty$8(as)) {
            return empty$8;
        }
        var out = [];
        for (var i = 0; i < as.length; i++) {
            out.push.apply(out, f(i, as[i]));
        }
        return out;
    }; };
    /**
     * Same as `reduce` but it carries over the intermediate steps.
     *
     * @example
     * import { scanLeft } from 'fp-ts/ReadonlyArray'
     *
     * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])
     *
     * @category combinators
     * @since 2.5.0
     */
    var scanLeft$1 = function (b, f) { return function (as) {
        var len = as.length;
        var out = new Array(len + 1);
        out[0] = b;
        for (var i = 0; i < len; i++) {
            out[i + 1] = f(out[i], as[i]);
        }
        return out;
    }; };
    /**
     * Fold an array from the right, keeping all intermediate results instead of only the final result
     *
     * @example
     * import { scanRight } from 'fp-ts/ReadonlyArray'
     *
     * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])
     *
     * @category combinators
     * @since 2.5.0
     */
    var scanRight$1 = function (b, f) { return function (as) {
        var len = as.length;
        var out = new Array(len + 1);
        out[len] = b;
        for (var i = len - 1; i >= 0; i--) {
            out[i] = f(as[i], out[i + 1]);
        }
        return out;
    }; };
    /**
     * Calculate the number of elements in a `ReadonlyArray`.
     *
     * @since 2.10.0
     */
    var size$8 = function (as) { return as.length; };
    /**
     * Test whether an array contains a particular index
     *
     * @since 2.5.0
     */
    var isOutOfBound$1 = isOutOfBound$3;
    function lookup$5(i, as) {
        return as === undefined ? function (as) { return lookup$5(i, as); } : isOutOfBound$1(i, as) ? none$2 : some$a(as[i]);
    }
    /**
     * Get the first element in an array, or `None` if the array is empty
     *
     * @example
     * import { head } from 'fp-ts/ReadonlyArray'
     * import { some, none } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(head([1, 2, 3]), some(1))
     * assert.deepStrictEqual(head([]), none)
     *
     * @since 2.5.0
     */
    var head$2 = function (as) { return (isNonEmpty$2(as) ? some$a(head$4(as)) : none$2); };
    /**
     * Get the last element in an array, or `None` if the array is empty
     *
     * @example
     * import { last } from 'fp-ts/ReadonlyArray'
     * import { some, none } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(last([1, 2, 3]), some(3))
     * assert.deepStrictEqual(last([]), none)
     *
     * @since 2.5.0
     */
    var last$1 = function (as) { return (isNonEmpty$2(as) ? some$a(last$3(as)) : none$2); };
    /**
     * Get all but the first element of an array, creating a new array, or `None` if the array is empty
     *
     * @example
     * import { tail } from 'fp-ts/ReadonlyArray'
     * import { some, none } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))
     * assert.deepStrictEqual(tail([]), none)
     *
     * @since 2.5.0
     */
    var tail$2 = function (as) {
        return isNonEmpty$2(as) ? some$a(tail$4(as)) : none$2;
    };
    /**
     * Get all but the last element of an array, creating a new array, or `None` if the array is empty
     *
     * @example
     * import { init } from 'fp-ts/ReadonlyArray'
     * import { some, none } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))
     * assert.deepStrictEqual(init([]), none)
     *
     * @since 2.5.0
     */
    var init$1 = function (as) {
        return isNonEmpty$2(as) ? some$a(init$3(as)) : none$2;
    };
    /**
     * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.
     *
     * **Note**. `n` is normalized to a non negative integer.
     *
     * @example
     * import * as RA from 'fp-ts/ReadonlyArray'
     * import { pipe } from 'fp-ts/function'
     *
     * const input: ReadonlyArray<number> = [1, 2, 3]
     * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])
     *
     * // out of bounds
     * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)
     * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)
     *
     * @category combinators
     * @since 2.5.0
     */
    var takeLeft$1 = function (n) { return function (as) {
        return isOutOfBound$1(n, as) ? as : n === 0 ? empty$8 : as.slice(0, n);
    }; };
    /**
     * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.
     *
     * **Note**. `n` is normalized to a non negative integer.
     *
     * @example
     * import * as RA from 'fp-ts/ReadonlyArray'
     * import { pipe } from 'fp-ts/function'
     *
     * const input: ReadonlyArray<number> = [1, 2, 3]
     * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])
     *
     * // out of bounds
     * assert.strictEqual(pipe(input, RA.takeRight(4)), input)
     * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)
     *
     * @category combinators
     * @since 2.5.0
     */
    var takeRight$1 = function (n) { return function (as) {
        return isOutOfBound$1(n, as) ? as : n === 0 ? empty$8 : as.slice(-n);
    }; };
    function takeLeftWhile$1(predicate) {
        return function (as) {
            var out = [];
            for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
                var a = as_1[_i];
                if (!predicate(a)) {
                    break;
                }
                out.push(a);
            }
            var len = out.length;
            return len === as.length ? as : len === 0 ? empty$8 : out;
        };
    }
    var spanLeftIndex$1 = function (as, predicate) {
        var l = as.length;
        var i = 0;
        for (; i < l; i++) {
            if (!predicate(as[i])) {
                break;
            }
        }
        return i;
    };
    function spanLeft$1(predicate) {
        return function (as) {
            var _a = splitAt$1(spanLeftIndex$1(as, predicate))(as), init = _a[0], rest = _a[1];
            return { init: init, rest: rest };
        };
    }
    /**
     * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.
     *
     * **Note**. `n` is normalized to a non negative integer.
     *
     * @example
     * import * as RA from 'fp-ts/ReadonlyArray'
     * import { pipe } from 'fp-ts/function'
     *
     * const input: ReadonlyArray<number> = [1, 2, 3]
     * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])
     * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)
     * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)
     *
     * @category combinators
     * @since 2.5.0
     */
    var dropLeft$1 = function (n) { return function (as) {
        return n <= 0 || isEmpty$8(as) ? as : n >= as.length ? empty$8 : as.slice(n, as.length);
    }; };
    /**
     * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.
     *
     * **Note**. `n` is normalized to a non negative integer.
     *
     * @example
     * import * as RA from 'fp-ts/ReadonlyArray'
     * import { pipe } from 'fp-ts/function'
     *
     * const input: ReadonlyArray<number> = [1, 2, 3]
     * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])
     * assert.strictEqual(pipe(input, RA.dropRight(0)), input)
     * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)
     *
     * @category combinators
     * @since 2.5.0
     */
    var dropRight$1 = function (n) { return function (as) {
        return n <= 0 || isEmpty$8(as) ? as : n >= as.length ? empty$8 : as.slice(0, as.length - n);
    }; };
    function dropLeftWhile$1(predicate) {
        return function (as) {
            var i = spanLeftIndex$1(as, predicate);
            return i === 0 ? as : i === as.length ? empty$8 : as.slice(i);
        };
    }
    /**
     * Find the first index for which a predicate holds
     *
     * @example
     * import { findIndex } from 'fp-ts/ReadonlyArray'
     * import { some, none } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))
     * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)
     *
     * @since 2.5.0
     */
    var findIndex$1 = function (predicate) { return function (as) {
        for (var i = 0; i < as.length; i++) {
            if (predicate(as[i])) {
                return some$a(i);
            }
        }
        return none$2;
    }; };
    function findFirst$1(predicate) {
        return function (as) {
            for (var i = 0; i < as.length; i++) {
                if (predicate(as[i])) {
                    return some$a(as[i]);
                }
            }
            return none$2;
        };
    }
    /**
     * Find the first element returned by an option based selector function
     *
     * @example
     * import { findFirstMap } from 'fp-ts/ReadonlyArray'
     * import { some, none } from 'fp-ts/Option'
     *
     * interface Person {
     *   readonly name: string
     *   readonly age?: number
     * }
     *
     * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]
     *
     * // returns the name of the first person that has an age
     * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))
     *
     * @since 2.5.0
     */
    var findFirstMap$1 = function (f) { return function (as) {
        for (var i = 0; i < as.length; i++) {
            var out = f(as[i]);
            if (isSome$2(out)) {
                return out;
            }
        }
        return none$2;
    }; };
    function findLast$1(predicate) {
        return function (as) {
            for (var i = as.length - 1; i >= 0; i--) {
                if (predicate(as[i])) {
                    return some$a(as[i]);
                }
            }
            return none$2;
        };
    }
    /**
     * Find the last element returned by an option based selector function
     *
     * @example
     * import { findLastMap } from 'fp-ts/ReadonlyArray'
     * import { some, none } from 'fp-ts/Option'
     *
     * interface Person {
     *   readonly name: string
     *   readonly age?: number
     * }
     *
     * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]
     *
     * // returns the name of the last person that has an age
     * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))
     *
     * @since 2.5.0
     */
    var findLastMap$1 = function (f) { return function (as) {
        for (var i = as.length - 1; i >= 0; i--) {
            var out = f(as[i]);
            if (isSome$2(out)) {
                return out;
            }
        }
        return none$2;
    }; };
    /**
     * Returns the index of the last element of the list which matches the predicate
     *
     * @example
     * import { findLastIndex } from 'fp-ts/ReadonlyArray'
     * import { some, none } from 'fp-ts/Option'
     *
     * interface X {
     *   readonly a: number
     *   readonly b: number
     * }
     * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]
     * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))
     * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)
     *
     *
     * @since 2.5.0
     */
    var findLastIndex$1 = function (predicate) { return function (as) {
        for (var i = as.length - 1; i >= 0; i--) {
            if (predicate(as[i])) {
                return some$a(i);
            }
        }
        return none$2;
    }; };
    /**
     * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds
     *
     * @example
     * import { insertAt } from 'fp-ts/ReadonlyArray'
     * import { some } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))
     *
     * @since 2.5.0
     */
    var insertAt$5 = function (i, a) { return function (as) {
        return i < 0 || i > as.length ? none$2 : some$a(unsafeInsertAt$3(i, a, as));
    }; };
    /**
     * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds
     *
     * @example
     * import { updateAt } from 'fp-ts/ReadonlyArray'
     * import { some, none } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))
     * assert.deepStrictEqual(updateAt(1, 1)([]), none)
     *
     * @since 2.5.0
     */
    var updateAt$5 = function (i, a) {
        return modifyAt$5(i, function () { return a; });
    };
    /**
     * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds
     *
     * @example
     * import { deleteAt } from 'fp-ts/ReadonlyArray'
     * import { some, none } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))
     * assert.deepStrictEqual(deleteAt(1)([]), none)
     *
     * @since 2.5.0
     */
    var deleteAt$5 = function (i) { return function (as) {
        return isOutOfBound$1(i, as) ? none$2 : some$a(unsafeDeleteAt$1(i, as));
    }; };
    /**
     * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out
     * of bounds
     *
     * @example
     * import { modifyAt } from 'fp-ts/ReadonlyArray'
     * import { some, none } from 'fp-ts/Option'
     *
     * const double = (x: number): number => x * 2
     * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))
     * assert.deepStrictEqual(modifyAt(1, double)([]), none)
     *
     * @since 2.5.0
     */
    var modifyAt$5 = function (i, f) { return function (as) {
        return isOutOfBound$1(i, as) ? none$2 : some$a(unsafeUpdateAt$1(i, f(as[i]), as));
    }; };
    /**
     * Reverse an array, creating a new array
     *
     * @example
     * import { reverse } from 'fp-ts/ReadonlyArray'
     *
     * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])
     *
     * @category combinators
     * @since 2.5.0
     */
    var reverse$5 = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };
    /**
     * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order
     *
     * @example
     * import { rights } from 'fp-ts/ReadonlyArray'
     * import { right, left } from 'fp-ts/Either'
     *
     * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])
     *
     * @category combinators
     * @since 2.5.0
     */
    var rights$1 = function (as) {
        var r = [];
        for (var i = 0; i < as.length; i++) {
            var a = as[i];
            if (a._tag === 'Right') {
                r.push(a.right);
            }
        }
        return r;
    };
    /**
     * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order
     *
     * @example
     * import { lefts } from 'fp-ts/ReadonlyArray'
     * import { left, right } from 'fp-ts/Either'
     *
     * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])
     *
     * @category combinators
     * @since 2.5.0
     */
    var lefts$1 = function (as) {
        var r = [];
        for (var i = 0; i < as.length; i++) {
            var a = as[i];
            if (a._tag === 'Left') {
                r.push(a.left);
            }
        }
        return r;
    };
    /**
     * Sort the elements of an array in increasing order, creating a new array
     *
     * @example
     * import { sort } from 'fp-ts/ReadonlyArray'
     * import * as N from 'fp-ts/number'
     *
     * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])
     *
     * @category combinators
     * @since 2.5.0
     */
    var sort$1 = function (O) { return function (as) {
        return as.length <= 1 ? as : as.slice().sort(O.compare);
    }; };
    // TODO: curry and make data-last in v3
    /**
     * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one
     * input array is short, excess elements of the longer array are discarded.
     *
     * @example
     * import { zipWith } from 'fp-ts/ReadonlyArray'
     *
     * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])
     *
     * @category combinators
     * @since 2.5.0
     */
    var zipWith$1 = function (fa, fb, f) {
        var fc = [];
        var len = Math.min(fa.length, fb.length);
        for (var i = 0; i < len; i++) {
            fc[i] = f(fa[i], fb[i]);
        }
        return fc;
    };
    function zip$2(as, bs) {
        if (bs === undefined) {
            return function (bs) { return zip$2(bs, as); };
        }
        return zipWith$1(as, bs, function (a, b) { return [a, b]; });
    }
    /**
     * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays
     *
     * @example
     * import { unzip } from 'fp-ts/ReadonlyArray'
     *
     * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])
     *
     * @category combinators
     * @since 2.5.0
     */
    var unzip$1 = function (as) {
        var fa = [];
        var fb = [];
        for (var i = 0; i < as.length; i++) {
            fa[i] = as[i][0];
            fb[i] = as[i][1];
        }
        return [fa, fb];
    };
    /**
     * Prepend an element to every member of an array
     *
     * @example
     * import { prependAll } from 'fp-ts/ReadonlyArray'
     *
     * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])
     *
     * @category combinators
     * @since 2.10.0
     */
    var prependAll$1 = function (middle) {
        var f = prependAll$3(middle);
        return function (as) { return (isNonEmpty$2(as) ? f(as) : as); };
    };
    /**
     * Places an element in between members of an array
     *
     * @example
     * import { intersperse } from 'fp-ts/ReadonlyArray'
     *
     * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])
     *
     * @category combinators
     * @since 2.9.0
     */
    var intersperse$1 = function (middle) {
        var f = intersperse$3(middle);
        return function (as) { return (isNonEmpty$2(as) ? f(as) : as); };
    };
    /**
     * Rotate a `ReadonlyArray` by `n` steps.
     *
     * @example
     * import { rotate } from 'fp-ts/ReadonlyArray'
     *
     * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])
     *
     * @category combinators
     * @since 2.5.0
     */
    var rotate$2 = function (n) {
        var f = rotate$4(n);
        return function (as) { return (isNonEmpty$2(as) ? f(as) : as); };
    };
    function elem$b(E) {
        return function (a, as) {
            if (as === undefined) {
                var elemE_1 = elem$b(E);
                return function (as) { return elemE_1(a, as); };
            }
            var predicate = function (element) { return E.equals(element, a); };
            var i = 0;
            for (; i < as.length; i++) {
                if (predicate(as[i])) {
                    return true;
                }
            }
            return false;
        };
    }
    /**
     * Remove duplicates from an array, keeping the first occurrence of an element.
     *
     * @example
     * import { uniq } from 'fp-ts/ReadonlyArray'
     * import * as N from 'fp-ts/number'
     *
     * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])
     *
     * @category combinators
     * @since 2.5.0
     */
    var uniq$1 = function (E) {
        var f = uniq$3(E);
        return function (as) { return (isNonEmpty$2(as) ? f(as) : as); };
    };
    /**
     * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,
     * etc...
     *
     * @example
     * import { sortBy } from 'fp-ts/ReadonlyArray'
     * import { contramap } from 'fp-ts/Ord'
     * import * as S from 'fp-ts/string'
     * import * as N from 'fp-ts/number'
     * import { pipe } from 'fp-ts/function'
     *
     * interface Person {
     *   readonly name: string
     *   readonly age: number
     * }
     * const byName = pipe(S.Ord, contramap((p: Person) => p.name))
     * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))
     *
     * const sortByNameByAge = sortBy([byName, byAge])
     *
     * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]
     * assert.deepStrictEqual(sortByNameByAge(persons), [
     *   { name: 'a', age: 1 },
     *   { name: 'b', age: 2 },
     *   { name: 'b', age: 3 },
     *   { name: 'c', age: 2 }
     * ])
     *
     * @category combinators
     * @since 2.5.0
     */
    var sortBy$1 = function (ords) {
        var f = sortBy$3(ords);
        return function (as) { return (isNonEmpty$2(as) ? f(as) : as); };
    };
    /**
     * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for "chopping" up the input
     * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a
     * value and the tail of the `ReadonlyArray`.
     *
     * @example
     * import { Eq } from 'fp-ts/Eq'
     * import * as RA from 'fp-ts/ReadonlyArray'
     * import * as N from 'fp-ts/number'
     * import { pipe } from 'fp-ts/function'
     *
     * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {
     *   return RA.chop(as => {
     *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))
     *     return [init, rest]
     *   })
     * }
     * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])
     *
     * @category combinators
     * @since 2.5.0
     */
    var chop$1 = function (f) {
        var g = chop$3(f);
        return function (as) { return (isNonEmpty$2(as) ? g(as) : empty$8); };
    };
    /**
     * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.
     *
     * @example
     * import { splitAt } from 'fp-ts/ReadonlyArray'
     *
     * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])
     *
     * @category combinators
     * @since 2.5.0
     */
    var splitAt$1 = function (n) { return function (as) {
        return n >= 1 && isNonEmpty$2(as) ? splitAt$3(n)(as) : isEmpty$8(as) ? [as, empty$8] : [empty$8, as];
    }; };
    /**
     * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
     * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive
     * definition of `chunksOf`; it satisfies the property that:
     *
     * ```ts
     * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))
     * ```
     *
     * whenever `n` evenly divides the length of `as`.
     *
     * @example
     * import { chunksOf } from 'fp-ts/ReadonlyArray'
     *
     * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])
     *
     * @category combinators
     * @since 2.5.0
     */
    var chunksOf$1 = function (n) {
        var f = chunksOf$3(n);
        return function (as) { return (isNonEmpty$2(as) ? f(as) : empty$8); };
    };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var fromOptionK$d = function (f) { return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return fromOption$b(f.apply(void 0, a));
    }; };
    function comprehension$1(input, f, g) {
        if (g === void 0) { g = function () { return true; }; }
        var go = function (scope, input) {
            return isNonEmpty$2(input)
                ? pipe$1(head$4(input), chain$n(function (x) { return go(pipe$1(scope, append$1(x)), tail$4(input)); }))
                : g.apply(void 0, scope) ? [f.apply(void 0, scope)]
                    : empty$8;
        };
        return go(empty$8, input);
    }
    /**
     * @category combinators
     * @since 2.11.0
     */
    var concatW$1 = function (second) { return function (first) {
        return isEmpty$8(first) ? second : isEmpty$8(second) ? first : first.concat(second);
    }; };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var concat$2 = concatW$1;
    function union$7(E) {
        var unionE = union$9(E);
        return function (first, second) {
            if (second === undefined) {
                var unionE_1 = union$7(E);
                return function (second) { return unionE_1(second, first); };
            }
            return isNonEmpty$2(first) && isNonEmpty$2(second) ? unionE(second)(first) : isNonEmpty$2(first) ? first : second;
        };
    }
    function intersection$7(E) {
        var elemE = elem$b(E);
        return function (xs, ys) {
            if (ys === undefined) {
                var intersectionE_1 = intersection$7(E);
                return function (ys) { return intersectionE_1(ys, xs); };
            }
            return xs.filter(function (a) { return elemE(a, ys); });
        };
    }
    function difference$7(E) {
        var elemE = elem$b(E);
        return function (xs, ys) {
            if (ys === undefined) {
                var differenceE_1 = difference$7(E);
                return function (ys) { return differenceE_1(ys, xs); };
            }
            return xs.filter(function (a) { return !elemE(a, ys); });
        };
    }
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _map$s = function (fa, f) { return pipe$1(fa, map$A(f)); };
    var _mapWithIndex$5 = function (fa, f) { return pipe$1(fa, mapWithIndex$6(f)); };
    var _ap$c = function (fab, fa) { return pipe$1(fab, ap$m(fa)); };
    var _chain$g = function (ma, f) { return pipe$1(ma, chain$n(f)); };
    var _filter$7 = function (fa, predicate) {
        return pipe$1(fa, filter$a(predicate));
    };
    var _filterMap$7 = function (fa, f) { return pipe$1(fa, filterMap$a(f)); };
    var _partition$7 = function (fa, predicate) {
        return pipe$1(fa, partition$a(predicate));
    };
    var _partitionMap$7 = function (fa, f) { return pipe$1(fa, partitionMap$a(f)); };
    var _partitionWithIndex$5 = function (fa, predicateWithIndex) { return pipe$1(fa, partitionWithIndex$5(predicateWithIndex)); };
    var _partitionMapWithIndex$5 = function (fa, f) { return pipe$1(fa, partitionMapWithIndex$5(f)); };
    var _alt$a = function (fa, that) { return pipe$1(fa, alt$c(that)); };
    var _reduce$a = function (fa, b, f) { return pipe$1(fa, reduce$f(b, f)); };
    var _foldMap$a = function (M) {
        var foldMapM = foldMap$f(M);
        return function (fa, f) { return pipe$1(fa, foldMapM(f)); };
    };
    var _reduceRight$a = function (fa, b, f) { return pipe$1(fa, reduceRight$f(b, f)); };
    var _reduceWithIndex$3 = function (fa, b, f) {
        return pipe$1(fa, reduceWithIndex$6(b, f));
    };
    var _foldMapWithIndex$3 = function (M) {
        var foldMapWithIndexM = foldMapWithIndex$6(M);
        return function (fa, f) { return pipe$1(fa, foldMapWithIndexM(f)); };
    };
    var _reduceRightWithIndex$3 = function (fa, b, f) {
        return pipe$1(fa, reduceRightWithIndex$6(b, f));
    };
    var _filterMapWithIndex$5 = function (fa, f) { return pipe$1(fa, filterMapWithIndex$5(f)); };
    var _filterWithIndex$5 = function (fa, predicateWithIndex) { return pipe$1(fa, filterWithIndex$5(predicateWithIndex)); };
    var _extend$8 = function (fa, f) { return pipe$1(fa, extend$8(f)); };
    var _traverse$a = function (F) {
        var traverseF = traverse$b(F);
        return function (ta, f) { return pipe$1(ta, traverseF(f)); };
    };
    /* istanbul ignore next */
    var _traverseWithIndex$3 = function (F) {
        var traverseWithIndexF = traverseWithIndex$3(F);
        return function (ta, f) { return pipe$1(ta, traverseWithIndexF(f)); };
    };
    /** @internal */
    var _chainRecDepthFirst$1 = function (a, f) { return pipe$1(a, chainRecDepthFirst$1(f)); };
    /** @internal */
    var _chainRecBreadthFirst$1 = function (a, f) { return pipe$1(a, chainRecBreadthFirst$1(f)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * @category Pointed
     * @since 2.5.0
     */
    var of$m = of$o;
    /**
     * @category Zero
     * @since 2.7.0
     */
    var zero$5 = function () { return empty$8; };
    /**
     * Less strict version of [`alt`](#alt).
     *
     * @category Alt
     * @since 2.9.0
     */
    var altW$a = function (that) { return function (fa) {
        return fa.concat(that());
    }; };
    /**
     * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
     * types of kind `* -> *`.
     *
     * @category Alt
     * @since 2.5.0
     */
    var alt$c = altW$a;
    /**
     * Apply a function to an argument under a type constructor.
     *
     * @category Apply
     * @since 2.5.0
     */
    var ap$m = function (fa) {
        return chain$n(function (f) { return pipe$1(fa, map$A(f)); });
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category Monad
     * @since 2.5.0
     */
    var chain$n = function (f) { return function (ma) {
        return pipe$1(ma, chainWithIndex$1(function (_, a) { return f(a); }));
    }; };
    /**
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.5.0
     */
    var flatten$g = 
    /*#__PURE__*/
    chain$n(identity$1);
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.5.0
     */
    var map$A = function (f) { return function (fa) {
        return fa.map(function (a) { return f(a); });
    }; };
    /**
     * @category FunctorWithIndex
     * @since 2.5.0
     */
    var mapWithIndex$6 = function (f) { return function (fa) { return fa.map(function (a, i) { return f(i, a); }); }; };
    /**
     * @category Compactable
     * @since 2.5.0
     */
    var separate$a = function (fa) {
        var left = [];
        var right = [];
        for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
            var e = fa_1[_i];
            if (e._tag === 'Left') {
                left.push(e.left);
            }
            else {
                right.push(e.right);
            }
        }
        return separated(left, right);
    };
    /**
     * @category Filterable
     * @since 2.5.0
     */
    var filter$a = function (predicate) { return function (as) { return as.filter(predicate); }; };
    /**
     * @category FilterableWithIndex
     * @since 2.5.0
     */
    var filterMapWithIndex$5 = function (f) { return function (fa) {
        var out = [];
        for (var i = 0; i < fa.length; i++) {
            var optionB = f(i, fa[i]);
            if (isSome$2(optionB)) {
                out.push(optionB.value);
            }
        }
        return out;
    }; };
    /**
     * @category Filterable
     * @since 2.5.0
     */
    var filterMap$a = function (f) {
        return filterMapWithIndex$5(function (_, a) { return f(a); });
    };
    /**
     * @category Compactable
     * @since 2.5.0
     */
    var compact$a = 
    /*#__PURE__*/
    filterMap$a(identity$1);
    /**
     * @category Filterable
     * @since 2.5.0
     */
    var partition$a = function (predicate) {
        return partitionWithIndex$5(function (_, a) { return predicate(a); });
    };
    /**
     * @category FilterableWithIndex
     * @since 2.5.0
     */
    var partitionWithIndex$5 = function (predicateWithIndex) { return function (as) {
        var left = [];
        var right = [];
        for (var i = 0; i < as.length; i++) {
            var a = as[i];
            if (predicateWithIndex(i, a)) {
                right.push(a);
            }
            else {
                left.push(a);
            }
        }
        return separated(left, right);
    }; };
    /**
     * @category Filterable
     * @since 2.5.0
     */
    var partitionMap$a = function (f) {
        return partitionMapWithIndex$5(function (_, a) { return f(a); });
    };
    /**
     * @category FilterableWithIndex
     * @since 2.5.0
     */
    var partitionMapWithIndex$5 = function (f) { return function (fa) {
        var left = [];
        var right = [];
        for (var i = 0; i < fa.length; i++) {
            var e = f(i, fa[i]);
            if (e._tag === 'Left') {
                left.push(e.left);
            }
            else {
                right.push(e.right);
            }
        }
        return separated(left, right);
    }; };
    /**
     * @category FilterableWithIndex
     * @since 2.5.0
     */
    var filterWithIndex$5 = function (predicateWithIndex) { return function (as) {
        return as.filter(function (a, i) { return predicateWithIndex(i, a); });
    }; };
    /**
     * @category Extend
     * @since 2.5.0
     */
    var extend$8 = function (f) { return function (wa) { return wa.map(function (_, i) { return f(wa.slice(i)); }); }; };
    /**
     * Derivable from `Extend`.
     *
     * @category combinators
     * @since 2.5.0
     */
    var duplicate$8 = 
    /*#__PURE__*/
    extend$8(identity$1);
    /**
     * @category FoldableWithIndex
     * @since 2.5.0
     */
    var foldMapWithIndex$6 = function (M) { return function (f) { return function (fa) {
        return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);
    }; }; };
    /**
     * @category Foldable
     * @since 2.5.0
     */
    var reduce$f = function (b, f) {
        return reduceWithIndex$6(b, function (_, b, a) { return f(b, a); });
    };
    /**
     * @category Foldable
     * @since 2.5.0
     */
    var foldMap$f = function (M) {
        var foldMapWithIndexM = foldMapWithIndex$6(M);
        return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };
    };
    /**
     * @category FoldableWithIndex
     * @since 2.5.0
     */
    var reduceWithIndex$6 = function (b, f) { return function (fa) {
        var len = fa.length;
        var out = b;
        for (var i = 0; i < len; i++) {
            out = f(i, out, fa[i]);
        }
        return out;
    }; };
    /**
     * @category Foldable
     * @since 2.5.0
     */
    var reduceRight$f = function (b, f) {
        return reduceRightWithIndex$6(b, function (_, a, b) { return f(a, b); });
    };
    /**
     * @category FoldableWithIndex
     * @since 2.5.0
     */
    var reduceRightWithIndex$6 = function (b, f) { return function (fa) { return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b); }; };
    /**
     * @category Traversable
     * @since 2.6.3
     */
    var traverse$b = function (F) {
        var traverseWithIndexF = traverseWithIndex$3(F);
        return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };
    };
    /**
     * @category Traversable
     * @since 2.6.3
     */
    var sequence$b = function (F) { return function (ta) {
        return _reduce$a(ta, F.of(zero$5()), function (fas, fa) {
            return F.ap(F.map(fas, function (as) { return function (a) { return pipe$1(as, append$1(a)); }; }), fa);
        });
    }; };
    /**
     * @category TraversableWithIndex
     * @since 2.6.3
     */
    var traverseWithIndex$3 = function (F) { return function (f) {
        return reduceWithIndex$6(F.of(zero$5()), function (i, fbs, a) {
            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe$1(bs, append$1(b)); }; }), f(i, a));
        });
    }; };
    /**
     * @category Witherable
     * @since 2.6.5
     */
    var wither$4 = function (F) {
        var _witherF = _wither$4(F);
        return function (f) { return function (fa) { return _witherF(fa, f); }; };
    };
    /**
     * @category Witherable
     * @since 2.6.5
     */
    var wilt$4 = function (F) {
        var _wiltF = _wilt$4(F);
        return function (f) { return function (fa) { return _wiltF(fa, f); }; };
    };
    /**
     * @category Unfoldable
     * @since 2.6.6
     */
    var unfold$1 = function (b, f) {
        var out = [];
        var bb = b;
        while (true) {
            var mt = f(bb);
            if (isSome$2(mt)) {
                var _a = mt.value, a = _a[0], b_1 = _a[1];
                out.push(a);
                bb = b_1;
            }
            else {
                break;
            }
        }
        return out;
    };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.5.0
     */
    var URI$v = 'ReadonlyArray';
    /**
     * @category instances
     * @since 2.5.0
     */
    var getShow$d = function (S) { return ({
        show: function (as) { return "[" + as.map(S.show).join(', ') + "]"; }
    }); };
    /**
     * @category instances
     * @since 2.5.0
     */
    var getSemigroup$e = function () { return ({
        concat: function (first, second) { return (isEmpty$8(first) ? second : isEmpty$8(second) ? first : first.concat(second)); }
    }); };
    /**
     * Returns a `Monoid` for `ReadonlyArray<A>`.
     *
     * @example
     * import { getMonoid } from 'fp-ts/ReadonlyArray'
     *
     * const M = getMonoid<number>()
     * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])
     *
     * @category instances
     * @since 2.5.0
     */
    var getMonoid$c = function () { return ({
        concat: getSemigroup$e().concat,
        empty: empty$8
    }); };
    /**
     * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two
     * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of
     * different lengths, the result is non equality.
     *
     * @example
     * import * as S from 'fp-ts/string'
     * import { getEq } from 'fp-ts/ReadonlyArray'
     *
     * const E = getEq(S.Eq)
     * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)
     * assert.strictEqual(E.equals(['a'], []), false)
     *
     * @category instances
     * @since 2.5.0
     */
    var getEq$d = function (E) {
        return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });
    };
    /**
     * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such
     * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in
     * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have
     * the same length, the result is equality.
     *
     * @example
     * import { getOrd } from 'fp-ts/ReadonlyArray'
     * import * as S from 'fp-ts/string'
     *
     * const O = getOrd(S.Ord)
     * assert.strictEqual(O.compare(['b'], ['a']), 1)
     * assert.strictEqual(O.compare(['a'], ['a']), 0)
     * assert.strictEqual(O.compare(['a'], ['b']), -1)
     *
     *
     * @category instances
     * @since 2.5.0
     */
    var getOrd$3 = function (O) {
        return fromCompare(function (a, b) {
            var aLen = a.length;
            var bLen = b.length;
            var len = Math.min(aLen, bLen);
            for (var i = 0; i < len; i++) {
                var ordering = O.compare(a[i], b[i]);
                if (ordering !== 0) {
                    return ordering;
                }
            }
            return Ord$4.compare(aLen, bLen);
        });
    };
    /**
     * @category instances
     * @since 2.11.0
     */
    var getUnionSemigroup$7 = function (E) {
        var unionE = union$7(E);
        return {
            concat: function (first, second) { return unionE(second)(first); }
        };
    };
    /**
     * @category instances
     * @since 2.11.0
     */
    var getUnionMonoid$7 = function (E) { return ({
        concat: getUnionSemigroup$7(E).concat,
        empty: empty$8
    }); };
    /**
     * @category instances
     * @since 2.11.0
     */
    var getIntersectionSemigroup$7 = function (E) {
        var intersectionE = intersection$7(E);
        return {
            concat: function (first, second) { return intersectionE(second)(first); }
        };
    };
    /**
     * @category instances
     * @since 2.11.0
     */
    var getDifferenceMagma$7 = function (E) {
        var differenceE = difference$7(E);
        return {
            concat: function (first, second) { return differenceE(second)(first); }
        };
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$t = {
        URI: URI$v,
        map: _map$s
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$t = 
    /*#__PURE__*/
    flap$x(Functor$t);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$j = {
        URI: URI$v,
        of: of$m
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var FunctorWithIndex$4 = {
        URI: URI$v,
        map: _map$s,
        mapWithIndex: _mapWithIndex$5
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Apply$b = {
        URI: URI$v,
        map: _map$s,
        ap: _ap$c
    };
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.5.0
     */
    var apFirst$h = 
    /*#__PURE__*/
    apFirst$k(Apply$b);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.5.0
     */
    var apSecond$h = 
    /*#__PURE__*/
    apSecond$k(Apply$b);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Applicative$c = {
        URI: URI$v,
        map: _map$s,
        ap: _ap$c,
        of: of$m
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$i = {
        URI: URI$v,
        map: _map$s,
        ap: _ap$c,
        chain: _chain$g
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Monad$h = {
        URI: URI$v,
        map: _map$s,
        ap: _ap$c,
        of: of$m,
        chain: _chain$g
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.5.0
     */
    var chainFirst$h = 
    /*#__PURE__*/
    chainFirst$k(Chain$i);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Unfoldable$2 = {
        URI: URI$v,
        unfold: unfold$1
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Alt$a = {
        URI: URI$v,
        map: _map$s,
        alt: _alt$a
    };
    /**
     * @category instances
     * @since 2.11.0
     */
    var Zero$4 = {
        URI: URI$v,
        zero: zero$5
    };
    /**
     * @category constructors
     * @since 2.11.0
     */
    var guard$4 = 
    /*#__PURE__*/
    guard$5(Zero$4, Pointed$j);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Alternative$3 = {
        URI: URI$v,
        map: _map$s,
        ap: _ap$c,
        of: of$m,
        alt: _alt$a,
        zero: zero$5
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Extend$4 = {
        URI: URI$v,
        map: _map$s,
        extend: _extend$8
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Compactable$8 = {
        URI: URI$v,
        compact: compact$a,
        separate: separate$a
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Filterable$8 = {
        URI: URI$v,
        map: _map$s,
        compact: compact$a,
        separate: separate$a,
        filter: _filter$7,
        filterMap: _filterMap$7,
        partition: _partition$7,
        partitionMap: _partitionMap$7
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var FilterableWithIndex$4 = {
        URI: URI$v,
        map: _map$s,
        mapWithIndex: _mapWithIndex$5,
        compact: compact$a,
        separate: separate$a,
        filter: _filter$7,
        filterMap: _filterMap$7,
        partition: _partition$7,
        partitionMap: _partitionMap$7,
        partitionMapWithIndex: _partitionMapWithIndex$5,
        partitionWithIndex: _partitionWithIndex$5,
        filterMapWithIndex: _filterMapWithIndex$5,
        filterWithIndex: _filterWithIndex$5
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Foldable$b = {
        URI: URI$v,
        reduce: _reduce$a,
        foldMap: _foldMap$a,
        reduceRight: _reduceRight$a
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var FoldableWithIndex$4 = {
        URI: URI$v,
        reduce: _reduce$a,
        foldMap: _foldMap$a,
        reduceRight: _reduceRight$a,
        reduceWithIndex: _reduceWithIndex$3,
        foldMapWithIndex: _foldMapWithIndex$3,
        reduceRightWithIndex: _reduceRightWithIndex$3
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Traversable$b = {
        URI: URI$v,
        map: _map$s,
        reduce: _reduce$a,
        foldMap: _foldMap$a,
        reduceRight: _reduceRight$a,
        traverse: _traverse$a,
        sequence: sequence$b
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var TraversableWithIndex$4 = {
        URI: URI$v,
        map: _map$s,
        mapWithIndex: _mapWithIndex$5,
        reduce: _reduce$a,
        foldMap: _foldMap$a,
        reduceRight: _reduceRight$a,
        reduceWithIndex: _reduceWithIndex$3,
        foldMapWithIndex: _foldMapWithIndex$3,
        reduceRightWithIndex: _reduceRightWithIndex$3,
        traverse: _traverse$a,
        sequence: sequence$b,
        traverseWithIndex: _traverseWithIndex$3
    };
    /**
     * @category ChainRec
     * @since 2.11.0
     */
    var chainRecDepthFirst$1 = function (f) { return function (a) {
        var todo = __spreadArray$1([], f(a));
        var out = [];
        while (todo.length > 0) {
            var e = todo.shift();
            if (isLeft$3(e)) {
                todo.unshift.apply(todo, f(e.left));
            }
            else {
                out.push(e.right);
            }
        }
        return out;
    }; };
    /**
     * @category instances
     * @since 2.11.0
     */
    var ChainRecDepthFirst$1 = {
        URI: URI$v,
        map: _map$s,
        ap: _ap$c,
        chain: _chain$g,
        chainRec: _chainRecDepthFirst$1
    };
    /**
     * @category ChainRec
     * @since 2.11.0
     */
    var chainRecBreadthFirst$1 = function (f) { return function (a) {
        var initial = f(a);
        var todo = [];
        var out = [];
        function go(e) {
            if (isLeft$3(e)) {
                f(e.left).forEach(function (v) { return todo.push(v); });
            }
            else {
                out.push(e.right);
            }
        }
        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {
            var e = initial_1[_i];
            go(e);
        }
        while (todo.length > 0) {
            go(todo.shift());
        }
        return out;
    }; };
    /**
     * @category instances
     * @since 2.11.0
     */
    var ChainRecBreadthFirst$1 = {
        URI: URI$v,
        map: _map$s,
        ap: _ap$c,
        chain: _chain$g,
        chainRec: _chainRecBreadthFirst$1
    };
    var _wither$4 = 
    /*#__PURE__*/
    witherDefault$1(Traversable$b, Compactable$8);
    var _wilt$4 = 
    /*#__PURE__*/
    wiltDefault$1(Traversable$b, Compactable$8);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Witherable$5 = {
        URI: URI$v,
        map: _map$s,
        compact: compact$a,
        separate: separate$a,
        filter: _filter$7,
        filterMap: _filterMap$7,
        partition: _partition$7,
        partitionMap: _partitionMap$7,
        reduce: _reduce$a,
        foldMap: _foldMap$a,
        reduceRight: _reduceRight$a,
        traverse: _traverse$a,
        sequence: sequence$b,
        wither: _wither$4,
        wilt: _wilt$4
    };
    /**
     * Filter values inside a context.
     *
     * @example
     * import { pipe } from 'fp-ts/function'
     * import * as RA from 'fp-ts/ReadonlyArray'
     * import * as T from 'fp-ts/Task'
     *
     * const filterE = RA.filterE(T.ApplicativePar)
     * async function test() {
     *   assert.deepStrictEqual(
     *     await pipe(
     *       [-1, 2, 3],
     *       filterE((n) => T.of(n > 0))
     *     )(),
     *     [2, 3]
     *   )
     * }
     * test()
     *
     * @since 2.11.0
     */
    var filterE$2 = 
    /*#__PURE__*/
    filterE$3(Witherable$5);
    /**
     * @category instances
     * @since 2.11.0
     */
    var FromEither$c = {
        URI: URI$v,
        fromEither: fromEither$a
    };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var fromEitherK$9 = 
    /*#__PURE__*/
    fromEitherK$a(FromEither$c);
    // -------------------------------------------------------------------------------------
    // unsafe
    // -------------------------------------------------------------------------------------
    /**
     * @category unsafe
     * @since 2.5.0
     */
    var unsafeInsertAt$1 = unsafeInsertAt$3;
    /**
     * @category unsafe
     * @since 2.5.0
     */
    var unsafeUpdateAt$1 = function (i, a, as) {
        return isNonEmpty$2(as) ? unsafeUpdateAt$3(i, a, as) : as;
    };
    /**
     * @category unsafe
     * @since 2.5.0
     */
    var unsafeDeleteAt$1 = function (i, as) {
        var xs = as.slice();
        xs.splice(i, 1);
        return xs;
    };
    // -------------------------------------------------------------------------------------
    // interop
    // -------------------------------------------------------------------------------------
    /**
     * @category interop
     * @since 2.5.0
     */
    var toArray$4 = function (as) { return as.slice(); };
    /**
     * @category interop
     * @since 2.5.0
     */
    var fromArray$2 = function (as) { return (isEmpty$8(as) ? empty$8 : as.slice()); };
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * An empty array
     *
     * @since 2.5.0
     */
    var empty$8 = empty$9;
    /**
     * Check if a predicate holds true for every array member.
     *
     * @example
     * import { every } from 'fp-ts/ReadonlyArray'
     * import { pipe } from 'fp-ts/function'
     *
     * const isPositive = (n: number): boolean => n > 0
     *
     * assert.deepStrictEqual(pipe([1, 2, 3], every(isPositive)), true)
     * assert.deepStrictEqual(pipe([1, 2, -3], every(isPositive)), false)
     *
     * @since 2.9.0
     */
    var every$5 = function (predicate) { return function (as) { return as.every(predicate); }; };
    /**
     * Check if a predicate holds true for any array member.
     *
     * @example
     * import { some } from 'fp-ts/ReadonlyArray'
     * import { pipe } from 'fp-ts/function'
     *
     * const isPositive = (n: number): boolean => n > 0
     *
     * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)
     * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)
     *
     * @since 2.9.0
     */
    var some$9 = function (predicate) { return function (as) {
        return as.some(predicate);
    }; };
    /**
     * Alias of [`some`](#some)
     *
     * @since 2.11.0
     */
    var exists$5 = some$9;
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.9.0
     */
    var Do$e = 
    /*#__PURE__*/
    of$m(emptyRecord);
    /**
     * @since 2.8.0
     */
    var bindTo$h = 
    /*#__PURE__*/
    bindTo$k(Functor$t);
    /**
     * @since 2.8.0
     */
    var bind$j = 
    /*#__PURE__*/
    bind$m(Chain$i);
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var apS$h = 
    /*#__PURE__*/
    apS$k(Apply$b);
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use `ReadonlyNonEmptyArray` module instead.
     *
     * @category constructors
     * @since 2.5.0
     * @deprecated
     */
    var range$1 = range$3;
    /**
     * Use [`prepend`](#prepend) instead.
     *
     * @category constructors
     * @since 2.5.0
     * @deprecated
     */
    var cons$1 = cons$3;
    /**
     * Use [`append`](#append) instead.
     *
     * @category constructors
     * @since 2.5.0
     * @deprecated
     */
    var snoc$1 = snoc$3;
    /**
     * Use [`prependAll`](#prependall) instead.
     *
     * @category combinators
     * @since 2.9.0
     * @deprecated
     */
    var prependToAll$1 = prependAll$1;
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.5.0
     * @deprecated
     */
    var readonlyArray = {
        URI: URI$v,
        compact: compact$a,
        separate: separate$a,
        map: _map$s,
        ap: _ap$c,
        of: of$m,
        chain: _chain$g,
        filter: _filter$7,
        filterMap: _filterMap$7,
        partition: _partition$7,
        partitionMap: _partitionMap$7,
        mapWithIndex: _mapWithIndex$5,
        partitionMapWithIndex: _partitionMapWithIndex$5,
        partitionWithIndex: _partitionWithIndex$5,
        filterMapWithIndex: _filterMapWithIndex$5,
        filterWithIndex: _filterWithIndex$5,
        alt: _alt$a,
        zero: zero$5,
        unfold: unfold$1,
        reduce: _reduce$a,
        foldMap: _foldMap$a,
        reduceRight: _reduceRight$a,
        traverse: _traverse$a,
        sequence: sequence$b,
        reduceWithIndex: _reduceWithIndex$3,
        foldMapWithIndex: _foldMapWithIndex$3,
        reduceRightWithIndex: _reduceRightWithIndex$3,
        traverseWithIndex: _traverseWithIndex$3,
        extend: _extend$8,
        wither: _wither$4,
        wilt: _wilt$4
    };

    var ReadonlyArray = /*#__PURE__*/Object.freeze({
        __proto__: null,
        isEmpty: isEmpty$8,
        isNonEmpty: isNonEmpty$2,
        prepend: prepend$1,
        prependW: prependW$1,
        append: append$1,
        appendW: appendW$1,
        makeBy: makeBy$1,
        replicate: replicate$1,
        fromPredicate: fromPredicate$c,
        fromOption: fromOption$b,
        fromEither: fromEither$a,
        matchW: matchW$b,
        match: match$f,
        matchLeftW: matchLeftW$1,
        matchLeft: matchLeft$1,
        foldLeft: foldLeft$1,
        matchRightW: matchRightW$1,
        matchRight: matchRight$1,
        foldRight: foldRight$1,
        chainWithIndex: chainWithIndex$1,
        scanLeft: scanLeft$1,
        scanRight: scanRight$1,
        size: size$8,
        isOutOfBound: isOutOfBound$1,
        lookup: lookup$5,
        head: head$2,
        last: last$1,
        tail: tail$2,
        init: init$1,
        takeLeft: takeLeft$1,
        takeRight: takeRight$1,
        takeLeftWhile: takeLeftWhile$1,
        spanLeft: spanLeft$1,
        dropLeft: dropLeft$1,
        dropRight: dropRight$1,
        dropLeftWhile: dropLeftWhile$1,
        findIndex: findIndex$1,
        findFirst: findFirst$1,
        findFirstMap: findFirstMap$1,
        findLast: findLast$1,
        findLastMap: findLastMap$1,
        findLastIndex: findLastIndex$1,
        insertAt: insertAt$5,
        updateAt: updateAt$5,
        deleteAt: deleteAt$5,
        modifyAt: modifyAt$5,
        reverse: reverse$5,
        rights: rights$1,
        lefts: lefts$1,
        sort: sort$1,
        zipWith: zipWith$1,
        zip: zip$2,
        unzip: unzip$1,
        prependAll: prependAll$1,
        intersperse: intersperse$1,
        rotate: rotate$2,
        elem: elem$b,
        uniq: uniq$1,
        sortBy: sortBy$1,
        chop: chop$1,
        splitAt: splitAt$1,
        chunksOf: chunksOf$1,
        fromOptionK: fromOptionK$d,
        comprehension: comprehension$1,
        concatW: concatW$1,
        concat: concat$2,
        union: union$7,
        intersection: intersection$7,
        difference: difference$7,
        _chainRecDepthFirst: _chainRecDepthFirst$1,
        _chainRecBreadthFirst: _chainRecBreadthFirst$1,
        of: of$m,
        zero: zero$5,
        altW: altW$a,
        alt: alt$c,
        ap: ap$m,
        chain: chain$n,
        flatten: flatten$g,
        map: map$A,
        mapWithIndex: mapWithIndex$6,
        separate: separate$a,
        filter: filter$a,
        filterMapWithIndex: filterMapWithIndex$5,
        filterMap: filterMap$a,
        compact: compact$a,
        partition: partition$a,
        partitionWithIndex: partitionWithIndex$5,
        partitionMap: partitionMap$a,
        partitionMapWithIndex: partitionMapWithIndex$5,
        filterWithIndex: filterWithIndex$5,
        extend: extend$8,
        duplicate: duplicate$8,
        foldMapWithIndex: foldMapWithIndex$6,
        reduce: reduce$f,
        foldMap: foldMap$f,
        reduceWithIndex: reduceWithIndex$6,
        reduceRight: reduceRight$f,
        reduceRightWithIndex: reduceRightWithIndex$6,
        traverse: traverse$b,
        sequence: sequence$b,
        traverseWithIndex: traverseWithIndex$3,
        wither: wither$4,
        wilt: wilt$4,
        unfold: unfold$1,
        URI: URI$v,
        getShow: getShow$d,
        getSemigroup: getSemigroup$e,
        getMonoid: getMonoid$c,
        getEq: getEq$d,
        getOrd: getOrd$3,
        getUnionSemigroup: getUnionSemigroup$7,
        getUnionMonoid: getUnionMonoid$7,
        getIntersectionSemigroup: getIntersectionSemigroup$7,
        getDifferenceMagma: getDifferenceMagma$7,
        Functor: Functor$t,
        flap: flap$t,
        Pointed: Pointed$j,
        FunctorWithIndex: FunctorWithIndex$4,
        Apply: Apply$b,
        apFirst: apFirst$h,
        apSecond: apSecond$h,
        Applicative: Applicative$c,
        Chain: Chain$i,
        Monad: Monad$h,
        chainFirst: chainFirst$h,
        Unfoldable: Unfoldable$2,
        Alt: Alt$a,
        Zero: Zero$4,
        guard: guard$4,
        Alternative: Alternative$3,
        Extend: Extend$4,
        Compactable: Compactable$8,
        Filterable: Filterable$8,
        FilterableWithIndex: FilterableWithIndex$4,
        Foldable: Foldable$b,
        FoldableWithIndex: FoldableWithIndex$4,
        Traversable: Traversable$b,
        TraversableWithIndex: TraversableWithIndex$4,
        chainRecDepthFirst: chainRecDepthFirst$1,
        ChainRecDepthFirst: ChainRecDepthFirst$1,
        chainRecBreadthFirst: chainRecBreadthFirst$1,
        ChainRecBreadthFirst: ChainRecBreadthFirst$1,
        Witherable: Witherable$5,
        filterE: filterE$2,
        FromEither: FromEither$c,
        fromEitherK: fromEitherK$9,
        unsafeInsertAt: unsafeInsertAt$1,
        unsafeUpdateAt: unsafeUpdateAt$1,
        unsafeDeleteAt: unsafeDeleteAt$1,
        toArray: toArray$4,
        fromArray: fromArray$2,
        empty: empty$8,
        every: every$5,
        some: some$9,
        exists: exists$5,
        Do: Do$e,
        bindTo: bindTo$h,
        bind: bind$j,
        apS: apS$h,
        range: range$1,
        cons: cons$1,
        snoc: snoc$1,
        prependToAll: prependToAll$1,
        readonlyArray: readonlyArray
    });

    // -------------------------------------------------------------------------------------
    // refinements
    // -------------------------------------------------------------------------------------
    /**
     * Test whether an array is empty
     *
     * @example
     * import { isEmpty } from 'fp-ts/Array'
     *
     * assert.strictEqual(isEmpty([]), true)
     * assert.strictEqual(isEmpty(['a']), false)
     *
     * @category refinements
     * @since 2.0.0
     */
    var isEmpty$7 = function (as) { return as.length === 0; };
    /**
     * Test whether an array is non empty narrowing down the type to `NonEmptyArray<A>`
     *
     * @example
     * import { isNonEmpty } from 'fp-ts/Array'
     *
     * assert.strictEqual(isNonEmpty([]), false)
     * assert.strictEqual(isNonEmpty(['a']), true)
     *
     * @category refinements
     * @since 2.0.0
     */
    var isNonEmpty$1 = isNonEmpty$3;
    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * Prepend an element to the front of a `Array`, creating a new `NonEmptyArray`.
     *
     * @example
     * import { prepend } from 'fp-ts/Array'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])
     *
     * @category constructors
     * @since 2.10.0
     */
    var prepend = prepend$2;
    /**
     * Less strict version of [`prepend`](#prepend).
     *
     * @example
     * import { prependW } from 'fp-ts/Array'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe([2, 3, 4], prependW("a")), ["a", 2, 3, 4]);
     *
     * @category constructors
     * @since 2.11.0
     */
    var prependW = prependW$2;
    /**
     * Append an element to the end of a `Array`, creating a new `NonEmptyArray`.
     *
     * @example
     * import { append } from 'fp-ts/Array'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])
     *
     * @category constructors
     * @since 2.10.0
     */
    var append = append$2;
    /**
     * Less strict version of [`append`](#append).
     *
     * @example
     * import { appendW } from 'fp-ts/Array'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe([1, 2, 3], appendW("d")), [1, 2, 3, "d"]);
     *
     * @category constructors
     * @since 2.11.0
     */
    var appendW = appendW$2;
    /**
     * Return a `Array` of length `n` with element `i` initialized with `f(i)`.
     *
     * **Note**. `n` is normalized to a non negative integer.
     *
     * @example
     * import { makeBy } from 'fp-ts/Array'
     *
     * const double = (i: number): number => i * 2
     * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])
     * assert.deepStrictEqual(makeBy(-3, double), [])
     * assert.deepStrictEqual(makeBy(4.32164, double), [0, 2, 4, 6])
     *
     * @category constructors
     * @since 2.0.0
     */
    var makeBy = function (n, f) { return (n <= 0 ? [] : makeBy$2(f)(n)); };
    /**
     * Create a `Array` containing a value repeated the specified number of times.
     *
     * **Note**. `n` is normalized to a non negative integer.
     *
     * @example
     * import { replicate } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])
     * assert.deepStrictEqual(replicate(-3, 'a'), [])
     * assert.deepStrictEqual(replicate(2.985647, 'a'), ['a', 'a'])
     *
     * @category constructors
     * @since 2.0.0
     */
    var replicate = function (n, a) { return makeBy(n, function () { return a; }); };
    function fromPredicate$b(predicate) {
        return function (a) { return (predicate(a) ? [a] : []); };
    }
    // -------------------------------------------------------------------------------------
    // natural transformations
    // -------------------------------------------------------------------------------------
    /**
     * Create an array from an `Option`. The resulting array will contain the content of the
     * `Option` if it is `Some` and it will be empty if the `Option` is `None`.
     *
     * @example
     * import { fromOption } from 'fp-ts/Array'
     * import { option } from "fp-ts";
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe(option.some("a"), fromOption),["a"])
     * assert.deepStrictEqual(pipe(option.none, fromOption),[])
     *
     * @category natural transformations
     * @since 2.11.0
     */
    var fromOption$a = function (ma) { return (isNone$2(ma) ? [] : [ma.value]); };
    /**
     * Create an array from an `Either`. The resulting array will contain the content of the
     * `Either` if it is `Right` and it will be empty if the `Either` is `Left`.
     *
     * @example
     * import { fromEither } from 'fp-ts/Array'
     * import { either } from "fp-ts";
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe(either.right("r"), fromEither), ["r"]);
     * assert.deepStrictEqual(pipe(either.left("l"), fromEither), []);
     *
     * @category natural transformations
     * @since 2.11.0
     */
    var fromEither$9 = function (e) { return (isLeft$3(e) ? [] : [e.right]); };
    // -------------------------------------------------------------------------------------
    // destructors
    // -------------------------------------------------------------------------------------
    /**
     * Less strict version of [`match`](#match). It will work when `onEmpty` and `onNonEmpty`
     * have different return types.
     *
     * @example
     * import { matchW } from 'fp-ts/Array'
     * import { pipe } from 'fp-ts/function'
     *
     * const matcherW = matchW(
     *   () => "No elements",
     *   (as) => as.length
     * );
     * assert.deepStrictEqual(pipe([1, 2, 3, 4], matcherW), 4);
     * assert.deepStrictEqual(pipe([], matcherW), "No elements");
     *
     * @category destructors
     * @since 2.11.0
     */
    var matchW$a = function (onEmpty, onNonEmpty) { return function (as) {
        return isNonEmpty$1(as) ? onNonEmpty(as) : onEmpty();
    }; };
    /**
     * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise
     * it passes the array to `onNonEmpty` and returns the result.
     *
     * @example
     * import { match } from 'fp-ts/Array'
     * import { pipe } from 'fp-ts/function'
     *
     * const matcher = match(
     *   () => "No elements",
     *   (as) => `Found ${as.length} element(s)`
     * );
     * assert.deepStrictEqual(pipe([1, 2, 3, 4], matcher), "Found 4 element(s)");
     * assert.deepStrictEqual(pipe([], matcher), "No elements");
     *
     * @category destructors
     * @since 2.11.0
     */
    var match$e = matchW$a;
    /**
     * Less strict version of [`matchLeft`](#matchleft). It will work when `onEmpty` and
     * `onNonEmpty` have different return types.
     *
     * @example
     * import { matchLeftW } from 'fp-ts/Array'
     *
     * const f = matchLeftW(
     *   () => 0,
     *   (head: string, tail: string[]) => `Found "${head}" followed by ${tail.length} elements`
     * );
     * assert.strictEqual(f(["a", "b", "c"]), 'Found "a" followed by 2 elements');
     * assert.strictEqual(f([]), 0);
     *
     * @category destructors
     * @since 2.11.0
     */
    var matchLeftW = function (onEmpty, onNonEmpty) { return function (as) { return (isNonEmpty$1(as) ? onNonEmpty(head$3(as), tail$3(as)) : onEmpty()); }; };
    /**
     * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise
     * it passes the array to `onNonEmpty` broken into its first element and remaining elements.
     *
     * @example
     * import { matchLeft } from 'fp-ts/Array'
     *
     * const len: <A>(as: Array<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))
     * assert.strictEqual(len([1, 2, 3]), 3)
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchLeft = matchLeftW;
    /**
     * Alias of [`matchLeft`](#matchleft).
     *
     * @category destructors
     * @since 2.0.0
     */
    var foldLeft = matchLeft;
    /**
     * Less strict version of [`matchRight`](#matchright). It will work when `onEmpty` and
     * `onNonEmpty` have different return types.
     *
     * @example
     * import { matchRightW } from 'fp-ts/Array'
     *
     * const f = matchRightW(
     *   () => 0,
     *   (head: string[], tail: string) => `Found ${head.length} elements folllowed by "${tail}"`
     * );
     * assert.strictEqual(f(["a", "b", "c"]), 'Found 2 elements folllowed by "c"');
     * assert.strictEqual(f([]), 0);
     *
     * @category destructors
     * @since 2.11.0
     */
    var matchRightW = function (onEmpty, onNonEmpty) { return function (as) { return (isNonEmpty$1(as) ? onNonEmpty(init$2(as), last$2(as)) : onEmpty()); }; };
    /**
     * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise
     * it passes the array to `onNonEmpty` broken  into its initial elements and the last element.
     *
     * @example
     * import { matchRight } from 'fp-ts/Array'
     *
     * const len: <A>(as: Array<A>) => number = matchRight(
     *   () => 0,
     *   (head, _) => 1 + len(head)
     * );
     * assert.strictEqual(len([1, 2, 3]), 3);
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchRight = matchRightW;
    /**
     * Alias of [`matchRight`](#matchright).
     *
     * @category destructors
     * @since 2.0.0
     */
    var foldRight = matchRight;
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * Same as [`chain`](#chain), but passing also the index to the iterating function.
     *
     * @example
     * import { chainWithIndex, replicate } from 'fp-ts/Array'
     * import { pipe } from 'fp-ts/function'
     *
     * const f = (index: number, x: string) => replicate(2, `${x}${index}`);
     * assert.deepStrictEqual(pipe(["a", "b", "c"], chainWithIndex(f)), ["a0", "a0", "b1", "b1", "c2", "c2"]);
     *
     * @category combinators
     * @since 2.7.0
     */
    var chainWithIndex = function (f) { return function (as) {
        var out = [];
        for (var i = 0; i < as.length; i++) {
            out.push.apply(out, f(i, as[i]));
        }
        return out;
    }; };
    /**
     * Same as `reduce` but it carries over the intermediate steps
     *
     * @example
     * import { scanLeft } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])
     *
     * @category combinators
     * @since 2.0.0
     */
    var scanLeft = function (b, f) { return function (as) {
        var len = as.length;
        var out = new Array(len + 1);
        out[0] = b;
        for (var i = 0; i < len; i++) {
            out[i + 1] = f(out[i], as[i]);
        }
        return out;
    }; };
    /**
     * Fold an array from the right, keeping all intermediate results instead of only the final result
     *
     * @example
     * import { scanRight } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])
     *
     * @category combinators
     * @since 2.0.0
     */
    var scanRight = function (b, f) { return function (as) {
        var len = as.length;
        var out = new Array(len + 1);
        out[len] = b;
        for (var i = len - 1; i >= 0; i--) {
            out[i] = f(as[i], out[i + 1]);
        }
        return out;
    }; };
    /**
     * Calculate the number of elements in a `Array`.
     *
     * @example
     * import { size } from 'fp-ts/Array'
     *
     * assert.strictEqual(size(["a","b","c"]),3)
     *
     * @since 2.10.0
     */
    var size$7 = function (as) { return as.length; };
    /**
     * Test whether an array contains a particular index
     *
     * @example
     * import { isOutOfBound } from 'fp-ts/Array'
     *
     * assert.strictEqual(isOutOfBound(1,["a","b","c"]),false)
     * assert.strictEqual(isOutOfBound(-1,["a","b","c"]),true)
     * assert.strictEqual(isOutOfBound(3,["a","b","c"]),true)
     *
     * @since 2.0.0
     */
    var isOutOfBound = isOutOfBound$2;
    // TODO: remove non-curried overloading in v3
    /**
     * This function provides a safe way to read a value at a particular index from an array.
     * It returns a `none` if the index is out of bounds, and a `some` of the element if the
     * index is valid.
     *
     * @example
     * import { lookup } from 'fp-ts/Array'
     * import { some, none } from 'fp-ts/Option'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe([1, 2, 3], lookup(1)), some(2))
     * assert.deepStrictEqual(pipe([1, 2, 3], lookup(3)), none)
     *
     * @since 2.0.0
     */
    var lookup$4 = lookup$5;
    /**
     * Get the first element in an array, or `None` if the array is empty
     *
     * @example
     * import { head } from 'fp-ts/Array'
     * import { some, none } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(head([1, 2, 3]), some(1))
     * assert.deepStrictEqual(head([]), none)
     *
     * @category destructors
     * @since 2.0.0
     */
    var head$1 = head$2;
    /**
     * Get the last element in an array, or `None` if the array is empty
     *
     * @example
     * import { last } from 'fp-ts/Array'
     * import { some, none } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(last([1, 2, 3]), some(3))
     * assert.deepStrictEqual(last([]), none)
     *
     * @category destructors
     * @since 2.0.0
     */
    var last = last$1;
    /**
     * Get all but the first element of an array, creating a new array, or `None` if the array is empty
     *
     * @example
     * import { tail } from 'fp-ts/Array'
     * import { some, none } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))
     * assert.deepStrictEqual(tail([]), none)
     *
     * @category destructors
     * @since 2.0.0
     */
    var tail$1 = function (as) { return (isNonEmpty$1(as) ? some$a(tail$3(as)) : none$2); };
    /**
     * Get all but the last element of an array, creating a new array, or `None` if the array is empty
     *
     * @example
     * import { init } from 'fp-ts/Array'
     * import { some, none } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))
     * assert.deepStrictEqual(init([]), none)
     *
     * @category destructors
     * @since 2.0.0
     */
    var init = function (as) { return (isNonEmpty$1(as) ? some$a(init$2(as)) : none$2); };
    /**
     * Keep only a max number of elements from the start of an `Array`, creating a new `Array`.
     *
     * **Note**. `n` is normalized to a non negative integer.
     *
     * @example
     * import { takeLeft } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(takeLeft(2)([1, 2, 3, 4, 5]), [1, 2]);
     * assert.deepStrictEqual(takeLeft(7)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);
     * assert.deepStrictEqual(takeLeft(0)([1, 2, 3, 4, 5]), []);
     * assert.deepStrictEqual(takeLeft(-1)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);
     *
     * @category combinators
     * @since 2.0.0
     */
    var takeLeft = function (n) { return function (as) { return (isOutOfBound(n, as) ? copy$1(as) : as.slice(0, n)); }; };
    /**
     * Keep only a max number of elements from the end of an `Array`, creating a new `Array`.
     *
     * **Note**. `n` is normalized to a non negative integer.
     *
     * @example
     * import { takeRight } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(takeRight(2)([1, 2, 3, 4, 5]), [4, 5]);
     * assert.deepStrictEqual(takeRight(7)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);
     * assert.deepStrictEqual(takeRight(0)([1, 2, 3, 4, 5]), []);
     * assert.deepStrictEqual(takeRight(-1)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);
     *
     * @category combinators
     * @since 2.0.0
     */
    var takeRight = function (n) { return function (as) {
        return isOutOfBound(n, as) ? copy$1(as) : n === 0 ? [] : as.slice(-n);
    }; };
    function takeLeftWhile(predicate) {
        return function (as) {
            var out = [];
            for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
                var a = as_1[_i];
                if (!predicate(a)) {
                    break;
                }
                out.push(a);
            }
            return out;
        };
    }
    var spanLeftIndex = function (as, predicate) {
        var l = as.length;
        var i = 0;
        for (; i < l; i++) {
            if (!predicate(as[i])) {
                break;
            }
        }
        return i;
    };
    function spanLeft(predicate) {
        return function (as) {
            var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];
            return { init: init, rest: rest };
        };
    }
    /**
     * Creates a new `Array` which is a copy of the input dropping a max number of elements from the start.
     *
     * **Note**. `n` is normalized to a non negative integer.
     *
     * @example
     * import { dropLeft } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(dropLeft(2)([1, 2, 3]), [3]);
     * assert.deepStrictEqual(dropLeft(5)([1, 2, 3]), []);
     * assert.deepStrictEqual(dropLeft(0)([1, 2, 3]), [1, 2, 3]);
     * assert.deepStrictEqual(dropLeft(-2)([1, 2, 3]), [1, 2, 3]);
     *
     * @category combinators
     * @since 2.0.0
     */
    var dropLeft = function (n) { return function (as) {
        return n <= 0 || isEmpty$7(as) ? copy$1(as) : n >= as.length ? [] : as.slice(n, as.length);
    }; };
    /**
     * Creates a new `Array` which is a copy of the input dropping a max number of elements from the end.
     *
     * **Note**. `n` is normalized to a non negative integer.
     *
     * @example
     * import { dropRight } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(dropRight(2)([1, 2, 3]), [1]);
     * assert.deepStrictEqual(dropRight(5)([1, 2, 3]), []);
     * assert.deepStrictEqual(dropRight(0)([1, 2, 3]), [1, 2, 3]);
     * assert.deepStrictEqual(dropRight(-2)([1, 2, 3]), [1, 2, 3]);
     *
     * @category combinators
     * @since 2.0.0
     */
    var dropRight = function (n) { return function (as) {
        return n <= 0 || isEmpty$7(as) ? copy$1(as) : n >= as.length ? [] : as.slice(0, as.length - n);
    }; };
    function dropLeftWhile(predicate) {
        return function (as) { return as.slice(spanLeftIndex(as, predicate)); };
    }
    /**
     * `findIndex` returns an `Option` containing the first index for which a predicate holds.
     * It returns `None` if no element satisfies the predicate.
     * Similar to [`findFirst`](#findFirst) but returning the index instead of the element.
     *
     * @example
     * import { findIndex } from 'fp-ts/Array'
     * import { some, none } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))
     * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)
     *
     * @since 2.0.0
     */
    var findIndex = findIndex$1;
    function findFirst(predicate) {
        return findFirst$1(predicate);
    }
    /**
     * Given a selector function which takes an element and returns an option,
     * this function applies the selector to each element of the array and
     * returns the first `Some` result. Otherwise it returns `None`.
     *
     * @example
     * import { findFirstMap } from 'fp-ts/Array'
     * import { some, none } from 'fp-ts/Option'
     *
     * interface Person {
     *   readonly name: string;
     *   readonly age: number;
     * }
     *
     * const persons: Array<Person> = [
     *   { name: "John", age: 16 },
     *   { name: "Mary", age: 45 },
     *   { name: "Joey", age: 28 },
     * ];
     *
     * const nameOfPersonAbove18 = (p: Person) => (p.age <= 18 ? none : some(p.name));
     * const nameOfPersonAbove70 = (p: Person) => (p.age <= 70 ? none : some(p.name));
     * assert.deepStrictEqual(findFirstMap(nameOfPersonAbove18)(persons), some("Mary"));
     * assert.deepStrictEqual(findFirstMap(nameOfPersonAbove70)(persons), none);
     *
     * @category destructors
     * @since 2.0.0
     */
    var findFirstMap = findFirstMap$1;
    function findLast(predicate) {
        return findLast$1(predicate);
    }
    /**
     * Given a selector function which takes an element and returns an option,
     * this function applies the selector to each element of the array starting from the
     * end and returns the last `Some` result. Otherwise it returns `None`.
     *
     * @example
     * import { findLastMap } from 'fp-ts/Array'
     * import { some, none } from 'fp-ts/Option'
     *
     * interface Person {
     *   readonly name: string;
     *   readonly age: number;
     * }
     *
     * const persons: Array<Person> = [
     *   { name: "John", age: 16 },
     *   { name: "Mary", age: 45 },
     *   { name: "Joey", age: 28 },
     * ];
     *
     * const nameOfPersonAbove18 = (p: Person) => (p.age <= 18 ? none : some(p.name));
     * const nameOfPersonAbove70 = (p: Person) => (p.age <= 70 ? none : some(p.name));
     * assert.deepStrictEqual(findLastMap(nameOfPersonAbove18)(persons), some("Joey"));
     * assert.deepStrictEqual(findLastMap(nameOfPersonAbove70)(persons), none);
     *
     * @category destructors
     * @since 2.0.0
     */
    var findLastMap = findLastMap$1;
    /**
     * Returns the index of the last element of the list which matches the predicate.
     * It returns an `Option` containing the index or `None` if not found.
     *
     * @example
     * import { findLastIndex } from 'fp-ts/Array'
     * import { some, none } from 'fp-ts/Option'
     *
     * interface X {
     *   readonly a: number
     *   readonly b: number
     * }
     * const xs: Array<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]
     * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))
     * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)
     *
     * @since 2.0.0
     */
    var findLastIndex = findLastIndex$1;
    /**
     * This function takes an array and makes a new array containing the same elements.
     *
     * @category combinators
     * @since 2.0.0
     */
    var copy$1 = function (as) { return as.slice(); };
    /**
     * Insert an element at the specified index, creating a new array,
     * or returning `None` if the index is out of bounds.
     *
     * @example
     * import { insertAt } from 'fp-ts/Array'
     * import { some } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))
     *
     * @since 2.0.0
     */
    var insertAt$4 = function (i, a) { return function (as) {
        return i < 0 || i > as.length ? none$2 : some$a(unsafeInsertAt(i, a, as));
    }; };
    /**
     * Change the element at the specified index, creating a new array,
     * or returning `None` if the index is out of bounds.
     *
     * @example
     * import { updateAt } from 'fp-ts/Array'
     * import { some, none } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))
     * assert.deepStrictEqual(updateAt(1, 1)([]), none)
     *
     * @since 2.0.0
     */
    var updateAt$4 = function (i, a) { return modifyAt$4(i, function () { return a; }); };
    /**
     * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds.
     *
     * @example
     * import { deleteAt } from 'fp-ts/Array'
     * import { some, none } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))
     * assert.deepStrictEqual(deleteAt(1)([]), none)
     *
     * @since 2.0.0
     */
    var deleteAt$4 = function (i) { return function (as) {
        return isOutOfBound(i, as) ? none$2 : some$a(unsafeDeleteAt(i, as));
    }; };
    /**
     * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out
     * of bounds.
     *
     * @example
     * import { modifyAt } from 'fp-ts/Array'
     * import { some, none } from 'fp-ts/Option'
     *
     * const double = (x: number): number => x * 2
     * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))
     * assert.deepStrictEqual(modifyAt(1, double)([]), none)
     *
     * @since 2.0.0
     */
    var modifyAt$4 = function (i, f) { return function (as) {
        return isOutOfBound(i, as) ? none$2 : some$a(unsafeUpdateAt(i, f(as[i]), as));
    }; };
    /**
     * Reverse an array, creating a new array
     *
     * @example
     * import { reverse } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])
     *
     * @category combinators
     * @since 2.0.0
     */
    var reverse$4 = function (as) { return (isEmpty$7(as) ? [] : as.slice().reverse()); };
    /**
     * Takes an `Array` of `Either` and produces a new `Array` containing
     * the values of all the `Right` elements in the same order.
     *
     * @example
     * import { rights } from 'fp-ts/Array'
     * import { right, left } from 'fp-ts/Either'
     *
     * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])
     *
     * @category combinators
     * @since 2.0.0
     */
    var rights = function (as) {
        var r = [];
        for (var i = 0; i < as.length; i++) {
            var a = as[i];
            if (a._tag === 'Right') {
                r.push(a.right);
            }
        }
        return r;
    };
    /**
     * Takes an `Array` of `Either` and produces a new `Array` containing
     * the values of all the `Left` elements in the same order.
     *
     * @example
     * import { lefts } from 'fp-ts/Array'
     * import { left, right } from 'fp-ts/Either'
     *
     * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])
     *
     * @category combinators
     * @since 2.0.0
     */
    var lefts = function (as) {
        var r = [];
        for (var i = 0; i < as.length; i++) {
            var a = as[i];
            if (a._tag === 'Left') {
                r.push(a.left);
            }
        }
        return r;
    };
    /**
     * Sort the elements of an array in increasing order, creating a new array
     *
     * @example
     * import { sort } from 'fp-ts/Array'
     * import * as N from 'fp-ts/number'
     *
     * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])
     *
     * @category combinators
     * @since 2.0.0
     */
    var sort = function (O) { return function (as) {
        return as.length <= 1 ? copy$1(as) : as.slice().sort(O.compare);
    }; };
    /**
     * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one
     * input array is short, excess elements of the longer array are discarded.
     *
     * @example
     * import { zipWith } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])
     *
     * @category combinators
     * @since 2.0.0
     */
    var zipWith = function (fa, fb, f) {
        var fc = [];
        var len = Math.min(fa.length, fb.length);
        for (var i = 0; i < len; i++) {
            fc[i] = f(fa[i], fb[i]);
        }
        return fc;
    };
    function zip$1(as, bs) {
        if (bs === undefined) {
            return function (bs) { return zip$1(bs, as); };
        }
        return zipWith(as, bs, function (a, b) { return [a, b]; });
    }
    /**
     * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays
     *
     * @example
     * import { unzip } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])
     *
     * @since 2.0.0
     */
    var unzip = function (as) {
        var fa = [];
        var fb = [];
        for (var i = 0; i < as.length; i++) {
            fa[i] = as[i][0];
            fb[i] = as[i][1];
        }
        return [fa, fb];
    };
    /**
     * Creates a new `Array`, prepending an element to every member of the input `Array`.
     *
     * @example
     * import { prependAll } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])
     *
     * @category combinators
     * @since 2.10.0
     */
    var prependAll = function (middle) {
        var f = prependAll$2(middle);
        return function (as) { return (isNonEmpty$1(as) ? f(as) : []); };
    };
    /**
     * Creates a new `Array` placing an element in between members of the input `Array`.
     *
     * @example
     * import { intersperse } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])
     *
     * @category combinators
     * @since 2.9.0
     */
    var intersperse = function (middle) {
        var f = intersperse$2(middle);
        return function (as) { return (isNonEmpty$1(as) ? f(as) : copy$1(as)); };
    };
    /**
     * Creates a new `Array` rotating the input `Array` by `n` steps.
     *
     * @example
     * import { rotate } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])
     *
     * @category combinators
     * @since 2.0.0
     */
    var rotate$1 = function (n) {
        var f = rotate$3(n);
        return function (as) { return (isNonEmpty$1(as) ? f(as) : copy$1(as)); };
    };
    // TODO: remove non-curried overloading in v3
    /**
     * Test if a value is a member of an `Array`. Takes a `Eq<A>` as a single
     * argument which returns the function to use to search for a value of type `A` in
     * an `Array<A>`.
     *
     * @example
     * import { elem } from 'fp-ts/Array'
     * import * as N from 'fp-ts/number'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(2)), true)
     * assert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(0)), false)
     *
     * @since 2.0.0
     */
    var elem$a = elem$b;
    /**
     * Creates a new `Array` removing duplicate elements, keeping the first occurrence of an element,
     * based on a `Eq<A>`.
     *
     * @example
     * import { uniq } from 'fp-ts/Array'
     * import * as N from 'fp-ts/number'
     *
     * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])
     *
     * @category combinators
     * @since 2.0.0
     */
    var uniq = function (E) {
        var f = uniq$2(E);
        return function (as) { return (isNonEmpty$1(as) ? f(as) : copy$1(as)); };
    };
    /**
     * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,
     * etc...
     *
     * @example
     * import { sortBy } from 'fp-ts/Array'
     * import { contramap } from 'fp-ts/Ord'
     * import * as S from 'fp-ts/string'
     * import * as N from 'fp-ts/number'
     * import { pipe } from 'fp-ts/function'
     *
     * interface Person {
     *   readonly name: string
     *   readonly age: number
     * }
     * const byName = pipe(S.Ord, contramap((p: Person) => p.name))
     * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))
     *
     * const sortByNameByAge = sortBy([byName, byAge])
     *
     * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]
     * assert.deepStrictEqual(sortByNameByAge(persons), [
     *   { name: 'a', age: 1 },
     *   { name: 'b', age: 2 },
     *   { name: 'b', age: 3 },
     *   { name: 'c', age: 2 }
     * ])
     *
     * @category combinators
     * @since 2.0.0
     */
    var sortBy = function (ords) {
        var f = sortBy$2(ords);
        return function (as) { return (isNonEmpty$1(as) ? f(as) : copy$1(as)); };
    };
    /**
     * A useful recursion pattern for processing an array to produce a new array, often used for "chopping" up the input
     * array. Typically chop is called with some function that will consume an initial prefix of the array and produce a
     * value and the rest of the array.
     *
     * @example
     * import { Eq } from 'fp-ts/Eq'
     * import * as A from 'fp-ts/Array'
     * import * as N from 'fp-ts/number'
     * import { pipe } from 'fp-ts/function'
     *
     * const group = <A>(S: Eq<A>): ((as: Array<A>) => Array<Array<A>>) => {
     *   return A.chop(as => {
     *     const { init, rest } = pipe(as, A.spanLeft((a: A) => S.equals(a, as[0])))
     *     return [init, rest]
     *   })
     * }
     * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])
     *
     * @category combinators
     * @since 2.0.0
     */
    var chop = function (f) {
        var g = chop$2(f);
        return function (as) { return (isNonEmpty$1(as) ? g(as) : []); };
    };
    /**
     * Splits an `Array` into two pieces, the first piece has max `n` elements.
     *
     * @example
     * import { splitAt } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])
     *
     * @category combinators
     * @since 2.0.0
     */
    var splitAt = function (n) { return function (as) {
        return n >= 1 && isNonEmpty$1(as) ? splitAt$2(n)(as) : isEmpty$7(as) ? [copy$1(as), []] : [[], copy$1(as)];
    }; };
    /**
     * Splits an array into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
     * the array. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive
     * definition of `chunksOf`; it satisfies the property that
     *
     * ```ts
     * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))
     * ```
     *
     * whenever `n` evenly divides the length of `xs`.
     *
     * @example
     * import { chunksOf } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])
     *
     * @category combinators
     * @since 2.0.0
     */
    var chunksOf = function (n) {
        var f = chunksOf$2(n);
        return function (as) { return (isNonEmpty$1(as) ? f(as) : []); };
    };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var fromOptionK$c = function (f) { return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return fromOption$a(f.apply(void 0, a));
    }; };
    function comprehension(input, f, g) {
        if (g === void 0) { g = function () { return true; }; }
        var go = function (scope, input) {
            return isNonEmpty$1(input)
                ? pipe$1(head$3(input), chain$m(function (x) { return go(pipe$1(scope, append(x)), tail$3(input)); }))
                : g.apply(void 0, scope) ? [f.apply(void 0, scope)]
                    : [];
        };
        return go([], input);
    }
    /**
     * @category combinators
     * @since 2.11.0
     */
    var concatW = function (second) { return function (first) {
        return isEmpty$7(first) ? copy$1(second) : isEmpty$7(second) ? copy$1(first) : first.concat(second);
    }; };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var concat$1 = concatW;
    function union$6(E) {
        var unionE = union$8(E);
        return function (first, second) {
            if (second === undefined) {
                var unionE_1 = union$6(E);
                return function (second) { return unionE_1(second, first); };
            }
            return isNonEmpty$1(first) && isNonEmpty$1(second)
                ? unionE(second)(first)
                : isNonEmpty$1(first)
                    ? copy$1(first)
                    : copy$1(second);
        };
    }
    function intersection$6(E) {
        var elemE = elem$a(E);
        return function (xs, ys) {
            if (ys === undefined) {
                var intersectionE_1 = intersection$6(E);
                return function (ys) { return intersectionE_1(ys, xs); };
            }
            return xs.filter(function (a) { return elemE(a, ys); });
        };
    }
    function difference$6(E) {
        var elemE = elem$a(E);
        return function (xs, ys) {
            if (ys === undefined) {
                var differenceE_1 = difference$6(E);
                return function (ys) { return differenceE_1(ys, xs); };
            }
            return xs.filter(function (a) { return !elemE(a, ys); });
        };
    }
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _map$r = function (fa, f) { return pipe$1(fa, map$z(f)); };
    /* istanbul ignore next */
    var _mapWithIndex$4 = function (fa, f) { return pipe$1(fa, mapWithIndex$5(f)); };
    var _ap$b = function (fab, fa) { return pipe$1(fab, ap$l(fa)); };
    var _chain$f = function (ma, f) { return pipe$1(ma, chain$m(f)); };
    /* istanbul ignore next */
    var _filter$6 = function (fa, predicate) { return pipe$1(fa, filter$9(predicate)); };
    /* istanbul ignore next */
    var _filterMap$6 = function (fa, f) { return pipe$1(fa, filterMap$9(f)); };
    /* istanbul ignore next */
    var _partition$6 = function (fa, predicate) {
        return pipe$1(fa, partition$9(predicate));
    };
    /* istanbul ignore next */
    var _partitionMap$6 = function (fa, f) { return pipe$1(fa, partitionMap$9(f)); };
    /* istanbul ignore next */
    var _partitionWithIndex$4 = function (fa, predicateWithIndex) { return pipe$1(fa, partitionWithIndex$4(predicateWithIndex)); };
    /* istanbul ignore next */
    var _partitionMapWithIndex$4 = function (fa, f) { return pipe$1(fa, partitionMapWithIndex$4(f)); };
    /* istanbul ignore next */
    var _alt$9 = function (fa, that) { return pipe$1(fa, alt$b(that)); };
    var _reduce$9 = function (fa, b, f) { return pipe$1(fa, reduce$e(b, f)); };
    /* istanbul ignore next */
    var _foldMap$9 = function (M) {
        var foldMapM = foldMap$e(M);
        return function (fa, f) { return pipe$1(fa, foldMapM(f)); };
    };
    /* istanbul ignore next */
    var _reduceRight$9 = function (fa, b, f) { return pipe$1(fa, reduceRight$e(b, f)); };
    /* istanbul ignore next */
    var _reduceWithIndex$2 = function (fa, b, f) {
        return pipe$1(fa, reduceWithIndex$5(b, f));
    };
    /* istanbul ignore next */
    var _foldMapWithIndex$2 = function (M) {
        var foldMapWithIndexM = foldMapWithIndex$5(M);
        return function (fa, f) { return pipe$1(fa, foldMapWithIndexM(f)); };
    };
    /* istanbul ignore next */
    var _reduceRightWithIndex$2 = function (fa, b, f) {
        return pipe$1(fa, reduceRightWithIndex$5(b, f));
    };
    /* istanbul ignore next */
    var _filterMapWithIndex$4 = function (fa, f) { return pipe$1(fa, filterMapWithIndex$4(f)); };
    /* istanbul ignore next */
    var _filterWithIndex$4 = function (fa, predicateWithIndex) { return pipe$1(fa, filterWithIndex$4(predicateWithIndex)); };
    /* istanbul ignore next */
    var _extend$7 = function (fa, f) { return pipe$1(fa, extend$7(f)); };
    /* istanbul ignore next */
    var _traverse$9 = function (F) {
        var traverseF = traverse$a(F);
        return function (ta, f) { return pipe$1(ta, traverseF(f)); };
    };
    /* istanbul ignore next */
    var _traverseWithIndex$2 = function (F) {
        var traverseWithIndexF = traverseWithIndex$2(F);
        return function (ta, f) { return pipe$1(ta, traverseWithIndexF(f)); };
    };
    var _chainRecDepthFirst = _chainRecDepthFirst$1;
    var _chainRecBreadthFirst = _chainRecBreadthFirst$1;
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * Given an element of the base type, `of` builds an `Array` containing just that
     * element of the base type (this is useful for building a `Monad`).
     *
     * @example
     * import { of } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(of("a"), ["a"]);
     *
     * @category Pointed
     * @since 2.0.0
     */
    var of$l = of$n;
    /**
     * Makes an empty `Array`, useful for building a [`Monoid`](#Monoid)
     *
     * @category Zero
     * @since 2.7.0
     */
    var zero$4 = function () { return []; };
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: Array<A>) => Array<B>`.
     * In practice it applies the base function to each element of the array and collects the
     * results in a new array.
     *
     * @example
     * import { map } from 'fp-ts/Array'
     * import { pipe } from 'fp-ts/function'
     *
     * const f = (n: number) => n * 2;
     * assert.deepStrictEqual(pipe([1, 2, 3], map(f)), [2, 4, 6]);
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$z = function (f) { return function (fa) { return fa.map(function (a) { return f(a); }); }; };
    /**
     * Apply a function to an argument under a type constructor.
     *
     * It can be used to extend the concept of [`map`](#map) to a function that
     * takes more than one parameter as described
     * read [here](https://dev.to/gcanti/getting-started-with-fp-ts-applicative-1kb3)
     *
     * @example
     * import { ap, map, of } from 'fp-ts/Array'
     * import { pipe } from 'fp-ts/function'
     *
     * // a curried function with 3 input parameteres
     * const f = (s1: string) => (n: number) => (s2: string) => s1 + n + s2;
     *
     * // let's use `ap` to iterate `f` over an array for each input parameter
     * assert.deepStrictEqual(pipe(["a", "b"], map(f), ap([1, 2]), ap(["😀", "😫", "😎"])), [
     *   "a1😀", "a1😫", "a1😎",
     *   "a2😀", "a2😫", "a2😎",
     *   "b1😀", "b1😫", "b1😎",
     *   "b2😀", "b2😫", "b2😎",
     * ]);
     *
     * // given Array implements the Applicative interface with the `of` method,
     * // we can write exactly the same thing in a more symmetric way
     * // using `of` on `f` and `ap` on each array in input
     * assert.deepStrictEqual(
     *   pipe(of(f), ap(["a", "b"]), ap([1, 2]), ap(["😀", "😫", "😎"])),
     *   pipe(["a", "b"], map(f), ap([1, 2]), ap(["😀", "😫", "😎"]))
     * );
     *
     * @category Apply
     * @since 2.0.0
     */
    var ap$l = function (fa) { return chain$m(function (f) { return pipe$1(fa, map$z(f)); }); };
    /**
     * Composes computations in sequence, using the return value of one computation to
     * determine the next computation.
     *
     * In other words it takes a function `f` that produces an array from a single element of
     * the base type `A` and returns a new function which applies `f` to each element of the
     * input array (like [`map`](#map)) and, instead of returning an array of arrays, concatenates the
     * results into a single array (like [`flatten`](#flatten)).
     *
     * This is the `chain` component of the array `Monad`.
     *
     * @example
     * import { chain, map, replicate } from 'fp-ts/Array'
     * import { pipe } from 'fp-ts/function'
     *
     * const f = (n: number) => replicate(n, `${n}`);
     * assert.deepStrictEqual(pipe([1, 2, 3], map(f)), [["1"], ["2", "2"], ["3", "3", "3"]]);
     * assert.deepStrictEqual(pipe([1, 2, 3], chain(f)), ["1", "2", "2", "3", "3", "3"]);
     *
     * @category Monad
     * @since 2.0.0
     */
    var chain$m = function (f) { return function (ma) {
        return pipe$1(ma, chainWithIndex(function (_, a) { return f(a); }));
    }; };
    /**
     * Takes an array of arrays of `A` and flattens them into an array of `A`
     * by concatenating the elements of each array in order.
     *
     * Derivable from [`chain`](#chain).
     *
     * @example
     * import { flatten } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(flatten([["a"], ["b", "c"], ["d", "e", "f"]]), ["a", "b", "c", "d", "e", "f"]);
     *
     * @category combinators
     * @since 2.5.0
     */
    var flatten$f = 
    /*#__PURE__*/
    chain$m(identity$1);
    /**
     * Same as [`map`](#map), but the iterating function takes both the index and the value
     * of the element.
     *
     * @example
     * import { mapWithIndex } from 'fp-ts/Array'
     * import { pipe } from 'fp-ts/function'
     *
     * const f = (i: number, s: string) => `${s} - ${i}`;
     * assert.deepStrictEqual(pipe(["a", "b", "c"], mapWithIndex(f)), ["a - 0", "b - 1", "c - 2"]);
     *
     * @category FunctorWithIndex
     * @since 2.0.0
     */
    var mapWithIndex$5 = function (f) { return function (fa) {
        return fa.map(function (a, i) { return f(i, a); });
    }; };
    /**
     * Maps an array with an iterating function that takes the index and the value of
     * each element and returns an `Option`. It keeps only the `Some` values discarding
     * the `None`s.
     *
     * Same as [`filterMap`](#filterMap), but with an iterating function which takes also
     * the index as input.
     *
     * @example
     * import { filterMapWithIndex } from 'fp-ts/Array'
     * import { pipe } from 'fp-ts/function'
     * import { option } from "fp-ts";
     *
     * const f = (i: number, s: string) => (i % 2 === 1 ? option.some(s.toUpperCase()) : option.none);
     * assert.deepStrictEqual(pipe(["a", "no", "neither", "b"], filterMapWithIndex(f)), ["NO", "B"]);
     *
     * @category FilterableWithIndex
     * @since 2.0.0
     */
    var filterMapWithIndex$4 = function (f) { return function (fa) {
        var out = [];
        for (var i = 0; i < fa.length; i++) {
            var optionB = f(i, fa[i]);
            if (isSome$2(optionB)) {
                out.push(optionB.value);
            }
        }
        return out;
    }; };
    /**
     * Maps an array with an iterating function that returns an `Option`
     * and it keeps only the `Some` values discarding the `None`s.
     *
     * @example
     * import { filterMap } from 'fp-ts/Array'
     * import { pipe } from 'fp-ts/function'
     * import { option } from "fp-ts";
     *
     * const f = (s: string) => s.length === 1 ? option.some(s.toUpperCase()) : option.none;
     * assert.deepStrictEqual(pipe(["a", "no", "neither", "b"], filterMap(f)), ["A", "B"]);
     *
     * @category Filterable
     * @since 2.0.0
     */
    var filterMap$9 = function (f) {
        return filterMapWithIndex$4(function (_, a) { return f(a); });
    };
    /**
     * Compact an array of `Option`s discarding the `None` values and
     * keeping the `Some` values. It returns a new array containing the values of
     * the `Some` options.
     *
     * @example
     * import { compact } from 'fp-ts/Array'
     * import { option } from "fp-ts";
     *
     * assert.deepStrictEqual(compact([option.some("a"), option.none, option.some("b")]), ["a", "b"]);
     *
     * @category Compactable
     * @since 2.0.0
     */
    var compact$9 = 
    /*#__PURE__*/
    filterMap$9(identity$1);
    /**
     * Separate an array of `Either`s into `Left`s and `Right`s, creating two new arrays:
     * one containing all the left values and one containing all the right values.
     *
     * @example
     * import { separate } from 'fp-ts/Array'
     * import { either } from "fp-ts";
     *
     * assert.deepStrictEqual(separate([either.right("r1"), either.left("l1"), either.right("r2")]), {
     *   left: ["l1"],
     *   right: ["r1", "r2"],
     * });
     *
     * @category Compactable
     * @since 2.0.0
     */
    var separate$9 = function (fa) {
        var left = [];
        var right = [];
        for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
            var e = fa_1[_i];
            if (e._tag === 'Left') {
                left.push(e.left);
            }
            else {
                right.push(e.right);
            }
        }
        return separated(left, right);
    };
    /**
     * Given an iterating function that is a `Predicate` or a `Refinement`,
     * `filter` creates a new `Array` containing the elements of the original
     * `Array` for which the iterating function is `true`.
     *
     * @example
     * import { filter } from 'fp-ts/Array'
     * import { isString } from "fp-ts/lib/string";
     *
     * assert.deepStrictEqual(filter(isString)(["a", 1, {}, "b", 5]), ["a", "b"]);
     * assert.deepStrictEqual(filter((x:number) => x > 0)([-3, 1, -2, 5]), [1, 5]);
     *
     * @category Filterable
     * @since 2.0.0
     */
    var filter$9 = function (predicate) { return function (as) { return as.filter(predicate); }; };
    /**
     * Given an iterating function that is a `Predicate` or a `Refinement`,
     * `partition` creates two new `Array`s: `right` containing the elements of the original
     * `Array` for which the iterating function is `true`, `left` containing the elements
     * for which it is false.
     *
     * @example
     * import { partition } from 'fp-ts/Array'
     * import { isString } from "fp-ts/lib/string";
     *
     * assert.deepStrictEqual(partition(isString)(["a", 1, {}, "b", 5]), { left: [1, {}, 5], right: ["a", "b"] });
     * assert.deepStrictEqual(partition((x: number) => x > 0)([-3, 1, -2, 5]), { left: [-3, -2], right: [1, 5] });
     *
     * @category Filterable
     * @since 2.0.0
     */
    var partition$9 = function (predicate) {
        return partitionWithIndex$4(function (_, a) { return predicate(a); });
    };
    /**
     * Same as [`partition`](#partition), but passing also the index to the iterating function.
     *
     * @example
     * import { partitionWithIndex } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(partitionWithIndex((index, x: number) => index < 3 && x > 0)([-2, 5, 6, 7]), {
     *   left: [-2, 7],
     *   right: [5, 6],
     * });
     *
     * @category FilterableWithIndex
     * @since 2.0.0
     */
    var partitionWithIndex$4 = function (predicateWithIndex) { return function (as) {
        var left = [];
        var right = [];
        for (var i = 0; i < as.length; i++) {
            var b = as[i];
            if (predicateWithIndex(i, b)) {
                right.push(b);
            }
            else {
                left.push(b);
            }
        }
        return separated(left, right);
    }; };
    /**
     * Given an iterating function that returns an `Either`,
     * `partitionMap` applies the iterating function to each element and it creates two `Array`s:
     * `right` containing the values of `Right` results, `left` containing the values of `Left` results.
     *
     * @example
     * import { partitionMap } from 'fp-ts/Array'
     * import { Either, left, right } from "fp-ts/lib/Either";
     *
     * const upperIfString = <B>(x: B): Either<B, string> =>
     *   typeof x === "string" ? right(x.toUpperCase()) : left(x);
     * assert.deepStrictEqual(partitionMap(upperIfString)([-2, "hello", 6, 7, "world"]), {
     *   left: [-2, 6, 7],
     *   right: [ 'HELLO', 'WORLD' ],
     * });
     *
     * @category Filterable
     * @since 2.0.0
     */
    var partitionMap$9 = function (f) { return partitionMapWithIndex$4(function (_, a) { return f(a); }); };
    /**
     * Same as [`partitionMap`](#partitionMap), but passing also the index to the iterating function.
     *
     * @example
     * import { partitionMapWithIndex } from 'fp-ts/Array'
     * import { Either, left, right } from "fp-ts/lib/Either";
     *
     * const upperIfStringBefore3 = <B>(index: number, x: B): Either<B, string> =>
     *   index < 3 && typeof x === "string" ? right(x.toUpperCase()) : left(x);
     * assert.deepStrictEqual(partitionMapWithIndex(upperIfStringBefore3)([-2, "hello", 6, 7, "world"]), {
     *   left: [-2, 6, 7, "world"],
     *   right: ["HELLO"],
     * });
     *
     * @category FilterableWithIndex
     * @since 2.0.0
     */
    var partitionMapWithIndex$4 = function (f) { return function (fa) {
        var left = [];
        var right = [];
        for (var i = 0; i < fa.length; i++) {
            var e = f(i, fa[i]);
            if (e._tag === 'Left') {
                left.push(e.left);
            }
            else {
                right.push(e.right);
            }
        }
        return separated(left, right);
    }; };
    /**
     * Less strict version of [`alt`](#alt), it can concatenate `Array`s of different base types.
     *
     * @example
     * import { altW } from 'fp-ts/Array';
     *
     * assert.deepStrictEqual(altW(() => [2, 3, 4])(["a"]), ["a", 2, 3, 4]);
     *
     * @category Alt
     * @since 2.9.0
     */
    var altW$9 = function (that) { return function (fa) { return fa.concat(that()); }; };
    /**
     * `alt` implements the `Alt` iterface by concatenation of `Array`s.
     * `Alt` interface is similar to `Semigroup` for higher-kinded types such
     * as `Array` and `Option`: the example below shows both `Alt`'s `alt` and
     * `Semigroup`'s `concat` functions.
     *
     * @example
     * import { alt, concat } from 'fp-ts/Array';
     *
     * assert.deepStrictEqual(alt(() => [2, 3, 4])([1]), [1, 2, 3, 4]);
     * assert.deepStrictEqual(concat([2, 3, 4])([1]), [1, 2, 3, 4]);
     *
     * @category Alt
     * @since 2.0.0
     */
    var alt$b = altW$9;
    /**
     * Same as [`filter`](#filter), but passing also the index to the iterating function.
     *
     * @example
     * import { filterWithIndex } from 'fp-ts/Array';
     *
     * const f = (index: number, x: number) => x > 0 && index <= 2;
     * assert.deepStrictEqual(filterWithIndex(f)([-3, 1, -2, 5]), [1]);
     *
     * @category FilterableWithIndex
     * @since 2.0.0
     */
    var filterWithIndex$4 = function (predicateWithIndex) { return function (as) {
        return as.filter(function (b, i) { return predicateWithIndex(i, b); });
    }; };
    /**
     * Given an iterating function that takes `Array<A>` as input, `extend` returns
     * an array containing the results of the iterating function applied to the whole input
     * `Array`, then to the input `Array` without the first element, then to the input
     * `Array` without the first two elements, etc.
     *
     * @example
     * import { extend } from 'fp-ts/Array'
     *
     * const f = (a: string[]) => a.join(",");
     * assert.deepStrictEqual(extend(f)(["a", "b", "c"]), ["a,b,c", "b,c", "c"]);
     *
     * @category Extend
     * @since 2.0.0
     */
    var extend$7 = function (f) { return function (wa) {
        return wa.map(function (_, i) { return f(wa.slice(i)); });
    }; };
    /**
     * `duplicate` returns an array containing the whole input `Array`,
     * then to the input `Array` dropping the first element, then to the input
     * `Array` dropping the first two elements, etc.
     * Derivable from `Extend`.
     *
     * @example
     * import { duplicate } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(duplicate(["a", "b", "c"]), [["a", "b", "c"], ["b", "c"], ["c"]]);
     *
     * @category combinators
     * @since 2.0.0
     */
    var duplicate$7 = 
    /*#__PURE__*/
    extend$7(identity$1);
    /**
     * Map and fold an `Array`.
     * Map the `Array` passing each value to the iterating function.
     * Then fold the results using the provided `Monoid`.
     *
     * @example
     * import { foldMap } from 'fp-ts/Array'
     *
     * const monoid = { concat: (a: string, b: string) => a + b, empty: "" };
     * const f = (s: string) => s.toUpperCase()
     * assert.deepStrictEqual(foldMap(monoid)(f)(["a", "b", "c"]), "ABC");
     *
     * @category Foldable
     * @since 2.0.0
     */
    var foldMap$e = foldMap$f;
    /**
     * Same as [`foldMap`](#foldMap) but passing also the index to the iterating function.
     *
     * @example
     * import { foldMapWithIndex } from 'fp-ts/Array'
     *
     * const monoid = { concat: (a: string, b: string) => a + b, empty: "" };
     * const f = (index:number, s: string) => `${s.toUpperCase()}(${index})`
     * assert.deepStrictEqual(foldMapWithIndex(monoid)(f)(["a", "b", "c"]), "A(0)B(1)C(2)");
     *
     * @category FoldableWithIndex
     * @since 2.0.0
     */
    var foldMapWithIndex$5 = foldMapWithIndex$6;
    /**
     * Reduces an `Array`.
     *
     * `reduce` executes the supplied iterating function on each element of the array,
     * in order, passing in the element and the return value from the calculation on the preceding element.
     *
     * The first time that the iterating function is called there is no "return value of the
     * previous calculation", the initial value is used in its place.
     *
     * @example
     * import { reduce } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(reduce(5, (acc: number, cur: number) => acc * cur)([2, 3]), 5 * 2 * 3);
     *
     * @category Foldable
     * @since 2.0.0
     */
    var reduce$e = reduce$f;
    /**
     * Same as [`reduce`](#reduce) but passing also the index to the iterating function.
     *
     * @example
     * import { reduceWithIndex } from 'fp-ts/Array'
     *
     * const f = (index: number, acc: string, cur: unknown) =>
     *   acc + (typeof cur === "string" ? cur.toUpperCase() + index : "");
     * assert.deepStrictEqual(reduceWithIndex("", f)([2, "a", "b", null]), "A1B2");
     *
     * @category FoldableWithIndex
     * @since 2.0.0
     */
    var reduceWithIndex$5 = reduceWithIndex$6;
    /**
     * Same as [`reduce`](#reduce) but applied from the end to the start.
     *
     * *Note*: the iterating function in this case takes the accumulator as the last argument.
     *
     * @example
     * import { reduceRight } from 'fp-ts/Array'
     *
     * assert.deepStrictEqual(reduceRight("", (cur: string, acc: string) => acc + cur)(["a", "b", "c"]), "cba");
     *
     * @category Foldable
     * @since 2.0.0
     */
    var reduceRight$e = reduceRight$f;
    /**
     * Same as [`reduceRight`](#reduceRight) but passing also the index to the iterating function.
     *
     * @example
     * import { reduceRightWithIndex } from 'fp-ts/Array'
     *
     * const f = (index: number, cur: unknown, acc: string) =>
     *   acc + (typeof cur === "string" ? cur.toUpperCase() + index : "");
     * assert.deepStrictEqual(reduceRightWithIndex("", f)([2, "a", "b", null]), "B2A1");
     *
     * @category FoldableWithIndex
     * @since 2.0.0
     */
    var reduceRightWithIndex$5 = reduceRightWithIndex$6;
    /**
     * Given an iterating function that returns a `HKT` (higher kinded type), `traverse`
     * applies the iterating function to each element of the `Array` and then [`sequence`](#sequence)-s
     * the results using the provided `Applicative`.
     *
     * E.g. suppose you have an `Array` and you want to format each element with a function
     * that returns a result or an error as `f = (a: A) => Either<Error, B>`, using `traverse`
     * you can apply `f` to all elements and directly obtain as a result an `Either<Error,Array<B>>`
     * i.e. an `Array<B>` if all the results are `B`, or an `Error` if some of the results
     * are `Error`s.
     *
     * @example
     * import { traverse } from 'fp-ts/Array'
     * import { Applicative, left, right } from "fp-ts/lib/Either";
     *
     * const f = (x: unknown) =>
     *   typeof x === "string" ? right(x.toUpperCase()) : left(new Error("not a string"));
     * assert.deepStrictEqual(traverse(Applicative)(f)(["a", "b"]), right(["A", "B"]));
     * assert.deepStrictEqual(traverse(Applicative)(f)(["a", 5]), left(new Error("not a string")));
     *
     * @category Traversable
     * @since 2.6.3
     */
    var traverse$a = function (F) {
        var traverseWithIndexF = traverseWithIndex$2(F);
        return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };
    };
    /**
     * `sequence` takes an `Array` where elements are `HKT<A>` (higher kinded type) and,
     * using an applicative of that `HKT`, returns an `HKT` of `Array<A>`.
     * E.g. it can turn an `Array<Either<Error, string>>` into an `Either<Error, Array<string>>`.
     *
     * `sequence` requires an `Applicative` of the `HKT` you are targeting, e.g. to turn an
     * `Array<Either<E, A>>` into an `Either<E, Array<A>>`, it needs an
     * `Applicative` for `Either`, to to turn an `Array<Option<A>>` into an `Option<Array<A>>`,
     * it needs an `Applicative` for `Option`.
     *
     * @example
     * import { sequence } from 'fp-ts/Array'
     * import { Applicative, left, right } from "fp-ts/lib/Either";
     *
     * assert.deepStrictEqual(sequence(Applicative)([right("a"), right("b")]), right(["a", "b"]));
     * assert.deepStrictEqual(
     *   sequence(Applicative)([right("a"), left(new Error("not a string"))]),
     *   left(new Error("not a string"))
     * );
     *
     * @category Traversable
     * @since 2.6.3
     */
    var sequence$a = function (F) { return function (ta) {
        return _reduce$9(ta, F.of(zero$4()), function (fas, fa) {
            return F.ap(F.map(fas, function (as) { return function (a) { return pipe$1(as, append(a)); }; }), fa);
        });
    }; };
    /**
     * Same as [`traverse`](#traverse) but passing also the index to the iterating function.
     *
     * @example
     * import { traverseWithIndex } from 'fp-ts/Array'
     * import { Applicative, left, right } from "fp-ts/lib/Either";
     *
     * const f = (index:number, x:unknown) =>
     *   typeof x === "string" ? right(x.toUpperCase() + index) : left(new Error("not a string"));
     * assert.deepStrictEqual(traverseWithIndex(Applicative)(f)(["a", "b"]), right(["A0", "B1"]));
     * assert.deepStrictEqual(traverseWithIndex(Applicative)(f)(["a", 5]), left(new Error("not a string")));
     *
     * @category TraversableWithIndex
     * @since 2.6.3
     */
    var traverseWithIndex$2 = function (F) { return function (f) {
        return reduceWithIndex$5(F.of(zero$4()), function (i, fbs, a) {
            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe$1(bs, append(b)); }; }), f(i, a));
        });
    }; };
    /**
     * @category Witherable
     * @since 2.6.5
     */
    var wither$3 = function (F) {
        var _witherF = _wither$3(F);
        return function (f) { return function (fa) { return _witherF(fa, f); }; };
    };
    /**
     * @category Witherable
     * @since 2.6.5
     */
    var wilt$3 = function (F) {
        var _wiltF = _wilt$3(F);
        return function (f) { return function (fa) { return _wiltF(fa, f); }; };
    };
    /**
     * `unfold` takes a function `f` which returns an `Option` of a tuple containing an outcome
     * value and an input for the following iteration.
     * `unfold` applies `f` to the initial value `b` and then recursively to the second
     * element of the tuple contained in the returned `option` of the previous
     * calculation until `f` returns `Option.none`.
     *
     * @example
     * import { unfold } from 'fp-ts/Array'
     * import { option } from 'fp-ts'
     *
     * const f = (n: number) => {
     *   if (n <= 0) return option.none;
     *   const returnValue = n * 2;
     *   const inputForNextRound = n - 1;
     *   return option.some([returnValue, inputForNextRound] as const);
     * };
     * assert.deepStrictEqual(unfold(5, f), [10, 8, 6, 4, 2]);
     *
     * @category Unfoldable
     * @since 2.6.6
     */
    var unfold = function (b, f) {
        var out = [];
        var bb = b;
        while (true) {
            var mt = f(bb);
            if (isSome$2(mt)) {
                var _a = mt.value, a = _a[0], b_1 = _a[1];
                out.push(a);
                bb = b_1;
            }
            else {
                break;
            }
        }
        return out;
    };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$u = 'Array';
    /**
     * `getShow` makes a `Show` for an `Array<A>` from a `Show` for
     * an `A`.
     *
     * @example
     * import { getShow } from 'fp-ts/Array'
     *
     * const numShow = { show: (n: number) => (n >= 0 ? `${n}` : `(${-n})`) };
     * assert.deepStrictEqual(getShow(numShow).show([-2, -1, 0, 1]), "[(2), (1), 0, 1]");
     *
     * @category instances
     * @since 2.0.0
     */
    var getShow$c = getShow$d;
    /**
     * Get a `Semigroup` based on the concatenation of `Array`s.
     * See also [`getMonoid`](#getMonoid).
     *
     * @example
     * import { getSemigroup } from 'fp-ts/Array'
     *
     * const S = getSemigroup<number>();
     * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1, 2, 2, 3]);
     *
     * @category instances
     * @since 2.10.0
     */
    var getSemigroup$d = function () { return ({
        concat: function (first, second) { return first.concat(second); }
    }); };
    /**
     * Returns a `Monoid` for `Array<A>` based on the concatenation of `Array`s.
     *
     * @example
     * import { getMonoid } from 'fp-ts/Array'
     *
     * const M = getMonoid<number>()
     * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])
     *
     * @category instances
     * @since 2.0.0
     */
    var getMonoid$b = function () { return ({
        concat: getSemigroup$d().concat,
        empty: []
    }); };
    /**
     * Derives an `Eq` over the `Array` of a given element type from the `Eq` of that type. The derived `Eq` defines two
     * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of
     * different lengths, the result is non equality.
     *
     * @example
     * import * as S from 'fp-ts/string'
     * import { getEq } from 'fp-ts/Array'
     *
     * const E = getEq(S.Eq)
     * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)
     * assert.strictEqual(E.equals(['a'], []), false)
     *
     * @category instances
     * @since 2.0.0
     */
    var getEq$c = getEq$d;
    /**
     * Derives an `Ord` over the `Array` of a given element type from the `Ord` of that type. The ordering between two such
     * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in
     * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have
     * the same length, the result is equality.
     *
     * @example
     * import { getOrd } from 'fp-ts/Array'
     * import * as S from 'fp-ts/string'
     *
     * const O = getOrd(S.Ord)
     * assert.strictEqual(O.compare(['b'], ['a']), 1)
     * assert.strictEqual(O.compare(['a'], ['a']), 0)
     * assert.strictEqual(O.compare(['a'], ['b']), -1)
     *
     * @category instances
     * @since 2.0.0
     */
    var getOrd$2 = getOrd$3;
    /**
     * Get a `Semigroup` based on the union of the elements of `Array`s.
     * Elements which equal according to the provided `Eq` are included
     * only once in the result.
     * See also [`getUnionMonoid`](#getUnionMonoid).
     *
     * @example
     * import { getUnionSemigroup } from 'fp-ts/Array';
     * import { Eq } from 'fp-ts/number';
     *
     * const S = getUnionSemigroup<number>(Eq);
     * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1, 2, 3]);
     *
     * @category instances
     * @since 2.11.0
     */
    var getUnionSemigroup$6 = function (E) {
        var unionE = union$6(E);
        return {
            concat: function (first, second) { return unionE(second)(first); }
        };
    };
    /**
     * Get a `Monoid` based on the union of the elements of `Array`s.
     * Elements which equal according to the provided `Eq` are included
     * only once in the result.
     *
     * @example
     * import { getUnionMonoid } from 'fp-ts/Array'
     * import { Eq } from 'fp-ts/number';
     *
     * const M = getUnionMonoid<number>(Eq);
     * assert.deepStrictEqual(M.concat([1, 2], [2, 3]), [1, 2, 3]);
     * assert.deepStrictEqual(M.empty,[]);
     *
     * @category instances
     * @since 2.11.0
     */
    var getUnionMonoid$6 = function (E) { return ({
        concat: getUnionSemigroup$6(E).concat,
        empty: []
    }); };
    /**
     * Get a `Semigroup` based on the intersection of the elements of `Array`s.
     * Only elements present in the two arrays which are equal according to the
     * provided `Eq` are included in the result.
     *
     * @example
     * import { getIntersectionSemigroup } from 'fp-ts/Array'
     * import { Eq } from 'fp-ts/number';
     *
     * const S = getIntersectionSemigroup<number>(Eq);
     * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [2]);
     *
     * @category instances
     * @since 2.11.0
     */
    var getIntersectionSemigroup$6 = function (E) {
        var intersectionE = intersection$6(E);
        return {
            concat: function (first, second) { return intersectionE(second)(first); }
        };
    };
    /**
     * Get a `Magma` for `Array` where the `concat` function is the differnce between
     * the first and the second array, i.e. the result contains all the elements of the
     * first array for which their is no equal element in the second array according
     * to the `Eq` provided.
     *
     *
     * @example
     * import { getDifferenceMagma } from 'fp-ts/Array'
     * import { Eq } from 'fp-ts/number';
     *
     * const S = getDifferenceMagma<number>(Eq);
     * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1]);
     *
     * @category instances
     * @since 2.11.0
     */
    var getDifferenceMagma$6 = function (E) {
        var differenceE = difference$6(E);
        return {
            concat: function (first, second) { return differenceE(second)(first); }
        };
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$s = {
        URI: URI$u,
        map: _map$r
    };
    /**
     * Given an input an `Array` of functions, `flap` returns an `Array` containing
     * the results of applying each function to the given input.
     *
     * @example
     * import { flap } from 'fp-ts/Array'
     *
     * const funs = [
     *   (n: number) => `Double: ${n * 2}`,
     *   (n: number) => `Triple: ${n * 3}`,
     *   (n: number) => `Square: ${n * n}`,
     * ];
     * assert.deepStrictEqual(flap(4)(funs), ['Double: 8', 'Triple: 12', 'Square: 16']);
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$s = 
    /*#__PURE__*/
    flap$x(Functor$s);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$i = {
        URI: URI$u,
        of: of$l
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var FunctorWithIndex$3 = {
        URI: URI$u,
        map: _map$r,
        mapWithIndex: _mapWithIndex$4
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Apply$a = {
        URI: URI$u,
        map: _map$r,
        ap: _ap$b
    };
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.5.0
     */
    var apFirst$g = 
    /*#__PURE__*/
    apFirst$k(Apply$a);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.5.0
     */
    var apSecond$g = 
    /*#__PURE__*/
    apSecond$k(Apply$a);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Applicative$b = {
        URI: URI$u,
        map: _map$r,
        ap: _ap$b,
        of: of$l
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$h = {
        URI: URI$u,
        map: _map$r,
        ap: _ap$b,
        chain: _chain$f
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var chainFirst$g = 
    /*#__PURE__*/
    chainFirst$k(Chain$h);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Monad$g = {
        URI: URI$u,
        map: _map$r,
        ap: _ap$b,
        of: of$l,
        chain: _chain$f
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Unfoldable$1 = {
        URI: URI$u,
        unfold: unfold
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Alt$9 = {
        URI: URI$u,
        map: _map$r,
        alt: _alt$9
    };
    /**
     * @category instances
     * @since 2.11.0
     */
    var Zero$3 = {
        URI: URI$u,
        zero: zero$4
    };
    /**
     * @category constructors
     * @since 2.11.0
     */
    var guard$3 = 
    /*#__PURE__*/
    guard$5(Zero$3, Pointed$i);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Alternative$2 = {
        URI: URI$u,
        map: _map$r,
        ap: _ap$b,
        of: of$l,
        alt: _alt$9,
        zero: zero$4
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Extend$3 = {
        URI: URI$u,
        map: _map$r,
        extend: _extend$7
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Compactable$7 = {
        URI: URI$u,
        compact: compact$9,
        separate: separate$9
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Filterable$7 = {
        URI: URI$u,
        map: _map$r,
        compact: compact$9,
        separate: separate$9,
        filter: _filter$6,
        filterMap: _filterMap$6,
        partition: _partition$6,
        partitionMap: _partitionMap$6
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var FilterableWithIndex$3 = {
        URI: URI$u,
        map: _map$r,
        mapWithIndex: _mapWithIndex$4,
        compact: compact$9,
        separate: separate$9,
        filter: _filter$6,
        filterMap: _filterMap$6,
        partition: _partition$6,
        partitionMap: _partitionMap$6,
        partitionMapWithIndex: _partitionMapWithIndex$4,
        partitionWithIndex: _partitionWithIndex$4,
        filterMapWithIndex: _filterMapWithIndex$4,
        filterWithIndex: _filterWithIndex$4
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Foldable$a = {
        URI: URI$u,
        reduce: _reduce$9,
        foldMap: _foldMap$9,
        reduceRight: _reduceRight$9
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var FoldableWithIndex$3 = {
        URI: URI$u,
        reduce: _reduce$9,
        foldMap: _foldMap$9,
        reduceRight: _reduceRight$9,
        reduceWithIndex: _reduceWithIndex$2,
        foldMapWithIndex: _foldMapWithIndex$2,
        reduceRightWithIndex: _reduceRightWithIndex$2
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Traversable$a = {
        URI: URI$u,
        map: _map$r,
        reduce: _reduce$9,
        foldMap: _foldMap$9,
        reduceRight: _reduceRight$9,
        traverse: _traverse$9,
        sequence: sequence$a
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var TraversableWithIndex$3 = {
        URI: URI$u,
        map: _map$r,
        mapWithIndex: _mapWithIndex$4,
        reduce: _reduce$9,
        foldMap: _foldMap$9,
        reduceRight: _reduceRight$9,
        reduceWithIndex: _reduceWithIndex$2,
        foldMapWithIndex: _foldMapWithIndex$2,
        reduceRightWithIndex: _reduceRightWithIndex$2,
        traverse: _traverse$9,
        sequence: sequence$a,
        traverseWithIndex: _traverseWithIndex$2
    };
    var _wither$3 = 
    /*#__PURE__*/
    witherDefault$1(Traversable$a, Compactable$7);
    var _wilt$3 = 
    /*#__PURE__*/
    wiltDefault$1(Traversable$a, Compactable$7);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Witherable$4 = {
        URI: URI$u,
        map: _map$r,
        compact: compact$9,
        separate: separate$9,
        filter: _filter$6,
        filterMap: _filterMap$6,
        partition: _partition$6,
        partitionMap: _partitionMap$6,
        reduce: _reduce$9,
        foldMap: _foldMap$9,
        reduceRight: _reduceRight$9,
        traverse: _traverse$9,
        sequence: sequence$a,
        wither: _wither$3,
        wilt: _wilt$3
    };
    /**
     * @category ChainRec
     * @since 2.11.0
     */
    var chainRecDepthFirst = chainRecDepthFirst$1;
    /**
     * @category instances
     * @since 2.11.0
     */
    var ChainRecDepthFirst = {
        URI: URI$u,
        map: _map$r,
        ap: _ap$b,
        chain: _chain$f,
        chainRec: _chainRecDepthFirst
    };
    /**
     * @category ChainRec
     * @since 2.11.0
     */
    var chainRecBreadthFirst = chainRecBreadthFirst$1;
    /**
     * @category instances
     * @since 2.11.0
     */
    var ChainRecBreadthFirst = {
        URI: URI$u,
        map: _map$r,
        ap: _ap$b,
        chain: _chain$f,
        chainRec: _chainRecBreadthFirst
    };
    /**
     * Filter values inside a context.
     *
     * @since 2.11.0
     */
    var filterE$1 = 
    /*#__PURE__*/
    filterE$3(Witherable$4);
    /**
     * @category instances
     * @since 2.11.0
     */
    var FromEither$b = {
        URI: URI$u,
        fromEither: fromEither$9
    };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var fromEitherK$8 = 
    /*#__PURE__*/
    fromEitherK$a(FromEither$b);
    // -------------------------------------------------------------------------------------
    // unsafe
    // -------------------------------------------------------------------------------------
    /**
     * @category unsafe
     * @since 2.0.0
     */
    var unsafeInsertAt = unsafeInsertAt$2;
    /**
     * @category unsafe
     * @since 2.0.0
     */
    var unsafeUpdateAt = function (i, a, as) {
        return isNonEmpty$1(as) ? unsafeUpdateAt$2(i, a, as) : [];
    };
    /**
     * @category unsafe
     * @since 2.0.0
     */
    var unsafeDeleteAt = function (i, as) {
        var xs = as.slice();
        xs.splice(i, 1);
        return xs;
    };
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * `every` tells if the provided predicate holds true for every element in the `Array`.
     *
     * @example
     * import { every } from 'fp-ts/Array'
     *
     * assert.equal(every((x: number) => x >= 0)([1, 2, 3]), true);
     * assert.equal(every((x: number) => x >= 0)([-1, 2, 3]), false);
     *
     * @since 2.9.0
     */
    var every$4 = every$5;
    /**
     * `some` tells if the provided predicate holds true at least for one element in the `Array`.
     *
     * @example
     * import { some } from 'fp-ts/Array'
     *
     * assert.equal(some((x: number) => x >= 0)([1, 2, 3]), true);
     * assert.equal(some((x: number) => x >= 10)([1, 2, 3]), false);
     *
     * @since 2.9.0
     */
    var some$8 = function (predicate) { return function (as) { return as.some(predicate); }; };
    /**
     * Alias of [`some`](#some)
     *
     * @since 2.11.0
     */
    var exists$4 = some$8;
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.9.0
     */
    var Do$d = 
    /*#__PURE__*/
    of$l(emptyRecord);
    /**
     * @since 2.8.0
     */
    var bindTo$g = 
    /*#__PURE__*/
    bindTo$k(Functor$s);
    /**
     * @since 2.8.0
     */
    var bind$i = 
    /*#__PURE__*/
    bind$m(Chain$h);
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var apS$g = 
    /*#__PURE__*/
    apS$k(Apply$a);
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use `NonEmptyArray` module instead.
     *
     * @category constructors
     * @since 2.0.0
     * @deprecated
     */
    var range = range$2;
    /**
     * Use a new `[]` instead.
     *
     * @since 2.0.0
     * @deprecated
     */
    var empty$7 = [];
    /**
     * Use `prepend` instead.
     *
     * @category constructors
     * @since 2.0.0
     * @deprecated
     */
    var cons = cons$2;
    /**
     * Use `append` instead.
     *
     * @category constructors
     * @since 2.0.0
     * @deprecated
     */
    var snoc = snoc$2;
    /**
     * Use `prependAll` instead
     *
     * @category combinators
     * @since 2.9.0
     * @deprecated
     */
    var prependToAll = prependAll;
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var array = {
        URI: URI$u,
        compact: compact$9,
        separate: separate$9,
        map: _map$r,
        ap: _ap$b,
        of: of$l,
        chain: _chain$f,
        filter: _filter$6,
        filterMap: _filterMap$6,
        partition: _partition$6,
        partitionMap: _partitionMap$6,
        mapWithIndex: _mapWithIndex$4,
        partitionMapWithIndex: _partitionMapWithIndex$4,
        partitionWithIndex: _partitionWithIndex$4,
        filterMapWithIndex: _filterMapWithIndex$4,
        filterWithIndex: _filterWithIndex$4,
        alt: _alt$9,
        zero: zero$4,
        unfold: unfold,
        reduce: _reduce$9,
        foldMap: _foldMap$9,
        reduceRight: _reduceRight$9,
        traverse: _traverse$9,
        sequence: sequence$a,
        reduceWithIndex: _reduceWithIndex$2,
        foldMapWithIndex: _foldMapWithIndex$2,
        reduceRightWithIndex: _reduceRightWithIndex$2,
        traverseWithIndex: _traverseWithIndex$2,
        extend: _extend$7,
        wither: _wither$3,
        wilt: _wilt$3
    };

    var Array$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        isEmpty: isEmpty$7,
        isNonEmpty: isNonEmpty$1,
        prepend: prepend,
        prependW: prependW,
        append: append,
        appendW: appendW,
        makeBy: makeBy,
        replicate: replicate,
        fromPredicate: fromPredicate$b,
        fromOption: fromOption$a,
        fromEither: fromEither$9,
        matchW: matchW$a,
        match: match$e,
        matchLeftW: matchLeftW,
        matchLeft: matchLeft,
        foldLeft: foldLeft,
        matchRightW: matchRightW,
        matchRight: matchRight,
        foldRight: foldRight,
        chainWithIndex: chainWithIndex,
        scanLeft: scanLeft,
        scanRight: scanRight,
        size: size$7,
        isOutOfBound: isOutOfBound,
        lookup: lookup$4,
        head: head$1,
        last: last,
        tail: tail$1,
        init: init,
        takeLeft: takeLeft,
        takeRight: takeRight,
        takeLeftWhile: takeLeftWhile,
        spanLeft: spanLeft,
        dropLeft: dropLeft,
        dropRight: dropRight,
        dropLeftWhile: dropLeftWhile,
        findIndex: findIndex,
        findFirst: findFirst,
        findFirstMap: findFirstMap,
        findLast: findLast,
        findLastMap: findLastMap,
        findLastIndex: findLastIndex,
        copy: copy$1,
        insertAt: insertAt$4,
        updateAt: updateAt$4,
        deleteAt: deleteAt$4,
        modifyAt: modifyAt$4,
        reverse: reverse$4,
        rights: rights,
        lefts: lefts,
        sort: sort,
        zipWith: zipWith,
        zip: zip$1,
        unzip: unzip,
        prependAll: prependAll,
        intersperse: intersperse,
        rotate: rotate$1,
        elem: elem$a,
        uniq: uniq,
        sortBy: sortBy,
        chop: chop,
        splitAt: splitAt,
        chunksOf: chunksOf,
        fromOptionK: fromOptionK$c,
        comprehension: comprehension,
        concatW: concatW,
        concat: concat$1,
        union: union$6,
        intersection: intersection$6,
        difference: difference$6,
        of: of$l,
        zero: zero$4,
        map: map$z,
        ap: ap$l,
        chain: chain$m,
        flatten: flatten$f,
        mapWithIndex: mapWithIndex$5,
        filterMapWithIndex: filterMapWithIndex$4,
        filterMap: filterMap$9,
        compact: compact$9,
        separate: separate$9,
        filter: filter$9,
        partition: partition$9,
        partitionWithIndex: partitionWithIndex$4,
        partitionMap: partitionMap$9,
        partitionMapWithIndex: partitionMapWithIndex$4,
        altW: altW$9,
        alt: alt$b,
        filterWithIndex: filterWithIndex$4,
        extend: extend$7,
        duplicate: duplicate$7,
        foldMap: foldMap$e,
        foldMapWithIndex: foldMapWithIndex$5,
        reduce: reduce$e,
        reduceWithIndex: reduceWithIndex$5,
        reduceRight: reduceRight$e,
        reduceRightWithIndex: reduceRightWithIndex$5,
        traverse: traverse$a,
        sequence: sequence$a,
        traverseWithIndex: traverseWithIndex$2,
        wither: wither$3,
        wilt: wilt$3,
        unfold: unfold,
        URI: URI$u,
        getShow: getShow$c,
        getSemigroup: getSemigroup$d,
        getMonoid: getMonoid$b,
        getEq: getEq$c,
        getOrd: getOrd$2,
        getUnionSemigroup: getUnionSemigroup$6,
        getUnionMonoid: getUnionMonoid$6,
        getIntersectionSemigroup: getIntersectionSemigroup$6,
        getDifferenceMagma: getDifferenceMagma$6,
        Functor: Functor$s,
        flap: flap$s,
        Pointed: Pointed$i,
        FunctorWithIndex: FunctorWithIndex$3,
        Apply: Apply$a,
        apFirst: apFirst$g,
        apSecond: apSecond$g,
        Applicative: Applicative$b,
        Chain: Chain$h,
        chainFirst: chainFirst$g,
        Monad: Monad$g,
        Unfoldable: Unfoldable$1,
        Alt: Alt$9,
        Zero: Zero$3,
        guard: guard$3,
        Alternative: Alternative$2,
        Extend: Extend$3,
        Compactable: Compactable$7,
        Filterable: Filterable$7,
        FilterableWithIndex: FilterableWithIndex$3,
        Foldable: Foldable$a,
        FoldableWithIndex: FoldableWithIndex$3,
        Traversable: Traversable$a,
        TraversableWithIndex: TraversableWithIndex$3,
        Witherable: Witherable$4,
        chainRecDepthFirst: chainRecDepthFirst,
        ChainRecDepthFirst: ChainRecDepthFirst,
        chainRecBreadthFirst: chainRecBreadthFirst,
        ChainRecBreadthFirst: ChainRecBreadthFirst,
        filterE: filterE$1,
        FromEither: FromEither$b,
        fromEitherK: fromEitherK$8,
        unsafeInsertAt: unsafeInsertAt,
        unsafeUpdateAt: unsafeUpdateAt,
        unsafeDeleteAt: unsafeDeleteAt,
        every: every$4,
        some: some$8,
        exists: exists$4,
        Do: Do$d,
        bindTo: bindTo$g,
        bind: bind$i,
        apS: apS$g,
        range: range,
        empty: empty$7,
        cons: cons,
        snoc: snoc,
        prependToAll: prependToAll,
        array: array
    });

    var Bifunctor$b = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    // -------------------------------------------------------------------------------------
    // refinements
    // -------------------------------------------------------------------------------------
    /**
     * @category refinements
     * @since 2.11.0
     */
    var isBoolean = function (u) { return typeof u === 'boolean'; };
    // -------------------------------------------------------------------------------------
    // destructors
    // -------------------------------------------------------------------------------------
    /**
     * Less strict version of [`match`](#match).
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchW$9 = function (onFalse, onTrue) { return function (value) {
        return value ? onTrue() : onFalse();
    }; };
    /**
     * Alias of [`matchW`](#matchw).
     *
     * @category destructors
     * @since 2.10.0
     */
    var foldW$9 = matchW$9;
    /**
     * Defines the fold over a boolean value.
     * Takes two thunks `onTrue`, `onFalse` and a `boolean` value.
     * If `value` is false, `onFalse()` is returned, otherwise `onTrue()`.
     *
     * @example
     * import { some, map } from 'fp-ts/Option'
     * import { pipe } from 'fp-ts/function'
     * import { match } from 'fp-ts/boolean'
     *
     * assert.deepStrictEqual(
     *  pipe(
     *    some(true),
     *    map(match(() => 'false', () => 'true'))
     *  ),
     *  some('true')
     * )
     *
     * @category destructors
     * @since 2.10.0
     */
    var match$d = foldW$9;
    /**
     * Alias of [`match`](#match).
     *
     * @category destructors
     * @since 2.2.0
     */
    var fold$b = match$d;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.10.0
     */
    var Eq$4 = {
        equals: function (first, second) { return first === second; }
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var BooleanAlgebra$1 = {
        meet: function (first, second) { return first && second; },
        join: function (first, second) { return first || second; },
        zero: false,
        one: true,
        implies: function (first, second) { return !first || second; },
        not: function (b) { return !b; }
    };
    /**
     * `boolean` semigroup under conjunction.
     *
     * @example
     * import { SemigroupAll } from 'fp-ts/boolean'
     *
     * assert.deepStrictEqual(SemigroupAll.concat(true, true), true)
     * assert.deepStrictEqual(SemigroupAll.concat(true, false), false)
     *
     * @category instances
     * @since 2.10.0
     */
    var SemigroupAll = {
        concat: function (first, second) { return first && second; }
    };
    /**
     * `boolean` semigroup under disjunction.
     *
     * @example
     * import { SemigroupAny } from 'fp-ts/boolean'
     *
     * assert.deepStrictEqual(SemigroupAny.concat(true, true), true)
     * assert.deepStrictEqual(SemigroupAny.concat(true, false), true)
     * assert.deepStrictEqual(SemigroupAny.concat(false, false), false)
     *
     * @category instances
     * @since 2.10.0
     */
    var SemigroupAny = {
        concat: function (first, second) { return first || second; }
    };
    /**
     * `boolean` monoid under conjunction.
     *
     * The `empty` value is `true`.
     *
     * @example
     * import { MonoidAll } from 'fp-ts/boolean'
     *
     * assert.deepStrictEqual(MonoidAll.concat(true, true), true)
     * assert.deepStrictEqual(MonoidAll.concat(true, false), false)
     *
     * @category instances
     * @since 2.10.0
     */
    var MonoidAll = {
        concat: SemigroupAll.concat,
        empty: true
    };
    /**
     * `boolean` monoid under disjunction.
     *
     * The `empty` value is `false`.
     *
     * @example
     * import { MonoidAny } from 'fp-ts/boolean'
     *
     * assert.deepStrictEqual(MonoidAny.concat(true, true), true)
     * assert.deepStrictEqual(MonoidAny.concat(true, false), true)
     * assert.deepStrictEqual(MonoidAny.concat(false, false), false)
     *
     * @category instances
     * @since 2.10.0
     */
    var MonoidAny = {
        concat: SemigroupAny.concat,
        empty: false
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Ord$3 = {
        equals: Eq$4.equals,
        compare: function (first, second) { return (first < second ? -1 : first > second ? 1 : 0); }
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Show$2 = {
        show: function (b) { return JSON.stringify(b); }
    };

    var boolean = /*#__PURE__*/Object.freeze({
        __proto__: null,
        isBoolean: isBoolean,
        matchW: matchW$9,
        foldW: foldW$9,
        match: match$d,
        fold: fold$b,
        Eq: Eq$4,
        BooleanAlgebra: BooleanAlgebra$1,
        SemigroupAll: SemigroupAll,
        SemigroupAny: SemigroupAny,
        MonoidAll: MonoidAll,
        MonoidAny: MonoidAny,
        Ord: Ord$3,
        Show: Show$2
    });

    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * Every boolean algebras has a dual algebra, which involves reversing one/zero as well as join/meet.
     *
     * @category combinators
     * @since 2.10.0
     */
    var reverse$3 = function (B) { return ({
        meet: function (x, y) { return B.join(x, y); },
        join: function (x, y) { return B.meet(x, y); },
        zero: B.one,
        one: B.zero,
        implies: function (x, y) { return B.join(B.not(x), y); },
        not: B.not
    }); };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var booleanAlgebraVoid = {
        meet: function () { return undefined; },
        join: function () { return undefined; },
        zero: undefined,
        one: undefined,
        implies: function () { return undefined; },
        not: function () { return undefined; }
    };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use [`reverse`](#reverse) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    var getDualBooleanAlgebra = reverse$3;
    /**
     * Use [`BooleanAlgebra`](./boolean.ts.html#booleanalgebra) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var booleanAlgebraBoolean = {
        meet: function (x, y) { return x && y; },
        join: function (x, y) { return x || y; },
        zero: false,
        one: true,
        implies: function (x, y) { return !x || y; },
        not: function (x) { return !x; }
    };
    /**
     * Use [`getBooleanAlgebra`](./function.ts.html#getbooleanalgebra) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getFunctionBooleanAlgebra = getBooleanAlgebra$1;

    var BooleanAlgebra = /*#__PURE__*/Object.freeze({
        __proto__: null,
        reverse: reverse$3,
        booleanAlgebraVoid: booleanAlgebraVoid,
        getDualBooleanAlgebra: getDualBooleanAlgebra,
        booleanAlgebraBoolean: booleanAlgebraBoolean,
        getFunctionBooleanAlgebra: getFunctionBooleanAlgebra
    });

    /**
     * The `Bounded` type class represents totally ordered types that have an upper and lower boundary.
     *
     * Instances should satisfy the following law in addition to the `Ord` laws:
     *
     * - Bounded: `bottom <= a <= top`
     *
     * @since 2.0.0
     */
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use [`Bounded`](./number.ts.html#bounded) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var boundedNumber = {
        equals: ordNumber.equals,
        compare: ordNumber.compare,
        top: Infinity,
        bottom: -Infinity
    };

    var Bounded = /*#__PURE__*/Object.freeze({
        __proto__: null,
        boundedNumber: boundedNumber
    });

    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * @category constructors
     * @since 2.0.0
     */
    function getMinMaxDistributiveLattice(O) {
        return {
            meet: min$4(O),
            join: max$4(O)
        };
    }

    var DistributiveLattice = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getMinMaxDistributiveLattice: getMinMaxDistributiveLattice
    });

    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * @category constructors
     * @since 2.0.0
     */
    function getMinMaxBoundedDistributiveLattice(O) {
        var L = getMinMaxDistributiveLattice(O);
        return function (min, max) { return ({
            join: L.join,
            meet: L.meet,
            zero: min,
            one: max
        }); };
    }

    var BoundedDistributiveLattice = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getMinMaxBoundedDistributiveLattice: getMinMaxBoundedDistributiveLattice
    });

    var BoundedJoinSemilattice = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    var BoundedLattice = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    var BoundedMeetSemilattice = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    var Category$1 = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    /**
     * @since 2.0.0
     */
    var tailRec = function (startWith, f) {
        var ab = f(startWith);
        while (ab._tag === 'Left') {
            ab = f(ab.left);
        }
        return ab.right;
    };

    var ChainRec$3 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        tailRec: tailRec
    });

    function split$2(P, C) {
        return function (pab, pcd) { return C.compose(P.right(pcd), P.left(pab)); };
    }
    function fanIn(P, C) {
        var splitPC = split$2(P, C);
        return function (pac, pbc) {
            return C.compose(P.promap(C.id(), function (cc) { return (cc._tag === 'Left' ? cc.left : cc.right); }, identity$1), splitPC(pac, pbc));
        };
    }
    function splitChoice(F) {
        return split$2(F, F);
    }
    function fanin(F) {
        return fanIn(F, F);
    }

    var Choice$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        split: split$2,
        fanIn: fanIn,
        splitChoice: splitChoice,
        fanin: fanin
    });

    var Comonad$5 = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    var contramap_ = function (predicate, f) { return pipe$1(predicate, contramap$1(f)); };
    /**
     * @category Contravariant
     * @since 2.11.0
     */
    var contramap$1 = function (f) { return function (predicate) { return flow(f, predicate); }; };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.11.0
     */
    var URI$t = 'Predicate';
    /**
     * @category instances
     * @since 2.11.0
     */
    var getSemigroupAny = function () { return ({
        concat: function (first, second) { return pipe$1(first, or$1(second)); }
    }); };
    /**
     * @category instances
     * @since 2.11.0
     */
    var getMonoidAny = function () { return ({
        concat: getSemigroupAny().concat,
        empty: constFalse
    }); };
    /**
     * @category instances
     * @since 2.11.0
     */
    var getSemigroupAll = function () { return ({
        concat: function (first, second) { return pipe$1(first, and$1(second)); }
    }); };
    /**
     * @category instances
     * @since 2.11.0
     */
    var getMonoidAll = function () { return ({
        concat: getSemigroupAll().concat,
        empty: constTrue
    }); };
    /**
     * @category instances
     * @since 2.11.0
     */
    var Contravariant$2 = {
        URI: URI$t,
        contramap: contramap_
    };
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var not$1 = function (predicate) { return function (a) { return !predicate(a); }; };
    /**
     * @since 2.11.0
     */
    var or$1 = function (second) { return function (first) { return function (a) { return first(a) || second(a); }; }; };
    /**
     * @since 2.11.0
     */
    var and$1 = function (second) { return function (first) { return function (a) { return first(a) && second(a); }; }; };

    var Predicate$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        contramap: contramap$1,
        URI: URI$t,
        getSemigroupAny: getSemigroupAny,
        getMonoidAny: getMonoidAny,
        getSemigroupAll: getSemigroupAll,
        getMonoidAll: getMonoidAll,
        Contravariant: Contravariant$2,
        not: not$1,
        or: or$1,
        and: and$1
    });

    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.
     *
     * @category constructors
     * @since 2.0.0
     */
    var none$1 = none$2;
    /**
     * Constructs a `Some`. Represents an optional value that exists.
     *
     * @category constructors
     * @since 2.0.0
     */
    var some$7 = some$a;
    function fromPredicate$a(predicate) {
        return function (a) { return (predicate(a) ? some$7(a) : none$1); };
    }
    /**
     * Returns the `Left` value of an `Either` if possible.
     *
     * @example
     * import { getLeft, none, some } from 'fp-ts/Option'
     * import { right, left } from 'fp-ts/Either'
     *
     * assert.deepStrictEqual(getLeft(right(1)), none)
     * assert.deepStrictEqual(getLeft(left('a')), some('a'))
     *
     * @category constructors
     * @since 2.0.0
     */
    var getLeft$1 = function (ma) { return (ma._tag === 'Right' ? none$1 : some$7(ma.left)); };
    /**
     * Returns the `Right` value of an `Either` if possible.
     *
     * @example
     * import { getRight, none, some } from 'fp-ts/Option'
     * import { right, left } from 'fp-ts/Either'
     *
     * assert.deepStrictEqual(getRight(right(1)), some(1))
     * assert.deepStrictEqual(getRight(left('a')), none)
     *
     * @category constructors
     * @since 2.0.0
     */
    var getRight$1 = function (ma) { return (ma._tag === 'Left' ? none$1 : some$7(ma.right)); };
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _map$q = function (fa, f) { return pipe$1(fa, map$y(f)); };
    var _ap$a = function (fab, fa) { return pipe$1(fab, ap$k(fa)); };
    var _chain$e = function (ma, f) { return pipe$1(ma, chain$l(f)); };
    var _reduce$8 = function (fa, b, f) { return pipe$1(fa, reduce$d(b, f)); };
    var _foldMap$8 = function (M) {
        var foldMapM = foldMap$d(M);
        return function (fa, f) { return pipe$1(fa, foldMapM(f)); };
    };
    var _reduceRight$8 = function (fa, b, f) { return pipe$1(fa, reduceRight$d(b, f)); };
    var _traverse$8 = function (F) {
        var traverseF = traverse$9(F);
        return function (ta, f) { return pipe$1(ta, traverseF(f)); };
    };
    /* istanbul ignore next */
    var _alt$8 = function (fa, that) { return pipe$1(fa, alt$a(that)); };
    var _filter$5 = function (fa, predicate) { return pipe$1(fa, filter$8(predicate)); };
    /* istanbul ignore next */
    var _filterMap$5 = function (fa, f) { return pipe$1(fa, filterMap$8(f)); };
    /* istanbul ignore next */
    var _extend$6 = function (wa, f) { return pipe$1(wa, extend$6(f)); };
    /* istanbul ignore next */
    var _partition$5 = function (fa, predicate) {
        return pipe$1(fa, partition$8(predicate));
    };
    /* istanbul ignore next */
    var _partitionMap$5 = function (fa, f) { return pipe$1(fa, partitionMap$8(f)); };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$s = 'Option';
    /**
     * @category instances
     * @since 2.0.0
     */
    var getShow$b = function (S) { return ({
        show: function (ma) { return (isNone$1(ma) ? 'none' : "some(" + S.show(ma.value) + ")"); }
    }); };
    /**
     * @example
     * import { none, some, getEq } from 'fp-ts/Option'
     * import * as N from 'fp-ts/number'
     *
     * const E = getEq(N.Eq)
     * assert.strictEqual(E.equals(none, none), true)
     * assert.strictEqual(E.equals(none, some(1)), false)
     * assert.strictEqual(E.equals(some(1), none), false)
     * assert.strictEqual(E.equals(some(1), some(2)), false)
     * assert.strictEqual(E.equals(some(1), some(1)), true)
     *
     * @category instances
     * @since 2.0.0
     */
    var getEq$b = function (E) { return ({
        equals: function (x, y) { return x === y || (isNone$1(x) ? isNone$1(y) : isNone$1(y) ? false : E.equals(x.value, y.value)); }
    }); };
    /**
     * The `Ord` instance allows `Option` values to be compared with
     * `compare`, whenever there is an `Ord` instance for
     * the type the `Option` contains.
     *
     * `None` is considered to be less than any `Some` value.
     *
     *
     * @example
     * import { none, some, getOrd } from 'fp-ts/Option'
     * import * as N from 'fp-ts/number'
     *
     * const O = getOrd(N.Ord)
     * assert.strictEqual(O.compare(none, none), 0)
     * assert.strictEqual(O.compare(none, some(1)), -1)
     * assert.strictEqual(O.compare(some(1), none), 1)
     * assert.strictEqual(O.compare(some(1), some(2)), -1)
     * assert.strictEqual(O.compare(some(1), some(1)), 0)
     *
     * @category instances
     * @since 2.0.0
     */
    var getOrd$1 = function (O) { return ({
        equals: getEq$b(O).equals,
        compare: function (x, y) { return (x === y ? 0 : isSome$1(x) ? (isSome$1(y) ? O.compare(x.value, y.value) : 1) : -1); }
    }); };
    /**
     * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are
     * concatenated using the provided `Semigroup`
     *
     * | x       | y       | concat(x, y)       |
     * | ------- | ------- | ------------------ |
     * | none    | none    | none               |
     * | some(a) | none    | some(a)            |
     * | none    | some(b) | some(b)            |
     * | some(a) | some(b) | some(concat(a, b)) |
     *
     * @example
     * import { getMonoid, some, none } from 'fp-ts/Option'
     * import { SemigroupSum } from 'fp-ts/number'
     *
     * const M = getMonoid(SemigroupSum)
     * assert.deepStrictEqual(M.concat(none, none), none)
     * assert.deepStrictEqual(M.concat(some(1), none), some(1))
     * assert.deepStrictEqual(M.concat(none, some(1)), some(1))
     * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))
     *
     * @category instances
     * @since 2.0.0
     */
    var getMonoid$a = function (S) { return ({
        concat: function (x, y) { return (isNone$1(x) ? y : isNone$1(y) ? x : some$7(S.concat(x.value, y.value))); },
        empty: none$1
    }); };
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var map$y = function (f) { return function (fa) {
        return isNone$1(fa) ? none$1 : some$7(f(fa.value));
    }; };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$r = {
        URI: URI$s,
        map: _map$q
    };
    /**
     * @category instance operations
     * @since 2.7.0
     */
    var of$k = some$7;
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$h = {
        URI: URI$s,
        of: of$k
    };
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var ap$k = function (fa) { return function (fab) {
        return isNone$1(fab) ? none$1 : isNone$1(fa) ? none$1 : some$7(fab.value(fa.value));
    }; };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Apply$9 = {
        URI: URI$s,
        map: _map$q,
        ap: _ap$a
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Applicative$a = {
        URI: URI$s,
        map: _map$q,
        ap: _ap$a,
        of: of$k
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category instance operations
     * @since 2.0.0
     */
    var chain$l = function (f) { return function (ma) {
        return isNone$1(ma) ? none$1 : f(ma.value);
    }; };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$g = {
        URI: URI$s,
        map: _map$q,
        ap: _ap$a,
        chain: _chain$e
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Monad$f = {
        URI: URI$s,
        map: _map$q,
        ap: _ap$a,
        of: of$k,
        chain: _chain$e
    };
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var reduce$d = function (b, f) { return function (fa) {
        return isNone$1(fa) ? b : f(b, fa.value);
    }; };
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var foldMap$d = function (M) { return function (f) { return function (fa) {
        return isNone$1(fa) ? M.empty : f(fa.value);
    }; }; };
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var reduceRight$d = function (b, f) { return function (fa) {
        return isNone$1(fa) ? b : f(fa.value, b);
    }; };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Foldable$9 = {
        URI: URI$s,
        reduce: _reduce$8,
        foldMap: _foldMap$8,
        reduceRight: _reduceRight$8
    };
    /**
     * Less strict version of [`alt`](#alt).
     *
     * @category instance operations
     * @since 2.9.0
     */
    var altW$8 = function (that) { return function (fa) {
        return isNone$1(fa) ? that() : fa;
    }; };
    /**
     * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
     * types of kind `* -> *`.
     *
     * In case of `Option` returns the left-most non-`None` value.
     *
     * @example
     * import * as O from 'fp-ts/Option'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(
     *   pipe(
     *     O.some('a'),
     *     O.alt(() => O.some('b'))
     *   ),
     *   O.some('a')
     * )
     * assert.deepStrictEqual(
     *   pipe(
     *     O.none,
     *     O.alt(() => O.some('b'))
     *   ),
     *   O.some('b')
     * )
     *
     * @category instance operations
     * @since 2.0.0
     */
    var alt$a = altW$8;
    /**
     * @category instances
     * @since 2.7.0
     */
    var Alt$8 = {
        URI: URI$s,
        map: _map$q,
        alt: _alt$8
    };
    /**
     * @category instance operations
     * @since 2.7.0
     */
    var zero$3 = function () { return none$1; };
    /**
     * @category instances
     * @since 2.11.0
     */
    var Zero$2 = {
        URI: URI$s,
        zero: zero$3
    };
    /**
     * @category constructors
     * @since 2.11.0
     */
    var guard$2 = 
    /*#__PURE__*/
    guard$5(Zero$2, Pointed$h);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Alternative$1 = {
        URI: URI$s,
        map: _map$q,
        ap: _ap$a,
        of: of$k,
        alt: _alt$8,
        zero: zero$3
    };
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var extend$6 = function (f) { return function (wa) {
        return isNone$1(wa) ? none$1 : some$7(f(wa));
    }; };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Extend$2 = {
        URI: URI$s,
        map: _map$q,
        extend: _extend$6
    };
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var compact$8 = 
    /*#__PURE__*/
    chain$l(identity$1);
    var defaultSeparated = 
    /*#__PURE__*/
    separated(none$1, none$1);
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var separate$8 = function (ma) {
        return isNone$1(ma) ? defaultSeparated : separated(getLeft$1(ma.value), getRight$1(ma.value));
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Compactable$6 = {
        URI: URI$s,
        compact: compact$8,
        separate: separate$8
    };
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var filter$8 = function (predicate) { return function (fa) { return (isNone$1(fa) ? none$1 : predicate(fa.value) ? fa : none$1); }; };
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var filterMap$8 = function (f) { return function (fa) {
        return isNone$1(fa) ? none$1 : f(fa.value);
    }; };
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var partition$8 = function (predicate) { return function (fa) { return separated(_filter$5(fa, not$1(predicate)), _filter$5(fa, predicate)); }; };
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var partitionMap$8 = function (f) { return flow(map$y(f), separate$8); };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Filterable$6 = {
        URI: URI$s,
        map: _map$q,
        compact: compact$8,
        separate: separate$8,
        filter: _filter$5,
        filterMap: _filterMap$5,
        partition: _partition$5,
        partitionMap: _partitionMap$5
    };
    /**
     * @category instance operations
     * @since 2.6.3
     */
    var traverse$9 = function (F) { return function (f) { return function (ta) { return (isNone$1(ta) ? F.of(none$1) : F.map(f(ta.value), some$7)); }; }; };
    /**
     * @category instance operations
     * @since 2.6.3
     */
    var sequence$9 = function (F) { return function (ta) { return (isNone$1(ta) ? F.of(none$1) : F.map(ta.value, some$7)); }; };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Traversable$9 = {
        URI: URI$s,
        map: _map$q,
        reduce: _reduce$8,
        foldMap: _foldMap$8,
        reduceRight: _reduceRight$8,
        traverse: _traverse$8,
        sequence: sequence$9
    };
    var _wither$2 = 
    /*#__PURE__*/
    witherDefault$1(Traversable$9, Compactable$6);
    var _wilt$2 = 
    /*#__PURE__*/
    wiltDefault$1(Traversable$9, Compactable$6);
    /**
     * @category instance operations
     * @since 2.6.5
     */
    var wither$2 = function (F) {
        var _witherF = _wither$2(F);
        return function (f) { return function (fa) { return _witherF(fa, f); }; };
    };
    /**
     * @category instance operations
     * @since 2.6.5
     */
    var wilt$2 = function (F) {
        var _wiltF = _wilt$2(F);
        return function (f) { return function (fa) { return _wiltF(fa, f); }; };
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Witherable$3 = {
        URI: URI$s,
        map: _map$q,
        reduce: _reduce$8,
        foldMap: _foldMap$8,
        reduceRight: _reduceRight$8,
        traverse: _traverse$8,
        sequence: sequence$9,
        compact: compact$8,
        separate: separate$8,
        filter: _filter$5,
        filterMap: _filterMap$5,
        partition: _partition$5,
        partitionMap: _partitionMap$5,
        wither: _wither$2,
        wilt: _wilt$2
    };
    /**
     * @category instance operations
     * @since 2.7.0
     */
    var throwError$6 = function () { return none$1; };
    /**
     * @category instances
     * @since 2.7.0
     */
    var MonadThrow$7 = {
        URI: URI$s,
        map: _map$q,
        ap: _ap$a,
        of: of$k,
        chain: _chain$e,
        throwError: throwError$6
    };
    /**
     * Transforms an `Either` to an `Option` discarding the error.
     *
     * Alias of [getRight](#getright)
     *
     * @category natural transformations
     * @since 2.0.0
     */
    var fromEither$8 = getRight$1;
    /**
     * @category instances
     * @since 2.11.0
     */
    var FromEither$a = {
        URI: URI$s,
        fromEither: fromEither$8
    };
    // -------------------------------------------------------------------------------------
    // refinements
    // -------------------------------------------------------------------------------------
    /**
     * Returns `true` if the option is an instance of `Some`, `false` otherwise.
     *
     * @example
     * import { some, none, isSome } from 'fp-ts/Option'
     *
     * assert.strictEqual(isSome(some(1)), true)
     * assert.strictEqual(isSome(none), false)
     *
     * @category refinements
     * @since 2.0.0
     */
    var isSome$1 = isSome$2;
    /**
     * Returns `true` if the option is `None`, `false` otherwise.
     *
     * @example
     * import { some, none, isNone } from 'fp-ts/Option'
     *
     * assert.strictEqual(isNone(some(1)), false)
     * assert.strictEqual(isNone(none), true)
     *
     * @category refinements
     * @since 2.0.0
     */
    var isNone$1 = function (fa) { return fa._tag === 'None'; };
    // -------------------------------------------------------------------------------------
    // destructors
    // -------------------------------------------------------------------------------------
    /**
     * Less strict version of [`match`](#match).
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchW$8 = function (onNone, onSome) { return function (ma) {
        return isNone$1(ma) ? onNone() : onSome(ma.value);
    }; };
    /**
     * Alias of [`matchW`](#matchw).
     *
     * @category destructors
     * @since 2.10.0
     */
    var foldW$8 = matchW$8;
    /**
     * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is
     * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.
     *
     * @example
     * import { some, none, match } from 'fp-ts/Option'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.strictEqual(
     *   pipe(
     *     some(1),
     *     match(() => 'a none', a => `a some containing ${a}`)
     *   ),
     *   'a some containing 1'
     * )
     *
     * assert.strictEqual(
     *   pipe(
     *     none,
     *     match(() => 'a none', a => `a some containing ${a}`)
     *   ),
     *   'a none'
     * )
     *
     * @category destructors
     * @since 2.10.0
     */
    var match$c = matchW$8;
    /**
     * Alias of [`match`](#match).
     *
     * @category destructors
     * @since 2.0.0
     */
    var fold$a = match$c;
    /**
     * Less strict version of [`getOrElse`](#getorelse).
     *
     * @category destructors
     * @since 2.6.0
     */
    var getOrElseW$6 = function (onNone) { return function (ma) { return (isNone$1(ma) ? onNone() : ma.value); }; };
    /**
     * Extracts the value out of the structure, if it exists. Otherwise returns the given default value
     *
     * @example
     * import { some, none, getOrElse } from 'fp-ts/Option'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.strictEqual(
     *   pipe(
     *     some(1),
     *     getOrElse(() => 0)
     *   ),
     *   1
     * )
     * assert.strictEqual(
     *   pipe(
     *     none,
     *     getOrElse(() => 0)
     *   ),
     *   0
     * )
     *
     * @category destructors
     * @since 2.0.0
     */
    var getOrElse$8 = getOrElseW$6;
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$r = 
    /*#__PURE__*/
    flap$x(Functor$r);
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apFirst$f = 
    /*#__PURE__*/
    apFirst$k(Apply$9);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apSecond$f = 
    /*#__PURE__*/
    apSecond$k(Apply$9);
    /**
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var flatten$e = compact$8;
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var chainFirst$f = 
    /*#__PURE__*/
    chainFirst$k(Chain$g);
    /**
     * Derivable from `Extend`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var duplicate$6 = 
    /*#__PURE__*/
    extend$6(identity$1);
    /**
     * @category combinators
     * @since 2.11.0
     */
    var fromEitherK$7 = 
    /*#__PURE__*/
    fromEitherK$a(FromEither$a);
    /**
     * @category combinators
     * @since 2.11.0
     */
    var chainEitherK$6 = 
    /*#__PURE__*/
    chainEitherK$7(FromEither$a, Chain$g);
    // -------------------------------------------------------------------------------------
    // interop
    // -------------------------------------------------------------------------------------
    /**
     * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise
     * returns the value wrapped in a `Some`.
     *
     * @example
     * import { none, some, fromNullable } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(fromNullable(undefined), none)
     * assert.deepStrictEqual(fromNullable(null), none)
     * assert.deepStrictEqual(fromNullable(1), some(1))
     *
     * @category interop
     * @since 2.0.0
     */
    var fromNullable$3 = function (a) { return (a == null ? none$1 : some$7(a)); };
    /**
     * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a
     * `Some`.
     *
     * See also [`tryCatchK`](#trycatchk).
     *
     * @example
     * import { none, some, tryCatch } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(
     *   tryCatch(() => {
     *     throw new Error()
     *   }),
     *   none
     * )
     * assert.deepStrictEqual(tryCatch(() => 1), some(1))
     *
     * @category interop
     * @since 2.0.0
     */
    var tryCatch$4 = function (f) {
        try {
            return some$7(f());
        }
        catch (e) {
            return none$1;
        }
    };
    /**
     * Converts a function that may throw to one returning a `Option`.
     *
     * @category interop
     * @since 2.10.0
     */
    var tryCatchK$4 = function (f) { return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return tryCatch$4(function () { return f.apply(void 0, a); });
    }; };
    /**
     * Returns a *smart constructor* from a function that returns a nullable value.
     *
     * @example
     * import { fromNullableK, none, some } from 'fp-ts/Option'
     *
     * const f = (s: string): number | undefined => {
     *   const n = parseFloat(s)
     *   return isNaN(n) ? undefined : n
     * }
     *
     * const g = fromNullableK(f)
     *
     * assert.deepStrictEqual(g('1'), some(1))
     * assert.deepStrictEqual(g('a'), none)
     *
     * @category interop
     * @since 2.9.0
     */
    var fromNullableK$3 = function (f) { return flow(f, fromNullable$3); };
    /**
     * This is `chain` + `fromNullable`, useful when working with optional values.
     *
     * @example
     * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'
     * import { pipe } from 'fp-ts/function'
     *
     * interface Employee {
     *   readonly company?: {
     *     readonly address?: {
     *       readonly street?: {
     *         readonly name?: string
     *       }
     *     }
     *   }
     * }
     *
     * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }
     *
     * assert.deepStrictEqual(
     *   pipe(
     *     fromNullable(employee1.company),
     *     chainNullableK(company => company.address),
     *     chainNullableK(address => address.street),
     *     chainNullableK(street => street.name)
     *   ),
     *   some('high street')
     * )
     *
     * const employee2: Employee = { company: { address: { street: {} } } }
     *
     * assert.deepStrictEqual(
     *   pipe(
     *     fromNullable(employee2.company),
     *     chainNullableK(company => company.address),
     *     chainNullableK(address => address.street),
     *     chainNullableK(street => street.name)
     *   ),
     *   none
     * )
     *
     * @category interop
     * @since 2.9.0
     */
    var chainNullableK$3 = function (f) { return function (ma) {
        return isNone$1(ma) ? none$1 : fromNullable$3(f(ma.value));
    }; };
    /**
     * Extracts the value out of the structure, if it exists. Otherwise returns `null`.
     *
     * @example
     * import { some, none, toNullable } from 'fp-ts/Option'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.strictEqual(
     *   pipe(
     *     some(1),
     *     toNullable
     *   ),
     *   1
     * )
     * assert.strictEqual(
     *   pipe(
     *     none,
     *     toNullable
     *   ),
     *   null
     * )
     *
     * @category interop
     * @since 2.0.0
     */
    var toNullable = 
    /*#__PURE__*/
    match$c(constNull, identity$1);
    /**
     * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.
     *
     * @example
     * import { some, none, toUndefined } from 'fp-ts/Option'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.strictEqual(
     *   pipe(
     *     some(1),
     *     toUndefined
     *   ),
     *   1
     * )
     * assert.strictEqual(
     *   pipe(
     *     none,
     *     toUndefined
     *   ),
     *   undefined
     * )
     *
     * @category interop
     * @since 2.0.0
     */
    var toUndefined = 
    /*#__PURE__*/
    match$c(constUndefined, identity$1);
    function elem$9(E) {
        return function (a, ma) {
            if (ma === undefined) {
                var elemE_1 = elem$9(E);
                return function (ma) { return elemE_1(a, ma); };
            }
            return isNone$1(ma) ? false : E.equals(a, ma.value);
        };
    }
    /**
     * Returns `true` if the predicate is satisfied by the wrapped value
     *
     * @example
     * import { some, none, exists } from 'fp-ts/Option'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.strictEqual(
     *   pipe(
     *     some(1),
     *     exists(n => n > 0)
     *   ),
     *   true
     * )
     * assert.strictEqual(
     *   pipe(
     *     some(1),
     *     exists(n => n > 1)
     *   ),
     *   false
     * )
     * assert.strictEqual(
     *   pipe(
     *     none,
     *     exists(n => n > 0)
     *   ),
     *   false
     * )
     *
     * @since 2.0.0
     */
    var exists$3 = function (predicate) { return function (ma) {
        return isNone$1(ma) ? false : predicate(ma.value);
    }; };
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.9.0
     */
    var Do$c = 
    /*#__PURE__*/
    of$k(emptyRecord);
    /**
     * @since 2.8.0
     */
    var bindTo$f = 
    /*#__PURE__*/
    bindTo$k(Functor$r);
    /**
     * @since 2.8.0
     */
    var bind$h = 
    /*#__PURE__*/
    bind$m(Chain$g);
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var apS$f = 
    /*#__PURE__*/
    apS$k(Apply$9);
    // -------------------------------------------------------------------------------------
    // sequence T
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var ApT$c = 
    /*#__PURE__*/
    of$k(emptyReadonlyArray);
    // -------------------------------------------------------------------------------------
    // array utils
    // -------------------------------------------------------------------------------------
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndex$e = function (f) { return function (as) {
        var o = f(0, head$5(as));
        if (isNone$1(o)) {
            return none$1;
        }
        var out = [o.value];
        for (var i = 1; i < as.length; i++) {
            var o_1 = f(i, as[i]);
            if (isNone$1(o_1)) {
                return none$1;
            }
            out.push(o_1.value);
        }
        return some$7(out);
    }; };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndex$e = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndex$e(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT$c); };
    };
    /**
     * @since 2.9.0
     */
    var traverseArrayWithIndex$c = traverseReadonlyArrayWithIndex$e;
    /**
     * @since 2.9.0
     */
    var traverseArray$c = function (f) {
        return traverseReadonlyArrayWithIndex$e(function (_, a) { return f(a); });
    };
    /**
     * @since 2.9.0
     */
    var sequenceArray$c = 
    /*#__PURE__*/
    traverseArray$c(identity$1);
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use `Refinement` module instead.
     *
     * @since 2.0.0
     * @deprecated
     */
    function getRefinement(getOption) {
        return function (a) { return isSome$1(getOption(a)); };
    }
    /**
     * Use [`chainNullableK`](#chainnullablek) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    var mapNullable = chainNullableK$3;
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var option = {
        URI: URI$s,
        map: _map$q,
        of: of$k,
        ap: _ap$a,
        chain: _chain$e,
        reduce: _reduce$8,
        foldMap: _foldMap$8,
        reduceRight: _reduceRight$8,
        traverse: _traverse$8,
        sequence: sequence$9,
        zero: zero$3,
        alt: _alt$8,
        extend: _extend$6,
        compact: compact$8,
        separate: separate$8,
        filter: _filter$5,
        filterMap: _filterMap$5,
        partition: _partition$5,
        partitionMap: _partitionMap$5,
        wither: _wither$2,
        wilt: _wilt$2,
        throwError: throwError$6
    };
    /**
     * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getApplySemigroup$6 = 
    /*#__PURE__*/
    getApplySemigroup$7(Apply$9);
    /**
     * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getApplyMonoid$5 = 
    /*#__PURE__*/
    getApplicativeMonoid$1(Applicative$a);
    /**
     * Use
     *
     * ```ts
     * import { first } from 'fp-ts/Semigroup'
     * import { getMonoid } from 'fp-ts/Option'
     *
     * getMonoid(first())
     * ```
     *
     * instead.
     *
     * Monoid returning the left-most non-`None` value
     *
     * | x       | y       | concat(x, y) |
     * | ------- | ------- | ------------ |
     * | none    | none    | none         |
     * | some(a) | none    | some(a)      |
     * | none    | some(b) | some(b)      |
     * | some(a) | some(b) | some(a)      |
     *
     * @example
     * import { getFirstMonoid, some, none } from 'fp-ts/Option'
     *
     * const M = getFirstMonoid<number>()
     * assert.deepStrictEqual(M.concat(none, none), none)
     * assert.deepStrictEqual(M.concat(some(1), none), some(1))
     * assert.deepStrictEqual(M.concat(none, some(2)), some(2))
     * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getFirstMonoid = function () { return getMonoid$a(first$1()); };
    /**
     * Use
     *
     * ```ts
     * import { last } from 'fp-ts/Semigroup'
     * import { getMonoid } from 'fp-ts/Option'
     *
     * getMonoid(last())
     * ```
     *
     * instead.
     *
     * Monoid returning the right-most non-`None` value
     *
     * | x       | y       | concat(x, y) |
     * | ------- | ------- | ------------ |
     * | none    | none    | none         |
     * | some(a) | none    | some(a)      |
     * | none    | some(b) | some(b)      |
     * | some(a) | some(b) | some(b)      |
     *
     * @example
     * import { getLastMonoid, some, none } from 'fp-ts/Option'
     *
     * const M = getLastMonoid<number>()
     * assert.deepStrictEqual(M.concat(none, none), none)
     * assert.deepStrictEqual(M.concat(some(1), none), some(1))
     * assert.deepStrictEqual(M.concat(none, some(2)), some(2))
     * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getLastMonoid = function () { return getMonoid$a(last$4()); };

    var Option$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        none: none$1,
        some: some$7,
        fromPredicate: fromPredicate$a,
        getLeft: getLeft$1,
        getRight: getRight$1,
        URI: URI$s,
        getShow: getShow$b,
        getEq: getEq$b,
        getOrd: getOrd$1,
        getMonoid: getMonoid$a,
        map: map$y,
        Functor: Functor$r,
        of: of$k,
        Pointed: Pointed$h,
        ap: ap$k,
        Apply: Apply$9,
        Applicative: Applicative$a,
        chain: chain$l,
        Chain: Chain$g,
        Monad: Monad$f,
        reduce: reduce$d,
        foldMap: foldMap$d,
        reduceRight: reduceRight$d,
        Foldable: Foldable$9,
        altW: altW$8,
        alt: alt$a,
        Alt: Alt$8,
        zero: zero$3,
        Zero: Zero$2,
        guard: guard$2,
        Alternative: Alternative$1,
        extend: extend$6,
        Extend: Extend$2,
        compact: compact$8,
        separate: separate$8,
        Compactable: Compactable$6,
        filter: filter$8,
        filterMap: filterMap$8,
        partition: partition$8,
        partitionMap: partitionMap$8,
        Filterable: Filterable$6,
        traverse: traverse$9,
        sequence: sequence$9,
        Traversable: Traversable$9,
        wither: wither$2,
        wilt: wilt$2,
        Witherable: Witherable$3,
        throwError: throwError$6,
        MonadThrow: MonadThrow$7,
        fromEither: fromEither$8,
        FromEither: FromEither$a,
        isSome: isSome$1,
        isNone: isNone$1,
        matchW: matchW$8,
        foldW: foldW$8,
        match: match$c,
        fold: fold$a,
        getOrElseW: getOrElseW$6,
        getOrElse: getOrElse$8,
        flap: flap$r,
        apFirst: apFirst$f,
        apSecond: apSecond$f,
        flatten: flatten$e,
        chainFirst: chainFirst$f,
        duplicate: duplicate$6,
        fromEitherK: fromEitherK$7,
        chainEitherK: chainEitherK$6,
        fromNullable: fromNullable$3,
        tryCatch: tryCatch$4,
        tryCatchK: tryCatchK$4,
        fromNullableK: fromNullableK$3,
        chainNullableK: chainNullableK$3,
        toNullable: toNullable,
        toUndefined: toUndefined,
        elem: elem$9,
        exists: exists$3,
        Do: Do$c,
        bindTo: bindTo$f,
        bind: bind$h,
        apS: apS$f,
        ApT: ApT$c,
        traverseReadonlyNonEmptyArrayWithIndex: traverseReadonlyNonEmptyArrayWithIndex$e,
        traverseReadonlyArrayWithIndex: traverseReadonlyArrayWithIndex$e,
        traverseArrayWithIndex: traverseArrayWithIndex$c,
        traverseArray: traverseArray$c,
        sequenceArray: sequenceArray$c,
        getRefinement: getRefinement,
        mapNullable: mapNullable,
        option: option,
        getApplySemigroup: getApplySemigroup$6,
        getApplyMonoid: getApplyMonoid$5,
        getFirstMonoid: getFirstMonoid,
        getLastMonoid: getLastMonoid
    });

    function compact$7(F, G) {
        return function (fga) { return F.map(fga, G.compact); };
    }
    function separate$7(F, C, G) {
        var _compact = compact$7(F, C);
        var _map = map$E(F, G);
        return function (fge) { return separated(_compact(pipe$1(fge, _map(getLeft$1))), _compact(pipe$1(fge, _map(getRight$1)))); };
    }
    /** @deprecated */
    function getCompactableComposition(F, G) {
        var map = getFunctorComposition$1(F, G).map;
        return {
            map: map,
            compact: compact$7(F, G),
            separate: separate$7(F, G, G)
        };
    }

    var Compactable$5 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        compact: compact$7,
        separate: separate$7,
        getCompactableComposition: getCompactableComposition
    });

    /**
     * @since 2.0.0
     */
    var log = function (a) { return function () { return console.log(a); }; }; // tslint:disable-line:no-console
    /**
     * @since 2.0.0
     */
    var warn = function (a) { return function () { return console.warn(a); }; }; // tslint:disable-line:no-console
    /**
     * @since 2.0.0
     */
    var error = function (a) { return function () { return console.error(a); }; }; // tslint:disable-line:no-console
    /**
     * @since 2.0.0
     */
    var info = function (a) { return function () { return console.info(a); }; }; // tslint:disable-line:no-console

    var Console = /*#__PURE__*/Object.freeze({
        __proto__: null,
        log: log,
        warn: warn,
        error: error,
        info: info
    });

    /**
     * @category constructors
     * @since 2.0.0
     */
    var make$1 = unsafeCoerce;
    /**
     * @category instances
     * @since 2.0.0
     */
    function getShow$a(S) {
        return {
            show: function (c) { return "make(" + S.show(c) + ")"; }
        };
    }
    /**
     * @category instances
     * @since 2.0.0
     */
    var getEq$a = identity$1;
    /**
     * @category instances
     * @since 2.6.0
     */
    var getOrd = identity$1;
    /**
     * @category instances
     * @since 2.6.0
     */
    var getBounded = identity$1;
    /**
     * @category instances
     * @since 2.6.0
     */
    var getSemigroup$c = identity$1;
    /**
     * @category instances
     * @since 2.6.0
     */
    var getMonoid$9 = identity$1;
    /**
     * @category instances
     * @since 2.6.0
     */
    var getSemiring = identity$1;
    /**
     * @category instances
     * @since 2.6.0
     */
    var getRing = identity$1;
    /**
     * @category instances
     * @since 2.6.0
     */
    var getHeytingAlgebra = identity$1;
    /**
     * @category instances
     * @since 2.6.0
     */
    var getBooleanAlgebra = identity$1;
    /**
     * @category instances
     * @since 2.0.0
     */
    function getApply$5(S) {
        return {
            URI: URI$r,
            _E: undefined,
            map: _map$p,
            ap: function (fab, fa) { return make$1(S.concat(fab, fa)); }
        };
    }
    /**
     * @category instances
     * @since 2.0.0
     */
    function getApplicative$5(M) {
        var A = getApply$5(M);
        return {
            URI: URI$r,
            _E: undefined,
            map: A.map,
            ap: A.ap,
            of: function () { return make$1(M.empty); }
        };
    }
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _contramap = function (fa, f) { return pipe$1(fa, contramap()); };
    /* istanbul ignore next */
    var _map$p = function (fa, f) { return pipe$1(fa, map$x(f)); };
    /* istanbul ignore next */
    var _bimap$a = function (fa, f, g) { return pipe$1(fa, bimap$c(f)); };
    /* istanbul ignore next */
    var _mapLeft$a = function (fa, f) { return pipe$1(fa, mapLeft$c(f)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * @category Contravariant
     * @since 2.0.0
     */
    var contramap = function () { return unsafeCoerce; };
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$x = function () { return unsafeCoerce; };
    /**
     * Map a pair of functions over the two type arguments of the bifunctor.
     *
     * @category Bifunctor
     * @since 2.6.2
     */
    var bimap$c = function (f) { return function (fa) {
        return make$1(f(fa));
    }; };
    /**
     * Map a function over the first type argument of a bifunctor.
     *
     * @category Bifunctor
     * @since 2.6.2
     */
    var mapLeft$c = function (f) { return function (fa) { return make$1(f(fa)); }; };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$r = 'Const';
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$q = {
        URI: URI$r,
        map: _map$p
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$q = 
    /*#__PURE__*/
    flap$x(Functor$q);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Contravariant$1 = {
        URI: URI$r,
        contramap: _contramap
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Bifunctor$a = {
        URI: URI$r,
        bimap: _bimap$a,
        mapLeft: _mapLeft$a
    };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var const_ = {
        URI: URI$r,
        map: _map$p,
        contramap: _contramap,
        bimap: _bimap$a,
        mapLeft: _mapLeft$a
    };

    var Const = /*#__PURE__*/Object.freeze({
        __proto__: null,
        make: make$1,
        getShow: getShow$a,
        getEq: getEq$a,
        getOrd: getOrd,
        getBounded: getBounded,
        getSemigroup: getSemigroup$c,
        getMonoid: getMonoid$9,
        getSemiring: getSemiring,
        getRing: getRing,
        getHeytingAlgebra: getHeytingAlgebra,
        getBooleanAlgebra: getBooleanAlgebra,
        getApply: getApply$5,
        getApplicative: getApplicative$5,
        contramap: contramap,
        map: map$x,
        bimap: bimap$c,
        mapLeft: mapLeft$c,
        URI: URI$r,
        Functor: Functor$q,
        flap: flap$q,
        Contravariant: Contravariant$1,
        Bifunctor: Bifunctor$a,
        const_: const_
    });

    var Contravariant = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.10.0
     */
    var Eq$3 = {
        equals: function (first, second) { return first.valueOf() === second.valueOf(); }
    };
    /**
     * @category instances
     * @since 2.6.0
     */
    var eqDate = {
        equals: function (x, y) { return x.getDate() === y.getDate(); }
    };
    /**
     * @category instances
     * @since 2.6.0
     */
    var eqMonth = {
        equals: function (x, y) { return x.getMonth() === y.getMonth(); }
    };
    /**
     * @category instances
     * @since 2.6.0
     */
    var eqYear = {
        equals: function (x, y) { return x.getFullYear() === y.getFullYear(); }
    };
    /**
     * @example
     * import { Ord } from 'fp-ts/Date'
     *
     * assert.deepStrictEqual(Ord.compare(new Date(1, 1, 2020), new Date(1, 1, 2021)), -1)
     *
     * @category instances
     * @since 2.10.0
     */
    var Ord$2 = 
    /*#__PURE__*/
    pipe$1(Ord$4, 
    /*#__PURE__*/
    contramap$2(function (date) { return date.valueOf(); }));
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * Returns the current `Date`
     *
     * @category constructors
     * @since 2.0.0
     */
    var create = function () { return new Date(); };
    /**
     * Returns the number of milliseconds elapsed since January 1, 1970, 00:00:00 UTC
     *
     * @since 2.0.0
     */
    var now = function () { return new Date().getTime(); };

    var Date$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Eq: Eq$3,
        eqDate: eqDate,
        eqMonth: eqMonth,
        eqYear: eqYear,
        Ord: Ord$2,
        create: create,
        now: now
    });

    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this
     * structure.
     *
     * @category constructors
     * @since 2.0.0
     */
    var left$b = left$d;
    /**
     * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias
     * of this structure.
     *
     * @category constructors
     * @since 2.0.0
     */
    var right$b = right$d;
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _map$o = function (fa, f) { return pipe$1(fa, map$w(f)); };
    var _ap$9 = function (fab, fa) { return pipe$1(fab, ap$j(fa)); };
    /* istanbul ignore next */
    var _chain$d = function (ma, f) { return pipe$1(ma, chain$k(f)); };
    /* istanbul ignore next */
    var _reduce$7 = function (fa, b, f) { return pipe$1(fa, reduce$c(b, f)); };
    /* istanbul ignore next */
    var _foldMap$7 = function (M) { return function (fa, f) {
        var foldMapM = foldMap$c(M);
        return pipe$1(fa, foldMapM(f));
    }; };
    /* istanbul ignore next */
    var _reduceRight$7 = function (fa, b, f) { return pipe$1(fa, reduceRight$c(b, f)); };
    var _traverse$7 = function (F) {
        var traverseF = traverse$8(F);
        return function (ta, f) { return pipe$1(ta, traverseF(f)); };
    };
    var _bimap$9 = function (fa, f, g) { return pipe$1(fa, bimap$b(f, g)); };
    var _mapLeft$9 = function (fa, f) { return pipe$1(fa, mapLeft$b(f)); };
    /* istanbul ignore next */
    var _alt$7 = function (fa, that) { return pipe$1(fa, alt$9(that)); };
    /* istanbul ignore next */
    var _extend$5 = function (wa, f) { return pipe$1(wa, extend$5(f)); };
    var _chainRec$2 = function (a, f) {
        return tailRec(f(a), function (e) {
            return isLeft$2(e) ? right$b(left$b(e.left)) : isLeft$2(e.right) ? left$b(f(e.right.left)) : right$b(right$b(e.right.right));
        });
    };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$q = 'Either';
    /**
     * @category instances
     * @since 2.0.0
     */
    var getShow$9 = function (SE, SA) { return ({
        show: function (ma) { return (isLeft$2(ma) ? "left(" + SE.show(ma.left) + ")" : "right(" + SA.show(ma.right) + ")"); }
    }); };
    /**
     * @category instances
     * @since 2.0.0
     */
    var getEq$9 = function (EL, EA) { return ({
        equals: function (x, y) {
            return x === y || (isLeft$2(x) ? isLeft$2(y) && EL.equals(x.left, y.left) : isRight$2(y) && EA.equals(x.right, y.right));
        }
    }); };
    /**
     * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are
     * concatenated using the provided `Semigroup`
     *
     * @example
     * import { getSemigroup, left, right } from 'fp-ts/Either'
     * import { SemigroupSum } from 'fp-ts/number'
     *
     * const S = getSemigroup<string, number>(SemigroupSum)
     * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))
     * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))
     * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))
     * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))
     *
     * @category instances
     * @since 2.0.0
     */
    var getSemigroup$b = function (S) { return ({
        concat: function (x, y) { return (isLeft$2(y) ? x : isLeft$2(x) ? y : right$b(S.concat(x.right, y.right))); }
    }); };
    /**
     * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.
     *
     * @category instances
     * @since 2.10.0
     */
    var getCompactable$4 = function (M) {
        var empty = left$b(M.empty);
        return {
            URI: URI$q,
            _E: undefined,
            compact: function (ma) { return (isLeft$2(ma) ? ma : ma.right._tag === 'None' ? empty : right$b(ma.right.value)); },
            separate: function (ma) {
                return isLeft$2(ma)
                    ? separated(ma, ma)
                    : isLeft$2(ma.right)
                        ? separated(right$b(ma.right.left), empty)
                        : separated(empty, right$b(ma.right.right));
            }
        };
    };
    /**
     * Builds a `Filterable` instance for `Either` given `Monoid` for the left side
     *
     * @category instances
     * @since 2.10.0
     */
    var getFilterable$4 = function (M) {
        var empty = left$b(M.empty);
        var _a = getCompactable$4(M), compact = _a.compact, separate = _a.separate;
        var filter = function (ma, predicate) {
            return isLeft$2(ma) ? ma : predicate(ma.right) ? ma : empty;
        };
        var partition = function (ma, p) {
            return isLeft$2(ma)
                ? separated(ma, ma)
                : p(ma.right)
                    ? separated(empty, right$b(ma.right))
                    : separated(right$b(ma.right), empty);
        };
        return {
            URI: URI$q,
            _E: undefined,
            map: _map$o,
            compact: compact,
            separate: separate,
            filter: filter,
            filterMap: function (ma, f) {
                if (isLeft$2(ma)) {
                    return ma;
                }
                var ob = f(ma.right);
                return ob._tag === 'None' ? empty : right$b(ob.value);
            },
            partition: partition,
            partitionMap: function (ma, f) {
                if (isLeft$2(ma)) {
                    return separated(ma, ma);
                }
                var e = f(ma.right);
                return isLeft$2(e) ? separated(right$b(e.left), empty) : separated(empty, right$b(e.right));
            }
        };
    };
    /**
     * Builds `Witherable` instance for `Either` given `Monoid` for the left side
     *
     * @category instances
     * @since 2.0.0
     */
    var getWitherable$4 = function (M) {
        var F_ = getFilterable$4(M);
        var C = getCompactable$4(M);
        return {
            URI: URI$q,
            _E: undefined,
            map: _map$o,
            compact: F_.compact,
            separate: F_.separate,
            filter: F_.filter,
            filterMap: F_.filterMap,
            partition: F_.partition,
            partitionMap: F_.partitionMap,
            traverse: _traverse$7,
            sequence: sequence$8,
            reduce: _reduce$7,
            foldMap: _foldMap$7,
            reduceRight: _reduceRight$7,
            wither: witherDefault$1(Traversable$8, C),
            wilt: wiltDefault$1(Traversable$8, C)
        };
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var getApplicativeValidation = function (SE) { return ({
        URI: URI$q,
        _E: undefined,
        map: _map$o,
        ap: function (fab, fa) {
            return isLeft$2(fab)
                ? isLeft$2(fa)
                    ? left$b(SE.concat(fab.left, fa.left))
                    : fab
                : isLeft$2(fa)
                    ? fa
                    : right$b(fab.right(fa.right));
        },
        of: of$j
    }); };
    /**
     * @category instances
     * @since 2.7.0
     */
    var getAltValidation = function (SE) { return ({
        URI: URI$q,
        _E: undefined,
        map: _map$o,
        alt: function (me, that) {
            if (isRight$2(me)) {
                return me;
            }
            var ea = that();
            return isLeft$2(ea) ? left$b(SE.concat(me.left, ea.left)) : ea;
        }
    }); };
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var map$w = function (f) { return function (fa) {
        return isLeft$2(fa) ? fa : right$b(f(fa.right));
    }; };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$p = {
        URI: URI$q,
        map: _map$o
    };
    /**
     * @category instance operations
     * @since 2.7.0
     */
    var of$j = right$b;
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$g = {
        URI: URI$q,
        of: of$j
    };
    /**
     * Less strict version of [`ap`](#ap).
     *
     * @category instance operations
     * @since 2.8.0
     */
    var apW$7 = function (fa) { return function (fab) { return (isLeft$2(fab) ? fab : isLeft$2(fa) ? fa : right$b(fab.right(fa.right))); }; };
    /**
     * Apply a function to an argument under a type constructor.
     *
     * @category instance operations
     * @since 2.0.0
     */
    var ap$j = apW$7;
    /**
     * @category instances
     * @since 2.10.0
     */
    var Apply$8 = {
        URI: URI$q,
        map: _map$o,
        ap: _ap$9
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Applicative$9 = {
        URI: URI$q,
        map: _map$o,
        ap: _ap$9,
        of: of$j
    };
    /**
     * Less strict version of [`chain`](#chain).
     *
     * @category instance operations
     * @since 2.6.0
     */
    var chainW$7 = function (f) { return function (ma) {
        return isLeft$2(ma) ? ma : f(ma.right);
    }; };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category instance operations
     * @since 2.0.0
     */
    var chain$k = chainW$7;
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$f = {
        URI: URI$q,
        map: _map$o,
        ap: _ap$9,
        chain: _chain$d
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Monad$e = {
        URI: URI$q,
        map: _map$o,
        ap: _ap$9,
        of: of$j,
        chain: _chain$d
    };
    /**
     * Left-associative fold of a structure.
     *
     * @example
     * import { pipe } from 'fp-ts/function'
     * import * as E from 'fp-ts/Either'
     *
     * const startWith = 'prefix'
     * const concat = (a: string, b: string) => `${a}:${b}`
     *
     * assert.deepStrictEqual(
     *   pipe(E.right('a'), E.reduce(startWith, concat)),
     *   'prefix:a'
     * )
     *
     * assert.deepStrictEqual(
     *   pipe(E.left('e'), E.reduce(startWith, concat)),
     *   'prefix'
     * )
     *
     * @category instance operations
     * @since 2.0.0
     */
    var reduce$c = function (b, f) { return function (fa) {
        return isLeft$2(fa) ? b : f(b, fa.right);
    }; };
    /**
     * Map each element of the structure to a monoid, and combine the results.
     *
     * @example
     * import { pipe } from 'fp-ts/function'
     * import * as E from 'fp-ts/Either'
     * import * as S from 'fp-ts/string'
     *
     * const yell = (a: string) => `${a}!`
     *
     * assert.deepStrictEqual(
     *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),
     *   'a!'
     * )
     *
     * assert.deepStrictEqual(
     *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),
     *   S.Monoid.empty
     * )
     *
     * @category instance operations
     * @since 2.0.0
     */
    var foldMap$c = function (M) { return function (f) { return function (fa) {
        return isLeft$2(fa) ? M.empty : f(fa.right);
    }; }; };
    /**
     * Right-associative fold of a structure.
     *
     * @example
     * import { pipe } from 'fp-ts/function'
     * import * as E from 'fp-ts/Either'
     *
     * const startWith = 'postfix'
     * const concat = (a: string, b: string) => `${a}:${b}`
     *
     * assert.deepStrictEqual(
     *   pipe(E.right('a'), E.reduceRight(startWith, concat)),
     *   'a:postfix'
     * )
     *
     * assert.deepStrictEqual(
     *   pipe(E.left('e'), E.reduceRight(startWith, concat)),
     *   'postfix'
     * )
     *
     * @category instance operations
     * @since 2.0.0
     */
    var reduceRight$c = function (b, f) { return function (fa) {
        return isLeft$2(fa) ? b : f(fa.right, b);
    }; };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Foldable$8 = {
        URI: URI$q,
        reduce: _reduce$7,
        foldMap: _foldMap$7,
        reduceRight: _reduceRight$7
    };
    /**
     * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.
     *
     * @example
     * import { pipe } from 'fp-ts/function'
     * import * as RA from 'fp-ts/ReadonlyArray'
     * import * as E from 'fp-ts/Either'
     * import * as O from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(
     *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),
     *   O.some(E.right('a'))
     *  )
     *
     * assert.deepStrictEqual(
     *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),
     *   O.none
     * )
     *
     * @category instance operations
     * @since 2.6.3
     */
    var traverse$8 = function (F) { return function (f) { return function (ta) { return (isLeft$2(ta) ? F.of(left$b(ta.left)) : F.map(f(ta.right), right$b)); }; }; };
    /**
     * Evaluate each monadic action in the structure from left to right, and collect the results.
     *
     * @example
     * import { pipe } from 'fp-ts/function'
     * import * as E from 'fp-ts/Either'
     * import * as O from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(
     *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),
     *   O.some(E.right('a'))
     *  )
     *
     * assert.deepStrictEqual(
     *   pipe(E.right(O.none), E.sequence(O.Applicative)),
     *   O.none
     * )
     *
     * @category instance operations
     * @since 2.6.3
     */
    var sequence$8 = function (F) { return function (ma) {
        return isLeft$2(ma) ? F.of(left$b(ma.left)) : F.map(ma.right, right$b);
    }; };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Traversable$8 = {
        URI: URI$q,
        map: _map$o,
        reduce: _reduce$7,
        foldMap: _foldMap$7,
        reduceRight: _reduceRight$7,
        traverse: _traverse$7,
        sequence: sequence$8
    };
    /**
     * Map a pair of functions over the two type arguments of the bifunctor.
     *
     * @category instance operations
     * @since 2.0.0
     */
    var bimap$b = function (f, g) { return function (fa) { return (isLeft$2(fa) ? left$b(f(fa.left)) : right$b(g(fa.right))); }; };
    /**
     * Map a function over the first type argument of a bifunctor.
     *
     * @category instance operations
     * @since 2.0.0
     */
    var mapLeft$b = function (f) { return function (fa) {
        return isLeft$2(fa) ? left$b(f(fa.left)) : fa;
    }; };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Bifunctor$9 = {
        URI: URI$q,
        bimap: _bimap$9,
        mapLeft: _mapLeft$9
    };
    /**
     * Less strict version of [`alt`](#alt).
     *
     * @category instance operations
     * @since 2.9.0
     */
    var altW$7 = function (that) { return function (fa) { return (isLeft$2(fa) ? that() : fa); }; };
    /**
     * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
     * types of kind `* -> *`.
     *
     * @category instance operations
     * @since 2.0.0
     */
    var alt$9 = altW$7;
    /**
     * @category instances
     * @since 2.7.0
     */
    var Alt$7 = {
        URI: URI$q,
        map: _map$o,
        alt: _alt$7
    };
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var extend$5 = function (f) { return function (wa) {
        return isLeft$2(wa) ? wa : right$b(f(wa));
    }; };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Extend$1 = {
        URI: URI$q,
        map: _map$o,
        extend: _extend$5
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var ChainRec$2 = {
        URI: URI$q,
        map: _map$o,
        ap: _ap$9,
        chain: _chain$d,
        chainRec: _chainRec$2
    };
    /**
     * @category instance operations
     * @since 2.6.3
     */
    var throwError$5 = left$b;
    /**
     * @category instances
     * @since 2.7.0
     */
    var MonadThrow$6 = {
        URI: URI$q,
        map: _map$o,
        ap: _ap$9,
        of: of$j,
        chain: _chain$d,
        throwError: throwError$5
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromEither$9 = {
        URI: URI$q,
        fromEither: identity$1
    };
    /**
     * @example
     * import { fromPredicate, left, right } from 'fp-ts/Either'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(
     *   pipe(
     *     1,
     *     fromPredicate(
     *       (n) => n > 0,
     *       () => 'error'
     *     )
     *   ),
     *   right(1)
     * )
     * assert.deepStrictEqual(
     *   pipe(
     *     -1,
     *     fromPredicate(
     *       (n) => n > 0,
     *       () => 'error'
     *     )
     *   ),
     *   left('error')
     * )
     *
     * @category constructors
     * @since 2.0.0
     */
    var fromPredicate$9 = 
    /*#__PURE__*/
    fromPredicate$d(FromEither$9);
    // -------------------------------------------------------------------------------------
    // natural transformations
    // -------------------------------------------------------------------------------------
    /**
     * @example
     * import * as E from 'fp-ts/Either'
     * import { pipe } from 'fp-ts/function'
     * import * as O from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(
     *   pipe(
     *     O.some(1),
     *     E.fromOption(() => 'error')
     *   ),
     *   E.right(1)
     * )
     * assert.deepStrictEqual(
     *   pipe(
     *     O.none,
     *     E.fromOption(() => 'error')
     *   ),
     *   E.left('error')
     * )
     *
     * @category natural transformations
     * @since 2.0.0
     */
    var fromOption$9 = 
    /*#__PURE__*/
    fromOption$c(FromEither$9);
    // -------------------------------------------------------------------------------------
    // refinements
    // -------------------------------------------------------------------------------------
    /**
     * Returns `true` if the either is an instance of `Left`, `false` otherwise.
     *
     * @category refinements
     * @since 2.0.0
     */
    var isLeft$2 = isLeft$3;
    /**
     * Returns `true` if the either is an instance of `Right`, `false` otherwise.
     *
     * @category refinements
     * @since 2.0.0
     */
    var isRight$2 = isRight$3;
    // -------------------------------------------------------------------------------------
    // destructors
    // -------------------------------------------------------------------------------------
    /**
     * Less strict version of [`match`](#match).
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchW$7 = function (onLeft, onRight) { return function (ma) {
        return isLeft$2(ma) ? onLeft(ma.left) : onRight(ma.right);
    }; };
    /**
     * Alias of [`matchW`](#matchw).
     *
     * @category destructors
     * @since 2.10.0
     */
    var foldW$7 = matchW$7;
    /**
     * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,
     * if the value is a `Right` the inner value is applied to the second function.
     *
     * @example
     * import { match, left, right } from 'fp-ts/Either'
     * import { pipe } from 'fp-ts/function'
     *
     * function onLeft(errors: Array<string>): string {
     *   return `Errors: ${errors.join(', ')}`
     * }
     *
     * function onRight(value: number): string {
     *   return `Ok: ${value}`
     * }
     *
     * assert.strictEqual(
     *   pipe(
     *     right(1),
     *     match(onLeft, onRight)
     *   ),
     *   'Ok: 1'
     * )
     * assert.strictEqual(
     *   pipe(
     *     left(['error 1', 'error 2']),
     *     match(onLeft, onRight)
     *   ),
     *   'Errors: error 1, error 2'
     * )
     *
     * @category destructors
     * @since 2.10.0
     */
    var match$b = matchW$7;
    /**
     * Alias of [`match`](#match).
     *
     * @category destructors
     * @since 2.0.0
     */
    var fold$9 = match$b;
    /**
     * Less strict version of [`getOrElse`](#getorelse).
     *
     * @category destructors
     * @since 2.6.0
     */
    var getOrElseW$5 = function (onLeft) { return function (ma) {
        return isLeft$2(ma) ? onLeft(ma.left) : ma.right;
    }; };
    /**
     * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.
     *
     * @example
     * import { getOrElse, left, right } from 'fp-ts/Either'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(
     *   pipe(
     *     right(1),
     *     getOrElse(() => 0)
     *   ),
     *   1
     * )
     * assert.deepStrictEqual(
     *   pipe(
     *     left('error'),
     *     getOrElse(() => 0)
     *   ),
     *   0
     * )
     *
     * @category destructors
     * @since 2.0.0
     */
    var getOrElse$7 = getOrElseW$5;
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$p = 
    /*#__PURE__*/
    flap$x(Functor$p);
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apFirst$e = 
    /*#__PURE__*/
    apFirst$k(Apply$8);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apSecond$e = 
    /*#__PURE__*/
    apSecond$k(Apply$8);
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var chainFirst$e = 
    /*#__PURE__*/
    chainFirst$k(Chain$f);
    /**
     * Less strict version of [`chainFirst`](#chainfirst)
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.8.0
     */
    var chainFirstW$7 = chainFirst$e;
    /**
     * Less strict version of [`flatten`](#flatten).
     *
     * @category combinators
     * @since 2.11.0
     */
    var flattenW$7 = 
    /*#__PURE__*/
    chainW$7(identity$1);
    /**
     * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.
     *
     * Derivable from `Chain`.
     *
     * @example
     * import * as E from 'fp-ts/Either'
     *
     * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))
     * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))
     * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))
     *
     * @category combinators
     * @since 2.0.0
     */
    var flatten$d = flattenW$7;
    /**
     * Derivable from `Extend`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var duplicate$5 = 
    /*#__PURE__*/
    extend$5(identity$1);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromOptionK$b = 
    /*#__PURE__*/
    fromOptionK$e(FromEither$9);
    /**
     * @category combinators
     * @since 2.11.0
     */
    var chainOptionK$8 = 
    /*#__PURE__*/
    chainOptionK$9(FromEither$9, Chain$f);
    /**
     * @example
     * import * as E from 'fp-ts/Either'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(
     *   pipe(
     *     E.right(1),
     *     E.filterOrElse(
     *       (n) => n > 0,
     *       () => 'error'
     *     )
     *   ),
     *   E.right(1)
     * )
     * assert.deepStrictEqual(
     *   pipe(
     *     E.right(-1),
     *     E.filterOrElse(
     *       (n) => n > 0,
     *       () => 'error'
     *     )
     *   ),
     *   E.left('error')
     * )
     * assert.deepStrictEqual(
     *   pipe(
     *     E.left('a'),
     *     E.filterOrElse(
     *       (n) => n > 0,
     *       () => 'error'
     *     )
     *   ),
     *   E.left('a')
     * )
     *
     * @category combinators
     * @since 2.0.0
     */
    var filterOrElse$6 = 
    /*#__PURE__*/
    filterOrElse$7(FromEither$9, Chain$f);
    /**
     * Less strict version of [`filterOrElse`](#filterorelse).
     *
     * @category combinators
     * @since 2.9.0
     */
    var filterOrElseW$5 = filterOrElse$6;
    /**
     * Returns a `Right` if is a `Left` (and vice versa).
     *
     * @category combinators
     * @since 2.0.0
     */
    var swap$a = function (ma) { return (isLeft$2(ma) ? right$b(ma.left) : left$b(ma.right)); };
    /**
     * Less strict version of [`orElse`](#orelse).
     *
     * @category combinators
     * @since 2.10.0
     */
    var orElseW$4 = function (onLeft) { return function (ma) {
        return isLeft$2(ma) ? onLeft(ma.left) : ma;
    }; };
    /**
     * Useful for recovering from errors.
     *
     * @category combinators
     * @since 2.0.0
     */
    var orElse$5 = orElseW$4;
    // -------------------------------------------------------------------------------------
    // interop
    // -------------------------------------------------------------------------------------
    /**
     * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use
     * the provided default as a `Left`.
     *
     * @example
     * import { fromNullable, left, right } from 'fp-ts/Either'
     *
     * const parse = fromNullable('nully')
     *
     * assert.deepStrictEqual(parse(1), right(1))
     * assert.deepStrictEqual(parse(null), left('nully'))
     *
     * @category interop
     * @since 2.0.0
     */
    var fromNullable$2 = function (e) { return function (a) {
        return a == null ? left$b(e) : right$b(a);
    }; };
    /**
     * Constructs a new `Either` from a function that might throw.
     *
     * See also [`tryCatchK`](#trycatchk).
     *
     * @example
     * import * as E from 'fp-ts/Either'
     *
     * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {
     *   if (as.length > 0) {
     *     return as[0]
     *   } else {
     *     throw new Error('empty array')
     *   }
     * }
     *
     * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>
     *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))
     *
     * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))
     * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))
     *
     * @category interop
     * @since 2.0.0
     */
    var tryCatch$3 = function (f, onThrow) {
        try {
            return right$b(f());
        }
        catch (e) {
            return left$b(onThrow(e));
        }
    };
    /**
     * Converts a function that may throw to one returning a `Either`.
     *
     * @category interop
     * @since 2.10.0
     */
    var tryCatchK$3 = function (f, onThrow) { return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return tryCatch$3(function () { return f.apply(void 0, a); }, onThrow);
    }; };
    /**
     * @category interop
     * @since 2.9.0
     */
    var fromNullableK$2 = function (e) {
        var from = fromNullable$2(e);
        return function (f) { return flow(f, from); };
    };
    /**
     * @category interop
     * @since 2.9.0
     */
    var chainNullableK$2 = function (e) {
        var from = fromNullableK$2(e);
        return function (f) { return chain$k(from(f)); };
    };
    /**
     * @category interop
     * @since 2.10.0
     */
    var toUnion$5 = 
    /*#__PURE__*/
    foldW$7(identity$1, identity$1);
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * Default value for the `onError` argument of `tryCatch`
     *
     * @since 2.0.0
     */
    function toError(e) {
        return e instanceof Error ? e : new Error(String(e));
    }
    function elem$8(E) {
        return function (a, ma) {
            if (ma === undefined) {
                var elemE_1 = elem$8(E);
                return function (ma) { return elemE_1(a, ma); };
            }
            return isLeft$2(ma) ? false : E.equals(a, ma.right);
        };
    }
    /**
     * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.
     *
     * @example
     * import { exists, left, right } from 'fp-ts/Either'
     *
     * const gt2 = exists((n: number) => n > 2)
     *
     * assert.strictEqual(gt2(left('a')), false)
     * assert.strictEqual(gt2(right(1)), false)
     * assert.strictEqual(gt2(right(3)), true)
     *
     * @since 2.0.0
     */
    var exists$2 = function (predicate) { return function (ma) {
        return isLeft$2(ma) ? false : predicate(ma.right);
    }; };
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.9.0
     */
    var Do$b = 
    /*#__PURE__*/
    of$j(emptyRecord);
    /**
     * @since 2.8.0
     */
    var bindTo$e = 
    /*#__PURE__*/
    bindTo$k(Functor$p);
    /**
     * @since 2.8.0
     */
    var bind$g = 
    /*#__PURE__*/
    bind$m(Chain$f);
    /**
     * @since 2.8.0
     */
    var bindW$7 = bind$g;
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var apS$e = 
    /*#__PURE__*/
    apS$k(Apply$8);
    /**
     * @since 2.8.0
     */
    var apSW$7 = apS$e;
    // -------------------------------------------------------------------------------------
    // sequence T
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var ApT$b = 
    /*#__PURE__*/
    of$j(emptyReadonlyArray);
    // -------------------------------------------------------------------------------------
    // array utils
    // -------------------------------------------------------------------------------------
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndex$d = function (f) { return function (as) {
        var e = f(0, head$5(as));
        if (isLeft$2(e)) {
            return e;
        }
        var out = [e.right];
        for (var i = 1; i < as.length; i++) {
            var e_1 = f(i, as[i]);
            if (isLeft$2(e_1)) {
                return e_1;
            }
            out.push(e_1.right);
        }
        return right$b(out);
    }; };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndex$d = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndex$d(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT$b); };
    };
    /**
     * @since 2.9.0
     */
    var traverseArrayWithIndex$b = traverseReadonlyArrayWithIndex$d;
    /**
     * @since 2.9.0
     */
    var traverseArray$b = function (f) { return traverseReadonlyArrayWithIndex$d(function (_, a) { return f(a); }); };
    /**
     * @since 2.9.0
     */
    var sequenceArray$b = 
    /*#__PURE__*/
    traverseArray$b(identity$1);
    /**
     * Use [`parse`](./Json.ts.html#parse) instead.
     *
     * @category constructors
     * @since 2.0.0
     * @deprecated
     */
    function parseJSON$1(s, onError) {
        return tryCatch$3(function () { return JSON.parse(s); }, onError);
    }
    /**
     * Use [`stringify`](./Json.ts.html#stringify) instead.
     *
     * @category constructors
     * @since 2.0.0
     * @deprecated
     */
    var stringifyJSON = function (u, onError) {
        return tryCatch$3(function () {
            var s = JSON.stringify(u);
            if (typeof s !== 'string') {
                throw new Error('Converting unsupported structure to JSON');
            }
            return s;
        }, onError);
    };
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var either = {
        URI: URI$q,
        map: _map$o,
        of: of$j,
        ap: _ap$9,
        chain: _chain$d,
        reduce: _reduce$7,
        foldMap: _foldMap$7,
        reduceRight: _reduceRight$7,
        traverse: _traverse$7,
        sequence: sequence$8,
        bimap: _bimap$9,
        mapLeft: _mapLeft$9,
        alt: _alt$7,
        extend: _extend$5,
        chainRec: _chainRec$2,
        throwError: throwError$5
    };
    /**
     * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
     *
     * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values
     * are concatenated using the provided `Semigroup`
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getApplySemigroup$5 = 
    /*#__PURE__*/
    getApplySemigroup$7(Apply$8);
    /**
     * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getApplyMonoid$4 = 
    /*#__PURE__*/
    getApplicativeMonoid$1(Applicative$9);
    /**
     * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getValidationSemigroup = function (SE, SA) {
        return getApplySemigroup$7(getApplicativeValidation(SE))(SA);
    };
    /**
     * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getValidationMonoid = function (SE, MA) {
        return getApplicativeMonoid$1(getApplicativeValidation(SE))(MA);
    };
    /**
     * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    function getValidation(SE) {
        var ap = getApplicativeValidation(SE).ap;
        var alt = getAltValidation(SE).alt;
        return {
            URI: URI$q,
            _E: undefined,
            map: _map$o,
            of: of$j,
            chain: _chain$d,
            bimap: _bimap$9,
            mapLeft: _mapLeft$9,
            reduce: _reduce$7,
            foldMap: _foldMap$7,
            reduceRight: _reduceRight$7,
            extend: _extend$5,
            traverse: _traverse$7,
            sequence: sequence$8,
            chainRec: _chainRec$2,
            throwError: throwError$5,
            ap: ap,
            alt: alt
        };
    }

    var Either = /*#__PURE__*/Object.freeze({
        __proto__: null,
        left: left$b,
        right: right$b,
        URI: URI$q,
        getShow: getShow$9,
        getEq: getEq$9,
        getSemigroup: getSemigroup$b,
        getCompactable: getCompactable$4,
        getFilterable: getFilterable$4,
        getWitherable: getWitherable$4,
        getApplicativeValidation: getApplicativeValidation,
        getAltValidation: getAltValidation,
        map: map$w,
        Functor: Functor$p,
        of: of$j,
        Pointed: Pointed$g,
        apW: apW$7,
        ap: ap$j,
        Apply: Apply$8,
        Applicative: Applicative$9,
        chainW: chainW$7,
        chain: chain$k,
        Chain: Chain$f,
        Monad: Monad$e,
        reduce: reduce$c,
        foldMap: foldMap$c,
        reduceRight: reduceRight$c,
        Foldable: Foldable$8,
        traverse: traverse$8,
        sequence: sequence$8,
        Traversable: Traversable$8,
        bimap: bimap$b,
        mapLeft: mapLeft$b,
        Bifunctor: Bifunctor$9,
        altW: altW$7,
        alt: alt$9,
        Alt: Alt$7,
        extend: extend$5,
        Extend: Extend$1,
        ChainRec: ChainRec$2,
        throwError: throwError$5,
        MonadThrow: MonadThrow$6,
        FromEither: FromEither$9,
        fromPredicate: fromPredicate$9,
        fromOption: fromOption$9,
        isLeft: isLeft$2,
        isRight: isRight$2,
        matchW: matchW$7,
        foldW: foldW$7,
        match: match$b,
        fold: fold$9,
        getOrElseW: getOrElseW$5,
        getOrElse: getOrElse$7,
        flap: flap$p,
        apFirst: apFirst$e,
        apSecond: apSecond$e,
        chainFirst: chainFirst$e,
        chainFirstW: chainFirstW$7,
        flattenW: flattenW$7,
        flatten: flatten$d,
        duplicate: duplicate$5,
        fromOptionK: fromOptionK$b,
        chainOptionK: chainOptionK$8,
        filterOrElse: filterOrElse$6,
        filterOrElseW: filterOrElseW$5,
        swap: swap$a,
        orElseW: orElseW$4,
        orElse: orElse$5,
        fromNullable: fromNullable$2,
        tryCatch: tryCatch$3,
        tryCatchK: tryCatchK$3,
        fromNullableK: fromNullableK$2,
        chainNullableK: chainNullableK$2,
        toUnion: toUnion$5,
        toError: toError,
        elem: elem$8,
        exists: exists$2,
        Do: Do$b,
        bindTo: bindTo$e,
        bind: bind$g,
        bindW: bindW$7,
        apS: apS$e,
        apSW: apSW$7,
        ApT: ApT$b,
        traverseReadonlyNonEmptyArrayWithIndex: traverseReadonlyNonEmptyArrayWithIndex$d,
        traverseReadonlyArrayWithIndex: traverseReadonlyArrayWithIndex$d,
        traverseArrayWithIndex: traverseArrayWithIndex$b,
        traverseArray: traverseArray$b,
        sequenceArray: sequenceArray$b,
        parseJSON: parseJSON$1,
        stringifyJSON: stringifyJSON,
        either: either,
        getApplySemigroup: getApplySemigroup$5,
        getApplyMonoid: getApplyMonoid$4,
        getValidationSemigroup: getValidationSemigroup,
        getValidationMonoid: getValidationMonoid,
        getValidation: getValidation
    });

    function right$a(F) {
        return flow(right$b, F.of);
    }
    function left$a(F) {
        return flow(left$b, F.of);
    }
    function rightF$1(F) {
        return function (fa) { return F.map(fa, right$b); };
    }
    function leftF$1(F) {
        return function (fe) { return F.map(fe, left$b); };
    }
    function map$v(F) {
        return map$E(F, Functor$p);
    }
    function ap$i(F) {
        return ap$p(F, Apply$8);
    }
    function chain$j(M) {
        return function (f) { return function (ma) { return M.chain(ma, function (e) { return (isLeft$2(e) ? M.of(e) : f(e.right)); }); }; };
    }
    function alt$8(M) {
        return function (second) { return function (first) { return M.chain(first, function (e) { return (isLeft$2(e) ? second() : M.of(e)); }); }; };
    }
    function bimap$a(F) {
        return function (f, g) { return function (fea) { return F.map(fea, bimap$b(f, g)); }; };
    }
    function mapLeft$a(F) {
        return function (f) { return function (fea) { return F.map(fea, mapLeft$b(f)); }; };
    }
    function altValidation(M, S) {
        return function (second) { return function (first) {
            return M.chain(first, match$b(function (e1) {
                return M.map(second(), mapLeft$b(function (e2) { return S.concat(e1, e2); }));
            }, right$a(M)));
        }; };
    }
    function match$a(F) {
        return function (onLeft, onRight) { return function (ma) { return F.map(ma, match$b(onLeft, onRight)); }; };
    }
    function matchE$8(M) {
        return function (onLeft, onRight) { return function (ma) { return M.chain(ma, match$b(onLeft, onRight)); }; };
    }
    function getOrElse$6(M) {
        return function (onLeft) { return function (ma) { return M.chain(ma, match$b(onLeft, M.of)); }; };
    }
    function orElse$4(M) {
        return function (onLeft) { return function (ma) { return M.chain(ma, function (e) { return (isLeft$2(e) ? onLeft(e.left) : M.of(e)); }); }; };
    }
    function orElseFirst$4(M) {
        var orElseM = orElse$4(M);
        return function (onLeft) { return orElseM(function (e) { return M.map(onLeft(e), function (eb) { return (isLeft$2(eb) ? eb : left$b(e)); }); }); };
    }
    function orLeft$4(M) {
        return function (onLeft) { return function (ma) {
            return M.chain(ma, match$b(function (e) { return M.map(onLeft(e), left$b); }, function (a) { return M.of(right$b(a)); }));
        }; };
    }
    function swap$9(F) {
        return function (ma) { return F.map(ma, swap$a); };
    }
    function toUnion$4(F) {
        return function (fa) { return F.map(fa, toUnion$5); };
    }
    /** @deprecated  */
    /* istanbul ignore next */
    function getEitherM(M) {
        var _ap = ap$i(M);
        var _map = map$v(M);
        var _chain = chain$j(M);
        var _alt = alt$8(M);
        var _bimap = bimap$a(M);
        var _mapLeft = mapLeft$a(M);
        var _fold = matchE$8(M);
        var _getOrElse = getOrElse$6(M);
        var _orElse = orElse$4(M);
        return {
            map: function (fa, f) { return pipe$1(fa, _map(f)); },
            ap: function (fab, fa) { return pipe$1(fab, _ap(fa)); },
            of: right$a(M),
            chain: function (ma, f) { return pipe$1(ma, _chain(f)); },
            alt: function (fa, that) { return pipe$1(fa, _alt(that)); },
            bimap: function (fea, f, g) { return pipe$1(fea, _bimap(f, g)); },
            mapLeft: function (fea, f) { return pipe$1(fea, _mapLeft(f)); },
            fold: function (fa, onLeft, onRight) { return pipe$1(fa, _fold(onLeft, onRight)); },
            getOrElse: function (fa, onLeft) { return pipe$1(fa, _getOrElse(onLeft)); },
            orElse: function (fa, f) { return pipe$1(fa, _orElse(f)); },
            swap: swap$9(M),
            rightM: rightF$1(M),
            leftM: leftF$1(M),
            left: left$a(M)
        };
    }

    var EitherT = /*#__PURE__*/Object.freeze({
        __proto__: null,
        right: right$a,
        left: left$a,
        rightF: rightF$1,
        leftF: leftF$1,
        map: map$v,
        ap: ap$i,
        chain: chain$j,
        alt: alt$8,
        bimap: bimap$a,
        mapLeft: mapLeft$a,
        altValidation: altValidation,
        match: match$a,
        matchE: matchE$8,
        getOrElse: getOrElse$6,
        orElse: orElse$4,
        orElseFirst: orElseFirst$4,
        orLeft: orLeft$4,
        swap: swap$9,
        toUnion: toUnion$4,
        getEitherM: getEitherM
    });

    /**
     * @since 2.11.0
     */
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.11.0
     */
    var URI$p = 'Endomorphism';
    /**
     * Endomorphism form a `Semigroup` where the `concat` operation is the usual function composition.
     *
     * @category instances
     * @since 2.11.0
     */
    var getSemigroup$a = function () { return ({
        concat: function (first, second) { return flow(first, second); }
    }); };
    /**
     * Endomorphism form a `Monoid` where the `empty` value is the `identity` function.
     *
     * @category instances
     * @since 2.11.0
     */
    var getMonoid$8 = function () { return ({
        concat: getSemigroup$a().concat,
        empty: identity$1
    }); };

    var Endomorphism = /*#__PURE__*/Object.freeze({
        __proto__: null,
        URI: URI$p,
        getSemigroup: getSemigroup$a,
        getMonoid: getMonoid$8
    });

    var Extend = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * The *greatest common divisor* of two values
     *
     * @since 2.0.0
     */
    function gcd(E, field) {
        var zero = field.zero;
        var f = function (x, y) { return (E.equals(y, zero) ? x : f(y, field.mod(x, y))); };
        return f;
    }
    /**
     * The *least common multiple* of two values
     *
     * @since 2.0.0
     */
    function lcm(E, F) {
        var zero = F.zero;
        var gcdSF = gcd(E, F);
        return function (x, y) { return (E.equals(x, zero) || E.equals(y, zero) ? zero : F.div(F.mul(x, y), gcdSF(x, y))); };
    }
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use [`Field`](./number.ts.html#field) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var fieldNumber = {
        add: function (x, y) { return x + y; },
        zero: 0,
        mul: function (x, y) { return x * y; },
        one: 1,
        sub: function (x, y) { return x - y; },
        degree: function (_) { return 1; },
        div: function (x, y) { return x / y; },
        mod: function (x, y) { return x % y; }
    };

    var Field = /*#__PURE__*/Object.freeze({
        __proto__: null,
        gcd: gcd,
        lcm: lcm,
        fieldNumber: fieldNumber
    });

    /**
     * `Filterable` represents data structures which can be _partitioned_/_filtered_.
     *
     * Adapted from https://github.com/LiamGoodacre/purescript-filterable/blob/master/src/Data/Filterable.purs
     *
     * @since 2.0.0
     */
    function filter$7(F, G) {
        return function (predicate) { return function (fga) { return F.map(fga, function (ga) { return G.filter(ga, predicate); }); }; };
    }
    function filterMap$7(F, G) {
        return function (f) { return function (fga) { return F.map(fga, function (ga) { return G.filterMap(ga, f); }); }; };
    }
    function partition$7(F, G) {
        var _filter = filter$7(F, G);
        return function (predicate) {
            var left = _filter(not$1(predicate));
            var right = _filter(predicate);
            return function (fgb) { return separated(left(fgb), right(fgb)); };
        };
    }
    function partitionMap$7(F, G) {
        var _filterMap = filterMap$7(F, G);
        return function (f) { return function (fga) {
            return separated(pipe$1(fga, _filterMap(function (a) { return getLeft$1(f(a)); })), pipe$1(fga, _filterMap(function (a) { return getRight$1(f(a)); })));
        }; };
    }
    /** @deprecated */
    function getFilterableComposition(F, G) {
        var map = getFunctorComposition$1(F, G).map;
        var _compact = compact$7(F, G);
        var _separate = separate$7(F, G, G);
        var _filter = filter$7(F, G);
        var _filterMap = filterMap$7(F, G);
        var _partition = partition$7(F, G);
        var _partitionMap = partitionMap$7(F, G);
        return {
            map: map,
            compact: _compact,
            separate: _separate,
            filter: function (fga, f) { return pipe$1(fga, _filter(f)); },
            filterMap: function (fga, f) { return pipe$1(fga, _filterMap(f)); },
            partition: function (fga, p) { return pipe$1(fga, _partition(p)); },
            partitionMap: function (fga, f) { return pipe$1(fga, _partitionMap(f)); }
        };
    }

    var Filterable$5 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        filter: filter$7,
        filterMap: filterMap$7,
        partition: partition$7,
        partitionMap: partitionMap$7,
        getFilterableComposition: getFilterableComposition
    });

    var FilterableWithIndex$2 = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    function reduce$b(F, G) {
        return function (b, f) { return function (fga) { return F.reduce(fga, b, function (b, ga) { return G.reduce(ga, b, f); }); }; };
    }
    function foldMap$b(F, G) {
        return function (M) {
            var foldMapF = F.foldMap(M);
            var foldMapG = G.foldMap(M);
            return function (f) { return function (fga) { return foldMapF(fga, function (ga) { return foldMapG(ga, f); }); }; };
        };
    }
    function reduceRight$b(F, G) {
        return function (b, f) { return function (fga) { return F.reduceRight(fga, b, function (ga, b) { return G.reduceRight(ga, b, f); }); }; };
    }
    function reduceM(M, F) {
        return function (b, f) { return function (fa) { return F.reduce(fa, M.of(b), function (mb, a) { return M.chain(mb, function (b) { return f(b, a); }); }); }; };
    }
    function intercalate(M, F) {
        return function (sep, fm) {
            var go = function (_a, x) {
                var init = _a.init, acc = _a.acc;
                return init ? { init: false, acc: x } : { init: false, acc: M.concat(M.concat(acc, sep), x) };
            };
            return F.reduce(fm, { init: true, acc: M.empty }, go).acc;
        };
    }
    function toReadonlyArray$3(F) {
        return function (fa) {
            return F.reduce(fa, [], function (acc, a) {
                acc.push(a);
                return acc;
            });
        };
    }
    function traverse_(M, F) {
        var applyFirst = function (mu, mb) { return M.ap(M.map(mu, constant$1), mb); };
        var mu = M.of(undefined);
        return function (fa, f) { return F.reduce(fa, mu, function (mu, a) { return applyFirst(mu, f(a)); }); };
    }
    function foldM(M, F) {
        return function (fa, b, f) { return F.reduce(fa, M.of(b), function (mb, a) { return M.chain(mb, function (b) { return f(b, a); }); }); };
    }
    /**
     * Use [`toReadonlyArray`](#toreadonlyarray) instead
     *
     * @since 2.8.0
     * @deprecated
     */
    var toArray$3 = toReadonlyArray$3;
    /** @deprecated */
    function getFoldableComposition(F, G) {
        var _reduce = reduce$b(F, G);
        var _foldMap = foldMap$b(F, G);
        var _reduceRight = reduceRight$b(F, G);
        return {
            reduce: function (fga, b, f) { return pipe$1(fga, _reduce(b, f)); },
            foldMap: function (M) {
                var foldMapM = _foldMap(M);
                return function (fga, f) { return pipe$1(fga, foldMapM(f)); };
            },
            reduceRight: function (fga, b, f) { return pipe$1(fga, _reduceRight(b, f)); }
        };
    }

    var Foldable$7 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        reduce: reduce$b,
        foldMap: foldMap$b,
        reduceRight: reduceRight$b,
        reduceM: reduceM,
        intercalate: intercalate,
        toReadonlyArray: toReadonlyArray$3,
        traverse_: traverse_,
        foldM: foldM,
        toArray: toArray$3,
        getFoldableComposition: getFoldableComposition
    });

    /**
     * A `Foldable` with an additional index.
     * A `FoldableWithIndex` instance must be compatible with its `Foldable` instance
     *
     * ```ts
     * reduce(fa, b, f) = reduceWithIndex(fa, b, (_, b, a) => f(b, a))
     * foldMap(M)(fa, f) = foldMapWithIndex(M)(fa, (_, a) => f(a))
     * reduceRight(fa, b, f) = reduceRightWithIndex(fa, b, (_, a, b) => f(a, b))
     * ```
     *
     * @since 2.0.0
     */
    function reduceWithIndex$4(F, G) {
        return function (b, f) { return function (fga) {
            return F.reduceWithIndex(fga, b, function (i, b, ga) { return G.reduceWithIndex(ga, b, function (j, b, a) { return f([i, j], b, a); }); });
        }; };
    }
    function foldMapWithIndex$4(F, G) {
        return function (M) {
            var foldMapWithIndexF = F.foldMapWithIndex(M);
            var foldMapWithIndexG = G.foldMapWithIndex(M);
            return function (f) { return function (fga) { return foldMapWithIndexF(fga, function (i, ga) { return foldMapWithIndexG(ga, function (j, a) { return f([i, j], a); }); }); }; };
        };
    }
    function reduceRightWithIndex$4(F, G) {
        return function (b, f) { return function (fga) {
            return F.reduceRightWithIndex(fga, b, function (i, ga, b) { return G.reduceRightWithIndex(ga, b, function (j, a, b) { return f([i, j], a, b); }); });
        }; };
    }
    /** @deprecated */
    function getFoldableWithIndexComposition(F, G) {
        var FC = getFoldableComposition(F, G);
        var _reduceWithIndex = reduceWithIndex$4(F, G);
        var _foldMapWithIndex = foldMapWithIndex$4(F, G);
        var _reduceRightWithIndex = reduceRightWithIndex$4(F, G);
        return {
            reduce: FC.reduce,
            foldMap: FC.foldMap,
            reduceRight: FC.reduceRight,
            reduceWithIndex: function (fga, b, f) { return pipe$1(fga, _reduceWithIndex(b, f)); },
            foldMapWithIndex: function (M) {
                var foldMapWithIndexM = _foldMapWithIndex(M);
                return function (fga, f) { return pipe$1(fga, foldMapWithIndexM(f)); };
            },
            reduceRightWithIndex: function (fga, b, f) { return pipe$1(fga, _reduceRightWithIndex(b, f)); }
        };
    }

    var FoldableWithIndex$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        reduceWithIndex: reduceWithIndex$4,
        foldMapWithIndex: foldMapWithIndex$4,
        reduceRightWithIndex: reduceRightWithIndex$4,
        getFoldableWithIndexComposition: getFoldableWithIndexComposition
    });

    /**
     * Lift a computation from the `IO` monad
     *
     * @since 2.10.0
     */
    function fromIOK$8(F) {
        return function (f) { return flow(f, F.fromIO); };
    }
    function chainIOK$7(F, M) {
        return function (f) {
            var g = flow(f, F.fromIO);
            return function (first) { return M.chain(first, g); };
        };
    }
    function chainFirstIOK$7(F, M) {
        var chainFirstM = chainFirst$k(M);
        return function (f) { return chainFirstM(flow(f, F.fromIO)); };
    }

    var FromIO$9 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fromIOK: fromIOK$8,
        chainIOK: chainIOK$7,
        chainFirstIOK: chainFirstIOK$7
    });

    /**
     * @since 2.0.0
     */
    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * Reads the current context
     *
     * @category constructors
     * @since 2.0.0
     */
    var ask$5 = function () { return identity$1; };
    /**
     * Projects a value from the global context in a Reader
     *
     * @category constructors
     * @since 2.0.0
     */
    var asks$5 = identity$1;
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * Changes the value of the local context during the execution of the action `ma` (similar to `Contravariant`'s
     * `contramap`).
     *
     * @category combinators
     * @since 2.0.0
     */
    var local$4 = function (f) { return function (ma) { return function (r2) {
        return ma(f(r2));
    }; }; };
    /**
     * Less strict version of [`asksReader`](#asksreader).
     *
     * @category combinators
     * @since 2.11.0
     */
    var asksReaderW = function (f) { return function (r) { return f(r)(r); }; };
    /**
     * Effectfully accesses the environment.
     *
     * @category combinators
     * @since 2.11.0
     */
    var asksReader = asksReaderW;
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    /* istanbul ignore next */
    var _map$n = function (fa, f) { return pipe$1(fa, map$u(f)); };
    /* istanbul ignore next */
    var _ap$8 = function (fab, fa) { return pipe$1(fab, ap$h(fa)); };
    /* istanbul ignore next */
    var _chain$c = function (ma, f) { return pipe$1(ma, chain$i(f)); };
    var _compose$2 = function (bc, ab) { return pipe$1(bc, compose$3(ab)); };
    var _promap = function (fea, f, g) { return pipe$1(fea, promap(f, g)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$u = function (f) { return function (fa) { return function (r) { return f(fa(r)); }; }; };
    /**
     * Less strict version of [`ap`](#ap).
     *
     * @category Apply
     * @since 2.8.0
     */
    var apW$6 = function (fa) { return function (fab) { return function (r) { return fab(r)(fa(r)); }; }; };
    /**
     * Apply a function to an argument under a type constructor.
     *
     * @category Apply
     * @since 2.0.0
     */
    var ap$h = apW$6;
    /**
     * @category Pointed
     * @since 2.0.0
     */
    var of$i = constant$1;
    /**
     * Less strict version of [`chain`](#chain).
     *
     * @category Monad
     * @since 2.6.0
     */
    var chainW$6 = function (f) { return function (fa) { return function (r) { return f(fa(r))(r); }; }; };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category Monad
     * @since 2.0.0
     */
    var chain$i = chainW$6;
    /**
     * Less strict version of [`flatten`](#flatten).
     *
     * @category combinators
     * @since 2.11.0
     */
    var flattenW$6 = 
    /*#__PURE__*/
    chainW$6(identity$1);
    /**
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var flatten$c = flattenW$6;
    /**
     * @category Semigroupoid
     * @since 2.0.0
     */
    var compose$3 = function (ab) { return function (bc) { return flow(ab, bc); }; };
    /**
     * @category Profunctor
     * @since 2.0.0
     */
    var promap = function (f, g) { return function (fea) { return function (a) { return g(fea(f(a))); }; }; };
    /**
     * @category Category
     * @since 2.0.0
     */
    var id$1 = function () { return identity$1; };
    /**
     * @category Strong
     * @since 2.10.0
     */
    var first = function (pab) { return function (_a) {
        var a = _a[0], c = _a[1];
        return [pab(a), c];
    }; };
    /**
     * @category Strong
     * @since 2.10.0
     */
    var second = function (pbc) { return function (_a) {
        var a = _a[0], b = _a[1];
        return [a, pbc(b)];
    }; };
    /**
     * @category Choice
     * @since 2.10.0
     */
    var left$9 = function (pab) { return fold$9(function (a) { return left$d(pab(a)); }, right$b); };
    /**
     * @category Choice
     * @since 2.10.0
     */
    var right$9 = function (pbc) { return fold$9(left$b, function (b) { return right$d(pbc(b)); }); };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$o = 'Reader';
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$o = {
        URI: URI$o,
        map: _map$n
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$o = 
    /*#__PURE__*/
    flap$x(Functor$o);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$f = {
        URI: URI$o,
        of: of$i
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Apply$7 = {
        URI: URI$o,
        map: _map$n,
        ap: _ap$8
    };
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apFirst$d = 
    /*#__PURE__*/
    apFirst$k(Apply$7);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apSecond$d = 
    /*#__PURE__*/
    apSecond$k(Apply$7);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Applicative$8 = {
        URI: URI$o,
        map: _map$n,
        ap: _ap$8,
        of: of$i
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$e = {
        URI: URI$o,
        map: _map$n,
        ap: _ap$8,
        chain: _chain$c
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Monad$d = {
        URI: URI$o,
        map: _map$n,
        of: of$i,
        ap: _ap$8,
        chain: _chain$c
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var chainFirst$d = 
    /*#__PURE__*/
    chainFirst$k(Chain$e);
    /**
     * Less strict version of [`chainFirst`](#chainfirst).
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.11.0
     */
    var chainFirstW$6 = chainFirst$d;
    /**
     * @category instances
     * @since 2.7.0
     */
    var Profunctor$1 = {
        URI: URI$o,
        map: _map$n,
        promap: _promap
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Category = {
        URI: URI$o,
        compose: _compose$2,
        id: id$1
    };
    /**
     * @category instances
     * @since 2.8.3
     */
    var Strong$1 = {
        URI: URI$o,
        map: _map$n,
        promap: _promap,
        first: first,
        second: second
    };
    /**
     * @category instances
     * @since 2.8.3
     */
    var Choice = {
        URI: URI$o,
        map: _map$n,
        promap: _promap,
        left: left$9,
        right: right$9
    };
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var bindTo$d = 
    /*#__PURE__*/
    bindTo$k(Functor$o);
    /**
     * @since 2.8.0
     */
    var bind$f = 
    /*#__PURE__*/
    bind$m(Chain$e);
    /**
     * @since 2.8.0
     */
    var bindW$6 = bind$f;
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.9.0
     */
    var Do$a = 
    /*#__PURE__*/
    of$i(emptyRecord);
    /**
     * @since 2.8.0
     */
    var apS$d = 
    /*#__PURE__*/
    apS$k(Apply$7);
    /**
     * @since 2.8.0
     */
    var apSW$6 = apS$d;
    // -------------------------------------------------------------------------------------
    // sequence T
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var ApT$a = 
    /*#__PURE__*/
    of$i(emptyReadonlyArray);
    // -------------------------------------------------------------------------------------
    // array utils
    // -------------------------------------------------------------------------------------
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndex$c = function (f) { return function (as) { return function (r) {
        var out = [f(0, head$5(as))(r)];
        for (var i = 1; i < as.length; i++) {
            out.push(f(i, as[i])(r));
        }
        return out;
    }; }; };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndex$c = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndex$c(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT$a); };
    };
    /**
     * @since 2.9.0
     */
    var traverseArrayWithIndex$a = traverseReadonlyArrayWithIndex$c;
    /**
     * @since 2.9.0
     */
    var traverseArray$a = function (f) { return traverseReadonlyArrayWithIndex$c(function (_, a) { return f(a); }); };
    /**
     * @since 2.9.0
     */
    var sequenceArray$a = 
    /*#__PURE__*/
    traverseArray$a(identity$1);
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var reader = {
        URI: URI$o,
        map: _map$n,
        of: of$i,
        ap: _ap$8,
        chain: _chain$c,
        promap: _promap,
        compose: _compose$2,
        id: id$1,
        first: first,
        second: second,
        left: left$9,
        right: right$9
    };
    /**
     * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getSemigroup$9 = 
    /*#__PURE__*/
    getApplySemigroup$7(Apply$7);
    /**
     * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getMonoid$7 = 
    /*#__PURE__*/
    getApplicativeMonoid$1(Applicative$8);

    var Reader = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ask: ask$5,
        asks: asks$5,
        local: local$4,
        asksReaderW: asksReaderW,
        asksReader: asksReader,
        map: map$u,
        apW: apW$6,
        ap: ap$h,
        of: of$i,
        chainW: chainW$6,
        chain: chain$i,
        flattenW: flattenW$6,
        flatten: flatten$c,
        compose: compose$3,
        promap: promap,
        id: id$1,
        first: first,
        second: second,
        left: left$9,
        right: right$9,
        URI: URI$o,
        Functor: Functor$o,
        flap: flap$o,
        Pointed: Pointed$f,
        Apply: Apply$7,
        apFirst: apFirst$d,
        apSecond: apSecond$d,
        Applicative: Applicative$8,
        Chain: Chain$e,
        Monad: Monad$d,
        chainFirst: chainFirst$d,
        chainFirstW: chainFirstW$6,
        Profunctor: Profunctor$1,
        Category: Category,
        Strong: Strong$1,
        Choice: Choice,
        bindTo: bindTo$d,
        bind: bind$f,
        bindW: bindW$6,
        Do: Do$a,
        apS: apS$d,
        apSW: apSW$6,
        ApT: ApT$a,
        traverseReadonlyNonEmptyArrayWithIndex: traverseReadonlyNonEmptyArrayWithIndex$c,
        traverseReadonlyArrayWithIndex: traverseReadonlyArrayWithIndex$c,
        traverseArrayWithIndex: traverseArrayWithIndex$a,
        traverseArray: traverseArray$a,
        sequenceArray: sequenceArray$a,
        reader: reader,
        getSemigroup: getSemigroup$9,
        getMonoid: getMonoid$7
    });

    /**
     * Lift a computation from the `Reader` monad.
     *
     * @since 2.11.0
     */
    function ask$4(F) {
        return function () { return F.fromReader(ask$5()); };
    }
    function asks$4(F) {
        return F.fromReader;
    }
    function fromReaderK$4(F) {
        return function (f) { return flow(f, F.fromReader); };
    }
    function chainReaderK$4(F, M) {
        var fromReaderKF = fromReaderK$4(F);
        return function (f) { return function (ma) { return M.chain(ma, fromReaderKF(f)); }; };
    }
    function chainFirstReaderK$4(F, M) {
        return flow(fromReaderK$4(F), chainFirst$k(M));
    }

    var FromReader$4 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ask: ask$4,
        asks: asks$4,
        fromReaderK: fromReaderK$4,
        chainReaderK: chainReaderK$4,
        chainFirstReaderK: chainFirstReaderK$4
    });

    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * Get the current state
     *
     * @category constructors
     * @since 2.0.0
     */
    var get$2 = function () { return function (s) { return [s, s]; }; };
    /**
     * Set the state
     *
     * @category constructors
     * @since 2.0.0
     */
    var put$2 = function (s) { return function () { return [undefined, s]; }; };
    /**
     * Modify the state by applying a function to the current state
     *
     * @category constructors
     * @since 2.0.0
     */
    var modify$2 = function (f) { return function (s) { return [undefined, f(s)]; }; };
    /**
     * Get a value which depends on the current state
     *
     * @category constructors
     * @since 2.0.0
     */
    var gets$2 = function (f) { return function (s) { return [f(s), s]; }; };
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    /* istanbul ignore next */
    var _map$m = function (fa, f) { return pipe$1(fa, map$t(f)); };
    /* istanbul ignore next */
    var _ap$7 = function (fab, fa) { return pipe$1(fab, ap$g(fa)); };
    /* istanbul ignore next */
    var _chain$b = function (ma, f) { return pipe$1(ma, chain$h(f)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$t = function (f) { return function (fa) { return function (s1) {
        var _a = fa(s1), a = _a[0], s2 = _a[1];
        return [f(a), s2];
    }; }; };
    /**
     * Apply a function to an argument under a type constructor.
     *
     * @category Apply
     * @since 2.0.0
     */
    var ap$g = function (fa) { return function (fab) { return function (s1) {
        var _a = fab(s1), f = _a[0], s2 = _a[1];
        var _b = fa(s2), a = _b[0], s3 = _b[1];
        return [f(a), s3];
    }; }; };
    /**
     * @category Pointed
     * @since 2.0.0
     */
    var of$h = function (a) { return function (s) { return [a, s]; }; };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category Monad
     * @since 2.0.0
     */
    var chain$h = function (f) { return function (ma) { return function (s1) {
        var _a = ma(s1), a = _a[0], s2 = _a[1];
        return f(a)(s2);
    }; }; };
    /**
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var flatten$b = 
    /*#__PURE__*/
    chain$h(identity$1);
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$n = 'State';
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$n = {
        URI: URI$n,
        map: _map$m
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$n = 
    /*#__PURE__*/
    flap$x(Functor$n);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$e = {
        URI: URI$n,
        of: of$h
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Apply$6 = {
        URI: URI$n,
        map: _map$m,
        ap: _ap$7
    };
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apFirst$c = 
    /*#__PURE__*/
    apFirst$k(Apply$6);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apSecond$c = 
    /*#__PURE__*/
    apSecond$k(Apply$6);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Applicative$7 = {
        URI: URI$n,
        map: _map$m,
        ap: _ap$7,
        of: of$h
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$d = {
        URI: URI$n,
        map: _map$m,
        ap: _ap$7,
        chain: _chain$b
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Monad$c = {
        URI: URI$n,
        map: _map$m,
        ap: _ap$7,
        of: of$h,
        chain: _chain$b
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var chainFirst$c = 
    /*#__PURE__*/
    chainFirst$k(Chain$d);
    /**
     * @category instances
     * @since 2.11.0
     */
    var FromState$2 = {
        URI: URI$n,
        fromState: identity$1
    };
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * Run a computation in the `State` monad, discarding the final state
     *
     * @since 2.8.0
     */
    var evaluate$3 = function (s) { return function (ma) { return ma(s)[0]; }; };
    /**
     * Run a computation in the `State` monad discarding the result
     *
     * @since 2.8.0
     */
    var execute$3 = function (s) { return function (ma) { return ma(s)[1]; }; };
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var bindTo$c = 
    /*#__PURE__*/
    bindTo$k(Functor$n);
    /**
     * @since 2.8.0
     */
    var bind$e = 
    /*#__PURE__*/
    bind$m(Chain$d);
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var apS$c = 
    /*#__PURE__*/
    apS$k(Apply$6);
    // -------------------------------------------------------------------------------------
    // array utils
    // -------------------------------------------------------------------------------------
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndex$b = function (f) { return function (as) { return function (s) {
        var _a = f(0, head$5(as))(s), b = _a[0], s2 = _a[1];
        var bs = [b];
        var out = s2;
        for (var i = 1; i < as.length; i++) {
            var _b = f(i, as[i])(out), b_1 = _b[0], s2_1 = _b[1];
            bs.push(b_1);
            out = s2_1;
        }
        return [bs, out];
    }; }; };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndex$b = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndex$b(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : of$h(emptyReadonlyArray)); };
    };
    /**
     * @since 2.9.0
     */
    var traverseArrayWithIndex$9 = traverseReadonlyArrayWithIndex$b;
    /**
     * @since 2.9.0
     */
    var traverseArray$9 = function (f) { return traverseReadonlyArrayWithIndex$b(function (_, a) { return f(a); }); };
    /**
     * @since 2.9.0
     */
    var sequenceArray$9 = 
    /*#__PURE__*/
    traverseArray$9(identity$1);
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use [`evaluate`](#evaluate) instead
     *
     * @since 2.0.0
     * @deprecated
     */
    var evalState$1 = function (ma, s) { return ma(s)[0]; };
    /**
     * Use [`execute`](#execute) instead
     *
     * @since 2.0.0
     * @deprecated
     */
    var execState$1 = function (ma, s) { return ma(s)[1]; };
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var state = Monad$c;

    var State = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get: get$2,
        put: put$2,
        modify: modify$2,
        gets: gets$2,
        map: map$t,
        ap: ap$g,
        of: of$h,
        chain: chain$h,
        flatten: flatten$b,
        URI: URI$n,
        Functor: Functor$n,
        flap: flap$n,
        Pointed: Pointed$e,
        Apply: Apply$6,
        apFirst: apFirst$c,
        apSecond: apSecond$c,
        Applicative: Applicative$7,
        Chain: Chain$d,
        Monad: Monad$c,
        chainFirst: chainFirst$c,
        FromState: FromState$2,
        evaluate: evaluate$3,
        execute: execute$3,
        bindTo: bindTo$c,
        bind: bind$e,
        apS: apS$c,
        traverseReadonlyNonEmptyArrayWithIndex: traverseReadonlyNonEmptyArrayWithIndex$b,
        traverseReadonlyArrayWithIndex: traverseReadonlyArrayWithIndex$b,
        traverseArrayWithIndex: traverseArrayWithIndex$9,
        traverseArray: traverseArray$9,
        sequenceArray: sequenceArray$9,
        evalState: evalState$1,
        execState: execState$1,
        state: state
    });

    function get$1(F) {
        return function () { return F.fromState(get$2()); };
    }
    function put$1(F) {
        return function (s) { return F.fromState(put$2(s)); };
    }
    function modify$1(F) {
        return flow(modify$2, F.fromState);
    }
    function gets$1(F) {
        return flow(gets$2, F.fromState);
    }
    function fromStateK$1(F) {
        return function (f) { return flow(f, F.fromState); };
    }
    function chainStateK$1(F, M) {
        var fromStateKF = fromStateK$1(F);
        return function (f) { return function (ma) { return M.chain(ma, fromStateKF(f)); }; };
    }

    var FromState$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get: get$1,
        put: put$1,
        modify: modify$1,
        gets: gets$1,
        fromStateK: fromStateK$1,
        chainStateK: chainStateK$1
    });

    /**
     * Lift a computation from the `Task` monad
     *
     * @since 2.10.0
     */
    function fromTaskK$6(F) {
        return function (f) { return flow(f, F.fromTask); };
    }
    function chainTaskK$5(F, M) {
        return function (f) {
            var g = flow(f, F.fromTask);
            return function (first) { return M.chain(first, g); };
        };
    }
    function chainFirstTaskK$5(F, M) {
        var chainFirstM = chainFirst$k(M);
        return function (f) { return chainFirstM(flow(f, F.fromTask)); };
    }

    var FromTask$7 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fromTaskK: fromTaskK$6,
        chainTaskK: chainTaskK$5,
        chainFirstTaskK: chainFirstTaskK$5
    });

    /**
     * The `FromThese` type class represents those data types which support errors and warnings.
     *
     * @since 2.11.0
     */
    function fromTheseK$1(F) {
        return function (f) { return flow(f, F.fromThese); };
    }

    var FromThese$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fromTheseK: fromTheseK$1
    });

    /**
     * A `FunctorWithIndex` is a type constructor which supports a mapping operation `mapWithIndex`.
     *
     * `mapWithIndex` can be used to turn functions `i -> a -> b` into functions `f a -> f b` whose argument and return types use the type
     * constructor `f` to represent some computational context.
     *
     * Instances must satisfy the following laws:
     *
     * 1. Identity: `F.mapWithIndex(fa, (_i, a) => a) <-> fa`
     * 2. Composition: `F.mapWithIndex(fa, (_i, a) => bc(ab(a))) <-> F.mapWithIndex(F.mapWithIndex(fa, ab), bc)`
     *
     * @since 2.0.0
     */
    function mapWithIndex$4(F, G) {
        return function (f) { return function (fa) { return F.mapWithIndex(fa, function (i, ga) { return G.mapWithIndex(ga, function (j, a) { return f([i, j], a); }); }); }; };
    }
    /** @deprecated */
    function getFunctorWithIndexComposition(F, G) {
        var map = getFunctorComposition$1(F, G).map;
        var _mapWithIndex = mapWithIndex$4(F, G);
        return {
            map: map,
            mapWithIndex: function (fga, f) { return pipe$1(fga, _mapWithIndex(f)); }
        };
    }

    var FunctorWithIndex$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        mapWithIndex: mapWithIndex$4,
        getFunctorWithIndexComposition: getFunctorWithIndexComposition
    });

    var Group = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    var HeytingAlgebra = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    /**
     * Type defunctionalization (as describe in [Lightweight higher-kinded polymorphism](https://www.cl.cam.ac.uk/~jdy22/papers/lightweight-higher-kinded-polymorphism.pdf))
     *
     * @since 2.0.0
     */

    var index = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _map$l = function (fa, f) { return pipe$1(fa, map$s(f)); };
    var _ap$6 = function (fab, fa) { return pipe$1(fab, ap$f(fa)); };
    var _chain$a = function (ma, f) { return pipe$1(ma, chain$g(f)); };
    /* istanbul ignore next */
    var _reduce$6 = function (fa, b, f) { return pipe$1(fa, reduce$a(b, f)); };
    /* istanbul ignore next */
    var _foldMap$6 = function (M) { return function (fa, f) { return pipe$1(fa, foldMap$a()(f)); }; };
    /* istanbul ignore next */
    var _reduceRight$6 = function (fa, b, f) { return pipe$1(fa, reduceRight$a(b, f)); };
    /* istanbul ignore next */
    var _alt$6 = function (fa, that) { return pipe$1(fa, alt$7()); };
    /* istanbul ignore next */
    var _extend$4 = function (wa, f) { return pipe$1(wa, extend$4(f)); };
    /* istanbul ignore next */
    var _traverse$6 = function (F) {
        var traverseF = traverse$7(F);
        return function (ta, f) { return pipe$1(ta, traverseF(f)); };
    };
    var _chainRec$1 = tailRec;
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$s = function (f) { return function (fa) { return f(fa); }; };
    /**
     * Apply a function to an argument under a type constructor.
     *
     * @category Apply
     * @since 2.0.0
     */
    var ap$f = function (fa) { return function (fab) { return fab(fa); }; };
    /**
     * @category Pointed
     * @since 2.0.0
     */
    var of$g = identity$1;
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category Monad
     * @since 2.0.0
     */
    var chain$g = function (f) { return function (ma) { return f(ma); }; };
    /**
     * @category Extend
     * @since 2.0.0
     */
    var extend$4 = function (f) { return function (wa) { return f(wa); }; };
    /**
     * @category Extract
     * @since 2.6.2
     */
    var extract$4 = identity$1;
    /**
     * Derivable from `Extend`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var duplicate$4 = 
    /*#__PURE__*/
    extend$4(identity$1);
    /**
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var flatten$a = 
    /*#__PURE__*/
    chain$g(identity$1);
    /**
     * @category Foldable
     * @since 2.0.0
     */
    var reduce$a = function (b, f) { return function (fa) { return f(b, fa); }; };
    /**
     * @category Foldable
     * @since 2.0.0
     */
    var foldMap$a = function () { return function (f) { return function (fa) { return f(fa); }; }; };
    /**
     * @category Foldable
     * @since 2.0.0
     */
    var reduceRight$a = function (b, f) { return function (fa) { return f(fa, b); }; };
    /**
     * @since 2.6.3
     */
    var traverse$7 = function (F) { return function (f) { return function (ta) { return F.map(f(ta), identity$1); }; }; };
    /**
     * @since 2.6.3
     */
    var sequence$7 = function (F) { return function (ta) {
        return F.map(ta, identity$1);
    }; };
    /**
     * Less strict version of [`alt`](#alt).
     *
     * @category Alt
     * @since 2.9.0
     */
    var altW$6 = function () { return identity$1; };
    /**
     * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
     * types of kind `* -> *`.
     *
     * @category Alt
     * @since 2.0.0
     */
    var alt$7 = altW$6;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$m = 'Identity';
    /**
     * @category instances
     * @since 2.0.0
     */
    var getShow$8 = identity$1;
    /**
     * @category instances
     * @since 2.0.0
     */
    var getEq$8 = identity$1;
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$m = {
        URI: URI$m,
        map: _map$l
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$m = 
    /*#__PURE__*/
    flap$x(Functor$m);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$d = {
        URI: URI$m,
        of: of$g
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Apply$5 = {
        URI: URI$m,
        map: _map$l,
        ap: _ap$6
    };
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apFirst$b = 
    /*#__PURE__*/
    apFirst$k(Apply$5);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apSecond$b = 
    /*#__PURE__*/
    apSecond$k(Apply$5);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Applicative$6 = {
        URI: URI$m,
        map: _map$l,
        ap: _ap$6,
        of: of$g
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$c = {
        URI: URI$m,
        map: _map$l,
        ap: _ap$6,
        chain: _chain$a
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Monad$b = {
        URI: URI$m,
        map: _map$l,
        ap: _ap$6,
        of: of$g,
        chain: _chain$a
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var chainFirst$b = 
    /*#__PURE__*/
    chainFirst$k(Chain$c);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Foldable$6 = {
        URI: URI$m,
        reduce: _reduce$6,
        foldMap: _foldMap$6,
        reduceRight: _reduceRight$6
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Traversable$7 = {
        URI: URI$m,
        map: _map$l,
        reduce: _reduce$6,
        foldMap: _foldMap$6,
        reduceRight: _reduceRight$6,
        traverse: _traverse$6,
        sequence: sequence$7
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Alt$6 = {
        URI: URI$m,
        map: _map$l,
        alt: _alt$6
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Comonad$4 = {
        URI: URI$m,
        map: _map$l,
        extend: _extend$4,
        extract: extract$4
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var ChainRec$1 = {
        URI: URI$m,
        map: _map$l,
        ap: _ap$6,
        chain: _chain$a,
        chainRec: _chainRec$1
    };
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.9.0
     */
    var Do$9 = 
    /*#__PURE__*/
    of$g(emptyRecord);
    /**
     * @since 2.8.0
     */
    var bindTo$b = 
    /*#__PURE__*/
    bindTo$k(Functor$m);
    /**
     * @since 2.8.0
     */
    var bind$d = 
    /*#__PURE__*/
    bind$m(Chain$c);
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var apS$b = 
    /*#__PURE__*/
    apS$k(Apply$5);
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var identity = {
        URI: URI$m,
        map: _map$l,
        ap: _ap$6,
        of: of$g,
        chain: _chain$a,
        reduce: _reduce$6,
        foldMap: _foldMap$6,
        reduceRight: _reduceRight$6,
        traverse: _traverse$6,
        sequence: sequence$7,
        alt: _alt$6,
        extract: extract$4,
        extend: _extend$4,
        chainRec: _chainRec$1
    };

    var Identity = /*#__PURE__*/Object.freeze({
        __proto__: null,
        map: map$s,
        ap: ap$f,
        of: of$g,
        chain: chain$g,
        extend: extend$4,
        extract: extract$4,
        duplicate: duplicate$4,
        flatten: flatten$a,
        reduce: reduce$a,
        foldMap: foldMap$a,
        reduceRight: reduceRight$a,
        traverse: traverse$7,
        sequence: sequence$7,
        altW: altW$6,
        alt: alt$7,
        URI: URI$m,
        getShow: getShow$8,
        getEq: getEq$8,
        Functor: Functor$m,
        flap: flap$m,
        Pointed: Pointed$d,
        Apply: Apply$5,
        apFirst: apFirst$b,
        apSecond: apSecond$b,
        Applicative: Applicative$6,
        Chain: Chain$c,
        Monad: Monad$b,
        chainFirst: chainFirst$b,
        Foldable: Foldable$6,
        Traversable: Traversable$7,
        Alt: Alt$6,
        Comonad: Comonad$4,
        ChainRec: ChainRec$1,
        Do: Do$9,
        bindTo: bindTo$b,
        bind: bind$d,
        apS: apS$b,
        identity: identity
    });

    var Invariant = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    /**
     * ```ts
     * interface IO<A> {
     *   (): A
     * }
     * ```
     *
     * `IO<A>` represents a non-deterministic synchronous computation that can cause side effects, yields a value of
     * type `A` and **never fails**. If you want to represent a synchronous computation that may fail, please see
     * `IOEither`.
     *
     * @since 2.0.0
     */
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _map$k = function (ma, f) { return function () { return f(ma()); }; };
    var _ap$5 = function (mab, ma) { return function () { return mab()(ma()); }; };
    var _chain$9 = function (ma, f) { return function () { return f(ma())(); }; };
    var _chainRec = function (a, f) { return function () {
        var e = f(a)();
        while (e._tag === 'Left') {
            e = f(e.left)();
        }
        return e.right;
    }; };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$r = function (f) { return function (fa) { return _map$k(fa, f); }; };
    /**
     * Apply a function to an argument under a type constructor.
     *
     * @category Apply
     * @since 2.0.0
     */
    var ap$e = function (fa) { return function (fab) { return _ap$5(fab, fa); }; };
    /**
     * @category Pointed
     * @since 2.0.0
     */
    var of$f = constant$1;
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category Monad
     * @since 2.0.0
     */
    var chain$f = function (f) { return function (ma) { return _chain$9(ma, f); }; };
    /**
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var flatten$9 = 
    /*#__PURE__*/
    chain$f(identity$1);
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$l = 'IO';
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$l = {
        URI: URI$l,
        map: _map$k
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$l = 
    /*#__PURE__*/
    flap$x(Functor$l);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$c = {
        URI: URI$l,
        of: of$f
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Apply$4 = {
        URI: URI$l,
        map: _map$k,
        ap: _ap$5
    };
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apFirst$a = 
    /*#__PURE__*/
    apFirst$k(Apply$4);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apSecond$a = 
    /*#__PURE__*/
    apSecond$k(Apply$4);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Applicative$5 = {
        URI: URI$l,
        map: _map$k,
        ap: _ap$5,
        of: of$f
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$b = {
        URI: URI$l,
        map: _map$k,
        ap: _ap$5,
        chain: _chain$9
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Monad$a = {
        URI: URI$l,
        map: _map$k,
        ap: _ap$5,
        of: of$f,
        chain: _chain$9
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var chainFirst$a = 
    /*#__PURE__*/
    chainFirst$k(Chain$b);
    /**
     * @category constructors
     * @since 2.7.0
     * @deprecated
     */
    var fromIO$8 = identity$1;
    /**
     * @category instances
     * @since 2.7.0
     */
    var MonadIO$8 = {
        URI: URI$l,
        map: _map$k,
        ap: _ap$5,
        of: of$f,
        chain: _chain$9,
        fromIO: fromIO$8
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var ChainRec = {
        URI: URI$l,
        map: _map$k,
        ap: _ap$5,
        chain: _chain$9,
        chainRec: _chainRec
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromIO$8 = {
        URI: URI$l,
        fromIO: identity$1
    };
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.9.0
     */
    var Do$8 = 
    /*#__PURE__*/
    of$f(emptyRecord);
    /**
     * @since 2.8.0
     */
    var bindTo$a = 
    /*#__PURE__*/
    bindTo$k(Functor$l);
    /**
     * @since 2.8.0
     */
    var bind$c = 
    /*#__PURE__*/
    bind$m(Chain$b);
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var apS$a = 
    /*#__PURE__*/
    apS$k(Apply$4);
    // -------------------------------------------------------------------------------------
    // sequence T
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var ApT$9 = 
    /*#__PURE__*/
    of$f(emptyReadonlyArray);
    // -------------------------------------------------------------------------------------
    // array utils
    // -------------------------------------------------------------------------------------
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndex$a = function (f) { return function (as) { return function () {
        var out = [f(0, head$5(as))()];
        for (var i = 1; i < as.length; i++) {
            out.push(f(i, as[i])());
        }
        return out;
    }; }; };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndex$a = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndex$a(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT$9); };
    };
    /**
     * @since 2.9.0
     */
    var traverseArrayWithIndex$8 = traverseReadonlyArrayWithIndex$a;
    /**
     * @since 2.9.0
     */
    var traverseArray$8 = function (f) {
        return traverseReadonlyArrayWithIndex$a(function (_, a) { return f(a); });
    };
    /**
     * @since 2.9.0
     */
    var sequenceArray$8 = 
    /*#__PURE__*/
    traverseArray$8(identity$1);
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var io = {
        URI: URI$l,
        map: _map$k,
        of: of$f,
        ap: _ap$5,
        chain: _chain$9,
        fromIO: fromIO$8,
        chainRec: _chainRec
    };
    /**
     * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getSemigroup$8 = 
    /*#__PURE__*/
    getApplySemigroup$7(Apply$4);
    /**
     * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getMonoid$6 = 
    /*#__PURE__*/
    getApplicativeMonoid$1(Applicative$5);

    var IO = /*#__PURE__*/Object.freeze({
        __proto__: null,
        map: map$r,
        ap: ap$e,
        of: of$f,
        chain: chain$f,
        flatten: flatten$9,
        URI: URI$l,
        Functor: Functor$l,
        flap: flap$l,
        Pointed: Pointed$c,
        Apply: Apply$4,
        apFirst: apFirst$a,
        apSecond: apSecond$a,
        Applicative: Applicative$5,
        Chain: Chain$b,
        Monad: Monad$a,
        chainFirst: chainFirst$a,
        fromIO: fromIO$8,
        MonadIO: MonadIO$8,
        ChainRec: ChainRec,
        FromIO: FromIO$8,
        Do: Do$8,
        bindTo: bindTo$a,
        bind: bind$c,
        apS: apS$a,
        ApT: ApT$9,
        traverseReadonlyNonEmptyArrayWithIndex: traverseReadonlyNonEmptyArrayWithIndex$a,
        traverseReadonlyArrayWithIndex: traverseReadonlyArrayWithIndex$a,
        traverseArrayWithIndex: traverseArrayWithIndex$8,
        traverseArray: traverseArray$8,
        sequenceArray: sequenceArray$8,
        io: io,
        getSemigroup: getSemigroup$8,
        getMonoid: getMonoid$6
    });

    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * @category constructors
     * @since 2.0.0
     */
    var left$8 = 
    /*#__PURE__*/
    left$a(Pointed$c);
    /**
     * @category constructors
     * @since 2.0.0
     */
    var right$8 = 
    /*#__PURE__*/
    right$a(Pointed$c);
    /**
     * @category constructors
     * @since 2.0.0
     */
    var rightIO$4 = 
    /*#__PURE__*/
    rightF$1(Functor$l);
    /**
     * @category constructors
     * @since 2.0.0
     */
    var leftIO$4 = 
    /*#__PURE__*/
    leftF$1(Functor$l);
    // -------------------------------------------------------------------------------------
    // natural transformations
    // -------------------------------------------------------------------------------------
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromEither$7 = of$f;
    /**
     * @category natural transformations
     * @since 2.7.0
     */
    var fromIO$7 = rightIO$4;
    // -------------------------------------------------------------------------------------
    // destructors
    // -------------------------------------------------------------------------------------
    /**
     * @category destructors
     * @since 2.10.0
     */
    var match$9 = 
    /*#__PURE__*/
    match$a(Functor$l);
    /**
     * Less strict version of [`match`](#match).
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchW$6 = match$9;
    /**
     * @category destructors
     * @since 2.10.0
     */
    var matchE$7 = 
    /*#__PURE__*/
    matchE$8(Monad$a);
    /**
     * Alias of [`matchE`](#matche).
     *
     * @category destructors
     * @since 2.0.0
     */
    var fold$8 = matchE$7;
    /**
     * Less strict version of [`matchE`](#matche).
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchEW$5 = matchE$7;
    /**
     * Alias of [`matchEW`](#matchew).
     *
     * @category destructors
     * @since 2.10.0
     */
    var foldW$6 = matchEW$5;
    /**
     * @category destructors
     * @since 2.0.0
     */
    var getOrElse$5 = 
    /*#__PURE__*/
    getOrElse$6(Monad$a);
    /**
     * Less strict version of [`getOrElse`](#getorelse).
     *
     * @category destructors
     * @since 2.6.0
     */
    var getOrElseW$4 = getOrElse$5;
    // -------------------------------------------------------------------------------------
    // interop
    // -------------------------------------------------------------------------------------
    /**
     * Constructs a new `IOEither` from a function that performs a side effect and might throw
     *
     * See also [`tryCatchK`](#trycatchk).
     *
     * @category interop
     * @since 2.0.0
     */
    var tryCatch$2 = function (f, onThrow) { return function () {
        return tryCatch$3(f, onThrow);
    }; };
    /**
     * Converts a function that may throw to one returning a `IOEither`.
     *
     * @category interop
     * @since 2.10.0
     */
    var tryCatchK$2 = function (f, onThrow) { return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return tryCatch$2(function () { return f.apply(void 0, a); }, onThrow);
    }; };
    /**
     * @category interop
     * @since 2.10.0
     */
    var toUnion$3 = 
    /*#__PURE__*/
    toUnion$4(Functor$l);
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * @category combinators
     * @since 2.0.0
     */
    var orElse$3 = 
    /*#__PURE__*/
    orElse$4(Monad$a);
    /**
     * Less strict version of [`orElse`](#orelse).
     *
     * @category combinators
     * @since 2.10.0
     */
    var orElseW$3 = orElse$3;
    /**
     * @category combinators
     * @since 2.11.0
     */
    var orElseFirst$3 = 
    /*#__PURE__*/
    orElseFirst$4(Monad$a);
    /**
     * @category combinators
     * @since 2.11.0
     */
    var orElseFirstW$3 = orElseFirst$3;
    /**
     * @category combinators
     * @since 2.11.0
     */
    var orLeft$3 = 
    /*#__PURE__*/
    orLeft$4(Monad$a);
    /**
     * @category combinators
     * @since 2.0.0
     */
    var swap$8 = 
    /*#__PURE__*/
    swap$9(Functor$l);
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    /* istanbul ignore next */
    var _map$j = function (fa, f) { return pipe$1(fa, map$q(f)); };
    /* istanbul ignore next */
    var _ap$4 = function (fab, fa) { return pipe$1(fab, ap$d(fa)); };
    var _apSeq$5 = function (fab, fa) {
        return pipe$1(fab, chain$e(function (f) { return pipe$1(fa, map$q(f)); }));
    };
    /* istanbul ignore next */
    var _chain$8 = function (ma, f) { return pipe$1(ma, chain$e(f)); };
    /* istanbul ignore next */
    var _bimap$8 = function (fa, f, g) { return pipe$1(fa, bimap$9(f, g)); };
    /* istanbul ignore next */
    var _mapLeft$8 = function (fa, f) { return pipe$1(fa, mapLeft$9(f)); };
    /* istanbul ignore next */
    var _alt$5 = function (fa, that) { return pipe$1(fa, alt$6(that)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$q = 
    /*#__PURE__*/
    map$v(Functor$l);
    /**
     * Map a pair of functions over the two type arguments of the bifunctor.
     *
     * @category Bifunctor
     * @since 2.0.0
     */
    var bimap$9 = 
    /*#__PURE__*/
    bimap$a(Functor$l);
    /**
     * Map a function over the first type argument of a bifunctor.
     *
     * @category Bifunctor
     * @since 2.0.0
     */
    var mapLeft$9 = 
    /*#__PURE__*/
    mapLeft$a(Functor$l);
    /**
     * Apply a function to an argument under a type constructor.
     *
     * @category Apply
     * @since 2.0.0
     */
    var ap$d = 
    /*#__PURE__*/
    ap$i(Apply$4);
    /**
     * Less strict version of [`ap`](#ap).
     *
     * @category Apply
     * @since 2.8.0
     */
    var apW$5 = ap$d;
    /**
     * @category Pointed
     * @since 2.8.5
     */
    var of$e = right$8;
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category Monad
     * @since 2.0.0
     */
    var chain$e = 
    /*#__PURE__*/
    chain$j(Monad$a);
    /**
     * Less strict version of [`chain`](#chain).
     *
     * @category Monad
     * @since 2.6.0
     */
    var chainW$5 = chain$e;
    /**
     * Less strict version of [`flatten`](#flatten).
     *
     * @category combinators
     * @since 2.11.0
     */
    var flattenW$5 = 
    /*#__PURE__*/
    chainW$5(identity$1);
    /**
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var flatten$8 = flattenW$5;
    /**
     * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
     * types of kind `* -> *`.
     *
     * @category Alt
     * @since 2.0.0
     */
    var alt$6 = 
    /*#__PURE__*/
    alt$8(Monad$a);
    /**
     * Less strict version of [`alt`](#alt).
     *
     * @category Alt
     * @since 2.9.0
     */
    var altW$5 = alt$6;
    /**
     * @category MonadThrow
     * @since 2.7.0
     */
    var throwError$4 = left$8;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$k = 'IOEither';
    /**
     * @category instances
     * @since 2.7.0
     */
    function getApplicativeIOValidation(S) {
        var ap = ap$p(Apply$4, getApplicativeValidation(S));
        return {
            URI: URI$k,
            _E: undefined,
            map: _map$j,
            ap: function (fab, fa) { return pipe$1(fab, ap(fa)); },
            of: of$e
        };
    }
    /**
     * @category instances
     * @since 2.7.0
     */
    function getAltIOValidation(S) {
        var alt = altValidation(Monad$a, S);
        return {
            URI: URI$k,
            _E: undefined,
            map: _map$j,
            alt: function (fa, that) { return pipe$1(fa, alt(that)); }
        };
    }
    /**
     * @category instances
     * @since 2.10.0
     */
    var getCompactable$3 = function (M) {
        var C = getCompactable$4(M);
        return {
            URI: URI$k,
            _E: undefined,
            compact: compact$7(Functor$l, C),
            separate: separate$7(Functor$l, C, Functor$p)
        };
    };
    /**
     * @category instances
     * @since 2.1.0
     */
    function getFilterable$3(M) {
        var F = getFilterable$4(M);
        var C = getCompactable$3(M);
        var filter = filter$7(Functor$l, F);
        var filterMap = filterMap$7(Functor$l, F);
        var partition = partition$7(Functor$l, F);
        var partitionMap = partitionMap$7(Functor$l, F);
        return {
            URI: URI$k,
            _E: undefined,
            map: _map$j,
            compact: C.compact,
            separate: C.separate,
            filter: function (fa, predicate) { return pipe$1(fa, filter(predicate)); },
            filterMap: function (fa, f) { return pipe$1(fa, filterMap(f)); },
            partition: function (fa, predicate) { return pipe$1(fa, partition(predicate)); },
            partitionMap: function (fa, f) { return pipe$1(fa, partitionMap(f)); }
        };
    }
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$k = {
        URI: URI$k,
        map: _map$j
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$k = 
    /*#__PURE__*/
    flap$x(Functor$k);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$b = {
        URI: URI$k,
        of: of$e
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Bifunctor$8 = {
        URI: URI$k,
        bimap: _bimap$8,
        mapLeft: _mapLeft$8
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var ApplyPar$5 = {
        URI: URI$k,
        map: _map$j,
        ap: _ap$4
    };
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apFirst$9 = 
    /*#__PURE__*/
    apFirst$k(ApplyPar$5);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apSecond$9 = 
    /*#__PURE__*/
    apSecond$k(ApplyPar$5);
    /**
     * @category instances
     * @since 2.8.4
     */
    var ApplicativePar$5 = {
        URI: URI$k,
        map: _map$j,
        ap: _ap$4,
        of: of$e
    };
    /**
     * @category instances
     * @since 2.8.4
     */
    var ApplicativeSeq$5 = {
        URI: URI$k,
        map: _map$j,
        ap: _apSeq$5,
        of: of$e
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$a = {
        URI: URI$k,
        map: _map$j,
        ap: _ap$4,
        chain: _chain$8
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Monad$9 = {
        URI: URI$k,
        map: _map$j,
        ap: _ap$4,
        of: of$e,
        chain: _chain$8
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var chainFirst$9 = 
    /*#__PURE__*/
    chainFirst$k(Chain$a);
    /**
     * Less strict version of [`chainFirst`](#chainfirst).
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.8.0
     */
    var chainFirstW$5 = chainFirst$9;
    /**
     * @category instances
     * @since 2.7.0
     */
    var Alt$5 = {
        URI: URI$k,
        map: _map$j,
        alt: _alt$5
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var MonadIO$7 = {
        URI: URI$k,
        map: _map$j,
        ap: _ap$4,
        of: of$e,
        chain: _chain$8,
        fromIO: fromIO$7
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var MonadThrow$5 = {
        URI: URI$k,
        map: _map$j,
        ap: _ap$4,
        of: of$e,
        chain: _chain$8,
        throwError: throwError$4
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromIO$7 = {
        URI: URI$k,
        fromIO: fromIO$7
    };
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromIOK$7 = 
    /*#__PURE__*/
    fromIOK$8(FromIO$7);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainIOK$6 = 
    /*#__PURE__*/
    chainIOK$7(FromIO$7, Chain$a);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainFirstIOK$6 = 
    /*#__PURE__*/
    chainFirstIOK$7(FromIO$7, Chain$a);
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromEither$8 = {
        URI: URI$k,
        fromEither: fromEither$7
    };
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromOption$8 = 
    /*#__PURE__*/
    fromOption$c(FromEither$8);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromOptionK$a = 
    /*#__PURE__*/
    fromOptionK$e(FromEither$8);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainOptionK$7 = 
    /*#__PURE__*/
    chainOptionK$9(FromEither$8, Chain$a);
    /**
     * @category combinators
     * @since 2.4.0
     */
    var chainEitherK$5 = 
    /*#__PURE__*/
    chainEitherK$7(FromEither$8, Chain$a);
    /**
     * Less strict version of [`chainEitherK`](#chaineitherk).
     *
     * @category combinators
     * @since 2.6.1
     */
    var chainEitherKW$4 = chainEitherK$5;
    /**
     * @category constructors
     * @since 2.0.0
     */
    var fromPredicate$8 = 
    /*#__PURE__*/
    fromPredicate$d(FromEither$8);
    /**
     * @category combinators
     * @since 2.0.0
     */
    var filterOrElse$5 = 
    /*#__PURE__*/
    filterOrElse$7(FromEither$8, Chain$a);
    /**
     * Less strict version of [`filterOrElse`](#filterorelse).
     *
     * @category combinators
     * @since 2.9.0
     */
    var filterOrElseW$4 = filterOrElse$5;
    /**
     * @category combinators
     * @since 2.4.0
     */
    var fromEitherK$6 = 
    /*#__PURE__*/
    fromEitherK$a(FromEither$8);
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * Make sure that a resource is cleaned up in the event of an exception (\*). The release action is called regardless of
     * whether the body action throws (\*) or returns.
     *
     * (\*) i.e. returns a `Left`
     *
     * @since 2.0.0
     */
    var bracket$2 = function (acquire, use, release) {
        return pipe$1(acquire, chain$e(function (a) {
            return pipe$1(use(a), chain$f(function (e) {
                return pipe$1(release(a, e), chain$e(function () { return of$f(e); }));
            }));
        }));
    };
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.9.0
     */
    var Do$7 = 
    /*#__PURE__*/
    of$e(emptyRecord);
    /**
     * @since 2.8.0
     */
    var bindTo$9 = 
    /*#__PURE__*/
    bindTo$k(Functor$k);
    /**
     * @since 2.8.0
     */
    var bind$b = 
    /*#__PURE__*/
    bind$m(Chain$a);
    /**
     * @since 2.8.0
     */
    var bindW$5 = bind$b;
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var apS$9 = 
    /*#__PURE__*/
    apS$k(ApplyPar$5);
    /**
     * @since 2.8.0
     */
    var apSW$5 = apS$9;
    // -------------------------------------------------------------------------------------
    // sequence T
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var ApT$8 = 
    /*#__PURE__*/
    of$e(emptyReadonlyArray);
    // -------------------------------------------------------------------------------------
    // array utils
    // -------------------------------------------------------------------------------------
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndex$9 = function (f) {
        return flow(traverseReadonlyNonEmptyArrayWithIndex$a(f), map$r(traverseReadonlyNonEmptyArrayWithIndex$d(SK)));
    };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndex$9 = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndex$9(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT$8); };
    };
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativeSeq)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndexSeq$6 = function (f) { return function (as) { return function () {
        var e = f(0, head$5(as))();
        if (isLeft$3(e)) {
            return e;
        }
        var out = [e.right];
        for (var i = 1; i < as.length; i++) {
            var e_1 = f(i, as[i])();
            if (isLeft$3(e_1)) {
                return e_1;
            }
            out.push(e_1.right);
        }
        return right$d(out);
    }; }; };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndexSeq$6 = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndexSeq$6(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT$8); };
    };
    /**
     * @since 2.9.0
     */
    var traverseArrayWithIndex$7 = traverseReadonlyArrayWithIndex$9;
    /**
     * @since 2.9.0
     */
    var traverseArray$7 = function (f) { return traverseReadonlyArrayWithIndex$9(function (_, a) { return f(a); }); };
    /**
     * @since 2.9.0
     */
    var sequenceArray$7 = 
    /*#__PURE__*/
    traverseArray$7(identity$1);
    /**
     * @since 2.9.0
     */
    var traverseSeqArrayWithIndex$5 = traverseReadonlyArrayWithIndexSeq$6;
    /**
     * @since 2.9.0
     */
    var traverseSeqArray$5 = function (f) { return traverseReadonlyArrayWithIndexSeq$6(function (_, a) { return f(a); }); };
    /**
     * @since 2.9.0
     */
    var sequenceSeqArray$5 = 
    /*#__PURE__*/
    traverseSeqArray$5(identity$1);
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use [`ApplicativePar`](#applicativepar) instead
     *
     * @since 2.7.0
     * @category instances
     * @deprecated
     */
    var Applicative$4 = ApplicativePar$5;
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var ioEither = {
        URI: URI$k,
        bimap: _bimap$8,
        mapLeft: _mapLeft$8,
        map: _map$j,
        of: of$e,
        ap: _ap$4,
        chain: _chain$8,
        alt: _alt$5,
        fromIO: fromIO$7,
        throwError: throwError$4
    };
    /**
     * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getApplySemigroup$4 = 
    /*#__PURE__*/
    getApplySemigroup$7(ApplyPar$5);
    /**
     * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getApplyMonoid$3 = 
    /*#__PURE__*/
    getApplicativeMonoid$1(ApplicativePar$5);
    /**
     * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getSemigroup$7 = function (S) {
        return getApplySemigroup$7(Apply$4)(getSemigroup$b(S));
    };
    /**
     * Use [`getApplicativeIOValidation`](#getapplicativeiovalidation) and [`getAltIOValidation`](#getaltiovalidation).
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    function getIOValidation(SE) {
        var applicativeIOValidation = getApplicativeIOValidation(SE);
        var altIOValidation = getAltIOValidation(SE);
        return {
            URI: URI$k,
            _E: undefined,
            map: _map$j,
            ap: applicativeIOValidation.ap,
            of: of$e,
            chain: _chain$8,
            bimap: _bimap$8,
            mapLeft: _mapLeft$8,
            alt: altIOValidation.alt,
            fromIO: fromIO$7,
            throwError: throwError$4
        };
    }

    var IOEither = /*#__PURE__*/Object.freeze({
        __proto__: null,
        left: left$8,
        right: right$8,
        rightIO: rightIO$4,
        leftIO: leftIO$4,
        fromEither: fromEither$7,
        fromIO: fromIO$7,
        match: match$9,
        matchW: matchW$6,
        matchE: matchE$7,
        fold: fold$8,
        matchEW: matchEW$5,
        foldW: foldW$6,
        getOrElse: getOrElse$5,
        getOrElseW: getOrElseW$4,
        tryCatch: tryCatch$2,
        tryCatchK: tryCatchK$2,
        toUnion: toUnion$3,
        orElse: orElse$3,
        orElseW: orElseW$3,
        orElseFirst: orElseFirst$3,
        orElseFirstW: orElseFirstW$3,
        orLeft: orLeft$3,
        swap: swap$8,
        map: map$q,
        bimap: bimap$9,
        mapLeft: mapLeft$9,
        ap: ap$d,
        apW: apW$5,
        of: of$e,
        chain: chain$e,
        chainW: chainW$5,
        flattenW: flattenW$5,
        flatten: flatten$8,
        alt: alt$6,
        altW: altW$5,
        throwError: throwError$4,
        URI: URI$k,
        getApplicativeIOValidation: getApplicativeIOValidation,
        getAltIOValidation: getAltIOValidation,
        getCompactable: getCompactable$3,
        getFilterable: getFilterable$3,
        Functor: Functor$k,
        flap: flap$k,
        Pointed: Pointed$b,
        Bifunctor: Bifunctor$8,
        ApplyPar: ApplyPar$5,
        apFirst: apFirst$9,
        apSecond: apSecond$9,
        ApplicativePar: ApplicativePar$5,
        ApplicativeSeq: ApplicativeSeq$5,
        Chain: Chain$a,
        Monad: Monad$9,
        chainFirst: chainFirst$9,
        chainFirstW: chainFirstW$5,
        Alt: Alt$5,
        MonadIO: MonadIO$7,
        MonadThrow: MonadThrow$5,
        FromIO: FromIO$7,
        fromIOK: fromIOK$7,
        chainIOK: chainIOK$6,
        chainFirstIOK: chainFirstIOK$6,
        FromEither: FromEither$8,
        fromOption: fromOption$8,
        fromOptionK: fromOptionK$a,
        chainOptionK: chainOptionK$7,
        chainEitherK: chainEitherK$5,
        chainEitherKW: chainEitherKW$4,
        fromPredicate: fromPredicate$8,
        filterOrElse: filterOrElse$5,
        filterOrElseW: filterOrElseW$4,
        fromEitherK: fromEitherK$6,
        bracket: bracket$2,
        Do: Do$7,
        bindTo: bindTo$9,
        bind: bind$b,
        bindW: bindW$5,
        apS: apS$9,
        apSW: apSW$5,
        ApT: ApT$8,
        traverseReadonlyNonEmptyArrayWithIndex: traverseReadonlyNonEmptyArrayWithIndex$9,
        traverseReadonlyArrayWithIndex: traverseReadonlyArrayWithIndex$9,
        traverseReadonlyNonEmptyArrayWithIndexSeq: traverseReadonlyNonEmptyArrayWithIndexSeq$6,
        traverseReadonlyArrayWithIndexSeq: traverseReadonlyArrayWithIndexSeq$6,
        traverseArrayWithIndex: traverseArrayWithIndex$7,
        traverseArray: traverseArray$7,
        sequenceArray: sequenceArray$7,
        traverseSeqArrayWithIndex: traverseSeqArrayWithIndex$5,
        traverseSeqArray: traverseSeqArray$5,
        sequenceSeqArray: sequenceSeqArray$5,
        Applicative: Applicative$4,
        ioEither: ioEither,
        getApplySemigroup: getApplySemigroup$4,
        getApplyMonoid: getApplyMonoid$3,
        getSemigroup: getSemigroup$7,
        getIOValidation: getIOValidation
    });

    /**
     * @example
     * import { io } from 'fp-ts/IO'
     * import { newIORef } from 'fp-ts/IORef'
     *
     * assert.strictEqual(io.chain(newIORef(1), ref => io.chain(ref.write(2), () => ref.read))(), 2)
     *
     * @category model
     * @since 2.0.0
     */
    var IORef = /** @class */ (function () {
        function IORef(value) {
            var _this = this;
            this.value = value;
            this.read = function () { return _this.value; };
            this.write = this.write.bind(this);
            this.modify = this.modify.bind(this);
        }
        /**
         * @since 2.0.0
         */
        IORef.prototype.write = function (a) {
            var _this = this;
            return function () {
                _this.value = a;
            };
        };
        /**
         * @since 2.0.0
         */
        IORef.prototype.modify = function (f) {
            var _this = this;
            return function () {
                _this.value = f(_this.value);
            };
        };
        return IORef;
    }());
    /**
     * @category constructors
     * @since 2.0.0
     */
    function newIORef(a) {
        return function () { return new IORef(a); };
    }

    var IORef$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        IORef: IORef,
        newIORef: newIORef
    });

    /**
     * A join-semilattice (or upper semilattice) is a semilattice whose operation is called `join`, and which can be thought
     * of as a least upper bound.
     *
     * A `JoinSemilattice` must satisfy the following laws:
     *
     * - Associativity: `a ∨ (b ∨ c) <-> (a ∨ b) ∨ c`
     * - Commutativity: `a ∨ b <-> b ∨ a`
     * - Idempotency:   `a ∨ a <-> a`
     *
     * @since 2.0.0
     */

    var JoinSemilattice = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    /**
     * @since 2.10.0
     */
    /**
     * Converts a JavaScript Object Notation (JSON) string into a `Json` type.
     *
     * @example
     * import * as J from 'fp-ts/Json'
     * import * as E from 'fp-ts/Either'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe('{"a":1}', J.parse), E.right({ a: 1 }))
     * assert.deepStrictEqual(pipe('{"a":}', J.parse), E.left(new SyntaxError('Unexpected token } in JSON at position 5')))
     *
     * @since 2.10.0
     */
    var parse = function (s) { return tryCatch$3(function () { return JSON.parse(s); }, identity$1); };
    /**
     * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.
     *
     * @example
     * import * as E from 'fp-ts/Either'
     * import * as J from 'fp-ts/Json'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(J.stringify({ a: 1 }), E.right('{"a":1}'))
     * const circular: any = { ref: null }
     * circular.ref = circular
     * assert.deepStrictEqual(
     *   pipe(
     *     J.stringify(circular),
     *     E.mapLeft(e => e instanceof Error && e.message.includes('Converting circular structure to JSON'))
     *   ),
     *   E.left(true)
     * )
     *
     *  @since 2.10.0
     */
    var stringify = function (a) {
        return tryCatch$3(function () {
            var s = JSON.stringify(a);
            if (typeof s !== 'string') {
                throw new Error('Converting unsupported structure to JSON');
            }
            return s;
        }, identity$1);
    };

    var Json = /*#__PURE__*/Object.freeze({
        __proto__: null,
        parse: parse,
        stringify: stringify
    });

    var Lattice = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    // -------------------------------------------------------------------------------------
    // interop
    // -------------------------------------------------------------------------------------
    /**
     * @category interop
     * @since 2.5.0
     */
    var fromMap = function (m) { return new Map(m); };
    /**
     * @category interop
     * @since 2.5.0
     */
    function toMap(m) {
        return new Map(m);
    }
    /**
     * @category instances
     * @since 2.5.0
     */
    function getShow$7(SK, SA) {
        return {
            show: function (m) {
                var entries = [];
                m.forEach(function (a, k) {
                    entries.push("[" + SK.show(k) + ", " + SA.show(a) + "]");
                });
                return "new Map([" + entries.sort().join(', ') + "])";
            }
        };
    }
    /**
     * Calculate the number of key/value pairs in a map
     *
     * @since 2.5.0
     */
    var size$6 = function (m) { return m.size; };
    /**
     * Test whether or not a map is empty
     *
     * @since 2.5.0
     */
    var isEmpty$6 = function (m) { return m.size === 0; };
    function member$1(E) {
        var lookupE = lookup$3(E);
        return function (k, m) {
            if (m === undefined) {
                var memberE_1 = member$1(E);
                return function (m) { return memberE_1(k, m); };
            }
            return isSome$2(lookupE(k, m));
        };
    }
    function elem$7(E) {
        return function (a, m) {
            if (m === undefined) {
                var elemE_1 = elem$7(E);
                return function (m) { return elemE_1(a, m); };
            }
            var values = m.values();
            var e;
            // tslint:disable-next-line: strict-boolean-expressions
            while (!(e = values.next()).done) {
                var v = e.value;
                if (E.equals(a, v)) {
                    return true;
                }
            }
            return false;
        };
    }
    /**
     * Get a sorted `ReadonlyArray` of the keys contained in a `ReadonlyMap`.
     *
     * @since 2.5.0
     */
    var keys$4 = function (O) { return function (m) {
        return Array.from(m.keys()).sort(O.compare);
    }; };
    /**
     * Get a sorted `ReadonlyArray` of the values contained in a `ReadonlyMap`.
     *
     * @since 2.5.0
     */
    var values$1 = function (O) { return function (m) {
        return Array.from(m.values()).sort(O.compare);
    }; };
    /**
     * @since 2.5.0
     */
    function collect$3(O) {
        var keysO = keys$4(O);
        return function (f) { return function (m) {
            var out = [];
            var ks = keysO(m);
            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
                var key = ks_1[_i];
                out.push(f(key, m.get(key)));
            }
            return out;
        }; };
    }
    /**
     * Get a sorted `ReadonlyArray` of the key/value pairs contained in a `ReadonlyMap`.
     *
     * @since 2.5.0
     */
    var toReadonlyArray$2 = function (O) {
        return collect$3(O)(function (k, a) { return [k, a]; });
    };
    function toUnfoldable$3(ord, U) {
        var toReadonlyArrayO = toReadonlyArray$2(ord);
        return function (d) {
            var kas = toReadonlyArrayO(d);
            var len = kas.length;
            return U.unfold(0, function (b) { return (b < len ? some$a([kas[b], b + 1]) : none$2); });
        };
    }
    /**
     * Insert or replace a key/value pair in a `ReadonlyMap`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var upsertAt$3 = function (E) {
        var lookupWithKeyE = lookupWithKey$1(E);
        return function (k, a) {
            var lookupWithKeyEk = lookupWithKeyE(k);
            return function (m) {
                var found = lookupWithKeyEk(m);
                if (isNone$2(found)) {
                    var out = new Map(m);
                    out.set(k, a);
                    return out;
                }
                else if (found.value[1] !== a) {
                    var out = new Map(m);
                    out.set(found.value[0], a);
                    return out;
                }
                return m;
            };
        };
    };
    /**
     * Delete a key and value from a map
     *
     * @category combinators
     * @since 2.5.0
     */
    var deleteAt$3 = function (E) {
        var lookupWithKeyE = lookupWithKey$1(E);
        return function (k) { return function (m) {
            var found = lookupWithKeyE(k, m);
            if (isSome$2(found)) {
                var r = new Map(m);
                r.delete(found.value[0]);
                return r;
            }
            return m;
        }; };
    };
    /**
     * @since 2.5.0
     */
    var updateAt$3 = function (E) {
        var modifyAtE = modifyAt$3(E);
        return function (k, a) { return modifyAtE(k, function () { return a; }); };
    };
    /**
     * @since 2.5.0
     */
    var modifyAt$3 = function (E) {
        var lookupWithKeyE = lookupWithKey$1(E);
        return function (k, f) { return function (m) {
            var found = lookupWithKeyE(k, m);
            if (isNone$2(found)) {
                return none$2;
            }
            var _a = found.value, fk = _a[0], fv = _a[1];
            var next = f(fv);
            if (next === fv) {
                return some$a(m);
            }
            var r = new Map(m);
            r.set(fk, next);
            return some$a(r);
        }; };
    };
    /**
     * Delete a key and value from a map, returning the value as well as the subsequent map
     *
     * @since 2.5.0
     */
    function pop$3(E) {
        var lookupE = lookup$3(E);
        var deleteAtE = deleteAt$3(E);
        return function (k) {
            var deleteAtEk = deleteAtE(k);
            return function (m) {
                return pipe$1(lookupE(k, m), map$y(function (a) { return [a, deleteAtEk(m)]; }));
            };
        };
    }
    function lookupWithKey$1(E) {
        return function (k, m) {
            if (m === undefined) {
                var lookupWithKeyE_1 = lookupWithKey$1(E);
                return function (m) { return lookupWithKeyE_1(k, m); };
            }
            var entries = m.entries();
            var e;
            // tslint:disable-next-line: strict-boolean-expressions
            while (!(e = entries.next()).done) {
                var _a = e.value, ka = _a[0], a = _a[1];
                if (E.equals(ka, k)) {
                    return some$a([ka, a]);
                }
            }
            return none$2;
        };
    }
    function lookup$3(E) {
        var lookupWithKeyE = lookupWithKey$1(E);
        return function (k, m) {
            if (m === undefined) {
                var lookupE_1 = lookup$3(E);
                return function (m) { return lookupE_1(k, m); };
            }
            return pipe$1(lookupWithKeyE(k, m), map$y(function (_a) {
                _a[0]; var a = _a[1];
                return a;
            }));
        };
    }
    function isSubmap$1(SK, SA) {
        var lookupWithKeyS = lookupWithKey$1(SK);
        return function (me, that) {
            if (that === undefined) {
                var isSubmapSKSA_1 = isSubmap$1(SK, SA);
                return function (that) { return isSubmapSKSA_1(that, me); };
            }
            var entries = me.entries();
            var e;
            // tslint:disable-next-line: strict-boolean-expressions
            while (!(e = entries.next()).done) {
                var _a = e.value, k = _a[0], a = _a[1];
                var d2OptA = lookupWithKeyS(k, that);
                if (isNone$2(d2OptA) || !SK.equals(k, d2OptA.value[0]) || !SA.equals(a, d2OptA.value[1])) {
                    return false;
                }
            }
            return true;
        };
    }
    /**
     * @since 2.5.0
     */
    var empty$6 = 
    // the type annotation here is intended (otherwise it doesn't type-check)
    new Map();
    /**
     * @category instances
     * @since 2.5.0
     */
    function getEq$7(SK, SA) {
        var isSubmapSKSA = isSubmap$1(SK, SA);
        return fromEquals(function (x, y) { return isSubmapSKSA(x, y) && isSubmapSKSA(y, x); });
    }
    /**
     * Gets `Monoid` instance for Maps given `Semigroup` instance for their values
     *
     * @category instances
     * @since 2.5.0
     */
    function getMonoid$5(SK, SA) {
        var lookupWithKeyS = lookupWithKey$1(SK);
        return {
            concat: function (mx, my) {
                if (isEmpty$6(mx)) {
                    return my;
                }
                if (isEmpty$6(my)) {
                    return mx;
                }
                var r = new Map(mx);
                var entries = my.entries();
                var e;
                // tslint:disable-next-line: strict-boolean-expressions
                while (!(e = entries.next()).done) {
                    var _a = e.value, k = _a[0], a = _a[1];
                    var mxOptA = lookupWithKeyS(k, mx);
                    if (isSome$2(mxOptA)) {
                        r.set(mxOptA.value[0], SA.concat(mxOptA.value[1], a));
                    }
                    else {
                        r.set(k, a);
                    }
                }
                return r;
            },
            empty: empty$6
        };
    }
    /**
     * Create a map with one key/value pair
     *
     * @category constructors
     * @since 2.5.0
     */
    var singleton$6 = function (k, a) { return new Map([[k, a]]); };
    function fromFoldable$3(E, M, F) {
        return function (fka) {
            var lookupWithKeyE = lookupWithKey$1(E);
            return F.reduce(fka, new Map(), function (b, _a) {
                var k = _a[0], a = _a[1];
                var bOpt = lookupWithKeyE(k, b);
                if (isSome$2(bOpt)) {
                    b.set(bOpt.value[0], M.concat(bOpt.value[1], a));
                }
                else {
                    b.set(k, a);
                }
                return b;
            });
        };
    }
    var _mapWithIndex$3 = function (fa, f) {
        var m = new Map();
        var entries = fa.entries();
        var e;
        // tslint:disable-next-line: strict-boolean-expressions
        while (!(e = entries.next()).done) {
            var _a = e.value, key = _a[0], a = _a[1];
            m.set(key, f(key, a));
        }
        return m;
    };
    /**
     * @category combinators
     * @since 2.10.0
     */
    var partitionMapWithIndex$3 = function (f) { return function (fa) {
        var left = new Map();
        var right = new Map();
        var entries = fa.entries();
        var e;
        // tslint:disable-next-line: strict-boolean-expressions
        while (!(e = entries.next()).done) {
            var _a = e.value, k = _a[0], a = _a[1];
            var ei = f(k, a);
            if (isLeft$3(ei)) {
                left.set(k, ei.left);
            }
            else {
                right.set(k, ei.right);
            }
        }
        return separated(left, right);
    }; };
    function partitionWithIndex$3(predicateWithIndex) {
        return function (m) {
            var left = new Map();
            var right = new Map();
            var entries = m.entries();
            var e;
            // tslint:disable-next-line: strict-boolean-expressions
            while (!(e = entries.next()).done) {
                var _a = e.value, k = _a[0], a = _a[1];
                if (predicateWithIndex(k, a)) {
                    right.set(k, a);
                }
                else {
                    left.set(k, a);
                }
            }
            return separated(left, right);
        };
    }
    /**
     * @category combinators
     * @since 2.10.0
     */
    var filterMapWithIndex$3 = function (f) { return function (fa) {
        var m = new Map();
        var entries = fa.entries();
        var e;
        // tslint:disable-next-line: strict-boolean-expressions
        while (!(e = entries.next()).done) {
            var _a = e.value, k = _a[0], a = _a[1];
            var o = f(k, a);
            if (isSome$2(o)) {
                m.set(k, o.value);
            }
        }
        return m;
    }; };
    function filterWithIndex$3(predicateWithIndex) {
        return function (m) {
            var out = new Map();
            var entries = m.entries();
            var e;
            // tslint:disable-next-line: strict-boolean-expressions
            while (!(e = entries.next()).done) {
                var _a = e.value, k = _a[0], a = _a[1];
                if (predicateWithIndex(k, a)) {
                    out.set(k, a);
                }
            }
            return out;
        };
    }
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _map$i = function (fa, f) { return _mapWithIndex$3(fa, function (_, a) { return f(a); }); };
    var _filter$4 = function (fa, p) {
        return _filterWithIndex$3(fa, function (_, a) { return p(a); });
    };
    var _filterMap$4 = function (fa, f) { return _filterMapWithIndex$3(fa, function (_, a) { return f(a); }); };
    var _partition$4 = function (fa, predicate) {
        return _partitionWithIndex$3(fa, function (_, a) { return predicate(a); });
    };
    var _partitionMap$4 = function (fa, f) { return _partitionMapWithIndex$3(fa, function (_, a) { return f(a); }); };
    var _filterWithIndex$3 = function (fa, p) { return pipe$1(fa, filterWithIndex$3(p)); };
    var _filterMapWithIndex$3 = function (fa, f) {
        return pipe$1(fa, filterMapWithIndex$3(f));
    };
    var _partitionWithIndex$3 = function (fa, p) { return pipe$1(fa, partitionWithIndex$3(p)); };
    var _partitionMapWithIndex$3 = function (fa, f) {
        return pipe$1(fa, partitionMapWithIndex$3(f));
    };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * @category Compactable
     * @since 2.5.0
     */
    var compact$6 = function (fa) {
        var m = new Map();
        var entries = fa.entries();
        var e;
        // tslint:disable-next-line: strict-boolean-expressions
        while (!(e = entries.next()).done) {
            var _a = e.value, k = _a[0], oa = _a[1];
            if (isSome$2(oa)) {
                m.set(k, oa.value);
            }
        }
        return m;
    };
    /**
     * @category Filterable
     * @since 2.5.0
     */
    var filter$6 = function (predicate) { return function (fa) { return _filter$4(fa, predicate); }; };
    /**
     * @category Filterable
     * @since 2.5.0
     */
    var filterMap$6 = function (f) { return function (fa) { return _filterMap$4(fa, f); }; };
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.5.0
     */
    var map$p = function (f) { return function (fa) { return _map$i(fa, f); }; };
    /**
     * @category FunctorWithIndex
     * @since 2.7.1
     */
    var mapWithIndex$3 = function (f) { return function (fa) { return _mapWithIndex$3(fa, f); }; };
    /**
     * @category Filterable
     * @since 2.5.0
     */
    var partition$6 = function (predicate) { return function (fa) { return _partition$4(fa, predicate); }; };
    /**
     * @category Filterable
     * @since 2.5.0
     */
    var partitionMap$6 = function (f) { return function (fa) { return _partitionMap$4(fa, f); }; };
    /**
     * @category Compactable
     * @since 2.5.0
     */
    var separate$6 = function (fa) {
        var left = new Map();
        var right = new Map();
        var entries = fa.entries();
        var e;
        // tslint:disable-next-line: strict-boolean-expressions
        while (!(e = entries.next()).done) {
            var _a = e.value, k = _a[0], ei = _a[1];
            if (isLeft$3(ei)) {
                left.set(k, ei.left);
            }
            else {
                right.set(k, ei.right);
            }
        }
        return separated(left, right);
    };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.5.0
     */
    var URI$j = 'ReadonlyMap';
    /**
     * @category instances
     * @since 2.11.0
     */
    var getUnionSemigroup$5 = function (E, S) {
        var unionES = union$5(E, S);
        return {
            concat: function (first, second) { return unionES(second)(first); }
        };
    };
    /**
     * @category instances
     * @since 2.11.0
     */
    var getUnionMonoid$5 = function (E, S) { return ({
        concat: getUnionSemigroup$5(E, S).concat,
        empty: empty$6
    }); };
    /**
     * @category instances
     * @since 2.11.0
     */
    var getIntersectionSemigroup$5 = function (E, S) {
        var intersectionES = intersection$5(E, S);
        return {
            concat: function (first, second) { return intersectionES(second)(first); }
        };
    };
    /**
     * @category instances
     * @since 2.11.0
     */
    var getDifferenceMagma$5 = function (E) { return function () {
        var differenceE = difference$5(E);
        return {
            concat: function (first, second) { return differenceE(second)(first); }
        };
    }; };
    /**
     * @category instances
     * @since 2.5.0
     */
    function getFilterableWithIndex$1() {
        return {
            URI: URI$j,
            _E: undefined,
            map: _map$i,
            mapWithIndex: _mapWithIndex$3,
            compact: compact$6,
            separate: separate$6,
            filter: _filter$4,
            filterMap: _filterMap$4,
            partition: _partition$4,
            partitionMap: _partitionMap$4,
            partitionMapWithIndex: _partitionMapWithIndex$3,
            partitionWithIndex: _partitionWithIndex$3,
            filterMapWithIndex: _filterMapWithIndex$3,
            filterWithIndex: _filterWithIndex$3
        };
    }
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$j = {
        URI: URI$j,
        map: _map$i
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$j = 
    /*#__PURE__*/
    flap$x(Functor$j);
    /**
     * @category instances
     * @since 2.10.0
     */
    var getFunctorWithIndex = function () { return ({
        URI: URI$j,
        _E: undefined,
        map: _map$i,
        mapWithIndex: _mapWithIndex$3
    }); };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Compactable$4 = {
        URI: URI$j,
        compact: compact$6,
        separate: separate$6
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Filterable$4 = {
        URI: URI$j,
        map: _map$i,
        compact: compact$6,
        separate: separate$6,
        filter: _filter$4,
        filterMap: _filterMap$4,
        partition: _partition$4,
        partitionMap: _partitionMap$4
    };
    /**
     * @since 2.11.0
     */
    var reduce$9 = function (O) {
        var reduceWithIndexO = reduceWithIndex$3(O);
        return function (b, f) { return reduceWithIndexO(b, function (_, b, a) { return f(b, a); }); };
    };
    /**
     * @since 2.11.0
     */
    var foldMap$9 = function (O) {
        var foldMapWithIndexO = foldMapWithIndex$3(O);
        return function (M) {
            var foldMapWithIndexOM = foldMapWithIndexO(M);
            return function (f) { return foldMapWithIndexOM(function (_, a) { return f(a); }); };
        };
    };
    /**
     * @since 2.11.0
     */
    var reduceRight$9 = function (O) {
        var reduceRightWithIndexO = reduceRightWithIndex$3(O);
        return function (b, f) { return reduceRightWithIndexO(b, function (_, b, a) { return f(b, a); }); };
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var getFoldable$3 = function (O) {
        var reduceO = reduce$9(O);
        var foldMapO = foldMap$9(O);
        var reduceRightO = reduceRight$9(O);
        return {
            URI: URI$j,
            _E: undefined,
            reduce: function (fa, b, f) { return pipe$1(fa, reduceO(b, f)); },
            foldMap: function (M) {
                var foldMapOM = foldMapO(M);
                return function (fa, f) { return pipe$1(fa, foldMapOM(f)); };
            },
            reduceRight: function (fa, b, f) { return pipe$1(fa, reduceRightO(b, f)); }
        };
    };
    /**
     * @since 2.11.0
     */
    var reduceWithIndex$3 = function (O) {
        var keysO = keys$4(O);
        return function (b, f) { return function (m) {
            var out = b;
            for (var _i = 0, _a = keysO(m); _i < _a.length; _i++) {
                var k = _a[_i];
                out = f(k, out, m.get(k));
            }
            return out;
        }; };
    };
    /**
     * @since 2.11.0
     */
    var foldMapWithIndex$3 = function (O) {
        var keysO = keys$4(O);
        return function (M) { return function (f) { return function (m) {
            var out = M.empty;
            for (var _i = 0, _a = keysO(m); _i < _a.length; _i++) {
                var k = _a[_i];
                out = M.concat(out, f(k, m.get(k)));
            }
            return out;
        }; }; };
    };
    /**
     * @since 2.11.0
     */
    var reduceRightWithIndex$3 = function (O) {
        var keysO = keys$4(O);
        return function (b, f) { return function (m) {
            var out = b;
            var ks = keysO(m);
            var len = ks.length;
            for (var i = len - 1; i >= 0; i--) {
                var k = ks[i];
                out = f(k, m.get(k), out);
            }
            return out;
        }; };
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var getFoldableWithIndex$3 = function (O) {
        var F = getFoldable$3(O);
        var reduceWithIndexO = reduceWithIndex$3(O);
        var foldMapWithIndexO = foldMapWithIndex$3(O);
        var reduceRightWithIndexO = reduceRightWithIndex$3(O);
        return {
            URI: URI$j,
            _E: undefined,
            reduce: F.reduce,
            foldMap: F.foldMap,
            reduceRight: F.reduceRight,
            reduceWithIndex: function (fa, b, f) { return pipe$1(fa, reduceWithIndexO(b, f)); },
            foldMapWithIndex: function (M) {
                var foldMapWithIndexOM = foldMapWithIndexO(M);
                return function (fa, f) { return pipe$1(fa, foldMapWithIndexOM(f)); };
            },
            reduceRightWithIndex: function (fa, b, f) { return pipe$1(fa, reduceRightWithIndexO(b, f)); }
        };
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var getTraversable$2 = function (O) {
        var TWI = getTraversableWithIndex$3(O);
        var F = getFoldable$3(O);
        return {
            URI: URI$j,
            _E: undefined,
            map: _map$i,
            reduce: F.reduce,
            foldMap: F.foldMap,
            reduceRight: F.reduceRight,
            traverse: TWI.traverse,
            sequence: TWI.sequence
        };
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var getTraversableWithIndex$3 = function (O) {
        var FWI = getFoldableWithIndex$3(O);
        var keysO = keys$4(O);
        var traverseWithIndex = function (F) {
            return function (ta, f) {
                var fm = F.of(new Map());
                var ks = keysO(ta);
                var len = ks.length;
                var _loop_1 = function (i) {
                    var key = ks[i];
                    var a = ta.get(key);
                    fm = F.ap(F.map(fm, function (m) { return function (b) { return m.set(key, b); }; }), f(key, a));
                };
                for (var i = 0; i < len; i++) {
                    _loop_1(i);
                }
                return fm;
            };
        };
        var traverse = function (F) {
            var traverseWithIndexF = traverseWithIndex(F);
            return function (ta, f) { return traverseWithIndexF(ta, function (_, a) { return f(a); }); };
        };
        var sequence = function (F) {
            var traverseWithIndexF = traverseWithIndex(F);
            return function (ta) { return traverseWithIndexF(ta, SK); };
        };
        return {
            URI: URI$j,
            _E: undefined,
            map: _map$i,
            mapWithIndex: _mapWithIndex$3,
            reduce: FWI.reduce,
            foldMap: FWI.foldMap,
            reduceRight: FWI.reduceRight,
            reduceWithIndex: FWI.reduceWithIndex,
            foldMapWithIndex: FWI.foldMapWithIndex,
            reduceRightWithIndex: FWI.reduceRightWithIndex,
            traverse: traverse,
            sequence: sequence,
            traverseWithIndex: traverseWithIndex
        };
    };
    /**
     * @category instances
     * @since 2.5.0
     */
    function getWitherable$3(O) {
        var TWI = getTraversableWithIndex$3(O);
        return {
            URI: URI$j,
            _E: undefined,
            map: _map$i,
            compact: compact$6,
            separate: separate$6,
            filter: _filter$4,
            filterMap: _filterMap$4,
            partition: _partition$4,
            partitionMap: _partitionMap$4,
            reduce: TWI.reduce,
            foldMap: TWI.foldMap,
            reduceRight: TWI.reduceRight,
            traverse: TWI.traverse,
            sequence: TWI.sequence,
            mapWithIndex: _mapWithIndex$3,
            reduceWithIndex: TWI.reduceWithIndex,
            foldMapWithIndex: TWI.foldMapWithIndex,
            reduceRightWithIndex: TWI.reduceRightWithIndex,
            traverseWithIndex: TWI.traverseWithIndex,
            wilt: wiltDefault$1(TWI, Compactable$4),
            wither: witherDefault$1(TWI, Compactable$4)
        };
    }
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var union$5 = function (E, M) {
        var lookupE = lookup$3(E);
        return function (second) { return function (first) {
            if (isEmpty$6(first)) {
                return second;
            }
            if (isEmpty$6(second)) {
                return first;
            }
            var out = new Map();
            var firstEntries = first.entries();
            var e;
            while (!(e = firstEntries.next()).done) {
                var _a = e.value, k = _a[0], a = _a[1];
                var oka = lookupE(k)(second);
                if (isSome$2(oka)) {
                    out.set(k, M.concat(a, oka.value));
                }
                else {
                    out.set(k, a);
                }
            }
            var secondEntries = second.entries();
            while (!(e = secondEntries.next()).done) {
                var _b = e.value, k = _b[0], a = _b[1];
                var oka = lookupE(k)(out);
                if (isNone$2(oka)) {
                    out.set(k, a);
                }
            }
            return out;
        }; };
    };
    /**
     * @since 2.11.0
     */
    var intersection$5 = function (E, M) {
        var lookupE = lookup$3(E);
        return function (second) { return function (first) {
            if (isEmpty$6(first) || isEmpty$6(second)) {
                return empty$6;
            }
            var out = new Map();
            var entries = first.entries();
            var e;
            while (!(e = entries.next()).done) {
                var _a = e.value, k = _a[0], a = _a[1];
                var oka = lookupE(k)(second);
                if (isSome$2(oka)) {
                    out.set(k, M.concat(a, oka.value));
                }
            }
            return out;
        }; };
    };
    /**
     * @since 2.11.0
     */
    var difference$5 = function (E) {
        var memberE = member$1(E);
        return function (second) { return function (first) {
            if (isEmpty$6(first)) {
                return second;
            }
            if (isEmpty$6(second)) {
                return first;
            }
            var out = new Map();
            var firstEntries = first.entries();
            var e;
            while (!(e = firstEntries.next()).done) {
                var _a = e.value, k = _a[0], a = _a[1];
                if (!memberE(k)(second)) {
                    out.set(k, a);
                }
            }
            var secondEntries = second.entries();
            while (!(e = secondEntries.next()).done) {
                var _b = e.value, k = _b[0], a = _b[1];
                if (!memberE(k)(first)) {
                    out.set(k, a);
                }
            }
            return out;
        }; };
    };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use [`upsertAt`](#upsertat) instead.
     *
     * @category combinators
     * @since 2.5.0
     * @deprecated
     */
    var insertAt$3 = upsertAt$3;
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.5.0
     * @deprecated
     */
    var readonlyMap = {
        URI: URI$j,
        map: _map$i,
        compact: compact$6,
        separate: separate$6,
        filter: _filter$4,
        filterMap: _filterMap$4,
        partition: _partition$4,
        partitionMap: _partitionMap$4
    };

    var ReadonlyMap = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fromMap: fromMap,
        toMap: toMap,
        getShow: getShow$7,
        size: size$6,
        isEmpty: isEmpty$6,
        member: member$1,
        elem: elem$7,
        keys: keys$4,
        values: values$1,
        collect: collect$3,
        toReadonlyArray: toReadonlyArray$2,
        toUnfoldable: toUnfoldable$3,
        upsertAt: upsertAt$3,
        deleteAt: deleteAt$3,
        updateAt: updateAt$3,
        modifyAt: modifyAt$3,
        pop: pop$3,
        lookupWithKey: lookupWithKey$1,
        lookup: lookup$3,
        isSubmap: isSubmap$1,
        empty: empty$6,
        getEq: getEq$7,
        getMonoid: getMonoid$5,
        singleton: singleton$6,
        fromFoldable: fromFoldable$3,
        partitionMapWithIndex: partitionMapWithIndex$3,
        partitionWithIndex: partitionWithIndex$3,
        filterMapWithIndex: filterMapWithIndex$3,
        filterWithIndex: filterWithIndex$3,
        compact: compact$6,
        filter: filter$6,
        filterMap: filterMap$6,
        map: map$p,
        mapWithIndex: mapWithIndex$3,
        partition: partition$6,
        partitionMap: partitionMap$6,
        separate: separate$6,
        URI: URI$j,
        getUnionSemigroup: getUnionSemigroup$5,
        getUnionMonoid: getUnionMonoid$5,
        getIntersectionSemigroup: getIntersectionSemigroup$5,
        getDifferenceMagma: getDifferenceMagma$5,
        getFilterableWithIndex: getFilterableWithIndex$1,
        Functor: Functor$j,
        flap: flap$j,
        getFunctorWithIndex: getFunctorWithIndex,
        Compactable: Compactable$4,
        Filterable: Filterable$4,
        reduce: reduce$9,
        foldMap: foldMap$9,
        reduceRight: reduceRight$9,
        getFoldable: getFoldable$3,
        reduceWithIndex: reduceWithIndex$3,
        foldMapWithIndex: foldMapWithIndex$3,
        reduceRightWithIndex: reduceRightWithIndex$3,
        getFoldableWithIndex: getFoldableWithIndex$3,
        getTraversable: getTraversable$2,
        getTraversableWithIndex: getTraversableWithIndex$3,
        getWitherable: getWitherable$3,
        union: union$5,
        intersection: intersection$5,
        difference: difference$5,
        insertAt: insertAt$3,
        readonlyMap: readonlyMap
    });

    var __assign$1 = (undefined && undefined.__assign) || function () {
        __assign$1 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1.apply(this, arguments);
    };
    /**
     * @category instances
     * @since 2.0.0
     */
    var getShow$6 = getShow$7;
    /**
     * Calculate the number of key/value pairs in a map
     *
     * @since 2.0.0
     */
    var size$5 = size$6;
    /**
     * Test whether or not a map is empty
     *
     * @since 2.0.0
     */
    var isEmpty$5 = isEmpty$6;
    // TODO: remove non-curried overloading in v3
    /**
     * Test whether or not a key exists in a map
     *
     * @since 2.0.0
     */
    var member = member$1;
    // TODO: remove non-curried overloading in v3
    /**
     * Test whether or not a value is a member of a map
     *
     * @since 2.0.0
     */
    var elem$6 = elem$7;
    /**
     * Get a sorted `Array` of the keys contained in a `Map`.
     *
     * @since 2.0.0
     */
    var keys$3 = function (O) { return function (m) { return Array.from(m.keys()).sort(O.compare); }; };
    /**
     * Get a sorted `Array` of the values contained in a `Map`.
     *
     * @since 2.0.0
     */
    var values = function (O) { return function (m) { return Array.from(m.values()).sort(O.compare); }; };
    /**
     * @since 2.0.0
     */
    function collect$2(O) {
        var keysO = keys$3(O);
        return function (f) { return function (m) {
            var out = [];
            var ks = keysO(m);
            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
                var key = ks_1[_i];
                out.push(f(key, m.get(key)));
            }
            return out;
        }; };
    }
    /**
     * Get a sorted `Array` of the key/value pairs contained in a `Map`.
     *
     * @since 2.0.0
     */
    function toArray$2(O) {
        return collect$2(O)(function (k, a) { return [k, a]; });
    }
    function toUnfoldable$2(ord, U) {
        var toArrayO = toArray$2(ord);
        return function (d) {
            var kas = toArrayO(d);
            var len = kas.length;
            return U.unfold(0, function (b) { return (b < len ? some$a([kas[b], b + 1]) : none$2); });
        };
    }
    /**
     * Insert or replace a key/value pair in a `Map`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var upsertAt$2 = function (E) {
        var lookupWithKeyE = lookupWithKey(E);
        return function (k, a) {
            var lookupWithKeyEk = lookupWithKeyE(k);
            return function (m) {
                var found = lookupWithKeyEk(m);
                if (isNone$2(found)) {
                    var out = new Map(m);
                    out.set(k, a);
                    return out;
                }
                else if (found.value[1] !== a) {
                    var out = new Map(m);
                    out.set(found.value[0], a);
                    return out;
                }
                return m;
            };
        };
    };
    /**
     * Delete a key and value from a map
     *
     * @category combinators
     * @since 2.0.0
     */
    var deleteAt$2 = function (E) {
        var lookupWithKeyE = lookupWithKey(E);
        return function (k) { return function (m) {
            var found = lookupWithKeyE(k, m);
            if (isSome$2(found)) {
                var r = new Map(m);
                r.delete(found.value[0]);
                return r;
            }
            return m;
        }; };
    };
    /**
     * @since 2.0.0
     */
    var updateAt$2 = function (E) {
        var modifyAtE = modifyAt$2(E);
        return function (k, a) { return modifyAtE(k, function () { return a; }); };
    };
    /**
     * @since 2.0.0
     */
    var modifyAt$2 = function (E) {
        var lookupWithKeyE = lookupWithKey(E);
        return function (k, f) { return function (m) {
            var found = lookupWithKeyE(k, m);
            if (isNone$2(found)) {
                return none$2;
            }
            var r = new Map(m);
            r.set(found.value[0], f(found.value[1]));
            return some$a(r);
        }; };
    };
    /**
     * Delete a key and value from a map, returning the value as well as the subsequent map
     *
     * @since 2.0.0
     */
    function pop$2(E) {
        var lookupE = lookup$2(E);
        var deleteAtE = deleteAt$2(E);
        return function (k) {
            var deleteAtEk = deleteAtE(k);
            return function (m) {
                return pipe$1(lookupE(k, m), map$y(function (a) { return [a, deleteAtEk(m)]; }));
            };
        };
    }
    function lookupWithKey(E) {
        return function (k, m) {
            if (m === undefined) {
                var lookupWithKeyE_1 = lookupWithKey(E);
                return function (m) { return lookupWithKeyE_1(k, m); };
            }
            var entries = m.entries();
            var e;
            // tslint:disable-next-line: strict-boolean-expressions
            while (!(e = entries.next()).done) {
                var _a = e.value, ka = _a[0], a = _a[1];
                if (E.equals(ka, k)) {
                    return some$a([ka, a]);
                }
            }
            return none$2;
        };
    }
    // TODO: remove non-curried overloading in v3
    /**
     * Lookup the value for a key in a `Map`.
     *
     * @since 2.0.0
     */
    var lookup$2 = lookup$3;
    // TODO: remove non-curried overloading in v3
    /**
     * Test whether or not one `Map` contains all of the keys and values contained in another `Map`
     *
     * @since 2.0.0
     */
    var isSubmap = isSubmap$1;
    /**
     * @category instances
     * @since 2.0.0
     */
    var getEq$6 = getEq$7;
    /**
     * Gets `Monoid` instance for Maps given `Semigroup` instance for their values
     *
     * @category instances
     * @since 2.0.0
     */
    function getMonoid$4(SK, SA) {
        var lookupWithKeyS = lookupWithKey(SK);
        return {
            concat: function (mx, my) {
                if (isEmpty$5(mx)) {
                    return my;
                }
                if (isEmpty$5(my)) {
                    return mx;
                }
                var r = new Map(mx);
                var entries = my.entries();
                var e;
                // tslint:disable-next-line: strict-boolean-expressions
                while (!(e = entries.next()).done) {
                    var _a = e.value, k = _a[0], a = _a[1];
                    var mxOptA = lookupWithKeyS(k, mx);
                    if (isSome$2(mxOptA)) {
                        r.set(mxOptA.value[0], SA.concat(mxOptA.value[1], a));
                    }
                    else {
                        r.set(k, a);
                    }
                }
                return r;
            },
            empty: new Map()
        };
    }
    /**
     * Create a map with one key/value pair
     *
     * @since 2.0.0
     */
    var singleton$5 = function (k, a) { return new Map([[k, a]]); };
    function fromFoldable$2(E, M, F) {
        return function (fka) {
            var lookupWithKeyE = lookupWithKey(E);
            return F.reduce(fka, new Map(), function (b, _a) {
                var k = _a[0], a = _a[1];
                var bOpt = lookupWithKeyE(k, b);
                if (isSome$2(bOpt)) {
                    b.set(bOpt.value[0], M.concat(bOpt.value[1], a));
                }
                else {
                    b.set(k, a);
                }
                return b;
            });
        };
    }
    var _mapWithIndex$2 = function (fa, f) {
        var m = new Map();
        var entries = fa.entries();
        var e;
        // tslint:disable-next-line: strict-boolean-expressions
        while (!(e = entries.next()).done) {
            var _a = e.value, key = _a[0], a = _a[1];
            m.set(key, f(key, a));
        }
        return m;
    };
    /**
     * @category combinators
     * @since 2.10.0
     */
    var partitionMapWithIndex$2 = function (f) { return function (fa) {
        var left = new Map();
        var right = new Map();
        var entries = fa.entries();
        var e;
        // tslint:disable-next-line: strict-boolean-expressions
        while (!(e = entries.next()).done) {
            var _a = e.value, k = _a[0], a = _a[1];
            var ei = f(k, a);
            if (isLeft$3(ei)) {
                left.set(k, ei.left);
            }
            else {
                right.set(k, ei.right);
            }
        }
        return separated(left, right);
    }; };
    function partitionWithIndex$2(predicateWithIndex) {
        return function (fa) {
            var left = new Map();
            var right = new Map();
            var entries = fa.entries();
            var e;
            // tslint:disable-next-line: strict-boolean-expressions
            while (!(e = entries.next()).done) {
                var _a = e.value, k = _a[0], a = _a[1];
                if (predicateWithIndex(k, a)) {
                    right.set(k, a);
                }
                else {
                    left.set(k, a);
                }
            }
            return separated(left, right);
        };
    }
    /**
     * @category combinators
     * @since 2.10.0
     */
    var filterMapWithIndex$2 = function (f) { return function (fa) {
        var m = new Map();
        var entries = fa.entries();
        var e;
        // tslint:disable-next-line: strict-boolean-expressions
        while (!(e = entries.next()).done) {
            var _a = e.value, k = _a[0], a = _a[1];
            var o = f(k, a);
            if (isSome$2(o)) {
                m.set(k, o.value);
            }
        }
        return m;
    }; };
    function filterWithIndex$2(p) {
        return function (m) {
            var out = new Map();
            var entries = m.entries();
            var e;
            // tslint:disable-next-line: strict-boolean-expressions
            while (!(e = entries.next()).done) {
                var _a = e.value, k = _a[0], a = _a[1];
                if (p(k, a)) {
                    out.set(k, a);
                }
            }
            return out;
        };
    }
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _map$h = function (fa, f) { return _mapWithIndex$2(fa, function (_, a) { return f(a); }); };
    var _filter$3 = function (fa, p) {
        return _filterWithIndex$2(fa, function (_, a) { return p(a); });
    };
    var _filterMap$3 = function (fa, f) { return _filterMapWithIndex$2(fa, function (_, a) { return f(a); }); };
    var _partition$3 = function (fa, predicate) {
        return _partitionWithIndex$2(fa, function (_, a) { return predicate(a); });
    };
    var _partitionMap$3 = function (fa, f) { return _partitionMapWithIndex$2(fa, function (_, a) { return f(a); }); };
    var _filterWithIndex$2 = function (fa, p) { return pipe$1(fa, filterWithIndex$2(p)); };
    var _filterMapWithIndex$2 = function (fa, f) { return pipe$1(fa, filterMapWithIndex$2(f)); };
    var _partitionWithIndex$2 = function (fa, p) { return pipe$1(fa, partitionWithIndex$2(p)); };
    var _partitionMapWithIndex$2 = function (fa, f) {
        return pipe$1(fa, partitionMapWithIndex$2(f));
    };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * @category Compactable
     * @since 2.0.0
     */
    var compact$5 = function (fa) {
        var m = new Map();
        var entries = fa.entries();
        var e;
        // tslint:disable-next-line: strict-boolean-expressions
        while (!(e = entries.next()).done) {
            var _a = e.value, k = _a[0], oa = _a[1];
            if (isSome$2(oa)) {
                m.set(k, oa.value);
            }
        }
        return m;
    };
    /**
     * @category Filterable
     * @since 2.0.0
     */
    var filter$5 = function (predicate) { return function (fa) { return _filter$3(fa, predicate); }; };
    /**
     * @category Filterable
     * @since 2.0.0
     */
    var filterMap$5 = function (f) { return function (fa) {
        return _filterMap$3(fa, f);
    }; };
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$o = function (f) { return function (fa) { return _map$h(fa, f); }; };
    /**
     * @category FunctorWithIndex
     * @since 2.7.1
     */
    var mapWithIndex$2 = function (f) { return function (fa) {
        return _mapWithIndex$2(fa, f);
    }; };
    /**
     * @category Filterable
     * @since 2.0.0
     */
    var partition$5 = function (predicate) { return function (fa) { return _partition$3(fa, predicate); }; };
    /**
     * @category Filterable
     * @since 2.0.0
     */
    var partitionMap$5 = function (f) { return function (fa) { return _partitionMap$3(fa, f); }; };
    /**
     * @category Compactable
     * @since 2.0.0
     */
    var separate$5 = function (fa) {
        var left = new Map();
        var right = new Map();
        var entries = fa.entries();
        var e;
        // tslint:disable-next-line: strict-boolean-expressions
        while (!(e = entries.next()).done) {
            var _a = e.value, k = _a[0], ei = _a[1];
            if (isLeft$3(ei)) {
                left.set(k, ei.left);
            }
            else {
                right.set(k, ei.right);
            }
        }
        return separated(left, right);
    };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$i = 'Map';
    /**
     * @category instances
     * @since 2.11.0
     */
    var getUnionSemigroup$4 = function (E, S) {
        var unionES = union$4(E, S);
        return {
            concat: function (first, second) { return unionES(second)(first); }
        };
    };
    /**
     * @category instances
     * @since 2.11.0
     */
    var getUnionMonoid$4 = function (E, S) { return ({
        concat: getUnionSemigroup$4(E, S).concat,
        empty: new Map()
    }); };
    /**
     * @category instances
     * @since 2.11.0
     */
    var getIntersectionSemigroup$4 = function (E, S) {
        var intersectionES = intersection$4(E, S);
        return {
            concat: function (first, second) { return intersectionES(second)(first); }
        };
    };
    /**
     * @category instances
     * @since 2.11.0
     */
    var getDifferenceMagma$4 = function (E) { return function () {
        var differenceE = difference$4(E);
        return {
            concat: function (first, second) { return differenceE(second)(first); }
        };
    }; };
    /**
     * @category instances
     * @since 2.0.0
     */
    function getFilterableWithIndex() {
        return {
            URI: URI$i,
            _E: undefined,
            map: _map$h,
            mapWithIndex: _mapWithIndex$2,
            compact: compact$5,
            separate: separate$5,
            filter: _filter$3,
            filterMap: _filterMap$3,
            partition: _partition$3,
            partitionMap: _partitionMap$3,
            partitionMapWithIndex: _partitionMapWithIndex$2,
            partitionWithIndex: _partitionWithIndex$2,
            filterMapWithIndex: _filterMapWithIndex$2,
            filterWithIndex: _filterWithIndex$2
        };
    }
    /**
     * @category instances
     * @since 2.0.0
     */
    function getWitherable$2(O) {
        var TWI = getTraversableWithIndex$2(O);
        return {
            URI: URI$i,
            _E: undefined,
            map: _map$h,
            compact: compact$5,
            separate: separate$5,
            filter: _filter$3,
            filterMap: _filterMap$3,
            partition: _partition$3,
            partitionMap: _partitionMap$3,
            reduce: TWI.reduce,
            foldMap: TWI.foldMap,
            reduceRight: TWI.reduceRight,
            traverse: TWI.traverse,
            sequence: TWI.sequence,
            mapWithIndex: _mapWithIndex$2,
            reduceWithIndex: TWI.reduceWithIndex,
            foldMapWithIndex: TWI.foldMapWithIndex,
            reduceRightWithIndex: TWI.reduceRightWithIndex,
            traverseWithIndex: TWI.traverseWithIndex,
            wilt: wiltDefault$1(TWI, Compactable$3),
            wither: witherDefault$1(TWI, Compactable$3)
        };
    }
    /**
     * @since 2.11.0
     */
    var reduce$8 = reduce$9;
    /**
     * @since 2.11.0
     */
    var foldMap$8 = foldMap$9;
    /**
     * @since 2.11.0
     */
    var reduceRight$8 = reduceRight$9;
    /**
     * @category instances
     * @since 2.11.0
     */
    var getFoldable$2 = function (O) {
        return __assign$1(__assign$1({}, getFoldable$3(O)), { URI: URI$i });
    };
    /**
     * @since 2.11.0
     */
    var reduceWithIndex$2 = reduceWithIndex$3;
    /**
     * @since 2.11.0
     */
    var foldMapWithIndex$2 = foldMapWithIndex$3;
    /**
     * @since 2.11.0
     */
    var reduceRightWithIndex$2 = reduceRightWithIndex$3;
    /**
     * @category instances
     * @since 2.10.0
     */
    var getFoldableWithIndex$2 = function (O) {
        return __assign$1(__assign$1({}, getFoldableWithIndex$3(O)), { URI: URI$i });
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var getTraversableWithIndex$2 = function (O) {
        var FWI = getFoldableWithIndex$2(O);
        var keysO = keys$3(O);
        var traverseWithIndex = function (F) {
            return function (ta, f) {
                var fm = F.of(new Map());
                var ks = keysO(ta);
                var len = ks.length;
                var _loop_1 = function (i) {
                    var key = ks[i];
                    var a = ta.get(key);
                    fm = F.ap(F.map(fm, function (m) { return function (b) { return m.set(key, b); }; }), f(key, a));
                };
                for (var i = 0; i < len; i++) {
                    _loop_1(i);
                }
                return fm;
            };
        };
        var traverse = function (F) {
            var traverseWithIndexF = traverseWithIndex(F);
            return function (ta, f) { return traverseWithIndexF(ta, function (_, a) { return f(a); }); };
        };
        var sequence = function (F) {
            var traverseWithIndexF = traverseWithIndex(F);
            return function (ta) { return traverseWithIndexF(ta, function (_, a) { return a; }); };
        };
        return {
            URI: URI$i,
            _E: undefined,
            map: _map$h,
            mapWithIndex: _mapWithIndex$2,
            reduce: FWI.reduce,
            foldMap: FWI.foldMap,
            reduceRight: FWI.reduceRight,
            reduceWithIndex: FWI.reduceWithIndex,
            foldMapWithIndex: FWI.foldMapWithIndex,
            reduceRightWithIndex: FWI.reduceRightWithIndex,
            traverse: traverse,
            sequence: sequence,
            traverseWithIndex: traverseWithIndex
        };
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$i = {
        URI: URI$i,
        map: _map$h
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$i = 
    /*#__PURE__*/
    flap$x(Functor$i);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Compactable$3 = {
        URI: URI$i,
        compact: compact$5,
        separate: separate$5
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Filterable$3 = {
        URI: URI$i,
        map: _map$h,
        compact: compact$5,
        separate: separate$5,
        filter: _filter$3,
        filterMap: _filterMap$3,
        partition: _partition$3,
        partitionMap: _partitionMap$3
    };
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    var copy = function (m) { return new Map(m); };
    /**
     * @since 2.11.0
     */
    var union$4 = function (E, M) {
        var unionEM = union$5(E, M);
        return function (second) { return function (first) {
            if (isEmpty$5(first)) {
                return copy(second);
            }
            if (isEmpty$5(second)) {
                return copy(first);
            }
            return unionEM(second)(first);
        }; };
    };
    /**
     * @since 2.11.0
     */
    var intersection$4 = function (E, M) {
        var intersectionEM = intersection$5(E, M);
        return function (second) { return function (first) {
            if (isEmpty$5(first) || isEmpty$5(second)) {
                return new Map();
            }
            return intersectionEM(second)(first);
        }; };
    };
    /**
     * @since 2.11.0
     */
    var difference$4 = function (E) {
        var differenceE = difference$5(E);
        return function (second) { return function (first) {
            if (isEmpty$5(first)) {
                return copy(second);
            }
            if (isEmpty$5(second)) {
                return copy(first);
            }
            return differenceE(second)(first);
        }; };
    };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use a `new Map()` instead.
     *
     * @since 2.0.0
     * @deprecated
     */
    var empty$5 = new Map();
    /**
     * Use [`upsertAt`](#upsertat) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    var insertAt$2 = upsertAt$2;
    /**
     * Use [`Filterable`](#filterable) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var map_ = Filterable$3;

    var Map$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getShow: getShow$6,
        size: size$5,
        isEmpty: isEmpty$5,
        member: member,
        elem: elem$6,
        keys: keys$3,
        values: values,
        collect: collect$2,
        toArray: toArray$2,
        toUnfoldable: toUnfoldable$2,
        upsertAt: upsertAt$2,
        deleteAt: deleteAt$2,
        updateAt: updateAt$2,
        modifyAt: modifyAt$2,
        pop: pop$2,
        lookupWithKey: lookupWithKey,
        lookup: lookup$2,
        isSubmap: isSubmap,
        getEq: getEq$6,
        getMonoid: getMonoid$4,
        singleton: singleton$5,
        fromFoldable: fromFoldable$2,
        partitionMapWithIndex: partitionMapWithIndex$2,
        partitionWithIndex: partitionWithIndex$2,
        filterMapWithIndex: filterMapWithIndex$2,
        filterWithIndex: filterWithIndex$2,
        compact: compact$5,
        filter: filter$5,
        filterMap: filterMap$5,
        map: map$o,
        mapWithIndex: mapWithIndex$2,
        partition: partition$5,
        partitionMap: partitionMap$5,
        separate: separate$5,
        URI: URI$i,
        getUnionSemigroup: getUnionSemigroup$4,
        getUnionMonoid: getUnionMonoid$4,
        getIntersectionSemigroup: getIntersectionSemigroup$4,
        getDifferenceMagma: getDifferenceMagma$4,
        getFilterableWithIndex: getFilterableWithIndex,
        getWitherable: getWitherable$2,
        reduce: reduce$8,
        foldMap: foldMap$8,
        reduceRight: reduceRight$8,
        getFoldable: getFoldable$2,
        reduceWithIndex: reduceWithIndex$2,
        foldMapWithIndex: foldMapWithIndex$2,
        reduceRightWithIndex: reduceRightWithIndex$2,
        getFoldableWithIndex: getFoldableWithIndex$2,
        getTraversableWithIndex: getTraversableWithIndex$2,
        Functor: Functor$i,
        flap: flap$i,
        Compactable: Compactable$3,
        Filterable: Filterable$3,
        union: union$4,
        intersection: intersection$4,
        difference: difference$4,
        empty: empty$5,
        insertAt: insertAt$2,
        map_: map_
    });

    /**
     * A meet-semilattice (or lower semilattice) is a semilattice whose operation is called `meet`, and which can be thought
     * of as a greatest lower bound.
     *
     * A `MeetSemilattice` must satisfy the following laws:
     *
     * - Associativity: `a ∧ (b ∧ c) <-> (a ∧ b) ∧ c`
     * - Commutativity: `a ∧ b <-> b ∧ a`
     * - Idempotency:   `a ∧ a <-> a`
     *
     * @since 2.0.0
     */

    var MeetSemilattice = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    var Monad$8 = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    var MonadIO$6 = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    var MonadTask$6 = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    var MonadThrow$4 = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * Get a monoid where `concat` will return the minimum, based on the provided bounded order.
     *
     * The `empty` value is the `top` value.
     *
     * @example
     * import * as N from 'fp-ts/number'
     * import * as M from 'fp-ts/Monoid'
     *
     * const M1 = M.min(N.Bounded)
     *
     * assert.deepStrictEqual(M1.concat(1, 2), 1)
     *
     * @category constructors
     * @since 2.10.0
     */
    var min = function (B) { return ({
        concat: min$3(B).concat,
        empty: B.top
    }); };
    /**
     * Get a monoid where `concat` will return the maximum, based on the provided bounded order.
     *
     * The `empty` value is the `bottom` value.
     *
     * @example
     * import * as N from 'fp-ts/number'
     * import * as M from 'fp-ts/Monoid'
     *
     * const M1 = M.max(N.Bounded)
     *
     * assert.deepStrictEqual(M1.concat(1, 2), 2)
     *
     * @category constructors
     * @since 2.10.0
     */
    var max = function (B) { return ({
        concat: max$3(B).concat,
        empty: B.bottom
    }); };
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * The dual of a `Monoid`, obtained by swapping the arguments of `concat`.
     *
     * @example
     * import { reverse } from 'fp-ts/Monoid'
     * import * as S from 'fp-ts/string'
     *
     * assert.deepStrictEqual(reverse(S.Monoid).concat('a', 'b'), 'ba')
     *
     * @category combinators
     * @since 2.10.0
     */
    var reverse$2 = function (M) { return ({
        concat: reverse$8(M).concat,
        empty: M.empty
    }); };
    /**
     * Given a struct of monoids returns a monoid for the struct.
     *
     * @example
     * import { struct } from 'fp-ts/Monoid'
     * import * as N from 'fp-ts/number'
     *
     * interface Point {
     *   readonly x: number
     *   readonly y: number
     * }
     *
     * const M = struct<Point>({
     *   x: N.MonoidSum,
     *   y: N.MonoidSum
     * })
     *
     * assert.deepStrictEqual(M.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })
     *
     * @category combinators
     * @since 2.10.0
     */
    var struct$2 = function (monoids) {
        var empty = {};
        for (var k in monoids) {
            if (has$4.call(monoids, k)) {
                empty[k] = monoids[k].empty;
            }
        }
        return {
            concat: struct$3(monoids).concat,
            empty: empty
        };
    };
    /**
     * Given a tuple of monoids returns a monoid for the tuple.
     *
     * @example
     * import { tuple } from 'fp-ts/Monoid'
     * import * as B from 'fp-ts/boolean'
     * import * as N from 'fp-ts/number'
     * import * as S from 'fp-ts/string'
     *
     * const M1 = tuple(S.Monoid, N.MonoidSum)
     * assert.deepStrictEqual(M1.concat(['a', 1], ['b', 2]), ['ab', 3])
     *
     * const M2 = tuple(S.Monoid, N.MonoidSum, B.MonoidAll)
     * assert.deepStrictEqual(M2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])
     *
     * @category combinators
     * @since 2.10.0
     */
    var tuple$3 = function () {
        var monoids = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            monoids[_i] = arguments[_i];
        }
        return ({
            concat: tuple$4.apply(Se, monoids).concat,
            empty: monoids.map(function (m) { return m.empty; })
        });
    };
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * Given a sequence of `as`, concat them and return the total.
     *
     * If `as` is empty, return the monoid `empty` value.
     *
     * @example
     * import { concatAll } from 'fp-ts/Monoid'
     * import * as N from 'fp-ts/number'
     *
     * assert.deepStrictEqual(concatAll(N.MonoidSum)([1, 2, 3]), 6)
     * assert.deepStrictEqual(concatAll(N.MonoidSum)([]), 0)
     *
     * @since 2.10.0
     */
    var concatAll$1 = function (M) { return concatAll$4(M)(M.empty); };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use [`Monoid`](./void.ts.html#monoid) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var monoidVoid = {
        concat: semigroupVoid.concat,
        empty: undefined
    };
    /**
     * Use [`tuple`](#tuple) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    var getTupleMonoid = tuple$3;
    /**
     * Use [`struct`](#struct) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    var getStructMonoid = struct$2;
    /**
     * Use [`reverse`](#reverse) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    var getDualMonoid = reverse$2;
    /**
     * Use [`max`](#max) instead.
     *
     * @category constructors
     * @since 2.0.0
     * @deprecated
     */
    var getJoinMonoid = max;
    /**
     * Use [`min`](#min) instead.
     *
     * @category constructors
     * @since 2.0.0
     * @deprecated
     */
    var getMeetMonoid = min;
    /**
     * Use [`concatAll`](#concatall) instead.
     *
     * @since 2.0.0
     * @deprecated
     */
    var fold$7 = concatAll$1;
    /**
     * Use [`MonoidAll`](./boolean.ts.html#monoidall) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var monoidAll = {
        concat: semigroupAll.concat,
        empty: true
    };
    /**
     * Use [`MonoidAny`](./boolean.ts.html#monoidany) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var monoidAny = {
        concat: semigroupAny.concat,
        empty: false
    };
    /**
     * Use [`getMonoid`](./function.ts.html#getmonoid) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getFunctionMonoid = getMonoid$f;
    /**
     * Use [`getEndomorphismMonoid`](./function.ts.html#getendomorphismmonoid) instead.
     *
     * **Note**. The execution order in [`getEndomorphismMonoid`](./function.ts.html#getendomorphismmonoid) is reversed.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getEndomorphismMonoid = function () { return reverse$2(getMonoid$8()); };
    /**
     * Use [`Monoid`](./string.ts.html#monoid) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var monoidString = {
        concat: semigroupString.concat,
        empty: ''
    };
    /**
     * Use [`MonoidSum`](./number.ts.html#monoidsum) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var monoidSum = {
        concat: semigroupSum.concat,
        empty: 0
    };
    /**
     * Use [`MonoidProduct`](./number.ts.html#monoidproduct) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var monoidProduct = {
        concat: semigroupProduct.concat,
        empty: 1
    };

    var Monoid$3 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        min: min,
        max: max,
        reverse: reverse$2,
        struct: struct$2,
        tuple: tuple$3,
        concatAll: concatAll$1,
        monoidVoid: monoidVoid,
        getTupleMonoid: getTupleMonoid,
        getStructMonoid: getStructMonoid,
        getDualMonoid: getDualMonoid,
        getJoinMonoid: getJoinMonoid,
        getMeetMonoid: getMeetMonoid,
        fold: fold$7,
        monoidAll: monoidAll,
        monoidAny: monoidAny,
        getFunctionMonoid: getFunctionMonoid,
        getEndomorphismMonoid: getEndomorphismMonoid,
        monoidString: monoidString,
        monoidSum: monoidSum,
        monoidProduct: monoidProduct
    });

    var NaturalTransformation = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    function some$6(F) {
        return flow(some$7, F.of);
    }
    function zero$2(F) {
        return constant$1(F.of(none$1));
    }
    function fromF$1(F) {
        return function (ma) { return F.map(ma, some$7); };
    }
    function fromNullable$1(F) {
        return flow(fromNullable$3, F.of);
    }
    function fromNullableK$1(F) {
        var fromNullableF = fromNullable$1(F);
        return function (f) { return flow(f, fromNullableF); };
    }
    function chainNullableK$1(M) {
        var chainM = chain$d(M);
        var fromNullableKM = fromNullableK$1(M);
        return function (f) { return chainM(fromNullableKM(f)); };
    }
    function fromOptionK$9(F) {
        return function (f) { return flow(f, F.of); };
    }
    function chainOptionK$6(M) {
        var chainM = chain$d(M);
        var fromOptionKM = fromOptionK$9(M);
        return function (f) { return chainM(fromOptionKM(f)); };
    }
    function fromPredicate$7(F) {
        return function (predicate) { return function (a) { return F.of(fromPredicate$a(predicate)(a)); }; };
    }
    function fromEither$6(F) {
        return flow(fromEither$8, F.of);
    }
    function match$8(F) {
        return function (onNone, onSome) { return function (ma) { return F.map(ma, match$c(onNone, onSome)); }; };
    }
    function matchE$6(M) {
        return function (onNone, onSome) { return function (ma) { return M.chain(ma, match$c(onNone, onSome)); }; };
    }
    function getOrElse$4(M) {
        return function (onNone) { return function (fa) { return M.chain(fa, match$c(onNone, M.of)); }; };
    }
    function map$n(F) {
        return map$E(F, Functor$r);
    }
    function ap$c(F) {
        return ap$p(F, Apply$9);
    }
    function chain$d(M) {
        var zeroM = zero$2(M);
        return function (f) { return function (ma) {
            return M.chain(ma, match$c(function () { return zeroM(); }, f));
        }; };
    }
    function alt$5(M) {
        var _some = some$6(M);
        return function (second) { return function (first) { return M.chain(first, match$c(second, _some)); }; };
    }
    /** @deprecated */
    function getOptionM(M) {
        var apM = ap$c(M);
        var mapM = map$n(M);
        var chainM = chain$d(M);
        var altM = alt$5(M);
        var foldM = matchE$6(M);
        var getOrElseM = getOrElse$4(M);
        var zeroM = zero$2(M);
        return {
            map: function (fa, f) { return pipe$1(fa, mapM(f)); },
            ap: function (fab, fa) { return pipe$1(fab, apM(fa)); },
            of: some$6(M),
            chain: function (ma, f) { return pipe$1(ma, chainM(f)); },
            alt: function (fa, that) { return pipe$1(fa, altM(that)); },
            fold: function (fa, onNone, onSome) { return pipe$1(fa, foldM(onNone, onSome)); },
            getOrElse: function (fa, onNone) { return pipe$1(fa, getOrElseM(onNone)); },
            fromM: fromF$1(M),
            none: function () { return zeroM(); }
        };
    }

    var OptionT = /*#__PURE__*/Object.freeze({
        __proto__: null,
        some: some$6,
        zero: zero$2,
        fromF: fromF$1,
        fromNullable: fromNullable$1,
        fromNullableK: fromNullableK$1,
        chainNullableK: chainNullableK$1,
        fromOptionK: fromOptionK$9,
        chainOptionK: chainOptionK$6,
        fromPredicate: fromPredicate$7,
        fromEither: fromEither$6,
        match: match$8,
        matchE: matchE$6,
        getOrElse: getOrElse$4,
        map: map$n,
        ap: ap$c,
        chain: chain$d,
        alt: alt$5,
        getOptionM: getOptionM
    });

    // -------------------------------------------------------------------------------------
    // destructors
    // -------------------------------------------------------------------------------------
    /**
     * @category destructors
     * @since 2.10.0
     */
    var match$7 = function (onLessThan, onEqual, onGreaterThan) { return function (o) {
        return o === -1 ? onLessThan() : o === 0 ? onEqual() : onGreaterThan();
    }; };
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * @category combinators
     * @since 2.10.0
     */
    var reverse$1 = function (o) { return (o === -1 ? 1 : o === 1 ? -1 : 0); };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.10.0
     */
    var Eq$2 = {
        equals: function (x, y) { return x === y; }
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Semigroup$3 = {
        concat: function (x, y) { return (x !== 0 ? x : y); }
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Monoid$2 = {
        concat: Semigroup$3.concat,
        empty: 0
    };
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.0.0
     */
    var sign = function (n) { return (n <= -1 ? -1 : n >= 1 ? 1 : 0); };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use [`reverse`](#reverse) instead.
     *
     * @since 2.0.0
     * @deprecated
     */
    var invert = reverse$1;
    /**
     * Use [`Semigroup`](#semigroup) instead
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var semigroupOrdering = Semigroup$3;
    /**
     * Use [`Eq`](#eq) instead
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var eqOrdering = Eq$2;
    /**
     * Use [`Monoid`](#monoid) instead
     *
     * @category instances
     * @since 2.4.0
     * @deprecated
     */
    var monoidOrdering = Monoid$2;

    var Ordering = /*#__PURE__*/Object.freeze({
        __proto__: null,
        match: match$7,
        reverse: reverse$1,
        Eq: Eq$2,
        Semigroup: Semigroup$3,
        Monoid: Monoid$2,
        sign: sign,
        invert: invert,
        semigroupOrdering: semigroupOrdering,
        eqOrdering: eqOrdering,
        monoidOrdering: monoidOrdering
    });

    var isFunctor$1 = function (I) { return typeof I.map === 'function'; };
    var isContravariant$1 = function (I) { return typeof I.contramap === 'function'; };
    var isFunctorWithIndex$1 = function (I) { return typeof I.mapWithIndex === 'function'; };
    var isApply$1 = function (I) { return typeof I.ap === 'function'; };
    var isChain$1 = function (I) { return typeof I.chain === 'function'; };
    var isBifunctor$1 = function (I) { return typeof I.bimap === 'function'; };
    var isExtend$1 = function (I) { return typeof I.extend === 'function'; };
    var isFoldable$1 = function (I) { return typeof I.reduce === 'function'; };
    var isFoldableWithIndex$1 = function (I) { return typeof I.reduceWithIndex === 'function'; };
    var isAlt$1 = function (I) { return typeof I.alt === 'function'; };
    var isCompactable$1 = function (I) { return typeof I.compact === 'function'; };
    var isFilterable$1 = function (I) { return typeof I.filter === 'function'; };
    var isFilterableWithIndex$1 = function (I) {
        return typeof I.filterWithIndex === 'function';
    };
    var isProfunctor$1 = function (I) { return typeof I.promap === 'function'; };
    var isSemigroupoid$1 = function (I) { return typeof I.compose === 'function'; };
    var isMonadThrow$1 = function (I) { return typeof I.throwError === 'function'; };
    /** @deprecated */
    function pipeable$2(I) {
        var r = {};
        if (isFunctor$1(I)) {
            var map = function (f) { return function (fa) { return I.map(fa, f); }; };
            r.map = map;
        }
        if (isContravariant$1(I)) {
            var contramap = function (f) { return function (fa) { return I.contramap(fa, f); }; };
            r.contramap = contramap;
        }
        if (isFunctorWithIndex$1(I)) {
            var mapWithIndex = function (f) { return function (fa) { return I.mapWithIndex(fa, f); }; };
            r.mapWithIndex = mapWithIndex;
        }
        if (isApply$1(I)) {
            var ap = function (fa) { return function (fab) { return I.ap(fab, fa); }; };
            var apFirst = function (fb) { return function (fa) {
                return I.ap(I.map(fa, function (a) { return function () { return a; }; }), fb);
            }; };
            r.ap = ap;
            r.apFirst = apFirst;
            r.apSecond = function (fb) { return function (fa) {
                return I.ap(I.map(fa, function () { return function (b) { return b; }; }), fb);
            }; };
        }
        if (isChain$1(I)) {
            var chain = function (f) { return function (ma) { return I.chain(ma, f); }; };
            var chainFirst = function (f) { return function (ma) { return I.chain(ma, function (a) { return I.map(f(a), function () { return a; }); }); }; };
            var flatten = function (mma) { return I.chain(mma, identity$1); };
            r.chain = chain;
            r.chainFirst = chainFirst;
            r.flatten = flatten;
        }
        if (isBifunctor$1(I)) {
            var bimap = function (f, g) { return function (fa) { return I.bimap(fa, f, g); }; };
            var mapLeft = function (f) { return function (fa) { return I.mapLeft(fa, f); }; };
            r.bimap = bimap;
            r.mapLeft = mapLeft;
        }
        if (isExtend$1(I)) {
            var extend = function (f) { return function (wa) { return I.extend(wa, f); }; };
            var duplicate = function (wa) { return I.extend(wa, identity$1); };
            r.extend = extend;
            r.duplicate = duplicate;
        }
        if (isFoldable$1(I)) {
            var reduce = function (b, f) { return function (fa) { return I.reduce(fa, b, f); }; };
            var foldMap = function (M) {
                var foldMapM = I.foldMap(M);
                return function (f) { return function (fa) { return foldMapM(fa, f); }; };
            };
            var reduceRight = function (b, f) { return function (fa) { return I.reduceRight(fa, b, f); }; };
            r.reduce = reduce;
            r.foldMap = foldMap;
            r.reduceRight = reduceRight;
        }
        if (isFoldableWithIndex$1(I)) {
            var reduceWithIndex = function (b, f) { return function (fa) {
                return I.reduceWithIndex(fa, b, f);
            }; };
            var foldMapWithIndex = function (M) {
                var foldMapM = I.foldMapWithIndex(M);
                return function (f) { return function (fa) { return foldMapM(fa, f); }; };
            };
            var reduceRightWithIndex = function (b, f) { return function (fa) {
                return I.reduceRightWithIndex(fa, b, f);
            }; };
            r.reduceWithIndex = reduceWithIndex;
            r.foldMapWithIndex = foldMapWithIndex;
            r.reduceRightWithIndex = reduceRightWithIndex;
        }
        if (isAlt$1(I)) {
            var alt = function (that) { return function (fa) { return I.alt(fa, that); }; };
            r.alt = alt;
        }
        if (isCompactable$1(I)) {
            r.compact = I.compact;
            r.separate = I.separate;
        }
        if (isFilterable$1(I)) {
            var filter = function (predicate) { return function (fa) {
                return I.filter(fa, predicate);
            }; };
            var filterMap = function (f) { return function (fa) { return I.filterMap(fa, f); }; };
            var partition = function (predicate) { return function (fa) {
                return I.partition(fa, predicate);
            }; };
            var partitionMap = function (f) { return function (fa) { return I.partitionMap(fa, f); }; };
            r.filter = filter;
            r.filterMap = filterMap;
            r.partition = partition;
            r.partitionMap = partitionMap;
        }
        if (isFilterableWithIndex$1(I)) {
            var filterWithIndex = function (predicateWithIndex) { return function (fa) { return I.filterWithIndex(fa, predicateWithIndex); }; };
            var filterMapWithIndex = function (f) { return function (fa) {
                return I.filterMapWithIndex(fa, f);
            }; };
            var partitionWithIndex = function (predicateWithIndex) { return function (fa) { return I.partitionWithIndex(fa, predicateWithIndex); }; };
            var partitionMapWithIndex = function (f) { return function (fa) {
                return I.partitionMapWithIndex(fa, f);
            }; };
            r.filterWithIndex = filterWithIndex;
            r.filterMapWithIndex = filterMapWithIndex;
            r.partitionWithIndex = partitionWithIndex;
            r.partitionMapWithIndex = partitionMapWithIndex;
        }
        if (isProfunctor$1(I)) {
            var promap = function (f, g) { return function (fa) { return I.promap(fa, f, g); }; };
            r.promap = promap;
        }
        if (isSemigroupoid$1(I)) {
            var compose = function (that) { return function (fa) { return I.compose(fa, that); }; };
            r.compose = compose;
        }
        if (isMonadThrow$1(I)) {
            var fromOption = function (onNone) { return function (ma) {
                return ma._tag === 'None' ? I.throwError(onNone()) : I.of(ma.value);
            }; };
            var fromEither = function (ma) {
                return ma._tag === 'Left' ? I.throwError(ma.left) : I.of(ma.right);
            };
            var fromPredicate = function (predicate, onFalse) { return function (a) { return (predicate(a) ? I.of(a) : I.throwError(onFalse(a))); }; };
            var filterOrElse = function (predicate, onFalse) { return function (ma) { return I.chain(ma, function (a) { return (predicate(a) ? I.of(a) : I.throwError(onFalse(a))); }); }; };
            r.fromOption = fromOption;
            r.fromEither = fromEither;
            r.fromPredicate = fromPredicate;
            r.filterOrElse = filterOrElse;
        }
        return r;
    }
    /**
     * Use [`pipe`](https://gcanti.github.io/fp-ts/modules/function.ts.html#flow) from `function` module instead.
     *
     * @since 2.0.0
     * @deprecated
     */
    var pipe = pipe$1;

    var pipeable$3 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        pipeable: pipeable$2,
        pipe: pipe
    });

    var Pointed$a = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    var Profunctor = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    /**
     * @since 2.0.0
     */
    /**
     * Returns a random number between 0 (inclusive) and 1 (exclusive). This is a direct wrapper around JavaScript's
     * `Math.random()`.
     *
     * @since 2.0.0
     */
    var random = function () { return Math.random(); };
    /**
     * Takes a range specified by `low` (the first argument) and `high` (the second), and returns a random integer uniformly
     * distributed in the closed interval `[low, high]`. It is unspecified what happens if `low > high`, or if either of
     * `low` or `high` is not an integer.
     *
     * @since 2.0.0
     */
    function randomInt(low, high) {
        return pipe$1(random, map$r(function (n) { return Math.floor((high - low + 1) * n + low); }));
    }
    /**
     * Returns a random number between a minimum value (inclusive) and a maximum value (exclusive). It is unspecified what
     * happens if `maximum < minimum`.
     *
     * @since 2.0.0
     */
    function randomRange(min, max) {
        return pipe$1(random, map$r(function (n) { return (max - min) * n + min; }));
    }
    /**
     * Returns a random boolean value with an equal chance of being `true` or `false`
     *
     * @since 2.0.0
     */
    var randomBool = 
    /*#__PURE__*/
    pipe$1(random, map$r(function (n) { return n < 0.5; }));
    /**
     * Returns a random element of a `ReadonlyNonEmptyArray`.
     *
     * @since 2.10.0
     */
    var randomElem = function (as) {
        return pipe$1(randomInt(0, as.length - 1), map$r(function (i) { return as[i]; }));
    };

    var Random = /*#__PURE__*/Object.freeze({
        __proto__: null,
        random: random,
        randomInt: randomInt,
        randomRange: randomRange,
        randomBool: randomBool,
        randomElem: randomElem
    });

    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * @category constructors
     * @since 2.0.0
     */
    var left$7 = 
    /*#__PURE__*/
    left$a(Pointed$f);
    /**
     * @category constructors
     * @since 2.0.0
     */
    var right$7 = 
    /*#__PURE__*/
    right$a(Pointed$f);
    /**
     * @category constructors
     * @since 2.0.0
     */
    var rightReader$2 = 
    /*#__PURE__*/
    rightF$1(Functor$o);
    /**
     * @category constructors
     * @since 2.0.0
     */
    var leftReader$2 = 
    /*#__PURE__*/
    leftF$1(Functor$o);
    // -------------------------------------------------------------------------------------
    // natural transformations
    // -------------------------------------------------------------------------------------
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromEither$5 = of$i;
    /**
     * @category natural transformations
     * @since 2.11.0
     */
    var fromReader$4 = rightReader$2;
    // -------------------------------------------------------------------------------------
    // destructors
    // -------------------------------------------------------------------------------------
    /**
     * @category destructors
     * @since 2.10.0
     */
    var match$6 = 
    /*#__PURE__*/
    match$a(Functor$o);
    /**
     * Less strict version of [`match`](#match).
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchW$5 = match$6;
    /**
     * @category destructors
     * @since 2.10.0
     */
    var matchE$5 = 
    /*#__PURE__*/
    matchE$8(Monad$d);
    /**
     * Alias of [`matchE`](#matche).
     *
     * @category destructors
     * @since 2.0.0
     */
    var fold$6 = matchE$5;
    /**
     * Less strict version of [`matchE`](#matche).
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchEW$4 = matchE$5;
    /**
     * Alias of [`matchEW`](#matchew).
     *
     * @category destructors
     * @since 2.10.0
     */
    var foldW$5 = matchEW$4;
    /**
     * @category destructors
     * @since 2.0.0
     */
    var getOrElse$3 = 
    /*#__PURE__*/
    getOrElse$6(Monad$d);
    /**
     * Less strict version of [`getOrElse`](#getorelse).
     *
     * @category destructors
     * @since 2.6.0
     */
    var getOrElseW$3 = getOrElse$3;
    // -------------------------------------------------------------------------------------
    // interop
    // -------------------------------------------------------------------------------------
    /**
     * @category interop
     * @since 2.10.0
     */
    var toUnion$2 = 
    /*#__PURE__*/
    toUnion$4(Functor$o);
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * Changes the value of the local context during the execution of the action `ma` (similar to `Contravariant`'s
     * `contramap`).
     *
     * @category combinators
     * @since 2.0.0
     */
    var local$3 = local$4;
    /**
     * Less strict version of [`asksReaderEither`](#asksreadereither).
     *
     * @category combinators
     * @since 2.11.0
     */
    var asksReaderEitherW = asksReaderW;
    /**
     * Effectfully accesses the environment.
     *
     * @category combinators
     * @since 2.11.0
     */
    var asksReaderEither = asksReaderEitherW;
    /**
     * @category combinators
     * @since 2.0.0
     */
    var orElse$2 = 
    /*#__PURE__*/
    orElse$4(Monad$d);
    /**
     * Less strict version of [`orElse`](#orelse).
     *
     * @category combinators
     * @since 2.10.0
     */
    var orElseW$2 = orElse$2;
    /**
     * @category combinators
     * @since 2.11.0
     */
    var orElseFirst$2 = 
    /*#__PURE__*/
    orElseFirst$4(Monad$d);
    /**
     * @category combinators
     * @since 2.11.0
     */
    var orElseFirstW$2 = orElseFirst$2;
    /**
     * @category combinators
     * @since 2.11.0
     */
    var orLeft$2 = 
    /*#__PURE__*/
    orLeft$4(Monad$d);
    /**
     * @category combinators
     * @since 2.0.0
     */
    var swap$7 = 
    /*#__PURE__*/
    swap$9(Functor$o);
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    /* istanbul ignore next */
    var _map$g = function (fa, f) { return pipe$1(fa, map$m(f)); };
    /* istanbul ignore next */
    var _bimap$7 = function (fa, f, g) { return pipe$1(fa, bimap$8(f, g)); };
    /* istanbul ignore next */
    var _mapLeft$7 = function (fa, f) { return pipe$1(fa, mapLeft$8(f)); };
    /* istanbul ignore next */
    var _ap$3 = function (fab, fa) { return pipe$1(fab, ap$b(fa)); };
    /* istanbul ignore next */
    var _chain$7 = function (ma, f) { return pipe$1(ma, chain$c(f)); };
    /* istanbul ignore next */
    var _alt$4 = function (fa, that) { return pipe$1(fa, alt$4(that)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$m = 
    /*#__PURE__*/
    map$v(Functor$o);
    /**
     * Map a pair of functions over the two last type arguments of the bifunctor.
     *
     * @category Bifunctor
     * @since 2.0.0
     */
    var bimap$8 = 
    /*#__PURE__*/
    bimap$a(Functor$o);
    /**
     * Map a function over the second type argument of a bifunctor.
     *
     * @category Bifunctor
     * @since 2.0.0
     */
    var mapLeft$8 = 
    /*#__PURE__*/
    mapLeft$a(Functor$o);
    /**
     * Apply a function to an argument under a type constructor.
     *
     * @category Apply
     * @since 2.0.0
     */
    var ap$b = 
    /*#__PURE__*/
    ap$i(Apply$7);
    /**
     * Less strict version of [`ap`](#ap).
     *
     * @category Apply
     * @since 2.8.0
     */
    var apW$4 = ap$b;
    /**
     * @category Pointed
     * @since 2.8.5
     */
    var of$d = right$7;
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category Monad
     * @since 2.0.0
     */
    var chain$c = 
    /*#__PURE__*/
    chain$j(Monad$d);
    /**
     * Less strict version of [`chain`](#chain).
     *
     * @category Monad
     * @since 2.6.0
     */
    var chainW$4 = chain$c;
    /**
     * Less strict version of [`flatten`](#flatten).
     *
     * @category combinators
     * @since 2.11.0
     */
    var flattenW$4 = 
    /*#__PURE__*/
    chainW$4(identity$1);
    /**
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var flatten$7 = flattenW$4;
    /**
     * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
     * types of kind `* -> *`.
     *
     * @category Alt
     * @since 2.0.0
     */
    var alt$4 = 
    /*#__PURE__*/
    alt$8(Monad$d);
    /**
     * Less strict version of [`alt`](#alt).
     *
     * @category Alt
     * @since 2.9.0
     */
    var altW$4 = alt$4;
    /**
     * @category MonadThrow
     * @since 2.7.0
     */
    var throwError$3 = left$7;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$h = 'ReaderEither';
    /**
     * @category instances
     * @since 2.10.0
     */
    var getCompactable$2 = function (M) {
        var C = getCompactable$4(M);
        return {
            URI: URI$h,
            _E: undefined,
            compact: compact$7(Functor$o, C),
            separate: separate$7(Functor$o, C, Functor$p)
        };
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    function getFilterable$2(M) {
        var F = getFilterable$4(M);
        var C = getCompactable$2(M);
        var filter = filter$7(Functor$o, F);
        var filterMap = filterMap$7(Functor$o, F);
        var partition = partition$7(Functor$o, F);
        var partitionMap = partitionMap$7(Functor$o, F);
        return {
            URI: URI$h,
            _E: undefined,
            map: _map$g,
            compact: C.compact,
            separate: C.separate,
            filter: function (fa, predicate) { return pipe$1(fa, filter(predicate)); },
            filterMap: function (fa, f) { return pipe$1(fa, filterMap(f)); },
            partition: function (fa, predicate) { return pipe$1(fa, partition(predicate)); },
            partitionMap: function (fa, f) { return pipe$1(fa, partitionMap(f)); }
        };
    }
    /**
     * @category instances
     * @since 2.7.0
     */
    function getApplicativeReaderValidation(S) {
        var ap = ap$p(Apply$7, getApplicativeValidation(S));
        return {
            URI: URI$h,
            _E: undefined,
            map: _map$g,
            ap: function (fab, fa) { return pipe$1(fab, ap(fa)); },
            of: of$d
        };
    }
    /**
     * @category instances
     * @since 2.7.0
     */
    function getAltReaderValidation(S) {
        var alt = altValidation(Monad$d, S);
        return {
            URI: URI$h,
            _E: undefined,
            map: _map$g,
            alt: function (fa, that) { return pipe$1(fa, alt(that)); }
        };
    }
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$h = {
        URI: URI$h,
        map: _map$g
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$h = 
    /*#__PURE__*/
    flap$x(Functor$h);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$9 = {
        URI: URI$h,
        of: of$d
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Apply$3 = {
        URI: URI$h,
        map: _map$g,
        ap: _ap$3
    };
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apFirst$8 = 
    /*#__PURE__*/
    apFirst$k(Apply$3);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apSecond$8 = 
    /*#__PURE__*/
    apSecond$k(Apply$3);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Applicative$3 = {
        URI: URI$h,
        map: _map$g,
        ap: _ap$3,
        of: of$d
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$9 = {
        URI: URI$h,
        map: _map$g,
        ap: _ap$3,
        chain: _chain$7
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Monad$7 = {
        URI: URI$h,
        map: _map$g,
        ap: _ap$3,
        of: of$d,
        chain: _chain$7
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var chainFirst$8 = 
    /*#__PURE__*/
    chainFirst$k(Chain$9);
    /**
     * Less strict version of [`chainFirst`](#chainfirst)
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.8.0
     */
    var chainFirstW$4 = chainFirst$8;
    /**
     * @category instances
     * @since 2.7.0
     */
    var Bifunctor$7 = {
        URI: URI$h,
        bimap: _bimap$7,
        mapLeft: _mapLeft$7
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Alt$4 = {
        URI: URI$h,
        map: _map$g,
        alt: _alt$4
    };
    /**
     * @category instances
     * @since 2.11.0
     */
    var FromReader$3 = {
        URI: URI$h,
        fromReader: fromReader$4
    };
    /**
     * Reads the current context.
     *
     * @category constructors
     * @since 2.0.0
     */
    var ask$3 = 
    /*#__PURE__*/
    ask$4(FromReader$3);
    /**
     * Projects a value from the global context in a `ReaderEither`.
     *
     * @category constructors
     * @since 2.0.0
     */
    var asks$3 = 
    /*#__PURE__*/
    asks$4(FromReader$3);
    /**
     * @category combinators
     * @since 2.11.0
     */
    var fromReaderK$3 = 
    /*#__PURE__*/
    fromReaderK$4(FromReader$3);
    /**
     * @category combinators
     * @since 2.11.0
     */
    var chainReaderK$3 = 
    /*#__PURE__*/
    chainReaderK$4(FromReader$3, Chain$9);
    /**
     * Less strict version of [`chainReaderK`](#chainreaderk).
     *
     * @category combinators
     * @since 2.11.0
     */
    var chainReaderKW$3 = chainReaderK$3;
    /**
     * @category combinators
     * @since 2.11.0
     */
    var chainFirstReaderK$3 = 
    /*#__PURE__*/
    chainFirstReaderK$4(FromReader$3, Chain$9);
    /**
     * Less strict version of [`chainReaderK`](#chainreaderk).
     *
     * @category combinators
     * @since 2.11.0
     */
    var chainFirstReaderKW$3 = chainFirstReaderK$3;
    /**
     * @category instances
     * @since 2.7.0
     */
    var MonadThrow$3 = {
        URI: URI$h,
        map: _map$g,
        ap: _ap$3,
        of: of$d,
        chain: _chain$7,
        throwError: throwError$3
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromEither$7 = {
        URI: URI$h,
        fromEither: fromEither$5
    };
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromOption$7 = 
    /*#__PURE__*/
    fromOption$c(FromEither$7);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromOptionK$8 = 
    /*#__PURE__*/
    fromOptionK$e(FromEither$7);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainOptionK$5 = 
    /*#__PURE__*/
    chainOptionK$9(FromEither$7, Chain$9);
    /**
     * @category combinators
     * @since 2.4.0
     */
    var chainEitherK$4 = 
    /*#__PURE__*/
    chainEitherK$7(FromEither$7, Chain$9);
    /**
     * Less strict version of [`chainEitherK`](#chaineitherk).
     *
     * @category combinators
     * @since 2.6.1
     */
    var chainEitherKW$3 = chainEitherK$4;
    /**
     * @category constructors
     * @since 2.0.0
     */
    var fromPredicate$6 = 
    /*#__PURE__*/
    fromPredicate$d(FromEither$7);
    /**
     * @category combinators
     * @since 2.0.0
     */
    var filterOrElse$4 = 
    /*#__PURE__*/
    filterOrElse$7(FromEither$7, Chain$9);
    /**
     * Less strict version of [`filterOrElse`](#filterorelse).
     *
     * @category combinators
     * @since 2.9.0
     */
    var filterOrElseW$3 = filterOrElse$4;
    /**
     * @category combinators
     * @since 2.4.0
     */
    var fromEitherK$5 = 
    /*#__PURE__*/
    fromEitherK$a(FromEither$7);
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.9.0
     */
    var Do$6 = 
    /*#__PURE__*/
    of$d(emptyRecord);
    /**
     * @since 2.8.0
     */
    var bindTo$8 = 
    /*#__PURE__*/
    bindTo$k(Functor$h);
    /**
     * @since 2.8.0
     */
    var bind$a = 
    /*#__PURE__*/
    bind$m(Chain$9);
    /**
     * @since 2.8.0
     */
    var bindW$4 = bind$a;
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var apS$8 = 
    /*#__PURE__*/
    apS$k(Apply$3);
    /**
     * @since 2.8.0
     */
    var apSW$4 = apS$8;
    // -------------------------------------------------------------------------------------
    // sequence T
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var ApT$7 = 
    /*#__PURE__*/
    of$d(emptyReadonlyArray);
    // -------------------------------------------------------------------------------------
    // array utils
    // -------------------------------------------------------------------------------------
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndex$8 = function (f) {
        return flow(traverseReadonlyNonEmptyArrayWithIndex$c(f), map$u(traverseReadonlyNonEmptyArrayWithIndex$d(SK)));
    };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndex$8 = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndex$8(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT$7); };
    };
    /**
     * @since 2.9.0
     */
    var traverseArrayWithIndex$6 = traverseReadonlyArrayWithIndex$8;
    /**
     * @since 2.9.0
     */
    var traverseArray$6 = function (f) { return traverseReadonlyArrayWithIndex$8(function (_, a) { return f(a); }); };
    /**
     * @since 2.9.0
     */
    var sequenceArray$6 = 
    /*#__PURE__*/
    traverseArray$6(identity$1);
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var readerEither = {
        URI: URI$h,
        bimap: _bimap$7,
        mapLeft: _mapLeft$7,
        map: _map$g,
        of: of$d,
        ap: _ap$3,
        chain: _chain$7,
        alt: _alt$4,
        throwError: left$7
    };
    /**
     * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getApplySemigroup$3 = 
    /*#__PURE__*/
    getApplySemigroup$7(Apply$3);
    /**
     * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getApplyMonoid$2 = 
    /*#__PURE__*/
    getApplicativeMonoid$1(Applicative$3);
    /**
     * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getSemigroup$6 = function (S) {
        return getApplySemigroup$7(Apply$7)(getSemigroup$b(S));
    };
    /**
     * Use [`getApplicativeReaderValidation`](#getapplicativereadervalidation) and [`getAltReaderValidation`](#getaltreadervalidation) instead.
     *
     * @category instances
     * @since 2.3.0
     * @deprecated
     */
    function getReaderValidation(SE) {
        var applicativeReaderValidation = getApplicativeReaderValidation(SE);
        var altReaderValidation = getAltReaderValidation(SE);
        return {
            URI: URI$h,
            _E: undefined,
            map: _map$g,
            ap: applicativeReaderValidation.ap,
            of: of$d,
            chain: _chain$7,
            bimap: _bimap$7,
            mapLeft: _mapLeft$7,
            alt: altReaderValidation.alt,
            throwError: throwError$3
        };
    }

    var ReaderEither = /*#__PURE__*/Object.freeze({
        __proto__: null,
        left: left$7,
        right: right$7,
        rightReader: rightReader$2,
        leftReader: leftReader$2,
        fromEither: fromEither$5,
        fromReader: fromReader$4,
        match: match$6,
        matchW: matchW$5,
        matchE: matchE$5,
        fold: fold$6,
        matchEW: matchEW$4,
        foldW: foldW$5,
        getOrElse: getOrElse$3,
        getOrElseW: getOrElseW$3,
        toUnion: toUnion$2,
        local: local$3,
        asksReaderEitherW: asksReaderEitherW,
        asksReaderEither: asksReaderEither,
        orElse: orElse$2,
        orElseW: orElseW$2,
        orElseFirst: orElseFirst$2,
        orElseFirstW: orElseFirstW$2,
        orLeft: orLeft$2,
        swap: swap$7,
        map: map$m,
        bimap: bimap$8,
        mapLeft: mapLeft$8,
        ap: ap$b,
        apW: apW$4,
        of: of$d,
        chain: chain$c,
        chainW: chainW$4,
        flattenW: flattenW$4,
        flatten: flatten$7,
        alt: alt$4,
        altW: altW$4,
        throwError: throwError$3,
        URI: URI$h,
        getCompactable: getCompactable$2,
        getFilterable: getFilterable$2,
        getApplicativeReaderValidation: getApplicativeReaderValidation,
        getAltReaderValidation: getAltReaderValidation,
        Functor: Functor$h,
        flap: flap$h,
        Pointed: Pointed$9,
        Apply: Apply$3,
        apFirst: apFirst$8,
        apSecond: apSecond$8,
        Applicative: Applicative$3,
        Chain: Chain$9,
        Monad: Monad$7,
        chainFirst: chainFirst$8,
        chainFirstW: chainFirstW$4,
        Bifunctor: Bifunctor$7,
        Alt: Alt$4,
        FromReader: FromReader$3,
        ask: ask$3,
        asks: asks$3,
        fromReaderK: fromReaderK$3,
        chainReaderK: chainReaderK$3,
        chainReaderKW: chainReaderKW$3,
        chainFirstReaderK: chainFirstReaderK$3,
        chainFirstReaderKW: chainFirstReaderKW$3,
        MonadThrow: MonadThrow$3,
        FromEither: FromEither$7,
        fromOption: fromOption$7,
        fromOptionK: fromOptionK$8,
        chainOptionK: chainOptionK$5,
        chainEitherK: chainEitherK$4,
        chainEitherKW: chainEitherKW$3,
        fromPredicate: fromPredicate$6,
        filterOrElse: filterOrElse$4,
        filterOrElseW: filterOrElseW$3,
        fromEitherK: fromEitherK$5,
        Do: Do$6,
        bindTo: bindTo$8,
        bind: bind$a,
        bindW: bindW$4,
        apS: apS$8,
        apSW: apSW$4,
        ApT: ApT$7,
        traverseReadonlyNonEmptyArrayWithIndex: traverseReadonlyNonEmptyArrayWithIndex$8,
        traverseReadonlyArrayWithIndex: traverseReadonlyArrayWithIndex$8,
        traverseArrayWithIndex: traverseArrayWithIndex$6,
        traverseArray: traverseArray$6,
        sequenceArray: sequenceArray$6,
        readerEither: readerEither,
        getApplySemigroup: getApplySemigroup$3,
        getApplyMonoid: getApplyMonoid$2,
        getSemigroup: getSemigroup$6,
        getReaderValidation: getReaderValidation
    });

    function of$c(F) {
        return function (a) { return function () { return F.of(a); }; };
    }
    function map$l(F) {
        return function (f) { return function (fa) { return function (r) { return F.map(fa(r), f); }; }; };
    }
    function ap$a(F) {
        return function (fa) { return function (fab) { return function (r) { return F.ap(fab(r), fa(r)); }; }; };
    }
    function chain$b(M) {
        return function (f) { return function (ma) { return function (r) { return M.chain(ma(r), function (a) { return f(a)(r); }); }; }; };
    }
    function fromReader$3(F) {
        return function (ma) { return flow(ma, F.of); };
    }
    function fromNaturalTransformation(nt) {
        return function (f) { return flow(f, nt); };
    }
    /** @deprecated */
    /* istanbul ignore next */
    function getReaderM(M) {
        var _ap = ap$a(M);
        var _map = map$l(M);
        var _chain = chain$b(M);
        return {
            map: function (fa, f) { return pipe$1(fa, _map(f)); },
            ap: function (fab, fa) { return pipe$1(fab, _ap(fa)); },
            of: of$c(M),
            chain: function (ma, f) { return pipe$1(ma, _chain(f)); },
            ask: function () { return M.of; },
            asks: function (f) { return flow(f, M.of); },
            local: function (ma, f) { return function (q) { return ma(f(q)); }; },
            fromReader: fromReader$3(M),
            fromM: function (ma) { return function () { return ma; }; }
        };
    }

    var ReaderT = /*#__PURE__*/Object.freeze({
        __proto__: null,
        of: of$c,
        map: map$l,
        ap: ap$a,
        chain: chain$b,
        fromReader: fromReader$3,
        fromNaturalTransformation: fromNaturalTransformation,
        getReaderM: getReaderM
    });

    /**
     * ```ts
     * interface Task<A> {
     *   (): Promise<A>
     * }
     * ```
     *
     * `Task<A>` represents an asynchronous computation that yields a value of type `A` and **never fails**.
     * If you want to represent an asynchronous computation that may fail, please see `TaskEither`.
     *
     * @since 2.0.0
     */
    // -------------------------------------------------------------------------------------
    // natural transformations
    // -------------------------------------------------------------------------------------
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromIO$6 = function (ma) { return function () { return Promise.resolve().then(ma); }; };
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * Creates a task that will complete after a time delay
     *
     * @example
     * import { sequenceT } from 'fp-ts/Apply'
     * import * as T from 'fp-ts/Task'
     * import { takeRight } from 'fp-ts/Array'
     *
     * async function test() {
     *   const log: Array<string> = []
     *   const append = (message: string): T.Task<void> =>
     *     T.fromIO(() => {
     *       log.push(message)
     *     })
     *   const fa = append('a')
     *   const fb = T.delay(20)(append('b'))
     *   const fc = T.delay(10)(append('c'))
     *   const fd = append('d')
     *   await sequenceT(T.ApplyPar)(fa, fb, fc, fd)()
     *   assert.deepStrictEqual(takeRight(2)(log), ['c', 'b'])
     * }
     *
     * test()
     *
     * @category combinators
     * @since 2.0.0
     */
    function delay(millis) {
        return function (ma) { return function () {
            return new Promise(function (resolve) {
                setTimeout(function () {
                    // tslint:disable-next-line: no-floating-promises
                    Promise.resolve().then(ma).then(resolve);
                }, millis);
            });
        }; };
    }
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _map$f = function (fa, f) { return pipe$1(fa, map$k(f)); };
    var _apPar$3 = function (fab, fa) { return pipe$1(fab, ap$9(fa)); };
    var _apSeq$4 = function (fab, fa) {
        return pipe$1(fab, chain$a(function (f) { return pipe$1(fa, map$k(f)); }));
    };
    var _chain$6 = function (ma, f) { return pipe$1(ma, chain$a(f)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$k = function (f) { return function (fa) { return function () {
        return Promise.resolve().then(fa).then(f);
    }; }; };
    /**
     * Apply a function to an argument under a type constructor.
     *
     * @category Apply
     * @since 2.0.0
     */
    var ap$9 = function (fa) { return function (fab) { return function () {
        return Promise.all([Promise.resolve().then(fab), Promise.resolve().then(fa)]).then(function (_a) {
            var f = _a[0], a = _a[1];
            return f(a);
        });
    }; }; };
    /**
     * @category Pointed
     * @since 2.0.0
     */
    var of$b = function (a) { return function () { return Promise.resolve(a); }; };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category Monad
     * @since 2.0.0
     */
    var chain$a = function (f) { return function (ma) { return function () {
        return Promise.resolve()
            .then(ma)
            .then(function (a) { return f(a)(); });
    }; }; };
    /**
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var flatten$6 = 
    /*#__PURE__*/
    chain$a(identity$1);
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$g = 'Task';
    /**
     * Monoid returning the first completed task.
     *
     * Note: uses `Promise.race` internally.
     *
     * @example
     * import * as T from 'fp-ts/Task'
     *
     * async function test() {
     *   const S = T.getRaceMonoid<string>()
     *   const fa = T.delay(20)(T.of('a'))
     *   const fb = T.delay(10)(T.of('b'))
     *   assert.deepStrictEqual(await S.concat(fa, fb)(), 'b')
     * }
     *
     * test()
     *
     * @category instances
     * @since 2.0.0
     */
    function getRaceMonoid() {
        return {
            concat: function (x, y) { return function () { return Promise.race([Promise.resolve().then(x), Promise.resolve().then(y)]); }; },
            empty: never
        };
    }
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$g = {
        URI: URI$g,
        map: _map$f
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$g = 
    /*#__PURE__*/
    flap$x(Functor$g);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$8 = {
        URI: URI$g,
        of: of$b
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var ApplyPar$4 = {
        URI: URI$g,
        map: _map$f,
        ap: _apPar$3
    };
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apFirst$7 = 
    /*#__PURE__*/
    apFirst$k(ApplyPar$4);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apSecond$7 = 
    /*#__PURE__*/
    apSecond$k(ApplyPar$4);
    /**
     * @category instances
     * @since 2.7.0
     */
    var ApplicativePar$4 = {
        URI: URI$g,
        map: _map$f,
        ap: _apPar$3,
        of: of$b
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var ApplySeq$4 = {
        URI: URI$g,
        map: _map$f,
        ap: _apSeq$4
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var ApplicativeSeq$4 = {
        URI: URI$g,
        map: _map$f,
        ap: _apSeq$4,
        of: of$b
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$8 = {
        URI: URI$g,
        map: _map$f,
        ap: _apPar$3,
        chain: _chain$6
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Monad$6 = {
        URI: URI$g,
        map: _map$f,
        of: of$b,
        ap: _apPar$3,
        chain: _chain$6
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var MonadIO$5 = {
        URI: URI$g,
        map: _map$f,
        of: of$b,
        ap: _apPar$3,
        chain: _chain$6,
        fromIO: fromIO$6
    };
    /**
     * @category FromTask
     * @since 2.7.0
     * @deprecated
     */
    var fromTask$6 = identity$1;
    /**
     * @category instances
     * @since 2.10.0
     */
    var MonadTask$5 = {
        URI: URI$g,
        map: _map$f,
        of: of$b,
        ap: _apPar$3,
        chain: _chain$6,
        fromIO: fromIO$6,
        fromTask: fromTask$6
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var chainFirst$7 = 
    /*#__PURE__*/
    chainFirst$k(Chain$8);
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromIO$6 = {
        URI: URI$g,
        fromIO: fromIO$6
    };
    /**
     * @category combinators
     * @since 2.4.0
     */
    var fromIOK$6 = 
    /*#__PURE__*/
    fromIOK$8(FromIO$6);
    /**
     * @category combinators
     * @since 2.4.0
     */
    var chainIOK$5 = 
    /*#__PURE__*/
    chainIOK$7(FromIO$6, Chain$8);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainFirstIOK$5 = 
    /*#__PURE__*/
    chainFirstIOK$7(FromIO$6, Chain$8);
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromTask$6 = {
        URI: URI$g,
        fromIO: fromIO$6,
        fromTask: fromTask$6
    };
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * A `Task` that never completes.
     *
     * @since 2.0.0
     */
    var never = function () { return new Promise(function (_) { return undefined; }); };
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.9.0
     */
    var Do$5 = 
    /*#__PURE__*/
    of$b(emptyRecord);
    /**
     * @since 2.8.0
     */
    var bindTo$7 = 
    /*#__PURE__*/
    bindTo$k(Functor$g);
    /**
     * @since 2.8.0
     */
    var bind$9 = 
    /*#__PURE__*/
    bind$m(Chain$8);
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var apS$7 = 
    /*#__PURE__*/
    apS$k(ApplyPar$4);
    // -------------------------------------------------------------------------------------
    // sequence T
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var ApT$6 = 
    /*#__PURE__*/
    of$b(emptyReadonlyArray);
    // -------------------------------------------------------------------------------------
    // array utils
    // -------------------------------------------------------------------------------------
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndex$7 = function (f) { return function (as) { return function () { return Promise.all(as.map(function (a, i) { return Promise.resolve().then(function () { return f(i, a)(); }); })); }; }; };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndex$7 = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndex$7(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT$6); };
    };
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativeSeq)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndexSeq$5 = function (f) { return function (as) { return function () {
        return tail$5(as).reduce(function (acc, a, i) {
            return acc.then(function (bs) {
                return Promise.resolve()
                    .then(f(i + 1, a))
                    .then(function (b) {
                    bs.push(b);
                    return bs;
                });
            });
        }, Promise.resolve()
            .then(f(0, head$5(as)))
            .then(singleton$7));
    }; }; };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndexSeq$5 = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndexSeq$5(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT$6); };
    };
    /**
     * @since 2.9.0
     */
    var traverseArrayWithIndex$5 = traverseReadonlyArrayWithIndex$7;
    /**
     * @since 2.9.0
     */
    var traverseArray$5 = function (f) {
        return traverseReadonlyArrayWithIndex$7(function (_, a) { return f(a); });
    };
    /**
     * @since 2.9.0
     */
    var sequenceArray$5 = 
    /*#__PURE__*/
    traverseArray$5(identity$1);
    /**
     * @since 2.9.0
     */
    var traverseSeqArrayWithIndex$4 = traverseReadonlyArrayWithIndexSeq$5;
    /**
     * @since 2.9.0
     */
    var traverseSeqArray$4 = function (f) {
        return traverseReadonlyArrayWithIndexSeq$5(function (_, a) { return f(a); });
    };
    /**
     * @since 2.9.0
     */
    var sequenceSeqArray$4 = 
    /*#__PURE__*/
    traverseSeqArray$4(identity$1);
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var task = {
        URI: URI$g,
        map: _map$f,
        of: of$b,
        ap: _apPar$3,
        chain: _chain$6,
        fromIO: fromIO$6,
        fromTask: fromTask$6
    };
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var taskSeq = {
        URI: URI$g,
        map: _map$f,
        of: of$b,
        ap: _apSeq$4,
        chain: _chain$6,
        fromIO: fromIO$6,
        fromTask: fromTask$6
    };
    /**
     * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getSemigroup$5 = 
    /*#__PURE__*/
    getApplySemigroup$7(ApplySeq$4);
    /**
     * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
     *
     * Lift a monoid into 'Task', the inner values are concatenated using the provided `Monoid`.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getMonoid$3 = 
    /*#__PURE__*/
    getApplicativeMonoid$1(ApplicativeSeq$4);

    var Task = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fromIO: fromIO$6,
        delay: delay,
        map: map$k,
        ap: ap$9,
        of: of$b,
        chain: chain$a,
        flatten: flatten$6,
        URI: URI$g,
        getRaceMonoid: getRaceMonoid,
        Functor: Functor$g,
        flap: flap$g,
        Pointed: Pointed$8,
        ApplyPar: ApplyPar$4,
        apFirst: apFirst$7,
        apSecond: apSecond$7,
        ApplicativePar: ApplicativePar$4,
        ApplySeq: ApplySeq$4,
        ApplicativeSeq: ApplicativeSeq$4,
        Chain: Chain$8,
        Monad: Monad$6,
        MonadIO: MonadIO$5,
        fromTask: fromTask$6,
        MonadTask: MonadTask$5,
        chainFirst: chainFirst$7,
        FromIO: FromIO$6,
        fromIOK: fromIOK$6,
        chainIOK: chainIOK$5,
        chainFirstIOK: chainFirstIOK$5,
        FromTask: FromTask$6,
        never: never,
        Do: Do$5,
        bindTo: bindTo$7,
        bind: bind$9,
        apS: apS$7,
        ApT: ApT$6,
        traverseReadonlyNonEmptyArrayWithIndex: traverseReadonlyNonEmptyArrayWithIndex$7,
        traverseReadonlyArrayWithIndex: traverseReadonlyArrayWithIndex$7,
        traverseReadonlyNonEmptyArrayWithIndexSeq: traverseReadonlyNonEmptyArrayWithIndexSeq$5,
        traverseReadonlyArrayWithIndexSeq: traverseReadonlyArrayWithIndexSeq$5,
        traverseArrayWithIndex: traverseArrayWithIndex$5,
        traverseArray: traverseArray$5,
        sequenceArray: sequenceArray$5,
        traverseSeqArrayWithIndex: traverseSeqArrayWithIndex$4,
        traverseSeqArray: traverseSeqArray$4,
        sequenceSeqArray: sequenceSeqArray$4,
        task: task,
        taskSeq: taskSeq,
        getSemigroup: getSemigroup$5,
        getMonoid: getMonoid$3
    });

    /**
     * @since 2.3.0
     */
    // -------------------------------------------------------------------------------------
    // natural transformations
    // -------------------------------------------------------------------------------------
    /**
     * @category natural transformations
     * @since 2.3.0
     */
    var fromReader$2 = 
    /*#__PURE__*/
    fromReader$3(Pointed$8);
    /**
     * @category natural transformations
     * @since 2.3.0
     */
    var fromTask$5 = 

    of$i;
    /**
     * @category natural transformations
     * @since 2.3.0
     */
    var fromIO$5 = 
    /*#__PURE__*/
    flow(fromIO$6, fromTask$5);
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * Changes the value of the local context during the execution of the action `ma` (similar to `Contravariant`'s
     * `contramap`).
     *
     * @category combinators
     * @since 2.3.0
     */
    var local$2 = local$4;
    /**
     * Less strict version of [`asksReaderTask`](#asksreadertask).
     *
     * @category combinators
     * @since 2.11.0
     */
    var asksReaderTaskW = asksReaderW;
    /**
     * Effectfully accesses the environment.
     *
     * @category combinators
     * @since 2.11.0
     */
    var asksReaderTask = asksReaderTaskW;
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    var _map$e = function (fa, f) { return pipe$1(fa, map$j(f)); };
    var _apPar$2 = function (fab, fa) { return pipe$1(fab, ap$8(fa)); };
    var _apSeq$3 = function (fab, fa) {
        return pipe$1(fab, chain$9(function (f) { return pipe$1(fa, map$j(f)); }));
    };
    var _chain$5 = function (ma, f) { return pipe$1(ma, chain$9(f)); };
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.3.0
     */
    var map$j = 
    /*#__PURE__*/
    map$l(Functor$g);
    /**
     * Apply a function to an argument under a type constructor.
     *
     * @category Apply
     * @since 2.3.0
     */
    var ap$8 = 
    /*#__PURE__*/
    ap$a(ApplyPar$4);
    /**
     * Less strict version of [`ap`](#ap).
     *
     * @category Apply
     * @since 2.8.0
     */
    var apW$3 = ap$8;
    /**
     * @category Pointed
     * @since 2.3.0
     */
    var of$a = 
    /*#__PURE__*/
    of$c(Pointed$8);
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category Monad
     * @since 2.3.0
     */
    var chain$9 = 
    /*#__PURE__*/
    chain$b(Monad$6);
    /**
     * Less strict version of  [`chain`](#chain).
     *
     * @category Monad
     * @since 2.6.7
     */
    var chainW$3 = chain$9;
    /**
     * Less strict version of [`flatten`](#flatten).
     *
     * @category combinators
     * @since 2.11.0
     */
    var flattenW$3 = 
    /*#__PURE__*/
    chainW$3(identity$1);
    /**
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.3.0
     */
    var flatten$5 = flattenW$3;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.3.0
     */
    var URI$f = 'ReaderTask';
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$f = {
        URI: URI$f,
        map: _map$e
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$f = 
    /*#__PURE__*/
    flap$x(Functor$f);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$7 = {
        URI: URI$f,
        of: of$a
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var ApplyPar$3 = {
        URI: URI$f,
        map: _map$e,
        ap: _apPar$2
    };
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.3.0
     */
    var apFirst$6 = 
    /*#__PURE__*/
    apFirst$k(ApplyPar$3);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.3.0
     */
    var apSecond$6 = 
    /*#__PURE__*/
    apSecond$k(ApplyPar$3);
    /**
     * @category instances
     * @since 2.7.0
     */
    var ApplicativePar$3 = {
        URI: URI$f,
        map: _map$e,
        ap: _apPar$2,
        of: of$a
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var ApplySeq$3 = {
        URI: URI$f,
        map: _map$e,
        ap: _apSeq$3
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var ApplicativeSeq$3 = {
        URI: URI$f,
        map: _map$e,
        ap: _apSeq$3,
        of: of$a
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$7 = {
        URI: URI$f,
        map: _map$e,
        ap: _apPar$2,
        chain: _chain$5
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Monad$5 = {
        URI: URI$f,
        map: _map$e,
        of: of$a,
        ap: _apPar$2,
        chain: _chain$5
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var MonadIO$4 = {
        URI: URI$f,
        map: _map$e,
        of: of$a,
        ap: _apPar$2,
        chain: _chain$5,
        fromIO: fromIO$5
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var MonadTask$4 = {
        URI: URI$f,
        map: _map$e,
        of: of$a,
        ap: _apPar$2,
        chain: _chain$5,
        fromIO: fromIO$5,
        fromTask: fromTask$5
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.3.0
     */
    var chainFirst$6 = 
    /*#__PURE__*/
    chainFirst$k(Chain$7);
    /**
     * Less strict version of [`chainFirst`](#chainfirst).
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.11.0
     */
    var chainFirstW$3 = chainFirst$6;
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromIO$5 = {
        URI: URI$f,
        fromIO: fromIO$5
    };
    /**
     * @category combinators
     * @since 2.4.0
     */
    var fromIOK$5 = 
    /*#__PURE__*/
    fromIOK$8(FromIO$5);
    /**
     * @category combinators
     * @since 2.4.0
     */
    var chainIOK$4 = 
    /*#__PURE__*/
    chainIOK$7(FromIO$5, Chain$7);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainFirstIOK$4 = 
    /*#__PURE__*/
    chainFirstIOK$7(FromIO$5, Chain$7);
    /**
     * @category instances
     * @since 2.11.0
     */
    var FromReader$2 = {
        URI: URI$f,
        fromReader: fromReader$2
    };
    /**
     * Reads the current context.
     *
     * @category constructors
     * @since 2.3.0
     */
    var ask$2 = 
    /*#__PURE__*/
    ask$4(FromReader$2);
    /**
     * Projects a value from the global context in a `ReaderTask`.
     *
     * @category constructors
     * @since 2.3.0
     */
    var asks$2 = 
    /*#__PURE__*/
    asks$4(FromReader$2);
    /**
     * @category combinators
     * @since 2.11.0
     */
    var fromReaderK$2 = 
    /*#__PURE__*/
    fromReaderK$4(FromReader$2);
    /**
     * @category combinators
     * @since 2.11.0
     */
    var chainReaderK$2 = 
    /*#__PURE__*/
    chainReaderK$4(FromReader$2, Chain$7);
    /**
     * Less strict version of [`chainReaderK`](#chainreaderk).
     *
     * @category combinators
     * @since 2.11.0
     */
    var chainReaderKW$2 = chainReaderK$2;
    /**
     * @category combinators
     * @since 2.11.0
     */
    var chainFirstReaderK$2 = 
    /*#__PURE__*/
    chainFirstReaderK$4(FromReader$2, Chain$7);
    /**
     * Less strict version of [`chainFirstReaderK`](#chainfirstreaderk).
     *
     * @category combinators
     * @since 2.11.0
     */
    var chainFirstReaderKW$2 = chainFirstReaderK$2;
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromTask$5 = {
        URI: URI$f,
        fromIO: fromIO$5,
        fromTask: fromTask$5
    };
    /**
     * @category combinators
     * @since 2.4.0
     */
    var fromTaskK$5 = 
    /*#__PURE__*/
    fromTaskK$6(FromTask$5);
    /**
     * @category combinators
     * @since 2.4.0
     */
    var chainTaskK$4 = 
    /*#__PURE__*/
    chainTaskK$5(FromTask$5, Chain$7);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainFirstTaskK$4 = 
    /*#__PURE__*/
    chainFirstTaskK$5(FromTask$5, Chain$7);
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.9.0
     */
    var Do$4 = 
    /*#__PURE__*/
    of$a(emptyRecord);
    /**
     * @since 2.8.0
     */
    var bindTo$6 = 
    /*#__PURE__*/
    bindTo$k(Functor$f);
    /**
     * @since 2.8.0
     */
    var bind$8 = 
    /*#__PURE__*/
    bind$m(Chain$7);
    /**
     * @since 2.8.0
     */
    var bindW$3 = bind$8;
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var apS$6 = 
    /*#__PURE__*/
    apS$k(ApplyPar$3);
    /**
     * @since 2.8.0
     */
    var apSW$3 = apS$6;
    // -------------------------------------------------------------------------------------
    // sequence T
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var ApT$5 = 
    /*#__PURE__*/
    of$a(emptyReadonlyArray);
    // -------------------------------------------------------------------------------------
    // array utils
    // -------------------------------------------------------------------------------------
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndex$6 = function (f) {
        return flow(traverseReadonlyNonEmptyArrayWithIndex$c(f), map$u(traverseReadonlyNonEmptyArrayWithIndex$7(SK)));
    };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndex$6 = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndex$6(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT$5); };
    };
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativeSeq)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndexSeq$4 = function (f) {
        return flow(traverseReadonlyNonEmptyArrayWithIndex$c(f), map$u(traverseReadonlyNonEmptyArrayWithIndexSeq$5(SK)));
    };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndexSeq$4 = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndexSeq$4(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT$5); };
    };
    /**
     * @since 2.9.0
     */
    var traverseArrayWithIndex$4 = traverseReadonlyArrayWithIndex$6;
    /**
     * @since 2.9.0
     */
    var traverseArray$4 = function (f) { return traverseReadonlyArrayWithIndex$6(function (_, a) { return f(a); }); };
    /**
     * @since 2.9.0
     */
    var sequenceArray$4 = 
    /*#__PURE__*/
    traverseArray$4(identity$1);
    /**
     * @since 2.10.0
     */
    var traverseSeqArrayWithIndex$3 = traverseReadonlyArrayWithIndexSeq$4;
    /**
     * @since 2.10.0
     */
    var traverseSeqArray$3 = function (f) { return traverseReadonlyArrayWithIndexSeq$4(function (_, a) { return f(a); }); };
    /**
     * Use `traverseReadonlyArrayWithIndexSeq` instead.
     *
     * @since 2.10.0
     * @deprecated
     */
    var sequenceSeqArray$3 = 
    /*#__PURE__*/
    traverseSeqArray$3(identity$1);
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.3.0
     * @deprecated
     */
    var readerTask = {
        URI: URI$f,
        map: _map$e,
        of: of$a,
        ap: _apPar$2,
        chain: _chain$5,
        fromIO: fromIO$5,
        fromTask: fromTask$5
    };
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.3.0
     * @deprecated
     */
    var readerTaskSeq = {
        URI: URI$f,
        map: _map$e,
        of: of$a,
        ap: _apSeq$3,
        chain: _chain$5,
        fromIO: fromIO$5,
        fromTask: fromTask$5
    };
    /**
     * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
     *
     * @category instances
     * @since 2.3.0
     * @deprecated
     */
    var getSemigroup$4 = 
    /*#__PURE__*/
    getApplySemigroup$7(ApplySeq$3);
    /**
     * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
     *
     * @category instances
     * @since 2.3.0
     * @deprecated
     */
    var getMonoid$2 = 
    /*#__PURE__*/
    getApplicativeMonoid$1(ApplicativeSeq$3);
    /**
     * @since 2.4.0
     * @deprecated
     */
    /* istanbul ignore next */
    function run$2(ma, r) {
        return ma(r)();
    }

    var ReaderTask = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fromReader: fromReader$2,
        fromTask: fromTask$5,
        fromIO: fromIO$5,
        local: local$2,
        asksReaderTaskW: asksReaderTaskW,
        asksReaderTask: asksReaderTask,
        map: map$j,
        ap: ap$8,
        apW: apW$3,
        of: of$a,
        chain: chain$9,
        chainW: chainW$3,
        flattenW: flattenW$3,
        flatten: flatten$5,
        URI: URI$f,
        Functor: Functor$f,
        flap: flap$f,
        Pointed: Pointed$7,
        ApplyPar: ApplyPar$3,
        apFirst: apFirst$6,
        apSecond: apSecond$6,
        ApplicativePar: ApplicativePar$3,
        ApplySeq: ApplySeq$3,
        ApplicativeSeq: ApplicativeSeq$3,
        Chain: Chain$7,
        Monad: Monad$5,
        MonadIO: MonadIO$4,
        MonadTask: MonadTask$4,
        chainFirst: chainFirst$6,
        chainFirstW: chainFirstW$3,
        FromIO: FromIO$5,
        fromIOK: fromIOK$5,
        chainIOK: chainIOK$4,
        chainFirstIOK: chainFirstIOK$4,
        FromReader: FromReader$2,
        ask: ask$2,
        asks: asks$2,
        fromReaderK: fromReaderK$2,
        chainReaderK: chainReaderK$2,
        chainReaderKW: chainReaderKW$2,
        chainFirstReaderK: chainFirstReaderK$2,
        chainFirstReaderKW: chainFirstReaderKW$2,
        FromTask: FromTask$5,
        fromTaskK: fromTaskK$5,
        chainTaskK: chainTaskK$4,
        chainFirstTaskK: chainFirstTaskK$4,
        Do: Do$4,
        bindTo: bindTo$6,
        bind: bind$8,
        bindW: bindW$3,
        apS: apS$6,
        apSW: apSW$3,
        ApT: ApT$5,
        traverseReadonlyNonEmptyArrayWithIndex: traverseReadonlyNonEmptyArrayWithIndex$6,
        traverseReadonlyArrayWithIndex: traverseReadonlyArrayWithIndex$6,
        traverseReadonlyNonEmptyArrayWithIndexSeq: traverseReadonlyNonEmptyArrayWithIndexSeq$4,
        traverseReadonlyArrayWithIndexSeq: traverseReadonlyArrayWithIndexSeq$4,
        traverseArrayWithIndex: traverseArrayWithIndex$4,
        traverseArray: traverseArray$4,
        sequenceArray: sequenceArray$4,
        traverseSeqArrayWithIndex: traverseSeqArrayWithIndex$3,
        traverseSeqArray: traverseSeqArray$3,
        sequenceSeqArray: sequenceSeqArray$3,
        readerTask: readerTask,
        readerTaskSeq: readerTaskSeq,
        getSemigroup: getSemigroup$4,
        getMonoid: getMonoid$2,
        run: run$2
    });

    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * @category constructors
     * @since 2.0.0
     */
    var left$6 = 
    /*#__PURE__*/
    left$a(Pointed$8);
    /**
     * @category constructors
     * @since 2.0.0
     */
    var right$6 = 
    /*#__PURE__*/
    right$a(Pointed$8);
    /**
     * @category constructors
     * @since 2.0.0
     */
    var rightTask$3 = 
    /*#__PURE__*/
    rightF$1(Functor$g);
    /**
     * @category constructors
     * @since 2.0.0
     */
    var leftTask$3 = 
    /*#__PURE__*/
    leftF$1(Functor$g);
    /**
     * @category constructors
     * @since 2.0.0
     */
    var rightIO$3 = 
    /*#__PURE__*/
    flow(fromIO$6, rightTask$3);
    /**
     * @category constructors
     * @since 2.0.0
     */
    var leftIO$3 = 
    /*#__PURE__*/
    flow(fromIO$6, leftTask$3);
    // -------------------------------------------------------------------------------------
    // natural transformations
    // -------------------------------------------------------------------------------------
    /**
     * @category natural transformations
     * @since 2.7.0
     */
    var fromIO$4 = rightIO$3;
    /**
     * @category natural transformations
     * @since 2.7.0
     */
    var fromTask$4 = rightTask$3;
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromEither$4 = of$b;
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromIOEither$3 = fromIO$6;
    /**
     * @category natural transformations
     * @since 2.11.0
     */
    var fromTaskOption = function (onNone) {
        return map$k(fromOption$9(onNone));
    };
    // -------------------------------------------------------------------------------------
    // destructors
    // -------------------------------------------------------------------------------------
    /**
     * @category destructors
     * @since 2.10.0
     */
    var match$5 = 
    /*#__PURE__*/
    match$a(Functor$g);
    /**
     * Less strict version of [`match`](#match).
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchW$4 = match$5;
    /**
     * @category destructors
     * @since 2.10.0
     */
    var matchE$4 = 
    /*#__PURE__*/
    matchE$8(Monad$6);
    /**
     * Alias of [`matchE`](#matche).
     *
     * @category destructors
     * @since 2.0.0
     */
    var fold$5 = matchE$4;
    /**
     * Less strict version of [`matchE`](#matche).
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchEW$3 = matchE$4;
    /**
     * Alias of [`matchEW`](#matchew).
     *
     * @category destructors
     * @since 2.10.0
     */
    var foldW$4 = matchEW$3;
    /**
     * @category destructors
     * @since 2.0.0
     */
    var getOrElse$2 = 
    /*#__PURE__*/
    getOrElse$6(Monad$6);
    /**
     * Less strict version of [`getOrElse`](#getorelse).
     *
     * @category destructors
     * @since 2.6.0
     */
    var getOrElseW$2 = getOrElse$2;
    // -------------------------------------------------------------------------------------
    // interop
    // -------------------------------------------------------------------------------------
    /**
     * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Either` instead.
     *
     * Note: `f` should never `throw` errors, they are not caught.
     *
     * See also [`tryCatchK`](#trycatchk).
     *
     * @example
     * import { left, right } from 'fp-ts/Either'
     * import { tryCatch } from 'fp-ts/TaskEither'
     *
     * tryCatch(() => Promise.resolve(1), String)().then(result => {
     *   assert.deepStrictEqual(result, right(1))
     * })
     * tryCatch(() => Promise.reject('error'), String)().then(result => {
     *   assert.deepStrictEqual(result, left('error'))
     * })
     *
     * @category interop
     * @since 2.0.0
     */
    var tryCatch$1 = function (f, onRejected) { return function () {
        return f().then(right$d, function (reason) { return left$d(onRejected(reason)); });
    }; };
    /**
     * Converts a function returning a `Promise` to one returning a `TaskEither`.
     *
     * @category interop
     * @since 2.5.0
     */
    var tryCatchK$1 = function (f, onRejected) { return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return tryCatch$1(function () { return f.apply(void 0, a); }, onRejected);
    }; };
    /**
     * @category interop
     * @since 2.10.0
     */
    var toUnion$1 = 
    /*#__PURE__*/
    toUnion$4(Functor$g);
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * Returns `ma` if is a `Right` or the value returned by `onLeft` otherwise.
     *
     * See also [alt](#alt).
     *
     * @example
     * import * as E from 'fp-ts/Either'
     * import { pipe } from 'fp-ts/function'
     * import * as TE from 'fp-ts/TaskEither'
     *
     * async function test() {
     *   const errorHandler = TE.orElse((error: string) => TE.right(`recovering from ${error}...`))
     *   assert.deepStrictEqual(await pipe(TE.right('ok'), errorHandler)(), E.right('ok'))
     *   assert.deepStrictEqual(await pipe(TE.left('ko'), errorHandler)(), E.right('recovering from ko...'))
     * }
     *
     * test()
     *
     * @category combinators
     * @since 2.0.0
     */
    var orElse$1 = 
    /*#__PURE__*/
    orElse$4(Monad$6);
    /**
     * Less strict version of [`orElse`](#orelse).
     *
     * @category combinators
     * @since 2.10.0
     */
    var orElseW$1 = orElse$1;
    /**
     * @category combinators
     * @since 2.11.0
     */
    var orElseFirst$1 = 
    /*#__PURE__*/
    orElseFirst$4(Monad$6);
    /**
     * @category combinators
     * @since 2.11.0
     */
    var orElseFirstW$1 = orElseFirst$1;
    /**
     * @category combinators
     * @since 2.11.0
     */
    var orLeft$1 = 
    /*#__PURE__*/
    orLeft$4(Monad$6);
    /**
     * @category combinators
     * @since 2.0.0
     */
    var swap$6 = 
    /*#__PURE__*/
    swap$9(Functor$g);
    /**
     * @category combinators
     * @since 2.11.0
     */
    var fromTaskOptionK = function (onNone) {
        var from = fromTaskOption(onNone);
        return function (f) { return flow(f, from); };
    };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var chainTaskOptionK = function (onNone) {
        return flow(fromTaskOptionK(onNone), chain$8);
    };
    /**
     * @category combinators
     * @since 2.4.0
     */
    var fromIOEitherK$2 = function (f) { return flow(f, fromIOEither$3); };
    /**
     * Less strict version of [`chainIOEitherK`](#chainioeitherk).
     *
     * @category combinators
     * @since 2.6.1
     */
    var chainIOEitherKW$2 = function (f) { return chainW$2(fromIOEitherK$2(f)); };
    /**
     * @category combinators
     * @since 2.4.0
     */
    var chainIOEitherK$2 = chainIOEitherKW$2;
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _map$d = function (fa, f) { return pipe$1(fa, map$i(f)); };
    var _apPar$1 = function (fab, fa) { return pipe$1(fab, ap$7(fa)); };
    var _apSeq$2 = function (fab, fa) {
        return pipe$1(fab, chain$8(function (f) { return pipe$1(fa, map$i(f)); }));
    };
    /* istanbul ignore next */
    var _chain$4 = function (ma, f) { return pipe$1(ma, chain$8(f)); };
    /* istanbul ignore next */
    var _bimap$6 = function (fa, f, g) { return pipe$1(fa, bimap$7(f, g)); };
    /* istanbul ignore next */
    var _mapLeft$6 = function (fa, f) { return pipe$1(fa, mapLeft$7(f)); };
    /* istanbul ignore next */
    var _alt$3 = function (fa, that) { return pipe$1(fa, alt$3(that)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$i = 
    /*#__PURE__*/
    map$v(Functor$g);
    /**
     * Map a pair of functions over the two type arguments of the bifunctor.
     *
     * @category Bifunctor
     * @since 2.0.0
     */
    var bimap$7 = 
    /*#__PURE__*/
    bimap$a(Functor$g);
    /**
     * Map a function over the first type argument of a bifunctor.
     *
     * @category Bifunctor
     * @since 2.0.0
     */
    var mapLeft$7 = 
    /*#__PURE__*/
    mapLeft$a(Functor$g);
    /**
     * Apply a function to an argument under a type constructor.
     *
     * @category Apply
     * @since 2.0.0
     */
    var ap$7 = 
    /*#__PURE__*/
    ap$i(ApplyPar$4);
    /**
     * Less strict version of [`ap`](#ap).
     *
     * @category Apply
     * @since 2.8.0
     */
    var apW$2 = ap$7;
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category Monad
     * @since 2.0.0
     */
    var chain$8 = 
    /*#__PURE__*/
    chain$j(Monad$6);
    /**
     * Less strict version of [`chain`](#chain).
     *
     * @category Monad
     * @since 2.6.0
     */
    var chainW$2 = chain$8;
    /**
     * Less strict version of [`flatten`](#flatten).
     *
     * @category combinators
     * @since 2.11.0
     */
    var flattenW$2 = 
    /*#__PURE__*/
    chainW$2(identity$1);
    /**
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var flatten$4 = flattenW$2;
    /**
     * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
     * types of kind `* -> *`.
     *
     * In case of `TaskEither` returns `fa` if is a `Right` or the value returned by `that` otherwise.
     *
     * See also [orElse](#orelse).
     *
     * @example
     * import * as E from 'fp-ts/Either'
     * import { pipe } from 'fp-ts/function'
     * import * as TE from 'fp-ts/TaskEither'
     *
     * async function test() {
     *   assert.deepStrictEqual(
     *     await pipe(
     *       TE.right(1),
     *       TE.alt(() => TE.right(2))
     *     )(),
     *     E.right(1)
     *   )
     *   assert.deepStrictEqual(
     *     await pipe(
     *       TE.left('a'),
     *       TE.alt(() => TE.right(2))
     *     )(),
     *     E.right(2)
     *   )
     *   assert.deepStrictEqual(
     *     await pipe(
     *       TE.left('a'),
     *       TE.alt(() => TE.left('b'))
     *     )(),
     *     E.left('b')
     *   )
     * }
     *
     * test()
     *
     * @category Alt
     * @since 2.0.0
     */
    var alt$3 = 
    /*#__PURE__*/
    alt$8(Monad$6);
    /**
     * Less strict version of [`alt`](#alt).
     *
     * @category Alt
     * @since 2.9.0
     */
    var altW$3 = alt$3;
    /**
     * @category Pointed
     * @since 2.0.0
     */
    var of$9 = right$6;
    /**
     * @category MonadTask
     * @since 2.7.0
     */
    var throwError$2 = left$6;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$e = 'TaskEither';
    /**
     * @category instances
     * @since 2.7.0
     */
    function getApplicativeTaskValidation(A, S) {
        var ap = ap$p(A, getApplicativeValidation(S));
        return {
            URI: URI$e,
            _E: undefined,
            map: _map$d,
            ap: function (fab, fa) { return pipe$1(fab, ap(fa)); },
            of: of$9
        };
    }
    /**
     * @category instances
     * @since 2.7.0
     */
    function getAltTaskValidation(S) {
        var alt = altValidation(Monad$6, S);
        return {
            URI: URI$e,
            _E: undefined,
            map: _map$d,
            alt: function (fa, that) { return pipe$1(fa, alt(that)); }
        };
    }
    /**
     * @category instances
     * @since 2.10.0
     */
    var getCompactable$1 = function (M) {
        var C = getCompactable$4(M);
        return {
            URI: URI$e,
            _E: undefined,
            compact: compact$7(Functor$g, C),
            separate: separate$7(Functor$g, C, Functor$p)
        };
    };
    /**
     * @category instances
     * @since 2.1.0
     */
    function getFilterable$1(M) {
        var F = getFilterable$4(M);
        var C = getCompactable$1(M);
        var filter = filter$7(Functor$g, F);
        var filterMap = filterMap$7(Functor$g, F);
        var partition = partition$7(Functor$g, F);
        var partitionMap = partitionMap$7(Functor$g, F);
        return {
            URI: URI$e,
            _E: undefined,
            map: _map$d,
            compact: C.compact,
            separate: C.separate,
            filter: function (fa, predicate) { return pipe$1(fa, filter(predicate)); },
            filterMap: function (fa, f) { return pipe$1(fa, filterMap(f)); },
            partition: function (fa, predicate) { return pipe$1(fa, partition(predicate)); },
            partitionMap: function (fa, f) { return pipe$1(fa, partitionMap(f)); }
        };
    }
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$e = {
        URI: URI$e,
        map: _map$d
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$e = 
    /*#__PURE__*/
    flap$x(Functor$e);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$6 = {
        URI: URI$e,
        of: of$9
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var ApplyPar$2 = {
        URI: URI$e,
        map: _map$d,
        ap: _apPar$1
    };
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apFirst$5 = 
    /*#__PURE__*/
    apFirst$k(ApplyPar$2);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apSecond$5 = 
    /*#__PURE__*/
    apSecond$k(ApplyPar$2);
    /**
     * @category instances
     * @since 2.7.0
     */
    var ApplicativePar$2 = {
        URI: URI$e,
        map: _map$d,
        ap: _apPar$1,
        of: of$9
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var ApplySeq$2 = {
        URI: URI$e,
        map: _map$d,
        ap: _apSeq$2
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var ApplicativeSeq$2 = {
        URI: URI$e,
        map: _map$d,
        ap: _apSeq$2,
        of: of$9
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$6 = {
        URI: URI$e,
        map: _map$d,
        ap: _apPar$1,
        chain: _chain$4
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Monad$4 = {
        URI: URI$e,
        map: _map$d,
        ap: _apPar$1,
        chain: _chain$4,
        of: of$9
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var MonadIO$3 = {
        URI: URI$e,
        map: _map$d,
        ap: _apPar$1,
        chain: _chain$4,
        of: of$9,
        fromIO: fromIO$4
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var MonadTask$3 = {
        URI: URI$e,
        map: _map$d,
        ap: _apPar$1,
        chain: _chain$4,
        of: of$9,
        fromIO: fromIO$4,
        fromTask: fromTask$4
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var MonadThrow$2 = {
        URI: URI$e,
        map: _map$d,
        ap: _apPar$1,
        chain: _chain$4,
        of: of$9,
        throwError: throwError$2
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var chainFirst$5 = 
    /*#__PURE__*/
    chainFirst$k(Chain$6);
    /**
     * Less strict version of [`chainFirst`](#chainfirst).
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.8.0
     */
    var chainFirstW$2 = chainFirst$5;
    /**
     * @category instances
     * @since 2.7.0
     */
    var Bifunctor$6 = {
        URI: URI$e,
        bimap: _bimap$6,
        mapLeft: _mapLeft$6
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Alt$3 = {
        URI: URI$e,
        map: _map$d,
        alt: _alt$3
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromEither$6 = {
        URI: URI$e,
        fromEither: fromEither$4
    };
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromOption$6 = 
    /*#__PURE__*/
    fromOption$c(FromEither$6);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromOptionK$7 = 
    /*#__PURE__*/
    fromOptionK$e(FromEither$6);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainOptionK$4 = 
    /*#__PURE__*/
    chainOptionK$9(FromEither$6, Chain$6);
    /**
     * @category combinators
     * @since 2.4.0
     */
    var chainEitherK$3 = 
    /*#__PURE__*/
    chainEitherK$7(FromEither$6, Chain$6);
    /**
     * Less strict version of [`chainEitherK`](#chaineitherk).
     *
     * @category combinators
     * @since 2.6.1
     */
    var chainEitherKW$2 = chainEitherK$3;
    /**
     * @category constructors
     * @since 2.0.0
     */
    var fromPredicate$5 = 
    /*#__PURE__*/
    fromPredicate$d(FromEither$6);
    /**
     * @category combinators
     * @since 2.0.0
     */
    var filterOrElse$3 = 
    /*#__PURE__*/
    filterOrElse$7(FromEither$6, Chain$6);
    /**
     * Less strict version of [`filterOrElse`](#filterorelse).
     *
     * @category combinators
     * @since 2.9.0
     */
    var filterOrElseW$2 = filterOrElse$3;
    /**
     * @category combinators
     * @since 2.4.0
     */
    var fromEitherK$4 = 
    /*#__PURE__*/
    fromEitherK$a(FromEither$6);
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromIO$4 = {
        URI: URI$e,
        fromIO: fromIO$4
    };
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromIOK$4 = 
    /*#__PURE__*/
    fromIOK$8(FromIO$4);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainIOK$3 = 
    /*#__PURE__*/
    chainIOK$7(FromIO$4, Chain$6);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainFirstIOK$3 = 
    /*#__PURE__*/
    chainFirstIOK$7(FromIO$4, Chain$6);
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromTask$4 = {
        URI: URI$e,
        fromIO: fromIO$4,
        fromTask: fromTask$4
    };
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromTaskK$4 = 
    /*#__PURE__*/
    fromTaskK$6(FromTask$4);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainTaskK$3 = 
    /*#__PURE__*/
    chainTaskK$5(FromTask$4, Chain$6);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainFirstTaskK$3 = 
    /*#__PURE__*/
    chainFirstTaskK$5(FromTask$4, Chain$6);
    function taskify(f) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return function () {
                return new Promise(function (resolve) {
                    var cbResolver = function (e, r) { return (e != null ? resolve(left$d(e)) : resolve(right$d(r))); };
                    f.apply(null, args.concat(cbResolver));
                });
            };
        };
    }
    /**
     * Make sure that a resource is cleaned up in the event of an exception (\*). The release action is called regardless of
     * whether the body action throws (\*) or returns.
     *
     * (\*) i.e. returns a `Left`
     *
     * @since 2.0.0
     */
    var bracket$1 = function (acquire, use, release) {
        return pipe$1(acquire, chain$8(function (a) {
            return pipe$1(use(a), chain$a(function (e) {
                return pipe$1(release(a, e), chain$8(function () { return of$b(e); }));
            }));
        }));
    };
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.9.0
     */
    var Do$3 = 
    /*#__PURE__*/
    of$9(emptyRecord);
    /**
     * @since 2.8.0
     */
    var bindTo$5 = 
    /*#__PURE__*/
    bindTo$k(Functor$e);
    /**
     * @since 2.8.0
     */
    var bind$7 = 
    /*#__PURE__*/
    bind$m(Chain$6);
    /**
     * @since 2.8.0
     */
    var bindW$2 = bind$7;
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var apS$5 = 
    /*#__PURE__*/
    apS$k(ApplyPar$2);
    /**
     * @since 2.8.0
     */
    var apSW$2 = apS$5;
    // -------------------------------------------------------------------------------------
    // sequence T
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var ApT$4 = 
    /*#__PURE__*/
    of$9(emptyReadonlyArray);
    // -------------------------------------------------------------------------------------
    // array utils
    // -------------------------------------------------------------------------------------
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndex$5 = function (f) {
        return flow(traverseReadonlyNonEmptyArrayWithIndex$7(f), map$k(traverseReadonlyNonEmptyArrayWithIndex$d(SK)));
    };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndex$5 = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndex$5(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT$4); };
    };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndexSeq$3 = function (f) { return function (as) { return function () {
        return tail$5(as).reduce(function (acc, a, i) {
            return acc.then(function (ebs) {
                return isLeft$3(ebs)
                    ? acc
                    : f(i + 1, a)().then(function (eb) {
                        if (isLeft$3(eb)) {
                            return eb;
                        }
                        ebs.right.push(eb.right);
                        return ebs;
                    });
            });
        }, f(0, head$5(as))().then(map$w(singleton$7)));
    }; }; };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndexSeq$3 = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndexSeq$3(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT$4); };
    };
    /**
     * @since 2.9.0
     */
    var traverseArrayWithIndex$3 = traverseReadonlyArrayWithIndex$5;
    /**
     * @since 2.9.0
     */
    var traverseArray$3 = function (f) { return traverseReadonlyArrayWithIndex$5(function (_, a) { return f(a); }); };
    /**
     * @since 2.9.0
     */
    var sequenceArray$3 = 
    /*#__PURE__*/
    traverseArray$3(identity$1);
    /**
     * @since 2.9.0
     */
    var traverseSeqArrayWithIndex$2 = traverseReadonlyArrayWithIndexSeq$3;
    /**
     * @since 2.9.0
     */
    var traverseSeqArray$2 = function (f) { return traverseReadonlyArrayWithIndexSeq$3(function (_, a) { return f(a); }); };
    /**
     * @since 2.9.0
     */
    var sequenceSeqArray$2 = 
    /*#__PURE__*/
    traverseSeqArray$2(identity$1);
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var taskEither = {
        URI: URI$e,
        bimap: _bimap$6,
        mapLeft: _mapLeft$6,
        map: _map$d,
        of: of$9,
        ap: _apPar$1,
        chain: _chain$4,
        alt: _alt$3,
        fromIO: fromIO$4,
        fromTask: fromTask$4,
        throwError: throwError$2
    };
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var taskEitherSeq = {
        URI: URI$e,
        bimap: _bimap$6,
        mapLeft: _mapLeft$6,
        map: _map$d,
        of: of$9,
        ap: _apSeq$2,
        chain: _chain$4,
        alt: _alt$3,
        fromIO: fromIO$4,
        fromTask: fromTask$4,
        throwError: throwError$2
    };
    /**
     * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getApplySemigroup$2 = 
    /*#__PURE__*/
    getApplySemigroup$7(ApplySeq$2);
    /**
     * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getApplyMonoid$1 = 
    /*#__PURE__*/
    getApplicativeMonoid$1(ApplicativeSeq$2);
    /**
     * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getSemigroup$3 = function (S) {
        return getApplySemigroup$7(ApplySeq$4)(getSemigroup$b(S));
    };
    /**
     * Use [`getApplicativeTaskValidation`](#getapplicativetaskvalidation) and [`getAltTaskValidation`](#getalttaskvalidation) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    function getTaskValidation(SE) {
        var applicativeTaskValidation = getApplicativeTaskValidation(ApplicativePar$4, SE);
        var altTaskValidation = getAltTaskValidation(SE);
        return {
            URI: URI$e,
            _E: undefined,
            map: _map$d,
            ap: applicativeTaskValidation.ap,
            of: of$9,
            chain: _chain$4,
            bimap: _bimap$6,
            mapLeft: _mapLeft$6,
            alt: altTaskValidation.alt,
            fromIO: fromIO$4,
            fromTask: fromTask$4,
            throwError: throwError$2
        };
    }

    var TaskEither = /*#__PURE__*/Object.freeze({
        __proto__: null,
        left: left$6,
        right: right$6,
        rightTask: rightTask$3,
        leftTask: leftTask$3,
        rightIO: rightIO$3,
        leftIO: leftIO$3,
        fromIO: fromIO$4,
        fromTask: fromTask$4,
        fromEither: fromEither$4,
        fromIOEither: fromIOEither$3,
        fromTaskOption: fromTaskOption,
        match: match$5,
        matchW: matchW$4,
        matchE: matchE$4,
        fold: fold$5,
        matchEW: matchEW$3,
        foldW: foldW$4,
        getOrElse: getOrElse$2,
        getOrElseW: getOrElseW$2,
        tryCatch: tryCatch$1,
        tryCatchK: tryCatchK$1,
        toUnion: toUnion$1,
        orElse: orElse$1,
        orElseW: orElseW$1,
        orElseFirst: orElseFirst$1,
        orElseFirstW: orElseFirstW$1,
        orLeft: orLeft$1,
        swap: swap$6,
        fromTaskOptionK: fromTaskOptionK,
        chainTaskOptionK: chainTaskOptionK,
        fromIOEitherK: fromIOEitherK$2,
        chainIOEitherKW: chainIOEitherKW$2,
        chainIOEitherK: chainIOEitherK$2,
        map: map$i,
        bimap: bimap$7,
        mapLeft: mapLeft$7,
        ap: ap$7,
        apW: apW$2,
        chain: chain$8,
        chainW: chainW$2,
        flattenW: flattenW$2,
        flatten: flatten$4,
        alt: alt$3,
        altW: altW$3,
        of: of$9,
        throwError: throwError$2,
        URI: URI$e,
        getApplicativeTaskValidation: getApplicativeTaskValidation,
        getAltTaskValidation: getAltTaskValidation,
        getCompactable: getCompactable$1,
        getFilterable: getFilterable$1,
        Functor: Functor$e,
        flap: flap$e,
        Pointed: Pointed$6,
        ApplyPar: ApplyPar$2,
        apFirst: apFirst$5,
        apSecond: apSecond$5,
        ApplicativePar: ApplicativePar$2,
        ApplySeq: ApplySeq$2,
        ApplicativeSeq: ApplicativeSeq$2,
        Chain: Chain$6,
        Monad: Monad$4,
        MonadIO: MonadIO$3,
        MonadTask: MonadTask$3,
        MonadThrow: MonadThrow$2,
        chainFirst: chainFirst$5,
        chainFirstW: chainFirstW$2,
        Bifunctor: Bifunctor$6,
        Alt: Alt$3,
        FromEither: FromEither$6,
        fromOption: fromOption$6,
        fromOptionK: fromOptionK$7,
        chainOptionK: chainOptionK$4,
        chainEitherK: chainEitherK$3,
        chainEitherKW: chainEitherKW$2,
        fromPredicate: fromPredicate$5,
        filterOrElse: filterOrElse$3,
        filterOrElseW: filterOrElseW$2,
        fromEitherK: fromEitherK$4,
        FromIO: FromIO$4,
        fromIOK: fromIOK$4,
        chainIOK: chainIOK$3,
        chainFirstIOK: chainFirstIOK$3,
        FromTask: FromTask$4,
        fromTaskK: fromTaskK$4,
        chainTaskK: chainTaskK$3,
        chainFirstTaskK: chainFirstTaskK$3,
        taskify: taskify,
        bracket: bracket$1,
        Do: Do$3,
        bindTo: bindTo$5,
        bind: bind$7,
        bindW: bindW$2,
        apS: apS$5,
        apSW: apSW$2,
        ApT: ApT$4,
        traverseReadonlyNonEmptyArrayWithIndex: traverseReadonlyNonEmptyArrayWithIndex$5,
        traverseReadonlyArrayWithIndex: traverseReadonlyArrayWithIndex$5,
        traverseReadonlyNonEmptyArrayWithIndexSeq: traverseReadonlyNonEmptyArrayWithIndexSeq$3,
        traverseReadonlyArrayWithIndexSeq: traverseReadonlyArrayWithIndexSeq$3,
        traverseArrayWithIndex: traverseArrayWithIndex$3,
        traverseArray: traverseArray$3,
        sequenceArray: sequenceArray$3,
        traverseSeqArrayWithIndex: traverseSeqArrayWithIndex$2,
        traverseSeqArray: traverseSeqArray$2,
        sequenceSeqArray: sequenceSeqArray$2,
        taskEither: taskEither,
        taskEitherSeq: taskEitherSeq,
        getApplySemigroup: getApplySemigroup$2,
        getApplyMonoid: getApplyMonoid$1,
        getSemigroup: getSemigroup$3,
        getTaskValidation: getTaskValidation
    });

    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromTaskEither$2 = 

    of$i;
    /**
     * @category constructors
     * @since 2.0.0
     */
    var left$5 = 
    /*#__PURE__*/
    left$a(Pointed$7);
    /**
     * @category constructors
     * @since 2.0.0
     */
    var right$5 = 
    /*#__PURE__*/
    right$a(Pointed$7);
    /**
     * @category constructors
     * @since 2.0.0
     */
    var rightTask$2 = 
    /*#__PURE__*/
    flow(rightTask$3, fromTaskEither$2);
    /**
     * @category constructors
     * @since 2.0.0
     */
    var leftTask$2 = 
    /*#__PURE__*/
    flow(leftTask$3, fromTaskEither$2);
    /**
     * @category constructors
     * @since 2.0.0
     */
    var rightReader$1 = function (ma) {
        return flow(ma, right$6);
    };
    /**
     * @category constructors
     * @since 2.0.0
     */
    var leftReader$1 = function (me) {
        return flow(me, left$6);
    };
    /**
     * @category constructors
     * @since 2.5.0
     */
    var rightReaderTask = 
    /*#__PURE__*/
    rightF$1(Functor$f);
    /**
     * @category constructors
     * @since 2.5.0
     */
    var leftReaderTask = 
    /*#__PURE__*/
    leftF$1(Functor$f);
    /**
     * @category constructors
     * @since 2.0.0
     */
    var rightIO$2 = 
    /*#__PURE__*/
    flow(rightIO$3, fromTaskEither$2);
    /**
     * @category constructors
     * @since 2.0.0
     */
    var leftIO$2 = 
    /*#__PURE__*/
    flow(leftIO$3, fromTaskEither$2);
    // -------------------------------------------------------------------------------------
    // natural transformations
    // -------------------------------------------------------------------------------------
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromEither$3 = of$a;
    /**
     * @category natural transformations
     * @since 2.11.0
     */
    var fromReader$1 = rightReader$1;
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromIO$3 = rightIO$2;
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromTask$3 = rightTask$2;
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromIOEither$2 = 
    /*#__PURE__*/
    flow(fromIOEither$3, fromTaskEither$2);
    /**
     * @category constructors
     * @since 2.0.0
     */
    var fromReaderEither$1 = function (ma) { return flow(ma, fromEither$4); };
    // -------------------------------------------------------------------------------------
    // destructors
    // -------------------------------------------------------------------------------------
    /**
     * @category destructors
     * @since 2.10.0
     */
    var match$4 = 
    /*#__PURE__*/
    match$a(Functor$f);
    /**
     * Less strict version of [`match`](#match).
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchW$3 = match$4;
    /**
     * @category destructors
     * @since 2.10.0
     */
    var matchE$3 = 
    /*#__PURE__*/
    matchE$8(Chain$7);
    /**
     * Alias of [`matchE`](#matche).
     *
     * @category destructors
     * @since 2.0.0
     */
    var fold$4 = matchE$3;
    /**
     * Less strict version of [`matchE`](#matche).
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchEW$2 = matchE$3;
    /**
     * Alias of [`matchEW`](#matchew).
     *
     * @category destructors
     * @since 2.10.0
     */
    var foldW$3 = matchEW$2;
    /**
     * @category destructors
     * @since 2.0.0
     */
    var getOrElse$1 = 
    /*#__PURE__*/
    getOrElse$6(Monad$5);
    /**
     * Less strict version of [`getOrElse`](#getorelse).
     *
     * @category destructors
     * @since 2.6.0
     */
    var getOrElseW$1 = getOrElse$1;
    // -------------------------------------------------------------------------------------
    // interop
    // -------------------------------------------------------------------------------------
    /**
     * @category interop
     * @since 2.10.0
     */
    var toUnion = 
    /*#__PURE__*/
    toUnion$4(Functor$f);
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * Changes the value of the local context during the execution of the action `ma` (similar to `Contravariant`'s
     * `contramap`).
     *
     * @category combinators
     * @since 2.0.0
     */
    var local$1 = local$4;
    /**
     * Less strict version of [`asksReaderTaskEither`](#asksreadertaskeither).
     *
     * @category combinators
     * @since 2.11.0
     */
    var asksReaderTaskEitherW = asksReaderW;
    /**
     * Effectfully accesses the environment.
     *
     * @category combinators
     * @since 2.11.0
     */
    var asksReaderTaskEither = asksReaderTaskEitherW;
    /**
     * @category combinators
     * @since 2.0.0
     */
    var orElse = 
    /*#__PURE__*/
    orElse$4(Monad$5);
    /**
     * Less strict version of [`orElse`](#orelse).
     *
     * @category combinators
     * @since 2.10.0
     */
    var orElseW = orElse;
    /**
     * @category combinators
     * @since 2.11.0
     */
    var orElseFirst = 
    /*#__PURE__*/
    orElseFirst$4(Monad$5);
    /**
     * @category combinators
     * @since 2.11.0
     */
    var orElseFirstW = orElseFirst;
    /**
     * @category combinators
     * @since 2.11.0
     */
    var orLeft = 
    /*#__PURE__*/
    orLeft$4(Monad$5);
    /**
     * @category combinators
     * @since 2.0.0
     */
    var swap$5 = 
    /*#__PURE__*/
    swap$9(Functor$f);
    /**
     * @category combinators
     * @since 2.4.0
     */
    var fromIOEitherK$1 = function (f) { return flow(f, fromIOEither$2); };
    /**
     * Less strict version of [`chainIOEitherK`](#chainioeitherk).
     *
     * @category combinators
     * @since 2.6.1
     */
    var chainIOEitherKW$1 = function (f) { return chainW$1(fromIOEitherK$1(f)); };
    /**
     * @category combinators
     * @since 2.4.0
     */
    var chainIOEitherK$1 = chainIOEitherKW$1;
    /**
     * @category combinators
     * @since 2.4.0
     */
    var fromTaskEitherK$1 = function (f) { return flow(f, fromTaskEither$2); };
    /**
     * Less strict version of [`chainTaskEitherK`](#chaintaskeitherk).
     *
     * @category combinators
     * @since 2.6.1
     */
    var chainTaskEitherKW$1 = function (f) { return chainW$1(fromTaskEitherK$1(f)); };
    /**
     * @category combinators
     * @since 2.4.0
     */
    var chainTaskEitherK$1 = chainTaskEitherKW$1;
    /**
     * Less strict version of [`chainFirstTaskEitherK`](#chainfirsttaskeitherk).
     *
     * @category combinators
     * @since 2.11.0
     */
    var chainFirstTaskEitherKW = function (f) { return chainFirstW$1(fromTaskEitherK$1(f)); };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var chainFirstTaskEitherK = chainFirstTaskEitherKW;
    /**
     * @category combinators
     * @since 2.11.0
     */
    var fromReaderEitherK = function (f) { return flow(f, fromReaderEither$1); };
    /**
     * Less strict version of [`chainReaderEitherK`](#chainreadereitherk).
     *
     * @category combinators
     * @since 2.11.0
     */
    var chainReaderEitherKW = function (f) {
        return chainW$1(fromReaderEitherK(f));
    };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var chainReaderEitherK = chainReaderEitherKW;
    /**
     * Less strict version of [`chainFirstReaderEitherK`](#chainfirstreadereitherk).
     *
     * @category combinators
     * @since 2.11.0
     */
    var chainFirstReaderEitherKW = function (f) {
        return chainFirstW$1(fromReaderEitherK(f));
    };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var chainFirstReaderEitherK = chainFirstReaderEitherKW;
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _map$c = function (fa, f) { return pipe$1(fa, map$h(f)); };
    var _apPar = function (fab, fa) { return pipe$1(fab, ap$6(fa)); };
    var _apSeq$1 = function (fab, fa) {
        return pipe$1(fab, chain$7(function (f) { return pipe$1(fa, map$h(f)); }));
    };
    /* istanbul ignore next */
    var _chain$3 = function (ma, f) { return pipe$1(ma, chain$7(f)); };
    /* istanbul ignore next */
    var _alt$2 = function (fa, that) { return pipe$1(fa, alt$2(that)); };
    /* istanbul ignore next */
    var _bimap$5 = function (fa, f, g) { return pipe$1(fa, bimap$6(f, g)); };
    /* istanbul ignore next */
    var _mapLeft$5 = function (fa, f) { return pipe$1(fa, mapLeft$6(f)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$h = 
    /*#__PURE__*/
    map$v(Functor$f);
    /**
     * Map a pair of functions over the two last type arguments of the bifunctor.
     *
     * @category Bifunctor
     * @since 2.0.0
     */
    var bimap$6 = 
    /*#__PURE__*/
    bimap$a(Functor$f);
    /**
     * Map a function over the second type argument of a bifunctor.
     *
     * @category Bifunctor
     * @since 2.0.0
     */
    var mapLeft$6 = 
    /*#__PURE__*/
    mapLeft$a(Functor$f);
    /**
     * Apply a function to an argument under a type constructor.
     *
     * @category Apply
     * @since 2.0.0
     */
    var ap$6 = 
    /*#__PURE__*/
    ap$i(ApplyPar$3);
    /**
     * Less strict version of [`ap`](#ap).
     *
     * @category Apply
     * @since 2.8.0
     */
    var apW$1 = ap$6;
    /**
     * @category Pointed
     * @since 2.7.0
     */
    var of$8 = right$5;
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category Monad
     * @since 2.0.0
     */
    var chain$7 = 
    /*#__PURE__*/
    chain$j(Monad$5);
    /**
     * Less strict version of [`chain`](#chain).
     *
     * @category Monad
     * @since 2.6.0
     */
    var chainW$1 = chain$7;
    /**
     * Less strict version of [`flatten`](#flatten).
     *
     * @category combinators
     * @since 2.11.0
     */
    var flattenW$1 = 
    /*#__PURE__*/
    chainW$1(identity$1);
    /**
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var flatten$3 = flattenW$1;
    /**
     * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
     * types of kind `* -> *`.
     *
     * @category Alt
     * @since 2.0.0
     */
    var alt$2 = 
    /*#__PURE__*/
    alt$8(Monad$5);
    /**
     * Less strict version of [`alt`](#alt).
     *
     * @category Alt
     * @since 2.9.0
     */
    var altW$2 = alt$2;
    /**
     * @category MonadThrow
     * @since 2.0.0
     */
    var throwError$1 = left$5;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$d = 'ReaderTaskEither';
    /**
     * @category instances
     * @since 2.10.0
     */
    var getCompactable = function (M) {
        var C = getCompactable$4(M);
        return {
            URI: URI$d,
            _E: undefined,
            compact: compact$7(Functor$f, C),
            separate: separate$7(Functor$f, C, Functor$p)
        };
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    function getFilterable(M) {
        var F = getFilterable$4(M);
        var C = getCompactable(M);
        var filter = filter$7(Functor$f, F);
        var filterMap = filterMap$7(Functor$f, F);
        var partition = partition$7(Functor$f, F);
        var partitionMap = partitionMap$7(Functor$f, F);
        return {
            URI: URI$d,
            _E: undefined,
            map: _map$c,
            compact: C.compact,
            separate: C.separate,
            filter: function (fa, predicate) { return pipe$1(fa, filter(predicate)); },
            filterMap: function (fa, f) { return pipe$1(fa, filterMap(f)); },
            partition: function (fa, predicate) { return pipe$1(fa, partition(predicate)); },
            partitionMap: function (fa, f) { return pipe$1(fa, partitionMap(f)); }
        };
    }
    /**
     * @category instances
     * @since 2.7.0
     */
    function getApplicativeReaderTaskValidation(A, S) {
        var ap = ap$p(Apply$7, getApplicativeTaskValidation(A, S));
        return {
            URI: URI$d,
            _E: undefined,
            map: _map$c,
            ap: function (fab, fa) { return pipe$1(fab, ap(fa)); },
            of: of$8
        };
    }
    /**
     * @category instances
     * @since 2.7.0
     */
    function getAltReaderTaskValidation(S) {
        var alt = altValidation(Monad$5, S);
        return {
            URI: URI$d,
            _E: undefined,
            map: _map$c,
            alt: function (fa, that) { return pipe$1(fa, alt(that)); }
        };
    }
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$d = {
        URI: URI$d,
        map: _map$c
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$d = 
    /*#__PURE__*/
    flap$x(Functor$d);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$5 = {
        URI: URI$d,
        of: of$8
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var ApplyPar$1 = {
        URI: URI$d,
        map: _map$c,
        ap: _apPar
    };
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apFirst$4 = 
    /*#__PURE__*/
    apFirst$k(ApplyPar$1);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apSecond$4 = 
    /*#__PURE__*/
    apSecond$k(ApplyPar$1);
    /**
     * @category instances
     * @since 2.7.0
     */
    var ApplicativePar$1 = {
        URI: URI$d,
        map: _map$c,
        ap: _apPar,
        of: of$8
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var ApplySeq$1 = {
        URI: URI$d,
        map: _map$c,
        ap: _apSeq$1
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var ApplicativeSeq$1 = {
        URI: URI$d,
        map: _map$c,
        ap: _apSeq$1,
        of: of$8
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$5 = {
        URI: URI$d,
        map: _map$c,
        ap: _apPar,
        chain: _chain$3
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Monad$3 = {
        URI: URI$d,
        map: _map$c,
        ap: _apPar,
        chain: _chain$3,
        of: of$8
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var MonadIO$2 = {
        URI: URI$d,
        map: _map$c,
        ap: _apPar,
        chain: _chain$3,
        of: of$8,
        fromIO: fromIO$3
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var MonadTask$2 = {
        URI: URI$d,
        map: _map$c,
        ap: _apPar,
        chain: _chain$3,
        of: of$8,
        fromIO: fromIO$3,
        fromTask: fromTask$3
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var MonadThrow$1 = {
        URI: URI$d,
        map: _map$c,
        ap: _apPar,
        chain: _chain$3,
        of: of$8,
        throwError: throwError$1
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var chainFirst$4 = 
    /*#__PURE__*/
    chainFirst$k(Chain$5);
    /**
     * Less strict version of [`chainFirst`](#chainfirst).
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.8.0
     */
    var chainFirstW$1 = chainFirst$4;
    /**
     * @category instances
     * @since 2.7.0
     */
    var Bifunctor$5 = {
        URI: URI$d,
        bimap: _bimap$5,
        mapLeft: _mapLeft$5
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Alt$2 = {
        URI: URI$d,
        map: _map$c,
        alt: _alt$2
    };
    /**
     * @category instances
     * @since 2.11.0
     */
    var FromReader$1 = {
        URI: URI$d,
        fromReader: fromReader$1
    };
    /**
     * Reads the current context.
     *
     * @category constructors
     * @since 2.0.0
     */
    var ask$1 = 
    /*#__PURE__*/
    ask$4(FromReader$1);
    /**
     * Projects a value from the global context in a `ReaderEither`.
     *
     * @category constructors
     * @since 2.0.0
     */
    var asks$1 = 
    /*#__PURE__*/
    asks$4(FromReader$1);
    /**
     * @category combinators
     * @since 2.11.0
     */
    var fromReaderK$1 = 
    /*#__PURE__*/
    fromReaderK$4(FromReader$1);
    /**
     * @category combinators
     * @since 2.11.0
     */
    var chainReaderK$1 = 
    /*#__PURE__*/
    chainReaderK$4(FromReader$1, Chain$5);
    /**
     * Less strict version of [`chainReaderK`](#chainreaderk).
     *
     * @category combinators
     * @since 2.11.0
     */
    var chainReaderKW$1 = chainReaderK$1;
    /**
     * @category combinators
     * @since 2.11.0
     */
    var chainFirstReaderK$1 = 
    /*#__PURE__*/
    chainFirstReaderK$4(FromReader$1, Chain$5);
    /**
     * Less strict version of [`chainFirstReaderK`](#chainfirstreaderk).
     *
     * @category combinators
     * @since 2.11.0
     */
    var chainFirstReaderKW$1 = chainFirstReaderK$1;
    /**
     * @category combinators
     * @since 2.11.0
     */
    var fromReaderTaskK = function (f) { return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return rightReaderTask(f.apply(void 0, a));
    }; };
    /**
     * Less strict version of [`chainReaderTaskK`](#chainreadertaskk).
     *
     * @category combinators
     * @since 2.11.0
     */
    var chainReaderTaskKW = function (f) {
        return chainW$1(fromReaderTaskK(f));
    };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var chainReaderTaskK = chainReaderTaskKW;
    /**
     * Less strict version of [`chainFirstReaderTaskK`](#chainfirstreadertaskk).
     *
     * @category combinators
     * @since 2.11.0
     */
    var chainFirstReaderTaskKW = function (f) {
        return chainFirstW$1(fromReaderTaskK(f));
    };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var chainFirstReaderTaskK = chainFirstReaderTaskKW;
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromEither$5 = {
        URI: URI$d,
        fromEither: fromEither$3
    };
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromOption$5 = 
    /*#__PURE__*/
    fromOption$c(FromEither$5);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromOptionK$6 = 
    /*#__PURE__*/
    fromOptionK$e(FromEither$5);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainOptionK$3 = 
    /*#__PURE__*/
    chainOptionK$9(FromEither$5, Chain$5);
    /**
     * @category combinators
     * @since 2.4.0
     */
    var chainEitherK$2 = 
    /*#__PURE__*/
    chainEitherK$7(FromEither$5, Chain$5);
    /**
     * Less strict version of [`chainEitherK`](#chaineitherk).
     *
     * @category combinators
     * @since 2.6.1
     */
    var chainEitherKW$1 = chainEitherK$2;
    /**
     * @category constructors
     * @since 2.0.0
     */
    var fromPredicate$4 = 
    /*#__PURE__*/
    fromPredicate$d(FromEither$5);
    /**
     * @category combinators
     * @since 2.0.0
     */
    var filterOrElse$2 = 
    /*#__PURE__*/
    filterOrElse$7(FromEither$5, Chain$5);
    /**
     * Less strict version of [`filterOrElse`](#filterorelse).
     *
     * @category combinators
     * @since 2.9.0
     */
    var filterOrElseW$1 = filterOrElse$2;
    /**
     * @category combinators
     * @since 2.4.0
     */
    var fromEitherK$3 = 
    /*#__PURE__*/
    fromEitherK$a(FromEither$5);
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromIO$3 = {
        URI: URI$d,
        fromIO: fromIO$3
    };
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromIOK$3 = 
    /*#__PURE__*/
    fromIOK$8(FromIO$3);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainIOK$2 = 
    /*#__PURE__*/
    chainIOK$7(FromIO$3, Chain$5);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainFirstIOK$2 = 
    /*#__PURE__*/
    chainFirstIOK$7(FromIO$3, Chain$5);
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromTask$3 = {
        URI: URI$d,
        fromIO: fromIO$3,
        fromTask: fromTask$3
    };
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromTaskK$3 = 
    /*#__PURE__*/
    fromTaskK$6(FromTask$3);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainTaskK$2 = 
    /*#__PURE__*/
    chainTaskK$5(FromTask$3, Chain$5);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainFirstTaskK$2 = 
    /*#__PURE__*/
    chainFirstTaskK$5(FromTask$3, Chain$5);
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * Make sure that a resource is cleaned up in the event of an exception (\*). The release action is called regardless of
     * whether the body action throws (\*) or returns.
     *
     * (\*) i.e. returns a `Left`
     *
     * @since 2.0.4
     */
    function bracket(aquire, use, release) {
        return function (r) {
            return bracket$1(aquire(r), function (a) { return use(a)(r); }, function (a, e) { return release(a, e)(r); });
        };
    }
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.9.0
     */
    var Do$2 = 
    /*#__PURE__*/
    of$8(emptyRecord);
    /**
     * @since 2.8.0
     */
    var bindTo$4 = 
    /*#__PURE__*/
    bindTo$k(Functor$d);
    /**
     * @since 2.8.0
     */
    var bind$6 = 
    /*#__PURE__*/
    bind$m(Chain$5);
    /**
     * @since 2.8.0
     */
    var bindW$1 = bind$6;
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var apS$4 = 
    /*#__PURE__*/
    apS$k(ApplyPar$1);
    /**
     * @since 2.8.0
     */
    var apSW$1 = apS$4;
    // -------------------------------------------------------------------------------------
    // sequence T
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var ApT$3 = 
    /*#__PURE__*/
    of$8(emptyReadonlyArray);
    // -------------------------------------------------------------------------------------
    // array utils
    // -------------------------------------------------------------------------------------
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndex$4 = function (f) {
        return flow(traverseReadonlyNonEmptyArrayWithIndex$c(f), map$u(traverseReadonlyNonEmptyArrayWithIndex$5(SK)));
    };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndex$4 = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndex$4(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT$3); };
    };
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativeSeq)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndexSeq$2 = function (f) {
        return flow(traverseReadonlyNonEmptyArrayWithIndex$c(f), map$u(traverseReadonlyNonEmptyArrayWithIndexSeq$3(SK)));
    };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndexSeq$2 = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndexSeq$2(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT$3); };
    };
    /**
     * @since 2.9.0
     */
    var traverseArrayWithIndex$2 = traverseReadonlyArrayWithIndex$4;
    /**
     * @since 2.9.0
     */
    var traverseArray$2 = function (f) {
        return traverseReadonlyArrayWithIndex$4(function (_, a) { return f(a); });
    };
    /**
     * @since 2.9.0
     */
    var sequenceArray$2 = 
    /*#__PURE__*/
    traverseArray$2(identity$1);
    /**
     * @since 2.9.0
     */
    var traverseSeqArrayWithIndex$1 = traverseReadonlyArrayWithIndexSeq$2;
    /**
     * @since 2.9.0
     */
    var traverseSeqArray$1 = function (f) {
        return traverseReadonlyArrayWithIndexSeq$2(function (_, a) { return f(a); });
    };
    /**
     * @since 2.9.0
     */
    var sequenceSeqArray$1 = 
    /*#__PURE__*/
    traverseSeqArray$1(identity$1);
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var readerTaskEither = {
        URI: URI$d,
        map: _map$c,
        of: of$8,
        ap: _apPar,
        chain: _chain$3,
        alt: _alt$2,
        bimap: _bimap$5,
        mapLeft: _mapLeft$5,
        fromIO: fromIO$3,
        fromTask: fromTask$3,
        throwError: throwError$1
    };
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var readerTaskEitherSeq = {
        URI: URI$d,
        map: _map$c,
        of: of$8,
        ap: _apSeq$1,
        chain: _chain$3,
        alt: _alt$2,
        bimap: _bimap$5,
        mapLeft: _mapLeft$5,
        fromIO: fromIO$3,
        fromTask: fromTask$3,
        throwError: throwError$1
    };
    /**
     * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
     *
     * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values
     * are concatenated using the provided `Semigroup`
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getApplySemigroup$1 = 
    /*#__PURE__*/
    getApplySemigroup$7(ApplySeq$1);
    /**
     * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getApplyMonoid = 
    /*#__PURE__*/
    getApplicativeMonoid$1(ApplicativeSeq$1);
    /**
     * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getSemigroup$2 = function (S) {
        return getApplySemigroup$7(ApplySeq$3)(getSemigroup$b(S));
    };
    /**
     * Use [`getApplicativeReaderTaskValidation`](#getapplicativereadertaskvalidation) and [`getAltReaderTaskValidation`](#getaltreadertaskvalidation) instead.
     *
     * @category instances
     * @since 2.3.0
     * @deprecated
     */
    function getReaderTaskValidation(SE) {
        var applicativeReaderTaskValidation = getApplicativeReaderTaskValidation(ApplicativePar$4, SE);
        var altReaderTaskValidation = getAltReaderTaskValidation(SE);
        return {
            URI: URI$d,
            _E: undefined,
            map: _map$c,
            of: of$8,
            chain: _chain$3,
            bimap: _bimap$5,
            mapLeft: _mapLeft$5,
            ap: applicativeReaderTaskValidation.ap,
            alt: altReaderTaskValidation.alt,
            fromIO: fromIO$3,
            fromTask: fromTask$3,
            throwError: throwError$1
        };
    }
    /**
     * @since 2.0.0
     * @deprecated
     */
    /* istanbul ignore next */
    function run$1(ma, r) {
        return ma(r)();
    }

    var ReaderTaskEither = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fromTaskEither: fromTaskEither$2,
        left: left$5,
        right: right$5,
        rightTask: rightTask$2,
        leftTask: leftTask$2,
        rightReader: rightReader$1,
        leftReader: leftReader$1,
        rightReaderTask: rightReaderTask,
        leftReaderTask: leftReaderTask,
        rightIO: rightIO$2,
        leftIO: leftIO$2,
        fromEither: fromEither$3,
        fromReader: fromReader$1,
        fromIO: fromIO$3,
        fromTask: fromTask$3,
        fromIOEither: fromIOEither$2,
        fromReaderEither: fromReaderEither$1,
        match: match$4,
        matchW: matchW$3,
        matchE: matchE$3,
        fold: fold$4,
        matchEW: matchEW$2,
        foldW: foldW$3,
        getOrElse: getOrElse$1,
        getOrElseW: getOrElseW$1,
        toUnion: toUnion,
        local: local$1,
        asksReaderTaskEitherW: asksReaderTaskEitherW,
        asksReaderTaskEither: asksReaderTaskEither,
        orElse: orElse,
        orElseW: orElseW,
        orElseFirst: orElseFirst,
        orElseFirstW: orElseFirstW,
        orLeft: orLeft,
        swap: swap$5,
        fromIOEitherK: fromIOEitherK$1,
        chainIOEitherKW: chainIOEitherKW$1,
        chainIOEitherK: chainIOEitherK$1,
        fromTaskEitherK: fromTaskEitherK$1,
        chainTaskEitherKW: chainTaskEitherKW$1,
        chainTaskEitherK: chainTaskEitherK$1,
        chainFirstTaskEitherKW: chainFirstTaskEitherKW,
        chainFirstTaskEitherK: chainFirstTaskEitherK,
        fromReaderEitherK: fromReaderEitherK,
        chainReaderEitherKW: chainReaderEitherKW,
        chainReaderEitherK: chainReaderEitherK,
        chainFirstReaderEitherKW: chainFirstReaderEitherKW,
        chainFirstReaderEitherK: chainFirstReaderEitherK,
        map: map$h,
        bimap: bimap$6,
        mapLeft: mapLeft$6,
        ap: ap$6,
        apW: apW$1,
        of: of$8,
        chain: chain$7,
        chainW: chainW$1,
        flattenW: flattenW$1,
        flatten: flatten$3,
        alt: alt$2,
        altW: altW$2,
        throwError: throwError$1,
        URI: URI$d,
        getCompactable: getCompactable,
        getFilterable: getFilterable,
        getApplicativeReaderTaskValidation: getApplicativeReaderTaskValidation,
        getAltReaderTaskValidation: getAltReaderTaskValidation,
        Functor: Functor$d,
        flap: flap$d,
        Pointed: Pointed$5,
        ApplyPar: ApplyPar$1,
        apFirst: apFirst$4,
        apSecond: apSecond$4,
        ApplicativePar: ApplicativePar$1,
        ApplySeq: ApplySeq$1,
        ApplicativeSeq: ApplicativeSeq$1,
        Chain: Chain$5,
        Monad: Monad$3,
        MonadIO: MonadIO$2,
        MonadTask: MonadTask$2,
        MonadThrow: MonadThrow$1,
        chainFirst: chainFirst$4,
        chainFirstW: chainFirstW$1,
        Bifunctor: Bifunctor$5,
        Alt: Alt$2,
        FromReader: FromReader$1,
        ask: ask$1,
        asks: asks$1,
        fromReaderK: fromReaderK$1,
        chainReaderK: chainReaderK$1,
        chainReaderKW: chainReaderKW$1,
        chainFirstReaderK: chainFirstReaderK$1,
        chainFirstReaderKW: chainFirstReaderKW$1,
        fromReaderTaskK: fromReaderTaskK,
        chainReaderTaskKW: chainReaderTaskKW,
        chainReaderTaskK: chainReaderTaskK,
        chainFirstReaderTaskKW: chainFirstReaderTaskKW,
        chainFirstReaderTaskK: chainFirstReaderTaskK,
        FromEither: FromEither$5,
        fromOption: fromOption$5,
        fromOptionK: fromOptionK$6,
        chainOptionK: chainOptionK$3,
        chainEitherK: chainEitherK$2,
        chainEitherKW: chainEitherKW$1,
        fromPredicate: fromPredicate$4,
        filterOrElse: filterOrElse$2,
        filterOrElseW: filterOrElseW$1,
        fromEitherK: fromEitherK$3,
        FromIO: FromIO$3,
        fromIOK: fromIOK$3,
        chainIOK: chainIOK$2,
        chainFirstIOK: chainFirstIOK$2,
        FromTask: FromTask$3,
        fromTaskK: fromTaskK$3,
        chainTaskK: chainTaskK$2,
        chainFirstTaskK: chainFirstTaskK$2,
        bracket: bracket,
        Do: Do$2,
        bindTo: bindTo$4,
        bind: bind$6,
        bindW: bindW$1,
        apS: apS$4,
        apSW: apSW$1,
        ApT: ApT$3,
        traverseReadonlyNonEmptyArrayWithIndex: traverseReadonlyNonEmptyArrayWithIndex$4,
        traverseReadonlyArrayWithIndex: traverseReadonlyArrayWithIndex$4,
        traverseReadonlyNonEmptyArrayWithIndexSeq: traverseReadonlyNonEmptyArrayWithIndexSeq$2,
        traverseReadonlyArrayWithIndexSeq: traverseReadonlyArrayWithIndexSeq$2,
        traverseArrayWithIndex: traverseArrayWithIndex$2,
        traverseArray: traverseArray$2,
        sequenceArray: sequenceArray$2,
        traverseSeqArrayWithIndex: traverseSeqArrayWithIndex$1,
        traverseSeqArray: traverseSeqArray$1,
        sequenceSeqArray: sequenceSeqArray$1,
        readerTaskEither: readerTaskEither,
        readerTaskEitherSeq: readerTaskEitherSeq,
        getApplySemigroup: getApplySemigroup$1,
        getApplyMonoid: getApplyMonoid,
        getSemigroup: getSemigroup$2,
        getReaderTaskValidation: getReaderTaskValidation,
        run: run$1
    });

    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @example
     * import * as S from 'fp-ts/string'
     *
     * assert.deepStrictEqual(S.Eq.equals('a', 'a'), true)
     * assert.deepStrictEqual(S.Eq.equals('a', 'b'), false)
     *
     * @category instances
     * @since 2.10.0
     */
    var Eq$1 = {
        equals: function (first, second) { return first === second; }
    };
    /**
     * `string` semigroup under concatenation.
     *
     * @example
     * import * as S from 'fp-ts/string'
     *
     * assert.deepStrictEqual(S.Semigroup.concat('a', 'b'), 'ab')
     *
     * @category instances
     * @since 2.10.0
     */
    var Semigroup$2 = {
        concat: function (first, second) { return first + second; }
    };
    /**
     * `string` monoid under concatenation.
     *
     * The `empty` value is `''`.
     *
     * @example
     * import * as S from 'fp-ts/string'
     *
     * assert.deepStrictEqual(S.Monoid.concat('a', 'b'), 'ab')
     * assert.deepStrictEqual(S.Monoid.concat('a', S.Monoid.empty), 'a')
     *
     * @category instances
     * @since 2.10.0
     */
    var Monoid$1 = {
        concat: Semigroup$2.concat,
        empty: ''
    };
    /**
     * @example
     * import * as S from 'fp-ts/string'
     *
     * assert.deepStrictEqual(S.Ord.compare('a', 'a'), 0)
     * assert.deepStrictEqual(S.Ord.compare('a', 'b'), -1)
     * assert.deepStrictEqual(S.Ord.compare('b', 'a'), 1)
     *
     * @category instances
     * @since 2.10.0
     */
    var Ord$1 = {
        equals: Eq$1.equals,
        compare: function (first, second) { return (first < second ? -1 : first > second ? 1 : 0); }
    };
    /**
     * @example
     * import * as S from 'fp-ts/string'
     *
     * assert.deepStrictEqual(S.Show.show('a'), '"a"')
     *
     * @category instances
     * @since 2.10.0
     */
    var Show$1 = {
        show: function (s) { return JSON.stringify(s); }
    };
    // -------------------------------------------------------------------------------------
    // refinements
    // -------------------------------------------------------------------------------------
    /**
     * @example
     * import * as S from 'fp-ts/string'
     *
     * assert.deepStrictEqual(S.isString('a'), true)
     * assert.deepStrictEqual(S.isString(1), false)
     *
     * @category refinements
     * @since 2.11.0
     */
    var isString = function (u) { return typeof u === 'string'; };
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * @example
     * import * as S from 'fp-ts/string'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe('a', S.toUpperCase), 'A')
     *
     * @category combinators
     * @since 2.11.0
     */
    var toUpperCase = function (s) { return s.toUpperCase(); };
    /**
     * @example
     * import * as S from 'fp-ts/string'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe('A', S.toLowerCase), 'a')
     *
     * @category combinators
     * @since 2.11.0
     */
    var toLowerCase = function (s) { return s.toLowerCase(); };
    /**
     * @example
     * import * as S from 'fp-ts/string'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe('abc', S.replace('b', 'd')), 'adc')
     *
     * @category combinators
     * @since 2.11.0
     */
    var replace = function (searchValue, replaceValue) { return function (s) {
        return s.replace(searchValue, replaceValue);
    }; };
    /**
     * @example
     * import * as S from 'fp-ts/string'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe(' a ', S.trim), 'a')
     *
     * @category combinators
     * @since 2.11.0
     */
    var trim = function (s) { return s.trim(); };
    /**
     * @example
     * import * as S from 'fp-ts/string'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe(' a ', S.trimLeft), 'a ')
     *
     * @category combinators
     * @since 2.11.0
     */
    var trimLeft = function (s) { return s.trimLeft(); };
    /**
     * @example
     * import * as S from 'fp-ts/string'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe(' a ', S.trimRight), ' a')
     *
     * @category combinators
     * @since 2.11.0
     */
    var trimRight = function (s) { return s.trimRight(); };
    /**
     * @example
     * import * as S from 'fp-ts/string'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe('abcd', S.slice(1, 3)), 'bc')
     *
     * @category combinators
     * @since 2.11.0
     */
    var slice$2 = function (start, end) { return function (s) { return s.slice(start, end); }; };
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * An empty `string`.
     *
     * @since 2.10.0
     */
    var empty$4 = '';
    /**
     * Test whether a `string` is empty.
     *
     * @example
     * import * as S from 'fp-ts/string'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe('', S.isEmpty), true)
     * assert.deepStrictEqual(pipe('a', S.isEmpty), false)
     *
     * @since 2.10.0
     */
    var isEmpty$4 = function (s) { return s.length === 0; };
    /**
     * Calculate the number of characters in a `string`.
     *
     * @example
     * import * as S from 'fp-ts/string'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe('abc', S.size), 3)
     *
     * @since 2.10.0
     */
    var size$4 = function (s) { return s.length; };
    /**
     * @example
     * import * as S from 'fp-ts/string'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe('abc', S.split('')), ['a', 'b', 'c'])
     * assert.deepStrictEqual(pipe('', S.split('')), [''])
     *
     * @since 2.11.0
     */
    var split$1 = function (separator) { return function (s) {
        var out = s.split(separator);
        return isNonEmpty$4(out) ? out : [s];
    }; };
    /**
     * @example
     * import * as S from 'fp-ts/string'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe('abc', S.includes('b')), true)
     * assert.deepStrictEqual(pipe('abc', S.includes('d')), false)
     *
     * @since 2.11.0
     */
    var includes = function (searchString, position) { return function (s) {
        return s.includes(searchString, position);
    }; };
    /**
     * @example
     * import * as S from 'fp-ts/string'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe('abc', S.startsWith('a')), true)
     * assert.deepStrictEqual(pipe('bc', S.startsWith('a')), false)
     *
     * @since 2.11.0
     */
    var startsWith = function (searchString, position) { return function (s) {
        return s.startsWith(searchString, position);
    }; };
    /**
     * @example
     * import * as S from 'fp-ts/string'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(pipe('abc', S.endsWith('c')), true)
     * assert.deepStrictEqual(pipe('ab', S.endsWith('c')), false)
     *
     * @since 2.11.0
     */
    var endsWith = function (searchString, position) { return function (s) {
        return s.endsWith(searchString, position);
    }; };

    var string = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Eq: Eq$1,
        Semigroup: Semigroup$2,
        Monoid: Monoid$1,
        Ord: Ord$1,
        Show: Show$1,
        isString: isString,
        toUpperCase: toUpperCase,
        toLowerCase: toLowerCase,
        replace: replace,
        trim: trim,
        trimLeft: trimLeft,
        trimRight: trimRight,
        slice: slice$2,
        empty: empty$4,
        isEmpty: isEmpty$4,
        size: size$4,
        split: split$1,
        includes: includes,
        startsWith: startsWith,
        endsWith: endsWith
    });

    // -------------------------------------------------------------------------------------
    // interop
    // -------------------------------------------------------------------------------------
    /**
     * Builds a `ReadonlyRecord` by copying a `Record`.
     *
     * @example
     * import { ReadonlyRecord, fromRecord } from "fp-ts/ReadonlyRecord"
     *
     * const x: Record<string, number> = { a: 1, b: 2 };
     * const y: ReadonlyRecord<string, number> = fromRecord(x);
     * assert.deepStrictEqual(x,y);
     * // `y.a = 5` gives compiler error
     *
     * @category interop
     * @since 2.5.0
     */
    var fromRecord = function (r) { return Object.assign({}, r); };
    /**
     * Builds a mutable `Record` from a `ReadonlyRecord`.
     *
     * @example
     * import { ReadonlyRecord, toRecord } from "fp-ts/ReadonlyRecord"
     *
     * const x: ReadonlyRecord<string, number> = { a: 1, b: 2 };
     * const y: Record<string, number> = toRecord(x);
     * assert.deepStrictEqual(x,y);
     * y.a = 5; // it's ok, y is mutable
     *
     * @category interop
     * @since 2.5.0
     */
    var toRecord = function (r) { return Object.assign({}, r); };
    /**
     * Calculate the number of key/value pairs in a `ReadonlyRecord`,
     *
     * @example
     * import { size } from "fp-ts/ReadonlyRecord";
     *
     * assert.deepStrictEqual(size({ a: true, b: 2, c: "three" }), 3);
     *
     * @since 2.5.0
     */
    var size$3 = function (r) { return Object.keys(r).length; };
    /**
     * Test whether a `ReadonlyRecord` is empty.
     *
     * @example
     * import { isEmpty } from "fp-ts/ReadonlyRecord"
     *
     * assert.deepStrictEqual(isEmpty({}), true);
     * assert.deepStrictEqual(isEmpty({ a: 3 }), false);
     * @since 2.5.0
     */
    var isEmpty$3 = function (r) {
        for (var k in r) {
            if (has$4.call(r, k)) {
                return false;
            }
        }
        return true;
    };
    var keys_$1 = function (O) { return function (r) {
        return Object.keys(r).sort(O.compare);
    }; };
    /**
     * @since 2.5.0
     */
    var keys$2 = 
    /*#__PURE__*/
    keys_$1(Ord$1);
    function collect$1(O) {
        if (typeof O === 'function') {
            return collect$1(Ord$1)(O);
        }
        var keysO = keys_$1(O);
        return function (f) { return function (r) {
            var out = [];
            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {
                var key = _a[_i];
                out.push(f(key, r[key]));
            }
            return out;
        }; };
    }
    /**
     * Get a sorted `ReadonlyArray` of the key/value pairs contained in a `ReadonlyRecord`.
     *
     * @example
     * import { toReadonlyArray } from 'fp-ts/ReadonlyRecord'
     *
     * const x = { c: 3, a: "foo", b: false };
     * assert.deepStrictEqual(toReadonlyArray(x), [
     *   ["a", "foo"],
     *   ["b", false],
     *   ["c", 3],
     * ]);
     *
     * @since 2.5.0
     */
    var toReadonlyArray$1 = 
    /*#__PURE__*/
    collect$1(Ord$1)(function (k, a) { return [k, a]; });
    function toUnfoldable$1(U) {
        return function (r) {
            var sas = toReadonlyArray$1(r);
            var len = sas.length;
            return U.unfold(0, function (b) { return (b < len ? some$a([sas[b], b + 1]) : none$2); });
        };
    }
    /**
     * Insert or replace a key/value pair in a `ReadonlyRecord`.
     *
     * @example
     * import { upsertAt } from 'fp-ts/ReadonlyRecord'
     *
     * assert.deepStrictEqual(upsertAt("a", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });
     * assert.deepStrictEqual(upsertAt("c", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });
     *
     * @category combinators
     * @since 2.10.0
     */
    var upsertAt$1 = function (k, a) { return function (r) {
        if (has$4.call(r, k) && r[k] === a) {
            return r;
        }
        var out = Object.assign({}, r);
        out[k] = a;
        return out;
    }; };
    /**
     * Test whether or not a key exists in a `ReadonlyRecord`.
     *
     * Note. This function is not pipeable because is a `Refinement`.
     *
     * @example
     * import { has } from 'fp-ts/ReadonlyRecord'
     *
     * assert.deepStrictEqual(has("a", { a: 1, b: 2 }), true);
     * assert.deepStrictEqual(has("c", { a: 1, b: 2 }), false);
     *
     * @since 2.10.0
     */
    var has$3 = function (k, r) { return has$4.call(r, k); };
    function deleteAt$1(k) {
        return function (r) {
            if (!has$4.call(r, k)) {
                return r;
            }
            var out = Object.assign({}, r);
            delete out[k];
            return out;
        };
    }
    /**
     * Replace a key/value pair in a `ReadonlyRecord`.
     *
     * @returns If the specified key exists it returns an `Option` containing a new `Record`
     * with the entry updated, otherwise it returns `None`
     *
     * @example
     * import { updateAt } from 'fp-ts/ReadonlyRecord'
     * import { option } from 'fp-ts'
     *
     * assert.deepStrictEqual(updateAt("a", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));
     * assert.deepStrictEqual(updateAt("c", 3)({ a: 1, b: 2 }), option.none);
     *
     * @since 2.5.0
     */
    var updateAt$1 = function (k, a) { return function (r) {
        if (!has$3(k, r)) {
            return none$2;
        }
        if (r[k] === a) {
            return some$a(r);
        }
        var out = Object.assign({}, r);
        out[k] = a;
        return some$a(out);
    }; };
    /**
     * Applies a mapping function to one spcific key/value pair in a `ReadonlyRecord`.
     *
     * @returns If the specified key exists it returns an `Option` containing a new `Record`
     * with the entry updated, otherwise it returns `None`
     *
     * @example
     * import { modifyAt } from 'fp-ts/ReadonlyRecord'
     * import { option } from 'fp-ts'
     *
     * assert.deepStrictEqual(modifyAt("a", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));
     * assert.deepStrictEqual(modifyAt("c", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);
     *
     * @since 2.5.0
     */
    var modifyAt$1 = function (k, f) { return function (r) {
        if (!has$3(k, r)) {
            return none$2;
        }
        var next = f(r[k]);
        if (next === r[k]) {
            return some$a(r);
        }
        var out = Object.assign({}, r);
        out[k] = next;
        return some$a(out);
    }; };
    function pop$1(k) {
        var deleteAtk = deleteAt$1(k);
        return function (r) {
            var oa = lookup$1(k, r);
            return isNone$2(oa) ? none$2 : some$a([oa.value, deleteAtk(r)]);
        };
    }
    function isSubrecord$1(E) {
        return function (me, that) {
            if (that === undefined) {
                var isSubrecordE_1 = isSubrecord$1(E);
                return function (that) { return isSubrecordE_1(that, me); };
            }
            for (var k in me) {
                if (!has$4.call(that, k) || !E.equals(me[k], that[k])) {
                    return false;
                }
            }
            return true;
        };
    }
    function lookup$1(k, r) {
        if (r === undefined) {
            return function (r) { return lookup$1(k, r); };
        }
        return has$4.call(r, k) ? some$a(r[k]) : none$2;
    }
    /**
     * @since 2.5.0
     */
    var empty$3 = {};
    function mapWithIndex$1(f) {
        return function (r) {
            var out = {};
            for (var k in r) {
                if (has$4.call(r, k)) {
                    out[k] = f(k, r[k]);
                }
            }
            return out;
        };
    }
    function map$g(f) {
        return mapWithIndex$1(function (_, a) { return f(a); });
    }
    function reduceWithIndex$1() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 2) {
            return reduceWithIndex$1(Ord$1).apply(void 0, args);
        }
        var keysO = keys_$1(args[0]);
        return function (b, f) { return function (fa) {
            var out = b;
            var ks = keysO(fa);
            var len = ks.length;
            for (var i = 0; i < len; i++) {
                var k = ks[i];
                out = f(k, out, fa[k]);
            }
            return out;
        }; };
    }
    function foldMapWithIndex$1(O) {
        if ('compare' in O) {
            var keysO_1 = keys_$1(O);
            return function (M) { return function (f) { return function (fa) {
                var out = M.empty;
                var ks = keysO_1(fa);
                var len = ks.length;
                for (var i = 0; i < len; i++) {
                    var k = ks[i];
                    out = M.concat(out, f(k, fa[k]));
                }
                return out;
            }; }; };
        }
        return foldMapWithIndex$1(Ord$1)(O);
    }
    function reduceRightWithIndex$1() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 2) {
            return reduceRightWithIndex$1(Ord$1).apply(void 0, args);
        }
        var keysO = keys_$1(args[0]);
        return function (b, f) { return function (fa) {
            var out = b;
            var ks = keysO(fa);
            var len = ks.length;
            for (var i = len - 1; i >= 0; i--) {
                var k = ks[i];
                out = f(k, fa[k], out);
            }
            return out;
        }; };
    }
    /**
     * Create a `ReadonlyRecord` with one key/value pair.
     *
     * @example
     * import { singleton } from "fp-ts/ReadonlyRecord";
     *
     * assert.deepStrictEqual(singleton("a", 1), { a: 1 });
     *
     * @category constructors
     * @since 2.5.0
     */
    var singleton$4 = function (k, a) {
        var _a;
        return (_a = {}, _a[k] = a, _a);
    };
    function traverseWithIndex$1(F) {
        var traverseWithIndexOF = _traverseWithIndex$1(Ord$1)(F);
        return function (f) { return function (ta) { return traverseWithIndexOF(ta, f); }; };
    }
    function traverse$6(F) {
        var traverseOF = _traverse$5(Ord$1)(F);
        return function (f) { return function (ta) { return traverseOF(ta, f); }; };
    }
    function sequence$6(F) {
        return _sequence$1(Ord$1)(F);
    }
    /**
     * @category Witherable
     * @since 2.6.5
     */
    var wither$1 = function (F) {
        var traverseF = traverse$6(F);
        return function (f) { return function (fa) { return F.map(pipe$1(fa, traverseF(f)), compact$4); }; };
    };
    /**
     * @category Witherable
     * @since 2.6.5
     */
    var wilt$1 = function (F) {
        var traverseF = traverse$6(F);
        return function (f) { return function (fa) { return F.map(pipe$1(fa, traverseF(f)), separate$4); }; };
    };
    function partitionMapWithIndex$1(f) {
        return function (r) {
            var left = {};
            var right = {};
            for (var k in r) {
                if (has$4.call(r, k)) {
                    var e = f(k, r[k]);
                    switch (e._tag) {
                        case 'Left':
                            left[k] = e.left;
                            break;
                        case 'Right':
                            right[k] = e.right;
                            break;
                    }
                }
            }
            return separated(left, right);
        };
    }
    function partitionWithIndex$1(predicateWithIndex) {
        return function (r) {
            var left = {};
            var right = {};
            for (var k in r) {
                if (has$4.call(r, k)) {
                    var a = r[k];
                    if (predicateWithIndex(k, a)) {
                        right[k] = a;
                    }
                    else {
                        left[k] = a;
                    }
                }
            }
            return separated(left, right);
        };
    }
    function filterMapWithIndex$1(f) {
        return function (r) {
            var out = {};
            for (var k in r) {
                if (has$4.call(r, k)) {
                    var ob = f(k, r[k]);
                    if (isSome$2(ob)) {
                        out[k] = ob.value;
                    }
                }
            }
            return out;
        };
    }
    function filterWithIndex$1(predicateWithIndex) {
        return function (fa) {
            var out = {};
            var changed = false;
            for (var key in fa) {
                if (has$4.call(fa, key)) {
                    var a = fa[key];
                    if (predicateWithIndex(key, a)) {
                        out[key] = a;
                    }
                    else {
                        changed = true;
                    }
                }
            }
            return changed ? out : fa;
        };
    }
    function fromFoldable$1(M, F) {
        var fromFoldableMapM = fromFoldableMap$1(M, F);
        return function (fka) { return fromFoldableMapM(fka, identity$1); };
    }
    function fromFoldableMap$1(M, F) {
        return function (ta, f) {
            return F.reduce(ta, {}, function (r, a) {
                var _a = f(a), k = _a[0], b = _a[1];
                r[k] = has$4.call(r, k) ? M.concat(r[k], b) : b;
                return r;
            });
        };
    }
    /**
     * Test if every value in a `ReadonlyRecord` satisfies the predicate.
     *
     * @example
     * import { every } from "fp-ts/ReadonlyRecord"
     *
     * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: 2 }), true);
     * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: -1 }), false);
     *
     * @since 2.5.0
     */
    function every$3(predicate) {
        return function (r) {
            for (var k in r) {
                if (!predicate(r[k])) {
                    return false;
                }
            }
            return true;
        };
    }
    /**
     * Test if at least one value in a `ReadonlyRecord` satisfies the predicate.
     *
     * @example
     * import { some } from "fp-ts/ReadonlyRecord"
     *
     * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);
     * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);
     *
     * @since 2.5.0
     */
    function some$5(predicate) {
        return function (r) {
            for (var k in r) {
                if (predicate(r[k])) {
                    return true;
                }
            }
            return false;
        };
    }
    function elem$5(E) {
        return function (a, fa) {
            if (fa === undefined) {
                var elemE_1 = elem$5(E);
                return function (fa) { return elemE_1(a, fa); };
            }
            for (var k in fa) {
                if (E.equals(fa[k], a)) {
                    return true;
                }
            }
            return false;
        };
    }
    /**
     * Union of two `ReadonlyRecord`s.
     * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining all the
     * entries of the two inputs.
     * It uses the `concat` function of the provided `Magma` to
     * combine the elements with the same key.
     *
     * @example
     * import { union } from "fp-ts/ReadonlyRecord";
     * import { Magma } from "fp-ts/Magma";
     *
     * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };
     * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });
     * const m2: Magma<number> = { concat: (x: number) => x };
     * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });
     *
     * @category combinators
     * @since 2.11.0
     */
    var union$3 = function (M) { return function (second) { return function (first) {
        if (isEmpty$3(first)) {
            return second;
        }
        if (isEmpty$3(second)) {
            return first;
        }
        var out = {};
        for (var k in first) {
            if (has$3(k, second)) {
                out[k] = M.concat(first[k], second[k]);
            }
            else {
                out[k] = first[k];
            }
        }
        for (var k in second) {
            if (!has$3(k, out)) {
                out[k] = second[k];
            }
        }
        return out;
    }; }; };
    /**
     * Intersection of two `ReadonlyRecord`s.
     * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining only the
     * entries of the two inputswith the same key.
     * It uses the `concat` function of the provided `Magma` to
     * combine the elements.
     *
     * @example
     * import { intersection } from "fp-ts/ReadonlyRecord";
     * import { Magma } from "fp-ts/Magma";
     *
     * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };
     * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});
     * const m2: Magma<number> = { concat: (x: number) => x };
     * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});
     *
     * @category combinators
     * @since 2.11.0
     */
    var intersection$3 = function (M) { return function (second) { return function (first) {
        if (isEmpty$3(first) || isEmpty$3(second)) {
            return empty$3;
        }
        var out = {};
        for (var k in first) {
            if (has$3(k, second)) {
                out[k] = M.concat(first[k], second[k]);
            }
        }
        return out;
    }; }; };
    /**
     * Difference between two `ReadonlyRecord`s.
     * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` composed by the
     * entries of the two inputs, removing the entries with the same
     * key in both inputs.
     *
     * @example
     * import { difference } from "fp-ts/ReadonlyRecord";
     *
     * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });
     * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });
     * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });
     *
     * @category combinators
     * @since 2.11.0
     */
    var difference$3 = function (second) { return function (first) {
        if (isEmpty$3(first)) {
            return second;
        }
        if (isEmpty$3(second)) {
            return first;
        }
        var out = {};
        for (var k in first) {
            if (!has$3(k, second)) {
                out[k] = first[k];
            }
        }
        for (var k in second) {
            if (!has$3(k, first)) {
                out[k] = second[k];
            }
        }
        return out;
    }; };
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    /** @internal */
    var _map$b = function (fa, f) { return pipe$1(fa, map$g(f)); };
    /** @internal */
    /* istanbul ignore next */
    var _mapWithIndex$1 = function (fa, f) { return pipe$1(fa, mapWithIndex$1(f)); };
    /** @internal */
    /* istanbul ignore next */
    var _reduce$5 = function (O) {
        var reduceO = reduce$7(O);
        return function (fa, b, f) { return pipe$1(fa, reduceO(b, f)); };
    };
    /** @internal */
    var _foldMap$5 = function (O) { return function (M) {
        var foldMapM = foldMap$7(O)(M);
        return function (fa, f) { return pipe$1(fa, foldMapM(f)); };
    }; };
    /** @internal */
    /* istanbul ignore next */
    var _reduceRight$5 = function (O) {
        var reduceRightO = reduceRight$7(O);
        return function (fa, b, f) { return pipe$1(fa, reduceRightO(b, f)); };
    };
    /** @internal */
    /* istanbul ignore next */
    var _filter$2 = function (fa, predicate) {
        return pipe$1(fa, filter$4(predicate));
    };
    /** @internal */
    /* istanbul ignore next */
    var _filterMap$2 = function (fa, f) { return pipe$1(fa, filterMap$4(f)); };
    /** @internal */
    /* istanbul ignore next */
    var _partition$2 = function (fa, predicate) { return pipe$1(fa, partition$4(predicate)); };
    /** @internal */
    /* istanbul ignore next */
    var _partitionMap$2 = function (fa, f) { return pipe$1(fa, partitionMap$4(f)); };
    /** @internal */
    /* istanbul ignore next */
    var _reduceWithIndex$1 = function (O) {
        var reduceWithIndexO = reduceWithIndex$1(O);
        return function (fa, b, f) { return pipe$1(fa, reduceWithIndexO(b, f)); };
    };
    /** @internal */
    var _foldMapWithIndex$1 = function (O) {
        var foldMapWithIndexO = foldMapWithIndex$1(O);
        return function (M) {
            var foldMapWithIndexM = foldMapWithIndexO(M);
            return function (fa, f) { return pipe$1(fa, foldMapWithIndexM(f)); };
        };
    };
    /** @internal */
    /* istanbul ignore next */
    var _reduceRightWithIndex$1 = function (O) {
        var reduceRightWithIndexO = reduceRightWithIndex$1(O);
        return function (fa, b, f) { return pipe$1(fa, reduceRightWithIndexO(b, f)); };
    };
    /** @internal */
    /* istanbul ignore next */
    var _partitionMapWithIndex$1 = function (fa, f) { return pipe$1(fa, partitionMapWithIndex$1(f)); };
    /** @internal */
    /* istanbul ignore next */
    var _partitionWithIndex$1 = function (fa, predicateWithIndex) { return pipe$1(fa, partitionWithIndex$1(predicateWithIndex)); };
    /** @internal */
    /* istanbul ignore next */
    var _filterMapWithIndex$1 = function (fa, f) {
        return pipe$1(fa, filterMapWithIndex$1(f));
    };
    /** @internal */
    /* istanbul ignore next */
    var _filterWithIndex$1 = function (fa, predicateWithIndex) {
        return pipe$1(fa, filterWithIndex$1(predicateWithIndex));
    };
    /** @internal */
    var _traverse$5 = function (O) {
        var traverseWithIndexO = _traverseWithIndex$1(O);
        return function (F) {
            var traverseWithIndexOF = traverseWithIndexO(F);
            return function (ta, f) { return traverseWithIndexOF(ta, flow(SK, f)); };
        };
    };
    /** @internal */
    var _sequence$1 = function (O) {
        var traverseO = _traverse$5(O);
        return function (F) {
            var traverseOF = traverseO(F);
            return function (ta) { return traverseOF(ta, identity$1); };
        };
    };
    var _traverseWithIndex$1 = function (O) { return function (F) {
        var keysO = keys_$1(O);
        return function (ta, f) {
            var ks = keysO(ta);
            if (ks.length === 0) {
                return F.of(empty$3);
            }
            var fr = F.of({});
            var _loop_1 = function (key) {
                fr = F.ap(F.map(fr, function (r) { return function (b) {
                    r[key] = b;
                    return r;
                }; }), f(key, ta[key]));
            };
            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
                var key = ks_1[_i];
                _loop_1(key);
            }
            return fr;
        };
    }; };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * Given a `Predicate`, it produces a new `ReadonlyRecord` keeping only the entries with a
     * value that satisfies the provided predicate.
     *
     * @example
     * import { filter } from "fp-ts/ReadonlyRecord"
     *
     * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: "foo", b: "bar", c: "verylong" }), {
     *   a: "foo",
     *   b: "bar",
     * });
     *
     * @category Filterable
     * @since 2.5.0
     */
    var filter$4 = function (predicate) {
        return filterWithIndex$1(function (_, a) { return predicate(a); });
    };
    /**
     * Maps a `ReadonlyRecord` with an iterating function that returns an `Option`
     * and it keeps only the `Some` values discarding the `None`s.
     *
     * @example
     * import { filterMap } from "fp-ts/ReadonlyRecord"
     * import { option } from "fp-ts"
     *
     * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none
     * assert.deepStrictEqual(filterMap(f)({ a: "foo", b: "bar", c: "verylong" }), {
     *   a: "foo is short",
     *   b: "bar is short",
     * });
     *
     * @category Filterable
     * @since 2.5.0
     */
    var filterMap$4 = function (f) { return filterMapWithIndex$1(function (_, a) { return f(a); }); };
    /**
     * Partition a `ReadonlyRecord` into two parts according to a `Predicate`.
     *
     * @example
     * import { partition } from "fp-ts/ReadonlyRecord"
     *
     * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: "foo", b: "bar", c: "verylong" }), {
     *   left:{
     *     c: "verylong"
     *   },
     *   right: {
     *     a: "foo",
     *     b: "bar",
     *   },
     * });
     *
     * @category Filterable
     * @since 2.5.0
     */
    var partition$4 = function (predicate) {
        return partitionWithIndex$1(function (_, a) { return predicate(a); });
    };
    /**
     * Maps a `ReadonlyRecord` with a function returning an `Either` and
     * partitions the resulting `ReadonlyRecord` into `Left`s and `Right`s.
     *
     * @example
     * import { partitionMap } from "fp-ts/ReadonlyRecord"
     * import { either } from "fp-ts"
     *
     * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));
     * assert.deepStrictEqual(partitionMap(f)({ a: "foo", b: "bar", c: "verylong" }), {
     *   left: {
     *     c: "verylong is not short",
     *   },
     *   right: {
     *     a: "foo is short",
     *     b: "bar is short",
     *   },
     * });
     *
     * @category Filterable
     * @since 2.5.0
     */
    var partitionMap$4 = function (f) {
        return partitionMapWithIndex$1(function (_, a) { return f(a); });
    };
    function reduce$7() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var reduceWithIndexO_1 = reduceWithIndex$1(args[0]);
            return function (b, f) { return reduceWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };
        }
        return reduce$7(Ord$1).apply(void 0, args);
    }
    function foldMap$7(O) {
        if ('compare' in O) {
            var foldMapWithIndexO_1 = foldMapWithIndex$1(O);
            return function (M) {
                var foldMapWithIndexM = foldMapWithIndexO_1(M);
                return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };
            };
        }
        return foldMap$7(Ord$1)(O);
    }
    function reduceRight$7() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var reduceRightWithIndexO_1 = reduceRightWithIndex$1(args[0]);
            return function (b, f) { return reduceRightWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };
        }
        return reduceRight$7(Ord$1).apply(void 0, args);
    }
    /**
     * Compact a `ReadonlyRecord` of `Option`s discarding the `None` values and
     * keeping the `Some` values.
     *
     * @example
     * import { compact } from 'fp-ts/ReadonlyRecord'
     * import { option } from 'fp-ts'
     *
     * assert.deepStrictEqual(compact({ a: option.some("foo"), b: option.none, c: option.some("bar") }), {
     *   a: "foo",
     *   c: "bar",
     * });
     *
     * @category Compactable
     * @since 2.5.0
     */
    var compact$4 = function (r) {
        var out = {};
        for (var k in r) {
            if (has$4.call(r, k)) {
                var oa = r[k];
                if (isSome$2(oa)) {
                    out[k] = oa.value;
                }
            }
        }
        return out;
    };
    /**
     * Separate a `ReadonlyRecord` of `Either`s into `Left`s and `Right`s.
     *
     * @example
     * import { separate } from 'fp-ts/ReadonlyRecord'
     * import { either } from 'fp-ts'
     *
     * assert.deepStrictEqual(
     *   separate({ a: either.right("foo"), b: either.left("bar"), c: either.right("baz") }),
     *   {
     *     right: {
     *       a: "foo",
     *       c: "baz",
     *     },
     *     left: {
     *       b: "bar",
     *     },
     *   }
     * );
     *
     * @category Compactable
     * @since 2.5.0
     */
    var separate$4 = function (r) {
        var left = {};
        var right = {};
        for (var k in r) {
            if (has$4.call(r, k)) {
                var e = r[k];
                if (isLeft$3(e)) {
                    left[k] = e.left;
                }
                else {
                    right[k] = e.right;
                }
            }
        }
        return separated(left, right);
    };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.5.0
     */
    var URI$c = 'ReadonlyRecord';
    function getShow$5(O) {
        if ('compare' in O) {
            return function (S) { return ({
                show: function (r) {
                    var elements = collect$1(O)(function (k, a) { return JSON.stringify(k) + ": " + S.show(a); })(r).join(', ');
                    return elements === '' ? '{}' : "{ " + elements + " }";
                }
            }); };
        }
        return getShow$5(Ord$1)(O);
    }
    function getEq$5(E) {
        var isSubrecordE = isSubrecord$1(E);
        return fromEquals(function (x, y) { return isSubrecordE(x)(y) && isSubrecordE(y)(x); });
    }
    function getMonoid$1(S) {
        return {
            concat: function (first, second) {
                if (isEmpty$3(first)) {
                    return second;
                }
                if (isEmpty$3(second)) {
                    return first;
                }
                var r = Object.assign({}, first);
                for (var k in second) {
                    if (has$4.call(second, k)) {
                        r[k] = has$4.call(first, k) ? S.concat(first[k], second[k]) : second[k];
                    }
                }
                return r;
            },
            empty: empty$3
        };
    }
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$c = {
        URI: URI$c,
        map: _map$b
    };
    /**
     * Derivable from `Functor`.
     * Takes a value and a `ReadonlyRecord` of functions and returns a
     * `ReadonlyRecord` by applying each function to the input value.
     *
     * @example
     * import { flap } from "fp-ts/ReadonlyRecord"
     *
     * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };
     * assert.deepStrictEqual(flap(3)(fab), {
     *   x: "3 times 2",
     *   y: "6",
     * });
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$c = 
    /*#__PURE__*/
    flap$x(Functor$c);
    /**
     * @category instances
     * @since 2.7.0
     */
    var FunctorWithIndex$1 = {
        URI: URI$c,
        map: _map$b,
        mapWithIndex: _mapWithIndex$1
    };
    /**
     * Produces a `Foldable` instance for a `ReadonlyRecord`, using the
     * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.
     *
     * @category instances
     * @since 2.11.0
     */
    var getFoldable$1 = function (O) { return ({
        URI: URI$c,
        reduce: _reduce$5(O),
        foldMap: _foldMap$5(O),
        reduceRight: _reduceRight$5(O)
    }); };
    /**
     * Produces a `FoldableWithIndex1` instance for a `ReadonlyRecord`, using the
     * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.
     *
     * @category instances
     * @since 2.11.0
     */
    var getFoldableWithIndex$1 = function (O) { return ({
        URI: URI$c,
        reduce: _reduce$5(O),
        foldMap: _foldMap$5(O),
        reduceRight: _reduceRight$5(O),
        reduceWithIndex: _reduceWithIndex$1(O),
        foldMapWithIndex: _foldMapWithIndex$1(O),
        reduceRightWithIndex: _reduceRightWithIndex$1(O)
    }); };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Compactable$2 = {
        URI: URI$c,
        compact: compact$4,
        separate: separate$4
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Filterable$2 = {
        URI: URI$c,
        map: _map$b,
        compact: compact$4,
        separate: separate$4,
        filter: _filter$2,
        filterMap: _filterMap$2,
        partition: _partition$2,
        partitionMap: _partitionMap$2
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var FilterableWithIndex$1 = {
        URI: URI$c,
        map: _map$b,
        mapWithIndex: _mapWithIndex$1,
        compact: compact$4,
        separate: separate$4,
        filter: _filter$2,
        filterMap: _filterMap$2,
        partition: _partition$2,
        partitionMap: _partitionMap$2,
        filterMapWithIndex: _filterMapWithIndex$1,
        filterWithIndex: _filterWithIndex$1,
        partitionMapWithIndex: _partitionMapWithIndex$1,
        partitionWithIndex: _partitionWithIndex$1
    };
    /**
     * Produces a `Traversable` instance for a `ReadonlyRecord`, using the
     * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.
     *
     * @category instances
     * @since 2.11.0
     */
    var getTraversable$1 = function (O) { return ({
        URI: URI$c,
        map: _map$b,
        reduce: _reduce$5(O),
        foldMap: _foldMap$5(O),
        reduceRight: _reduceRight$5(O),
        traverse: _traverse$5(O),
        sequence: _sequence$1(O)
    }); };
    /**
     * Produces a `TraversableWithIndex` instance for a `ReadonlyRecord`, using the
     * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.
     *
     * @category instances
     * @since 2.11.0
     */
    var getTraversableWithIndex$1 = function (O) { return ({
        URI: URI$c,
        map: _map$b,
        mapWithIndex: _mapWithIndex$1,
        reduce: _reduce$5(O),
        foldMap: _foldMap$5(O),
        reduceRight: _reduceRight$5(O),
        reduceWithIndex: _reduceWithIndex$1(O),
        foldMapWithIndex: _foldMapWithIndex$1(O),
        reduceRightWithIndex: _reduceRightWithIndex$1(O),
        traverse: _traverse$5(O),
        sequence: _sequence$1(O),
        traverseWithIndex: _traverseWithIndex$1(O)
    }); };
    /**
     * @category instances
     * @since 2.11.0
     */
    var getWitherable$1 = function (O) {
        var T = getTraversable$1(O);
        return {
            URI: URI$c,
            map: _map$b,
            reduce: _reduce$5(O),
            foldMap: _foldMap$5(O),
            reduceRight: _reduceRight$5(O),
            traverse: T.traverse,
            sequence: T.sequence,
            compact: compact$4,
            separate: separate$4,
            filter: _filter$2,
            filterMap: _filterMap$2,
            partition: _partition$2,
            partitionMap: _partitionMap$2,
            wither: witherDefault$1(T, Compactable$2),
            wilt: wiltDefault$1(T, Compactable$2)
        };
    };
    /**
     * Given a `Semigroup` in the base type, it produces a `Semigroup`
     * in the `ReadonlyRecord` of the base type.
     * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by
     * `union`.
     *
     * @example
     * import { getUnionSemigroup, ReadonlyRecord } from "fp-ts/ReadonlyRecord"
     * import { Semigroup } from "fp-ts/Semigroup"
     *
     * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };
     * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getUnionSemigroup(sNumber);
     * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });
     *
     * @category instances
     * @since 2.11.0
     */
    var getUnionSemigroup$3 = function (S) {
        var unionS = union$3(S);
        return {
            concat: function (first, second) { return unionS(second)(first); }
        };
    };
    /**
     * Same as `getMonoid`.
     * Returns a `Monoid` instance for `ReadonlyRecord`s given a `Semigroup`
     * instance for the base type.
     * The `Monoid` makes the union of two `ReadonlyRecord`s combining the
     * entries that have the same key with the provided `Semigroup`.
     *
     * @example
     * import { SemigroupSum } from 'fp-ts/number'
     * import { getUnionMonoid } from 'fp-ts/ReadonlyRecord'
     *
     * const M = getUnionMonoid(SemigroupSum);
     * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });
     *
     * @category instances
     * @since 2.11.0
     */
    var getUnionMonoid$3 = function (S) { return ({
        concat: getUnionSemigroup$3(S).concat,
        empty: empty$3
    }); };
    /**
     * Given a `Semigroup` in the base type, it produces a `Semigroup`
     * in the `ReadonlyRecord` of the base type.
     * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by
     * `intersection`.
     *
     * @example
     * import { getIntersectionSemigroup, ReadonlyRecord } from "fp-ts/ReadonlyRecord"
     * import { Semigroup } from "fp-ts/Semigroup"
     *
     * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };
     * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getIntersectionSemigroup(sNumber);
     * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });
     *
     * @category instances
     * @since 2.11.0
     */
    var getIntersectionSemigroup$3 = function (S) {
        var intersectionS = intersection$3(S);
        return {
            concat: function (first, second) { return intersectionS(second)(first); }
        };
    };
    /**
     * Produces a `Magma` with a `concat` function that combines
     * two `ReadonlyRecord`s by making the `difference`.
     *
     * @example
     * import { getDifferenceMagma, difference, ReadonlyRecord } from "fp-ts/ReadonlyRecord"
     * import { Magma } from "fp-ts/Magma"
     *
     * const r1 = { a: 3, c: 3 };
     * const r2 = { a: 1, b: 2 };
     * const m: Magma<ReadonlyRecord<string, number>> = getDifferenceMagma<number>();
     * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));
     * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });
     *
     * @category instances
     * @since 2.11.0
     */
    var getDifferenceMagma$3 = function () { return ({
        concat: function (first, second) { return difference$3(second)(first); }
    }); };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use `getFoldable` instead.
     *
     * @category instances
     * @since 2.7.0
     * @deprecated
     */
    var Foldable$5 = {
        URI: URI$c,
        reduce: 
        /*#__PURE__*/
        _reduce$5(Ord$1),
        foldMap: 
        /*#__PURE__*/
        _foldMap$5(Ord$1),
        reduceRight: 
        /*#__PURE__*/
        _reduceRight$5(Ord$1)
    };
    /**
     * Use `getFoldableWithIndex` instead.
     *
     * @category instances
     * @since 2.7.0
     * @deprecated
     */
    var FoldableWithIndex$1 = {
        URI: URI$c,
        reduce: 
        /*#__PURE__*/
        _reduce$5(Ord$1),
        foldMap: 
        /*#__PURE__*/
        _foldMap$5(Ord$1),
        reduceRight: 
        /*#__PURE__*/
        _reduceRight$5(Ord$1),
        reduceWithIndex: 
        /*#__PURE__*/
        _reduceWithIndex$1(Ord$1),
        foldMapWithIndex: 
        /*#__PURE__*/
        _foldMapWithIndex$1(Ord$1),
        reduceRightWithIndex: 
        /*#__PURE__*/
        _reduceRightWithIndex$1(Ord$1)
    };
    /**
     * Use `getTraversable` instead.
     *
     * @category instances
     * @since 2.7.0
     * @deprecated
     */
    var Traversable$6 = {
        URI: URI$c,
        map: _map$b,
        reduce: 
        /*#__PURE__*/
        _reduce$5(Ord$1),
        foldMap: 
        /*#__PURE__*/
        _foldMap$5(Ord$1),
        reduceRight: 
        /*#__PURE__*/
        _reduceRight$5(Ord$1),
        traverse: 
        /*#__PURE__*/
        _traverse$5(Ord$1),
        sequence: sequence$6
    };
    /**
     * Use `getTraversableWithIndex` instead.
     *
     * @category instances
     * @since 2.7.0
     * @deprecated
     */
    var TraversableWithIndex$2 = {
        URI: URI$c,
        map: _map$b,
        mapWithIndex: _mapWithIndex$1,
        reduce: 
        /*#__PURE__*/
        _reduce$5(Ord$1),
        foldMap: 
        /*#__PURE__*/
        _foldMap$5(Ord$1),
        reduceRight: 
        /*#__PURE__*/
        _reduceRight$5(Ord$1),
        reduceWithIndex: 
        /*#__PURE__*/
        _reduceWithIndex$1(Ord$1),
        foldMapWithIndex: 
        /*#__PURE__*/
        _foldMapWithIndex$1(Ord$1),
        reduceRightWithIndex: 
        /*#__PURE__*/
        _reduceRightWithIndex$1(Ord$1),
        traverse: 
        /*#__PURE__*/
        _traverse$5(Ord$1),
        sequence: sequence$6,
        traverseWithIndex: 
        /*#__PURE__*/
        _traverseWithIndex$1(Ord$1)
    };
    var _wither$1 = 
    /*#__PURE__*/
    witherDefault$1(Traversable$6, Compactable$2);
    var _wilt$1 = 
    /*#__PURE__*/
    wiltDefault$1(Traversable$6, Compactable$2);
    /**
     * Use `getWitherable` instead.
     *
     * @category instances
     * @since 2.7.0
     * @deprecated
     */
    var Witherable$2 = {
        URI: URI$c,
        map: _map$b,
        reduce: 
        /*#__PURE__*/
        _reduce$5(Ord$1),
        foldMap: 
        /*#__PURE__*/
        _foldMap$5(Ord$1),
        reduceRight: 
        /*#__PURE__*/
        _reduceRight$5(Ord$1),
        traverse: 
        /*#__PURE__*/
        _traverse$5(Ord$1),
        sequence: sequence$6,
        compact: compact$4,
        separate: separate$4,
        filter: _filter$2,
        filterMap: _filterMap$2,
        partition: _partition$2,
        partitionMap: _partitionMap$2,
        wither: _wither$1,
        wilt: _wilt$1
    };
    /**
     * Use [`upsertAt`](#upsertat) instead.
     *
     * @category combinators
     * @since 2.5.0
     * @deprecated
     */
    var insertAt$1 = upsertAt$1;
    function hasOwnProperty$1(k, r) {
        return has$4.call(r === undefined ? this : r, k);
    }
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.5.0
     * @deprecated
     */
    var readonlyRecord = {
        URI: URI$c,
        map: _map$b,
        reduce: 
        /*#__PURE__*/
        _reduce$5(Ord$1),
        foldMap: 
        /*#__PURE__*/
        _foldMap$5(Ord$1),
        reduceRight: 
        /*#__PURE__*/
        _reduceRight$5(Ord$1),
        traverse: 
        /*#__PURE__*/
        _traverse$5(Ord$1),
        sequence: sequence$6,
        compact: compact$4,
        separate: separate$4,
        filter: _filter$2,
        filterMap: _filterMap$2,
        partition: _partition$2,
        partitionMap: _partitionMap$2,
        mapWithIndex: _mapWithIndex$1,
        reduceWithIndex: 
        /*#__PURE__*/
        _reduceWithIndex$1(Ord$1),
        foldMapWithIndex: 
        /*#__PURE__*/
        _foldMapWithIndex$1(Ord$1),
        reduceRightWithIndex: 
        /*#__PURE__*/
        _reduceRightWithIndex$1(Ord$1),
        filterMapWithIndex: _filterMapWithIndex$1,
        filterWithIndex: _filterWithIndex$1,
        partitionMapWithIndex: _partitionMapWithIndex$1,
        partitionWithIndex: _partitionWithIndex$1,
        traverseWithIndex: 
        /*#__PURE__*/
        _traverseWithIndex$1(Ord$1),
        wither: _wither$1,
        wilt: _wilt$1
    };

    var ReadonlyRecord = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fromRecord: fromRecord,
        toRecord: toRecord,
        size: size$3,
        isEmpty: isEmpty$3,
        keys: keys$2,
        collect: collect$1,
        toReadonlyArray: toReadonlyArray$1,
        toUnfoldable: toUnfoldable$1,
        upsertAt: upsertAt$1,
        has: has$3,
        deleteAt: deleteAt$1,
        updateAt: updateAt$1,
        modifyAt: modifyAt$1,
        pop: pop$1,
        isSubrecord: isSubrecord$1,
        lookup: lookup$1,
        empty: empty$3,
        mapWithIndex: mapWithIndex$1,
        map: map$g,
        reduceWithIndex: reduceWithIndex$1,
        foldMapWithIndex: foldMapWithIndex$1,
        reduceRightWithIndex: reduceRightWithIndex$1,
        singleton: singleton$4,
        traverseWithIndex: traverseWithIndex$1,
        traverse: traverse$6,
        sequence: sequence$6,
        wither: wither$1,
        wilt: wilt$1,
        partitionMapWithIndex: partitionMapWithIndex$1,
        partitionWithIndex: partitionWithIndex$1,
        filterMapWithIndex: filterMapWithIndex$1,
        filterWithIndex: filterWithIndex$1,
        fromFoldable: fromFoldable$1,
        fromFoldableMap: fromFoldableMap$1,
        every: every$3,
        some: some$5,
        elem: elem$5,
        union: union$3,
        intersection: intersection$3,
        difference: difference$3,
        _map: _map$b,
        _mapWithIndex: _mapWithIndex$1,
        _reduce: _reduce$5,
        _foldMap: _foldMap$5,
        _reduceRight: _reduceRight$5,
        _filter: _filter$2,
        _filterMap: _filterMap$2,
        _partition: _partition$2,
        _partitionMap: _partitionMap$2,
        _reduceWithIndex: _reduceWithIndex$1,
        _foldMapWithIndex: _foldMapWithIndex$1,
        _reduceRightWithIndex: _reduceRightWithIndex$1,
        _partitionMapWithIndex: _partitionMapWithIndex$1,
        _partitionWithIndex: _partitionWithIndex$1,
        _filterMapWithIndex: _filterMapWithIndex$1,
        _filterWithIndex: _filterWithIndex$1,
        _traverse: _traverse$5,
        _sequence: _sequence$1,
        filter: filter$4,
        filterMap: filterMap$4,
        partition: partition$4,
        partitionMap: partitionMap$4,
        reduce: reduce$7,
        foldMap: foldMap$7,
        reduceRight: reduceRight$7,
        compact: compact$4,
        separate: separate$4,
        URI: URI$c,
        getShow: getShow$5,
        getEq: getEq$5,
        getMonoid: getMonoid$1,
        Functor: Functor$c,
        flap: flap$c,
        FunctorWithIndex: FunctorWithIndex$1,
        getFoldable: getFoldable$1,
        getFoldableWithIndex: getFoldableWithIndex$1,
        Compactable: Compactable$2,
        Filterable: Filterable$2,
        FilterableWithIndex: FilterableWithIndex$1,
        getTraversable: getTraversable$1,
        getTraversableWithIndex: getTraversableWithIndex$1,
        getWitherable: getWitherable$1,
        getUnionSemigroup: getUnionSemigroup$3,
        getUnionMonoid: getUnionMonoid$3,
        getIntersectionSemigroup: getIntersectionSemigroup$3,
        getDifferenceMagma: getDifferenceMagma$3,
        Foldable: Foldable$5,
        FoldableWithIndex: FoldableWithIndex$1,
        Traversable: Traversable$6,
        TraversableWithIndex: TraversableWithIndex$2,
        Witherable: Witherable$2,
        insertAt: insertAt$1,
        hasOwnProperty: hasOwnProperty$1,
        readonlyRecord: readonlyRecord
    });

    // -------------------------------------------------------------------------------------
    // interop
    // -------------------------------------------------------------------------------------
    /**
     * @category interop
     * @since 2.5.0
     */
    var fromSet = function (s) { return new Set(s); };
    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * Create a set with one element
     *
     * @category constructors
     * @since 2.5.0
     */
    var singleton$3 = function (a) { return new Set([a]); };
    /**
     * Create a `ReadonlySet` from a `ReadonlyArray`
     *
     * @category constructors
     * @since 2.10.0
     */
    var fromReadonlyArray = function (E) { return function (as) {
        var len = as.length;
        var out = new Set();
        var has = elem$4(E);
        for (var i = 0; i < len; i++) {
            var a = as[i];
            if (!has(a, out)) {
                out.add(a);
            }
        }
        return out;
    }; };
    // -------------------------------------------------------------------------------------
    // destructors
    // -------------------------------------------------------------------------------------
    /**
     * @category destructors
     * @since 2.5.0
     */
    function toSet(s) {
        return new Set(s);
    }
    /**
     * Projects a Set through a function
     *
     * @category combinators
     * @since 2.5.0
     */
    function map$f(E) {
        var elemE = elem$4(E);
        return function (f) { return function (set) {
            var r = new Set();
            set.forEach(function (e) {
                var v = f(e);
                if (!elemE(v, r)) {
                    r.add(v);
                }
            });
            return r;
        }; };
    }
    /**
     * @category combinators
     * @since 2.5.0
     */
    function chain$6(E) {
        var elemE = elem$4(E);
        return function (f) { return function (set) {
            var r = new Set();
            set.forEach(function (e) {
                f(e).forEach(function (e) {
                    if (!elemE(e, r)) {
                        r.add(e);
                    }
                });
            });
            return r;
        }; };
    }
    function filter$3(predicate) {
        return function (set) {
            var values = set.values();
            var e;
            var r = new Set();
            // tslint:disable-next-line: strict-boolean-expressions
            while (!(e = values.next()).done) {
                var a = e.value;
                if (predicate(a)) {
                    r.add(a);
                }
            }
            return r;
        };
    }
    function partition$3(predicate) {
        return function (set) {
            var values = set.values();
            var e;
            var right = new Set();
            var left = new Set();
            // tslint:disable-next-line: strict-boolean-expressions
            while (!(e = values.next()).done) {
                var a = e.value;
                if (predicate(a)) {
                    right.add(a);
                }
                else {
                    left.add(a);
                }
            }
            return separated(left, right);
        };
    }
    function union$2(E) {
        var elemE = elem$4(E);
        return function (me, that) {
            if (that === undefined) {
                var unionE_1 = union$2(E);
                return function (that) { return unionE_1(me, that); };
            }
            if (isEmpty$2(me)) {
                return that;
            }
            if (isEmpty$2(that)) {
                return me;
            }
            var r = new Set(me);
            that.forEach(function (e) {
                if (!elemE(e, r)) {
                    r.add(e);
                }
            });
            return r;
        };
    }
    function intersection$2(E) {
        var elemE = elem$4(E);
        return function (me, that) {
            if (that === undefined) {
                var intersectionE_1 = intersection$2(E);
                return function (that) { return intersectionE_1(that, me); };
            }
            if (isEmpty$2(me) || isEmpty$2(that)) {
                return empty$2;
            }
            var r = new Set();
            me.forEach(function (e) {
                if (elemE(e, that)) {
                    r.add(e);
                }
            });
            return r;
        };
    }
    /**
     * @since 2.5.0
     */
    function partitionMap$3(EB, EC) {
        return function (f) { return function (set) {
            var values = set.values();
            var e;
            var left = new Set();
            var right = new Set();
            var hasB = elem$4(EB);
            var hasC = elem$4(EC);
            // tslint:disable-next-line: strict-boolean-expressions
            while (!(e = values.next()).done) {
                var v = f(e.value);
                switch (v._tag) {
                    case 'Left':
                        if (!hasB(v.left, left)) {
                            left.add(v.left);
                        }
                        break;
                    case 'Right':
                        if (!hasC(v.right, right)) {
                            right.add(v.right);
                        }
                        break;
                }
            }
            return separated(left, right);
        }; };
    }
    function difference$2(E) {
        var elemE = elem$4(E);
        return function (me, that) {
            if (that === undefined) {
                var differenceE_1 = difference$2(E);
                return function (that) { return differenceE_1(that, me); };
            }
            return filter$3(function (a) { return !elemE(a, that); })(me);
        };
    }
    /**
     * @since 2.5.0
     */
    function reduce$6(O) {
        var toReadonlyArrayO = toReadonlyArray(O);
        return function (b, f) { return function (fa) { return toReadonlyArrayO(fa).reduce(f, b); }; };
    }
    /**
     * @since 2.5.0
     */
    function foldMap$6(O, M) {
        var toReadonlyArrayO = toReadonlyArray(O);
        return function (f) { return function (fa) { return toReadonlyArrayO(fa).reduce(function (b, a) { return M.concat(b, f(a)); }, M.empty); }; };
    }
    /**
     * @since 2.11.0
     */
    var reduceRight$6 = function (O) {
        var toReadonlyArrayO = toReadonlyArray(O);
        return function (b, f) { return function (fa) { return toReadonlyArrayO(fa).reduceRight(function (b, a) { return f(a, b); }, b); }; };
    };
    /**
     * Insert a value into a set
     *
     * @category combinators
     * @since 2.5.0
     */
    function insert$1(E) {
        var elemE = elem$4(E);
        return function (a) { return function (set) {
            if (!elemE(a)(set)) {
                var r = new Set(set);
                r.add(a);
                return r;
            }
            else {
                return set;
            }
        }; };
    }
    /**
     * Delete a value from a set
     *
     * @category combinators
     * @since 2.5.0
     */
    var remove$1 = function (E) { return function (a) { return function (set) {
        return filter$3(function (ax) { return !E.equals(a, ax); })(set);
    }; }; };
    /**
     * Checks an element is a member of a set;
     * If yes, removes the value from the set
     * If no, inserts the value to the set
     *
     * @category combinators
     * @since 2.10.0
     */
    var toggle$1 = function (E) {
        var elemE = elem$4(E);
        var removeE = remove$1(E);
        var insertE = insert$1(E);
        return function (a) { return function (set) { return (elemE(a, set) ? removeE : insertE)(a)(set); }; };
    };
    /**
     * @category combinators
     * @since 2.5.0
     */
    var compact$3 = function (E) { return filterMap$3(E)(identity$1); };
    /**
     * @since 2.5.0
     */
    function separate$3(EE, EA) {
        return function (fa) {
            var elemEE = elem$4(EE);
            var elemEA = elem$4(EA);
            var left = new Set();
            var right = new Set();
            fa.forEach(function (e) {
                switch (e._tag) {
                    case 'Left':
                        if (!elemEE(e.left, left)) {
                            left.add(e.left);
                        }
                        break;
                    case 'Right':
                        if (!elemEA(e.right, right)) {
                            right.add(e.right);
                        }
                        break;
                }
            });
            return separated(left, right);
        };
    }
    /**
     * @category combinators
     * @since 2.5.0
     */
    function filterMap$3(E) {
        var elemE = elem$4(E);
        return function (f) { return function (fa) {
            var r = new Set();
            fa.forEach(function (a) {
                var ob = f(a);
                if (ob._tag === 'Some' && !elemE(ob.value, r)) {
                    r.add(ob.value);
                }
            });
            return r;
        }; };
    }
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.5.0
     */
    var empty$2 = new Set();
    /**
     * Test whether a `ReadonlySet` is empty.
     *
     * @since 2.10.0
     */
    var isEmpty$2 = function (set) { return set.size === 0; };
    /**
     * Calculate the number of elements in a `ReadonlySet`.
     *
     * @since 2.10.0
     */
    var size$2 = function (set) { return set.size; };
    /**
     * @since 2.5.0
     */
    var some$4 = function (predicate) { return function (set) {
        var values = set.values();
        var e;
        var found = false;
        // tslint:disable-next-line: strict-boolean-expressions
        while (!found && !(e = values.next()).done) {
            found = predicate(e.value);
        }
        return found;
    }; };
    /**
     * @since 2.5.0
     */
    var every$2 = function (predicate) { return not$1(some$4(not$1(predicate))); };
    function isSubset$1(E) {
        var elemE = elem$4(E);
        return function (me, that) {
            if (that === undefined) {
                var isSubsetE_1 = isSubset$1(E);
                return function (that) { return isSubsetE_1(that, me); };
            }
            return every$2(function (a) { return elemE(a, that); })(me);
        };
    }
    function elem$4(E) {
        return function (a, set) {
            if (set === undefined) {
                var elemE_1 = elem$4(E);
                return function (set) { return elemE_1(a, set); };
            }
            var values = set.values();
            var e;
            var found = false;
            // tslint:disable-next-line: strict-boolean-expressions
            while (!found && !(e = values.next()).done) {
                found = E.equals(a, e.value);
            }
            return found;
        };
    }
    /**
     * Get a sorted `ReadonlyArray` of the values contained in a `ReadonlySet`.
     *
     * @since 2.5.0
     */
    var toReadonlyArray = function (O) { return function (set) {
        var out = [];
        set.forEach(function (e) { return out.push(e); });
        return out.sort(O.compare);
    }; };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.11.0
     */
    var URI$b = 'ReadonlySet';
    /**
     * @category instances
     * @since 2.5.0
     */
    function getShow$4(S) {
        return {
            show: function (s) {
                var entries = [];
                s.forEach(function (a) {
                    entries.push(S.show(a));
                });
                return "new Set([" + entries.sort().join(', ') + "])";
            }
        };
    }
    /**
     * @category instances
     * @since 2.5.0
     */
    function getEq$4(E) {
        var subsetE = isSubset$1(E);
        return fromEquals(function (x, y) { return subsetE(x, y) && subsetE(y, x); });
    }
    /**
     * @category instances
     * @since 2.11.0
     */
    var getUnionSemigroup$2 = function (E) { return ({
        concat: union$2(E)
    }); };
    /**
     * @category instances
     * @since 2.5.0
     */
    var getUnionMonoid$2 = function (E) { return ({
        concat: getUnionSemigroup$2(E).concat,
        empty: empty$2
    }); };
    /**
     * @category instances
     * @since 2.5.0
     */
    var getIntersectionSemigroup$2 = function (E) { return ({
        concat: intersection$2(E)
    }); };
    /**
     * @category instances
     * @since 2.11.0
     */
    var getDifferenceMagma$2 = function (E) { return ({
        concat: difference$2(E)
    }); };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use [`fromReadonlyArray`](#fromreadonlyarray) instead.
     *
     * @category constructors
     * @since 2.5.0
     * @deprecated
     */
    var fromArray$1 = fromReadonlyArray;

    var ReadonlySet = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fromSet: fromSet,
        singleton: singleton$3,
        fromReadonlyArray: fromReadonlyArray,
        toSet: toSet,
        map: map$f,
        chain: chain$6,
        filter: filter$3,
        partition: partition$3,
        union: union$2,
        intersection: intersection$2,
        partitionMap: partitionMap$3,
        difference: difference$2,
        reduce: reduce$6,
        foldMap: foldMap$6,
        reduceRight: reduceRight$6,
        insert: insert$1,
        remove: remove$1,
        toggle: toggle$1,
        compact: compact$3,
        separate: separate$3,
        filterMap: filterMap$3,
        empty: empty$2,
        isEmpty: isEmpty$2,
        size: size$2,
        some: some$4,
        every: every$2,
        isSubset: isSubset$1,
        elem: elem$4,
        toReadonlyArray: toReadonlyArray,
        URI: URI$b,
        getShow: getShow$4,
        getEq: getEq$4,
        getUnionSemigroup: getUnionSemigroup$2,
        getUnionMonoid: getUnionMonoid$2,
        getIntersectionSemigroup: getIntersectionSemigroup$2,
        getDifferenceMagma: getDifferenceMagma$2,
        fromArray: fromArray$1
    });

    // -------------------------------------------------------------------------------------
    // model
    // -------------------------------------------------------------------------------------
    /**
     * @category destructors
     * @since 2.5.0
     */
    function fst$1(ea) {
        return ea[0];
    }
    /**
     * @category destructors
     * @since 2.5.0
     */
    function snd$1(ea) {
        return ea[1];
    }
    /**
     * @category combinators
     * @since 2.5.0
     */
    var swap$4 = function (ea) { return [snd$1(ea), fst$1(ea)]; };
    /**
     * @category instances
     * @since 2.5.0
     */
    function getApply$4(S) {
        return {
            URI: URI$a,
            _E: undefined,
            map: _map$a,
            ap: function (fab, fa) { return [fst$1(fab)(fst$1(fa)), S.concat(snd$1(fab), snd$1(fa))]; }
        };
    }
    var of$7 = function (M) { return function (a) {
        return [a, M.empty];
    }; };
    /**
     * @category instances
     * @since 2.5.0
     */
    function getApplicative$4(M) {
        var A = getApply$4(M);
        return {
            URI: URI$a,
            _E: undefined,
            map: A.map,
            ap: A.ap,
            of: of$7(M)
        };
    }
    /**
     * @category instances
     * @since 2.5.0
     */
    function getChain$4(S) {
        var A = getApply$4(S);
        return {
            URI: URI$a,
            _E: undefined,
            map: A.map,
            ap: A.ap,
            chain: function (ma, f) {
                var _a = f(fst$1(ma)), b = _a[0], s = _a[1];
                return [b, S.concat(snd$1(ma), s)];
            }
        };
    }
    /**
     * @category instances
     * @since 2.5.0
     */
    function getMonad$4(M) {
        var C = getChain$4(M);
        return {
            URI: URI$a,
            _E: undefined,
            map: C.map,
            ap: C.ap,
            chain: C.chain,
            of: of$7(M)
        };
    }
    /**
     * @category instances
     * @since 2.5.0
     */
    function getChainRec$1(M) {
        var chainRec = function (a, f) {
            var result = f(a);
            var acc = M.empty;
            var s = fst$1(result);
            while (s._tag === 'Left') {
                acc = M.concat(acc, snd$1(result));
                result = f(s.left);
                s = fst$1(result);
            }
            return [s.right, M.concat(acc, snd$1(result))];
        };
        var C = getChain$4(M);
        return {
            URI: URI$a,
            _E: undefined,
            map: C.map,
            ap: C.ap,
            chain: C.chain,
            chainRec: chainRec
        };
    }
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    /* istanbul ignore next */
    var _compose$1 = function (bc, ab) { return pipe$1(bc, compose$2(ab)); };
    /* istanbul ignore next */
    var _map$a = function (fa, f) { return pipe$1(fa, mapFst$1(f)); };
    /* istanbul ignore next */
    var _bimap$4 = function (fa, f, g) { return pipe$1(fa, bimap$5(f, g)); };
    /* istanbul ignore next */
    var _mapLeft$4 = function (fa, f) { return pipe$1(fa, mapSnd$1(f)); };
    /* istanbul ignore next */
    var _extend$3 = function (wa, f) { return pipe$1(wa, extend$3(f)); };
    /* istanbul ignore next */
    var _reduce$4 = function (fa, b, f) { return pipe$1(fa, reduce$5(b, f)); };
    /* istanbul ignore next */
    var _foldMap$4 = function (M) {
        var foldMapM = foldMap$5();
        return function (fa, f) { return pipe$1(fa, foldMapM(f)); };
    };
    /* istanbul ignore next */
    var _reduceRight$4 = function (fa, b, f) { return pipe$1(fa, reduceRight$5(b, f)); };
    /* istanbul ignore next */
    var _traverse$4 = function (F) {
        var traverseF = traverse$5(F);
        return function (ta, f) { return pipe$1(ta, traverseF(f)); };
    };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * Map a pair of functions over the two type arguments of the bifunctor.
     *
     * @category Bifunctor
     * @since 2.5.0
     */
    var bimap$5 = function (f, g) { return function (fa) { return [g(fst$1(fa)), f(snd$1(fa))]; }; };
    /**
     * Map a function over the first component of a `ReadonlyTuple`.
     *
     * This is the `map` operation of the `Functor` instance.
     *
     * @category Functor
     * @since 2.10.0
     */
    var mapFst$1 = function (f) { return function (fa) { return [
        f(fst$1(fa)),
        snd$1(fa)
    ]; }; };
    /**
     * Map a function over the second component of a `ReadonlyTuple`.
     *
     * This is the `mapLeft` operation of the `Bifunctor` instance.
     *
     * @category Bifunctor
     * @since 2.10.0
     */
    var mapSnd$1 = function (f) { return function (fa) { return [
        fst$1(fa),
        f(snd$1(fa))
    ]; }; };
    /**
     * @category Semigroupoid
     * @since 2.5.0
     */
    var compose$2 = function (ab) { return function (bc) { return [
        fst$1(bc),
        snd$1(ab)
    ]; }; };
    /**
     * @category Extend
     * @since 2.5.0
     */
    var extend$3 = function (f) { return function (wa) { return [f(wa), snd$1(wa)]; }; };
    /**
     * @category Extract
     * @since 2.6.2
     */
    var extract$3 = fst$1;
    /**
     * Derivable from `Extend`.
     *
     * @category combinators
     * @since 2.5.0
     */
    var duplicate$3 = 
    /*#__PURE__*/
    extend$3(identity$1);
    /**
     * @category Foldable
     * @since 2.5.0
     */
    var reduce$5 = function (b, f) { return function (fa) {
        return f(b, fst$1(fa));
    }; };
    /**
     * @category Foldable
     * @since 2.5.0
     */
    var foldMap$5 = function () {
        return function (f) { return function (fa) { return f(fst$1(fa)); }; };
    };
    /**
     * @category Foldable
     * @since 2.5.0
     */
    var reduceRight$5 = function (b, f) { return function (fa) {
        return f(fst$1(fa), b);
    }; };
    /**
     * @since 2.6.3
     */
    var traverse$5 = function (F) {
        return function (f) { return function (ta) { return F.map(f(fst$1(ta)), function (b) { return [b, snd$1(ta)]; }); }; };
    };
    /**
     * @since 2.6.3
     */
    var sequence$5 = function (F) { return function (fas) {
        return F.map(fst$1(fas), function (a) { return [a, snd$1(fas)]; });
    }; };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.5.0
     */
    var URI$a = 'ReadonlyTuple';
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$b = {
        URI: URI$a,
        map: _map$a
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$b = 
    /*#__PURE__*/
    flap$x(Functor$b);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Bifunctor$4 = {
        URI: URI$a,
        bimap: _bimap$4,
        mapLeft: _mapLeft$4
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Semigroupoid$2 = {
        URI: URI$a,
        compose: _compose$1
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Comonad$3 = {
        URI: URI$a,
        map: _map$a,
        extend: _extend$3,
        extract: extract$3
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Foldable$4 = {
        URI: URI$a,
        reduce: _reduce$4,
        foldMap: _foldMap$4,
        reduceRight: _reduceRight$4
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Traversable$5 = {
        URI: URI$a,
        map: _map$a,
        reduce: _reduce$4,
        foldMap: _foldMap$4,
        reduceRight: _reduceRight$4,
        traverse: _traverse$4,
        sequence: sequence$5
    };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use [`mapFst`](#mapfst) instead.
     *
     * @since 2.5.0
     * @deprecated
     */
    var map$e = mapFst$1;
    /**
     * Use [`mapSnd`](#mapsnd) instead.
     *
     * @since 2.5.0
     * @deprecated
     */
    var mapLeft$5 = mapSnd$1;
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.5.0
     * @deprecated
     */
    var readonlyTuple = {
        URI: URI$a,
        compose: _compose$1,
        map: _map$a,
        bimap: _bimap$4,
        mapLeft: _mapLeft$4,
        extract: extract$3,
        extend: _extend$3,
        reduce: _reduce$4,
        foldMap: _foldMap$4,
        reduceRight: _reduceRight$4,
        traverse: _traverse$4,
        sequence: sequence$5
    };

    var ReadonlyTuple = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fst: fst$1,
        snd: snd$1,
        swap: swap$4,
        getApply: getApply$4,
        getApplicative: getApplicative$4,
        getChain: getChain$4,
        getMonad: getMonad$4,
        getChainRec: getChainRec$1,
        bimap: bimap$5,
        mapFst: mapFst$1,
        mapSnd: mapSnd$1,
        compose: compose$2,
        extend: extend$3,
        extract: extract$3,
        duplicate: duplicate$3,
        reduce: reduce$5,
        foldMap: foldMap$5,
        reduceRight: reduceRight$5,
        traverse: traverse$5,
        sequence: sequence$5,
        URI: URI$a,
        Functor: Functor$b,
        flap: flap$b,
        Bifunctor: Bifunctor$4,
        Semigroupoid: Semigroupoid$2,
        Comonad: Comonad$3,
        Foldable: Foldable$4,
        Traversable: Traversable$5,
        map: map$e,
        mapLeft: mapLeft$5,
        readonlyTuple: readonlyTuple
    });

    var __assign = (undefined && undefined.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    // -------------------------------------------------------------------------------------
    // model
    // -------------------------------------------------------------------------------------
    /**
     * Calculate the number of key/value pairs in a `Record`.
     *
     * @example
     * import { size } from "fp-ts/Record";
     *
     * assert.deepStrictEqual(size({ a: true, b: 2, c: "three" }), 3);
     *
     * @since 2.0.0
     */
    var size$1 = size$3;
    /**
     * Test whether a `Record` is empty.
     *
     * @example
     * import { isEmpty } from "fp-ts/Record";
     *
     * assert.deepStrictEqual(isEmpty({}), true);
     * assert.deepStrictEqual(isEmpty({ a: 3 }), false);
     *
     * @since 2.0.0
     */
    var isEmpty$1 = isEmpty$3;
    var keys_ = function (O) { return function (r) {
        return Object.keys(r).sort(O.compare);
    }; };
    /**
     * The keys of a `Record`, sorted alphabetically.
     *
     * @example
     * import { keys } from "fp-ts/Record";
     *
     * assert.deepStrictEqual(keys({ c: 1, a: 2, b: 3 }), ["a", "b", "c"]);
     *
     * @since 2.0.0
     */
    var keys$1 = 
    /*#__PURE__*/
    keys_(Ord$1);
    function collect(O) {
        if (typeof O === 'function') {
            return collect(Ord$1)(O);
        }
        var keysO = keys_(O);
        return function (f) { return function (r) {
            var out = [];
            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {
                var key = _a[_i];
                out.push(f(key, r[key]));
            }
            return out;
        }; };
    }
    /**
     * Get a sorted `Array` of the key/value pairs contained in a `Record`.
     * Sorted alphabetically by key.
     *
     * @example
     * import { toArray } from 'fp-ts/Record'
     *
     * const x = { c: 3, a: "foo", b: false };
     * assert.deepStrictEqual(toArray(x), [
     *   ["a", "foo"],
     *   ["b", false],
     *   ["c", 3],
     * ]);
     *
     * @since 2.0.0
     */
    var toArray$1 = 
    /*#__PURE__*/
    collect(Ord$1)(function (k, a) { return [k, a]; });
    function toUnfoldable(U) {
        return function (r) {
            var sas = toArray$1(r);
            var len = sas.length;
            return U.unfold(0, function (b) { return (b < len ? some$a([sas[b], b + 1]) : none$2); });
        };
    }
    /**
     * Insert or replace a key/value pair in a `Record`.
     *
     * @example
     * import { upsertAt } from 'fp-ts/Record'
     *
     * assert.deepStrictEqual(upsertAt("a", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });
     * assert.deepStrictEqual(upsertAt("c", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });
     *
     * @category combinators
     * @since 2.10.0
     */
    var upsertAt = upsertAt$1;
    /**
     * Test whether or not a key exists in a `Record`.
     *
     * Note. This function is not pipeable because is a `Refinement`.
     *
     * @example
     * import { has } from 'fp-ts/Record'
     *
     * assert.deepStrictEqual(has("a", { a: 1, b: 2 }), true);
     * assert.deepStrictEqual(has("c", { a: 1, b: 2 }), false);
     *
     * @since 2.10.0
     */
    var has$2 = has$3;
    function deleteAt(k) {
        return function (r) {
            if (!has$4.call(r, k)) {
                return r;
            }
            var out = Object.assign({}, r);
            delete out[k];
            return out;
        };
    }
    /**
     * Replace a key/value pair in a `Record`.
     *
     * @returns If the specified key exists it returns an `Option` containing a new `Record`
     * with the entry updated, otherwise it returns `None`
     *
     * @example
     * import { updateAt } from 'fp-ts/Record'
     * import { option } from 'fp-ts'
     *
     * assert.deepStrictEqual(updateAt("a", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));
     * assert.deepStrictEqual(updateAt("c", 3)({ a: 1, b: 2 }), option.none);
     *
     * @since 2.0.0
     */
    var updateAt = function (k, a) {
        return modifyAt(k, function () { return a; });
    };
    /**
     * Applies a mapping function to one spcific key/value pair in a `Record`.
     *
     * @returns If the specified key exists it returns an `Option` containing a new `Record`
     * with the entry updated, otherwise it returns `None`
     *
     * @example
     * import { modifyAt } from 'fp-ts/Record'
     * import { option } from 'fp-ts'
     *
     * assert.deepStrictEqual(modifyAt("a", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));
     * assert.deepStrictEqual(modifyAt("c", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);
     *
     * @since 2.0.0
     */
    var modifyAt = function (k, f) { return function (r) {
        if (!has$2(k, r)) {
            return none$2;
        }
        var out = Object.assign({}, r);
        out[k] = f(r[k]);
        return some$a(out);
    }; };
    function pop(k) {
        var deleteAtk = deleteAt(k);
        return function (r) {
            var oa = lookup(k, r);
            return isNone$2(oa) ? none$2 : some$a([oa.value, deleteAtk(r)]);
        };
    }
    // TODO: remove non-curried overloading in v3
    /**
     * Test whether one `Record` contains all of the keys and values
     * contained in another `Record`.
     *
     * @example
     * import { isSubrecord } from 'fp-ts/Record'
     * import { string } from 'fp-ts'
     *
     * assert.deepStrictEqual(
     *   isSubrecord(string.Eq)({ a: "foo", b: "bar", c: "baz" })({ a: "foo", b: "bar", c: "baz" }),
     *   true
     * );
     * assert.deepStrictEqual(
     *   isSubrecord(string.Eq)({ a: "foo", b: "bar", c: "baz" })({ a: "foo", c: "baz" }),
     *   true
     * );
     * assert.deepStrictEqual(
     *   isSubrecord(string.Eq)({ a: "foo", b: "bar", c: "baz" })({ a: "foo", b: "not-bar", c: "baz" }),
     *   false
     * );
     * assert.deepStrictEqual(
     *   isSubrecord(string.Eq)({ a: "foo", b: "bar" })({ a: "foo", b: "bar", c: "baz" }),
     *   false
     * );
     *
     * @since 2.0.0
     */
    var isSubrecord = isSubrecord$1;
    // TODO: remove non-curried overloading in v3
    /**
     * Lookup the value for a key in a `Record`.
     *
     * @returns If the specified key exists it returns an `Option` containing the value,
     * otherwise it returns `None`
     *
     * @example
     * import { lookup } from 'fp-ts/Record'
     * import { option } from 'fp-ts'
     *
     * assert.deepStrictEqual(lookup("b")({ a: "foo", b: "bar" }), option.some("bar"));
     * assert.deepStrictEqual(lookup("c")({ a: "foo", b: "bar" }), option.none);
     *
     * @since 2.0.0
     */
    var lookup = lookup$1;
    /**
     * Map a `Record` passing the key/value pairs to the iterating function.
     *
     * @example
     * import { mapWithIndex } from "fp-ts/Record";
     *
     * const f = (k: string, n: number) => `${k.toUpperCase()}-${n}`;
     * assert.deepStrictEqual(mapWithIndex(f)({ a: 3, b: 5 }), { a: "A-3", b: "B-5" });
     *
     * @since 2.0.0
     */
    var mapWithIndex = mapWithIndex$1;
    /**
     * Map a `Record` passing the values to the iterating function.
     *
     * @example
     * import { map } from "fp-ts/Record";
     *
     * const f = (n: number) => `-${n}-`;
     * assert.deepStrictEqual(map(f)({ a: 3, b: 5 }), { a: "-3-", b: "-5-" });
     *
     * @since 2.0.0
     */
    var map$d = map$g;
    function reduceWithIndex() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return args.length === 1 ? reduceWithIndex$1(args[0]) : reduceWithIndex$1(Ord$1).apply(void 0, args);
    }
    function foldMapWithIndex(O) {
        return 'compare' in O ? foldMapWithIndex$1(O) : foldMapWithIndex$1(Ord$1)(O);
    }
    function reduceRightWithIndex() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return args.length === 1 ? reduceRightWithIndex$1(args[0]) : reduceRightWithIndex$1(Ord$1).apply(void 0, args);
    }
    /**
     * Create a `Record` with one key/value pair.
     *
     * @example
     * import { singleton } from "fp-ts/Record";
     *
     * assert.deepStrictEqual(singleton("a", 1), { a: 1 });
     *
     * @since 2.0.0
     */
    var singleton$2 = singleton$4;
    function traverseWithIndex(F) {
        return traverseWithIndex$1(F);
    }
    function traverse$4(F) {
        return traverse$6(F);
    }
    function sequence$4(F) {
        return sequence$6(F);
    }
    /**
     * @category Witherable
     * @since 2.6.5
     */
    var wither = function (F) {
        var traverseF = traverse$4(F);
        return function (f) { return function (fa) { return F.map(pipe$1(fa, traverseF(f)), compact$2); }; };
    };
    /**
     * @category Witherable
     * @since 2.6.5
     */
    var wilt = function (F) {
        var traverseF = traverse$4(F);
        return function (f) { return function (fa) { return F.map(pipe$1(fa, traverseF(f)), separate$2); }; };
    };
    /**
     * Maps a `Record` with a function returning an `Either` and
     * partitions the resulting `Record` into `Left`s and `Right`s.
     *
     * @example
     * import { partitionMapWithIndex } from "fp-ts/Record"
     * import { either } from "fp-ts"
     *
     * const f = (key: string, a: number) =>
     *   a >= 0 ? either.right(`${key} is >= 0 (${a})`) : either.left(`${key} is < 0 (${a})`);
     * assert.deepStrictEqual(partitionMapWithIndex(f)({ a: -1, b: 2, c: 123 }), {
     *   left: {
     *     a: "a is < 0 (-1)",
     *   },
     *   right: {
     *     b: "b is >= 0 (2)",
     *     c: "c is >= 0 (123)",
     *   },
     * });
     *
     * @since 2.0.0
     */
    var partitionMapWithIndex = partitionMapWithIndex$1;
    function partitionWithIndex(predicateWithIndex) {
        return partitionWithIndex$1(predicateWithIndex);
    }
    /**
     * Maps a `Record` with an iterating function that takes key and value and
     * returns an `Option`, keeping only the `Some` values and discarding `None`s.
     *
     * @example
     * import { filterMapWithIndex } from "fp-ts/Record"
     * import { option } from "fp-ts"
     *
     * const f = (key: string, a: number) => (a >= 0 ? option.some(`${key}${a}`) : option.none);
     * assert.deepStrictEqual(filterMapWithIndex(f)({ a: -1, b: 2, c: 3 }), {
     *   b: "b2",
     *   c: "c3",
     * });
     *
     * @since 2.0.0
     */
    var filterMapWithIndex = filterMapWithIndex$1;
    function filterWithIndex(predicateWithIndex) {
        return filterWithIndex$1(predicateWithIndex);
    }
    function fromFoldable(M, F) {
        return fromFoldable$1(M, F);
    }
    function fromFoldableMap(M, F) {
        return fromFoldableMap$1(M, F);
    }
    /**
     * Test if every value in a `Record` satisfies the predicate.
     *
     * @example
     * import { every } from "fp-ts/Record"
     *
     * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: 2 }), true);
     * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: -1 }), false);
     *
     * @since 2.0.0
     */
    var every$1 = every$3;
    /**
     * Test if at least one value in a `Record` satisfies the predicate.
     *
     * @example
     * import { some } from "fp-ts/Record"
     *
     * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);
     * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);
     *
     * @since 2.0.0
     */
    var some$3 = some$5;
    // TODO: remove non-curried overloading in v3
    /**
     * Given an `Eq` checks if a `Record` contains an entry with
     * value equal to a provided value.
     *
     * @example
     * import { elem } from "fp-ts/Record"
     * import { number } from "fp-ts"
     *
     * assert.deepStrictEqual(elem(number.Eq)(123, { foo: 123, bar: 234 }), true);
     * assert.deepStrictEqual(elem(number.Eq)(-7, { foo: 123, bar: 234 }), false);
     *
     * @since 2.0.0
     */
    var elem$3 = elem$5;
    /**
     * Union of two `Record`s.
     * Takes two `Record`s and produces a `Record` combining all the
     * entries of the two inputs.
     * It uses the `concat` function of the provided `Magma` to
     * combine the elements with the same key.
     *
     * @example
     * import { union } from "fp-ts/Record";
     * import { Magma } from "fp-ts/Magma";
     *
     * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };
     * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });
     * const m2: Magma<number> = { concat: (x: number) => x };
     * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });
     *
     * @category combinators
     * @since 2.11.0
     */
    var union$1 = function (M) {
        var unionM = union$3(M);
        return function (second) { return function (first) {
            if (isEmpty$1(first)) {
                return __assign({}, second);
            }
            if (isEmpty$1(second)) {
                return __assign({}, first);
            }
            return unionM(second)(first);
        }; };
    };
    /**
     * Intersection of two `Record`s.
     * Takes two `Record`s and produces a `Record` combining only the
     * entries of the two inputswith the same key.
     * It uses the `concat` function of the provided `Magma` to
     * combine the elements.
     *
     * @example
     * import { intersection } from "fp-ts/Record";
     * import { Magma } from "fp-ts/Magma";
     *
     * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };
     * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});
     * const m2: Magma<number> = { concat: (x: number) => x };
     * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});
     *
     * @category combinators
     * @since 2.11.0
     */
    var intersection$1 = function (M) { return function (second) { return function (first) {
        if (isEmpty$1(first) || isEmpty$1(second)) {
            return {};
        }
        return intersection$3(M)(second)(first);
    }; }; };
    /**
     * Difference between two `Record`s.
     * Takes two `Record`s and produces a `Record` composed by the
     * entries of the two inputs, removing the entries with the same
     * key in both inputs.
     *
     * @example
     * import { difference } from "fp-ts/Record";
     *
     * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });
     * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });
     * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });
     *
     * @category combinators
     * @since 2.11.0
     */
    var difference$1 = function (second) { return function (first) {
        if (isEmpty$1(first)) {
            return __assign({}, second);
        }
        if (isEmpty$1(second)) {
            return __assign({}, first);
        }
        return difference$3(second)(first);
    }; };
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _map$9 = _map$b;
    var _mapWithIndex = _mapWithIndex$1;
    var _reduce$3 = _reduce$5;
    var _foldMap$3 = _foldMap$5;
    var _reduceRight$3 = _reduceRight$5;
    var _filter$1 = _filter$2;
    var _filterMap$1 = _filterMap$2;
    var _partition$1 = _partition$2;
    var _partitionMap$1 = _partitionMap$2;
    var _reduceWithIndex = _reduceWithIndex$1;
    var _foldMapWithIndex = _foldMapWithIndex$1;
    var _reduceRightWithIndex = _reduceRightWithIndex$1;
    var _partitionMapWithIndex = _partitionMapWithIndex$1;
    var _partitionWithIndex = _partitionWithIndex$1;
    var _filterMapWithIndex = _filterMapWithIndex$1;
    var _filterWithIndex = _filterWithIndex$1;
    var _traverse$3 = _traverse$5;
    var _sequence = _sequence$1;
    var _traverseWithIndex = function (O) { return function (F) {
        var keysO = keys_(O);
        return function (ta, f) {
            var ks = keysO(ta);
            if (ks.length === 0) {
                return F.of({});
            }
            var fr = F.of({});
            var _loop_1 = function (key) {
                fr = F.ap(F.map(fr, function (r) { return function (b) {
                    r[key] = b;
                    return r;
                }; }), f(key, ta[key]));
            };
            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
                var key = ks_1[_i];
                _loop_1(key);
            }
            return fr;
        };
    }; };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * Given a `Predicate`, it produces a new `Record` keeping only the entries with a
     * value that satisfies the provided predicate.
     *
     * @example
     * import { filter } from "fp-ts/Record"
     *
     * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: "foo", b: "bar", c: "verylong" }), {
     *   a: "foo",
     *   b: "bar",
     * });
     *
     * @category Filterable
     * @since 2.0.0
     */
    var filter$2 = filter$4;
    /**
     * Maps a `Record` with an iterating function that returns an `Option`
     * and it keeps only the `Some` values discarding the `None`s.
     *
     * @example
     * import { filterMap } from "fp-ts/Record"
     * import { option } from "fp-ts"
     *
     * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none
     * assert.deepStrictEqual(filterMap(f)({ a: "foo", b: "bar", c: "verylong" }), {
     *   a: "foo is short",
     *   b: "bar is short",
     * });
     *
     * @category Filterable
     * @since 2.0.0
     */
    var filterMap$2 = filterMap$4;
    /**
     * Partition a `Record` into two parts according to a `Predicate`.
     *
     * @example
     * import { partition } from "fp-ts/Record"
     *
     * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: "foo", b: "bar", c: "verylong" }), {
     *   left:{
     *     c: "verylong"
     *   },
     *   right: {
     *     a: "foo",
     *     b: "bar",
     *   },
     * });
     *
     * @category Filterable
     * @since 2.0.0
     */
    var partition$2 = partition$4;
    /**
     * Maps a `Record` with a function returning an `Either` and
     * partitions the resulting `Record` into `Left`s and `Right`s.
     *
     * @example
     * import { partitionMap } from "fp-ts/Record"
     * import { either } from "fp-ts"
     *
     * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));
     * assert.deepStrictEqual(partitionMap(f)({ a: "foo", b: "bar", c: "verylong" }), {
     *   left: {
     *     c: "verylong is not short",
     *   },
     *   right: {
     *     a: "foo is short",
     *     b: "bar is short",
     *   },
     * });
     *
     * @category Filterable
     * @since 2.0.0
     */
    var partitionMap$2 = partitionMap$4;
    function reduce$4() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return args.length === 1 ? reduce$7(args[0]) : reduce$7(Ord$1).apply(void 0, args);
    }
    function foldMap$4(O) {
        return 'compare' in O ? foldMap$7(O) : foldMap$7(Ord$1)(O);
    }
    function reduceRight$4() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return args.length === 1 ? reduceRight$7(args[0]) : reduceRight$7(Ord$1).apply(void 0, args);
    }
    /**
     * Compact a `Record` of `Option`s discarding the `None` values and
     * keeping the `Some` values.
     *
     * @example
     * import { compact } from 'fp-ts/Record'
     * import { option } from 'fp-ts'
     *
     * assert.deepStrictEqual(compact({ a: option.some("foo"), b: option.none, c: option.some("bar") }), {
     *   a: "foo",
     *   c: "bar",
     * });
     *
     * @category Compactable
     * @since 2.0.0
     */
    var compact$2 = compact$4;
    /**
     * Separate a `Record` of `Either`s into `Left`s and `Right`s.
     *
     * @example
     * import { separate } from 'fp-ts/Record'
     * import { either } from 'fp-ts'
     *
     * assert.deepStrictEqual(
     *   separate({ a: either.right("foo"), b: either.left("bar"), c: either.right("baz") }),
     *   {
     *     right: {
     *       a: "foo",
     *       c: "baz",
     *     },
     *     left: {
     *       b: "bar",
     *     },
     *   }
     * );
     *
     * @category Compactable
     * @since 2.0.0
     */
    var separate$2 = separate$4;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$9 = 'Record';
    function getShow$3(O) {
        return 'compare' in O ? getShow$5(O) : getShow$5(Ord$1)(O);
    }
    /**
     * Given an `Eq` for the base type, it produces an `Eq`
     * for a `Record` of that base type.
     *
     * @example
     * import { getEq } from "fp-ts/Record";
     * import { string } from "fp-ts";
     * import { Eq } from "fp-ts/Eq";
     *
     * const eq: Eq<Record<string, string>> = getEq(string.Eq);
     * assert.deepStrictEqual(eq.equals({ a: "foo" }, { b: "bar" }), false);
     * assert.deepStrictEqual(eq.equals({ a: "foo" }, { a: "foo" }), true);
     *
     * @category instances
     * @since 2.0.0
     */
    var getEq$3 = getEq$5;
    /**
     * Returns a `Monoid` instance for `Record`s, given a `Semigroup`
     * instance for the base type.
     * The `Monoid` makes the union of two `Record`s comining the
     * overlapping entries with the provided `Semigroup`.
     *
     * @example
     * import { SemigroupSum } from 'fp-ts/number'
     * import { getMonoid } from 'fp-ts/Record'
     *
     * const M = getMonoid(SemigroupSum);
     * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });
     *
     * @category instances
     * @since 2.0.0
     */
    var getMonoid = getMonoid$1;
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$a = {
        URI: URI$9,
        map: _map$9
    };
    /**
     * Derivable from `Functor`.
     * Takes a value and a `Record` of functions and returns a
     * `Record` by applying each function to the input value.
     *
     * @example
     * import { flap } from "fp-ts/Record"
     *
     * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };
     * assert.deepStrictEqual(flap(3)(fab), {
     *   x: "3 times 2",
     *   y: "6",
     * });
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$a = 
    /*#__PURE__*/
    flap$x(Functor$a);
    /**
     * @category instances
     * @since 2.7.0
     */
    var FunctorWithIndex = {
        URI: URI$9,
        map: _map$9,
        mapWithIndex: _mapWithIndex
    };
    /**
     * Produces a `Foldable` instance for a `Record`, using the
     * provided `Ord` to sort the `Record`'s entries by key.
     *
     * @category instances
     * @since 2.11.0
     */
    var getFoldable = function (O) { return ({
        URI: URI$9,
        reduce: _reduce$3(O),
        foldMap: _foldMap$3(O),
        reduceRight: _reduceRight$3(O)
    }); };
    /**
     * Produces a `FoldableWithIndex1` instance for a `Record`, using the
     * provided `Ord` to sort the `Record`'s entries by key.
     *
     * @category instances
     * @since 2.11.0
     */
    var getFoldableWithIndex = function (O) { return ({
        URI: URI$9,
        reduce: _reduce$3(O),
        foldMap: _foldMap$3(O),
        reduceRight: _reduceRight$3(O),
        reduceWithIndex: _reduceWithIndex(O),
        foldMapWithIndex: _foldMapWithIndex(O),
        reduceRightWithIndex: _reduceRightWithIndex(O)
    }); };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Compactable$1 = {
        URI: URI$9,
        compact: compact$2,
        separate: separate$2
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Filterable$1 = {
        URI: URI$9,
        map: _map$9,
        compact: compact$2,
        separate: separate$2,
        filter: _filter$1,
        filterMap: _filterMap$1,
        partition: _partition$1,
        partitionMap: _partitionMap$1
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var FilterableWithIndex = {
        URI: URI$9,
        map: _map$9,
        mapWithIndex: _mapWithIndex,
        compact: compact$2,
        separate: separate$2,
        filter: _filter$1,
        filterMap: _filterMap$1,
        partition: _partition$1,
        partitionMap: _partitionMap$1,
        filterMapWithIndex: _filterMapWithIndex,
        filterWithIndex: _filterWithIndex,
        partitionMapWithIndex: _partitionMapWithIndex,
        partitionWithIndex: _partitionWithIndex
    };
    /**
     * Produces a `Traversable` instance for a `Record`, using the
     * provided `Ord` to sort the `Record`'s entries by key.
     *
     * @category instances
     * @since 2.11.0
     */
    var getTraversable = function (O) { return ({
        URI: URI$9,
        map: _map$9,
        reduce: _reduce$3(O),
        foldMap: _foldMap$3(O),
        reduceRight: _reduceRight$3(O),
        traverse: _traverse$3(O),
        sequence: _sequence(O)
    }); };
    /**
     * Produces a `TraversableWithIndex` instance for a `Record`, using the
     * provided `Ord` to sort the `Record`'s entries by key.
     *
     * @category instances
     * @since 2.11.0
     */
    var getTraversableWithIndex = function (O) { return ({
        URI: URI$9,
        map: _map$9,
        mapWithIndex: _mapWithIndex,
        reduce: _reduce$3(O),
        foldMap: _foldMap$3(O),
        reduceRight: _reduceRight$3(O),
        reduceWithIndex: _reduceWithIndex(O),
        foldMapWithIndex: _foldMapWithIndex(O),
        reduceRightWithIndex: _reduceRightWithIndex(O),
        traverse: _traverse$3(O),
        sequence: _sequence(O),
        traverseWithIndex: _traverseWithIndex(O)
    }); };
    /**
     * @category instances
     * @since 2.11.0
     */
    var getWitherable = function (O) {
        var T = getTraversable(O);
        return {
            URI: URI$9,
            map: _map$9,
            reduce: _reduce$3(O),
            foldMap: _foldMap$3(O),
            reduceRight: _reduceRight$3(O),
            traverse: T.traverse,
            sequence: T.sequence,
            compact: compact$2,
            separate: separate$2,
            filter: _filter$1,
            filterMap: _filterMap$1,
            partition: _partition$1,
            partitionMap: _partitionMap$1,
            wither: witherDefault$1(T, Compactable$1),
            wilt: wiltDefault$1(T, Compactable$1)
        };
    };
    /**
     * Given a `Semigroup` in the base type, it produces a `Semigroup`
     * in the `Record` of the base type.
     * The resulting `Semigroup` concatenates two `Record`s by
     * `union`.
     *
     * @example
     * import { getUnionSemigroup } from "fp-ts/Record"
     * import { Semigroup } from "fp-ts/Semigroup"
     *
     * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };
     * const sRecord: Semigroup<Record<string, number>> = getUnionSemigroup(sNumber);
     * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });
     *
     * @category instances
     * @since 2.11.0
     */
    var getUnionSemigroup$1 = function (S) {
        var unionS = union$1(S);
        return {
            concat: function (first, second) { return unionS(second)(first); }
        };
    };
    /**
     * Same as `getMonoid`.
     * Returns a `Monoid` instance for `Record`s given a `Semigroup`
     * instance for the base type.
     * The `Monoid` makes the union of two `Record`s combining the
     * entries that have the same key with the provided `Semigroup`.
     *
     * @example
     * import { SemigroupSum } from 'fp-ts/number'
     * import { getUnionMonoid } from 'fp-ts/Record'
     *
     * const M = getUnionMonoid(SemigroupSum);
     * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });
     *
     * @category instances
     * @since 2.11.0
     */
    var getUnionMonoid$1 = function (S) { return ({
        concat: getUnionSemigroup$1(S).concat,
        empty: {}
    }); };
    /**
     * Given a `Semigroup` in the base type, it produces a `Semigroup`
     * in the `Record` of the base type.
     * The resulting `Semigroup` concatenates two `Record`s by
     * `intersection`.
     *
     * @example
     * import { getIntersectionSemigroup } from "fp-ts/Record"
     * import { Semigroup } from "fp-ts/Semigroup"
     *
     * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };
     * const sRecord: Semigroup<Record<string, number>> = getIntersectionSemigroup(sNumber);
     * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });
     *
     * @category instances
     * @since 2.11.0
     */
    var getIntersectionSemigroup$1 = function (S) {
        var intersectionS = intersection$1(S);
        return {
            concat: function (first, second) { return intersectionS(second)(first); }
        };
    };
    /**
     * Produces a `Magma` with a `concat` function that combines
     * two `Record`s by making the `difference`.
     *
     * @example
     * import { getDifferenceMagma, difference } from "fp-ts/Record"
     * import { Magma } from "fp-ts/Magma"
     *
     * const r1 = { a: 3, c: 3 };
     * const r2 = { a: 1, b: 2 };
     * const m: Magma<Record<string, number>> = getDifferenceMagma<number>();
     * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));
     * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });
     *
     * @category instances
     * @since 2.11.0
     */
    var getDifferenceMagma$1 = function () { return ({
        concat: function (first, second) { return difference$1(second)(first); }
    }); };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use `getFoldable` instead.
     *
     * @category instances
     * @since 2.7.0
     * @deprecated
     */
    var Foldable$3 = {
        URI: URI$9,
        reduce: 
        /*#__PURE__*/
        _reduce$3(Ord$1),
        foldMap: 
        /*#__PURE__*/
        _foldMap$3(Ord$1),
        reduceRight: 
        /*#__PURE__*/
        _reduceRight$3(Ord$1)
    };
    /**
     * Use `getFoldableWithIndex` instead.
     *
     * @category instances
     * @since 2.7.0
     * @deprecated
     */
    var FoldableWithIndex = {
        URI: URI$9,
        reduce: 
        /*#__PURE__*/
        _reduce$3(Ord$1),
        foldMap: 
        /*#__PURE__*/
        _foldMap$3(Ord$1),
        reduceRight: 
        /*#__PURE__*/
        _reduceRight$3(Ord$1),
        reduceWithIndex: 
        /*#__PURE__*/
        _reduceWithIndex(Ord$1),
        foldMapWithIndex: 
        /*#__PURE__*/
        _foldMapWithIndex(Ord$1),
        reduceRightWithIndex: 
        /*#__PURE__*/
        _reduceRightWithIndex(Ord$1)
    };
    /**
     * Use `getTraversable` instead.
     *
     * @category instances
     * @since 2.7.0
     * @deprecated
     */
    var Traversable$4 = {
        URI: URI$9,
        map: _map$9,
        reduce: 
        /*#__PURE__*/
        _reduce$3(Ord$1),
        foldMap: 
        /*#__PURE__*/
        _foldMap$3(Ord$1),
        reduceRight: 
        /*#__PURE__*/
        _reduceRight$3(Ord$1),
        traverse: 
        /*#__PURE__*/
        _traverse$3(Ord$1),
        sequence: sequence$4
    };
    /**
     * Use the `getTraversableWithIndex` instead.
     *
     * @category instances
     * @since 2.7.0
     * @deprecated
     */
    var TraversableWithIndex$1 = {
        URI: URI$9,
        map: _map$9,
        mapWithIndex: _mapWithIndex,
        reduce: 
        /*#__PURE__*/
        _reduce$3(Ord$1),
        foldMap: 
        /*#__PURE__*/
        _foldMap$3(Ord$1),
        reduceRight: 
        /*#__PURE__*/
        _reduceRight$3(Ord$1),
        reduceWithIndex: 
        /*#__PURE__*/
        _reduceWithIndex(Ord$1),
        foldMapWithIndex: 
        /*#__PURE__*/
        _foldMapWithIndex(Ord$1),
        reduceRightWithIndex: 
        /*#__PURE__*/
        _reduceRightWithIndex(Ord$1),
        traverse: 
        /*#__PURE__*/
        _traverse$3(Ord$1),
        sequence: sequence$4,
        traverseWithIndex: 
        /*#__PURE__*/
        _traverseWithIndex(Ord$1)
    };
    var _wither = 
    /*#__PURE__*/
    witherDefault$1(Traversable$4, Compactable$1);
    var _wilt = 
    /*#__PURE__*/
    wiltDefault$1(Traversable$4, Compactable$1);
    /**
     * Use `getWitherable` instead.
     *
     * @category instances
     * @since 2.7.0
     * @deprecated
     */
    var Witherable$1 = {
        URI: URI$9,
        map: _map$9,
        reduce: 
        /*#__PURE__*/
        _reduce$3(Ord$1),
        foldMap: 
        /*#__PURE__*/
        _foldMap$3(Ord$1),
        reduceRight: 
        /*#__PURE__*/
        _reduceRight$3(Ord$1),
        traverse: 
        /*#__PURE__*/
        _traverse$3(Ord$1),
        sequence: sequence$4,
        compact: compact$2,
        separate: separate$2,
        filter: _filter$1,
        filterMap: _filterMap$1,
        partition: _partition$1,
        partitionMap: _partitionMap$1,
        wither: _wither,
        wilt: _wilt
    };
    /**
     * Use a new `{}` instead.
     *
     * @since 2.0.0
     * @deprecated
     */
    var empty$1 = {};
    /**
     * Use [`upsertAt`](#upsertat) instead.
     *
     * @since 2.0.0
     * @deprecated
     */
    var insertAt = upsertAt;
    /**
     * Use [`has`](#has) instead.
     *
     * @since 2.0.0
     * @deprecated
     */
    var hasOwnProperty = hasOwnProperty$1;
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var record = {
        URI: URI$9,
        map: _map$9,
        reduce: 
        /*#__PURE__*/
        _reduce$3(Ord$1),
        foldMap: 
        /*#__PURE__*/
        _foldMap$3(Ord$1),
        reduceRight: 
        /*#__PURE__*/
        _reduceRight$3(Ord$1),
        traverse: 
        /*#__PURE__*/
        _traverse$3(Ord$1),
        sequence: sequence$4,
        compact: compact$2,
        separate: separate$2,
        filter: _filter$1,
        filterMap: _filterMap$1,
        partition: _partition$1,
        partitionMap: _partitionMap$1,
        mapWithIndex: _mapWithIndex,
        reduceWithIndex: 
        /*#__PURE__*/
        _reduceWithIndex(Ord$1),
        foldMapWithIndex: 
        /*#__PURE__*/
        _foldMapWithIndex(Ord$1),
        reduceRightWithIndex: 
        /*#__PURE__*/
        _reduceRightWithIndex(Ord$1),
        filterMapWithIndex: _filterMapWithIndex,
        filterWithIndex: _filterWithIndex,
        partitionMapWithIndex: _partitionMapWithIndex,
        partitionWithIndex: _partitionWithIndex,
        traverseWithIndex: 
        /*#__PURE__*/
        _traverseWithIndex(Ord$1),
        wither: _wither,
        wilt: _wilt
    };

    var Record = /*#__PURE__*/Object.freeze({
        __proto__: null,
        size: size$1,
        isEmpty: isEmpty$1,
        keys: keys$1,
        collect: collect,
        toArray: toArray$1,
        toUnfoldable: toUnfoldable,
        upsertAt: upsertAt,
        has: has$2,
        deleteAt: deleteAt,
        updateAt: updateAt,
        modifyAt: modifyAt,
        pop: pop,
        isSubrecord: isSubrecord,
        lookup: lookup,
        mapWithIndex: mapWithIndex,
        map: map$d,
        reduceWithIndex: reduceWithIndex,
        foldMapWithIndex: foldMapWithIndex,
        reduceRightWithIndex: reduceRightWithIndex,
        singleton: singleton$2,
        traverseWithIndex: traverseWithIndex,
        traverse: traverse$4,
        sequence: sequence$4,
        wither: wither,
        wilt: wilt,
        partitionMapWithIndex: partitionMapWithIndex,
        partitionWithIndex: partitionWithIndex,
        filterMapWithIndex: filterMapWithIndex,
        filterWithIndex: filterWithIndex,
        fromFoldable: fromFoldable,
        fromFoldableMap: fromFoldableMap,
        every: every$1,
        some: some$3,
        elem: elem$3,
        union: union$1,
        intersection: intersection$1,
        difference: difference$1,
        filter: filter$2,
        filterMap: filterMap$2,
        partition: partition$2,
        partitionMap: partitionMap$2,
        reduce: reduce$4,
        foldMap: foldMap$4,
        reduceRight: reduceRight$4,
        compact: compact$2,
        separate: separate$2,
        URI: URI$9,
        getShow: getShow$3,
        getEq: getEq$3,
        getMonoid: getMonoid,
        Functor: Functor$a,
        flap: flap$a,
        FunctorWithIndex: FunctorWithIndex,
        getFoldable: getFoldable,
        getFoldableWithIndex: getFoldableWithIndex,
        Compactable: Compactable$1,
        Filterable: Filterable$1,
        FilterableWithIndex: FilterableWithIndex,
        getTraversable: getTraversable,
        getTraversableWithIndex: getTraversableWithIndex,
        getWitherable: getWitherable,
        getUnionSemigroup: getUnionSemigroup$1,
        getUnionMonoid: getUnionMonoid$1,
        getIntersectionSemigroup: getIntersectionSemigroup$1,
        getDifferenceMagma: getDifferenceMagma$1,
        Foldable: Foldable$3,
        FoldableWithIndex: FoldableWithIndex,
        Traversable: Traversable$4,
        TraversableWithIndex: TraversableWithIndex$1,
        Witherable: Witherable$1,
        empty: empty$1,
        insertAt: insertAt,
        hasOwnProperty: hasOwnProperty,
        record: record
    });

    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * Returns a `Refinement` from a `Option` returning function.
     * This function ensures that a `Refinement` definition is type-safe.
     *
     * @category constructors
     * @since 2.11.0
     */
    var fromOptionK$5 = function (getOption) {
        return function (a) { return isSome$2(getOption(a)); };
    };
    /**
     * @category constructors
     * @since 2.11.0
     */
    var fromEitherK$2 = function (getEither) {
        return function (a) { return isRight$3(getEither(a)); };
    };
    /**
     * @category constructors
     * @since 2.11.0
     */
    var id = function () {
        return function (_) { return true; };
    };
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * @category combinators
     * @since 2.11.0
     */
    var not = function (refinement) { return function (a) { return !refinement(a); }; };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var or = function (second) { return function (first) { return function (a) { return first(a) || second(a); }; }; };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var and = function (second) { return function (first) { return function (a) { return first(a) && second(a); }; }; };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var zero$1 = function () {
        return function (_) { return false; };
    };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var compose$1 = function (bc) { return function (ab) {
        return function (i) { return ab(i) && bc(i); };
    }; };

    var Refinement = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fromOptionK: fromOptionK$5,
        fromEitherK: fromEitherK$2,
        id: id,
        not: not,
        or: or,
        and: and,
        zero: zero$1,
        compose: compose$1
    });

    /**
     * The `Ring` class is for types that support addition, multiplication, and subtraction operations.
     *
     * Instances must satisfy the following law in addition to the `Semiring` laws:
     *
     * - Additive inverse: `a - a <-> (zero - a) + a <-> zero`
     *
     * Adapted from https://github.com/purescript/purescript-prelude/blob/master/src/Data/Ring.purs
     *
     * @since 2.0.0
     */
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * Given a tuple of `Ring`s returns a `Ring` for the tuple
     *
     * @example
     * import { tuple } from 'fp-ts/Ring'
     * import * as N from 'fp-ts/number'
     *
     * const R = tuple(N.Field, N.Field, N.Field)
     * assert.deepStrictEqual(R.add([1, 2, 3], [4, 5, 6]), [5, 7, 9])
     * assert.deepStrictEqual(R.mul([1, 2, 3], [4, 5, 6]), [4, 10, 18])
     * assert.deepStrictEqual(R.one, [1, 1, 1])
     * assert.deepStrictEqual(R.sub([1, 2, 3], [4, 5, 6]), [-3, -3, -3])
     * assert.deepStrictEqual(R.zero, [0, 0, 0])
     *
     * @category combinators
     * @since 2.10.0
     */
    var tuple$2 = function () {
        var rings = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            rings[_i] = arguments[_i];
        }
        return ({
            add: function (x, y) { return rings.map(function (R, i) { return R.add(x[i], y[i]); }); },
            zero: rings.map(function (R) { return R.zero; }),
            mul: function (x, y) { return rings.map(function (R, i) { return R.mul(x[i], y[i]); }); },
            one: rings.map(function (R) { return R.one; }),
            sub: function (x, y) { return rings.map(function (R, i) { return R.sub(x[i], y[i]); }); }
        });
    };
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * `negate x` can be used as a shorthand for `zero - x`
     *
     * @since 2.0.0
     */
    var negate = function (R) { return function (a) { return R.sub(R.zero, a); }; };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use [`tuple`](#tuple) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    var getTupleRing = tuple$2;
    /**
     * Use [`getRing`](./function.ts.html#getring) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getFunctionRing = getRing$1;

    var Ring = /*#__PURE__*/Object.freeze({
        __proto__: null,
        tuple: tuple$2,
        negate: negate,
        getTupleRing: getTupleRing,
        getFunctionRing: getFunctionRing
    });

    var Semigroupoid$1 = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    /**
     * The `Semiring` class is for types that support an addition and multiplication operation.
     *
     * Instances must satisfy the following laws:
     *
     * - Commutative monoid under addition:
     *   - Associativity: `(a + b) + c <-> a + (b + c)`
     *   - Identity: `zero + a = a + zero <-> a`
     *   - Commutative: `a + b <-> b + a`
     * - Monoid under multiplication:
     *   - Associativity: `(a * b) * c <-> a * (b * c)`
     *   - Identity: `one * a <-> a * one <-> a`
     * - Multiplication distributes over addition:
     *   - Left distributivity: `a * (b + c) <-> (a * b) + (a * c)`
     *   - Right distributivity: `(a + b) * c <-> (a * c) + (b * c)`
     * - Annihilation: `zero * a <-> a * zero <-> zero`
     *
     * **Note:** The `number` type is not fully law abiding members of this class hierarchy due to the potential
     * for arithmetic overflows, and the presence of `NaN` and `Infinity` values. The behaviour is
     * unspecified in these cases.
     *
     * @since 2.0.0
     */
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use [`getSemiring`](./function.ts.html#getsemiring) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getFunctionSemiring = getSemiring$1;

    var Semiring = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getFunctionSemiring: getFunctionSemiring
    });

    /**
     * @category instances
     * @since 2.0.0
     */
    var getShow$2 = getShow$4;
    /**
     * @category instances
     * @since 2.0.0
     */
    var getEq$2 = getEq$4;
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category combinators
     * @since 2.0.0
     */
    function map$c(E) {
        var elemE = elem$2(E);
        return function (f) { return function (set) {
            var r = new Set();
            set.forEach(function (e) {
                var v = f(e);
                if (!elemE(v, r)) {
                    r.add(v);
                }
            });
            return r;
        }; };
    }
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category combinators
     * @since 2.0.0
     */
    function chain$5(E) {
        var elemE = elem$2(E);
        return function (f) { return function (set) {
            var r = new Set();
            set.forEach(function (e) {
                f(e).forEach(function (e) {
                    if (!elemE(e, r)) {
                        r.add(e);
                    }
                });
            });
            return r;
        }; };
    }
    function filter$1(predicate) {
        return function (set) {
            var values = set.values();
            var e;
            var r = new Set();
            // tslint:disable-next-line: strict-boolean-expressions
            while (!(e = values.next()).done) {
                var a = e.value;
                if (predicate(a)) {
                    r.add(a);
                }
            }
            return r;
        };
    }
    function partition$1(predicate) {
        return function (set) {
            var values = set.values();
            var e;
            var right = new Set();
            var left = new Set();
            // tslint:disable-next-line: strict-boolean-expressions
            while (!(e = values.next()).done) {
                var a = e.value;
                if (predicate(a)) {
                    right.add(a);
                }
                else {
                    left.add(a);
                }
            }
            return separated(left, right);
        };
    }
    function union(E) {
        var elemE = elem$2(E);
        return function (me, that) {
            if (that === undefined) {
                var unionE_1 = union(E);
                return function (that) { return unionE_1(me, that); };
            }
            if (isEmpty(me)) {
                return that;
            }
            if (isEmpty(that)) {
                return me;
            }
            var r = new Set(me);
            that.forEach(function (e) {
                if (!elemE(e, r)) {
                    r.add(e);
                }
            });
            return r;
        };
    }
    function intersection(E) {
        var elemE = elem$2(E);
        return function (me, that) {
            if (that === undefined) {
                var intersectionE_1 = intersection(E);
                return function (that) { return intersectionE_1(that, me); };
            }
            if (isEmpty(me) || isEmpty(that)) {
                return new Set();
            }
            var r = new Set();
            me.forEach(function (e) {
                if (elemE(e, that)) {
                    r.add(e);
                }
            });
            return r;
        };
    }
    /**
     * @since 2.0.0
     */
    function partitionMap$1(EB, EC) {
        return function (f) { return function (set) {
            var values = set.values();
            var e;
            var left = new Set();
            var right = new Set();
            var hasB = elem$2(EB);
            var hasC = elem$2(EC);
            // tslint:disable-next-line: strict-boolean-expressions
            while (!(e = values.next()).done) {
                var v = f(e.value);
                switch (v._tag) {
                    case 'Left':
                        if (!hasB(v.left, left)) {
                            left.add(v.left);
                        }
                        break;
                    case 'Right':
                        if (!hasC(v.right, right)) {
                            right.add(v.right);
                        }
                        break;
                }
            }
            return separated(left, right);
        }; };
    }
    function difference(E) {
        var elemE = elem$2(E);
        return function (me, that) {
            if (that === undefined) {
                var differenceE_1 = difference(E);
                return function (that) { return differenceE_1(that, me); };
            }
            return filter$1(function (a) { return !elemE(a, that); })(me);
        };
    }
    /**
     * @category instances
     * @since 2.11.0
     */
    var getUnionSemigroup = function (E) { return ({
        concat: union(E)
    }); };
    /**
     * @category instances
     * @since 2.0.0
     */
    var getUnionMonoid = function (E) { return ({
        concat: getUnionSemigroup(E).concat,
        empty: new Set()
    }); };
    /**
     * @category instances
     * @since 2.0.0
     */
    var getIntersectionSemigroup = function (E) { return ({
        concat: intersection(E)
    }); };
    /**
     * @category instances
     * @since 2.11.0
     */
    var getDifferenceMagma = function (E) { return ({
        concat: difference(E)
    }); };
    /**
     * @since 2.0.0
     */
    var reduce$3 = reduce$6;
    /**
     * @since 2.0.0
     */
    var foldMap$3 = foldMap$6;
    /**
     * @since 2.11.0
     */
    var reduceRight$3 = reduceRight$6;
    /**
     * Create a set with one element
     *
     * @category constructors
     * @since 2.0.0
     */
    var singleton$1 = function (a) { return new Set([a]); };
    /**
     * Insert a value into a set
     *
     * @category combinators
     * @since 2.0.0
     */
    function insert(E) {
        var elemE = elem$2(E);
        return function (a) { return function (set) {
            if (!elemE(a)(set)) {
                var r = new Set(set);
                r.add(a);
                return r;
            }
            else {
                return set;
            }
        }; };
    }
    /**
     * Delete a value from a set
     *
     * @category combinators
     * @since 2.0.0
     */
    var remove = function (E) { return function (a) { return function (set) { return filter$1(function (ax) { return !E.equals(a, ax); })(set); }; }; };
    /**
     * Checks an element is a member of a set;
     * If yes, removes the value from the set
     * If no, inserts the value to the set
     *
     * @category combinators
     * @since 2.5.0
     */
    var toggle = function (E) {
        var elemE = elem$2(E);
        var removeE = remove(E);
        var insertE = insert(E);
        return function (a) { return function (set) { return (elemE(a, set) ? removeE : insertE)(a)(set); }; };
    };
    /**
     * Create a set from an array
     *
     * @category constructors
     * @since 2.0.0
     */
    var fromArray = function (E) { return function (as) {
        var len = as.length;
        var out = new Set();
        var has = elem$2(E);
        for (var i = 0; i < len; i++) {
            var a = as[i];
            if (!has(a, out)) {
                out.add(a);
            }
        }
        return out;
    }; };
    /**
     * @category combinators
     * @since 2.0.0
     */
    var compact$1 = function (E) { return filterMap$1(E)(identity$1); };
    /**
     * @since 2.0.0
     */
    function separate$1(EE, EA) {
        return function (fa) {
            var elemEE = elem$2(EE);
            var elemEA = elem$2(EA);
            var left = new Set();
            var right = new Set();
            fa.forEach(function (e) {
                switch (e._tag) {
                    case 'Left':
                        if (!elemEE(e.left, left)) {
                            left.add(e.left);
                        }
                        break;
                    case 'Right':
                        if (!elemEA(e.right, right)) {
                            right.add(e.right);
                        }
                        break;
                }
            });
            return separated(left, right);
        };
    }
    /**
     * @category combinators
     * @since 2.0.0
     */
    function filterMap$1(E) {
        var elemE = elem$2(E);
        return function (f) { return function (fa) {
            var r = new Set();
            fa.forEach(function (a) {
                var ob = f(a);
                if (ob._tag === 'Some' && !elemE(ob.value, r)) {
                    r.add(ob.value);
                }
            });
            return r;
        }; };
    }
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.0.0
     */
    var empty = new Set();
    /**
     * Test whether a `Set` is empty.
     *
     * @since 2.10.0
     */
    var isEmpty = function (set) { return set.size === 0; };
    /**
     * Calculate the number of elements in a `Set`.
     *
     * @since 2.10.0
     */
    var size = function (set) { return set.size; };
    /**
     * @since 2.0.0
     */
    var some$2 = some$4;
    /**
     * @since 2.0.0
     */
    var every = every$2;
    /**
     * @since 2.10.0
     */
    var isSubset = isSubset$1;
    // TODO: remove non-curried overloading in v3
    /**
     * Test if a value is a member of a set
     *
     * @since 2.0.0
     */
    var elem$2 = elem$4;
    /**
     * Get a sorted `Array` of the values contained in a `Set`.
     *
     * @since 2.0.0
     */
    var toArray = function (O) { return function (set) {
        var out = [];
        set.forEach(function (e) { return out.push(e); });
        return out.sort(O.compare);
    }; };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use [`isSubset`](#issubset) instead.
     *
     * @since 2.0.0
     * @deprecated
     */
    var subset = isSubset$1;

    var Set$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getShow: getShow$2,
        getEq: getEq$2,
        map: map$c,
        chain: chain$5,
        filter: filter$1,
        partition: partition$1,
        union: union,
        intersection: intersection,
        partitionMap: partitionMap$1,
        difference: difference,
        getUnionSemigroup: getUnionSemigroup,
        getUnionMonoid: getUnionMonoid,
        getIntersectionSemigroup: getIntersectionSemigroup,
        getDifferenceMagma: getDifferenceMagma,
        reduce: reduce$3,
        foldMap: foldMap$3,
        reduceRight: reduceRight$3,
        singleton: singleton$1,
        insert: insert,
        remove: remove,
        toggle: toggle,
        fromArray: fromArray,
        compact: compact$1,
        separate: separate$1,
        filterMap: filterMap$1,
        empty: empty,
        isEmpty: isEmpty,
        size: size,
        some: some$2,
        every: every,
        isSubset: isSubset,
        elem: elem$2,
        toArray: toArray,
        subset: subset
    });

    /**
     * The `Show` type class represents those types which can be converted into
     * a human-readable `string` representation.
     *
     * While not required, it is recommended that for any expression `x`, the
     * string `show(x)` be executable TypeScript code which evaluates to the same
     * value as the expression `x`.
     *
     * @since 2.0.0
     */
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * @category combinators
     * @since 2.10.0
     */
    var struct$1 = function (shows) { return ({
        show: function (a) {
            var s = '{';
            for (var k in shows) {
                if (has$4.call(shows, k)) {
                    s += " " + k + ": " + shows[k].show(a[k]) + ",";
                }
            }
            if (s.length > 1) {
                s = s.slice(0, -1) + ' ';
            }
            s += '}';
            return s;
        }
    }); };
    /**
     * @category combinators
     * @since 2.10.0
     */
    var tuple$1 = function () {
        var shows = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            shows[_i] = arguments[_i];
        }
        return ({
            show: function (t) { return "[" + t.map(function (a, i) { return shows[i].show(a); }).join(', ') + "]"; }
        });
    };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use [`tuple`](#tuple) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    var getTupleShow = tuple$1;
    /**
     * Use [`struct`](#struct) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    var getStructShow = struct$1;
    /**
     * Use [`Show`](./boolean.ts.html#show) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var showBoolean = {
        show: function (a) { return JSON.stringify(a); }
    };
    /**
     * Use [`Show`](./string.ts.html#show) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var showString = {
        show: function (a) { return JSON.stringify(a); }
    };
    /**
     * Use [`Show`](./number.ts.html#show) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var showNumber = {
        show: function (a) { return JSON.stringify(a); }
    };

    var Show = /*#__PURE__*/Object.freeze({
        __proto__: null,
        struct: struct$1,
        tuple: tuple$1,
        getTupleShow: getTupleShow,
        getStructShow: getStructShow,
        showBoolean: showBoolean,
        showString: showString,
        showNumber: showNumber
    });

    function of$6(F) {
        return function (a) { return function (s) { return F.of([a, s]); }; };
    }
    function map$b(F) {
        return function (f) { return function (fa) { return function (s) { return F.map(fa(s), function (_a) {
            var a = _a[0], s1 = _a[1];
            return [f(a), s1];
        }); }; }; };
    }
    function ap$5(M) {
        return function (fa) { return function (fab) { return function (s) { return M.chain(fab(s), function (_a) {
            var f = _a[0], s = _a[1];
            return M.map(fa(s), function (_a) {
                var a = _a[0], s = _a[1];
                return [f(a), s];
            });
        }); }; }; };
    }
    function chain$4(M) {
        return function (f) { return function (ma) { return function (s) { return M.chain(ma(s), function (_a) {
            var a = _a[0], s1 = _a[1];
            return f(a)(s1);
        }); }; }; };
    }
    function fromState$1(F) {
        return function (sa) { return function (s) { return F.of(sa(s)); }; };
    }
    function fromF(F) {
        return function (ma) { return function (s) { return F.map(ma, function (a) { return [a, s]; }); }; };
    }
    function evaluate$2(F) {
        return function (s) { return function (ma) { return F.map(ma(s), function (_a) {
            var a = _a[0];
            return a;
        }); }; };
    }
    function execute$2(F) {
        return function (s) { return function (ma) { return F.map(ma(s), snd$1); }; };
    }
    /** @deprecated */
    /* istanbul ignore next */
    function getStateM(M) {
        var _ap = ap$5(M);
        var _map = map$b(M);
        var _chain = chain$4(M);
        var _evaluate = evaluate$2(M);
        var _execute = execute$2(M);
        return {
            map: function (fa, f) { return pipe$1(fa, _map(f)); },
            ap: function (fab, fa) { return pipe$1(fab, _ap(fa)); },
            of: of$6(M),
            chain: function (ma, f) { return pipe$1(ma, _chain(f)); },
            get: function () { return function (s) { return M.of([s, s]); }; },
            put: function (s) { return function () { return M.of([undefined, s]); }; },
            modify: function (f) { return function (s) { return M.of([undefined, f(s)]); }; },
            gets: function (f) { return function (s) { return M.of([f(s), s]); }; },
            fromState: fromState$1(M),
            fromM: fromF(M),
            evalState: function (fa, s) { return pipe$1(fa, _evaluate(s)); },
            execState: function (fa, s) { return pipe$1(fa, _execute(s)); }
        };
    }

    var StateT = /*#__PURE__*/Object.freeze({
        __proto__: null,
        of: of$6,
        map: map$b,
        ap: ap$5,
        chain: chain$4,
        fromState: fromState$1,
        fromF: fromF,
        evaluate: evaluate$2,
        execute: execute$2,
        getStateM: getStateM
    });

    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * @category constructors
     * @since 2.0.0
     */
    var left$4 = function (e) { return function () { return left$5(e); }; };
    /**
     * @category constructors
     * @since 2.0.0
     */
    var right$4 = 
    /*#__PURE__*/
    of$6(Pointed$5);
    /**
     * @category constructors
     * @since 2.0.0
     */
    function rightTask$1(ma) {
        return fromReaderTaskEither(rightTask$2(ma));
    }
    /**
     * @category constructors
     * @since 2.0.0
     */
    function leftTask$1(me) {
        return fromReaderTaskEither(leftTask$2(me));
    }
    /**
     * @category constructors
     * @since 2.0.0
     */
    function rightReader(ma) {
        return fromReaderTaskEither(rightReader$1(ma));
    }
    /**
     * @category constructors
     * @since 2.0.0
     */
    function leftReader(me) {
        return fromReaderTaskEither(leftReader$1(me));
    }
    /**
     * @category constructors
     * @since 2.0.0
     */
    function rightIO$1(ma) {
        return fromReaderTaskEither(rightIO$2(ma));
    }
    /**
     * @category constructors
     * @since 2.0.0
     */
    function leftIO$1(me) {
        return fromReaderTaskEither(leftIO$2(me));
    }
    /**
     * @category constructors
     * @since 2.0.0
     */
    var rightState = function (sa) {
        return flow(sa, right$5);
    };
    /**
     * @category constructors
     * @since 2.0.0
     */
    var leftState = function (me) { return function (s) { return left$5(me(s)[0]); }; };
    // -------------------------------------------------------------------------------------
    // natural transformations
    // -------------------------------------------------------------------------------------
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromEither$2 = 
    /*#__PURE__*/
    match$b(function (e) { return left$4(e); }, right$4);
    /**
     * @category natural transformations
     * @since 2.11.0
     */
    var fromReader = rightReader;
    /**
     * @category natural transformations
     * @since 2.7.0
     */
    var fromIO$2 = rightIO$1;
    /**
     * @category natural transformations
     * @since 2.7.0
     */
    var fromTask$2 = rightTask$1;
    /**
     * @category natural transformations
     * @since 2.10.0
     */
    var fromState = 
    /*#__PURE__*/
    fromState$1(Pointed$5);
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromTaskEither$1 = function (ma) { return fromReaderTaskEither(fromTaskEither$2(ma)); };
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromIOEither$1 = function (ma) { return fromReaderTaskEither(fromIOEither$2(ma)); };
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromReaderEither = function (ma) {
        return fromReaderTaskEither(fromReaderEither$1(ma));
    };
    /**
     * @category constructors
     * @since 2.0.0
     */
    var fromReaderTaskEither = 
    /*#__PURE__*/
    fromF(Functor$d);
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * Changes the value of the local context during the execution of the action `ma` (similar to `Contravariant`'s
     * `contramap`).
     *
     * @category combinators
     * @since 2.11.0
     */
    var local = function (f) { return function (ma) { return flow(ma, local$4(f)); }; };
    /**
     * Less strict version of [`asksStateReaderTaskEither`](#asksstatereadertaskeither).
     *
     * @category combinators
     * @since 2.11.0
     */
    var asksStateReaderTaskEitherW = function (f) { return function (s) { return function (r) { return f(r)(s)(r); }; }; };
    /**
     * Effectfully accesses the environment.
     *
     * @category combinators
     * @since 2.11.0
     */
    var asksStateReaderTaskEither = asksStateReaderTaskEitherW;
    /**
     * @category combinators
     * @since 2.4.0
     */
    var fromIOEitherK = function (f) { return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return fromIOEither$1(f.apply(void 0, a));
    }; };
    /**
     * Less strict version of [`chainIOEitherK`](#chainioeitherk).
     *
     * @category combinators
     * @since 2.6.1
     */
    var chainIOEitherKW = function (f) { return function (ma) { return pipe$1(ma, chainW(fromIOEitherK(f))); }; };
    /**
     * @category combinators
     * @since 2.4.0
     */
    var chainIOEitherK = chainIOEitherKW;
    /**
     * @category combinators
     * @since 2.4.0
     */
    var fromTaskEitherK = function (f) { return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return fromTaskEither$1(f.apply(void 0, a));
    }; };
    /**
     * Less strict version of [`chainTaskEitherK`](#chaintaskeitherk).
     *
     * @category combinators
     * @since 2.6.1
     */
    var chainTaskEitherKW = function (f) { return function (ma) { return pipe$1(ma, chainW(fromTaskEitherK(f))); }; };
    /**
     * @category combinators
     * @since 2.4.0
     */
    var chainTaskEitherK = chainTaskEitherKW;
    /**
     * @category combinators
     * @since 2.4.0
     */
    var fromReaderTaskEitherK = function (f) { return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return fromReaderTaskEither(f.apply(void 0, a));
    }; };
    /**
     * Less strict version of [`chainReaderTaskEitherK`](#chainreadertaskeitherk).
     *
     * @category combinators
     * @since 2.6.1
     */
    var chainReaderTaskEitherKW = function (f) { return function (ma) { return pipe$1(ma, chainW(fromReaderTaskEitherK(f))); }; };
    /**
     * @category combinators
     * @since 2.4.0
     */
    var chainReaderTaskEitherK = chainReaderTaskEitherKW;
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    /* istanbul ignore next */
    var _map$8 = function (fa, f) { return pipe$1(fa, map$a(f)); };
    /* istanbul ignore next */
    var _ap$2 = function (fab, fa) { return pipe$1(fab, ap$4(fa)); };
    /* istanbul ignore next */
    var _chain$2 = function (ma, f) { return pipe$1(ma, chain$3(f)); };
    /* istanbul ignore next */
    var _alt$1 = function (fa, that) { return function (s) {
        return pipe$1(fa(s), alt$2(function () { return that()(s); }));
    }; };
    var _bimap$3 = function (fea, f, g) { return function (s) {
        return pipe$1(fea(s), bimap$6(f, function (_a) {
            var a = _a[0], s = _a[1];
            return [g(a), s];
        }));
    }; };
    var _mapLeft$3 = function (fea, f) { return function (s) { return pipe$1(fea(s), mapLeft$6(f)); }; };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$a = 
    /*#__PURE__*/
    map$b(Functor$d);
    /**
     * Map a pair of functions over the two last type arguments of the bifunctor.
     *
     * @category Bifunctor
     * @since 2.6.2
     */
    var bimap$4 = function (f, g) { return function (fa) {
        return _bimap$3(fa, f, g);
    }; };
    /**
     * Map a function over the third type argument of a bifunctor.
     *
     * @category Bifunctor
     * @since 2.6.2
     */
    var mapLeft$4 = function (f) { return function (fa) {
        return _mapLeft$3(fa, f);
    }; };
    /**
     * Apply a function to an argument under a type constructor.
     *
     * @category Apply
     * @since 2.0.0
     */
    var ap$4 = 
    /*#__PURE__*/
    ap$5(Chain$5);
    /**
     * Less strict version of [`ap`](#ap).
     *
     * @category Apply
     * @since 2.8.0
     */
    var apW = ap$4;
    /**
     * @category Pointed
     * @since 2.7.0
     */
    var of$5 = right$4;
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category Monad
     * @since 2.0.0
     */
    var chain$3 = 
    /*#__PURE__*/
    chain$4(Chain$5);
    /**
     * Less strict version of [`chain`](#chain).
     *
     * @category Monad
     * @since 2.6.0
     */
    var chainW = chain$3;
    /**
     * Less strict version of [`flatten`](#flatten).
     *
     * @category combinators
     * @since 2.11.0
     */
    var flattenW = 
    /*#__PURE__*/
    chainW(identity$1);
    /**
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var flatten$2 = flattenW;
    /**
     * Less strict version of [`alt`](#alt).
     *
     * @category Alt
     * @since 2.9.0
     */
    var altW$1 = function (that) { return function (fa) { return function (r) {
        return pipe$1(fa(r), altW$2(function () { return that()(r); }));
    }; }; };
    /**
     * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
     * types of kind `* -> *`.
     *
     * @category Alt
     * @since 2.6.2
     */
    var alt$1 = altW$1;
    /**
     * @category MonadThrow
     * @since 2.7.0
     */
    var throwError = left$4;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$8 = 'StateReaderTaskEither';
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$9 = {
        URI: URI$8,
        map: _map$8
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$9 = 
    /*#__PURE__*/
    flap$x(Functor$9);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$4 = {
        URI: URI$8,
        of: of$5
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Apply$2 = {
        URI: URI$8,
        map: _map$8,
        ap: _ap$2
    };
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apFirst$3 = 
    /*#__PURE__*/
    apFirst$k(Apply$2);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apSecond$3 = 
    /*#__PURE__*/
    apSecond$k(Apply$2);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Applicative$2 = {
        URI: URI$8,
        map: _map$8,
        ap: _ap$2,
        of: of$5
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$4 = {
        URI: URI$8,
        map: _map$8,
        ap: _ap$2,
        chain: _chain$2
    };
    /**
     * @category instances
     * @since 2.11.0
     */
    var FromState = {
        URI: URI$8,
        fromState: fromState
    };
    /**
     * Get the current state
     *
     * @category constructors
     * @since 2.0.0
     */
    var get = 
    /*#__PURE__*/
    get$1(FromState);
    /**
     * Set the state
     *
     * @category constructors
     * @since 2.0.0
     */
    var put = 
    /*#__PURE__*/
    put$1(FromState);
    /**
     * Modify the state by applying a function to the current state
     *
     * @category constructors
     * @since 2.0.0
     */
    var modify = 
    /*#__PURE__*/
    modify$1(FromState);
    /**
     * Get a value which depends on the current state
     *
     * @category constructors
     * @since 2.0.0
     */
    var gets = 
    /*#__PURE__*/
    gets$1(FromState);
    /**
     * @category combinators
     * @since 2.11.0
     */
    var fromStateK = 
    /*#__PURE__*/
    fromStateK$1(FromState);
    /**
     * @category combinators
     * @since 2.11.0
     */
    var chainStateK = 
    /*#__PURE__*/
    chainStateK$1(FromState, Chain$4);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Monad$2 = {
        URI: URI$8,
        map: _map$8,
        ap: _ap$2,
        of: of$5,
        chain: _chain$2
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var MonadIO$1 = {
        URI: URI$8,
        map: _map$8,
        ap: _ap$2,
        of: of$5,
        chain: _chain$2,
        fromIO: fromIO$2
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var MonadTask$1 = {
        URI: URI$8,
        map: _map$8,
        ap: _ap$2,
        of: of$5,
        chain: _chain$2,
        fromIO: fromIO$2,
        fromTask: fromTask$2
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var MonadThrow = {
        URI: URI$8,
        map: _map$8,
        ap: _ap$2,
        of: of$5,
        chain: _chain$2,
        throwError: throwError
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var chainFirst$3 = 
    /*#__PURE__*/
    chainFirst$k(Chain$4);
    /**
     * Less strict version of [`chainFirst`](#chainfirst).
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.8.0
     */
    var chainFirstW = chainFirst$3;
    /**
     * @category instances
     * @since 2.7.0
     */
    var Bifunctor$3 = {
        URI: URI$8,
        bimap: _bimap$3,
        mapLeft: _mapLeft$3
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Alt$1 = {
        URI: URI$8,
        map: _map$8,
        alt: _alt$1
    };
    /**
     * @category instances
     * @since 2.11.0
     */
    var FromReader = {
        URI: URI$8,
        fromReader: fromReader
    };
    /**
     * Reads the current context.
     *
     * @category constructors
     * @since 2.11.0
     */
    var ask = 
    /*#__PURE__*/
    ask$4(FromReader);
    /**
     * Projects a value from the global context in a `ReaderEither`.
     *
     * @category constructors
     * @since 2.11.0
     */
    var asks = 
    /*#__PURE__*/
    asks$4(FromReader);
    /**
     * @category combinators
     * @since 2.11.0
     */
    var fromReaderK = 
    /*#__PURE__*/
    fromReaderK$4(FromReader);
    /**
     * @category combinators
     * @since 2.11.0
     */
    var chainReaderK = 
    /*#__PURE__*/
    chainReaderK$4(FromReader, Chain$4);
    /**
     * Less strict version of [`chainReaderK`](#chainReaderK).
     *
     * @category combinators
     * @since 2.11.0
     */
    var chainReaderKW = chainReaderK;
    /**
     * @category combinators
     * @since 2.11.0
     */
    var chainFirstReaderK = 
    /*#__PURE__*/
    chainFirstReaderK$4(FromReader, Chain$4);
    /**
     * Less strict version of [`chainFirstReaderK`](#chainFirstReaderK).
     *
     * @category combinators
     * @since 2.11.0
     */
    var chainFirstReaderKW = chainFirstReaderK;
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromEither$4 = {
        URI: URI$8,
        fromEither: fromEither$2
    };
    /**
     * @category natural transformations
     * @since 2.0.0
     */
    var fromOption$4 = 
    /*#__PURE__*/
    fromOption$c(FromEither$4);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromOptionK$4 = 
    /*#__PURE__*/
    fromOptionK$e(FromEither$4);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainOptionK$2 = 
    /*#__PURE__*/
    chainOptionK$9(FromEither$4, Chain$4);
    /**
     * @category combinators
     * @since 2.4.0
     */
    var chainEitherK$1 = 
    /*#__PURE__*/
    chainEitherK$7(FromEither$4, Chain$4);
    /**
     * Less strict version of [`chainEitherK`](#chaineitherk).
     *
     * @category combinators
     * @since 2.6.1
     */
    var chainEitherKW = chainEitherK$1;
    /**
     * @category constructors
     * @since 2.4.4
     */
    var fromPredicate$3 = 
    /*#__PURE__*/
    fromPredicate$d(FromEither$4);
    /**
     * @category combinators
     * @since 2.4.4
     */
    var filterOrElse$1 = 
    /*#__PURE__*/
    filterOrElse$7(FromEither$4, Chain$4);
    /**
     * Less strict version of [`filterOrElse`](#filterorelse).
     *
     * @category combinators
     * @since 2.9.0
     */
    var filterOrElseW = filterOrElse$1;
    /**
     * @category combinators
     * @since 2.4.0
     */
    var fromEitherK$1 = 
    /*#__PURE__*/
    fromEitherK$a(FromEither$4);
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromIO$2 = {
        URI: URI$8,
        fromIO: fromIO$2
    };
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromIOK$2 = 
    /*#__PURE__*/
    fromIOK$8(FromIO$2);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainIOK$1 = 
    /*#__PURE__*/
    chainIOK$7(FromIO$2, Chain$4);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainFirstIOK$1 = 
    /*#__PURE__*/
    chainFirstIOK$7(FromIO$2, Chain$4);
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromTask$2 = {
        URI: URI$8,
        fromIO: fromIO$2,
        fromTask: fromTask$2
    };
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromTaskK$2 = 
    /*#__PURE__*/
    fromTaskK$6(FromTask$2);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainTaskK$1 = 
    /*#__PURE__*/
    chainTaskK$5(FromTask$2, Chain$4);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainFirstTaskK$1 = 
    /*#__PURE__*/
    chainFirstTaskK$5(FromTask$2, Chain$4);
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * Run a computation in the `StateReaderTaskEither` monad, discarding the final state
     *
     * @since 2.8.0
     */
    var evaluate$1 = 
    /*#__PURE__*/
    evaluate$2(Functor$d);
    /**
     * Run a computation in the `StateReaderTaskEither` monad discarding the result
     *
     * @since 2.8.0
     */
    var execute$1 = 
    /*#__PURE__*/
    execute$2(Functor$d);
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var bindTo$3 = 
    /*#__PURE__*/
    bindTo$k(Functor$9);
    /**
     * @since 2.8.0
     */
    var bind$5 = 
    /*#__PURE__*/
    bind$m(Chain$4);
    /**
     * @since 2.8.0
     */
    var bindW = bind$5;
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var apS$3 = 
    /*#__PURE__*/
    apS$k(Apply$2);
    /**
     * @since 2.8.0
     */
    var apSW = apS$3;
    // -------------------------------------------------------------------------------------
    // array utils
    // -------------------------------------------------------------------------------------
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndex$3 = function (f) { return function (as) { return function (s) { return function (r) { return function () {
        return tail$5(as).reduce(function (acc, a, i) {
            return acc.then(function (ebs) {
                return isLeft$3(ebs)
                    ? acc
                    : f(i + 1, a)(ebs.right[1])(r)().then(function (eb) {
                        if (isLeft$3(eb)) {
                            return eb;
                        }
                        var _a = eb.right, b = _a[0], s = _a[1];
                        ebs.right[0].push(b);
                        ebs.right[1] = s;
                        return ebs;
                    });
            });
        }, f(0, head$5(as))(s)(r)().then(map$w(function (_a) {
            var b = _a[0], s = _a[1];
            return [[b], s];
        })));
    }; }; }; }; };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndex$3 = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndex$3(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : of$5(emptyReadonlyArray)); };
    };
    /**
     * @since 2.9.0
     */
    var traverseArrayWithIndex$1 = traverseReadonlyArrayWithIndex$3;
    /**
     * @since 2.9.0
     */
    var traverseArray$1 = function (f) {
        return traverseReadonlyArrayWithIndex$3(function (_, a) { return f(a); });
    };
    /**
     * @since 2.9.0
     */
    var sequenceArray$1 = 
    /*#__PURE__*/
    traverseArray$1(identity$1);
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var stateReaderTaskEither = {
        URI: URI$8,
        map: _map$8,
        of: of$5,
        ap: _ap$2,
        chain: _chain$2,
        bimap: _bimap$3,
        mapLeft: _mapLeft$3,
        alt: _alt$1,
        fromIO: fromIO$2,
        fromTask: fromTask$2,
        throwError: throwError
    };
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var stateReaderTaskEitherSeq = {
        URI: URI$8,
        map: _map$8,
        of: of$5,
        ap: _ap$2,
        chain: _chain$2,
        bimap: _bimap$3,
        mapLeft: _mapLeft$3,
        alt: _alt$1,
        fromIO: fromIO$2,
        fromTask: fromTask$2,
        throwError: throwError
    };
    /**
     * Use [`evaluate`](#evaluate) instead
     *
     * @since 2.0.0
     * @deprecated
     */
    /* istanbul ignore next */
    var evalState = function (fsa, s) {
        return pipe$1(fsa(s), map$h(function (_a) {
            var a = _a[0];
            return a;
        }));
    };
    /**
     * Use [`execute`](#execute) instead
     *
     * @since 2.0.0
     * @deprecated
     */
    /* istanbul ignore next */
    var execState = function (fsa, s) {
        return pipe$1(fsa(s), map$h(function (_a) {
            _a[0]; var s = _a[1];
            return s;
        }));
    };
    /**
     * @since 2.0.0
     * @deprecated
     */
    /* istanbul ignore next */
    function run(ma, s, r) {
        return ma(s)(r)();
    }

    var StateReaderTaskEither = /*#__PURE__*/Object.freeze({
        __proto__: null,
        left: left$4,
        right: right$4,
        rightTask: rightTask$1,
        leftTask: leftTask$1,
        rightReader: rightReader,
        leftReader: leftReader,
        rightIO: rightIO$1,
        leftIO: leftIO$1,
        rightState: rightState,
        leftState: leftState,
        fromEither: fromEither$2,
        fromReader: fromReader,
        fromIO: fromIO$2,
        fromTask: fromTask$2,
        fromState: fromState,
        fromTaskEither: fromTaskEither$1,
        fromIOEither: fromIOEither$1,
        fromReaderEither: fromReaderEither,
        fromReaderTaskEither: fromReaderTaskEither,
        local: local,
        asksStateReaderTaskEitherW: asksStateReaderTaskEitherW,
        asksStateReaderTaskEither: asksStateReaderTaskEither,
        fromIOEitherK: fromIOEitherK,
        chainIOEitherKW: chainIOEitherKW,
        chainIOEitherK: chainIOEitherK,
        fromTaskEitherK: fromTaskEitherK,
        chainTaskEitherKW: chainTaskEitherKW,
        chainTaskEitherK: chainTaskEitherK,
        fromReaderTaskEitherK: fromReaderTaskEitherK,
        chainReaderTaskEitherKW: chainReaderTaskEitherKW,
        chainReaderTaskEitherK: chainReaderTaskEitherK,
        map: map$a,
        bimap: bimap$4,
        mapLeft: mapLeft$4,
        ap: ap$4,
        apW: apW,
        of: of$5,
        chain: chain$3,
        chainW: chainW,
        flattenW: flattenW,
        flatten: flatten$2,
        altW: altW$1,
        alt: alt$1,
        throwError: throwError,
        URI: URI$8,
        Functor: Functor$9,
        flap: flap$9,
        Pointed: Pointed$4,
        Apply: Apply$2,
        apFirst: apFirst$3,
        apSecond: apSecond$3,
        Applicative: Applicative$2,
        Chain: Chain$4,
        FromState: FromState,
        get: get,
        put: put,
        modify: modify,
        gets: gets,
        fromStateK: fromStateK,
        chainStateK: chainStateK,
        Monad: Monad$2,
        MonadIO: MonadIO$1,
        MonadTask: MonadTask$1,
        MonadThrow: MonadThrow,
        chainFirst: chainFirst$3,
        chainFirstW: chainFirstW,
        Bifunctor: Bifunctor$3,
        Alt: Alt$1,
        FromReader: FromReader,
        ask: ask,
        asks: asks,
        fromReaderK: fromReaderK,
        chainReaderK: chainReaderK,
        chainReaderKW: chainReaderKW,
        chainFirstReaderK: chainFirstReaderK,
        chainFirstReaderKW: chainFirstReaderKW,
        FromEither: FromEither$4,
        fromOption: fromOption$4,
        fromOptionK: fromOptionK$4,
        chainOptionK: chainOptionK$2,
        chainEitherK: chainEitherK$1,
        chainEitherKW: chainEitherKW,
        fromPredicate: fromPredicate$3,
        filterOrElse: filterOrElse$1,
        filterOrElseW: filterOrElseW,
        fromEitherK: fromEitherK$1,
        FromIO: FromIO$2,
        fromIOK: fromIOK$2,
        chainIOK: chainIOK$1,
        chainFirstIOK: chainFirstIOK$1,
        FromTask: FromTask$2,
        fromTaskK: fromTaskK$2,
        chainTaskK: chainTaskK$1,
        chainFirstTaskK: chainFirstTaskK$1,
        evaluate: evaluate$1,
        execute: execute$1,
        bindTo: bindTo$3,
        bind: bind$5,
        bindW: bindW,
        apS: apS$3,
        apSW: apSW,
        traverseReadonlyNonEmptyArrayWithIndex: traverseReadonlyNonEmptyArrayWithIndex$3,
        traverseReadonlyArrayWithIndex: traverseReadonlyArrayWithIndex$3,
        traverseArrayWithIndex: traverseArrayWithIndex$1,
        traverseArray: traverseArray$1,
        sequenceArray: sequenceArray$1,
        stateReaderTaskEither: stateReaderTaskEither,
        stateReaderTaskEitherSeq: stateReaderTaskEitherSeq,
        evalState: evalState,
        execState: execState,
        run: run
    });

    /**
     * Reposition the focus at the specified position
     *
     * @since 2.0.0
     */
    function seek(s) {
        return function (wa) { return ({ peek: wa.peek, pos: s }); };
    }
    /**
     * Reposition the focus at the specified position, which depends on the current position
     *
     * @since 2.0.0
     */
    function seeks(f) {
        return function (wa) { return ({ peek: wa.peek, pos: f(wa.pos) }); };
    }
    /**
     * Extract a value from a position which depends on the current position
     *
     * @since 2.0.0
     */
    function peeks(f) {
        return function (wa) { return wa.peek(f(wa.pos)); };
    }
    function experiment(F) {
        return function (f) { return function (wa) { return F.map(f(wa.pos), function (s) { return wa.peek(s); }); }; };
    }
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    /* istanbul ignore next */
    var _map$7 = function (fa, f) { return pipe$1(fa, map$9(f)); };
    /* istanbul ignore next */
    var _extend$2 = function (wa, f) { return pipe$1(wa, extend$2(f)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * @category Extend
     * @since 2.0.0
     */
    var extend$2 = function (f) { return function (wa) { return ({
        peek: function (s) { return f({ peek: wa.peek, pos: s }); },
        pos: wa.pos
    }); }; };
    /**
     * @category Extract
     * @since 2.6.2
     */
    var extract$2 = function (wa) { return wa.peek(wa.pos); };
    /**
     * Derivable from `Extend`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var duplicate$2 = 
    /*#__PURE__*/
    extend$2(identity$1);
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$9 = function (f) { return function (fa) { return ({
        peek: function (s) { return f(fa.peek(s)); },
        pos: fa.pos
    }); }; };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$7 = 'Store';
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$8 = {
        URI: URI$7,
        map: _map$7
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$8 = 
    /*#__PURE__*/
    flap$x(Functor$8);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Comonad$2 = {
        URI: URI$7,
        map: _map$7,
        extend: _extend$2,
        extract: extract$2
    };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var store = Comonad$2;

    var Store = /*#__PURE__*/Object.freeze({
        __proto__: null,
        seek: seek,
        seeks: seeks,
        peeks: peeks,
        experiment: experiment,
        extend: extend$2,
        extract: extract$2,
        duplicate: duplicate$2,
        map: map$9,
        URI: URI$7,
        Functor: Functor$8,
        flap: flap$8,
        Comonad: Comonad$2,
        store: store
    });

    function split(S, C) {
        return function (pab, pcd) {
            return C.compose(S.second(pcd), S.first(pab));
        };
    }
    function fanOut(S, C) {
        var splitSC = split(S, C);
        return function (pab, pac) {
            return C.compose(splitSC(pab, pac), S.promap(C.id(), identity$1, function (a) { return [a, a]; }));
        };
    }
    function splitStrong(F) {
        return split(F, F);
    }
    function fanout(F) {
        return fanOut(F, F);
    }

    var Strong = /*#__PURE__*/Object.freeze({
        __proto__: null,
        split: split,
        fanOut: fanOut,
        splitStrong: splitStrong,
        fanout: fanout
    });

    /**
     * @since 2.10.0
     */
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * Return a semigroup which works like `Object.assign`.
     *
     * @example
     * import { getAssignSemigroup } from 'fp-ts/struct'
     *
     * interface Person {
     *   readonly name: string
     *   readonly age: number
     * }
     *
     * const S = getAssignSemigroup<Person>()
     * assert.deepStrictEqual(S.concat({ name: 'name', age: 23 }, { name: 'name', age: 24 }), { name: 'name', age: 24 })
     *
     * @category instances
     * @since 2.10.0
     */
    var getAssignSemigroup = function () { return ({
        concat: function (first, second) { return Object.assign({}, first, second); }
    }); };
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * Creates a new object by recursively evolving a shallow copy of `a`, according to the `transformation` functions.
     *
     * @example
     * import { pipe } from 'fp-ts/function'
     * import { evolve } from 'fp-ts/struct'
     *
     * assert.deepStrictEqual(
     *   pipe(
     *     { a: 'a', b: 1 },
     *     evolve({
     *       a: (a) => a.length,
     *       b: (b) => b * 2
     *     })
     *   ),
     *   { a: 1, b: 2 }
     * )
     *
     * @since 2.11.0
     */
    var evolve = function (transformations) { return function (a) {
        var out = {};
        for (var k in a) {
            if (has$4.call(a, k)) {
                out[k] = transformations[k](a[k]);
            }
        }
        return out;
    }; };

    var struct = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getAssignSemigroup: getAssignSemigroup,
        evolve: evolve
    });

    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * @category constructors
     * @since 2.10.0
     */
    var some$1 = 
    /*#__PURE__*/
    some$6(Pointed$8);
    /**
     * @category constructors
     * @since 2.10.0
     */
    var fromPredicate$2 = 
    /*#__PURE__*/
    fromPredicate$7(Pointed$8);
    // -------------------------------------------------------------------------------------
    // natural transformations
    // -------------------------------------------------------------------------------------
    /**
     * @category natural transformations
     * @since 2.10.0
     */
    var fromOption$3 = of$b;
    /**
     * @category natural transformations
     * @since 2.10.0
     */
    var fromEither$1 = 
    /*#__PURE__*/
    fromEither$6(Pointed$8);
    /**
     * @category natural transformations
     * @since 2.10.0
     */
    var fromIO$1 = function (ma) { return fromTask$1(fromIO$6(ma)); };
    /**
     * @category natural transformations
     * @since 2.10.0
     */
    var fromTask$1 = 
    /*#__PURE__*/
    fromF$1(Functor$g);
    /**
     * @category natural transformations
     * @since 2.11.0
     */
    var fromTaskEither = 
    /*#__PURE__*/
    map$k(fromEither$8);
    // -------------------------------------------------------------------------------------
    // destructors
    // -------------------------------------------------------------------------------------
    /**
     * @category destructors
     * @since 2.10.0
     */
    var match$3 = 
    /*#__PURE__*/
    match$8(Functor$g);
    /**
     * Less strict version of [`match`](#match).
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchW$2 = match$3;
    /**
     * @category destructors
     * @since 2.10.0
     */
    var matchE$2 = 
    /*#__PURE__*/
    matchE$6(Chain$8);
    /**
     * Alias of [`matchE`](#matche).
     *
     * @category destructors
     * @since 2.10.0
     */
    var fold$3 = matchE$2;
    /**
     * Less strict version of [`matchE`](#matche).
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchEW$1 = matchE$2;
    /**
     * Alias of [`matchEW`](#matchew).
     *
     * @category destructors
     * @since 2.10.0
     */
    var foldW$2 = matchEW$1;
    /**
     * @category destructors
     * @since 2.10.0
     */
    var getOrElse = 
    /*#__PURE__*/
    getOrElse$4(Monad$6);
    /**
     * Less strict version of [`getOrElse`](#getorelse).
     *
     * @category destructors
     * @since 2.10.0
     */
    var getOrElseW = getOrElse;
    // -------------------------------------------------------------------------------------
    // interop
    // -------------------------------------------------------------------------------------
    /**
     * @category interop
     * @since 2.10.0
     */
    var fromNullable = 
    /*#__PURE__*/
    fromNullable$1(Pointed$8);
    /**
     * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Option` instead.
     *
     * Note: `f` should never `throw` errors, they are not caught.
     *
     * See also [`tryCatchK`](#trycatchk).
     *
     * @category interop
     * @since 2.10.0
     */
    var tryCatch = function (f) { return function () {
        return f().then(function (a) { return some$7(a); }, function () { return none$1; });
    }; };
    /**
     * Converts a function returning a `Promise` to one returning a `TaskOption`.
     *
     * @category interop
     * @since 2.10.0
     */
    var tryCatchK = function (f) { return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return tryCatch(function () { return f.apply(void 0, a); });
    }; };
    /**
     * @category interop
     * @since 2.10.0
     */
    var fromNullableK = 
    /*#__PURE__*/
    fromNullableK$1(Pointed$8);
    /**
     * @category interop
     * @since 2.10.0
     */
    var chainNullableK = 
    /*#__PURE__*/
    chainNullableK$1(Monad$6);
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromOptionK$3 = 
    /*#__PURE__*/
    fromOptionK$9(Pointed$8);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainOptionK$1 = 
    /*#__PURE__*/
    chainOptionK$6(Monad$6);
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.10.0
     */
    var map$8 = 
    /*#__PURE__*/
    map$n(Functor$g);
    /**
     * @category Apply
     * @since 2.10.0
     */
    var ap$3 = 
    /*#__PURE__*/
    ap$c(ApplyPar$4);
    /**
     * @category Pointed
     * @since 2.10.0
     */
    var of$4 = some$1;
    /**
     * @category Monad
     * @since 2.10.0
     */
    var chain$2 = 
    /*#__PURE__*/
    chain$d(Monad$6);
    /**
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flatten$1 = 
    /*#__PURE__*/
    chain$2(identity$1);
    /**
     * @category Alt
     * @since 2.10.0
     */
    var alt = 
    /*#__PURE__*/
    alt$5(Monad$6);
    /**
     * Less strict version of [`alt`](#alt).
     *
     * @category Alt
     * @since 2.10.0
     */
    var altW = alt;
    /**
     * @category Zero
     * @since 2.10.0
     */
    var zero = 
    /*#__PURE__*/
    zero$2(Pointed$8);
    /**
     * @category constructors
     * @since 2.10.0
     */
    var none = 
    /*#__PURE__*/
    zero();
    /**
     * @category Compactable
     * @since 2.10.0
     */
    var compact = 
    /*#__PURE__*/
    compact$7(Functor$g, Compactable$6);
    /**
     * @category Compactable
     * @since 2.10.0
     */
    var separate = 
    /*#__PURE__*/
    separate$7(Functor$g, Compactable$6, Functor$r);
    /**
     * @category Filterable
     * @since 2.10.0
     */
    var filter = 
    /*#__PURE__*/
    filter$7(Functor$g, Filterable$6);
    /**
     * @category Filterable
     * @since 2.10.0
     */
    var filterMap = 
    /*#__PURE__*/
    filterMap$7(Functor$g, Filterable$6);
    /**
     * @category Filterable
     * @since 2.10.0
     */
    var partition = 
    /*#__PURE__*/
    partition$7(Functor$g, Filterable$6);
    /**
     * @category Filterable
     * @since 2.10.0
     */
    var partitionMap = 
    /*#__PURE__*/
    partitionMap$7(Functor$g, Filterable$6);
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    var _map$6 = function (fa, f) { return pipe$1(fa, map$8(f)); };
    var _ap$1 = function (fab, fa) { return pipe$1(fab, ap$3(fa)); };
    /* istanbul ignore next */
    var _chain$1 = function (ma, f) { return pipe$1(ma, chain$2(f)); };
    /* istanbul ignore next */
    var _alt = function (fa, that) { return pipe$1(fa, alt(that)); };
    /* istanbul ignore next */
    var _filter = function (fa, predicate) {
        return pipe$1(fa, filter(predicate));
    };
    /* istanbul ignore next */
    var _filterMap = function (fa, f) { return pipe$1(fa, filterMap(f)); };
    /* istanbul ignore next */
    var _partition = function (fa, predicate) {
        return pipe$1(fa, partition(predicate));
    };
    /* istanbul ignore next */
    var _partitionMap = function (fa, f) { return pipe$1(fa, partitionMap(f)); };
    /**
     * @category instances
     * @since 2.10.0
     */
    var URI$6 = 'TaskOption';
    /**
     * @category instances
     * @since 2.10.0
     */
    var Functor$7 = {
        URI: URI$6,
        map: _map$6
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$7 = 
    /*#__PURE__*/
    flap$x(Functor$7);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$3 = {
        URI: URI$6,
        of: of$4
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var ApplyPar = {
        URI: URI$6,
        map: _map$6,
        ap: _ap$1
    };
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var apFirst$2 = 
    /*#__PURE__*/
    apFirst$k(ApplyPar);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var apSecond$2 = 
    /*#__PURE__*/
    apSecond$k(ApplyPar);
    /**
     * @category instances
     * @since 2.10.0
     */
    var ApplicativePar = {
        URI: URI$6,
        map: _map$6,
        ap: _ap$1,
        of: of$4
    };
    var _apSeq = function (fab, fa) {
        return pipe$1(fab, chain$2(function (f) { return pipe$1(fa, map$8(f)); }));
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var ApplySeq = {
        URI: URI$6,
        map: _map$6,
        ap: _apSeq
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var ApplicativeSeq = {
        URI: URI$6,
        map: _map$6,
        ap: _apSeq,
        of: of$4
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$3 = {
        URI: URI$6,
        map: _map$6,
        ap: _ap$1,
        chain: _chain$1
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var chainFirst$2 = 
    /*#__PURE__*/
    chainFirst$k(Chain$3);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Alt = {
        URI: URI$6,
        map: _map$6,
        alt: _alt
    };
    /**
     * @category instances
     * @since 2.11.0
     */
    var Zero$1 = {
        URI: URI$6,
        zero: zero
    };
    /**
     * @category constructors
     * @since 2.11.0
     */
    var guard$1 = 
    /*#__PURE__*/
    guard$5(Zero$1, Pointed$3);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Alternative = {
        URI: URI$6,
        map: _map$6,
        ap: _ap$1,
        of: of$4,
        alt: _alt,
        zero: zero
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Monad$1 = {
        URI: URI$6,
        map: _map$6,
        ap: _ap$1,
        of: of$4,
        chain: _chain$1
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var MonadIO = {
        URI: URI$6,
        map: _map$6,
        ap: _ap$1,
        of: of$4,
        chain: _chain$1,
        fromIO: fromIO$1
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var MonadTask = {
        URI: URI$6,
        map: _map$6,
        ap: _ap$1,
        of: of$4,
        chain: _chain$1,
        fromIO: fromIO$1,
        fromTask: fromTask$1
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Compactable = {
        URI: URI$6,
        compact: compact,
        separate: separate
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Filterable = {
        URI: URI$6,
        map: _map$6,
        compact: compact,
        separate: separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromIO$1 = {
        URI: URI$6,
        fromIO: fromIO$1
    };
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromIOK$1 = 
    /*#__PURE__*/
    fromIOK$8(FromIO$1);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainIOK = 
    /*#__PURE__*/
    chainIOK$7(FromIO$1, Chain$3);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainFirstIOK = 
    /*#__PURE__*/
    chainFirstIOK$7(FromIO$1, Chain$3);
    /**
     * @category instances
     * @since 2.11.0
     */
    var FromEither$3 = {
        URI: URI$6,
        fromEither: fromEither$1
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromTask$1 = {
        URI: URI$6,
        fromIO: fromIO$1,
        fromTask: fromTask$1
    };
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromTaskK$1 = 
    /*#__PURE__*/
    fromTaskK$6(FromTask$1);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainTaskK = 
    /*#__PURE__*/
    chainTaskK$5(FromTask$1, Chain$3);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var chainFirstTaskK = 
    /*#__PURE__*/
    chainFirstTaskK$5(FromTask$1, Chain$3);
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.10.0
     */
    var Do$1 = 
    /*#__PURE__*/
    of$4(emptyRecord);
    /**
     * @since 2.10.0
     */
    var bindTo$2 = 
    /*#__PURE__*/
    bindTo$k(Functor$7);
    /**
     * @since 2.10.0
     */
    var bind$4 = 
    /*#__PURE__*/
    bind$m(Chain$3);
    // -------------------------------------------------------------------------------------
    // sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.10.0
     */
    var apS$2 = 
    /*#__PURE__*/
    apS$k(ApplyPar);
    // -------------------------------------------------------------------------------------
    // sequence T
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var ApT$2 = 
    /*#__PURE__*/
    of$4(emptyReadonlyArray);
    // -------------------------------------------------------------------------------------
    // array utils
    // -------------------------------------------------------------------------------------
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndex$2 = function (f) {
        return flow(traverseReadonlyNonEmptyArrayWithIndex$7(f), map$k(traverseReadonlyNonEmptyArrayWithIndex$e(SK)));
    };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndex$2 = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndex$2(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT$2); };
    };
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativeSeq)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndexSeq$1 = function (f) { return function (as) { return function () {
        return tail$5(as).reduce(function (acc, a, i) {
            return acc.then(function (obs) {
                return isNone$2(obs)
                    ? acc
                    : f(i + 1, a)().then(function (ob) {
                        if (isNone$2(ob)) {
                            return ob;
                        }
                        obs.value.push(ob.value);
                        return obs;
                    });
            });
        }, f(0, head$5(as))().then(map$y(singleton$7)));
    }; }; };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndexSeq$1 = function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndexSeq$1(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT$2); };
    };
    /**
     * @since 2.10.0
     */
    var traverseArrayWithIndex = traverseReadonlyArrayWithIndex$2;
    /**
     * @since 2.10.0
     */
    var traverseArray = function (f) { return traverseReadonlyArrayWithIndex$2(function (_, a) { return f(a); }); };
    /**
     * @since 2.10.0
     */
    var sequenceArray = 
    /*#__PURE__*/
    traverseArray(identity$1);
    /**
     * @since 2.10.0
     */
    var traverseSeqArrayWithIndex = traverseReadonlyArrayWithIndexSeq$1;
    /**
     * @since 2.10.0
     */
    var traverseSeqArray = function (f) { return traverseReadonlyArrayWithIndexSeq$1(function (_, a) { return f(a); }); };
    /**
     * @since 2.10.0
     */
    var sequenceSeqArray = 
    /*#__PURE__*/
    traverseSeqArray(identity$1);
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation

    var TaskOption = /*#__PURE__*/Object.freeze({
        __proto__: null,
        some: some$1,
        fromPredicate: fromPredicate$2,
        fromOption: fromOption$3,
        fromEither: fromEither$1,
        fromIO: fromIO$1,
        fromTask: fromTask$1,
        fromTaskEither: fromTaskEither,
        match: match$3,
        matchW: matchW$2,
        matchE: matchE$2,
        fold: fold$3,
        matchEW: matchEW$1,
        foldW: foldW$2,
        getOrElse: getOrElse,
        getOrElseW: getOrElseW,
        fromNullable: fromNullable,
        tryCatch: tryCatch,
        tryCatchK: tryCatchK,
        fromNullableK: fromNullableK,
        chainNullableK: chainNullableK,
        fromOptionK: fromOptionK$3,
        chainOptionK: chainOptionK$1,
        map: map$8,
        ap: ap$3,
        of: of$4,
        chain: chain$2,
        flatten: flatten$1,
        alt: alt,
        altW: altW,
        zero: zero,
        none: none,
        compact: compact,
        separate: separate,
        filter: filter,
        filterMap: filterMap,
        partition: partition,
        partitionMap: partitionMap,
        Functor: Functor$7,
        flap: flap$7,
        Pointed: Pointed$3,
        ApplyPar: ApplyPar,
        apFirst: apFirst$2,
        apSecond: apSecond$2,
        ApplicativePar: ApplicativePar,
        ApplySeq: ApplySeq,
        ApplicativeSeq: ApplicativeSeq,
        Chain: Chain$3,
        chainFirst: chainFirst$2,
        Alt: Alt,
        Zero: Zero$1,
        guard: guard$1,
        Alternative: Alternative,
        Monad: Monad$1,
        MonadIO: MonadIO,
        MonadTask: MonadTask,
        Compactable: Compactable,
        Filterable: Filterable,
        FromIO: FromIO$1,
        fromIOK: fromIOK$1,
        chainIOK: chainIOK,
        chainFirstIOK: chainFirstIOK,
        FromEither: FromEither$3,
        FromTask: FromTask$1,
        fromTaskK: fromTaskK$1,
        chainTaskK: chainTaskK,
        chainFirstTaskK: chainFirstTaskK,
        Do: Do$1,
        bindTo: bindTo$2,
        bind: bind$4,
        apS: apS$2,
        ApT: ApT$2,
        traverseReadonlyNonEmptyArrayWithIndex: traverseReadonlyNonEmptyArrayWithIndex$2,
        traverseReadonlyArrayWithIndex: traverseReadonlyArrayWithIndex$2,
        traverseReadonlyNonEmptyArrayWithIndexSeq: traverseReadonlyNonEmptyArrayWithIndexSeq$1,
        traverseReadonlyArrayWithIndexSeq: traverseReadonlyArrayWithIndexSeq$1,
        traverseArrayWithIndex: traverseArrayWithIndex,
        traverseArray: traverseArray,
        sequenceArray: sequenceArray,
        traverseSeqArrayWithIndex: traverseSeqArrayWithIndex,
        traverseSeqArray: traverseSeqArray,
        sequenceSeqArray: sequenceSeqArray
    });

    // -------------------------------------------------------------------------------------
    // refinements
    // -------------------------------------------------------------------------------------
    /**
     * Returns `true` if the these is an instance of `Left`, `false` otherwise
     *
     * @category refinements
     * @since 2.0.0
     */
    var isLeft$1 = function (fa) { return fa._tag === 'Left'; };
    /**
     * Returns `true` if the these is an instance of `Right`, `false` otherwise
     *
     * @category refinements
     * @since 2.0.0
     */
    var isRight$1 = function (fa) { return fa._tag === 'Right'; };
    /**
     * Returns `true` if the these is an instance of `Both`, `false` otherwise
     *
     * @category refinements
     * @since 2.0.0
     */
    function isBoth(fa) {
        return fa._tag === 'Both';
    }
    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * @category constructors
     * @since 2.0.0
     */
    function left$3(left) {
        return { _tag: 'Left', left: left };
    }
    /**
     * @category constructors
     * @since 2.0.0
     */
    function right$3(right) {
        return { _tag: 'Right', right: right };
    }
    /**
     * @category constructors
     * @since 2.0.0
     */
    function both$2(left, right) {
        return { _tag: 'Both', left: left, right: right };
    }
    /**
     * Less strict version of [`match`](#match).
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchW$1 = function (onLeft, onRight, onBoth) { return function (fa) {
        switch (fa._tag) {
            case 'Left':
                return onLeft(fa.left);
            case 'Right':
                return onRight(fa.right);
            case 'Both':
                return onBoth(fa.left, fa.right);
        }
    }; };
    /**
     * Alias of [`matchW`](#matchw).
     *
     * @category destructors
     * @since 2.10.0
     */
    var foldW$1 = matchW$1;
    /**
     * @category destructors
     * @since 2.10.0
     */
    var match$2 = matchW$1;
    /**
     * Alias of [`match`](#match).
     *
     * @category destructors
     * @since 2.0.0
     */
    var fold$2 = match$2;
    /**
     * @category combinators
     * @since 2.4.0
     */
    var swap$3 = match$2(right$3, left$3, function (e, a) { return both$2(a, e); });
    /**
     * @category instances
     * @since 2.0.0
     */
    function getShow$1(SE, SA) {
        return {
            show: match$2(function (l) { return "left(" + SE.show(l) + ")"; }, function (a) { return "right(" + SA.show(a) + ")"; }, function (l, a) { return "both(" + SE.show(l) + ", " + SA.show(a) + ")"; })
        };
    }
    /**
     * @category instances
     * @since 2.0.0
     */
    function getEq$1(EE, EA) {
        return fromEquals(function (x, y) {
            return isLeft$1(x)
                ? isLeft$1(y) && EE.equals(x.left, y.left)
                : isRight$1(x)
                    ? isRight$1(y) && EA.equals(x.right, y.right)
                    : isBoth(y) && EE.equals(x.left, y.left) && EA.equals(x.right, y.right);
        });
    }
    /**
     * @category instances
     * @since 2.0.0
     */
    function getSemigroup$1(SE, SA) {
        return {
            concat: function (x, y) {
                return isLeft$1(x)
                    ? isLeft$1(y)
                        ? left$3(SE.concat(x.left, y.left))
                        : isRight$1(y)
                            ? both$2(x.left, y.right)
                            : both$2(SE.concat(x.left, y.left), y.right)
                    : isRight$1(x)
                        ? isLeft$1(y)
                            ? both$2(y.left, x.right)
                            : isRight$1(y)
                                ? right$3(SA.concat(x.right, y.right))
                                : both$2(y.left, SA.concat(x.right, y.right))
                        : isLeft$1(y)
                            ? both$2(SE.concat(x.left, y.left), x.right)
                            : isRight$1(y)
                                ? both$2(x.left, SA.concat(x.right, y.right))
                                : both$2(SE.concat(x.left, y.left), SA.concat(x.right, y.right));
            }
        };
    }
    /**
     * @category instances
     * @since 2.10.0
     */
    var getApply$3 = function (S) { return ({
        URI: URI$5,
        _E: undefined,
        map: _map$5,
        ap: function (fab, fa) {
            return isLeft$1(fab)
                ? isLeft$1(fa)
                    ? left$3(S.concat(fab.left, fa.left))
                    : isRight$1(fa)
                        ? left$3(fab.left)
                        : left$3(S.concat(fab.left, fa.left))
                : isRight$1(fab)
                    ? isLeft$1(fa)
                        ? left$3(fa.left)
                        : isRight$1(fa)
                            ? right$3(fab.right(fa.right))
                            : both$2(fa.left, fab.right(fa.right))
                    : isLeft$1(fa)
                        ? left$3(S.concat(fab.left, fa.left))
                        : isRight$1(fa)
                            ? both$2(fab.left, fab.right(fa.right))
                            : both$2(S.concat(fab.left, fa.left), fab.right(fa.right));
        }
    }); };
    /**
     * @category instances
     * @since 2.7.0
     */
    function getApplicative$3(S) {
        var A = getApply$3(S);
        return {
            URI: URI$5,
            _E: undefined,
            map: _map$5,
            ap: A.ap,
            of: of$3
        };
    }
    /**
     * @category instances
     * @since 2.10.0
     */
    function getChain$3(S) {
        var A = getApply$3(S);
        var chain = function (ma, f) {
            if (isLeft$1(ma)) {
                return ma;
            }
            if (isRight$1(ma)) {
                return f(ma.right);
            }
            var fb = f(ma.right);
            return isLeft$1(fb)
                ? left$3(S.concat(ma.left, fb.left))
                : isRight$1(fb)
                    ? both$2(ma.left, fb.right)
                    : both$2(S.concat(ma.left, fb.left), fb.right);
        };
        return {
            URI: URI$5,
            _E: undefined,
            map: _map$5,
            ap: A.ap,
            chain: chain
        };
    }
    /**
     * @category instances
     * @since 2.0.0
     */
    function getMonad$3(S) {
        var C = getChain$3(S);
        return {
            URI: URI$5,
            _E: undefined,
            map: _map$5,
            of: of$3,
            ap: C.ap,
            chain: C.chain,
            throwError: left$3
        };
    }
    /**
     * Returns an `E` value if possible
     *
     * @example
     * import { getLeft, left, right, both } from 'fp-ts/These'
     * import { none, some } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(getLeft(left('a')), some('a'))
     * assert.deepStrictEqual(getLeft(right(1)), none)
     * assert.deepStrictEqual(getLeft(both('a', 1)), some('a'))
     *
     * @category destructors
     * @since 2.0.0
     */
    function getLeft(fa) {
        return isLeft$1(fa) ? some$a(fa.left) : isRight$1(fa) ? none$2 : some$a(fa.left);
    }
    /**
     * Returns an `A` value if possible
     *
     * @example
     * import { getRight, left, right, both } from 'fp-ts/These'
     * import { none, some } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(getRight(left('a')), none)
     * assert.deepStrictEqual(getRight(right(1)), some(1))
     * assert.deepStrictEqual(getRight(both('a', 1)), some(1))
     *
     * @category destructors
     * @since 2.0.0
     */
    function getRight(fa) {
        return isLeft$1(fa) ? none$2 : isRight$1(fa) ? some$a(fa.right) : some$a(fa.right);
    }
    // TODO: make lazy in v3
    /**
     * @example
     * import { leftOrBoth, left, both } from 'fp-ts/These'
     * import { none, some } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(leftOrBoth('a')(none), left('a'))
     * assert.deepStrictEqual(leftOrBoth('a')(some(1)), both('a', 1))
     *
     * @category constructors
     * @since 2.0.0
     */
    function leftOrBoth(e) {
        return function (ma) { return (isNone$2(ma) ? left$3(e) : both$2(e, ma.value)); };
    }
    // TODO: make lazy in v3
    /**
     * @example
     * import { rightOrBoth, right, both } from 'fp-ts/These'
     * import { none, some } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(rightOrBoth(1)(none), right(1))
     * assert.deepStrictEqual(rightOrBoth(1)(some('a')), both('a', 1))
     *
     * @category constructors
     * @since 2.0.0
     */
    function rightOrBoth(a) {
        return function (me) { return (isNone$2(me) ? right$3(a) : both$2(me.value, a)); };
    }
    /**
     * Returns the `E` value if and only if the value is constructed with `Left`
     *
     * @example
     * import { getLeftOnly, left, right, both } from 'fp-ts/These'
     * import { none, some } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(getLeftOnly(left('a')), some('a'))
     * assert.deepStrictEqual(getLeftOnly(right(1)), none)
     * assert.deepStrictEqual(getLeftOnly(both('a', 1)), none)
     *
     * @category destructors
     * @since 2.0.0
     */
    function getLeftOnly(fa) {
        return isLeft$1(fa) ? some$a(fa.left) : none$2;
    }
    /**
     * Returns the `A` value if and only if the value is constructed with `Right`
     *
     * @example
     * import { getRightOnly, left, right, both } from 'fp-ts/These'
     * import { none, some } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(getRightOnly(left('a')), none)
     * assert.deepStrictEqual(getRightOnly(right(1)), some(1))
     * assert.deepStrictEqual(getRightOnly(both('a', 1)), none)
     *
     * @category destructors
     * @since 2.0.0
     */
    function getRightOnly(fa) {
        return isRight$1(fa) ? some$a(fa.right) : none$2;
    }
    /**
     * Takes a pair of `Option`s and attempts to create a `These` from them
     *
     * @example
     * import { fromOptions, left, right, both } from 'fp-ts/These'
     * import { none, some } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(fromOptions(none, none), none)
     * assert.deepStrictEqual(fromOptions(some('a'), none), some(left('a')))
     * assert.deepStrictEqual(fromOptions(none, some(1)), some(right(1)))
     * assert.deepStrictEqual(fromOptions(some('a'), some(1)), some(both('a', 1)))
     *
     * @category constructors
     * @since 2.0.0
     */
    var fromOptions = function (fe, fa) {
        return isNone$2(fe)
            ? isNone$2(fa)
                ? none$2
                : some$a(right$3(fa.value))
            : isNone$2(fa)
                ? some$a(left$3(fe.value))
                : some$a(both$2(fe.value, fa.value));
    };
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _map$5 = function (fa, f) { return pipe$1(fa, map$7(f)); };
    /* istanbul ignore next */
    var _bimap$2 = function (fa, f, g) { return pipe$1(fa, bimap$3(f, g)); };
    /* istanbul ignore next */
    var _mapLeft$2 = function (fa, f) { return pipe$1(fa, mapLeft$3(f)); };
    /* istanbul ignore next */
    var _reduce$2 = function (fa, b, f) { return pipe$1(fa, reduce$2(b, f)); };
    /* istanbul ignore next */
    var _foldMap$2 = function (M) {
        var foldMapM = foldMap$2(M);
        return function (fa, f) { return pipe$1(fa, foldMapM(f)); };
    };
    /* istanbul ignore next */
    var _reduceRight$2 = function (fa, b, f) { return pipe$1(fa, reduceRight$2(b, f)); };
    /* istanbul ignore next */
    var _traverse$2 = function (F) {
        var traverseF = traverse$3(F);
        return function (ta, f) { return pipe$1(ta, traverseF(f)); };
    };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * Map a pair of functions over the two type arguments of the bifunctor.
     *
     * @category Bifunctor
     * @since 2.0.0
     */
    var bimap$3 = function (f, g) { return function (fa) {
        return isLeft$1(fa) ? left$3(f(fa.left)) : isRight$1(fa) ? right$3(g(fa.right)) : both$2(f(fa.left), g(fa.right));
    }; };
    /**
     * Map a function over the first type argument of a bifunctor.
     *
     * @category Bifunctor
     * @since 2.0.0
     */
    var mapLeft$3 = function (f) { return function (fa) {
        return isLeft$1(fa) ? left$3(f(fa.left)) : isBoth(fa) ? both$2(f(fa.left), fa.right) : fa;
    }; };
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$7 = function (f) { return function (fa) {
        return isLeft$1(fa) ? fa : isRight$1(fa) ? right$3(f(fa.right)) : both$2(fa.left, f(fa.right));
    }; };
    /**
     * @category Foldable
     * @since 2.0.0
     */
    var reduce$2 = function (b, f) { return function (fa) {
        return isLeft$1(fa) ? b : f(b, fa.right);
    }; };
    /**
     * @category Foldable
     * @since 2.0.0
     */
    var foldMap$2 = function (M) { return function (f) { return function (fa) {
        return isLeft$1(fa) ? M.empty : f(fa.right);
    }; }; };
    /**
     * @category Foldable
     * @since 2.0.0
     */
    var reduceRight$2 = function (b, f) { return function (fa) {
        return isLeft$1(fa) ? b : f(fa.right, b);
    }; };
    /**
     * @since 2.6.3
     */
    var traverse$3 = function (F) { return function (f) { return function (ta) {
        return isLeft$1(ta) ? F.of(ta) : isRight$1(ta) ? F.map(f(ta.right), right$3) : F.map(f(ta.right), function (b) { return both$2(ta.left, b); });
    }; }; };
    /**
     * @since 2.6.3
     */
    var sequence$3 = function (F) { return function (ta) {
        return isLeft$1(ta) ? F.of(ta) : isRight$1(ta) ? F.map(ta.right, right$3) : F.map(ta.right, function (b) { return both$2(ta.left, b); });
    }; };
    /**
     * @category Pointed
     * @since 2.0.0
     */
    var of$3 = right$3;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$5 = 'These';
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$6 = {
        URI: URI$5,
        map: _map$5
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$6 = 
    /*#__PURE__*/
    flap$x(Functor$6);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$2 = {
        URI: URI$5,
        of: of$3
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Bifunctor$2 = {
        URI: URI$5,
        bimap: _bimap$2,
        mapLeft: _mapLeft$2
    };
    /**
     * @category instances
     * @since 2.11.0
     */
    var FromThese$1 = {
        URI: URI$5,
        fromThese: identity$1
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Foldable$2 = {
        URI: URI$5,
        reduce: _reduce$2,
        foldMap: _foldMap$2,
        reduceRight: _reduceRight$2
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Traversable$3 = {
        URI: URI$5,
        map: _map$5,
        reduce: _reduce$2,
        foldMap: _foldMap$2,
        reduceRight: _reduceRight$2,
        traverse: _traverse$2,
        sequence: sequence$3
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromEither$2 = {
        URI: URI$5,
        fromEither: identity$1
    };
    /**
     * @category natural transformations
     * @since 2.10.0
     */
    var fromOption$2 = 
    /*#__PURE__*/
    fromOption$c(FromEither$2);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromOptionK$2 = 
    /*#__PURE__*/
    fromOptionK$e(FromEither$2);
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var elem$1 = function (E) { return function (a) { return function (ma) {
        return isLeft$1(ma) ? false : E.equals(a, ma.right);
    }; }; };
    /**
     * @since 2.11.0
     */
    var exists$1 = function (predicate) { return function (ma) {
        return isLeft$1(ma) ? false : predicate(ma.right);
    }; };
    /**
     * @example
     * import { toTuple2, left, right, both } from 'fp-ts/These'
     *
     * assert.deepStrictEqual(toTuple2(() => 'a', () => 1)(left('b')), ['b', 1])
     * assert.deepStrictEqual(toTuple2(() => 'a', () => 1)(right(2)), ['a', 2])
     * assert.deepStrictEqual(toTuple2(() => 'a', () => 1)(both('b', 2)), ['b', 2])
     *
     * @since 2.10.0
     */
    var toTuple2$2 = function (e, a) { return function (fa) {
        return isLeft$1(fa) ? [fa.left, a()] : isRight$1(fa) ? [e(), fa.right] : [fa.left, fa.right];
    }; };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use [`toTuple2`](#totuple2) instead.
     *
     * @since 2.0.0
     * @deprecated
     */
    var toTuple$1 = function (e, a) {
        return toTuple2$2(function () { return e; }, function () { return a; });
    };
    // -------------------------------------------------------------------------------------
    // sequence T
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var ApT$1 = 
    /*#__PURE__*/
    of$3(emptyReadonlyArray);
    // -------------------------------------------------------------------------------------
    // array utils
    // -------------------------------------------------------------------------------------
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(getApplicative(S))`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndex$1 = function (S) { return function (f) { return function (as) {
        var e = none$2;
        var t = f(0, head$5(as));
        if (isLeft$1(t)) {
            return t;
        }
        if (isBoth(t)) {
            e = some$a(t.left);
        }
        var out = [t.right];
        for (var i = 1; i < as.length; i++) {
            var t_1 = f(i, as[i]);
            if (isLeft$1(t_1)) {
                return t_1;
            }
            if (isBoth(t_1)) {
                e = isNone$2(e) ? some$a(t_1.left) : some$a(S.concat(e.value, t_1.left));
            }
            out.push(t_1.right);
        }
        return isNone$2(e) ? right$3(out) : both$2(e.value, out);
    }; }; };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(getApplicative(S))`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndex$1 = function (S) { return function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndex$1(S)(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT$1); };
    }; };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var these = {
        URI: URI$5,
        map: _map$5,
        bimap: _bimap$2,
        mapLeft: _mapLeft$2,
        reduce: _reduce$2,
        foldMap: _foldMap$2,
        reduceRight: _reduceRight$2,
        traverse: _traverse$2,
        sequence: sequence$3
    };

    var These = /*#__PURE__*/Object.freeze({
        __proto__: null,
        isLeft: isLeft$1,
        isRight: isRight$1,
        isBoth: isBoth,
        left: left$3,
        right: right$3,
        both: both$2,
        matchW: matchW$1,
        foldW: foldW$1,
        match: match$2,
        fold: fold$2,
        swap: swap$3,
        getShow: getShow$1,
        getEq: getEq$1,
        getSemigroup: getSemigroup$1,
        getApply: getApply$3,
        getApplicative: getApplicative$3,
        getChain: getChain$3,
        getMonad: getMonad$3,
        getLeft: getLeft,
        getRight: getRight,
        leftOrBoth: leftOrBoth,
        rightOrBoth: rightOrBoth,
        getLeftOnly: getLeftOnly,
        getRightOnly: getRightOnly,
        fromOptions: fromOptions,
        bimap: bimap$3,
        mapLeft: mapLeft$3,
        map: map$7,
        reduce: reduce$2,
        foldMap: foldMap$2,
        reduceRight: reduceRight$2,
        traverse: traverse$3,
        sequence: sequence$3,
        of: of$3,
        URI: URI$5,
        Functor: Functor$6,
        flap: flap$6,
        Pointed: Pointed$2,
        Bifunctor: Bifunctor$2,
        FromThese: FromThese$1,
        Foldable: Foldable$2,
        Traversable: Traversable$3,
        FromEither: FromEither$2,
        fromOption: fromOption$2,
        fromOptionK: fromOptionK$2,
        elem: elem$1,
        exists: exists$1,
        toTuple2: toTuple2$2,
        toTuple: toTuple$1,
        ApT: ApT$1,
        traverseReadonlyNonEmptyArrayWithIndex: traverseReadonlyNonEmptyArrayWithIndex$1,
        traverseReadonlyArrayWithIndex: traverseReadonlyArrayWithIndex$1,
        these: these
    });

    /**
     * @since 2.4.0
     */
    function right$2(F) {
        return flow(right$3, F.of);
    }
    function left$2(F) {
        return flow(left$3, F.of);
    }
    function both$1(F) {
        return flow(both$2, F.of);
    }
    function rightF(F) {
        return function (fa) { return F.map(fa, right$3); };
    }
    function leftF(F) {
        return function (fe) { return F.map(fe, left$3); };
    }
    function map$6(F) {
        return map$E(F, Functor$6);
    }
    function ap$2(F, S) {
        return ap$p(F, getApply$3(S));
    }
    function chain$1(M, S) {
        var _left = left$2(M);
        return function (f) { return function (ma) {
            return M.chain(ma, match$2(_left, f, function (e1, a) {
                return M.map(f(a), match$2(function (e2) { return left$3(S.concat(e1, e2)); }, function (b) { return both$2(e1, b); }, function (e2, b) { return both$2(S.concat(e1, e2), b); }));
            }));
        }; };
    }
    function bimap$2(F) {
        return function (f, g) { return function (fea) { return F.map(fea, bimap$3(f, g)); }; };
    }
    function mapLeft$2(F) {
        return function (f) { return function (fea) { return F.map(fea, mapLeft$3(f)); }; };
    }
    function match$1(F) {
        return function (onLeft, onRight, onBoth) { return function (ma) { return F.map(ma, match$2(onLeft, onRight, onBoth)); }; };
    }
    function matchE$1(M) {
        return function (onLeft, onRight, onBoth) { return function (ma) { return M.chain(ma, match$2(onLeft, onRight, onBoth)); }; };
    }
    function swap$2(F) {
        return function (ma) { return F.map(ma, swap$3); };
    }
    function toTuple2$1(F) {
        return function (e, a) { return function (fa) { return F.map(fa, toTuple2$2(e, a)); }; };
    }
    /** @deprecated */
    /* istanbul ignore next */
    function getTheseM(M) {
        var _map = map$6(M);
        var _bimap = bimap$2(M);
        var _mapLeft = mapLeft$2(M);
        var _fold = matchE$1(M);
        var _toTuple2 = toTuple2$1(M);
        var of = right$2(M);
        var mapT = function (fa, f) { return pipe$1(fa, _map(f)); };
        return {
            map: mapT,
            bimap: function (fea, f, g) { return pipe$1(fea, _bimap(f, g)); },
            mapLeft: function (fea, f) { return pipe$1(fea, _mapLeft(f)); },
            fold: function (fa, onLeft, onRight, onBoth) { return pipe$1(fa, _fold(onLeft, onRight, onBoth)); },
            swap: swap$2(M),
            rightM: rightF(M),
            leftM: leftF(M),
            left: left$2(M),
            right: right$2(M),
            both: both$1(M),
            toTuple: function (fa, e, a) {
                return pipe$1(fa, _toTuple2(function () { return e; }, function () { return a; }));
            },
            getMonad: function (S) {
                var _ap = ap$2(M, S);
                var _chain = chain$1(M, S);
                return {
                    _E: undefined,
                    map: mapT,
                    of: of,
                    ap: function (fab, fa) { return pipe$1(fab, _ap(fa)); },
                    chain: function (ma, f) { return pipe$1(ma, _chain(f)); }
                };
            }
        };
    }

    var TheseT = /*#__PURE__*/Object.freeze({
        __proto__: null,
        right: right$2,
        left: left$2,
        both: both$1,
        rightF: rightF,
        leftF: leftF,
        map: map$6,
        ap: ap$2,
        chain: chain$1,
        bimap: bimap$2,
        mapLeft: mapLeft$2,
        match: match$1,
        matchE: matchE$1,
        swap: swap$2,
        toTuple2: toTuple2$1,
        getTheseM: getTheseM
    });

    /**
     * @category constructors
     * @since 2.4.0
     */
    var left$1 = 
    /*#__PURE__*/
    left$2(Pointed$8);
    /**
     * @category constructors
     * @since 2.4.0
     */
    var right$1 = 
    /*#__PURE__*/
    right$2(Pointed$8);
    /**
     * @category constructors
     * @since 2.4.0
     */
    var both = 
    /*#__PURE__*/
    both$1(Pointed$8);
    /**
     * @category constructors
     * @since 2.4.0
     */
    var rightTask = 
    /*#__PURE__*/
    rightF(Functor$g);
    /**
     * @category constructors
     * @since 2.4.0
     */
    var leftTask = 
    /*#__PURE__*/
    leftF(Functor$g);
    /**
     * @category constructors
     * @since 2.4.0
     */
    var rightIO = 
    /*#__PURE__*/
    flow(fromIO$6, rightTask);
    /**
     * @category constructors
     * @since 2.4.0
     */
    var leftIO = 
    /*#__PURE__*/
    flow(fromIO$6, leftTask);
    // -------------------------------------------------------------------------------------
    // natural transformations
    // -------------------------------------------------------------------------------------
    /**
     * @category natural transformations
     * @since 2.10.0
     */
    var fromEither = of$b;
    /**
     * @category natural transformations
     * @since 2.11.0
     */
    var fromThese = of$b;
    /**
     * @category natural transformations
     * @since 2.7.0
     */
    var fromIO = rightIO;
    /**
     * @category natural transformations
     * @since 2.4.0
     */
    var fromIOEither = 

    fromIO$6;
    /**
     * @category natural transformations
     * @since 2.7.0
     */
    var fromTask = rightTask;
    // -------------------------------------------------------------------------------------
    // destructors
    // -------------------------------------------------------------------------------------
    /**
     * @category destructors
     * @since 2.10.0
     */
    var match = 
    /*#__PURE__*/
    match$1(Functor$g);
    /**
     * Less strict version of [`match`](#match).
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchW = match;
    /**
     * @category destructors
     * @since 2.10.0
     */
    var matchE = 
    /*#__PURE__*/
    matchE$1(Monad$6);
    /**
     * Alias of [`matchE`](#matche).
     *
     * @category destructors
     * @since 2.4.0
     */
    var fold$1 = matchE;
    /**
     * Less strict version of [`matchE`](#matche).
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchEW = fold$1;
    /**
     * Alias of [`matchEW`](#matchew).
     *
     * @category destructors
     * @since 2.10.0
     */
    var foldW = matchEW;
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * @category combinators
     * @since 2.4.0
     */
    var swap$1 = 
    /*#__PURE__*/
    swap$2(Functor$g);
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _map$4 = function (fa, f) { return pipe$1(fa, map$5(f)); };
    /* istanbul ignore next */
    var _bimap$1 = function (fa, f, g) { return pipe$1(fa, bimap$1(f, g)); };
    /* istanbul ignore next */
    var _mapLeft$1 = function (fa, f) { return pipe$1(fa, mapLeft$1(f)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.4.0
     */
    var map$5 = 
    /*#__PURE__*/
    map$6(Functor$g);
    /**
     * Map a pair of functions over the two type arguments of the bifunctor.
     *
     * @category Bifunctor
     * @since 2.4.0
     */
    var bimap$1 = 
    /*#__PURE__*/
    bimap$2(Functor$g);
    /**
     * Map a function over the first type argument of a bifunctor.
     *
     * @category Bifunctor
     * @since 2.4.0
     */
    var mapLeft$1 = 
    /*#__PURE__*/
    mapLeft$2(Functor$g);
    /**
     * @category Pointed
     * @since 2.7.0
     */
    var of$2 = right$1;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.4.0
     */
    var URI$4 = 'TaskThese';
    /**
     * @category instances
     * @since 2.10.0
     */
    var getApply$2 = function (A, S) {
        var ap = ap$2(A, S);
        return {
            URI: URI$4,
            _E: undefined,
            map: _map$4,
            ap: function (fab, fa) { return pipe$1(fab, ap(fa)); }
        };
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    function getApplicative$2(A, S) {
        var ap = getApply$2(A, S).ap;
        return {
            URI: URI$4,
            _E: undefined,
            map: _map$4,
            ap: ap,
            of: of$2
        };
    }
    /**
     * @category instances
     * @since 2.10.0
     */
    function getChain$2(S) {
        var A = getApply$2(ApplicativePar$4, S);
        var chain = chain$1(Monad$6, S);
        return {
            URI: URI$4,
            _E: undefined,
            map: _map$4,
            ap: A.ap,
            chain: function (ma, f) { return pipe$1(ma, chain(f)); }
        };
    }
    /**
     * @category instances
     * @since 2.4.0
     */
    function getMonad$2(S) {
        var A = getApplicative$2(ApplicativePar$4, S);
        var C = getChain$2(S);
        return {
            URI: URI$4,
            _E: undefined,
            map: _map$4,
            ap: A.ap,
            of: of$2,
            chain: C.chain,
            fromIO: fromIO,
            fromTask: fromTask
        };
    }
    /**
     * @category instances
     * @since 2.10.0
     */
    var Functor$5 = {
        URI: URI$4,
        map: _map$4
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$5 = 
    /*#__PURE__*/
    flap$x(Functor$5);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed$1 = {
        URI: URI$4,
        of: of$2
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Bifunctor$1 = {
        URI: URI$4,
        bimap: _bimap$1,
        mapLeft: _mapLeft$1
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromEither$1 = {
        URI: URI$4,
        fromEither: fromEither
    };
    /**
     * @category natural transformations
     * @since 2.10.0
     */
    var fromOption$1 = 
    /*#__PURE__*/
    fromOption$c(FromEither$1);
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromOptionK$1 = 
    /*#__PURE__*/
    fromOptionK$e(FromEither$1);
    /**
     * @category constructors
     * @since 2.10.0
     */
    var fromPredicate$1 = 
    /*#__PURE__*/
    fromPredicate$d(FromEither$1);
    /**
     * @category instances
     * @since 2.11.0
     */
    var FromThese = {
        URI: URI$4,
        fromThese: fromThese
    };
    /**
     * @category combinators
     * @since 2.11.0
     */
    var fromTheseK = 
    /*#__PURE__*/
    fromTheseK$1(FromThese);
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromIO = {
        URI: URI$4,
        fromIO: fromIO
    };
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromIOK = 
    /*#__PURE__*/
    fromIOK$8(FromIO);
    /**
     * @category instances
     * @since 2.10.0
     */
    var FromTask = {
        URI: URI$4,
        fromIO: fromIO,
        fromTask: fromTask
    };
    /**
     * @category combinators
     * @since 2.10.0
     */
    var fromTaskK = 
    /*#__PURE__*/
    fromTaskK$6(FromTask);
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.10.0
     */
    var toTuple2 = 
    /*#__PURE__*/
    toTuple2$1(Functor$g);
    // -------------------------------------------------------------------------------------
    // sequence T
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var ApT = 
    /*#__PURE__*/
    of$2(emptyReadonlyArray);
    // -------------------------------------------------------------------------------------
    // array utils
    // -------------------------------------------------------------------------------------
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(getApplicative(T.ApplicativePar, S))`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndex = function (S) {
        var g = traverseReadonlyNonEmptyArrayWithIndex$1(S);
        return function (f) { return flow(traverseReadonlyNonEmptyArrayWithIndex$7(f), map$k(g(SK))); };
    };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(getApplicative(T.ApplicativePar, S))`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndex = function (S) { return function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndex(S)(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT); };
    }; };
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(getApplicative(T.ApplicativeSeq, S))`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndexSeq = function (S) { return function (f) { return function (as) { return function () {
        return tail$5(as).reduce(function (acc, a, i) {
            return acc.then(function (ebs) {
                return isLeft$1(ebs)
                    ? acc
                    : f(i + 1, a)().then(function (eb) {
                        if (isLeft$1(eb)) {
                            return eb;
                        }
                        if (isBoth(eb)) {
                            var right_1 = ebs.right;
                            right_1.push(eb.right);
                            return isBoth(ebs) ? both$2(S.concat(ebs.left, eb.left), right_1) : both$2(eb.left, right_1);
                        }
                        ebs.right.push(eb.right);
                        return ebs;
                    });
            });
        }, f(0, head$5(as))().then(map$7(singleton$7)));
    }; }; }; };
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(getApplicative(T.ApplicativeSeq, S))`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndexSeq = function (S) { return function (f) {
        var g = traverseReadonlyNonEmptyArrayWithIndexSeq(S)(f);
        return function (as) { return (isNonEmpty$5(as) ? g(as) : ApT); };
    }; };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use [`Functor`](#functor) instead.
     *
     * @category instances
     * @since 2.7.0
     * @deprecated
     */
    var functorTaskThese = {
        URI: URI$4,
        map: _map$4
    };
    /**
     * Use [`Bifunctor`](#bifunctor) instead.
     *
     * @category instances
     * @since 2.7.0
     * @deprecated
     */
    var bifunctorTaskThese = {
        URI: URI$4,
        bimap: _bimap$1,
        mapLeft: _mapLeft$1
    };
    /**
     * Use [`toTuple2`](#totuple2) instead.
     *
     * @since 2.4.0
     * @deprecated
     */
    var toTuple = function (e, a) {
        return toTuple2(function () { return e; }, function () { return a; });
    };
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.4.0
     * @deprecated
     */
    var taskThese = {
        URI: URI$4,
        map: _map$4,
        bimap: _bimap$1,
        mapLeft: _mapLeft$1
    };
    /**
     * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
     *
     * @category instances
     * @since 2.4.0
     * @deprecated
     */
    var getSemigroup = function (SE, SA) {
        return getApplySemigroup$7(ApplySeq$4)(getSemigroup$1(SE, SA));
    };

    var TaskThese = /*#__PURE__*/Object.freeze({
        __proto__: null,
        left: left$1,
        right: right$1,
        both: both,
        rightTask: rightTask,
        leftTask: leftTask,
        rightIO: rightIO,
        leftIO: leftIO,
        fromEither: fromEither,
        fromThese: fromThese,
        fromIO: fromIO,
        fromIOEither: fromIOEither,
        fromTask: fromTask,
        match: match,
        matchW: matchW,
        matchE: matchE,
        fold: fold$1,
        matchEW: matchEW,
        foldW: foldW,
        swap: swap$1,
        map: map$5,
        bimap: bimap$1,
        mapLeft: mapLeft$1,
        of: of$2,
        URI: URI$4,
        getApply: getApply$2,
        getApplicative: getApplicative$2,
        getChain: getChain$2,
        getMonad: getMonad$2,
        Functor: Functor$5,
        flap: flap$5,
        Pointed: Pointed$1,
        Bifunctor: Bifunctor$1,
        FromEither: FromEither$1,
        fromOption: fromOption$1,
        fromOptionK: fromOptionK$1,
        fromPredicate: fromPredicate$1,
        FromThese: FromThese,
        fromTheseK: fromTheseK,
        FromIO: FromIO,
        fromIOK: fromIOK,
        FromTask: FromTask,
        fromTaskK: fromTaskK,
        toTuple2: toTuple2,
        ApT: ApT,
        traverseReadonlyNonEmptyArrayWithIndex: traverseReadonlyNonEmptyArrayWithIndex,
        traverseReadonlyArrayWithIndex: traverseReadonlyArrayWithIndex,
        traverseReadonlyNonEmptyArrayWithIndexSeq: traverseReadonlyNonEmptyArrayWithIndexSeq,
        traverseReadonlyArrayWithIndexSeq: traverseReadonlyArrayWithIndexSeq,
        functorTaskThese: functorTaskThese,
        bifunctorTaskThese: bifunctorTaskThese,
        toTuple: toTuple,
        taskThese: taskThese,
        getSemigroup: getSemigroup
    });

    // TODO: curry in v3
    /**
     * Extracts a value at a relative position which depends on the current value.
     *
     * @since 2.0.0
     */
    function tracks(M, f) {
        return function (wa) { return wa(f(wa(M.empty))); };
    }
    /**
     * Get the current position
     *
     * @since 2.0.0
     */
    function listen$2(wa) {
        return function (e) { return [wa(e), e]; };
    }
    /**
     * Get a value which depends on the current position
     *
     * @since 2.0.0
     */
    function listens$1(f) {
        return function (wa) { return function (e) { return [wa(e), f(e)]; }; };
    }
    /**
     * Apply a function to the current position
     *
     * @since 2.0.0
     */
    function censor$1(f) {
        return function (wa) { return function (e) { return wa(f(e)); }; };
    }
    /**
     * @category instances
     * @since 2.0.0
     */
    function getComonad(monoid) {
        function extend(wa, f) {
            return function (p1) { return f(function (p2) { return wa(monoid.concat(p1, p2)); }); };
        }
        function extract(wa) {
            return wa(monoid.empty);
        }
        return {
            URI: URI$3,
            _E: undefined,
            map: _map$3,
            extend: extend,
            extract: extract
        };
    }
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    /* istanbul ignore next */
    var _map$3 = function (fa, f) { return pipe$1(fa, map$4(f)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$4 = function (f) { return function (fa) { return function (p) { return f(fa(p)); }; }; };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$3 = 'Traced';
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$4 = {
        URI: URI$3,
        map: _map$3
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$4 = 
    /*#__PURE__*/
    flap$x(Functor$4);
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use [`Functor`](#functor) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var traced = Functor$4;

    var Traced = /*#__PURE__*/Object.freeze({
        __proto__: null,
        tracks: tracks,
        listen: listen$2,
        listens: listens$1,
        censor: censor$1,
        getComonad: getComonad,
        map: map$4,
        URI: URI$3,
        Functor: Functor$4,
        flap: flap$4,
        traced: traced
    });

    function traverse$2(T, G) {
        return function (F) {
            var traverseT = T.traverse(F);
            var traverseG = G.traverse(F);
            return function (f) { return function (fga) { return traverseT(fga, function (ga) { return traverseG(ga, f); }); }; };
        };
    }
    function sequence$2(T, G) {
        return function (F) {
            var sequenceT = T.sequence(F);
            var sequenceG = G.sequence(F);
            return function (fgha) { return sequenceT(T.map(fgha, sequenceG)); };
        };
    }
    /** @deprecated */
    function getTraversableComposition(F, G) {
        var map = getFunctorComposition$1(F, G).map;
        var FC = getFoldableComposition(F, G);
        var _traverse = traverse$2(F, G);
        var _sequence = sequence$2(F, G);
        return {
            map: map,
            reduce: FC.reduce,
            foldMap: FC.foldMap,
            reduceRight: FC.reduceRight,
            traverse: function (H) {
                var traverseH = _traverse(H);
                return function (fga, f) { return pipe$1(fga, traverseH(f)); };
            },
            sequence: function (H) {
                var sequenceH = _sequence(H);
                return function (fgha) { return pipe$1(fgha, sequenceH); };
            }
        };
    }

    var Traversable$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        traverse: traverse$2,
        sequence: sequence$2,
        getTraversableComposition: getTraversableComposition
    });

    var TraversableWithIndex = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    /**
     * @category constructors
     * @since 2.0.0
     */
    function make(value, forest) {
        if (forest === void 0) { forest = []; }
        return {
            value: value,
            forest: forest
        };
    }
    /**
     * @category instances
     * @since 2.0.0
     */
    function getShow(S) {
        var show = function (t) {
            return isEmpty$7(t.forest)
                ? "make(" + S.show(t.value) + ")"
                : "make(" + S.show(t.value) + ", [" + t.forest.map(show).join(', ') + "])";
        };
        return {
            show: show
        };
    }
    /**
     * @category instances
     * @since 2.0.0
     */
    function getEq(E) {
        var SA;
        var R = fromEquals(function (x, y) { return E.equals(x.value, y.value) && SA.equals(x.forest, y.forest); });
        SA = getEq$c(R);
        return R;
    }
    var draw = function (indentation, forest) {
        var r = '';
        var len = forest.length;
        var tree;
        for (var i = 0; i < len; i++) {
            tree = forest[i];
            var isLast = i === len - 1;
            r += indentation + (isLast ? '└' : '├') + '─ ' + tree.value;
            r += draw(indentation + (len > 1 && !isLast ? '│  ' : '   '), tree.forest);
        }
        return r;
    };
    /**
     * Neat 2-dimensional drawing of a forest
     *
     * @since 2.0.0
     */
    function drawForest(forest) {
        return draw('\n', forest);
    }
    /**
     * Neat 2-dimensional drawing of a tree
     *
     * @example
     * import { make, drawTree } from 'fp-ts/Tree'
     *
     * const fa = make('a', [
     *   make('b'),
     *   make('c'),
     *   make('d', [make('e'), make('f')])
     * ])
     *
     * assert.strictEqual(drawTree(fa), `a
     * ├─ b
     * ├─ c
     * └─ d
     *    ├─ e
     *    └─ f`)
     *
     *
     * @since 2.0.0
     */
    function drawTree(tree) {
        return tree.value + drawForest(tree.forest);
    }
    /**
     * Build a (possibly infinite) tree from a seed value in breadth-first order.
     *
     * @category constructors
     * @since 2.0.0
     */
    function unfoldTree(b, f) {
        var _a = f(b), a = _a[0], bs = _a[1];
        return { value: a, forest: unfoldForest(bs, f) };
    }
    /**
     * Build a (possibly infinite) forest from a list of seed values in breadth-first order.
     *
     * @category constructors
     * @since 2.0.0
     */
    function unfoldForest(bs, f) {
        return bs.map(function (b) { return unfoldTree(b, f); });
    }
    function unfoldTreeM(M) {
        var unfoldForestMM = unfoldForestM(M);
        return function (b, f) { return M.chain(f(b), function (_a) {
            var a = _a[0], bs = _a[1];
            return M.map(unfoldForestMM(bs, f), function (ts) { return ({ value: a, forest: ts }); });
        }); };
    }
    function unfoldForestM(M) {
        var traverseM = traverse$a(M);
        return function (bs, f) {
            return pipe$1(bs, traverseM(function (b) { return unfoldTreeM(M)(b, f); }));
        };
    }
    /**
     * Fold a tree into a "summary" value in depth-first order.
     *
     * For each node in the tree, apply `f` to the `value` and the result of applying `f` to each `forest`.
     *
     * This is also known as the catamorphism on trees.
     *
     * @example
     * import { fold, make } from 'fp-ts/Tree'
     * import { concatAll } from 'fp-ts/Monoid'
     * import { MonoidSum } from 'fp-ts/number'
     *
     * const t = make(1, [make(2), make(3)])
     *
     * const sum = concatAll(MonoidSum)
     *
     * // Sum the values in a tree:
     * assert.deepStrictEqual(fold((a: number, bs: Array<number>) => a + sum(bs))(t), 6)
     *
     * // Find the maximum value in the tree:
     * assert.deepStrictEqual(fold((a: number, bs: Array<number>) => bs.reduce((b, acc) => Math.max(b, acc), a))(t), 3)
     *
     * // Count the number of leaves in the tree:
     * assert.deepStrictEqual(fold((_: number, bs: Array<number>) => (bs.length === 0 ? 1 : sum(bs)))(t), 2)
     *
     * @category destructors
     * @since 2.6.0
     */
    function fold(f) {
        var go = function (tree) { return f(tree.value, tree.forest.map(go)); };
        return go;
    }
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    /* istanbul ignore next */
    var _map$2 = function (fa, f) { return pipe$1(fa, map$3(f)); };
    var _ap = function (fab, fa) {
        return pipe$1(fab, chain(function (f) { return pipe$1(fa, map$3(f)); }));
    };
    /* istanbul ignore next */
    var _chain = function (ma, f) { return pipe$1(ma, chain(f)); };
    /* istanbul ignore next */
    var _reduce$1 = function (fa, b, f) { return pipe$1(fa, reduce$1(b, f)); };
    /* istanbul ignore next */
    var _foldMap$1 = function (M) {
        var foldMapM = foldMap$1(M);
        return function (fa, f) { return pipe$1(fa, foldMapM(f)); };
    };
    /* istanbul ignore next */
    var _reduceRight$1 = function (fa, b, f) { return pipe$1(fa, reduceRight$1(b, f)); };
    /* istanbul ignore next */
    var _extend$1 = function (wa, f) { return pipe$1(wa, extend$1(f)); };
    /* istanbul ignore next */
    var _traverse$1 = function (F) {
        var traverseF = traverse$1(F);
        return function (ta, f) { return pipe$1(ta, traverseF(f)); };
    };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * Apply a function to an argument under a type constructor.
     *
     * @category Apply
     * @since 2.0.0
     */
    var ap$1 = function (fa) { return function (fab) { return _ap(fab, fa); }; };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category Monad
     * @since 2.0.0
     */
    var chain = function (f) { return function (ma) {
        var _a = f(ma.value), value = _a.value, forest = _a.forest;
        var concat = getMonoid$b().concat;
        return {
            value: value,
            forest: concat(forest, ma.forest.map(chain(f)))
        };
    }; };
    /**
     * @category Extend
     * @since 2.0.0
     */
    var extend$1 = function (f) { return function (wa) { return ({
        value: f(wa),
        forest: wa.forest.map(extend$1(f))
    }); }; };
    /**
     * Derivable from `Extend`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var duplicate$1 = 
    /*#__PURE__*/
    extend$1(identity$1);
    /**
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var flatten = 
    /*#__PURE__*/
    chain(identity$1);
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$3 = function (f) { return function (fa) { return ({
        value: f(fa.value),
        forest: fa.forest.map(map$3(f))
    }); }; };
    /**
     * @category Foldable
     * @since 2.0.0
     */
    var reduce$1 = function (b, f) { return function (fa) {
        var r = f(b, fa.value);
        var len = fa.forest.length;
        for (var i = 0; i < len; i++) {
            r = pipe$1(fa.forest[i], reduce$1(r, f));
        }
        return r;
    }; };
    /**
     * @category Foldable
     * @since 2.0.0
     */
    var foldMap$1 = function (M) { return function (f) {
        return reduce$1(M.empty, function (acc, a) { return M.concat(acc, f(a)); });
    }; };
    /**
     * @category Foldable
     * @since 2.0.0
     */
    var reduceRight$1 = function (b, f) { return function (fa) {
        var r = b;
        var len = fa.forest.length;
        for (var i = len - 1; i >= 0; i--) {
            r = pipe$1(fa.forest[i], reduceRight$1(r, f));
        }
        return f(fa.value, r);
    }; };
    /**
     * @category Extract
     * @since 2.6.2
     */
    var extract$1 = function (wa) { return wa.value; };
    /**
     * @since 2.6.3
     */
    var traverse$1 = function (F) {
        var traverseF = traverse$a(F);
        var out = function (f) { return function (ta) {
            return F.ap(F.map(f(ta.value), function (value) { return function (forest) { return ({
                value: value,
                forest: forest
            }); }; }), pipe$1(ta.forest, traverseF(out(f))));
        }; };
        return out;
    };
    /**
     * @since 2.6.3
     */
    var sequence$1 = function (F) { return traverse$1(F)(identity$1); };
    /**
     * @category Pointed
     * @since 2.7.0
     */
    var of$1 = function (a) { return make(a); };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$2 = 'Tree';
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$3 = {
        URI: URI$2,
        map: _map$2
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$3 = 
    /*#__PURE__*/
    flap$x(Functor$3);
    /**
     * @category instances
     * @since 2.10.0
     */
    var Pointed = {
        URI: URI$2,
        of: of$1
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Apply$1 = {
        URI: URI$2,
        map: _map$2,
        ap: _ap
    };
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apFirst$1 = 
    /*#__PURE__*/
    apFirst$k(Apply$1);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var apSecond$1 = 
    /*#__PURE__*/
    apSecond$k(Apply$1);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Applicative$1 = {
        URI: URI$2,
        map: _map$2,
        ap: _ap,
        of: of$1
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var Chain$2 = {
        URI: URI$2,
        map: _map$2,
        ap: _ap,
        chain: _chain
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Monad = {
        URI: URI$2,
        map: _map$2,
        ap: _ap,
        of: of$1,
        chain: _chain
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var chainFirst$1 = 
    /*#__PURE__*/
    chainFirst$k(Chain$2);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Foldable$1 = {
        URI: URI$2,
        reduce: _reduce$1,
        foldMap: _foldMap$1,
        reduceRight: _reduceRight$1
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Traversable$1 = {
        URI: URI$2,
        map: _map$2,
        reduce: _reduce$1,
        foldMap: _foldMap$1,
        reduceRight: _reduceRight$1,
        traverse: _traverse$1,
        sequence: sequence$1
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Comonad$1 = {
        URI: URI$2,
        map: _map$2,
        extend: _extend$1,
        extract: extract$1
    };
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.9.0
     */
    var Do = 
    /*#__PURE__*/
    of$1(emptyRecord);
    /**
     * @since 2.8.0
     */
    var bindTo$1 = 
    /*#__PURE__*/
    bindTo$k(Functor$3);
    /**
     * @since 2.8.0
     */
    var bind$3 = 
    /*#__PURE__*/
    bind$m(Chain$2);
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var apS$1 = 
    /*#__PURE__*/
    apS$k(Apply$1);
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.0.0
     */
    function elem(E) {
        var go = function (a, fa) { return E.equals(a, fa.value) || fa.forest.some(function (tree) { return go(a, tree); }); };
        return go;
    }
    /**
     * @since 2.11.0
     */
    var exists = function (predicate) { return function (ma) {
        return predicate(ma.value) || ma.forest.some(exists(predicate));
    }; };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var tree = {
        URI: URI$2,
        map: _map$2,
        of: of$1,
        ap: _ap,
        chain: _chain,
        reduce: _reduce$1,
        foldMap: _foldMap$1,
        reduceRight: _reduceRight$1,
        traverse: _traverse$1,
        sequence: sequence$1,
        extract: extract$1,
        extend: _extend$1
    };

    var Tree = /*#__PURE__*/Object.freeze({
        __proto__: null,
        make: make,
        getShow: getShow,
        getEq: getEq,
        drawForest: drawForest,
        drawTree: drawTree,
        unfoldTree: unfoldTree,
        unfoldForest: unfoldForest,
        unfoldTreeM: unfoldTreeM,
        unfoldForestM: unfoldForestM,
        fold: fold,
        ap: ap$1,
        chain: chain,
        extend: extend$1,
        duplicate: duplicate$1,
        flatten: flatten,
        map: map$3,
        reduce: reduce$1,
        foldMap: foldMap$1,
        reduceRight: reduceRight$1,
        extract: extract$1,
        traverse: traverse$1,
        sequence: sequence$1,
        of: of$1,
        URI: URI$2,
        Functor: Functor$3,
        flap: flap$3,
        Pointed: Pointed,
        Apply: Apply$1,
        apFirst: apFirst$1,
        apSecond: apSecond$1,
        Applicative: Applicative$1,
        Chain: Chain$2,
        Monad: Monad,
        chainFirst: chainFirst$1,
        Foldable: Foldable$1,
        Traversable: Traversable$1,
        Comonad: Comonad$1,
        Do: Do,
        bindTo: bindTo$1,
        bind: bind$3,
        apS: apS$1,
        elem: elem,
        exists: exists,
        tree: tree
    });

    // -------------------------------------------------------------------------------------
    // model
    // -------------------------------------------------------------------------------------
    /**
     * @category destructors
     * @since 2.0.0
     */
    var fst = fst$1;
    /**
     * @category destructors
     * @since 2.0.0
     */
    var snd = snd$1;
    /**
     * @category combinators
     * @since 2.0.0
     */
    var swap = function (ea) { return [snd(ea), fst(ea)]; };
    /**
     * @category instances
     * @since 2.0.0
     */
    function getApply$1(S) {
        return {
            URI: URI$1,
            _E: undefined,
            map: _map$1,
            ap: function (fab, fa) { return [fst(fab)(fst(fa)), S.concat(snd(fab), snd(fa))]; }
        };
    }
    var of = function (M) { return function (a) {
        return [a, M.empty];
    }; };
    /**
     * @category instances
     * @since 2.0.0
     */
    function getApplicative$1(M) {
        var A = getApply$1(M);
        return {
            URI: URI$1,
            _E: undefined,
            map: A.map,
            ap: A.ap,
            of: of(M)
        };
    }
    /**
     * @category instances
     * @since 2.0.0
     */
    function getChain$1(S) {
        var A = getApply$1(S);
        return {
            URI: URI$1,
            _E: undefined,
            map: A.map,
            ap: A.ap,
            chain: function (ma, f) {
                var _a = f(fst(ma)), b = _a[0], s = _a[1];
                return [b, S.concat(snd(ma), s)];
            }
        };
    }
    /**
     * @category instances
     * @since 2.0.0
     */
    function getMonad$1(M) {
        var C = getChain$1(M);
        return {
            URI: URI$1,
            _E: undefined,
            map: C.map,
            ap: C.ap,
            chain: C.chain,
            of: of(M)
        };
    }
    /**
     * @category instances
     * @since 2.0.0
     */
    function getChainRec(M) {
        var chainRec = function (a, f) {
            var result = f(a);
            var acc = M.empty;
            var s = fst(result);
            while (s._tag === 'Left') {
                acc = M.concat(acc, snd(result));
                result = f(s.left);
                s = fst(result);
            }
            return [s.right, M.concat(acc, snd(result))];
        };
        var C = getChain$1(M);
        return {
            URI: URI$1,
            _E: undefined,
            map: C.map,
            ap: C.ap,
            chain: C.chain,
            chainRec: chainRec
        };
    }
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    /* istanbul ignore next */
    var _compose = function (bc, ab) { return pipe$1(bc, compose(ab)); };
    /* istanbul ignore next */
    var _map$1 = function (fa, f) { return pipe$1(fa, mapFst(f)); };
    /* istanbul ignore next */
    var _bimap = function (fa, f, g) { return pipe$1(fa, bimap(f, g)); };
    /* istanbul ignore next */
    var _mapLeft = function (fa, f) { return pipe$1(fa, mapSnd(f)); };
    /* istanbul ignore next */
    var _extend = function (wa, f) { return pipe$1(wa, extend(f)); };
    /* istanbul ignore next */
    var _reduce = function (fa, b, f) { return pipe$1(fa, reduce(b, f)); };
    /* istanbul ignore next */
    var _foldMap = function (M) {
        var foldMapM = foldMap();
        return function (fa, f) { return pipe$1(fa, foldMapM(f)); };
    };
    /* istanbul ignore next */
    var _reduceRight = function (fa, b, f) { return pipe$1(fa, reduceRight(b, f)); };
    /* istanbul ignore next */
    function _traverse(F) {
        var traverseF = traverse(F);
        return function (ta, f) { return pipe$1(ta, traverseF(f)); };
    }
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * Map a pair of functions over the two type arguments of the bifunctor.
     *
     * @category Bifunctor
     * @since 2.0.0
     */
    var bimap = function (f, g) { return function (fa) { return [g(fst(fa)), f(snd(fa))]; }; };
    /**
     * Map a function over the first component of a `Tuple`.
     *
     * This is the `map` operation of the `Functor` instance.
     *
     * @category Functor
     * @since 2.0.0
     */
    var mapFst = function (f) { return function (fa) { return [f(fst(fa)), snd(fa)]; }; };
    /**
     * Map a function over the second component of a `Tuple`.
     *
     * This is the `mapLeft` operation of the `Bifunctor` instance.
     *
     * @category Bifunctor
     * @since 2.10.0
     */
    var mapSnd = function (f) { return function (fa) { return [fst(fa), f(snd(fa))]; }; };
    /**
     * @category Semigroupoid
     * @since 2.0.0
     */
    var compose = function (ab) { return function (bc) { return [fst(bc), snd(ab)]; }; };
    /**
     * @category Extend
     * @since 2.0.0
     */
    var extend = function (f) { return function (wa) { return [f(wa), snd(wa)]; }; };
    /**
     * Derivable from `Extend`.
     *
     * @category combinators
     * @since 2.0.0
     */
    var duplicate = 
    /*#__PURE__*/
    extend(identity$1);
    /**
     * @category Extract
     * @since 2.6.2
     */
    var extract = extract$3;
    /**
     * @category Foldable
     * @since 2.0.0
     */
    var foldMap = foldMap$5;
    /**
     * @category Foldable
     * @since 2.0.0
     */
    var reduce = reduce$5;
    /**
     * @category Foldable
     * @since 2.0.0
     */
    var reduceRight = reduceRight$5;
    /**
     * @since 2.6.3
     */
    var traverse = function (F) {
        return function (f) { return function (ta) { return F.map(f(fst(ta)), function (b) { return [b, snd(ta)]; }); }; };
    };
    /**
     * @since 2.6.3
     */
    var sequence = function (F) { return function (fas) {
        return F.map(fst(fas), function (a) { return [a, snd(fas)]; });
    }; };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI$1 = 'Tuple';
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$2 = {
        URI: URI$1,
        map: _map$1
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$2 = 
    /*#__PURE__*/
    flap$x(Functor$2);
    /**
     * @category instances
     * @since 2.7.0
     */
    var Bifunctor = {
        URI: URI$1,
        bimap: _bimap,
        mapLeft: _mapLeft
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Semigroupoid = {
        URI: URI$1,
        compose: _compose
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Comonad = {
        URI: URI$1,
        map: _map$1,
        extend: _extend,
        extract: extract
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Foldable = {
        URI: URI$1,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    var Traversable = {
        URI: URI$1,
        map: _map$1,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: sequence
    };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use [`mapFst`](#mapfst) instead.
     *
     * @since 2.0.0
     * @deprecated
     */
    var map$2 = mapFst;
    /**
     * Use [`mapSnd`](#mapsnd) instead.
     *
     * @since 2.0.0
     * @deprecated
     */
    var mapLeft = mapSnd;
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var tuple = {
        URI: URI$1,
        compose: _compose,
        map: _map$1,
        bimap: _bimap,
        mapLeft: _mapLeft,
        extract: extract,
        extend: _extend,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: sequence
    };

    var Tuple = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fst: fst,
        snd: snd,
        swap: swap,
        getApply: getApply$1,
        getApplicative: getApplicative$1,
        getChain: getChain$1,
        getMonad: getMonad$1,
        getChainRec: getChainRec,
        bimap: bimap,
        mapFst: mapFst,
        mapSnd: mapSnd,
        compose: compose,
        extend: extend,
        duplicate: duplicate,
        extract: extract,
        foldMap: foldMap,
        reduce: reduce,
        reduceRight: reduceRight,
        traverse: traverse,
        sequence: sequence,
        URI: URI$1,
        Functor: Functor$2,
        flap: flap$2,
        Bifunctor: Bifunctor,
        Semigroupoid: Semigroupoid,
        Comonad: Comonad,
        Foldable: Foldable,
        Traversable: Traversable,
        map: map$2,
        mapLeft: mapLeft,
        tuple: tuple
    });

    var Unfoldable = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    /**
     * @since 2.0.0
     */
    /** @deprecated */
    function getValidationM(S, M) {
        var A = getApplicativeComposition$1(M, getApplicativeValidation(S));
        return {
            map: A.map,
            ap: A.ap,
            of: A.of,
            chain: function (ma, f) { return M.chain(ma, function (e) { return (isLeft$3(e) ? M.of(left$d(e.left)) : f(e.right)); }); },
            alt: function (me, that) {
                return M.chain(me, function (e1) {
                    return isRight$3(e1) ? M.of(e1) : M.map(that(), function (e2) { return (isLeft$3(e2) ? left$d(S.concat(e1.left, e2.left)) : e2); });
                });
            }
        };
    }

    var ValidationT = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getValidationM: getValidationM
    });

    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.11.0
     */
    var Semigroup$1 = constant(undefined);
    /**
     * @category instances
     * @since 2.11.0
     */
    var Monoid = {
        concat: Semigroup$1.concat,
        empty: undefined
    };

    var _void = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Semigroup: Semigroup$1,
        Monoid: Monoid
    });

    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * Appends a value to the accumulator
     *
     * @category combinators
     * @since 2.0.0
     */
    var tell = function (w) { return function () { return [undefined, w]; }; };
    /**
     * Modifies the result to include the changes to the accumulator
     *
     * @category combinators
     * @since 2.0.0
     */
    var listen$1 = function (fa) { return function () {
        var _a = fa(), a = _a[0], w = _a[1];
        return [[a, w], w];
    }; };
    /**
     * Applies the returned function to the accumulator
     *
     * @category combinators
     * @since 2.0.0
     */
    var pass = function (fa) { return function () {
        var _a = fa(), _b = _a[0], a = _b[0], f = _b[1], w = _a[1];
        return [a, f(w)];
    }; };
    /**
     * Projects a value from modifications made to the accumulator during an action
     *
     * @category combinators
     * @since 2.0.0
     */
    var listens = function (f) { return function (fa) { return function () {
        var _a = fa(), a = _a[0], w = _a[1];
        return [[a, f(w)], w];
    }; }; };
    /**
     * Modify the final accumulator value by applying a function
     *
     * @category combinators
     * @since 2.0.0
     */
    var censor = function (f) { return function (fa) { return function () {
        var _a = fa(), a = _a[0], w = _a[1];
        return [a, f(w)];
    }; }; };
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    /* istanbul ignore next */
    var _map = function (fa, f) { return pipe$1(fa, map$1(f)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.0.0
     */
    var map$1 = function (f) { return function (fa) { return function () {
        var _a = fa(), a = _a[0], w = _a[1];
        return [f(a), w];
    }; }; };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    var URI = 'Writer';
    /**
     * @category instances
     * @since 2.10.0
     */
    var getPointed = function (M) { return ({
        URI: URI,
        _E: undefined,
        of: function (a) { return function () { return [a, M.empty]; }; }
    }); };
    /**
     * @category instances
     * @since 2.10.0
     */
    var getApply = function (S) { return ({
        URI: URI,
        _E: undefined,
        map: _map,
        ap: function (fab, fa) { return function () {
            var _a = fab(), f = _a[0], w1 = _a[1];
            var _b = fa(), a = _b[0], w2 = _b[1];
            return [f(a), S.concat(w1, w2)];
        }; }
    }); };
    /**
     * @category instances
     * @since 2.10.0
     */
    var getApplicative = function (M) {
        var A = getApply(M);
        var P = getPointed(M);
        return {
            URI: URI,
            _E: undefined,
            map: _map,
            ap: A.ap,
            of: P.of
        };
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    function getChain(M) {
        var A = getApply(M);
        return {
            URI: URI,
            _E: undefined,
            map: _map,
            ap: A.ap,
            chain: function (fa, f) { return function () {
                var _a = fa(), a = _a[0], w1 = _a[1];
                var _b = f(a)(), b = _b[0], w2 = _b[1];
                return [b, M.concat(w1, w2)];
            }; }
        };
    }
    /**
     * @category instances
     * @since 2.0.0
     */
    function getMonad(M) {
        var A = getApplicative(M);
        var C = getChain(M);
        return {
            URI: URI,
            _E: undefined,
            map: _map,
            ap: A.ap,
            of: A.of,
            chain: C.chain
        };
    }
    /**
     * @category instances
     * @since 2.7.0
     */
    var Functor$1 = {
        URI: URI,
        map: _map
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    var flap$1 = 
    /*#__PURE__*/
    flap$x(Functor$1);
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    var evaluate = function (fa) { return fa()[0]; };
    /**
     * @since 2.8.0
     */
    var execute = function (fa) { return fa()[1]; };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use [`evaluate`](#evaluate) instead
     *
     * @since 2.0.0
     * @deprecated
     */
    var evalWriter = function (fa) { return fa()[0]; };
    /**
     * Use [`execute`](#execute) instead
     *
     * @since 2.0.0
     * @deprecated
     */
    var execWriter = function (fa) { return fa()[1]; };
    /**
     * Use [`Functor`](#functor) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var writer = Functor$1;

    var Writer = /*#__PURE__*/Object.freeze({
        __proto__: null,
        tell: tell,
        listen: listen$1,
        pass: pass,
        listens: listens,
        censor: censor,
        map: map$1,
        URI: URI,
        getPointed: getPointed,
        getApply: getApply,
        getApplicative: getApplicative,
        getChain: getChain,
        getMonad: getMonad,
        Functor: Functor$1,
        flap: flap$1,
        evaluate: evaluate,
        execute: execute,
        evalWriter: evalWriter,
        execWriter: execWriter,
        writer: writer
    });

    function getWriterM(M) {
        var map = function (fa, f) { return function () {
            return M.map(fa(), function (_a) {
                var a = _a[0], w = _a[1];
                return [f(a), w];
            });
        }; };
        return {
            map: map,
            evalWriter: function (fa) { return M.map(fa(), function (_a) {
                var a = _a[0];
                return a;
            }); },
            execWriter: function (fa) { return M.map(fa(), function (_a) {
                _a[0]; var w = _a[1];
                return w;
            }); },
            tell: function (w) { return function () { return M.of([undefined, w]); }; },
            listen: function (fa) { return function () { return M.map(fa(), function (_a) {
                var a = _a[0], w = _a[1];
                return [[a, w], w];
            }); }; },
            pass: function (fa) { return function () { return M.map(fa(), function (_a) {
                var _b = _a[0], a = _b[0], f = _b[1], w = _a[1];
                return [a, f(w)];
            }); }; },
            listens: function (fa, f) { return function () { return M.map(fa(), function (_a) {
                var a = _a[0], w = _a[1];
                return [[a, f(w)], w];
            }); }; },
            censor: function (fa, f) { return function () { return M.map(fa(), function (_a) {
                var a = _a[0], w = _a[1];
                return [a, f(w)];
            }); }; },
            getMonad: function (W) {
                return {
                    _E: undefined,
                    map: map,
                    of: function (a) { return function () { return M.of([a, W.empty]); }; },
                    ap: function (mab, ma) { return function () { return M.chain(mab(), function (_a) {
                        var f = _a[0], w1 = _a[1];
                        return M.map(ma(), function (_a) {
                            var a = _a[0], w2 = _a[1];
                            return [f(a), W.concat(w1, w2)];
                        });
                    }); }; },
                    chain: function (ma, f) { return function () { return M.chain(ma(), function (_a) {
                        var a = _a[0], w1 = _a[1];
                        return M.map(f(a)(), function (_a) {
                            var b = _a[0], w2 = _a[1];
                            return [b, W.concat(w1, w2)];
                        });
                    }); }; }
                };
            }
        };
    }

    var WriterT = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getWriterM: getWriterM
    });

    /**
     * @since 2.0.0
     */

    var es6 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        alt: Alt$d,
        alternative: Alternative$4,
        applicative: Applicative$f,
        apply: Apply$e,
        array: Array$1,
        bifunctor: Bifunctor$b,
        boolean: boolean,
        booleanAlgebra: BooleanAlgebra,
        bounded: Bounded,
        boundedDistributiveLattice: BoundedDistributiveLattice,
        boundedJoinSemilattice: BoundedJoinSemilattice,
        boundedLattice: BoundedLattice,
        boundedMeetSemilattice: BoundedMeetSemilattice,
        category: Category$1,
        chain: Chain$l,
        chainRec: ChainRec$3,
        choice: Choice$1,
        comonad: Comonad$5,
        compactable: Compactable$5,
        console: Console,
        'const': Const,
        contravariant: Contravariant,
        date: Date$1,
        distributiveLattice: DistributiveLattice,
        either: Either,
        eitherT: EitherT,
        endomorphism: Endomorphism,
        extend: Extend,
        field: Field,
        filterable: Filterable$5,
        filterableWithIndex: FilterableWithIndex$2,
        foldable: Foldable$7,
        foldableWithIndex: FoldableWithIndex$2,
        fromEither: FromEither$d,
        fromIO: FromIO$9,
        fromReader: FromReader$4,
        fromState: FromState$1,
        fromTask: FromTask$7,
        fromThese: FromThese$2,
        'function': _function$1,
        functor: Functor$x,
        functorWithIndex: FunctorWithIndex$2,
        group: Group,
        heytingAlgebra: HeytingAlgebra,
        hkt: index,
        identity: Identity,
        invariant: Invariant,
        io: IO,
        ioEither: IOEither,
        ioRef: IORef$1,
        joinSemilattice: JoinSemilattice,
        json: Json,
        lattice: Lattice,
        magma: Magma$1,
        map: Map$1,
        meetSemilattice: MeetSemilattice,
        monad: Monad$8,
        monadIO: MonadIO$6,
        monadTask: MonadTask$6,
        monadThrow: MonadThrow$4,
        monoid: Monoid$3,
        naturalTransformation: NaturalTransformation,
        nonEmptyArray: NonEmptyArray,
        number: number,
        option: Option$1,
        optionT: OptionT,
        ord: Ord$5,
        ordering: Ordering,
        pipeable: pipeable$3,
        pointed: Pointed$a,
        predicate: Predicate$1,
        profunctor: Profunctor,
        random: Random,
        reader: Reader,
        readerEither: ReaderEither,
        readerT: ReaderT,
        readerTaskEither: ReaderTaskEither,
        readonlyArray: ReadonlyArray,
        readonlyMap: ReadonlyMap,
        readonlyNonEmptyArray: ReadonlyNonEmptyArray,
        readonlyRecord: ReadonlyRecord,
        readonlySet: ReadonlySet,
        readonlyTuple: ReadonlyTuple,
        readerTask: ReaderTask,
        record: Record,
        refinement: Refinement,
        ring: Ring,
        semigroup: Se,
        semigroupoid: Semigroupoid$1,
        semiring: Semiring,
        separated: Separated$1,
        set: Set$1,
        eq: Eq$6,
        show: Show,
        state: State,
        stateReaderTaskEither: StateReaderTaskEither,
        stateT: StateT,
        store: Store,
        string: string,
        strong: Strong,
        struct: struct,
        task: Task,
        taskEither: TaskEither,
        taskOption: TaskOption,
        taskThese: TaskThese,
        these: These,
        theseT: TheseT,
        traced: Traced,
        traversable: Traversable$2,
        traversableWithIndex: TraversableWithIndex,
        tree: Tree,
        tuple: Tuple,
        unfoldable: Unfoldable,
        validationT: ValidationT,
        'void': _void,
        witherable: Witherable$6,
        writer: Writer,
        writerT: WriterT,
        zero: Zero$5
    });

    var require$$1 = /*@__PURE__*/getAugmentedNamespace(es6);

    var pipeable$1 = {};

    var _function = {};

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEndomorphismMonoid = exports.not = exports.SK = exports.hole = exports.pipe = exports.untupled = exports.tupled = exports.absurd = exports.decrement = exports.increment = exports.tuple = exports.flow = exports.flip = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.constant = exports.unsafeCoerce = exports.identity = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.10.0
     */
    var getBooleanAlgebra = function (B) { return function () { return ({
        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },
        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },
        zero: function () { return B.zero; },
        one: function () { return B.one; },
        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },
        not: function (x) { return function (a) { return B.not(x(a)); }; }
    }); }; };
    exports.getBooleanAlgebra = getBooleanAlgebra;
    /**
     * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.
     *
     * @example
     * import { Predicate, getSemigroup } from 'fp-ts/function'
     * import * as B from 'fp-ts/boolean'
     *
     * const f: Predicate<number> = (n) => n <= 2
     * const g: Predicate<number> = (n) => n >= 0
     *
     * const S1 = getSemigroup(B.SemigroupAll)<number>()
     *
     * assert.deepStrictEqual(S1.concat(f, g)(1), true)
     * assert.deepStrictEqual(S1.concat(f, g)(3), false)
     *
     * const S2 = getSemigroup(B.SemigroupAny)<number>()
     *
     * assert.deepStrictEqual(S2.concat(f, g)(1), true)
     * assert.deepStrictEqual(S2.concat(f, g)(3), true)
     *
     * @category instances
     * @since 2.10.0
     */
    var getSemigroup = function (S) { return function () { return ({
        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }
    }); }; };
    exports.getSemigroup = getSemigroup;
    /**
     * Unary functions form a monoid as long as you can provide a monoid for the codomain.
     *
     * @example
     * import { Predicate } from 'fp-ts/Predicate'
     * import { getMonoid } from 'fp-ts/function'
     * import * as B from 'fp-ts/boolean'
     *
     * const f: Predicate<number> = (n) => n <= 2
     * const g: Predicate<number> = (n) => n >= 0
     *
     * const M1 = getMonoid(B.MonoidAll)<number>()
     *
     * assert.deepStrictEqual(M1.concat(f, g)(1), true)
     * assert.deepStrictEqual(M1.concat(f, g)(3), false)
     *
     * const M2 = getMonoid(B.MonoidAny)<number>()
     *
     * assert.deepStrictEqual(M2.concat(f, g)(1), true)
     * assert.deepStrictEqual(M2.concat(f, g)(3), true)
     *
     * @category instances
     * @since 2.10.0
     */
    var getMonoid = function (M) {
        var getSemigroupM = exports.getSemigroup(M);
        return function () { return ({
            concat: getSemigroupM().concat,
            empty: function () { return M.empty; }
        }); };
    };
    exports.getMonoid = getMonoid;
    /**
     * @category instances
     * @since 2.10.0
     */
    var getSemiring = function (S) { return ({
        add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },
        zero: function () { return S.zero; },
        mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },
        one: function () { return S.one; }
    }); };
    exports.getSemiring = getSemiring;
    /**
     * @category instances
     * @since 2.10.0
     */
    var getRing = function (R) {
        var S = exports.getSemiring(R);
        return {
            add: S.add,
            mul: S.mul,
            one: S.one,
            zero: S.zero,
            sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }
        };
    };
    exports.getRing = getRing;
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var apply = function (a) { return function (f) { return f(a); }; };
    exports.apply = apply;
    /**
     * @since 2.0.0
     */
    function identity(a) {
        return a;
    }
    exports.identity = identity;
    /**
     * @since 2.0.0
     */
    exports.unsafeCoerce = identity;
    /**
     * @since 2.0.0
     */
    function constant(a) {
        return function () { return a; };
    }
    exports.constant = constant;
    /**
     * A thunk that returns always `true`.
     *
     * @since 2.0.0
     */
    exports.constTrue = 
    /*#__PURE__*/
    constant(true);
    /**
     * A thunk that returns always `false`.
     *
     * @since 2.0.0
     */
    exports.constFalse = 
    /*#__PURE__*/
    constant(false);
    /**
     * A thunk that returns always `null`.
     *
     * @since 2.0.0
     */
    exports.constNull = 
    /*#__PURE__*/
    constant(null);
    /**
     * A thunk that returns always `undefined`.
     *
     * @since 2.0.0
     */
    exports.constUndefined = 
    /*#__PURE__*/
    constant(undefined);
    /**
     * A thunk that returns always `void`.
     *
     * @since 2.0.0
     */
    exports.constVoid = exports.constUndefined;
    /**
     * Flips the order of the arguments of a function of two arguments.
     *
     * @since 2.0.0
     */
    function flip(f) {
        return function (b, a) { return f(a, b); };
    }
    exports.flip = flip;
    function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
        switch (arguments.length) {
            case 1:
                return ab;
            case 2:
                return function () {
                    return bc(ab.apply(this, arguments));
                };
            case 3:
                return function () {
                    return cd(bc(ab.apply(this, arguments)));
                };
            case 4:
                return function () {
                    return de(cd(bc(ab.apply(this, arguments))));
                };
            case 5:
                return function () {
                    return ef(de(cd(bc(ab.apply(this, arguments)))));
                };
            case 6:
                return function () {
                    return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
                };
            case 7:
                return function () {
                    return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
                };
            case 8:
                return function () {
                    return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
                };
            case 9:
                return function () {
                    return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
                };
        }
        return;
    }
    exports.flow = flow;
    /**
     * @since 2.0.0
     */
    function tuple() {
        var t = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            t[_i] = arguments[_i];
        }
        return t;
    }
    exports.tuple = tuple;
    /**
     * @since 2.0.0
     */
    function increment(n) {
        return n + 1;
    }
    exports.increment = increment;
    /**
     * @since 2.0.0
     */
    function decrement(n) {
        return n - 1;
    }
    exports.decrement = decrement;
    /**
     * @since 2.0.0
     */
    function absurd(_) {
        throw new Error('Called `absurd` function which should be uncallable');
    }
    exports.absurd = absurd;
    /**
     * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.
     *
     * @example
     * import { tupled } from 'fp-ts/function'
     *
     * const add = tupled((x: number, y: number): number => x + y)
     *
     * assert.strictEqual(add([1, 2]), 3)
     *
     * @since 2.4.0
     */
    function tupled(f) {
        return function (a) { return f.apply(void 0, a); };
    }
    exports.tupled = tupled;
    /**
     * Inverse function of `tupled`
     *
     * @since 2.4.0
     */
    function untupled(f) {
        return function () {
            var a = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                a[_i] = arguments[_i];
            }
            return f(a);
        };
    }
    exports.untupled = untupled;
    function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
        switch (arguments.length) {
            case 1:
                return a;
            case 2:
                return ab(a);
            case 3:
                return bc(ab(a));
            case 4:
                return cd(bc(ab(a)));
            case 5:
                return de(cd(bc(ab(a))));
            case 6:
                return ef(de(cd(bc(ab(a)))));
            case 7:
                return fg(ef(de(cd(bc(ab(a))))));
            case 8:
                return gh(fg(ef(de(cd(bc(ab(a)))))));
            case 9:
                return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
            default:
                var ret = arguments[0];
                for (var i = 1; i < arguments.length; i++) {
                    ret = arguments[i](ret);
                }
                return ret;
        }
    }
    exports.pipe = pipe;
    /**
     * Type hole simulation
     *
     * @since 2.7.0
     */
    exports.hole = absurd;
    /**
     * @since 2.11.0
     */
    var SK = function (_, b) { return b; };
    exports.SK = SK;
    /**
     * Use `Predicate` module instead.
     *
     * @since 2.0.0
     * @deprecated
     */
    function not(predicate) {
        return function (a) { return !predicate(a); };
    }
    exports.not = not;
    /**
     * Use `Endomorphism` module instead.
     *
     * @category instances
     * @since 2.10.0
     * @deprecated
     */
    var getEndomorphismMonoid = function () { return ({
        concat: function (first, second) { return flow(first, second); },
        empty: identity
    }); };
    exports.getEndomorphismMonoid = getEndomorphismMonoid;
    }(_function));

    Object.defineProperty(pipeable$1, "__esModule", { value: true });
    pipeable$1.pipe = pipeable$1.pipeable = void 0;
    var function_1$4 = _function;
    var isFunctor = function (I) { return typeof I.map === 'function'; };
    var isContravariant = function (I) { return typeof I.contramap === 'function'; };
    var isFunctorWithIndex = function (I) { return typeof I.mapWithIndex === 'function'; };
    var isApply = function (I) { return typeof I.ap === 'function'; };
    var isChain = function (I) { return typeof I.chain === 'function'; };
    var isBifunctor = function (I) { return typeof I.bimap === 'function'; };
    var isExtend = function (I) { return typeof I.extend === 'function'; };
    var isFoldable = function (I) { return typeof I.reduce === 'function'; };
    var isFoldableWithIndex = function (I) { return typeof I.reduceWithIndex === 'function'; };
    var isAlt = function (I) { return typeof I.alt === 'function'; };
    var isCompactable = function (I) { return typeof I.compact === 'function'; };
    var isFilterable = function (I) { return typeof I.filter === 'function'; };
    var isFilterableWithIndex = function (I) {
        return typeof I.filterWithIndex === 'function';
    };
    var isProfunctor = function (I) { return typeof I.promap === 'function'; };
    var isSemigroupoid = function (I) { return typeof I.compose === 'function'; };
    var isMonadThrow = function (I) { return typeof I.throwError === 'function'; };
    /** @deprecated */
    function pipeable(I) {
        var r = {};
        if (isFunctor(I)) {
            var map = function (f) { return function (fa) { return I.map(fa, f); }; };
            r.map = map;
        }
        if (isContravariant(I)) {
            var contramap = function (f) { return function (fa) { return I.contramap(fa, f); }; };
            r.contramap = contramap;
        }
        if (isFunctorWithIndex(I)) {
            var mapWithIndex = function (f) { return function (fa) { return I.mapWithIndex(fa, f); }; };
            r.mapWithIndex = mapWithIndex;
        }
        if (isApply(I)) {
            var ap = function (fa) { return function (fab) { return I.ap(fab, fa); }; };
            var apFirst = function (fb) { return function (fa) {
                return I.ap(I.map(fa, function (a) { return function () { return a; }; }), fb);
            }; };
            r.ap = ap;
            r.apFirst = apFirst;
            r.apSecond = function (fb) { return function (fa) {
                return I.ap(I.map(fa, function () { return function (b) { return b; }; }), fb);
            }; };
        }
        if (isChain(I)) {
            var chain = function (f) { return function (ma) { return I.chain(ma, f); }; };
            var chainFirst = function (f) { return function (ma) { return I.chain(ma, function (a) { return I.map(f(a), function () { return a; }); }); }; };
            var flatten = function (mma) { return I.chain(mma, function_1$4.identity); };
            r.chain = chain;
            r.chainFirst = chainFirst;
            r.flatten = flatten;
        }
        if (isBifunctor(I)) {
            var bimap = function (f, g) { return function (fa) { return I.bimap(fa, f, g); }; };
            var mapLeft = function (f) { return function (fa) { return I.mapLeft(fa, f); }; };
            r.bimap = bimap;
            r.mapLeft = mapLeft;
        }
        if (isExtend(I)) {
            var extend = function (f) { return function (wa) { return I.extend(wa, f); }; };
            var duplicate = function (wa) { return I.extend(wa, function_1$4.identity); };
            r.extend = extend;
            r.duplicate = duplicate;
        }
        if (isFoldable(I)) {
            var reduce = function (b, f) { return function (fa) { return I.reduce(fa, b, f); }; };
            var foldMap = function (M) {
                var foldMapM = I.foldMap(M);
                return function (f) { return function (fa) { return foldMapM(fa, f); }; };
            };
            var reduceRight = function (b, f) { return function (fa) { return I.reduceRight(fa, b, f); }; };
            r.reduce = reduce;
            r.foldMap = foldMap;
            r.reduceRight = reduceRight;
        }
        if (isFoldableWithIndex(I)) {
            var reduceWithIndex = function (b, f) { return function (fa) {
                return I.reduceWithIndex(fa, b, f);
            }; };
            var foldMapWithIndex = function (M) {
                var foldMapM = I.foldMapWithIndex(M);
                return function (f) { return function (fa) { return foldMapM(fa, f); }; };
            };
            var reduceRightWithIndex = function (b, f) { return function (fa) {
                return I.reduceRightWithIndex(fa, b, f);
            }; };
            r.reduceWithIndex = reduceWithIndex;
            r.foldMapWithIndex = foldMapWithIndex;
            r.reduceRightWithIndex = reduceRightWithIndex;
        }
        if (isAlt(I)) {
            var alt = function (that) { return function (fa) { return I.alt(fa, that); }; };
            r.alt = alt;
        }
        if (isCompactable(I)) {
            r.compact = I.compact;
            r.separate = I.separate;
        }
        if (isFilterable(I)) {
            var filter = function (predicate) { return function (fa) {
                return I.filter(fa, predicate);
            }; };
            var filterMap = function (f) { return function (fa) { return I.filterMap(fa, f); }; };
            var partition = function (predicate) { return function (fa) {
                return I.partition(fa, predicate);
            }; };
            var partitionMap = function (f) { return function (fa) { return I.partitionMap(fa, f); }; };
            r.filter = filter;
            r.filterMap = filterMap;
            r.partition = partition;
            r.partitionMap = partitionMap;
        }
        if (isFilterableWithIndex(I)) {
            var filterWithIndex = function (predicateWithIndex) { return function (fa) { return I.filterWithIndex(fa, predicateWithIndex); }; };
            var filterMapWithIndex = function (f) { return function (fa) {
                return I.filterMapWithIndex(fa, f);
            }; };
            var partitionWithIndex = function (predicateWithIndex) { return function (fa) { return I.partitionWithIndex(fa, predicateWithIndex); }; };
            var partitionMapWithIndex = function (f) { return function (fa) {
                return I.partitionMapWithIndex(fa, f);
            }; };
            r.filterWithIndex = filterWithIndex;
            r.filterMapWithIndex = filterMapWithIndex;
            r.partitionWithIndex = partitionWithIndex;
            r.partitionMapWithIndex = partitionMapWithIndex;
        }
        if (isProfunctor(I)) {
            var promap = function (f, g) { return function (fa) { return I.promap(fa, f, g); }; };
            r.promap = promap;
        }
        if (isSemigroupoid(I)) {
            var compose = function (that) { return function (fa) { return I.compose(fa, that); }; };
            r.compose = compose;
        }
        if (isMonadThrow(I)) {
            var fromOption = function (onNone) { return function (ma) {
                return ma._tag === 'None' ? I.throwError(onNone()) : I.of(ma.value);
            }; };
            var fromEither = function (ma) {
                return ma._tag === 'Left' ? I.throwError(ma.left) : I.of(ma.right);
            };
            var fromPredicate = function (predicate, onFalse) { return function (a) { return (predicate(a) ? I.of(a) : I.throwError(onFalse(a))); }; };
            var filterOrElse = function (predicate, onFalse) { return function (ma) { return I.chain(ma, function (a) { return (predicate(a) ? I.of(a) : I.throwError(onFalse(a))); }); }; };
            r.fromOption = fromOption;
            r.fromEither = fromEither;
            r.fromPredicate = fromPredicate;
            r.filterOrElse = filterOrElse;
        }
        return r;
    }
    pipeable$1.pipeable = pipeable;
    /**
     * Use [`pipe`](https://gcanti.github.io/fp-ts/modules/function.ts.html#flow) from `function` module instead.
     *
     * @since 2.0.0
     * @deprecated
     */
    pipeable$1.pipe = function_1$4.pipe;

    var __createBinding$3 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault$3 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar$3 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding$3(result, mod, k);
        __setModuleDefault$3(result, mod);
        return result;
    };
    Object.defineProperty(Validate, "__esModule", { value: true });
    Validate.testParams = Validate.testConnection = Validate.validateNodes = Validate.validateNode = Validate.parseJSON = void 0;
    const Types_1 = Types;
    const parsedops = __importStar$3(require$$5);
    const fp_ts_1$1 = require$$1;
    const pipeable_1 = pipeable$1;
    function parseJSON(data) {
        return pipeable_1.pipe(fp_ts_1$1.either.tryCatch(() => JSON.parse(data), e => (e instanceof Error ? e : new Error('couldn\'t parse json'))), fp_ts_1$1.either.mapLeft(e => e.message), fp_ts_1$1.either.chain(d => validateNode(d)));
    }
    Validate.parseJSON = parseJSON;
    function validateNode(node) {
        return pipeable_1.pipe([node], validateNodes, fp_ts_1$1.either.map(ns => ns[0]));
    }
    Validate.validateNode = validateNode;
    function validateNodes(nodes) {
        return fp_ts_1$1.array.array.traverse(fp_ts_1$1.either.either)(nodes, n => pipeable_1.pipe(fp_ts_1$1.either.right(n), fp_ts_1$1.either.chain(n => n.type in parsedops ? fp_ts_1$1.either.right(n) : fp_ts_1$1.either.left("type '" + n.type + "' does not exist")), fp_ts_1$1.either.chain(n => parsedops[n.type].type == n.family ? fp_ts_1$1.either.right(n) : fp_ts_1$1.either.left("type '" + n.family + "' is not correct for '" + n.type + "'")), fp_ts_1$1.either.chain(n => parsedops[n.type].type == n.family ? fp_ts_1$1.either.right(n) : fp_ts_1$1.either.left("type '" + n.family + "' is not correct for '" + n.type + "'")), fp_ts_1$1.either.chainFirst(n => testParams(n.type, n.params)), fp_ts_1$1.either.chain(n => n.connections.length < parsedops[n.type]['minInputs'] ? fp_ts_1$1.either.left("too few inputs for node '" + n.type + "'") : fp_ts_1$1.either.right(n)), fp_ts_1$1.either.chain(n => n.connections.length > parsedops[n.type]['maxInputs'] ? fp_ts_1$1.either.left("too many inputs for node '" + n.type + "'") : fp_ts_1$1.either.right(n)), fp_ts_1$1.either.chainFirst(n => fp_ts_1$1.array.array.traverse(fp_ts_1$1.either.either)(n.connections, c => testConnection(n.type, n.family, c)))));
    }
    Validate.validateNodes = validateNodes;
    function testConnection(type, family, connection) {
        return connection === undefined ? fp_ts_1$1.either.left("connection undefined for " + type) :
            (connection.family == family || family == "COMP" || connection.family == "COMP" ?
                validateNode(connection) :
                fp_ts_1$1.either.left("expected '" + family + "' as '" + type + "' child but got '" + connection.family + "'"));
    }
    Validate.testConnection = testConnection;
    function testParams(type, params) {
        return fp_ts_1$1.array.array.traverse(fp_ts_1$1.either.either)(Object.entries(params), ([n, p]) => testParam(type, n, p));
    }
    Validate.testParams = testParams;
    function isIParamAny(param) {
        return param.type !== undefined;
    }
    function testParam(type, name, param) {
        return pipeable_1.pipe(fp_ts_1$1.either.right(param), fp_ts_1$1.either.chain(p => p === undefined ?
            fp_ts_1$1.either.left("param " + name + " undefined in '" + type + "'") : fp_ts_1$1.either.right(p)), fp_ts_1$1.either.chain(p => (name in parsedops[type].pars) || type == "baseCOMP" ?
            fp_ts_1$1.either.right(p) : fp_ts_1$1.either.left("param '" + name + "' does not exist for type '" + type + "'")), fp_ts_1$1.either.chain(p => {
            if (typeof p === 'string') {
                let poptype = parsedops[type].pars[name].type;
                if (poptype === "string") {
                    return fp_ts_1$1.either.right({ type: "string", value0: [p.toString()] });
                }
                else if (poptype === "menu") {
                    let idx = parsedops[type].pars[name].menuitems.indexOf(p);
                    return idx >= 0 ?
                        fp_ts_1$1.either.right({ type: "menu", value0: [idx.toString()] }) :
                        fp_ts_1$1.either.left("invalid menu parameter " + p + " for op " + type);
                }
                else {
                    return fp_ts_1$1.either.left("param type is not correct for " + type + "." + name);
                }
            }
            else if (typeof p === 'number' && (parsedops[type].pars[name].type == "number" || parsedops[type].pars[name].type == "float")) {
                return fp_ts_1$1.either.right({ type: parsedops[type].pars[name].type, value0: [p.toString()] });
            }
            else if (isIParamAny(p)) {
                return type != "baseCOMP" && p.type !== parsedops[type].pars[name].type &&
                    !(parsedops[type].pars[name].type == "OP" && Types_1.OPTypes.indexOf(p.type) > -1) ?
                    fp_ts_1$1.either.left("param type is not correct for '" + type + "." + name + "'") : fp_ts_1$1.either.right(p);
            }
            else {
                return fp_ts_1$1.either.left("param type is not correct for '" + type + "." + name + "'");
            }
        }), fp_ts_1$1.either.chainFirst(p => pipeable_1.pipe(p.value0, fp_ts_1$1.array.filter(val => !(typeof val === "string")), vs => fp_ts_1$1.array.array.traverse(fp_ts_1$1.either.either)(vs, validateNode))));
    }

    var _JSON = {};

    var toStr$4 = Object.prototype.toString;

    var isArguments$2 = function isArguments(value) {
    	var str = toStr$4.call(value);
    	var isArgs = str === '[object Arguments]';
    	if (!isArgs) {
    		isArgs = str !== '[object Array]' &&
    			value !== null &&
    			typeof value === 'object' &&
    			typeof value.length === 'number' &&
    			value.length >= 0 &&
    			toStr$4.call(value.callee) === '[object Function]';
    	}
    	return isArgs;
    };

    var keysShim$1;
    if (!Object.keys) {
    	// modified from https://github.com/es-shims/es5-shim
    	var has$1 = Object.prototype.hasOwnProperty;
    	var toStr$3 = Object.prototype.toString;
    	var isArgs$1 = isArguments$2; // eslint-disable-line global-require
    	var isEnumerable = Object.prototype.propertyIsEnumerable;
    	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
    	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
    	var dontEnums = [
    		'toString',
    		'toLocaleString',
    		'valueOf',
    		'hasOwnProperty',
    		'isPrototypeOf',
    		'propertyIsEnumerable',
    		'constructor'
    	];
    	var equalsConstructorPrototype = function (o) {
    		var ctor = o.constructor;
    		return ctor && ctor.prototype === o;
    	};
    	var excludedKeys = {
    		$applicationCache: true,
    		$console: true,
    		$external: true,
    		$frame: true,
    		$frameElement: true,
    		$frames: true,
    		$innerHeight: true,
    		$innerWidth: true,
    		$onmozfullscreenchange: true,
    		$onmozfullscreenerror: true,
    		$outerHeight: true,
    		$outerWidth: true,
    		$pageXOffset: true,
    		$pageYOffset: true,
    		$parent: true,
    		$scrollLeft: true,
    		$scrollTop: true,
    		$scrollX: true,
    		$scrollY: true,
    		$self: true,
    		$webkitIndexedDB: true,
    		$webkitStorageInfo: true,
    		$window: true
    	};
    	var hasAutomationEqualityBug = (function () {
    		/* global window */
    		if (typeof window === 'undefined') { return false; }
    		for (var k in window) {
    			try {
    				if (!excludedKeys['$' + k] && has$1.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
    					try {
    						equalsConstructorPrototype(window[k]);
    					} catch (e) {
    						return true;
    					}
    				}
    			} catch (e) {
    				return true;
    			}
    		}
    		return false;
    	}());
    	var equalsConstructorPrototypeIfNotBuggy = function (o) {
    		/* global window */
    		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
    			return equalsConstructorPrototype(o);
    		}
    		try {
    			return equalsConstructorPrototype(o);
    		} catch (e) {
    			return false;
    		}
    	};

    	keysShim$1 = function keys(object) {
    		var isObject = object !== null && typeof object === 'object';
    		var isFunction = toStr$3.call(object) === '[object Function]';
    		var isArguments = isArgs$1(object);
    		var isString = isObject && toStr$3.call(object) === '[object String]';
    		var theKeys = [];

    		if (!isObject && !isFunction && !isArguments) {
    			throw new TypeError('Object.keys called on a non-object');
    		}

    		var skipProto = hasProtoEnumBug && isFunction;
    		if (isString && object.length > 0 && !has$1.call(object, 0)) {
    			for (var i = 0; i < object.length; ++i) {
    				theKeys.push(String(i));
    			}
    		}

    		if (isArguments && object.length > 0) {
    			for (var j = 0; j < object.length; ++j) {
    				theKeys.push(String(j));
    			}
    		} else {
    			for (var name in object) {
    				if (!(skipProto && name === 'prototype') && has$1.call(object, name)) {
    					theKeys.push(String(name));
    				}
    			}
    		}

    		if (hasDontEnumBug) {
    			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

    			for (var k = 0; k < dontEnums.length; ++k) {
    				if (!(skipConstructor && dontEnums[k] === 'constructor') && has$1.call(object, dontEnums[k])) {
    					theKeys.push(dontEnums[k]);
    				}
    			}
    		}
    		return theKeys;
    	};
    }
    var implementation$8 = keysShim$1;

    var slice$1 = Array.prototype.slice;
    var isArgs = isArguments$2;

    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) { return origKeys(o); } : implementation$8;

    var originalKeys = Object.keys;

    keysShim.shim = function shimObjectKeys() {
    	if (Object.keys) {
    		var keysWorksWithArguments = (function () {
    			// Safari 5.0 bug
    			var args = Object.keys(arguments);
    			return args && args.length === arguments.length;
    		}(1, 2));
    		if (!keysWorksWithArguments) {
    			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
    				if (isArgs(object)) {
    					return originalKeys(slice$1.call(object));
    				}
    				return originalKeys(object);
    			};
    		}
    	} else {
    		Object.keys = keysShim;
    	}
    	return Object.keys || keysShim;
    };

    var objectKeys$1 = keysShim;

    /* eslint complexity: [2, 18], max-statements: [2, 33] */
    var shams$1 = function hasSymbols() {
    	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
    	if (typeof Symbol.iterator === 'symbol') { return true; }

    	var obj = {};
    	var sym = Symbol('test');
    	var symObj = Object(sym);
    	if (typeof sym === 'string') { return false; }

    	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
    	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

    	// temp disabled per https://github.com/ljharb/object.assign/issues/17
    	// if (sym instanceof Symbol) { return false; }
    	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    	// if (!(symObj instanceof Symbol)) { return false; }

    	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
    	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

    	var symVal = 42;
    	obj[sym] = symVal;
    	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

    	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

    	var syms = Object.getOwnPropertySymbols(obj);
    	if (syms.length !== 1 || syms[0] !== sym) { return false; }

    	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

    	if (typeof Object.getOwnPropertyDescriptor === 'function') {
    		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
    	}

    	return true;
    };

    var hasSymbols$3 = shams$1;

    var shams = function hasToStringTagShams() {
    	return hasSymbols$3() && !!Symbol.toStringTag;
    };

    var origSymbol = typeof Symbol !== 'undefined' && Symbol;
    var hasSymbolSham = shams$1;

    var hasSymbols$2 = function hasNativeSymbols() {
    	if (typeof origSymbol !== 'function') { return false; }
    	if (typeof Symbol !== 'function') { return false; }
    	if (typeof origSymbol('foo') !== 'symbol') { return false; }
    	if (typeof Symbol('bar') !== 'symbol') { return false; }

    	return hasSymbolSham();
    };

    /* eslint no-invalid-this: 1 */

    var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
    var slice = Array.prototype.slice;
    var toStr$2 = Object.prototype.toString;
    var funcType = '[object Function]';

    var implementation$7 = function bind(that) {
        var target = this;
        if (typeof target !== 'function' || toStr$2.call(target) !== funcType) {
            throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);

        var bound;
        var binder = function () {
            if (this instanceof bound) {
                var result = target.apply(
                    this,
                    args.concat(slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;
            } else {
                return target.apply(
                    that,
                    args.concat(slice.call(arguments))
                );
            }
        };

        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

        if (target.prototype) {
            var Empty = function Empty() {};
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
        }

        return bound;
    };

    var implementation$6 = implementation$7;

    var functionBind = Function.prototype.bind || implementation$6;

    var bind$2 = functionBind;

    var src = bind$2.call(Function.call, Object.prototype.hasOwnProperty);

    var undefined$1;

    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError$1 = TypeError;

    // eslint-disable-next-line consistent-return
    var getEvalledConstructor = function (expressionSyntax) {
    	try {
    		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
    	} catch (e) {}
    };

    var $gOPD$1 = Object.getOwnPropertyDescriptor;
    if ($gOPD$1) {
    	try {
    		$gOPD$1({}, '');
    	} catch (e) {
    		$gOPD$1 = null; // this is IE 8, which has a broken gOPD
    	}
    }

    var throwTypeError = function () {
    	throw new $TypeError$1();
    };
    var ThrowTypeError = $gOPD$1
    	? (function () {
    		try {
    			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    			arguments.callee; // IE 8 does not throw here
    			return throwTypeError;
    		} catch (calleeThrows) {
    			try {
    				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
    				return $gOPD$1(arguments, 'callee').get;
    			} catch (gOPDthrows) {
    				return throwTypeError;
    			}
    		}
    	}())
    	: throwTypeError;

    var hasSymbols$1 = hasSymbols$2();

    var getProto$1 = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

    var needsEval = {};

    var TypedArray = typeof Uint8Array === 'undefined' ? undefined$1 : getProto$1(Uint8Array);

    var INTRINSICS = {
    	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
    	'%Array%': Array,
    	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
    	'%ArrayIteratorPrototype%': hasSymbols$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
    	'%AsyncFromSyncIteratorPrototype%': undefined$1,
    	'%AsyncFunction%': needsEval,
    	'%AsyncGenerator%': needsEval,
    	'%AsyncGeneratorFunction%': needsEval,
    	'%AsyncIteratorPrototype%': needsEval,
    	'%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
    	'%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
    	'%Boolean%': Boolean,
    	'%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
    	'%Date%': Date,
    	'%decodeURI%': decodeURI,
    	'%decodeURIComponent%': decodeURIComponent,
    	'%encodeURI%': encodeURI,
    	'%encodeURIComponent%': encodeURIComponent,
    	'%Error%': Error,
    	'%eval%': eval, // eslint-disable-line no-eval
    	'%EvalError%': EvalError,
    	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
    	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
    	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
    	'%Function%': $Function,
    	'%GeneratorFunction%': needsEval,
    	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
    	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
    	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
    	'%isFinite%': isFinite,
    	'%isNaN%': isNaN,
    	'%IteratorPrototype%': hasSymbols$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
    	'%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
    	'%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
    	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols$1 ? undefined$1 : getProto$1(new Map()[Symbol.iterator]()),
    	'%Math%': Math,
    	'%Number%': Number,
    	'%Object%': Object,
    	'%parseFloat%': parseFloat,
    	'%parseInt%': parseInt,
    	'%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
    	'%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
    	'%RangeError%': RangeError,
    	'%ReferenceError%': ReferenceError,
    	'%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
    	'%RegExp%': RegExp,
    	'%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
    	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols$1 ? undefined$1 : getProto$1(new Set()[Symbol.iterator]()),
    	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
    	'%String%': String,
    	'%StringIteratorPrototype%': hasSymbols$1 ? getProto$1(''[Symbol.iterator]()) : undefined$1,
    	'%Symbol%': hasSymbols$1 ? Symbol : undefined$1,
    	'%SyntaxError%': $SyntaxError,
    	'%ThrowTypeError%': ThrowTypeError,
    	'%TypedArray%': TypedArray,
    	'%TypeError%': $TypeError$1,
    	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
    	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
    	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
    	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
    	'%URIError%': URIError,
    	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
    	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
    	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet
    };

    var doEval = function doEval(name) {
    	var value;
    	if (name === '%AsyncFunction%') {
    		value = getEvalledConstructor('async function () {}');
    	} else if (name === '%GeneratorFunction%') {
    		value = getEvalledConstructor('function* () {}');
    	} else if (name === '%AsyncGeneratorFunction%') {
    		value = getEvalledConstructor('async function* () {}');
    	} else if (name === '%AsyncGenerator%') {
    		var fn = doEval('%AsyncGeneratorFunction%');
    		if (fn) {
    			value = fn.prototype;
    		}
    	} else if (name === '%AsyncIteratorPrototype%') {
    		var gen = doEval('%AsyncGenerator%');
    		if (gen) {
    			value = getProto$1(gen.prototype);
    		}
    	}

    	INTRINSICS[name] = value;

    	return value;
    };

    var LEGACY_ALIASES = {
    	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
    	'%ArrayPrototype%': ['Array', 'prototype'],
    	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
    	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
    	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
    	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
    	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
    	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
    	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
    	'%BooleanPrototype%': ['Boolean', 'prototype'],
    	'%DataViewPrototype%': ['DataView', 'prototype'],
    	'%DatePrototype%': ['Date', 'prototype'],
    	'%ErrorPrototype%': ['Error', 'prototype'],
    	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
    	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
    	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
    	'%FunctionPrototype%': ['Function', 'prototype'],
    	'%Generator%': ['GeneratorFunction', 'prototype'],
    	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
    	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
    	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
    	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
    	'%JSONParse%': ['JSON', 'parse'],
    	'%JSONStringify%': ['JSON', 'stringify'],
    	'%MapPrototype%': ['Map', 'prototype'],
    	'%NumberPrototype%': ['Number', 'prototype'],
    	'%ObjectPrototype%': ['Object', 'prototype'],
    	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
    	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
    	'%PromisePrototype%': ['Promise', 'prototype'],
    	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
    	'%Promise_all%': ['Promise', 'all'],
    	'%Promise_reject%': ['Promise', 'reject'],
    	'%Promise_resolve%': ['Promise', 'resolve'],
    	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
    	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
    	'%RegExpPrototype%': ['RegExp', 'prototype'],
    	'%SetPrototype%': ['Set', 'prototype'],
    	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
    	'%StringPrototype%': ['String', 'prototype'],
    	'%SymbolPrototype%': ['Symbol', 'prototype'],
    	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
    	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
    	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
    	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
    	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
    	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
    	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
    	'%URIErrorPrototype%': ['URIError', 'prototype'],
    	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
    	'%WeakSetPrototype%': ['WeakSet', 'prototype']
    };

    var bind$1 = functionBind;
    var hasOwn = src;
    var $concat = bind$1.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind$1.call(Function.apply, Array.prototype.splice);
    var $replace = bind$1.call(Function.call, String.prototype.replace);
    var $strSlice = bind$1.call(Function.call, String.prototype.slice);

    /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
    var stringToPath = function stringToPath(string) {
    	var first = $strSlice(string, 0, 1);
    	var last = $strSlice(string, -1);
    	if (first === '%' && last !== '%') {
    		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
    	} else if (last === '%' && first !== '%') {
    		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
    	}
    	var result = [];
    	$replace(string, rePropName, function (match, number, quote, subString) {
    		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
    	});
    	return result;
    };
    /* end adaptation */

    var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    	var intrinsicName = name;
    	var alias;
    	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    		alias = LEGACY_ALIASES[intrinsicName];
    		intrinsicName = '%' + alias[0] + '%';
    	}

    	if (hasOwn(INTRINSICS, intrinsicName)) {
    		var value = INTRINSICS[intrinsicName];
    		if (value === needsEval) {
    			value = doEval(intrinsicName);
    		}
    		if (typeof value === 'undefined' && !allowMissing) {
    			throw new $TypeError$1('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    		}

    		return {
    			alias: alias,
    			name: intrinsicName,
    			value: value
    		};
    	}

    	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
    };

    var getIntrinsic = function GetIntrinsic(name, allowMissing) {
    	if (typeof name !== 'string' || name.length === 0) {
    		throw new $TypeError$1('intrinsic name must be a non-empty string');
    	}
    	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    		throw new $TypeError$1('"allowMissing" argument must be a boolean');
    	}

    	var parts = stringToPath(name);
    	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

    	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
    	var intrinsicRealName = intrinsic.name;
    	var value = intrinsic.value;
    	var skipFurtherCaching = false;

    	var alias = intrinsic.alias;
    	if (alias) {
    		intrinsicBaseName = alias[0];
    		$spliceApply(parts, $concat([0, 1], alias));
    	}

    	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    		var part = parts[i];
    		var first = $strSlice(part, 0, 1);
    		var last = $strSlice(part, -1);
    		if (
    			(
    				(first === '"' || first === "'" || first === '`')
    				|| (last === '"' || last === "'" || last === '`')
    			)
    			&& first !== last
    		) {
    			throw new $SyntaxError('property names with quotes must have matching quotes');
    		}
    		if (part === 'constructor' || !isOwn) {
    			skipFurtherCaching = true;
    		}

    		intrinsicBaseName += '.' + part;
    		intrinsicRealName = '%' + intrinsicBaseName + '%';

    		if (hasOwn(INTRINSICS, intrinsicRealName)) {
    			value = INTRINSICS[intrinsicRealName];
    		} else if (value != null) {
    			if (!(part in value)) {
    				if (!allowMissing) {
    					throw new $TypeError$1('base intrinsic for ' + name + ' exists, but the property is not available.');
    				}
    				return void undefined$1;
    			}
    			if ($gOPD$1 && (i + 1) >= parts.length) {
    				var desc = $gOPD$1(value, part);
    				isOwn = !!desc;

    				// By convention, when a data property is converted to an accessor
    				// property to emulate a data property that does not suffer from
    				// the override mistake, that accessor's getter is marked with
    				// an `originalValue` property. Here, when we detect this, we
    				// uphold the illusion by pretending to see that original data
    				// property, i.e., returning the value rather than the getter
    				// itself.
    				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
    					value = desc.get;
    				} else {
    					value = value[part];
    				}
    			} else {
    				isOwn = hasOwn(value, part);
    				value = value[part];
    			}

    			if (isOwn && !skipFurtherCaching) {
    				INTRINSICS[intrinsicRealName] = value;
    			}
    		}
    	}
    	return value;
    };

    var callBind$3 = {exports: {}};

    (function (module) {

    var bind = functionBind;
    var GetIntrinsic = getIntrinsic;

    var $apply = GetIntrinsic('%Function.prototype.apply%');
    var $call = GetIntrinsic('%Function.prototype.call%');
    var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

    var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
    var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
    var $max = GetIntrinsic('%Math.max%');

    if ($defineProperty) {
    	try {
    		$defineProperty({}, 'a', { value: 1 });
    	} catch (e) {
    		// IE 8 has a broken defineProperty
    		$defineProperty = null;
    	}
    }

    module.exports = function callBind(originalFunction) {
    	var func = $reflectApply(bind, $call, arguments);
    	if ($gOPD && $defineProperty) {
    		var desc = $gOPD(func, 'length');
    		if (desc.configurable) {
    			// original length, plus the receiver, minus any additional arguments (after the receiver)
    			$defineProperty(
    				func,
    				'length',
    				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
    			);
    		}
    	}
    	return func;
    };

    var applyBind = function applyBind() {
    	return $reflectApply(bind, $apply, arguments);
    };

    if ($defineProperty) {
    	$defineProperty(module.exports, 'apply', { value: applyBind });
    } else {
    	module.exports.apply = applyBind;
    }
    }(callBind$3));

    var GetIntrinsic = getIntrinsic;

    var callBind$2 = callBind$3.exports;

    var $indexOf = callBind$2(GetIntrinsic('String.prototype.indexOf'));

    var callBound$2 = function callBoundIntrinsic(name, allowMissing) {
    	var intrinsic = GetIntrinsic(name, !!allowMissing);
    	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
    		return callBind$2(intrinsic);
    	}
    	return intrinsic;
    };

    var hasToStringTag$2 = shams();
    var callBound$1 = callBound$2;

    var $toString$1 = callBound$1('Object.prototype.toString');

    var isStandardArguments = function isArguments(value) {
    	if (hasToStringTag$2 && value && typeof value === 'object' && Symbol.toStringTag in value) {
    		return false;
    	}
    	return $toString$1(value) === '[object Arguments]';
    };

    var isLegacyArguments = function isArguments(value) {
    	if (isStandardArguments(value)) {
    		return true;
    	}
    	return value !== null &&
    		typeof value === 'object' &&
    		typeof value.length === 'number' &&
    		value.length >= 0 &&
    		$toString$1(value) !== '[object Array]' &&
    		$toString$1(value.callee) === '[object Function]';
    };

    var supportsStandardArguments = (function () {
    	return isStandardArguments(arguments);
    }());

    isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

    var isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

    var keys = objectKeys$1;
    var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

    var toStr$1 = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var origDefineProperty = Object.defineProperty;

    var isFunction = function (fn) {
    	return typeof fn === 'function' && toStr$1.call(fn) === '[object Function]';
    };

    var arePropertyDescriptorsSupported = function () {
    	var obj = {};
    	try {
    		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
    		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
    		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
    			return false;
    		}
    		return obj.x === obj;
    	} catch (e) { /* this is IE 8. */
    		return false;
    	}
    };
    var supportsDescriptors$2 = origDefineProperty && arePropertyDescriptorsSupported();

    var defineProperty$1 = function (object, name, value, predicate) {
    	if (name in object && (!isFunction(predicate) || !predicate())) {
    		return;
    	}
    	if (supportsDescriptors$2) {
    		origDefineProperty(object, name, {
    			configurable: true,
    			enumerable: false,
    			value: value,
    			writable: true
    		});
    	} else {
    		object[name] = value;
    	}
    };

    var defineProperties = function (object, map) {
    	var predicates = arguments.length > 2 ? arguments[2] : {};
    	var props = keys(map);
    	if (hasSymbols) {
    		props = concat.call(props, Object.getOwnPropertySymbols(map));
    	}
    	for (var i = 0; i < props.length; i += 1) {
    		defineProperty$1(object, props[i], map[props[i]], predicates[props[i]]);
    	}
    };

    defineProperties.supportsDescriptors = !!supportsDescriptors$2;

    var defineProperties_1 = defineProperties;

    var numberIsNaN = function (value) {
    	return value !== value;
    };

    var implementation$5 = function is(a, b) {
    	if (a === 0 && b === 0) {
    		return 1 / a === 1 / b;
    	}
    	if (a === b) {
    		return true;
    	}
    	if (numberIsNaN(a) && numberIsNaN(b)) {
    		return true;
    	}
    	return false;
    };

    var implementation$4 = implementation$5;

    var polyfill$2 = function getPolyfill() {
    	return typeof Object.is === 'function' ? Object.is : implementation$4;
    };

    var getPolyfill$3 = polyfill$2;
    var define$2 = defineProperties_1;

    var shim$3 = function shimObjectIs() {
    	var polyfill = getPolyfill$3();
    	define$2(Object, { is: polyfill }, {
    		is: function testObjectIs() {
    			return Object.is !== polyfill;
    		}
    	});
    	return polyfill;
    };

    var define$1 = defineProperties_1;
    var callBind$1 = callBind$3.exports;

    var implementation$3 = implementation$5;
    var getPolyfill$2 = polyfill$2;
    var shim$2 = shim$3;

    var polyfill$1 = callBind$1(getPolyfill$2(), Object);

    define$1(polyfill$1, {
    	getPolyfill: getPolyfill$2,
    	implementation: implementation$3,
    	shim: shim$2
    });

    var objectIs = polyfill$1;

    var callBound = callBound$2;
    var hasToStringTag$1 = shams();
    var has;
    var $exec;
    var isRegexMarker;
    var badStringifier;

    if (hasToStringTag$1) {
    	has = callBound('Object.prototype.hasOwnProperty');
    	$exec = callBound('RegExp.prototype.exec');
    	isRegexMarker = {};

    	var throwRegexMarker = function () {
    		throw isRegexMarker;
    	};
    	badStringifier = {
    		toString: throwRegexMarker,
    		valueOf: throwRegexMarker
    	};

    	if (typeof Symbol.toPrimitive === 'symbol') {
    		badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    	}
    }

    var $toString = callBound('Object.prototype.toString');
    var gOPD$1 = Object.getOwnPropertyDescriptor;
    var regexClass = '[object RegExp]';

    var isRegex$1 = hasToStringTag$1
    	// eslint-disable-next-line consistent-return
    	? function isRegex(value) {
    		if (!value || typeof value !== 'object') {
    			return false;
    		}

    		var descriptor = gOPD$1(value, 'lastIndex');
    		var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
    		if (!hasLastIndexDataProperty) {
    			return false;
    		}

    		try {
    			$exec(value, badStringifier);
    		} catch (e) {
    			return e === isRegexMarker;
    		}
    	}
    	: function isRegex(value) {
    		// In older browsers, typeof regex incorrectly returns 'function'
    		if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
    			return false;
    		}

    		return $toString(value) === regexClass;
    	};

    var $Object = Object;
    var $TypeError = TypeError;

    var implementation$2 = function flags() {
    	if (this != null && this !== $Object(this)) {
    		throw new $TypeError('RegExp.prototype.flags getter called on non-object');
    	}
    	var result = '';
    	if (this.hasIndices) {
    		result += 'd';
    	}
    	if (this.global) {
    		result += 'g';
    	}
    	if (this.ignoreCase) {
    		result += 'i';
    	}
    	if (this.multiline) {
    		result += 'm';
    	}
    	if (this.dotAll) {
    		result += 's';
    	}
    	if (this.unicode) {
    		result += 'u';
    	}
    	if (this.sticky) {
    		result += 'y';
    	}
    	return result;
    };

    var implementation$1 = implementation$2;

    var supportsDescriptors$1 = defineProperties_1.supportsDescriptors;
    var $gOPD = Object.getOwnPropertyDescriptor;

    var polyfill = function getPolyfill() {
    	if (supportsDescriptors$1 && (/a/mig).flags === 'gim') {
    		var descriptor = $gOPD(RegExp.prototype, 'flags');
    		if (descriptor && typeof descriptor.get === 'function' && typeof (/a/).dotAll === 'boolean') {
    			return descriptor.get;
    		}
    	}
    	return implementation$1;
    };

    var supportsDescriptors = defineProperties_1.supportsDescriptors;
    var getPolyfill$1 = polyfill;
    var gOPD = Object.getOwnPropertyDescriptor;
    var defineProperty = Object.defineProperty;
    var TypeErr = TypeError;
    var getProto = Object.getPrototypeOf;
    var regex = /a/;

    var shim$1 = function shimFlags() {
    	if (!supportsDescriptors || !getProto) {
    		throw new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
    	}
    	var polyfill = getPolyfill$1();
    	var proto = getProto(regex);
    	var descriptor = gOPD(proto, 'flags');
    	if (!descriptor || descriptor.get !== polyfill) {
    		defineProperty(proto, 'flags', {
    			configurable: true,
    			enumerable: false,
    			get: polyfill
    		});
    	}
    	return polyfill;
    };

    var define = defineProperties_1;
    var callBind = callBind$3.exports;

    var implementation = implementation$2;
    var getPolyfill = polyfill;
    var shim = shim$1;

    var flagsBound = callBind(getPolyfill());

    define(flagsBound, {
    	getPolyfill: getPolyfill,
    	implementation: implementation,
    	shim: shim
    });

    var regexp_prototype_flags = flagsBound;

    var getDay = Date.prototype.getDay;
    var tryDateObject = function tryDateGetDayCall(value) {
    	try {
    		getDay.call(value);
    		return true;
    	} catch (e) {
    		return false;
    	}
    };

    var toStr = Object.prototype.toString;
    var dateClass = '[object Date]';
    var hasToStringTag = shams();

    var isDateObject = function isDateObject(value) {
    	if (typeof value !== 'object' || value === null) {
    		return false;
    	}
    	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
    };

    var objectKeys = objectKeys$1;
    var isArguments = isArguments$1;
    var is = objectIs;
    var isRegex = isRegex$1;
    var flags = regexp_prototype_flags;
    var isDate = isDateObject;

    var getTime = Date.prototype.getTime;

    function deepEqual(actual, expected, options) {
      var opts = options || {};

      // 7.1. All identical values are equivalent, as determined by ===.
      if (opts.strict ? is(actual, expected) : actual === expected) {
        return true;
      }

      // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.
      if (!actual || !expected || (typeof actual !== 'object' && typeof expected !== 'object')) {
        return opts.strict ? is(actual, expected) : actual == expected;
      }

      /*
       * 7.4. For all other Object pairs, including Array objects, equivalence is
       * determined by having the same number of owned properties (as verified
       * with Object.prototype.hasOwnProperty.call), the same set of keys
       * (although not necessarily the same order), equivalent values for every
       * corresponding key, and an identical 'prototype' property. Note: this
       * accounts for both named and indexed properties on Arrays.
       */
      // eslint-disable-next-line no-use-before-define
      return objEquiv(actual, expected, opts);
    }

    function isUndefinedOrNull(value) {
      return value === null || value === undefined;
    }

    function isBuffer(x) {
      if (!x || typeof x !== 'object' || typeof x.length !== 'number') {
        return false;
      }
      if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
        return false;
      }
      if (x.length > 0 && typeof x[0] !== 'number') {
        return false;
      }
      return true;
    }

    function objEquiv(a, b, opts) {
      /* eslint max-statements: [2, 50] */
      var i, key;
      if (typeof a !== typeof b) { return false; }
      if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) { return false; }

      // an identical 'prototype' property.
      if (a.prototype !== b.prototype) { return false; }

      if (isArguments(a) !== isArguments(b)) { return false; }

      var aIsRegex = isRegex(a);
      var bIsRegex = isRegex(b);
      if (aIsRegex !== bIsRegex) { return false; }
      if (aIsRegex || bIsRegex) {
        return a.source === b.source && flags(a) === flags(b);
      }

      if (isDate(a) && isDate(b)) {
        return getTime.call(a) === getTime.call(b);
      }

      var aIsBuffer = isBuffer(a);
      var bIsBuffer = isBuffer(b);
      if (aIsBuffer !== bIsBuffer) { return false; }
      if (aIsBuffer || bIsBuffer) { // && would work too, because both are true or both false here
        if (a.length !== b.length) { return false; }
        for (i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) { return false; }
        }
        return true;
      }

      if (typeof a !== typeof b) { return false; }

      try {
        var ka = objectKeys(a);
        var kb = objectKeys(b);
      } catch (e) { // happens when one is a string literal and the other isn't
        return false;
      }
      // having the same number of owned properties (keys incorporates hasOwnProperty)
      if (ka.length !== kb.length) { return false; }

      // the same set of keys (although not necessarily the same order),
      ka.sort();
      kb.sort();
      // ~~~cheap key test
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] != kb[i]) { return false; }
      }
      // equivalent values for every corresponding key, and ~~~possibly expensive deep test
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!deepEqual(a[key], b[key], opts)) { return false; }
      }

      return true;
    }

    var deepEqual_1 = deepEqual;

    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(_JSON, "__esModule", { value: true });
    _JSON.nodesToJSON = _JSON.nodeToJSON = void 0;
    const deep_equal_1 = __importDefault(deepEqual_1);
    const fp_ts_1 = require$$1;
    function nodedictout(nd) {
        let ops = {};
        for (let optype in nd) {
            Object.entries(nd[optype]).forEach((v, idx) => ops[dictname(optype, v[0])] = v[1]);
        }
        return JSON.stringify(ops);
    }
    function dictname(optype, opidx) {
        return "/" + optype + "_" + opidx;
    }
    function nodeToJSON(node) {
        return nodesToJSON([node]);
    }
    _JSON.nodeToJSON = nodeToJSON;
    function nodesToJSON(nodes) {
        return nodedictout(nodes.reduce((acc, val) => addToNodeDict(acc, val), {}));
    }
    _JSON.nodesToJSON = nodesToJSON;
    function instanceofFBTargetNode(node) {
        return 'selects' in node;
    }
    function instanceofFBNode(node) {
        return 'id' in node;
    }
    function addToNodeDict(nodedict, node) {
        addNode(nodedict, node);
        return nodedict;
    }
    function addNode(nodedict, node) {
        let parsednode = Object.assign({
            ty: node.type,
            optype: node.family,
            parameters: fp_ts_1.array.array.reduce(Object.keys(node.params), {}, (acc, p) => addParameter(nodedict, acc, p, node.params[p])),
            connections: [],
            commands: node.actions.map(addAction()),
        }, fp_ts_1.option.isNone(node.text) ? {} : { text: node.text.value }, fp_ts_1.option.isNone(node.unique) ? {} : { unique: node.unique.value });
        if (instanceofFBNode(node)) {
            parsednode.fbid = node.id;
        }
        for (let n of node.connections) {
            let child = addNode(nodedict, n);
            parsednode.connections.push("/" + child[0] + "_" + child[1]);
        }
        let output = placeInNodeDict(nodedict, parsednode);
        if (instanceofFBTargetNode(node)) {
            for (let fbn of Object.values(nodedict["feedback" + node.family])) {
                for (let id of node.selects) {
                    if (fbn.fbid !== undefined && fbn.fbid.equals(id)) {
                        fbn.parameters["top"] = '"' + output[0] + "_" + output[1] + '"';
                        fbn.fbid = undefined;
                    }
                }
            }
        }
        return output;
    }
    function placeInNodeDict(nodedict, node) {
        if (node.ty in nodedict) {
            let nodes = nodedict[node.ty];
            let foundnode = Object.entries(nodes).reduce((acc, n) => fp_ts_1.option.isNone(acc) && deep_equal_1.default(n[1], node) ? fp_ts_1.option.fromNullable(n[0]) : acc, fp_ts_1.option.none);
            if (fp_ts_1.option.isSome(foundnode)) {
                return [node.ty, foundnode.value];
            }
        }
        else {
            nodedict[node.ty] = {};
        }
        const nodeid = node.unique ? node.unique : (Object.keys(nodedict[node.ty]).length).toString();
        nodedict[node.ty][nodeid] = node;
        return [node.ty, nodeid];
    }
    function addParameter(nodedict, parameters, name, param) {
        if (typeof param === "string") {
            parameters[name] = param;
        }
        else if (typeof param === "number") {
            parameters[name] = param.toString();
        }
        else if (param.type == "xy") {
            parameters[name + "x"] = parseParamValue(nodedict, param.value0);
            parameters[name + "y"] = parseParamValue(nodedict, param.value1);
        }
        else if (param.type == "uv") {
            parameters[name + "u"] = parseParamValue(nodedict, param.value0);
            parameters[name + "v"] = parseParamValue(nodedict, param.value1);
        }
        else if (param.type == "rgb") {
            parameters[name + "r"] = parseParamValue(nodedict, param.value0);
            parameters[name + "g"] = parseParamValue(nodedict, param.value1);
            parameters[name + "b"] = parseParamValue(nodedict, param.value2);
        }
        else if (param.type == "xyz") {
            parameters[name + "x"] = parseParamValue(nodedict, param.value0);
            parameters[name + "y"] = parseParamValue(nodedict, param.value1);
            parameters[name + "z"] = parseParamValue(nodedict, param.value2);
        }
        else if (param.type == "xyzw") {
            parameters[name + "x"] = parseParamValue(nodedict, param.value0);
            parameters[name + "y"] = parseParamValue(nodedict, param.value1);
            parameters[name + "z"] = parseParamValue(nodedict, param.value2);
            parameters[name + "w"] = parseParamValue(nodedict, param.value3);
        }
        else if (param.type == "rgba") {
            parameters[name + "r"] = parseParamValue(nodedict, param.value0);
            parameters[name + "g"] = parseParamValue(nodedict, param.value1);
            parameters[name + "b"] = parseParamValue(nodedict, param.value2);
            parameters[name + "a"] = parseParamValue(nodedict, param.value3);
        }
        else {
            parameters[name] = parseParamValue(nodedict, param.value0);
        }
        return parameters;
    }
    function addAction(nodedict) {
        return (action) => {
            return {
                command: action.type,
                delay: action.delay,
                args: [action.param, action.val, action.frames]
            };
        };
    }
    function parseParamValue(nodedict, value) {
        let val = fp_ts_1.array.array.reduce(value, "", (acc, p) => {
            if (typeof p === 'string') {
                return acc + p;
            }
            else {
                let addednode = addNode(nodedict, p);
                return acc + " " + addednode[0] + "_" + addednode[1];
            }
        });
        return val == "" ? undefined : val;
    }

    var Chain$1 = {};

    var guid = {};

    guid.__esModule = true;
    var Guid = /** @class */ (function () {
        function Guid(guid) {
            if (!guid) {
                throw new TypeError("Invalid argument; `value` has no value.");
            }
            this.value = Guid.EMPTY;
            if (guid && Guid.isGuid(guid)) {
                this.value = guid;
            }
        }
        Guid.isGuid = function (guid) {
            var value = guid.toString();
            return guid && (guid instanceof Guid || Guid.validator.test(value));
        };
        Guid.create = function () {
            return new Guid([Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join("-"));
        };
        Guid.createEmpty = function () {
            return new Guid("emptyguid");
        };
        Guid.parse = function (guid) {
            return new Guid(guid);
        };
        Guid.raw = function () {
            return [Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join("-");
        };
        Guid.gen = function (count) {
            var out = "";
            for (var i = 0; i < count; i++) {
                // tslint:disable-next-line:no-bitwise
                out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
            }
            return out;
        };
        Guid.prototype.equals = function (other) {
            // Comparing string `value` against provided `guid` will auto-call
            // toString on `guid` for comparison
            return Guid.isGuid(other) && this.value === other.toString();
        };
        Guid.prototype.isEmpty = function () {
            return this.value === Guid.EMPTY;
        };
        Guid.prototype.toString = function () {
            return this.value;
        };
        Guid.prototype.toJSON = function () {
            return {
                value: this.value
            };
        };
        Guid.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i");
        Guid.EMPTY = "00000000-0000-0000-0000-000000000000";
        return Guid;
    }());
    guid.Guid = Guid;

    var Option = {};

    var Applicative = {};

    var Apply = {};

    Object.defineProperty(Apply, "__esModule", { value: true });
    Apply.sequenceS = Apply.sequenceT = Apply.getApplySemigroup = Apply.apS = Apply.apSecond = Apply.apFirst = Apply.ap = void 0;
    var function_1$3 = _function;
    function ap(F, G) {
        return function (fa) { return function (fab) {
            return F.ap(F.map(fab, function (gab) { return function (ga) { return G.ap(gab, ga); }; }), fa);
        }; };
    }
    Apply.ap = ap;
    function apFirst(A) {
        return function (second) { return function (first) {
            return A.ap(A.map(first, function (a) { return function () { return a; }; }), second);
        }; };
    }
    Apply.apFirst = apFirst;
    function apSecond(A) {
        return function (second) { return function (first) {
            return A.ap(A.map(first, function () { return function (b) { return b; }; }), second);
        }; };
    }
    Apply.apSecond = apSecond;
    function apS(F) {
        return function (name, fb) { return function (fa) {
            return F.ap(F.map(fa, function (a) { return function (b) {
                var _a;
                return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
            }; }), fb);
        }; };
    }
    Apply.apS = apS;
    function getApplySemigroup(F) {
        return function (S) { return ({
            concat: function (first, second) {
                return F.ap(F.map(first, function (x) { return function (y) { return S.concat(x, y); }; }), second);
            }
        }); };
    }
    Apply.getApplySemigroup = getApplySemigroup;
    function curried(f, n, acc) {
        return function (x) {
            var combined = Array(acc.length + 1);
            for (var i = 0; i < acc.length; i++) {
                combined[i] = acc[i];
            }
            combined[acc.length] = x;
            return n === 0 ? f.apply(null, combined) : curried(f, n - 1, combined);
        };
    }
    var tupleConstructors = {
        1: function (a) { return [a]; },
        2: function (a) { return function (b) { return [a, b]; }; },
        3: function (a) { return function (b) { return function (c) { return [a, b, c]; }; }; },
        4: function (a) { return function (b) { return function (c) { return function (d) { return [a, b, c, d]; }; }; }; },
        5: function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return [a, b, c, d, e]; }; }; }; }; }
    };
    function getTupleConstructor(len) {
        if (!tupleConstructors.hasOwnProperty(len)) {
            tupleConstructors[len] = curried(function_1$3.tuple, len - 1, []);
        }
        return tupleConstructors[len];
    }
    function sequenceT(F) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var len = args.length;
            var f = getTupleConstructor(len);
            var fas = F.map(args[0], f);
            for (var i = 1; i < len; i++) {
                fas = F.ap(fas, args[i]);
            }
            return fas;
        };
    }
    Apply.sequenceT = sequenceT;
    function getRecordConstructor(keys) {
        var len = keys.length;
        switch (len) {
            case 1:
                return function (a) {
                    var _a;
                    return (_a = {}, _a[keys[0]] = a, _a);
                };
            case 2:
                return function (a) { return function (b) {
                    var _a;
                    return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a);
                }; };
            case 3:
                return function (a) { return function (b) { return function (c) {
                    var _a;
                    return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a);
                }; }; };
            case 4:
                return function (a) { return function (b) { return function (c) { return function (d) {
                    var _a;
                    return (_a = {},
                        _a[keys[0]] = a,
                        _a[keys[1]] = b,
                        _a[keys[2]] = c,
                        _a[keys[3]] = d,
                        _a);
                }; }; }; };
            case 5:
                return function (a) { return function (b) { return function (c) { return function (d) { return function (e) {
                    var _a;
                    return (_a = {},
                        _a[keys[0]] = a,
                        _a[keys[1]] = b,
                        _a[keys[2]] = c,
                        _a[keys[3]] = d,
                        _a[keys[4]] = e,
                        _a);
                }; }; }; }; };
            default:
                return curried(function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var r = {};
                    for (var i = 0; i < len; i++) {
                        r[keys[i]] = args[i];
                    }
                    return r;
                }, len - 1, []);
        }
    }
    function sequenceS(F) {
        return function (r) {
            var keys = Object.keys(r);
            var len = keys.length;
            var f = getRecordConstructor(keys);
            var fr = F.map(r[keys[0]], f);
            for (var i = 1; i < len; i++) {
                fr = F.ap(fr, r[keys[i]]);
            }
            return fr;
        };
    }
    Apply.sequenceS = sequenceS;

    var Functor = {};

    Object.defineProperty(Functor, "__esModule", { value: true });
    Functor.getFunctorComposition = Functor.bindTo = Functor.flap = Functor.map = void 0;
    /**
     * A `Functor` is a type constructor which supports a mapping operation `map`.
     *
     * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type
     * constructor `f` to represent some computational context.
     *
     * Instances must satisfy the following laws:
     *
     * 1. Identity: `F.map(fa, a => a) <-> fa`
     * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`
     *
     * @since 2.0.0
     */
    var function_1$2 = _function;
    function map(F, G) {
        return function (f) { return function (fa) { return F.map(fa, function (ga) { return G.map(ga, f); }); }; };
    }
    Functor.map = map;
    function flap(F) {
        return function (a) { return function (fab) { return F.map(fab, function (f) { return f(a); }); }; };
    }
    Functor.flap = flap;
    function bindTo(F) {
        return function (name) { return function (fa) { return F.map(fa, function (a) {
            var _a;
            return (_a = {}, _a[name] = a, _a);
        }); }; };
    }
    Functor.bindTo = bindTo;
    /** @deprecated */
    function getFunctorComposition(F, G) {
        var _map = map(F, G);
        return {
            map: function (fga, f) { return function_1$2.pipe(fga, _map(f)); }
        };
    }
    Functor.getFunctorComposition = getFunctorComposition;

    Object.defineProperty(Applicative, "__esModule", { value: true });
    Applicative.getApplicativeComposition = Applicative.getApplicativeMonoid = void 0;
    /**
     * The `Applicative` type class extends the `Apply` type class with a `of` function, which can be used to create values
     * of type `f a` from values of type `a`.
     *
     * Where `Apply` provides the ability to lift functions of two or more arguments to functions whose arguments are
     * wrapped using `f`, and `Functor` provides the ability to lift functions of one argument, `pure` can be seen as the
     * function which lifts functions of _zero_ arguments. That is, `Applicative` functors support a lifting operation for
     * any number of function arguments.
     *
     * Instances must satisfy the following laws in addition to the `Apply` laws:
     *
     * 1. Identity: `A.ap(A.of(a => a), fa) <-> fa`
     * 2. Homomorphism: `A.ap(A.of(ab), A.of(a)) <-> A.of(ab(a))`
     * 3. Interchange: `A.ap(fab, A.of(a)) <-> A.ap(A.of(ab => ab(a)), fab)`
     *
     * Note. `Functor`'s `map` can be derived: `A.map(x, f) = A.ap(A.of(f), x)`
     *
     * @since 2.0.0
     */
    var Apply_1 = Apply;
    var function_1$1 = _function;
    var Functor_1 = Functor;
    function getApplicativeMonoid(F) {
        var f = Apply_1.getApplySemigroup(F);
        return function (M) { return ({
            concat: f(M).concat,
            empty: F.of(M.empty)
        }); };
    }
    Applicative.getApplicativeMonoid = getApplicativeMonoid;
    /** @deprecated */
    function getApplicativeComposition(F, G) {
        var map = Functor_1.getFunctorComposition(F, G).map;
        var _ap = Apply_1.ap(F, G);
        return {
            map: map,
            of: function (a) { return F.of(G.of(a)); },
            ap: function (fgab, fga) { return function_1$1.pipe(fgab, _ap(fga)); }
        };
    }
    Applicative.getApplicativeComposition = getApplicativeComposition;

    var Chain = {};

    Object.defineProperty(Chain, "__esModule", { value: true });
    Chain.bind = Chain.chainFirst = void 0;
    function chainFirst(M) {
        return function (f) { return function (first) { return M.chain(first, function (a) { return M.map(f(a), function () { return a; }); }); }; };
    }
    Chain.chainFirst = chainFirst;
    function bind(M) {
        return function (name, f) { return function (ma) { return M.chain(ma, function (a) { return M.map(f(a), function (b) {
            var _a;
            return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
        }); }); }; };
    }
    Chain.bind = bind;

    var FromEither = {};

    var internal = {};

    var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    };
    Object.defineProperty(internal, "__esModule", { value: true });
    internal.fromReadonlyNonEmptyArray = internal.has = internal.emptyRecord = internal.emptyReadonlyArray = internal.tail = internal.head = internal.isNonEmpty = internal.singleton = internal.right = internal.left = internal.isRight = internal.isLeft = internal.some = internal.none = internal.isSome = internal.isNone = void 0;
    // -------------------------------------------------------------------------------------
    // Option
    // -------------------------------------------------------------------------------------
    /** @internal */
    var isNone = function (fa) { return fa._tag === 'None'; };
    internal.isNone = isNone;
    /** @internal */
    var isSome = function (fa) { return fa._tag === 'Some'; };
    internal.isSome = isSome;
    /** @internal */
    internal.none = { _tag: 'None' };
    /** @internal */
    var some = function (a) { return ({ _tag: 'Some', value: a }); };
    internal.some = some;
    // -------------------------------------------------------------------------------------
    // Either
    // -------------------------------------------------------------------------------------
    /** @internal */
    var isLeft = function (ma) { return ma._tag === 'Left'; };
    internal.isLeft = isLeft;
    /** @internal */
    var isRight = function (ma) { return ma._tag === 'Right'; };
    internal.isRight = isRight;
    /** @internal */
    var left = function (e) { return ({ _tag: 'Left', left: e }); };
    internal.left = left;
    /** @internal */
    var right = function (a) { return ({ _tag: 'Right', right: a }); };
    internal.right = right;
    // -------------------------------------------------------------------------------------
    // ReadonlyNonEmptyArray
    // -------------------------------------------------------------------------------------
    /** @internal */
    var singleton = function (a) { return [a]; };
    internal.singleton = singleton;
    /** @internal */
    var isNonEmpty = function (as) { return as.length > 0; };
    internal.isNonEmpty = isNonEmpty;
    /** @internal */
    var head = function (as) { return as[0]; };
    internal.head = head;
    /** @internal */
    var tail = function (as) { return as.slice(1); };
    internal.tail = tail;
    // -------------------------------------------------------------------------------------
    // empty
    // -------------------------------------------------------------------------------------
    /** @internal */
    internal.emptyReadonlyArray = [];
    /** @internal */
    internal.emptyRecord = {};
    // -------------------------------------------------------------------------------------
    // Record
    // -------------------------------------------------------------------------------------
    /** @internal */
    internal.has = Object.prototype.hasOwnProperty;
    // -------------------------------------------------------------------------------------
    // NonEmptyArray
    // -------------------------------------------------------------------------------------
    /** @internal */
    var fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1)); };
    internal.fromReadonlyNonEmptyArray = fromReadonlyNonEmptyArray;

    /**
     * The `FromEither` type class represents those data types which support errors.
     *
     * @since 2.10.0
     */
    var __createBinding$2 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault$2 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar$2 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$2(result, mod, k);
        __setModuleDefault$2(result, mod);
        return result;
    };
    Object.defineProperty(FromEither, "__esModule", { value: true });
    FromEither.filterOrElse = FromEither.chainEitherK = FromEither.fromEitherK = FromEither.chainOptionK = FromEither.fromOptionK = FromEither.fromPredicate = FromEither.fromOption = void 0;
    var function_1 = _function;
    var _$1 = __importStar$2(internal);
    function fromOption(F) {
        return function (onNone) { return function (ma) { return F.fromEither(_$1.isNone(ma) ? _$1.left(onNone()) : _$1.right(ma.value)); }; };
    }
    FromEither.fromOption = fromOption;
    function fromPredicate(F) {
        return function (predicate, onFalse) { return function (a) {
            return F.fromEither(predicate(a) ? _$1.right(a) : _$1.left(onFalse(a)));
        }; };
    }
    FromEither.fromPredicate = fromPredicate;
    function fromOptionK(F) {
        var fromOptionF = fromOption(F);
        return function (onNone) {
            var from = fromOptionF(onNone);
            return function (f) { return function_1.flow(f, from); };
        };
    }
    FromEither.fromOptionK = fromOptionK;
    function chainOptionK(F, M) {
        var fromOptionKF = fromOptionK(F);
        return function (onNone) {
            var from = fromOptionKF(onNone);
            return function (f) { return function (ma) { return M.chain(ma, from(f)); }; };
        };
    }
    FromEither.chainOptionK = chainOptionK;
    function fromEitherK(F) {
        return function (f) { return function_1.flow(f, F.fromEither); };
    }
    FromEither.fromEitherK = fromEitherK;
    function chainEitherK(F, M) {
        var fromEitherKF = fromEitherK(F);
        return function (f) { return function (ma) { return M.chain(ma, fromEitherKF(f)); }; };
    }
    FromEither.chainEitherK = chainEitherK;
    function filterOrElse(F, M) {
        return function (predicate, onFalse) { return function (ma) {
            return M.chain(ma, function (a) { return F.fromEither(predicate(a) ? _$1.right(a) : _$1.left(onFalse(a))); });
        }; };
    }
    FromEither.filterOrElse = filterOrElse;

    var Predicate = {};

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.and = exports.or = exports.not = exports.Contravariant = exports.getMonoidAll = exports.getSemigroupAll = exports.getMonoidAny = exports.getSemigroupAny = exports.URI = exports.contramap = void 0;
    var function_1 = _function;
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    var contramap_ = function (predicate, f) { return function_1.pipe(predicate, exports.contramap(f)); };
    /**
     * @category Contravariant
     * @since 2.11.0
     */
    var contramap = function (f) { return function (predicate) { return function_1.flow(f, predicate); }; };
    exports.contramap = contramap;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.11.0
     */
    exports.URI = 'Predicate';
    /**
     * @category instances
     * @since 2.11.0
     */
    var getSemigroupAny = function () { return ({
        concat: function (first, second) { return function_1.pipe(first, exports.or(second)); }
    }); };
    exports.getSemigroupAny = getSemigroupAny;
    /**
     * @category instances
     * @since 2.11.0
     */
    var getMonoidAny = function () { return ({
        concat: exports.getSemigroupAny().concat,
        empty: function_1.constFalse
    }); };
    exports.getMonoidAny = getMonoidAny;
    /**
     * @category instances
     * @since 2.11.0
     */
    var getSemigroupAll = function () { return ({
        concat: function (first, second) { return function_1.pipe(first, exports.and(second)); }
    }); };
    exports.getSemigroupAll = getSemigroupAll;
    /**
     * @category instances
     * @since 2.11.0
     */
    var getMonoidAll = function () { return ({
        concat: exports.getSemigroupAll().concat,
        empty: function_1.constTrue
    }); };
    exports.getMonoidAll = getMonoidAll;
    /**
     * @category instances
     * @since 2.11.0
     */
    exports.Contravariant = {
        URI: exports.URI,
        contramap: contramap_
    };
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    var not = function (predicate) { return function (a) { return !predicate(a); }; };
    exports.not = not;
    /**
     * @since 2.11.0
     */
    var or = function (second) { return function (first) { return function (a) { return first(a) || second(a); }; }; };
    exports.or = or;
    /**
     * @since 2.11.0
     */
    var and = function (second) { return function (first) { return function (a) { return first(a) && second(a); }; }; };
    exports.and = and;
    }(Predicate));

    var Semigroup = {};

    var Magma = {};

    /**
     * A `Magma` is a pair `(A, concat)` in which `A` is a non-empty set and `concat` is a binary operation on `A`
     *
     * See [Semigroup](https://gcanti.github.io/fp-ts/modules/Semigroup.ts.html) for some instances.
     *
     * @since 2.0.0
     */
    Object.defineProperty(Magma, "__esModule", { value: true });
    Magma.concatAll = Magma.endo = Magma.filterSecond = Magma.filterFirst = Magma.reverse = void 0;
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * The dual of a `Magma`, obtained by swapping the arguments of `concat`.
     *
     * @example
     * import { reverse, concatAll } from 'fp-ts/Magma'
     * import * as N from 'fp-ts/number'
     *
     * const subAll = concatAll(reverse(N.MagmaSub))(0)
     *
     * assert.deepStrictEqual(subAll([1, 2, 3]), 2)
     *
     * @category combinators
     * @since 2.11.0
     */
    var reverse = function (M) { return ({
        concat: function (first, second) { return M.concat(second, first); }
    }); };
    Magma.reverse = reverse;
    /**
     * @category combinators
     * @since 2.11.0
     */
    var filterFirst = function (predicate) { return function (M) { return ({
        concat: function (first, second) { return (predicate(first) ? M.concat(first, second) : second); }
    }); }; };
    Magma.filterFirst = filterFirst;
    /**
     * @category combinators
     * @since 2.11.0
     */
    var filterSecond = function (predicate) { return function (M) { return ({
        concat: function (first, second) { return (predicate(second) ? M.concat(first, second) : first); }
    }); }; };
    Magma.filterSecond = filterSecond;
    /**
     * @category combinators
     * @since 2.11.0
     */
    var endo = function (f) { return function (M) { return ({
        concat: function (first, second) { return M.concat(f(first), f(second)); }
    }); }; };
    Magma.endo = endo;
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * Given a sequence of `as`, concat them and return the total.
     *
     * If `as` is empty, return the provided `startWith` value.
     *
     * @example
     * import { concatAll } from 'fp-ts/Magma'
     * import * as N from 'fp-ts/number'
     *
     * const subAll = concatAll(N.MagmaSub)(0)
     *
     * assert.deepStrictEqual(subAll([1, 2, 3]), -6)
     *
     * @since 2.11.0
     */
    var concatAll = function (M) { return function (startWith) { return function (as) {
        return as.reduce(function (a, acc) { return M.concat(a, acc); }, startWith);
    }; }; };
    Magma.concatAll = concatAll;

    var Ord = {};

    var Eq = {};

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.eqDate = exports.eqNumber = exports.eqString = exports.eqBoolean = exports.eq = exports.strictEqual = exports.getStructEq = exports.getTupleEq = exports.Contravariant = exports.getMonoid = exports.getSemigroup = exports.eqStrict = exports.URI = exports.contramap = exports.tuple = exports.struct = exports.fromEquals = void 0;
    var function_1 = _function;
    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * @category constructors
     * @since 2.0.0
     */
    var fromEquals = function (equals) { return ({
        equals: function (x, y) { return x === y || equals(x, y); }
    }); };
    exports.fromEquals = fromEquals;
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * @category combinators
     * @since 2.10.0
     */
    var struct = function (eqs) {
        return exports.fromEquals(function (first, second) {
            for (var key in eqs) {
                if (!eqs[key].equals(first[key], second[key])) {
                    return false;
                }
            }
            return true;
        });
    };
    exports.struct = struct;
    /**
     * Given a tuple of `Eq`s returns a `Eq` for the tuple
     *
     * @example
     * import { tuple } from 'fp-ts/Eq'
     * import * as S from 'fp-ts/string'
     * import * as N from 'fp-ts/number'
     * import * as B from 'fp-ts/boolean'
     *
     * const E = tuple(S.Eq, N.Eq, B.Eq)
     * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, true]), true)
     * assert.strictEqual(E.equals(['a', 1, true], ['b', 1, true]), false)
     * assert.strictEqual(E.equals(['a', 1, true], ['a', 2, true]), false)
     * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, false]), false)
     *
     * @category combinators
     * @since 2.10.0
     */
    var tuple = function () {
        var eqs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            eqs[_i] = arguments[_i];
        }
        return exports.fromEquals(function (first, second) { return eqs.every(function (E, i) { return E.equals(first[i], second[i]); }); });
    };
    exports.tuple = tuple;
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    /* istanbul ignore next */
    var contramap_ = function (fa, f) { return function_1.pipe(fa, exports.contramap(f)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * @category Contravariant
     * @since 2.0.0
     */
    var contramap = function (f) { return function (fa) {
        return exports.fromEquals(function (x, y) { return fa.equals(f(x), f(y)); });
    }; };
    exports.contramap = contramap;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    exports.URI = 'Eq';
    /**
     * @category instances
     * @since 2.5.0
     */
    exports.eqStrict = {
        equals: function (a, b) { return a === b; }
    };
    var empty = {
        equals: function () { return true; }
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    var getSemigroup = function () { return ({
        concat: function (x, y) { return exports.fromEquals(function (a, b) { return x.equals(a, b) && y.equals(a, b); }); }
    }); };
    exports.getSemigroup = getSemigroup;
    /**
     * @category instances
     * @since 2.6.0
     */
    var getMonoid = function () { return ({
        concat: exports.getSemigroup().concat,
        empty: empty
    }); };
    exports.getMonoid = getMonoid;
    /**
     * @category instances
     * @since 2.7.0
     */
    exports.Contravariant = {
        URI: exports.URI,
        contramap: contramap_
    };
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use [`tuple`](#tuple) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    exports.getTupleEq = exports.tuple;
    /**
     * Use [`struct`](#struct) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    exports.getStructEq = exports.struct;
    /**
     * Use [`eqStrict`](#eqstrict) instead
     *
     * @since 2.0.0
     * @deprecated
     */
    exports.strictEqual = exports.eqStrict.equals;
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.eq = exports.Contravariant;
    /**
     * Use [`Eq`](./boolean.ts.html#eq) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.eqBoolean = exports.eqStrict;
    /**
     * Use [`Eq`](./string.ts.html#eq) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.eqString = exports.eqStrict;
    /**
     * Use [`Eq`](./number.ts.html#eq) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.eqNumber = exports.eqStrict;
    /**
     * Use [`Eq`](./Date.ts.html#eq) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.eqDate = {
        equals: function (first, second) { return first.valueOf() === second.valueOf(); }
    };
    }(Eq));

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ordDate = exports.ordNumber = exports.ordString = exports.ordBoolean = exports.ord = exports.getDualOrd = exports.getTupleOrd = exports.between = exports.clamp = exports.max = exports.min = exports.geq = exports.leq = exports.gt = exports.lt = exports.equals = exports.trivial = exports.Contravariant = exports.getMonoid = exports.getSemigroup = exports.URI = exports.contramap = exports.reverse = exports.tuple = exports.fromCompare = exports.equalsDefault = void 0;
    var Eq_1 = Eq;
    var function_1 = _function;
    // -------------------------------------------------------------------------------------
    // defaults
    // -------------------------------------------------------------------------------------
    /**
     * @category defaults
     * @since 2.10.0
     */
    var equalsDefault = function (compare) { return function (first, second) {
        return first === second || compare(first, second) === 0;
    }; };
    exports.equalsDefault = equalsDefault;
    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * @category constructors
     * @since 2.0.0
     */
    var fromCompare = function (compare) { return ({
        equals: exports.equalsDefault(compare),
        compare: function (first, second) { return (first === second ? 0 : compare(first, second)); }
    }); };
    exports.fromCompare = fromCompare;
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * Given a tuple of `Ord`s returns an `Ord` for the tuple.
     *
     * @example
     * import { tuple } from 'fp-ts/Ord'
     * import * as B from 'fp-ts/boolean'
     * import * as S from 'fp-ts/string'
     * import * as N from 'fp-ts/number'
     *
     * const O = tuple(S.Ord, N.Ord, B.Ord)
     * assert.strictEqual(O.compare(['a', 1, true], ['b', 2, true]), -1)
     * assert.strictEqual(O.compare(['a', 1, true], ['a', 2, true]), -1)
     * assert.strictEqual(O.compare(['a', 1, true], ['a', 1, false]), 1)
     *
     * @category combinators
     * @since 2.10.0
     */
    var tuple = function () {
        var ords = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            ords[_i] = arguments[_i];
        }
        return exports.fromCompare(function (first, second) {
            var i = 0;
            for (; i < ords.length - 1; i++) {
                var r = ords[i].compare(first[i], second[i]);
                if (r !== 0) {
                    return r;
                }
            }
            return ords[i].compare(first[i], second[i]);
        });
    };
    exports.tuple = tuple;
    /**
     * @category combinators
     * @since 2.10.0
     */
    var reverse = function (O) { return exports.fromCompare(function (first, second) { return O.compare(second, first); }); };
    exports.reverse = reverse;
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    /* istanbul ignore next */
    var contramap_ = function (fa, f) { return function_1.pipe(fa, exports.contramap(f)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * @category Contravariant
     * @since 2.0.0
     */
    var contramap = function (f) { return function (fa) {
        return exports.fromCompare(function (first, second) { return fa.compare(f(first), f(second)); });
    }; };
    exports.contramap = contramap;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    exports.URI = 'Ord';
    /**
     * @category instances
     * @since 2.0.0
     */
    var getSemigroup = function () { return ({
        concat: function (first, second) {
            return exports.fromCompare(function (a, b) {
                var ox = first.compare(a, b);
                return ox !== 0 ? ox : second.compare(a, b);
            });
        }
    }); };
    exports.getSemigroup = getSemigroup;
    /**
     * Returns a `Monoid` such that:
     *
     * - its `concat(ord1, ord2)` operation will order first by `ord1`, and then by `ord2`
     * - its `empty` value is an `Ord` that always considers compared elements equal
     *
     * @example
     * import { sort } from 'fp-ts/Array'
     * import { contramap, reverse, getMonoid } from 'fp-ts/Ord'
     * import * as S from 'fp-ts/string'
     * import * as B from 'fp-ts/boolean'
     * import { pipe } from 'fp-ts/function'
     * import { concatAll } from 'fp-ts/Monoid'
     * import * as N from 'fp-ts/number'
     *
     * interface User {
     *   readonly id: number
     *   readonly name: string
     *   readonly age: number
     *   readonly rememberMe: boolean
     * }
     *
     * const byName = pipe(
     *   S.Ord,
     *   contramap((p: User) => p.name)
     * )
     *
     * const byAge = pipe(
     *   N.Ord,
     *   contramap((p: User) => p.age)
     * )
     *
     * const byRememberMe = pipe(
     *   B.Ord,
     *   contramap((p: User) => p.rememberMe)
     * )
     *
     * const M = getMonoid<User>()
     *
     * const users: Array<User> = [
     *   { id: 1, name: 'Guido', age: 47, rememberMe: false },
     *   { id: 2, name: 'Guido', age: 46, rememberMe: true },
     *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },
     *   { id: 4, name: 'Giulio', age: 44, rememberMe: true }
     * ]
     *
     * // sort by name, then by age, then by `rememberMe`
     * const O1 = concatAll(M)([byName, byAge, byRememberMe])
     * assert.deepStrictEqual(sort(O1)(users), [
     *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },
     *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },
     *   { id: 2, name: 'Guido', age: 46, rememberMe: true },
     *   { id: 1, name: 'Guido', age: 47, rememberMe: false }
     * ])
     *
     * // now `rememberMe = true` first, then by name, then by age
     * const O2 = concatAll(M)([reverse(byRememberMe), byName, byAge])
     * assert.deepStrictEqual(sort(O2)(users), [
     *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },
     *   { id: 2, name: 'Guido', age: 46, rememberMe: true },
     *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },
     *   { id: 1, name: 'Guido', age: 47, rememberMe: false }
     * ])
     *
     * @category instances
     * @since 2.4.0
     */
    var getMonoid = function () { return ({
        concat: exports.getSemigroup().concat,
        empty: exports.fromCompare(function () { return 0; })
    }); };
    exports.getMonoid = getMonoid;
    /**
     * @category instances
     * @since 2.7.0
     */
    exports.Contravariant = {
        URI: exports.URI,
        contramap: contramap_
    };
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    exports.trivial = {
        equals: function_1.constTrue,
        compare: 
        /*#__PURE__*/
        function_1.constant(0)
    };
    /**
     * @since 2.11.0
     */
    var equals = function (O) { return function (second) { return function (first) {
        return first === second || O.compare(first, second) === 0;
    }; }; };
    exports.equals = equals;
    // TODO: curry in v3
    /**
     * Test whether one value is _strictly less than_ another
     *
     * @since 2.0.0
     */
    var lt = function (O) { return function (first, second) { return O.compare(first, second) === -1; }; };
    exports.lt = lt;
    // TODO: curry in v3
    /**
     * Test whether one value is _strictly greater than_ another
     *
     * @since 2.0.0
     */
    var gt = function (O) { return function (first, second) { return O.compare(first, second) === 1; }; };
    exports.gt = gt;
    // TODO: curry in v3
    /**
     * Test whether one value is _non-strictly less than_ another
     *
     * @since 2.0.0
     */
    var leq = function (O) { return function (first, second) { return O.compare(first, second) !== 1; }; };
    exports.leq = leq;
    // TODO: curry in v3
    /**
     * Test whether one value is _non-strictly greater than_ another
     *
     * @since 2.0.0
     */
    var geq = function (O) { return function (first, second) { return O.compare(first, second) !== -1; }; };
    exports.geq = geq;
    // TODO: curry in v3
    /**
     * Take the minimum of two values. If they are considered equal, the first argument is chosen
     *
     * @since 2.0.0
     */
    var min = function (O) { return function (first, second) {
        return first === second || O.compare(first, second) < 1 ? first : second;
    }; };
    exports.min = min;
    // TODO: curry in v3
    /**
     * Take the maximum of two values. If they are considered equal, the first argument is chosen
     *
     * @since 2.0.0
     */
    var max = function (O) { return function (first, second) {
        return first === second || O.compare(first, second) > -1 ? first : second;
    }; };
    exports.max = max;
    /**
     * Clamp a value between a minimum and a maximum
     *
     * @since 2.0.0
     */
    var clamp = function (O) {
        var minO = exports.min(O);
        var maxO = exports.max(O);
        return function (low, hi) { return function (a) { return maxO(minO(a, hi), low); }; };
    };
    exports.clamp = clamp;
    /**
     * Test whether a value is between a minimum and a maximum (inclusive)
     *
     * @since 2.0.0
     */
    var between = function (O) {
        var ltO = exports.lt(O);
        var gtO = exports.gt(O);
        return function (low, hi) { return function (a) { return (ltO(a, low) || gtO(a, hi) ? false : true); }; };
    };
    exports.between = between;
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use [`tuple`](#tuple) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    exports.getTupleOrd = exports.tuple;
    /**
     * Use [`reverse`](#reverse) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    exports.getDualOrd = exports.reverse;
    /**
     * Use [`Contravariant`](#contravariant) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.ord = exports.Contravariant;
    // default compare for primitive types
    function compare(first, second) {
        return first < second ? -1 : first > second ? 1 : 0;
    }
    var strictOrd = {
        equals: Eq_1.eqStrict.equals,
        compare: compare
    };
    /**
     * Use [`Ord`](./boolean.ts.html#ord) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.ordBoolean = strictOrd;
    /**
     * Use [`Ord`](./string.ts.html#ord) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.ordString = strictOrd;
    /**
     * Use [`Ord`](./number.ts.html#ord) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.ordNumber = strictOrd;
    /**
     * Use [`Ord`](./Date.ts.html#ord) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.ordDate = 
    /*#__PURE__*/
    function_1.pipe(exports.ordNumber, 
    /*#__PURE__*/
    exports.contramap(function (date) { return date.valueOf(); }));
    }(Ord));

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.semigroupProduct = exports.semigroupSum = exports.semigroupString = exports.getFunctionSemigroup = exports.semigroupAny = exports.semigroupAll = exports.fold = exports.getIntercalateSemigroup = exports.getMeetSemigroup = exports.getJoinSemigroup = exports.getDualSemigroup = exports.getStructSemigroup = exports.getTupleSemigroup = exports.getFirstSemigroup = exports.getLastSemigroup = exports.getObjectSemigroup = exports.semigroupVoid = exports.concatAll = exports.last = exports.first = exports.intercalate = exports.tuple = exports.struct = exports.reverse = exports.constant = exports.max = exports.min = void 0;
    /**
     * If a type `A` can form a `Semigroup` it has an **associative** binary operation.
     *
     * ```ts
     * interface Semigroup<A> {
     *   readonly concat: (x: A, y: A) => A
     * }
     * ```
     *
     * Associativity means the following equality must hold for any choice of `x`, `y`, and `z`.
     *
     * ```ts
     * concat(x, concat(y, z)) = concat(concat(x, y), z)
     * ```
     *
     * A common example of a semigroup is the type `string` with the operation `+`.
     *
     * ```ts
     * import { Semigroup } from 'fp-ts/Semigroup'
     *
     * const semigroupString: Semigroup<string> = {
     *   concat: (x, y) => x + y
     * }
     *
     * const x = 'x'
     * const y = 'y'
     * const z = 'z'
     *
     * semigroupString.concat(x, y) // 'xy'
     *
     * semigroupString.concat(x, semigroupString.concat(y, z)) // 'xyz'
     *
     * semigroupString.concat(semigroupString.concat(x, y), z) // 'xyz'
     * ```
     *
     * *Adapted from https://typelevel.org/cats*
     *
     * @since 2.0.0
     */
    var function_1 = _function;
    var _ = __importStar(internal);
    var M = __importStar(Magma);
    var Or = __importStar(Ord);
    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * Get a semigroup where `concat` will return the minimum, based on the provided order.
     *
     * @example
     * import * as N from 'fp-ts/number'
     * import * as S from 'fp-ts/Semigroup'
     *
     * const S1 = S.min(N.Ord)
     *
     * assert.deepStrictEqual(S1.concat(1, 2), 1)
     *
     * @category constructors
     * @since 2.10.0
     */
    var min = function (O) { return ({
        concat: Or.min(O)
    }); };
    exports.min = min;
    /**
     * Get a semigroup where `concat` will return the maximum, based on the provided order.
     *
     * @example
     * import * as N from 'fp-ts/number'
     * import * as S from 'fp-ts/Semigroup'
     *
     * const S1 = S.max(N.Ord)
     *
     * assert.deepStrictEqual(S1.concat(1, 2), 2)
     *
     * @category constructors
     * @since 2.10.0
     */
    var max = function (O) { return ({
        concat: Or.max(O)
    }); };
    exports.max = max;
    /**
     * @category constructors
     * @since 2.10.0
     */
    var constant = function (a) { return ({
        concat: function () { return a; }
    }); };
    exports.constant = constant;
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * The dual of a `Semigroup`, obtained by swapping the arguments of `concat`.
     *
     * @example
     * import { reverse } from 'fp-ts/Semigroup'
     * import * as S from 'fp-ts/string'
     *
     * assert.deepStrictEqual(reverse(S.Semigroup).concat('a', 'b'), 'ba')
     *
     * @category combinators
     * @since 2.10.0
     */
    exports.reverse = M.reverse;
    /**
     * Given a struct of semigroups returns a semigroup for the struct.
     *
     * @example
     * import { struct } from 'fp-ts/Semigroup'
     * import * as N from 'fp-ts/number'
     *
     * interface Point {
     *   readonly x: number
     *   readonly y: number
     * }
     *
     * const S = struct<Point>({
     *   x: N.SemigroupSum,
     *   y: N.SemigroupSum
     * })
     *
     * assert.deepStrictEqual(S.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })
     *
     * @category combinators
     * @since 2.10.0
     */
    var struct = function (semigroups) { return ({
        concat: function (first, second) {
            var r = {};
            for (var k in semigroups) {
                if (_.has.call(semigroups, k)) {
                    r[k] = semigroups[k].concat(first[k], second[k]);
                }
            }
            return r;
        }
    }); };
    exports.struct = struct;
    /**
     * Given a tuple of semigroups returns a semigroup for the tuple.
     *
     * @example
     * import { tuple } from 'fp-ts/Semigroup'
     * import * as B from 'fp-ts/boolean'
     * import * as N from 'fp-ts/number'
     * import * as S from 'fp-ts/string'
     *
     * const S1 = tuple(S.Semigroup, N.SemigroupSum)
     * assert.deepStrictEqual(S1.concat(['a', 1], ['b', 2]), ['ab', 3])
     *
     * const S2 = tuple(S.Semigroup, N.SemigroupSum, B.SemigroupAll)
     * assert.deepStrictEqual(S2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])
     *
     * @category combinators
     * @since 2.10.0
     */
    var tuple = function () {
        var semigroups = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            semigroups[_i] = arguments[_i];
        }
        return ({
            concat: function (first, second) { return semigroups.map(function (s, i) { return s.concat(first[i], second[i]); }); }
        });
    };
    exports.tuple = tuple;
    /**
     * Between each pair of elements insert `middle`.
     *
     * @example
     * import { intercalate } from 'fp-ts/Semigroup'
     * import * as S from 'fp-ts/string'
     * import { pipe } from 'fp-ts/function'
     *
     * const S1 = pipe(S.Semigroup, intercalate(' + '))
     *
     * assert.strictEqual(S1.concat('a', 'b'), 'a + b')
     *
     * @category combinators
     * @since 2.10.0
     */
    var intercalate = function (middle) { return function (S) { return ({
        concat: function (x, y) { return S.concat(x, S.concat(middle, y)); }
    }); }; };
    exports.intercalate = intercalate;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * Always return the first argument.
     *
     * @example
     * import * as S from 'fp-ts/Semigroup'
     *
     * assert.deepStrictEqual(S.first<number>().concat(1, 2), 1)
     *
     * @category instances
     * @since 2.10.0
     */
    var first = function () { return ({ concat: function_1.identity }); };
    exports.first = first;
    /**
     * Always return the last argument.
     *
     * @example
     * import * as S from 'fp-ts/Semigroup'
     *
     * assert.deepStrictEqual(S.last<number>().concat(1, 2), 2)
     *
     * @category instances
     * @since 2.10.0
     */
    var last = function () { return ({ concat: function (_, y) { return y; } }); };
    exports.last = last;
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * Given a sequence of `as`, concat them and return the total.
     *
     * If `as` is empty, return the provided `startWith` value.
     *
     * @example
     * import { concatAll } from 'fp-ts/Semigroup'
     * import * as N from 'fp-ts/number'
     *
     * const sum = concatAll(N.SemigroupSum)(0)
     *
     * assert.deepStrictEqual(sum([1, 2, 3]), 6)
     * assert.deepStrictEqual(sum([]), 0)
     *
     * @since 2.10.0
     */
    exports.concatAll = M.concatAll;
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    /**
     * Use `void` module instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.semigroupVoid = exports.constant(undefined);
    /**
     * Use [`getAssignSemigroup`](./struct.ts.html#getAssignSemigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getObjectSemigroup = function () { return ({
        concat: function (first, second) { return Object.assign({}, first, second); }
    }); };
    exports.getObjectSemigroup = getObjectSemigroup;
    /**
     * Use [`last`](#last) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.getLastSemigroup = exports.last;
    /**
     * Use [`first`](#first) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.getFirstSemigroup = exports.first;
    /**
     * Use [`tuple`](#tuple) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    exports.getTupleSemigroup = exports.tuple;
    /**
     * Use [`struct`](#struct) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    exports.getStructSemigroup = exports.struct;
    /**
     * Use [`reverse`](#reverse) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    exports.getDualSemigroup = exports.reverse;
    /**
     * Use [`max`](#max) instead.
     *
     * @category constructors
     * @since 2.0.0
     * @deprecated
     */
    exports.getJoinSemigroup = exports.max;
    /**
     * Use [`min`](#min) instead.
     *
     * @category constructors
     * @since 2.0.0
     * @deprecated
     */
    exports.getMeetSemigroup = exports.min;
    /**
     * Use [`intercalate`](#intercalate) instead.
     *
     * @category combinators
     * @since 2.5.0
     * @deprecated
     */
    exports.getIntercalateSemigroup = exports.intercalate;
    function fold(S) {
        var concatAllS = exports.concatAll(S);
        return function (startWith, as) { return (as === undefined ? concatAllS(startWith) : concatAllS(startWith)(as)); };
    }
    exports.fold = fold;
    /**
     * Use [`SemigroupAll`](./boolean.ts.html#SemigroupAll) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.semigroupAll = {
        concat: function (x, y) { return x && y; }
    };
    /**
     * Use [`SemigroupAny`](./boolean.ts.html#SemigroupAny) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.semigroupAny = {
        concat: function (x, y) { return x || y; }
    };
    /**
     * Use [`getSemigroup`](./function.ts.html#getSemigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.getFunctionSemigroup = function_1.getSemigroup;
    /**
     * Use [`Semigroup`](./string.ts.html#Semigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.semigroupString = {
        concat: function (x, y) { return x + y; }
    };
    /**
     * Use [`SemigroupSum`](./number.ts.html#SemigroupSum) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.semigroupSum = {
        concat: function (x, y) { return x + y; }
    };
    /**
     * Use [`SemigroupProduct`](./number.ts.html#SemigroupProduct) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.semigroupProduct = {
        concat: function (x, y) { return x * y; }
    };
    }(Semigroup));

    var Separated = {};

    (function (exports) {
    /**
     * ```ts
     * interface Separated<E, A> {
     *    readonly left: E
     *    readonly right: A
     * }
     * ```
     *
     * Represents a result of separating a whole into two parts.
     *
     * @since 2.10.0
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.right = exports.left = exports.flap = exports.Functor = exports.Bifunctor = exports.URI = exports.bimap = exports.mapLeft = exports.map = exports.separated = void 0;
    var function_1 = _function;
    var Functor_1 = Functor;
    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * @category constructors
     * @since 2.10.0
     */
    var separated = function (left, right) { return ({ left: left, right: right }); };
    exports.separated = separated;
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _map = function (fa, f) { return function_1.pipe(fa, exports.map(f)); };
    var _mapLeft = function (fa, f) { return function_1.pipe(fa, exports.mapLeft(f)); };
    var _bimap = function (fa, g, f) { return function_1.pipe(fa, exports.bimap(g, f)); };
    // -------------------------------------------------------------------------------------
    // type class members
    // -------------------------------------------------------------------------------------
    /**
     * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
     * use the type constructor `F` to represent some computational context.
     *
     * @category Functor
     * @since 2.10.0
     */
    var map = function (f) { return function (fa) {
        return exports.separated(exports.left(fa), f(exports.right(fa)));
    }; };
    exports.map = map;
    /**
     * Map a function over the first type argument of a bifunctor.
     *
     * @category Bifunctor
     * @since 2.10.0
     */
    var mapLeft = function (f) { return function (fa) {
        return exports.separated(f(exports.left(fa)), exports.right(fa));
    }; };
    exports.mapLeft = mapLeft;
    /**
     * Map a pair of functions over the two type arguments of the bifunctor.
     *
     * @category Bifunctor
     * @since 2.10.0
     */
    var bimap = function (f, g) { return function (fa) {
        return exports.separated(f(exports.left(fa)), g(exports.right(fa)));
    }; };
    exports.bimap = bimap;
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.10.0
     */
    exports.URI = 'Separated';
    /**
     * @category instances
     * @since 2.10.0
     */
    exports.Bifunctor = {
        URI: exports.URI,
        mapLeft: _mapLeft,
        bimap: _bimap
    };
    /**
     * @category instances
     * @since 2.10.0
     */
    exports.Functor = {
        URI: exports.URI,
        map: _map
    };
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    exports.flap = 
    /*#__PURE__*/
    Functor_1.flap(exports.Functor);
    // -------------------------------------------------------------------------------------
    // utils
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.10.0
     */
    var left = function (s) { return s.left; };
    exports.left = left;
    /**
     * @since 2.10.0
     */
    var right = function (s) { return s.right; };
    exports.right = right;
    }(Separated));

    var Witherable = {};

    var __createBinding$1 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault$1 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar$1 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);
        __setModuleDefault$1(result, mod);
        return result;
    };
    Object.defineProperty(Witherable, "__esModule", { value: true });
    Witherable.filterE = Witherable.witherDefault = Witherable.wiltDefault = void 0;
    var _ = __importStar$1(internal);
    function wiltDefault(T, C) {
        return function (F) {
            var traverseF = T.traverse(F);
            return function (wa, f) { return F.map(traverseF(wa, f), C.separate); };
        };
    }
    Witherable.wiltDefault = wiltDefault;
    function witherDefault(T, C) {
        return function (F) {
            var traverseF = T.traverse(F);
            return function (wa, f) { return F.map(traverseF(wa, f), C.compact); };
        };
    }
    Witherable.witherDefault = witherDefault;
    function filterE(W) {
        return function (F) {
            var witherF = W.wither(F);
            return function (predicate) { return function (ga) { return witherF(ga, function (a) { return F.map(predicate(a), function (b) { return (b ? _.some(a) : _.none); }); }); }; };
        };
    }
    Witherable.filterE = filterE;

    var Zero = {};

    Object.defineProperty(Zero, "__esModule", { value: true });
    Zero.guard = void 0;
    function guard(F, P) {
        return function (b) { return (b ? P.of(undefined) : F.zero()); };
    }
    Zero.guard = guard;

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromEither = exports.MonadThrow = exports.throwError = exports.Witherable = exports.wilt = exports.wither = exports.Traversable = exports.sequence = exports.traverse = exports.Filterable = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.Compactable = exports.separate = exports.compact = exports.Extend = exports.extend = exports.Alternative = exports.guard = exports.Zero = exports.zero = exports.Alt = exports.alt = exports.altW = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.chain = exports.Applicative = exports.Apply = exports.ap = exports.Pointed = exports.of = exports.Functor = exports.map = exports.getMonoid = exports.getOrd = exports.getEq = exports.getShow = exports.URI = exports.getRight = exports.getLeft = exports.fromPredicate = exports.some = exports.none = void 0;
    exports.getLastMonoid = exports.getFirstMonoid = exports.getApplyMonoid = exports.getApplySemigroup = exports.option = exports.mapNullable = exports.getRefinement = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toUndefined = exports.toNullable = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.chainEitherK = exports.fromEitherK = exports.duplicate = exports.chainFirst = exports.flatten = exports.apSecond = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = exports.fold = exports.match = exports.foldW = exports.matchW = exports.isNone = exports.isSome = exports.FromEither = void 0;
    var Applicative_1 = Applicative;
    var Apply_1 = Apply;
    var Chain_1 = Chain;
    var FromEither_1 = FromEither;
    var function_1 = _function;
    var Functor_1 = Functor;
    var _ = __importStar(internal);
    var Predicate_1 = Predicate;
    var Semigroup_1 = Semigroup;
    var Separated_1 = Separated;
    var Witherable_1 = Witherable;
    var Zero_1 = Zero;
    // -------------------------------------------------------------------------------------
    // constructors
    // -------------------------------------------------------------------------------------
    /**
     * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.
     *
     * @category constructors
     * @since 2.0.0
     */
    exports.none = _.none;
    /**
     * Constructs a `Some`. Represents an optional value that exists.
     *
     * @category constructors
     * @since 2.0.0
     */
    exports.some = _.some;
    function fromPredicate(predicate) {
        return function (a) { return (predicate(a) ? exports.some(a) : exports.none); };
    }
    exports.fromPredicate = fromPredicate;
    /**
     * Returns the `Left` value of an `Either` if possible.
     *
     * @example
     * import { getLeft, none, some } from 'fp-ts/Option'
     * import { right, left } from 'fp-ts/Either'
     *
     * assert.deepStrictEqual(getLeft(right(1)), none)
     * assert.deepStrictEqual(getLeft(left('a')), some('a'))
     *
     * @category constructors
     * @since 2.0.0
     */
    var getLeft = function (ma) { return (ma._tag === 'Right' ? exports.none : exports.some(ma.left)); };
    exports.getLeft = getLeft;
    /**
     * Returns the `Right` value of an `Either` if possible.
     *
     * @example
     * import { getRight, none, some } from 'fp-ts/Option'
     * import { right, left } from 'fp-ts/Either'
     *
     * assert.deepStrictEqual(getRight(right(1)), some(1))
     * assert.deepStrictEqual(getRight(left('a')), none)
     *
     * @category constructors
     * @since 2.0.0
     */
    var getRight = function (ma) { return (ma._tag === 'Left' ? exports.none : exports.some(ma.right)); };
    exports.getRight = getRight;
    // -------------------------------------------------------------------------------------
    // non-pipeables
    // -------------------------------------------------------------------------------------
    var _map = function (fa, f) { return function_1.pipe(fa, exports.map(f)); };
    var _ap = function (fab, fa) { return function_1.pipe(fab, exports.ap(fa)); };
    var _chain = function (ma, f) { return function_1.pipe(ma, exports.chain(f)); };
    var _reduce = function (fa, b, f) { return function_1.pipe(fa, exports.reduce(b, f)); };
    var _foldMap = function (M) {
        var foldMapM = exports.foldMap(M);
        return function (fa, f) { return function_1.pipe(fa, foldMapM(f)); };
    };
    var _reduceRight = function (fa, b, f) { return function_1.pipe(fa, exports.reduceRight(b, f)); };
    var _traverse = function (F) {
        var traverseF = exports.traverse(F);
        return function (ta, f) { return function_1.pipe(ta, traverseF(f)); };
    };
    /* istanbul ignore next */
    var _alt = function (fa, that) { return function_1.pipe(fa, exports.alt(that)); };
    var _filter = function (fa, predicate) { return function_1.pipe(fa, exports.filter(predicate)); };
    /* istanbul ignore next */
    var _filterMap = function (fa, f) { return function_1.pipe(fa, exports.filterMap(f)); };
    /* istanbul ignore next */
    var _extend = function (wa, f) { return function_1.pipe(wa, exports.extend(f)); };
    /* istanbul ignore next */
    var _partition = function (fa, predicate) {
        return function_1.pipe(fa, exports.partition(predicate));
    };
    /* istanbul ignore next */
    var _partitionMap = function (fa, f) { return function_1.pipe(fa, exports.partitionMap(f)); };
    // -------------------------------------------------------------------------------------
    // instances
    // -------------------------------------------------------------------------------------
    /**
     * @category instances
     * @since 2.0.0
     */
    exports.URI = 'Option';
    /**
     * @category instances
     * @since 2.0.0
     */
    var getShow = function (S) { return ({
        show: function (ma) { return (exports.isNone(ma) ? 'none' : "some(" + S.show(ma.value) + ")"); }
    }); };
    exports.getShow = getShow;
    /**
     * @example
     * import { none, some, getEq } from 'fp-ts/Option'
     * import * as N from 'fp-ts/number'
     *
     * const E = getEq(N.Eq)
     * assert.strictEqual(E.equals(none, none), true)
     * assert.strictEqual(E.equals(none, some(1)), false)
     * assert.strictEqual(E.equals(some(1), none), false)
     * assert.strictEqual(E.equals(some(1), some(2)), false)
     * assert.strictEqual(E.equals(some(1), some(1)), true)
     *
     * @category instances
     * @since 2.0.0
     */
    var getEq = function (E) { return ({
        equals: function (x, y) { return x === y || (exports.isNone(x) ? exports.isNone(y) : exports.isNone(y) ? false : E.equals(x.value, y.value)); }
    }); };
    exports.getEq = getEq;
    /**
     * The `Ord` instance allows `Option` values to be compared with
     * `compare`, whenever there is an `Ord` instance for
     * the type the `Option` contains.
     *
     * `None` is considered to be less than any `Some` value.
     *
     *
     * @example
     * import { none, some, getOrd } from 'fp-ts/Option'
     * import * as N from 'fp-ts/number'
     *
     * const O = getOrd(N.Ord)
     * assert.strictEqual(O.compare(none, none), 0)
     * assert.strictEqual(O.compare(none, some(1)), -1)
     * assert.strictEqual(O.compare(some(1), none), 1)
     * assert.strictEqual(O.compare(some(1), some(2)), -1)
     * assert.strictEqual(O.compare(some(1), some(1)), 0)
     *
     * @category instances
     * @since 2.0.0
     */
    var getOrd = function (O) { return ({
        equals: exports.getEq(O).equals,
        compare: function (x, y) { return (x === y ? 0 : exports.isSome(x) ? (exports.isSome(y) ? O.compare(x.value, y.value) : 1) : -1); }
    }); };
    exports.getOrd = getOrd;
    /**
     * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are
     * concatenated using the provided `Semigroup`
     *
     * | x       | y       | concat(x, y)       |
     * | ------- | ------- | ------------------ |
     * | none    | none    | none               |
     * | some(a) | none    | some(a)            |
     * | none    | some(b) | some(b)            |
     * | some(a) | some(b) | some(concat(a, b)) |
     *
     * @example
     * import { getMonoid, some, none } from 'fp-ts/Option'
     * import { SemigroupSum } from 'fp-ts/number'
     *
     * const M = getMonoid(SemigroupSum)
     * assert.deepStrictEqual(M.concat(none, none), none)
     * assert.deepStrictEqual(M.concat(some(1), none), some(1))
     * assert.deepStrictEqual(M.concat(none, some(1)), some(1))
     * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))
     *
     * @category instances
     * @since 2.0.0
     */
    var getMonoid = function (S) { return ({
        concat: function (x, y) { return (exports.isNone(x) ? y : exports.isNone(y) ? x : exports.some(S.concat(x.value, y.value))); },
        empty: exports.none
    }); };
    exports.getMonoid = getMonoid;
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var map = function (f) { return function (fa) {
        return exports.isNone(fa) ? exports.none : exports.some(f(fa.value));
    }; };
    exports.map = map;
    /**
     * @category instances
     * @since 2.7.0
     */
    exports.Functor = {
        URI: exports.URI,
        map: _map
    };
    /**
     * @category instance operations
     * @since 2.7.0
     */
    exports.of = exports.some;
    /**
     * @category instances
     * @since 2.10.0
     */
    exports.Pointed = {
        URI: exports.URI,
        of: exports.of
    };
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var ap = function (fa) { return function (fab) {
        return exports.isNone(fab) ? exports.none : exports.isNone(fa) ? exports.none : exports.some(fab.value(fa.value));
    }; };
    exports.ap = ap;
    /**
     * @category instances
     * @since 2.10.0
     */
    exports.Apply = {
        URI: exports.URI,
        map: _map,
        ap: _ap
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    exports.Applicative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of
    };
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation.
     *
     * @category instance operations
     * @since 2.0.0
     */
    var chain = function (f) { return function (ma) {
        return exports.isNone(ma) ? exports.none : f(ma.value);
    }; };
    exports.chain = chain;
    /**
     * @category instances
     * @since 2.10.0
     */
    exports.Chain = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain
    };
    /**
     * @category instances
     * @since 2.7.0
     */
    exports.Monad = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain
    };
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var reduce = function (b, f) { return function (fa) {
        return exports.isNone(fa) ? b : f(b, fa.value);
    }; };
    exports.reduce = reduce;
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var foldMap = function (M) { return function (f) { return function (fa) {
        return exports.isNone(fa) ? M.empty : f(fa.value);
    }; }; };
    exports.foldMap = foldMap;
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var reduceRight = function (b, f) { return function (fa) {
        return exports.isNone(fa) ? b : f(fa.value, b);
    }; };
    exports.reduceRight = reduceRight;
    /**
     * @category instances
     * @since 2.7.0
     */
    exports.Foldable = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight
    };
    /**
     * Less strict version of [`alt`](#alt).
     *
     * @category instance operations
     * @since 2.9.0
     */
    var altW = function (that) { return function (fa) {
        return exports.isNone(fa) ? that() : fa;
    }; };
    exports.altW = altW;
    /**
     * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
     * types of kind `* -> *`.
     *
     * In case of `Option` returns the left-most non-`None` value.
     *
     * @example
     * import * as O from 'fp-ts/Option'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.deepStrictEqual(
     *   pipe(
     *     O.some('a'),
     *     O.alt(() => O.some('b'))
     *   ),
     *   O.some('a')
     * )
     * assert.deepStrictEqual(
     *   pipe(
     *     O.none,
     *     O.alt(() => O.some('b'))
     *   ),
     *   O.some('b')
     * )
     *
     * @category instance operations
     * @since 2.0.0
     */
    exports.alt = exports.altW;
    /**
     * @category instances
     * @since 2.7.0
     */
    exports.Alt = {
        URI: exports.URI,
        map: _map,
        alt: _alt
    };
    /**
     * @category instance operations
     * @since 2.7.0
     */
    var zero = function () { return exports.none; };
    exports.zero = zero;
    /**
     * @category instances
     * @since 2.11.0
     */
    exports.Zero = {
        URI: exports.URI,
        zero: exports.zero
    };
    /**
     * @category constructors
     * @since 2.11.0
     */
    exports.guard = 
    /*#__PURE__*/
    Zero_1.guard(exports.Zero, exports.Pointed);
    /**
     * @category instances
     * @since 2.7.0
     */
    exports.Alternative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        alt: _alt,
        zero: exports.zero
    };
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var extend = function (f) { return function (wa) {
        return exports.isNone(wa) ? exports.none : exports.some(f(wa));
    }; };
    exports.extend = extend;
    /**
     * @category instances
     * @since 2.7.0
     */
    exports.Extend = {
        URI: exports.URI,
        map: _map,
        extend: _extend
    };
    /**
     * @category instance operations
     * @since 2.0.0
     */
    exports.compact = 
    /*#__PURE__*/
    exports.chain(function_1.identity);
    var defaultSeparated = 
    /*#__PURE__*/
    Separated_1.separated(exports.none, exports.none);
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var separate = function (ma) {
        return exports.isNone(ma) ? defaultSeparated : Separated_1.separated(exports.getLeft(ma.value), exports.getRight(ma.value));
    };
    exports.separate = separate;
    /**
     * @category instances
     * @since 2.7.0
     */
    exports.Compactable = {
        URI: exports.URI,
        compact: exports.compact,
        separate: exports.separate
    };
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var filter = function (predicate) { return function (fa) { return (exports.isNone(fa) ? exports.none : predicate(fa.value) ? fa : exports.none); }; };
    exports.filter = filter;
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var filterMap = function (f) { return function (fa) {
        return exports.isNone(fa) ? exports.none : f(fa.value);
    }; };
    exports.filterMap = filterMap;
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var partition = function (predicate) { return function (fa) { return Separated_1.separated(_filter(fa, Predicate_1.not(predicate)), _filter(fa, predicate)); }; };
    exports.partition = partition;
    /**
     * @category instance operations
     * @since 2.0.0
     */
    var partitionMap = function (f) { return function_1.flow(exports.map(f), exports.separate); };
    exports.partitionMap = partitionMap;
    /**
     * @category instances
     * @since 2.7.0
     */
    exports.Filterable = {
        URI: exports.URI,
        map: _map,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap
    };
    /**
     * @category instance operations
     * @since 2.6.3
     */
    var traverse = function (F) { return function (f) { return function (ta) { return (exports.isNone(ta) ? F.of(exports.none) : F.map(f(ta.value), exports.some)); }; }; };
    exports.traverse = traverse;
    /**
     * @category instance operations
     * @since 2.6.3
     */
    var sequence = function (F) { return function (ta) { return (exports.isNone(ta) ? F.of(exports.none) : F.map(ta.value, exports.some)); }; };
    exports.sequence = sequence;
    /**
     * @category instances
     * @since 2.7.0
     */
    exports.Traversable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence
    };
    var _wither = 
    /*#__PURE__*/
    Witherable_1.witherDefault(exports.Traversable, exports.Compactable);
    var _wilt = 
    /*#__PURE__*/
    Witherable_1.wiltDefault(exports.Traversable, exports.Compactable);
    /**
     * @category instance operations
     * @since 2.6.5
     */
    var wither = function (F) {
        var _witherF = _wither(F);
        return function (f) { return function (fa) { return _witherF(fa, f); }; };
    };
    exports.wither = wither;
    /**
     * @category instance operations
     * @since 2.6.5
     */
    var wilt = function (F) {
        var _wiltF = _wilt(F);
        return function (f) { return function (fa) { return _wiltF(fa, f); }; };
    };
    exports.wilt = wilt;
    /**
     * @category instances
     * @since 2.7.0
     */
    exports.Witherable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        wither: _wither,
        wilt: _wilt
    };
    /**
     * @category instance operations
     * @since 2.7.0
     */
    var throwError = function () { return exports.none; };
    exports.throwError = throwError;
    /**
     * @category instances
     * @since 2.7.0
     */
    exports.MonadThrow = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain,
        throwError: exports.throwError
    };
    /**
     * Transforms an `Either` to an `Option` discarding the error.
     *
     * Alias of [getRight](#getright)
     *
     * @category natural transformations
     * @since 2.0.0
     */
    exports.fromEither = exports.getRight;
    /**
     * @category instances
     * @since 2.11.0
     */
    exports.FromEither = {
        URI: exports.URI,
        fromEither: exports.fromEither
    };
    // -------------------------------------------------------------------------------------
    // refinements
    // -------------------------------------------------------------------------------------
    /**
     * Returns `true` if the option is an instance of `Some`, `false` otherwise.
     *
     * @example
     * import { some, none, isSome } from 'fp-ts/Option'
     *
     * assert.strictEqual(isSome(some(1)), true)
     * assert.strictEqual(isSome(none), false)
     *
     * @category refinements
     * @since 2.0.0
     */
    exports.isSome = _.isSome;
    /**
     * Returns `true` if the option is `None`, `false` otherwise.
     *
     * @example
     * import { some, none, isNone } from 'fp-ts/Option'
     *
     * assert.strictEqual(isNone(some(1)), false)
     * assert.strictEqual(isNone(none), true)
     *
     * @category refinements
     * @since 2.0.0
     */
    var isNone = function (fa) { return fa._tag === 'None'; };
    exports.isNone = isNone;
    // -------------------------------------------------------------------------------------
    // destructors
    // -------------------------------------------------------------------------------------
    /**
     * Less strict version of [`match`](#match).
     *
     * @category destructors
     * @since 2.10.0
     */
    var matchW = function (onNone, onSome) { return function (ma) {
        return exports.isNone(ma) ? onNone() : onSome(ma.value);
    }; };
    exports.matchW = matchW;
    /**
     * Alias of [`matchW`](#matchw).
     *
     * @category destructors
     * @since 2.10.0
     */
    exports.foldW = exports.matchW;
    /**
     * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is
     * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.
     *
     * @example
     * import { some, none, match } from 'fp-ts/Option'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.strictEqual(
     *   pipe(
     *     some(1),
     *     match(() => 'a none', a => `a some containing ${a}`)
     *   ),
     *   'a some containing 1'
     * )
     *
     * assert.strictEqual(
     *   pipe(
     *     none,
     *     match(() => 'a none', a => `a some containing ${a}`)
     *   ),
     *   'a none'
     * )
     *
     * @category destructors
     * @since 2.10.0
     */
    exports.match = exports.matchW;
    /**
     * Alias of [`match`](#match).
     *
     * @category destructors
     * @since 2.0.0
     */
    exports.fold = exports.match;
    /**
     * Less strict version of [`getOrElse`](#getorelse).
     *
     * @category destructors
     * @since 2.6.0
     */
    var getOrElseW = function (onNone) { return function (ma) { return (exports.isNone(ma) ? onNone() : ma.value); }; };
    exports.getOrElseW = getOrElseW;
    /**
     * Extracts the value out of the structure, if it exists. Otherwise returns the given default value
     *
     * @example
     * import { some, none, getOrElse } from 'fp-ts/Option'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.strictEqual(
     *   pipe(
     *     some(1),
     *     getOrElse(() => 0)
     *   ),
     *   1
     * )
     * assert.strictEqual(
     *   pipe(
     *     none,
     *     getOrElse(() => 0)
     *   ),
     *   0
     * )
     *
     * @category destructors
     * @since 2.0.0
     */
    exports.getOrElse = exports.getOrElseW;
    // -------------------------------------------------------------------------------------
    // combinators
    // -------------------------------------------------------------------------------------
    /**
     * Derivable from `Functor`.
     *
     * @category combinators
     * @since 2.10.0
     */
    exports.flap = 
    /*#__PURE__*/
    Functor_1.flap(exports.Functor);
    /**
     * Combine two effectful actions, keeping only the result of the first.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    exports.apFirst = 
    /*#__PURE__*/
    Apply_1.apFirst(exports.Apply);
    /**
     * Combine two effectful actions, keeping only the result of the second.
     *
     * Derivable from `Apply`.
     *
     * @category combinators
     * @since 2.0.0
     */
    exports.apSecond = 
    /*#__PURE__*/
    Apply_1.apSecond(exports.Apply);
    /**
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    exports.flatten = exports.compact;
    /**
     * Composes computations in sequence, using the return value of one computation to determine the next computation and
     * keeping only the result of the first.
     *
     * Derivable from `Chain`.
     *
     * @category combinators
     * @since 2.0.0
     */
    exports.chainFirst = 
    /*#__PURE__*/
    Chain_1.chainFirst(exports.Chain);
    /**
     * Derivable from `Extend`.
     *
     * @category combinators
     * @since 2.0.0
     */
    exports.duplicate = 
    /*#__PURE__*/
    exports.extend(function_1.identity);
    /**
     * @category combinators
     * @since 2.11.0
     */
    exports.fromEitherK = 
    /*#__PURE__*/
    FromEither_1.fromEitherK(exports.FromEither);
    /**
     * @category combinators
     * @since 2.11.0
     */
    exports.chainEitherK = 
    /*#__PURE__*/
    FromEither_1.chainEitherK(exports.FromEither, exports.Chain);
    // -------------------------------------------------------------------------------------
    // interop
    // -------------------------------------------------------------------------------------
    /**
     * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise
     * returns the value wrapped in a `Some`.
     *
     * @example
     * import { none, some, fromNullable } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(fromNullable(undefined), none)
     * assert.deepStrictEqual(fromNullable(null), none)
     * assert.deepStrictEqual(fromNullable(1), some(1))
     *
     * @category interop
     * @since 2.0.0
     */
    var fromNullable = function (a) { return (a == null ? exports.none : exports.some(a)); };
    exports.fromNullable = fromNullable;
    /**
     * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a
     * `Some`.
     *
     * See also [`tryCatchK`](#trycatchk).
     *
     * @example
     * import { none, some, tryCatch } from 'fp-ts/Option'
     *
     * assert.deepStrictEqual(
     *   tryCatch(() => {
     *     throw new Error()
     *   }),
     *   none
     * )
     * assert.deepStrictEqual(tryCatch(() => 1), some(1))
     *
     * @category interop
     * @since 2.0.0
     */
    var tryCatch = function (f) {
        try {
            return exports.some(f());
        }
        catch (e) {
            return exports.none;
        }
    };
    exports.tryCatch = tryCatch;
    /**
     * Converts a function that may throw to one returning a `Option`.
     *
     * @category interop
     * @since 2.10.0
     */
    var tryCatchK = function (f) { return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return exports.tryCatch(function () { return f.apply(void 0, a); });
    }; };
    exports.tryCatchK = tryCatchK;
    /**
     * Returns a *smart constructor* from a function that returns a nullable value.
     *
     * @example
     * import { fromNullableK, none, some } from 'fp-ts/Option'
     *
     * const f = (s: string): number | undefined => {
     *   const n = parseFloat(s)
     *   return isNaN(n) ? undefined : n
     * }
     *
     * const g = fromNullableK(f)
     *
     * assert.deepStrictEqual(g('1'), some(1))
     * assert.deepStrictEqual(g('a'), none)
     *
     * @category interop
     * @since 2.9.0
     */
    var fromNullableK = function (f) { return function_1.flow(f, exports.fromNullable); };
    exports.fromNullableK = fromNullableK;
    /**
     * This is `chain` + `fromNullable`, useful when working with optional values.
     *
     * @example
     * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'
     * import { pipe } from 'fp-ts/function'
     *
     * interface Employee {
     *   readonly company?: {
     *     readonly address?: {
     *       readonly street?: {
     *         readonly name?: string
     *       }
     *     }
     *   }
     * }
     *
     * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }
     *
     * assert.deepStrictEqual(
     *   pipe(
     *     fromNullable(employee1.company),
     *     chainNullableK(company => company.address),
     *     chainNullableK(address => address.street),
     *     chainNullableK(street => street.name)
     *   ),
     *   some('high street')
     * )
     *
     * const employee2: Employee = { company: { address: { street: {} } } }
     *
     * assert.deepStrictEqual(
     *   pipe(
     *     fromNullable(employee2.company),
     *     chainNullableK(company => company.address),
     *     chainNullableK(address => address.street),
     *     chainNullableK(street => street.name)
     *   ),
     *   none
     * )
     *
     * @category interop
     * @since 2.9.0
     */
    var chainNullableK = function (f) { return function (ma) {
        return exports.isNone(ma) ? exports.none : exports.fromNullable(f(ma.value));
    }; };
    exports.chainNullableK = chainNullableK;
    /**
     * Extracts the value out of the structure, if it exists. Otherwise returns `null`.
     *
     * @example
     * import { some, none, toNullable } from 'fp-ts/Option'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.strictEqual(
     *   pipe(
     *     some(1),
     *     toNullable
     *   ),
     *   1
     * )
     * assert.strictEqual(
     *   pipe(
     *     none,
     *     toNullable
     *   ),
     *   null
     * )
     *
     * @category interop
     * @since 2.0.0
     */
    exports.toNullable = 
    /*#__PURE__*/
    exports.match(function_1.constNull, function_1.identity);
    /**
     * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.
     *
     * @example
     * import { some, none, toUndefined } from 'fp-ts/Option'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.strictEqual(
     *   pipe(
     *     some(1),
     *     toUndefined
     *   ),
     *   1
     * )
     * assert.strictEqual(
     *   pipe(
     *     none,
     *     toUndefined
     *   ),
     *   undefined
     * )
     *
     * @category interop
     * @since 2.0.0
     */
    exports.toUndefined = 
    /*#__PURE__*/
    exports.match(function_1.constUndefined, function_1.identity);
    function elem(E) {
        return function (a, ma) {
            if (ma === undefined) {
                var elemE_1 = elem(E);
                return function (ma) { return elemE_1(a, ma); };
            }
            return exports.isNone(ma) ? false : E.equals(a, ma.value);
        };
    }
    exports.elem = elem;
    /**
     * Returns `true` if the predicate is satisfied by the wrapped value
     *
     * @example
     * import { some, none, exists } from 'fp-ts/Option'
     * import { pipe } from 'fp-ts/function'
     *
     * assert.strictEqual(
     *   pipe(
     *     some(1),
     *     exists(n => n > 0)
     *   ),
     *   true
     * )
     * assert.strictEqual(
     *   pipe(
     *     some(1),
     *     exists(n => n > 1)
     *   ),
     *   false
     * )
     * assert.strictEqual(
     *   pipe(
     *     none,
     *     exists(n => n > 0)
     *   ),
     *   false
     * )
     *
     * @since 2.0.0
     */
    var exists = function (predicate) { return function (ma) {
        return exports.isNone(ma) ? false : predicate(ma.value);
    }; };
    exports.exists = exists;
    // -------------------------------------------------------------------------------------
    // do notation
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.9.0
     */
    exports.Do = 
    /*#__PURE__*/
    exports.of(_.emptyRecord);
    /**
     * @since 2.8.0
     */
    exports.bindTo = 
    /*#__PURE__*/
    Functor_1.bindTo(exports.Functor);
    /**
     * @since 2.8.0
     */
    exports.bind = 
    /*#__PURE__*/
    Chain_1.bind(exports.Chain);
    // -------------------------------------------------------------------------------------
    // pipeable sequence S
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.8.0
     */
    exports.apS = 
    /*#__PURE__*/
    Apply_1.apS(exports.Apply);
    // -------------------------------------------------------------------------------------
    // sequence T
    // -------------------------------------------------------------------------------------
    /**
     * @since 2.11.0
     */
    exports.ApT = 
    /*#__PURE__*/
    exports.of(_.emptyReadonlyArray);
    // -------------------------------------------------------------------------------------
    // array utils
    // -------------------------------------------------------------------------------------
    /**
     * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyNonEmptyArrayWithIndex = function (f) { return function (as) {
        var o = f(0, _.head(as));
        if (exports.isNone(o)) {
            return exports.none;
        }
        var out = [o.value];
        for (var i = 1; i < as.length; i++) {
            var o_1 = f(i, as[i]);
            if (exports.isNone(o_1)) {
                return exports.none;
            }
            out.push(o_1.value);
        }
        return exports.some(out);
    }; };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    /**
     * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
     *
     * @since 2.11.0
     */
    var traverseReadonlyArrayWithIndex = function (f) {
        var g = exports.traverseReadonlyNonEmptyArrayWithIndex(f);
        return function (as) { return (_.isNonEmpty(as) ? g(as) : exports.ApT); };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    /**
     * @since 2.9.0
     */
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    /**
     * @since 2.9.0
     */
    var traverseArray = function (f) {
        return exports.traverseReadonlyArrayWithIndex(function (_, a) { return f(a); });
    };
    exports.traverseArray = traverseArray;
    /**
     * @since 2.9.0
     */
    exports.sequenceArray = 
    /*#__PURE__*/
    exports.traverseArray(function_1.identity);
    // -------------------------------------------------------------------------------------
    // deprecated
    // -------------------------------------------------------------------------------------
    // tslint:disable: deprecation
    /**
     * Use `Refinement` module instead.
     *
     * @since 2.0.0
     * @deprecated
     */
    function getRefinement(getOption) {
        return function (a) { return exports.isSome(getOption(a)); };
    }
    exports.getRefinement = getRefinement;
    /**
     * Use [`chainNullableK`](#chainnullablek) instead.
     *
     * @category combinators
     * @since 2.0.0
     * @deprecated
     */
    exports.mapNullable = exports.chainNullableK;
    /**
     * Use small, specific instances instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.option = {
        URI: exports.URI,
        map: _map,
        of: exports.of,
        ap: _ap,
        chain: _chain,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        zero: exports.zero,
        alt: _alt,
        extend: _extend,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        wither: _wither,
        wilt: _wilt,
        throwError: exports.throwError
    };
    /**
     * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.getApplySemigroup = 
    /*#__PURE__*/
    Apply_1.getApplySemigroup(exports.Apply);
    /**
     * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    exports.getApplyMonoid = 
    /*#__PURE__*/
    Applicative_1.getApplicativeMonoid(exports.Applicative);
    /**
     * Use
     *
     * ```ts
     * import { first } from 'fp-ts/Semigroup'
     * import { getMonoid } from 'fp-ts/Option'
     *
     * getMonoid(first())
     * ```
     *
     * instead.
     *
     * Monoid returning the left-most non-`None` value
     *
     * | x       | y       | concat(x, y) |
     * | ------- | ------- | ------------ |
     * | none    | none    | none         |
     * | some(a) | none    | some(a)      |
     * | none    | some(b) | some(b)      |
     * | some(a) | some(b) | some(a)      |
     *
     * @example
     * import { getFirstMonoid, some, none } from 'fp-ts/Option'
     *
     * const M = getFirstMonoid<number>()
     * assert.deepStrictEqual(M.concat(none, none), none)
     * assert.deepStrictEqual(M.concat(some(1), none), some(1))
     * assert.deepStrictEqual(M.concat(none, some(2)), some(2))
     * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getFirstMonoid = function () { return exports.getMonoid(Semigroup_1.first()); };
    exports.getFirstMonoid = getFirstMonoid;
    /**
     * Use
     *
     * ```ts
     * import { last } from 'fp-ts/Semigroup'
     * import { getMonoid } from 'fp-ts/Option'
     *
     * getMonoid(last())
     * ```
     *
     * instead.
     *
     * Monoid returning the right-most non-`None` value
     *
     * | x       | y       | concat(x, y) |
     * | ------- | ------- | ------------ |
     * | none    | none    | none         |
     * | some(a) | none    | some(a)      |
     * | none    | some(b) | some(b)      |
     * | some(a) | some(b) | some(b)      |
     *
     * @example
     * import { getLastMonoid, some, none } from 'fp-ts/Option'
     *
     * const M = getLastMonoid<number>()
     * assert.deepStrictEqual(M.concat(none, none), none)
     * assert.deepStrictEqual(M.concat(some(1), none), some(1))
     * assert.deepStrictEqual(M.concat(none, some(2)), some(2))
     * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))
     *
     * @category instances
     * @since 2.0.0
     * @deprecated
     */
    var getLastMonoid = function () { return exports.getMonoid(Semigroup_1.last()); };
    exports.getLastMonoid = getLastMonoid;
    }(Option));

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sampleIndex = exports.frames = exports.seconds = exports.x4p = exports.tanp = exports.cosp = exports.sinp = exports.floorp = exports.clampp = exports.absp = exports.funcp2 = exports.funcp = exports.powp = exports.modp = exports.divp = exports.subp = exports.addp = exports.multp = exports.mathopp = exports.chan0 = exports.chan = exports.compp = exports.matp = exports.sopp = exports.chopp = exports.datp = exports.topp = exports.castp = exports.casts = exports.castf = exports.castt = exports.casti = exports.whp = exports.xyzwp = exports.rgbp = exports.xyzp = exports.xyp = exports.mp = exports.tp = exports.sp = exports.ip = exports.fp = exports.feedbackChain = exports.feedbacktarget = exports.feedbacktop = exports.node = exports.insertconn = exports.cc = exports.compe = exports.comp = exports.mate = exports.mat = exports.sope = exports.sop = exports.chope = exports.chop = exports.date = exports.dat = exports.tope = exports.top = exports.constructNodeFromDefault = void 0;
    const Types_1 = Types;
    const guid_typescript_1 = guid;
    const Option_1 = Option;
    const assert = {
        ok: (res, str) => { if (!res) {
            throw new Error(str);
        } },
        equal: (a, b, str = 'something went wrong') => { if (a !== b) {
            throw new Error(str);
        } }
    };
    // Ops
    // const op = <T extends OP>(type: OP) => (optype: string, params: { [name: string] : IParamAny}) : OpTree<T> => {
    //   if (type === "DAT"){}
    //   return new OpTree<T>({family: type, type: optype + type, params: params, connections: []}, [])
    // }
    // New chain mechanism
    exports.constructNodeFromDefault = (n) => Object.assign({ unique: Option_1.none, text: Option_1.none, connections: [], params: {}, actions: [] }, n);
    const op = (type) => (ty, params = {}, actions = [], unique = null, text = null) => new Types_1.DisconnectedNode((inputs) => new Types_1.Node({
        type: ty + type,
        family: type,
        actions,
        params,
        connections: inputs.map(n => n.node),
        unique: Option_1.fromNullable(unique),
        text: Option_1.fromNullable(text)
    }));
    exports.top = op("TOP");
    exports.tope = (optype) => op("TOP")(optype, {});
    exports.dat = op("DAT");
    exports.date = (optype) => op("DAT")(optype, {});
    exports.chop = op("CHOP");
    exports.chope = (optype) => op("CHOP")(optype, {});
    exports.sop = op("SOP");
    exports.sope = (optype) => op("SOP")(optype, {});
    exports.mat = op("MAT");
    exports.mate = (optype) => op("MAT")(optype, {});
    exports.comp = op("COMP");
    exports.compe = (optype) => op("COMP")(optype, {});
    // export const replacetop = new ReplaceTree<"TOP">(tope("null").value, [])
    // export const replacechop = new ReplaceTree<"CHOP">(chope("null").value, [])
    // export const replacedat = new ReplaceTree<"DAT">(date("null").value, [])
    // export const replacesop = new ReplaceTree<"SOP">(sope("null").value, [])
    // export const replacemat = new ReplaceTree<"MAT">(mate("null").value, [])
    // export const cc = <T extends OP>(handlef: (self: OpTree<T>, n: OpTree<T>) => OpTree<T>, root: OpTree<T>) => {
    //   new CustomConnectOpTree<T>(handlef, root.value, root.forest as OpTree<T>[]);
    // }
    exports.cc = (func) => {
        return new Types_1.DisconnectedNode(func);
    };
    exports.insertconn = (dn, before, after) => {
        return exports.cc((inputs) => dn.run(before.concat(inputs, after)));
    };
    exports.node = (n) => {
        return new Types_1.Node(n);
    };
    exports.feedbacktop = () => {
        return exports.cc((inputs) => exports.node(exports.constructNodeFromDefault({ family: "TOP", type: "feedbackTOP", special: "FB", id: guid_typescript_1.Guid.create(), unique: Option_1.none, actions: [], connections: inputs.map(i => i.out()), params: {} })));
    };
    exports.feedbacktarget = (fbg, optype, params) => {
        return exports.cc((inputs) => exports.node(exports.constructNodeFromDefault({ special: "FBT", selects: [fbg], unique: Option_1.none, actions: [], connections: inputs.map(i => i.out()), params: params, type: optype + "TOP", family: "TOP" })));
    };
    exports.feedbackChain = (middle) => {
        return exports.cc((inputs) => {
            let fbt = exports.feedbacktop();
            let baseop = (id) => exports.cc((inputs) => {
                let basemiddle = middle.run(inputs).out();
                return exports.node(exports.constructNodeFromDefault({ special: "FBT", selects: [id], unique: Option_1.none, actions: [], connections: basemiddle.connections, params: middle.run(inputs).out().params, type: middle.out().type, family: "TOP" }));
            });
            return fbt.connect(exports.cc((inputs) => baseop(inputs[0].node.id).run(inputs))).run(inputs);
        });
    };
    exports.fp = (v) => {
        assert.ok(typeof v === 'number', "float param only takes numbers");
        return { type: "float", value0: [String(v)] };
    };
    exports.ip = (v) => {
        assert.ok(Number.isSafeInteger(v), "integer param only takes integers");
        return { type: "number", value0: [String(v)] };
    };
    exports.sp = (v) => {
        assert.equal(typeof v, "string");
        return ({ type: "string", value0: ['"' + v + '"'] });
    };
    exports.tp = (v) => {
        assert.ok(typeof v === 'boolean', "boolean param only takes booleans");
        return { type: "toggle", value0: [String(v ? 1 : 0)] };
    };
    exports.mp = (v) => {
        assert.ok(Number.isSafeInteger(v), "menu param only takes integers");
        return { type: "menu", value0: [String(v)] };
    };
    exports.xyp = (v0, v1) => {
        assert.ok((v0.type == "float" || v0.type === "number") && (v1.type == "float" || v1.type === "number"), "xy requires float params");
        return ({ type: "xy", value0: v0.value0, value1: v1.value0 });
    };
    exports.xyzp = (v0, v1, v2) => {
        assert.ok(v0.type == "float" || v0.type == "number", "xyz requires float params");
        assert.ok(v1.type == "float" || v1.type == "number", "xyz requires float params");
        assert.ok(v2.type == "float" || v2.type == "number", "xyz requires float params");
        return ({ type: "xyz", value0: v0.value0, value1: v1.value0, value2: v2.value0 });
    };
    exports.rgbp = (v0, v1, v2) => {
        assert.ok(v0.type == "float" || v0.type == "number", "rgb requires float params");
        assert.ok(v1.type == "float" || v1.type == "number", "rgb requires float params");
        assert.ok(v2.type == "float" || v2.type == "number", "rgb requires float params");
        return ({ type: "rgb", value0: v0.value0, value1: v1.value0, value2: v2.value0 });
    };
    exports.xyzwp = (v0, v1, v2, v3) => {
        assert.ok(v0.type == "float" || v0.type == "number", "xyzw requires float params");
        assert.ok(v1.type == "float" || v1.type == "number", "xyzw requires float params");
        assert.ok(v2.type == "float" || v2.type == "number", "xyzw requires float params");
        assert.ok(v3.type == "float" || v3.type == "number", "xyzw requires float params");
        return ({ type: "xyzw", value0: v0.value0, value1: v1.value0, value2: v2.value0, value3: v3.value0 });
    };
    exports.whp = (v0, v1) => {
        assert.ok(v0.type == "number" && v1.type == "number", "wh requires number params");
        return ({ type: "wh", value0: v0.value0, value1: v1.value0 });
    };
    const cast = (ty, op) => (v) => ({
        type: ty,
        value0: [op, "("].concat(v.value0, [")"])
    });
    exports.casti = cast("number", "int");
    exports.castt = cast("toggle", "bool");
    exports.castf = cast("float", "float");
    exports.casts = cast("string", "str");
    exports.castp = cast("pulse", "int");
    const opp = (type) => (n) => {
        assert.equal(type, (Array.isArray(n) ? n[0] : n).out().family, "param and op family must match");
        return { type: type, value0: ['\"'].concat(n instanceof Array ? n.map(n => n.runT().out()) : [n.out()], ['\"']) };
    };
    exports.topp = opp("TOP");
    exports.datp = opp("DAT");
    exports.chopp = opp("CHOP");
    exports.sopp = opp("SOP");
    exports.matp = opp("MAT");
    exports.compp = opp("COMP");
    exports.chan = (i, v) => {
        let out = v.out();
        assert.equal("CHOP", out.family, "param and op family must match");
        assert.ok("number" === i.type || "string" === i.type, "chan needs integer or string param index");
        return ({ type: "float", value0: ['op(\"', v.out(), '\")['].concat(i.value0, [']']) });
    };
    exports.chan0 = (chop) => exports.chan(exports.ip(0), chop);
    exports.mathopp = (t) => (a, b) => {
        assert.ok("float" === a.type || "number" === b.type, t + "is a float or integer op");
        assert.equal(a.type, b.type, t + " ops match");
        return { type: a.type, value0: ["( "].concat(a.value0, [" " + t + " "], b.value0, [" )"]) };
    };
    exports.multp = exports.mathopp("*");
    exports.addp = exports.mathopp("+");
    exports.subp = exports.mathopp("-");
    exports.divp = exports.mathopp("/");
    exports.modp = exports.mathopp("%");
    exports.powp = exports.mathopp("**");
    exports.funcp = (b) => (a) => {
        return { type: "float", value0: [b, "("].concat(a.value0, [")"]) };
    };
    exports.funcp2 = (f) => (a, b) => {
        return { type: "float", value0: [f, "("].concat(a.value0, [", "], b.value0, [")"]) };
    };
    exports.absp = exports.funcp("abs");
    exports.clampp = exports.funcp2("clamp");
    exports.floorp = exports.funcp("math.floor");
    exports.sinp = exports.funcp("math.sin");
    exports.cosp = exports.funcp("math.cos");
    exports.tanp = exports.funcp("math.tan");
    exports.x4p = (v0) => {
        assert.ok(v0.type == "float", "xyzw requires float params");
        return ({ type: "xyzw", value0: v0.value0, value1: [], value2: [], value3: [] });
    };
    exports.seconds = { type: "float", value0: ["absTime.seconds"] };
    exports.frames = { type: "float", value0: ["absTime.frame"] };
    exports.sampleIndex = { type: "number", value0: ["sampleIndex"] };

    }(Chain$1));

    var oscillare = {};

    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    Object.defineProperty(oscillare, "__esModule", { value: true });
    oscillare.runop = oscillare.fullscreentext = oscillare.textdat = oscillare.changestop = oscillare.removedtop = oscillare.removedchange = oscillare.removed = oscillare.addedtop = oscillare.addedchange = oscillare.added = oscillare.gesturetop = oscillare.gesture = oscillare.senseltouches = oscillare.senseltop = oscillare.senselchop = oscillare.sensel = oscillare.pulse = oscillare.multchops = oscillare.dmxtochop = oscillare.beatsecondschop = oscillare.tapbeatm9sec = oscillare.beatseconds = oscillare.beatxramp = oscillare.beatxpulse = oscillare.beatxcount = oscillare.beatramp = oscillare.tapbeatm9 = oscillare.tapbeat = oscillare.sinct = oscillare.flocking = oscillare.torusGeo = oscillare.geoGeo = oscillare.distfun = oscillare.movecircle = oscillare.decaywave = oscillare.centerCam = oscillare.lineLines = oscillare.line = oscillare.sidesTorus = oscillare.scaleC = oscillare.sinC = oscillare.renderEasy = oscillare.render = oscillare.tox = oscillare.geo = oscillare.floor = oscillare.secs = oscillare.fade = oscillare.triggerchops = oscillare.triggerops = oscillare.littleplanet = oscillare.triggercount = oscillare.bounce = oscillare.fadeops = oscillare.overops = oscillare.multops = oscillare.addops = oscillare.edgesc = oscillare.sat = oscillare.lime = oscillare.bluepink = oscillare.flower = oscillare.buddhist = oscillare.fire = oscillare.neon = oscillare.tealblue = oscillare.greenpurple = oscillare.nature = oscillare.darkestred = oscillare.coolpink = oscillare.sunset = oscillare.bnw = oscillare.purplish = oscillare.tealcontrast = oscillare.palettecycle = oscillare.palettemap = oscillare.palette = oscillare.rgbt = oscillare.palettergbc = oscillare.rgbc = oscillare.constc = oscillare.const1 = oscillare.mirrory = oscillare.mirrorx = oscillare.strobe = oscillare.repeatTxy = oscillare.repeatT = oscillare.rgbsplit = oscillare.scale = oscillare.transformscale = oscillare.val = oscillare.translatey = oscillare.translatexclamp = oscillare.translatex = oscillare.translatee = oscillare.translate = oscillare.rotate = oscillare.transform = oscillare.noisedisplace = oscillare.mosaic = oscillare.lumidots = oscillare.flowermod = oscillare.commandcode = oscillare.crosshatch = oscillare.stringtheory = oscillare.shapes = oscillare.lines = oscillare.noisects = oscillare.sparsenoisec = oscillare.noisec = oscillare.timeslice = oscillare.speed = oscillare.noisecc = oscillare.noiset = oscillare.adata = oscillare.verticalstack = oscillare.sidebyside = oscillare.frag = oscillare.lagboth = oscillare.lagup = oscillare.lagdown = oscillare.cxyzp = oscillare.mchop = oscillare.mchan = oscillare.bandvc = oscillare.bandv = oscillare.bandPass = oscillare.highvc = oscillare.highv = oscillare.highPass = oscillare.lowvsc = oscillare.lowvc = oscillare.lowvs = oscillare.lowv = oscillare.lowPass = oscillare.volsc = oscillare.volc = oscillare.vols = oscillare.vol = oscillare.analyze = oscillare.aspecttex = oscillare.aspect = oscillare.atex = oscillare.aine = oscillare.ain = void 0;
    const c = __importStar(Chain$1);
    function zip(arrs) {
        let shortest = arrs.reduce((acc, p) => acc.length < p.length ? acc : p);
        return shortest.map(function (_, i) {
            return arrs.map(function (array) { return array[i]; });
        });
    }
    function hexToRgb(hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }
    let rgb = (r, g, b) => ({ r: r, g: g, b: b });
    function ain(g) {
        return c.chope("audiodevicein")
            .connect(c.chop("select", { channames: c.sp("chan1") }))
            .connect(c.chop("resample", { "timeslice": c.tp(false), "method": c.mp(0), "relative": c.mp(0), "end": c.fp(0.03) }))
            .connect(c.chop("math", { "gain": g === undefined ? c.fp(1) : g }));
    }
    oscillare.ain = ain;
    function aine(v) {
        return ain(v == undefined ? c.fp(1) : v);
    }
    oscillare.aine = aine;
    function atex(v) {
        return c.top("chopto", { "chop": c.chopp([ain(v)]) });
    }
    oscillare.atex = atex;
    function aspect() {
        return c.chope('audiodevicein').connect(c.chope('audiospectrum'));
    }
    oscillare.aspect = aspect;
    function aspecttex() {
        return c.top("chopto", { "chop": c.chopp([aspect()]) });
    }
    oscillare.aspecttex = aspecttex;
    function analyze(i) {
        return c.chop('analyze', { "function": c.mp(i) });
    }
    oscillare.analyze = analyze;
    function vol(v) {
        return ain(v).connect(analyze(6));
    }
    oscillare.vol = vol;
    function vols(v) {
        return vol(v).connect(c.chop("speed"));
    }
    oscillare.vols = vols;
    function volc(v) {
        return c.chan(c.ip(0), vol(v));
    }
    oscillare.volc = volc;
    function volsc(v) {
        return c.chan(c.ip(0), vols(v));
    }
    oscillare.volsc = volsc;
    function lowPass() {
        return c.chop("audiofilter", { "filter": c.mp(0) });
    }
    oscillare.lowPass = lowPass;
    function lowv(v) {
        return ain(v).connect(lowPass()).connect(analyze(6));
    }
    oscillare.lowv = lowv;
    function lowvs(v) {
        return lowv(v).connect(c.chop("speed"));
    }
    oscillare.lowvs = lowvs;
    function lowvc(v) {
        return c.chan(c.ip(0), lowv(v));
    }
    oscillare.lowvc = lowvc;
    function lowvsc(v) {
        return c.chan(c.ip(0), lowvs(v));
    }
    oscillare.lowvsc = lowvsc;
    function highPass() {
        return c.chop("audiofilter", { "filter": c.mp(1) });
    }
    oscillare.highPass = highPass;
    function highv(v) {
        return ain(v).connect(highPass()).connect(analyze(6));
    }
    oscillare.highv = highv;
    function highvc(v) {
        return c.chan(c.ip(0), highv(v));
    }
    oscillare.highvc = highvc;
    function bandPass(b) {
        return c.chop("audiofilter", { "filter": c.mp(2), "cutofflog": c.multp(b, c.fp(4.5)) });
    }
    oscillare.bandPass = bandPass;
    function bandv(b, v) {
        return ain(v).connect(bandPass(b)).connect(analyze(6));
    }
    oscillare.bandv = bandv;
    function bandvc(b, v) {
        return c.chan(c.ip(0), bandv(b, v));
    }
    oscillare.bandvc = bandvc;
    function mchan(chan) {
        return c.chan(c.sp(chan), c.chope("midiinmap"));
    }
    oscillare.mchan = mchan;
    function mchop(chan) {
        return c.chope("midiinmap").connect(c.chop("select", { "channames": c.sp(chan) }));
    }
    oscillare.mchop = mchop;
    function cxyzp(val) {
        return c.xyzp(val, val, val);
    }
    oscillare.cxyzp = cxyzp;
    function lagdown(val) {
        return c.chop("lag", { lag2: val });
    }
    oscillare.lagdown = lagdown;
    function lagup(val) {
        return c.chop("lag", { lag1: val });
    }
    oscillare.lagup = lagup;
    function lagboth(val) {
        return c.chop("lag", { lag1: val, lag2: val });
    }
    oscillare.lagboth = lagboth;
    function frag(fragname, uniforms) {
        return c.top("glslmulti", Object.assign({
            "resolutionw": c.ip(1920),
            "resolutionh": c.ip(1080),
            "pixeldat": c.datp([c.dat("text", { "file": c.sp("scripts/Visuals/" + fragname) })]),
            "outputresolution": c.mp(9),
            "format": c.mp(4)
        }, zip([Array(8).fill("uniname"), Array.from(Array(8).keys()), Object.keys(uniforms)]).reduce((acc, v) => { acc[v[0] + v[1]] = c.sp(v[2]); return acc; }, {}), zip([Array(8).fill("value"), Array.from(Array(8).keys()), Object.values(uniforms)]).reduce((acc, v) => { acc[v[0] + v[1]] = v[2]; return acc; }, {})));
    }
    oscillare.frag = frag;
    function sidebyside(inputs) {
        return;
    }
    oscillare.sidebyside = sidebyside;
    function verticalstack(inputs) {
        return c.top("glslmulti", {
            pixeldat: c.datp([
                c.dat("text", {
                    "file": c.sp("scripts/verticalstack.frag")
                })
            ]),
            resolutionw: { type: "number", value0: ["max(map(lambda n: n.width, me.inputs))"] },
            resolutionh: { type: "number", value0: ["sum(map(lambda n: n.height, me.inputs))"] },
            outputresolution: c.mp(9)
        }).run(inputs);
    }
    oscillare.verticalstack = verticalstack;
    function adata(v) {
        return atex(v).connect(frag('audio_data.frag', { 'i_volume': c.x4p(c.fp(1)) }));
    }
    oscillare.adata = adata;
    function noiset(t) {
        return c.top("noise", { "t": c.xyzp(c.fp(0), c.fp(0), t) });
    }
    oscillare.noiset = noiset;
    function noisecc(t, amp, channames) {
        return c.chan(c.ip(0), noisec(t, amp, channames));
    }
    oscillare.noisecc = noisecc;
    function speed(val) {
        return c.chop("speed");
    }
    oscillare.speed = speed;
    function timeslice(off) {
        return c.chop("trim", {
            relative: c.mp(0),
            startunit: c.mp(2),
            endunit: c.mp(2),
            start: off,
            end: off
        });
    }
    oscillare.timeslice = timeslice;
    function noisec(t, amp, channames, seed = c.fp(0)) {
        return c.chop("noise", {
            type: c.mp(3),
            amp: amp,
            left: c.mp(2),
            right: c.mp(2),
            channelname: c.sp(channames),
            seed: seed,
        });
    }
    oscillare.noisec = noisec;
    function sparsenoisec(t, g) {
        return c.chan0(c.chop("noise", {
            seed: c.fp(new Date().getMilliseconds()),
            t: c.xyzp(t, c.fp(0), c.fp(0)),
        })
            .c(c.cc((inputs) => c.chop("math", { gain: g }).run(inputs)))
            .c(c.chop("function", { func: c.mp(1), }))
            .c(c.chop("speed")));
    }
    oscillare.sparsenoisec = sparsenoisec;
    function noisects(t, amp, channames, seed = c.fp(0)) {
        return noisec(t, amp, channames, seed)
            .c(timeslice(t));
    }
    oscillare.noisects = noisects;
    function lines(spacing, width) {
        return frag("lines.frag", { "i_spacing": c.x4p(spacing), "i_width": c.x4p(width) });
    }
    oscillare.lines = lines;
    function shapes(sides, size, width) {
        return frag("shapes.frag", { "i_size": c.x4p(size), "i_width": c.x4p(width), "i_sides": c.x4p(sides) });
    }
    oscillare.shapes = shapes;
    function stringtheory(time, angle, angle_delta, xoffset) {
        return;
    }
    oscillare.stringtheory = stringtheory;
    function crosshatch() {
        return frag("crosshatch.frag", {});
    }
    oscillare.crosshatch = crosshatch;
    function commandcode(text) {
        return c.top("text", {
            "resolutionw": c.ip(1920),
            "resolutionh": c.ip(1080),
            "fontsizey": c.fp(16),
            "alignx": c.mp(0),
            "aligny": c.mp(0),
            "text": c.sp(text),
            "dispmethod": c.mp(3),
            "fontautosize": c.mp(1)
        });
    }
    oscillare.commandcode = commandcode;
    function flowermod(s) {
        return frag("flower_mod.frag", { "uSeconds": c.x4p(s) });
    }
    oscillare.flowermod = flowermod;
    function lumidots() {
        return frag("lumidots.frag", {});
    }
    oscillare.lumidots = lumidots;
    function mosaic(t, s) {
        return frag("mosaic.frag", { "uTime": c.x4p(t), "uScale": c.x4p(s) });
    }
    oscillare.mosaic = mosaic;
    function noisedisplace(t, d) {
        return frag("noise_displace.frag", { "uTime": c.x4p(t), "uDisplacement": c.x4p(d) });
    }
    oscillare.noisedisplace = noisedisplace;
    function transform(extra) {
        return c.top("transform", extra);
    }
    oscillare.transform = transform;
    function rotate(r) {
        return transform({ "rotate": r });
    }
    oscillare.rotate = rotate;
    function translate(x, y) {
        return transform({ "t": c.xyp(x, y), "extend": c.mp(3) });
    }
    oscillare.translate = translate;
    function translatee(x, y, e) {
        return transform({ "t": c.xyp(x, y), "extend": c.mp(e) });
    }
    oscillare.translatee = translatee;
    function translatex(x) {
        return translate(x, c.fp(0));
    }
    oscillare.translatex = translatex;
    function translatexclamp(t, clamp) {
        return c.top("transform", {
            t: c.xyp(c.multp(floor(c.divp(c.modp(t, c.fp(1)), clamp)), clamp), c.fp(0)),
            extend: c.mp(2),
        });
    }
    oscillare.translatexclamp = translatexclamp;
    function translatey(y) {
        return translate(c.fp(0), y);
    }
    oscillare.translatey = translatey;
    function val(v) {
        return c.top("hsvadjust", { "valuemult": v });
    }
    oscillare.val = val;
    function transformscale(f, x, y, e) {
        return transform(Object.assign({
            "extend": c.mp(e),
            "s": c.xyp(c.powp(x, c.fp(-1)), c.powp(y, c.fp(-1)))
        }, f));
    }
    oscillare.transformscale = transformscale;
    function scale(xy) {
        return transformscale({}, xy, xy, 1);
    }
    oscillare.scale = scale;
    function rgbsplit(s) {
        return frag("rgbsplit.frag", { "uFrames": c.x4p(s) });
    }
    oscillare.rgbsplit = rgbsplit;
    function repeatT(x, y) { return transformscale({}, x, y, 3); }
    oscillare.repeatT = repeatT;
    function repeatTxy(xy) { return transformscale({}, xy, xy, 3); }
    oscillare.repeatTxy = repeatTxy;
    function strobe(s) {
        return frag("strobe.frag", { "uSpeed": c.x4p(s), "uTime": c.x4p(c.seconds) });
    }
    oscillare.strobe = strobe;
    function mirrorx() {
        return c.cc((inputs) => addops([inputs[0].c(c.top("flip", { flipx: c.tp(true) }))].concat(inputs)));
    }
    oscillare.mirrorx = mirrorx;
    function mirrory() {
        return c.cc((inputs) => addops([inputs[0].c(c.top("flip", { flipy: c.tp(true) }))].concat(inputs)));
    }
    oscillare.mirrory = mirrory;
    function const1(v) {
        return c.chop("constant", { "name0": c.sp("const"), "value0": v });
    }
    oscillare.const1 = const1;
    function constc(namevals) {
        return c.chop("constant", Object.entries(namevals).reduce(function (map, val, idx) {
            map["name" + idx] = c.sp(val[0]);
            map["value" + idx] = val[1];
            return map;
        }, {}));
    }
    oscillare.constc = constc;
    function rgbc(r, g, b) {
        return constc({ r: r, g: g, b: b });
    }
    oscillare.rgbc = rgbc;
    function palettergbc(color) {
        return rgbc(c.fp(color.r / 255), c.fp(color.g / 255), c.fp(color.b / 255));
    }
    oscillare.palettergbc = palettergbc;
    function rgbt(color) {
        return c.top("chopto", { "chop": c.chopp([palettergbc(color).runT()]), "dataformat": c.mp(2) });
    }
    oscillare.rgbt = rgbt;
    function palette(colors) {
        return c.top("chopto", {
            "chop": c.chopp([
                c.chope("merge")
                    .run(colors.map((col) => palettergbc(col).runT()))
                    .connect(c.chop("shuffle", { "method": c.mp(2), "nval": c.ip(3) }))
            ]),
            "dataformat": c.mp(2)
        });
    }
    oscillare.palette = palette;
    function palettemap(p, o) {
        return c.insertconn(frag("palette_map.frag", { "uOffset": c.x4p(o), "uSamples": c.x4p(c.fp(16)) }), [], [palette(p).runT()]);
    }
    oscillare.palettemap = palettemap;
    function palettecycle(palette, s) {
        let palettechop = c.chop("cross", { "cross": c.modp(s, c.fp(palette.length)) }).run(palette.map((col) => palettergbc(col).runT()));
        let palettet = c.top("chopto", { "chop": c.chopp([palettechop]), "dataformat": c.mp(2) });
        return c.cc((inputs) => c.top("composite", { "operand": c.mp(27) }).run([palettet.runT()].concat(inputs)));
    }
    oscillare.palettecycle = palettecycle;
    oscillare.tealcontrast = [rgb(188, 242, 246), rgb(50, 107, 113), rgb(211, 90, 30), rgb(209, 122, 43), rgb(188, 242, 246)];
    oscillare.purplish = [rgb(150, 110, 100), rgb(223, 143, 67), rgb(76, 73, 100), rgb(146, 118, 133), rgb(165, 148, 180)];
    oscillare.bnw = [rgb(255, 255, 255), rgb(0, 0, 0)];
    oscillare.sunset = [rgb(185, 117, 19), rgb(228, 187, 108), rgb(251, 162, 1), rgb(255, 243, 201)];
    oscillare.coolpink = [rgb(215, 40, 26), rgb(157, 60, 121), rgb(179, 83, 154), rgb(187, 59, 98)];
    oscillare.darkestred = [rgb(153, 7, 17), rgb(97, 6, 11), rgb(49, 7, 8), rgb(13, 7, 7), rgb(189, 5, 13)];
    oscillare.nature = [rgb(63, 124, 7), rgb(201, 121, 66), rgb(213, 101, 23), rgb(177, 201, 80), rgb(180, 207, 127)];
    oscillare.greenpurple = [rgb(42, 4, 74), rgb(11, 46, 89), rgb(13, 103, 89), rgb(122, 179, 23), rgb(160, 197, 95)];
    oscillare.tealblue = [rgb(188, 242, 246), rgb(50, 107, 113), rgb(188, 242, 246), rgb(165, 148, 180)];
    oscillare.neon = ["A9336B", "5F2F88", "CB673D", "87BB38"].map(hexToRgb);
    oscillare.fire = ["F07F13", "800909", "F27D0C", "FDCF58"].map(hexToRgb);
    oscillare.buddhist = ["0000FF", "FFFF00", "FF0000", "FFFFFF", "FF9800"].map(hexToRgb);
    oscillare.flower = ["000E00", "003D00", "E4A900", "FEDEEF", "C99CB8"].map(hexToRgb);
    oscillare.bluepink = ["F2C6F2", "F8F0F0", "A6D1FF", "3988E1", "4C8600"].map(hexToRgb);
    oscillare.lime = ["FF4274", "DCD549", "ABDFAB", "437432", "033B45"].map(hexToRgb);
    function sat(s) {
        return c.top("hsvadjust", { "saturationmult": s });
    }
    oscillare.sat = sat;
    function edgesc(original) {
        return c.cc((inputs) => c.top("composite", { "operand": c.mp(0) })
            .run([
            inputs[0].connect(c.tope("edge")),
            inputs[0].connect(c.top("level", { "opacity": original }))
        ]));
    }
    oscillare.edgesc = edgesc;
    function addops(nodes) {
        return c.top("composite", { "operand": c.mp(0) }).run(nodes.map((n) => n.runT()));
    }
    oscillare.addops = addops;
    function multops(nodes) {
        return c.top("composite", { "operand": c.mp(27) }).run(nodes.map((n) => n.runT()));
    }
    oscillare.multops = multops;
    function overops(nodes) {
        return c.top("composite", { "operand": c.mp(31) }).run(nodes.map((n) => n.runT()));
    }
    oscillare.overops = overops;
    function fadeops(idx, ops) {
        return c.top("switch", { "blend": c.tp(true), "index": bounce(idx, 0.4) }).run(ops.map(o => o.runT()));
    }
    oscillare.fadeops = fadeops;
    function bounce(fp, i) {
        return c.absp(c.subp(c.modp(fp, c.fp(i * 2)), c.fp(1)));
    }
    oscillare.bounce = bounce;
    function triggercount(l, f) {
        return f.connect(c.chop("count", {
            "threshold": c.tp(true),
            "threshup": c.fp(0.5),
            "limitmax": c.fp(l),
            "output": c.mp(1)
        }));
    }
    oscillare.triggercount = triggercount;
    function littleplanet() {
        return frag("little_planet.frag", {});
    }
    oscillare.littleplanet = littleplanet;
    function triggerops(f, inputs) {
        return c.top("switch", {
            "index": c.chan(c.ip(0), triggercount(inputs.length - 1, f))
        }).run(inputs.map((i) => i.runT()));
    }
    oscillare.triggerops = triggerops;
    function triggerchops(f, inputs) {
        return c.chop("switch", {
            "index": c.chan(c.ip(0), triggercount(inputs.length - 1, f))
        }).run(inputs.map((i) => i.runT()));
    }
    oscillare.triggerchops = triggerchops;
    function fade(opacity, midops = c.cc((inputs) => inputs[0])) {
        return c.cc((inputs) => c.feedbackChain(c.cc((fbinputs) => c.top("composite", { "operand": c.mp(0) })
            .run(inputs.concat([
            c.top("level", { "opacity": opacity })
                .c(midops)
                .run(fbinputs)
        ])))).run(inputs));
    }
    oscillare.fade = fade;
    function secs(m) {
        return c.multp(c.seconds, m);
    }
    oscillare.secs = secs;
    function floor(f) {
        return c.funcp("math.floor")(f);
    }
    oscillare.floor = floor;
    function geo(params) {
        return c.comp("geometry", Object.assign({ externaltox: c.sp("toxes/Visuals/geo.tox") }, params));
    }
    oscillare.geo = geo;
    function tox(tox, params) { return c.comp("base", Object.assign({ externaltox: c.sp(tox) }, params)); }
    oscillare.tox = tox;
    function render(g, cam, light) {
        return c.top("render", {
            lights: light === undefined ? c.compp([c.compe("light")]) : c.compp(light),
            geometry: c.compp(g),
            camera: cam === undefined ? c.compp([c.compe("camera")]) : c.compp(cam),
            resolutionw: c.ip(1920),
            resolutionh: c.ip(1080)
        });
    }
    oscillare.render = render;
    function renderEasy(sop, instances, geoparams) {
        return c.top("render", {
            "lights": c.compp([c.comp("light", { lighttype: c.mp(2) })]),
            "geometry": c.compp([
                sop.connect(c.comp("geometry", Object.assign({
                    externaltox: c.sp("toxes/Visuals/geo.tox"),
                    material: c.matp([c.mat("pbr", {
                            roughness: c.fp(0.2),
                            metallic: c.fp(0.5),
                            rim1enable: c.tp(true),
                            rim1color: c.rgbp(c.fp(1), c.fp(0), c.fp(0.55)),
                        })]),
                    instanceop: c.chopp([instances]),
                    instancing: c.tp(true),
                    instancetx: c.sp("tx"),
                    instancety: c.sp("ty"),
                    instancetz: c.sp("tz"),
                    instancerx: c.sp("rx"),
                    instancery: c.sp("ry"),
                    instancerz: c.sp("rz"),
                    instancesx: c.sp("sx"),
                    instancesy: c.sp("sy"),
                    instancesz: c.sp("sz"),
                }, geoparams))),
            ]),
            "camera": c.compp([c.compe("camera")]),
            resolutionw: c.ip(1920),
            resolutionh: c.ip(1080)
        });
    }
    oscillare.renderEasy = renderEasy;
    function sinC(i, phase, off) {
        return c.chop("wave", {
            "channelname": c.sp("rz"),
            "end": i,
            "endunit": c.mp(1),
            phase: phase,
            offset: off
        });
    }
    oscillare.sinC = sinC;
    function scaleC(i, n) {
        return c.chop("wave", {
            channelname: c.sp("sx"),
            "end": i,
            "endunit": c.mp(1),
            "wavetype": c.mp(4),
            "period": i,
            "amp": n
        });
    }
    oscillare.scaleC = scaleC;
    function sidesTorus(sides, scale) {
        return c.sop("torus", {
            orientation: c.fp(2),
            rows: c.fp(10),
            columns: sides,
            radius: c.xyp(scale, c.multp(scale, c.fp(0.5)))
        });
    }
    oscillare.sidesTorus = sidesTorus;
    function line(ty, rz, sx, sy, sop, width, instances, mat) {
        let tx = c.chop("wave", {
            channelname: c.sp("tx"),
            end: instances,
            endunit: c.mp(1),
            period: instances,
            amp: width,
            offset: c.fp(-0.5),
            "wavetype": c.mp(4),
        });
        let typ = ty.connect(c.chop("resample", {
            rate: instances,
            timeslice: c.tp(false)
        })).connect(c.chop("rename", { renameto: c.sp("ty") }));
        let poses = c.chop("merge", { align: c.mp(7) }).run([tx, typ,
            rz.c(c.chop("rename", { renameto: c.sp("rz") })),
            sx.c(c.chop("rename", { renameto: c.sp("sx") })),
            sx.c(c.chop("rename", { renameto: c.sp("sz") })),
            sy.c(c.chop("rename", { renameto: c.sp("sy") }))]
            .map((r) => r.runT()));
        let sgeo = sop.connect(geo({
            material: c.matp([mat]),
            instanceop: c.chopp([poses]),
            instancing: c.tp(true),
            instancetx: c.sp("tx"),
            instancety: c.sp("ty"),
            instancetz: c.sp("tz"),
            instancerx: c.sp("rx"),
            instancery: c.sp("ry"),
            instancerz: c.sp("rz"),
            instancesx: c.sp("sx"),
            instancesy: c.sp("sy"),
            instancesz: c.sp("sz"),
        }));
        return render(sgeo);
    }
    oscillare.line = line;
    function lineLines(width, scale, inst, sop) {
        let instances = c.addp(inst, c.fp(2));
        return line(ain(scale).connect(c.chop("resample", {
            method: c.mp(0),
            end: instances,
            endunit: c.mp(1),
            timeslice: c.tp(false),
            relative: c.mp(0)
        })), sinC(instances, c.fp(0), c.fp(0)), scaleC(instances, c.fp(10)), scaleC(instances, c.fp(10)), sop, width, instances, c.mate("wireframe").runT());
    }
    oscillare.lineLines = lineLines;
    function centerCam(t, r) {
        return c.comp("camera", {
            t: c.xyzp(c.fp(0), c.fp(0), t),
            p: c.xyzp(c.fp(0), c.fp(0), c.multp(c.fp(-1), t)),
            r: r === undefined ? c.xyzp(c.fp(0), c.fp(0), c.fp(0)) : r
        });
    }
    oscillare.centerCam = centerCam;
    function decaywave(v) {
        return c.chop("wave", {
            wavetype: c.mp(1),
            end: c.fp(32),
            endunit: c.mp(1),
            amp: c.fp(0.11),
            decay: c.fp(0.1),
            decayunit: c.mp(1),
            ramp: c.fp(0),
            rampunit: c.mp(1),
            period: c.fp(16),
            periodunit: c.mp(1),
            right: c.mp(0),
        })
            .c(c.chop("trim", { start: c.fp(2) }))
            .c(c.chop("math", { gain: c.fp(2) }));
    }
    oscillare.decaywave = decaywave;
    function movecircle(off, off2) {
        return constc({
            tx: c.multp(c.sinp(off), c.cosp(off2)),
            ty: c.multp(c.sinp(off), c.sinp(off2)),
            tz: c.cosp(off)
        });
    }
    oscillare.movecircle = movecircle;
    function distfun(outerc, fun) {
        return c.chop("math", { chopop: c.mp(2) })
            .run([outerc.runT(), fun.runT()])
            .c(c.chop("function", { func: c.mp(19), expval: c.fp(2) }))
            .c(c.chop("function", { func: c.mp(1) }))
            .c(c.chop("math", { chanop: c.mp(1) }));
    }
    oscillare.distfun = distfun;
    function geoGeo(instancesop, parentchop, scale, cam, lightmap) {
        let chop = c.chop("merge").run([
            parentchop.runT(),
            scale.c(c.chop("rename", { renameto: c.sp("sx") })).runT(),
            scale.c(c.chop("rename", { renameto: c.sp("sy") })).runT(),
            scale.c(c.chop("rename", { renameto: c.sp("sz") })).runT()
        ]);
        let metalic = c.mat("pbr", {
            roughness: c.fp(0.2),
            metallic: c.fp(0.5),
        });
        let sgeo = instancesop.connect(geo({
            material: c.matp([metalic]),
            scale: c.fp(1),
            instanceop: c.chopp([chop]),
            instancing: c.tp(true),
            instancetx: c.sp("tx"),
            instancety: c.sp("ty"),
            instancetz: c.sp("tz"),
            instancerx: c.sp("rx"),
            instancery: c.sp("ry"),
            instancerz: c.sp("rz"),
            instancesx: c.sp("sx"),
            instancesy: c.sp("sy"),
            instancesz: c.sp("sz"),
        }));
        return render([sgeo], [cam], [c.comp("environmentlight", {
                envlightmap: c.topp([lightmap.runT()]),
                envlightmapprefilter: c.mp(0)
            })]);
    }
    oscillare.geoGeo = geoGeo;
    function torusGeo(sop, lightmap) {
        let s = c.chop("wave", {
            end: c.fp(50),
            endunit: c.mp(1),
            amp: c.fp(0.1),
            phase: secs(c.fp(0.3)),
            offset: c.fp(1),
        });
        let torus = c.chop("sopto", { sop: c.sopp([c.sop("torus", { rows: c.ip(5), cols: c.ip(10) }).runT()]) });
        let cam = centerCam(c.fp(5), c.xyzp(c.fp(-30), secs(c.fp(30)), c.fp(0)));
        return geoGeo(sop, torus, s, cam, lightmap);
    }
    oscillare.torusGeo = torusGeo;
    function flocking(cohesion, sep, sp) {
        return;
    }
    oscillare.flocking = flocking;
    function sinct(t, i, w) {
        return c.cc((inputs) => multops([
            c.top("chopto", { "chop": c.chopp([sinC(i, t, w)]) }).runT()
        ].concat(inputs)));
    }
    oscillare.sinct = sinct;
    function tapbeat(input, g, reset) {
        let beat = input.c(c.chop("logic", { preop: c.mp(5) })).runT();
        let beathold = c.chop("hold").run([
            c.chop("speed").run([const1(c.fp(1)).runT(), beat])
                .c(c.chop("delay", { delay: c.fp(1), delayunit: c.mp(1) })),
            beat
        ]).c(c.chop("null", { cooktype: c.mp(2) })).runT();
        let beattrail = c.chop("trail", {
            wlength: c.fp(8),
            wlengthunit: c.mp(1),
            capture: c.mp(1)
        }).run([beathold])
            .c(c.chop("delete", {
            delsamples: c.tp(true),
            condition: c.mp(5),
            inclvalue1: c.tp(false)
        })).runT();
        let bps = c.chop("math", { postop: c.mp(5), gain: g })
            .c(c.chop("analyze", { function: c.mp(1) }))
            .run([beattrail]);
        let beataccum = c.chop("speed").run([bps, reset.runT()]);
        let finalbeat = beataccum
            .c(c.chop("limit", {
            max: c.fp(1),
            type: c.mp(2),
            min: c.fp(0)
        }))
            .c(c.chop("logic", {
            boundmax: c.fp(0.08),
            preop: c.mp(5),
            convert: c.mp(2)
        }));
        return { beatpulse: finalbeat, bps: bps };
    }
    oscillare.tapbeat = tapbeat;
    function tapbeatm9() {
        return tapbeat(mchop("b9"), (c.powp(c.fp(2), (floor(c.multp(c.subp(mchan("s1a"), c.fp(0.5)), c.fp(4)))))), mchop("b10"));
    }
    oscillare.tapbeatm9 = tapbeatm9;
    function beatramp(beat) {
        return c.chop("speed", { resetcondition: c.mp(2) }).run([beat.bps, beat.beatpulse]);
    }
    oscillare.beatramp = beatramp;
    function beatxcount(x, reset, beat) {
        return c.chop("count", { output: c.mp(1), limitmax: c.fp(x - 1) }).run([beat.beatpulse, reset]);
    }
    oscillare.beatxcount = beatxcount;
    function beatxpulse(x, reset, beat) {
        return beatxcount(x, reset, beat).c(c.chop("logic", { preop: c.mp(6) }));
    }
    oscillare.beatxpulse = beatxpulse;
    function beatxramp(x, reset, beat) {
        return;
    }
    oscillare.beatxramp = beatxramp;
    function beatseconds(b, reset) {
        return c.multp(c.seconds, c.chan0(b.bps));
    }
    oscillare.beatseconds = beatseconds;
    function tapbeatm9sec() {
        return beatseconds(tapbeatm9(), mchop("b10"));
    }
    oscillare.tapbeatm9sec = tapbeatm9sec;
    function beatsecondschop(b) {
        return c.chop("speed").run([b.bps.runT()]);
    }
    oscillare.beatsecondschop = beatsecondschop;
    function dmxtochop(dmx) {
        switch (dmx.type) {
            case 'GenericRGB':
                return dmx.color;
            case '5Chan':
                return c.chop("merge").run([
                    dmx.dim, dmx.color,
                    constc({ gen1: c.fp(0), gen2: c.fp(0) })
                ]);
            case 'Fill':
                return constc(Object.assign({}, new Array(dmx.num).fill(c.fp(0))));
            case 'FillVal':
                return constc(Object.assign({}, new Array(dmx.num).fill(dmx.value)));
        }
    }
    oscillare.dmxtochop = dmxtochop;
    function multchops(chops) {
        return c.chop("math", { chopop: c.mp(3) }).run(chops);
    }
    oscillare.multchops = multchops;
    function pulse(g, usb) {
        return c.chop("datto", {
            firstrow: c.mp(1),
            firstcolumn: c.mp(2),
            dat: c.datp([c.dat("serial", {
                    port: c.sp(usb),
                    maxlines: c.ip(1)
                }).runT()])
        })
            .c(c.chop("math", { gain: g === undefined ? c.fp(1) : g }));
    }
    oscillare.pulse = pulse;
    function sensel() {
        return c.chop("cplusplus");
    }
    oscillare.sensel = sensel;
    function senselchop() {
        return sensel().c(c.chop("select", { channames: c.sp("chan") })).c(c.chop("shuffle", { method: c.mp(8), nval: c.ip(185) }));
    }
    oscillare.senselchop = senselchop;
    function senseltop(f = (n) => n) {
        return c.top("chopto", { chop: c.chopp([f(senselchop())]) })
            .c(c.top("flip", { flipy: c.tp(true) }))
            .c(c.top("resolution", { resolutionw: c.ip(1920), resolutionh: c.ip(1080), outputresolution: c.mp(9) }))
            .c(c.top("reorder", { format: c.mp(26), outputalphachan: c.mp(0) }));
    }
    oscillare.senseltop = senseltop;
    function senseltouches() {
        return sensel().c(c.chop("select", { channames: c.sp("chan1") })).c(c.chop("delete", { delsamples: c.tp(true) }));
    }
    oscillare.senseltouches = senseltouches;
    function gesture(mchan) {
        return c.chop("gesture").run([
            sensel()
                .c(c.chop("select", { channames: c.sp("chan") }))
                .c(c.chop("shuffle", { method: c.mp(1) })),
            mchop(mchan)
        ]).c(c.chop("shuffle", {
            method: c.mp(4),
            nval: c.ip(185),
            firstsample: c.tp(true)
        }));
    }
    oscillare.gesture = gesture;
    function gesturetop(chop) {
        return;
    }
    oscillare.gesturetop = gesturetop;
    function added(changes) {
        return c.dat("table", {}, [], null, changes)
            .c(c.dat("select", { extractrows: c.mp(5), rownames: c.sp("added"), extractcols: c.mp(2), colindexstart: c.ip(1) }));
    }
    oscillare.added = added;
    function addedchange(changes) {
        return c.chop("math", { gain: c.fp(0.8), chopop: c.mp(2), postop: c.mp(0) }).run([
            c.chop("info", { op: c.datp(added(changes)), iscope: c.sp("cook_abs_frame") }),
            c.chop("timeline", { absframe: c.tp(true), frame: c.tp(false) })
        ])
            .c(c.chop("logic", { preop: c.mp(1), convert: c.mp(0) }));
    }
    oscillare.addedchange = addedchange;
    function addedtop(changes) {
        return fullscreentext(added(changes).c(c.dat("convert", { how: c.mp(0) })), c.chan(c.sp("num_rows"), c.chop("info", { op: c.datp(added(changes)) })))
            .c(c.top("level", { opacity: c.chan0(addedchange(changes).c(c.chop("trigger", {
                attack: c.fp(0),
                peak: c.fp(1),
                sustain: c.fp(1),
                minsustain: c.fp(5),
                release: c.fp(1)
            }))) }));
    }
    oscillare.addedtop = addedtop;
    function removed(changes) {
        return c.dat("table", {}, [], null, changes)
            .c(c.dat("select", { extractrows: c.mp(5), rownames: c.sp("removed"), extractcols: c.mp(2), colindexstart: c.ip(1) }));
    }
    oscillare.removed = removed;
    function removedchange(changes) {
        return;
    }
    oscillare.removedchange = removedchange;
    function removedtop(changes) {
        return;
    }
    oscillare.removedtop = removedtop;
    function changestop(changes) {
        return verticalstack([
            multops([c.top("constant", { color: c.rgbp(c.fp(0), c.fp(1), c.fp(0)) }), addedtop(changes)]),
            multops([c.top("constant", { color: c.rgbp(c.fp(1), c.fp(0), c.fp(0)) }), removedtop()]),
        ]).c(c.top("fit", { resolutionw: c.ip(1920), resolutionh: c.ip(1080), outputresolution: c.mp(9), outputaspect: c.mp(1), }));
    }
    oscillare.changestop = changestop;
    function textdat(text) {
        return c.dat("text", {}, [], null, text);
    }
    oscillare.textdat = textdat;
    function fullscreentext(textdat, rowcount) {
        return c.top("text", {
            dat: c.datp(textdat),
            "resolutionw": c.ip(1920),
            "resolutionh": c.multp(c.ip(36), c.casti(rowcount)),
            "fontsizey": c.fp(18),
            "alignx": c.mp(0),
            "aligny": c.mp(2),
            "dispmethod": c.mp(3),
            "fontautosize": c.mp(1),
            fontsizex: c.fp(16),
            text: c.sp(""),
            fontfile: c.sp("AnonymousPro-Regular.ttf"),
            linespacing: c.fp(12),
            bgalpha: c.fp(0.4)
        });
    }
    oscillare.fullscreentext = fullscreentext;
    function runop(op, opp) { return c.cc((inputs) => op.run(inputs.concat([opp]))); }
    oscillare.runop = runop;

    (function (exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
    };
    var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parsedops = void 0;
    __exportStar(Validate, exports);
    __exportStar(_JSON, exports);
    __exportStar(Types, exports);
    __exportStar(Chain$1, exports);
    __exportStar(oscillare, exports);
    exports.parsedops = Promise.resolve().then(() => __importStar(require$$5));

    }(build));

    var ldjs = /*@__PURE__*/getDefaultExportFromCjs(build);

    function compare(value1, value2) {
        if (value1 === value2) {
            return true;
        }
        /* eslint-disable no-self-compare */
        // if both values are NaNs return true
        if (value1 !== value1 && value2 !== value2) {
            return true;
        }
        if (value1?._Proxy && value2?._Proxy) {
            return value1._nodeid === value2._nodeid;
        }
        if(typeof value1 !== typeof value2) {
            return false;
        }
        // if (value1 !== Object(value1)) {
        //     // non equal primitives
        //     return false;
        // }
        // if (!value1) {
        //     return false;
        // }
        if (Array.isArray(value1)) {
            return compareArrays(value1, value2);
        }
        if(typeof value1 === 'object' && typeof value2 === 'object') {
            if ((value1 instanceof Map) && (value2 instanceof Map)) {
                return compareArrays([...value1.entries()], [...value2.entries()]);
            }
            if ((value1 instanceof Set) && (value2 instanceof Set)) {
                return compareArrays(Array.from(value1), Array.from(value2));
            }

            return compareObjects(value1, value2);
        }

        return compareNativeSubrefs(value1, value2);
    }

    function compareNativeSubrefs(value1, value2) {
        // e.g. Function, RegExp, Date
        return value1.toString() === value2.toString();
    }

    function compareArrays(value1, value2) {
        var len = value1.length;
        if (len != value2.length) {
            return false;
        }
        var alike = true;
        for (var i = 0; i < len; i++) {
            if (!compare(value1[i], value2[i])) {
                alike = false;
                break;
            }
        }
        return alike;
    }

    function compareObjects(value1, value2) {
        var keys1 = Object.keys(value1);
        var keys2 = Object.keys(value2);
        var len = keys1.length;
        if (len != keys2.length) {
            return false;
        }
        if (value1._needsresolve || value2._needsresolve) {
            return false;
        }
        for (var i = 0; i < len; i++) {
            var key1 = keys1[i];
            // var key2 = keys2[i];
            if (value1[key1] === value2[key1]) {
                continue;
            }

            // if(value1[key1]?._Proxy && value2[key1]?._Proxy 
            //     && value1[key1]._value === value2[key1]._value) {
            //     continue;
            // }

            return false;

            // if (!(compare(value1[key1], value2[key1]))) {
            //     return false;
            // }
        }
        return true;
    }

    const hashcode = function(str, seed = 0) {
        let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
        let i = str.length, ch;
        while(i > 0){
            i--;
            ch = str.charCodeAt(i);
            h1 = Math.imul(h1 ^ ch, 2654435761);
            h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
        h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
        return 4294967296 * (2097151 & h2) + (h1>>>0);
    };

    const createProxy = (run_with_val, input, graph_input_value) => { 
        let res = Object.create(null);
        let resolved = false;
        return new Proxy(res, {
        get: (_, prop) => {
            if (prop === "_Proxy") {
                return true;
            } else if (prop === "_nodeid") {
                return input.from;
            } if (prop === 'toJSON') {
                return () => resolved ? res : {Proxy: input.from}
            }

            if (!resolved) {
                res = run_with_val(input.from)(graph_input_value);
                resolved = true;
            }


            if (prop === "_value") {
                return res
            } else if(!res) {
                return res;
            } else {
                if(typeof res[prop] === 'function'){
                    return res[prop].bind(res);
                } else {
                    return res[prop];
                }
            }
        },
        ownKeys: (_) => {
            if (!resolved) {
                res = run_with_val(input.from)(graph_input_value);
                resolved = true;
            }

            return typeof res === 'object' ? Reflect.ownKeys(res) : undefined;
        },
        getOwnPropertyDescriptor: (target, prop) => {
            if (!resolved) {
                res = run_with_val(input.from)(graph_input_value);
                resolved = true;
            }

            return typeof res === 'object' && !!res ? (Reflect.getOwnPropertyDescriptor(res, prop) || {value: objectSafeGet(target, prop)}) : undefined;
        }
    })
    };

    const resolve = (o) => {
        if (o?._Proxy) {
            return resolve(o._value)
        } else if (Array.isArray(o)) {
            const new_arr = [];
            let same = true;
            let i = o.length;
            while(i > 0) {
                i--;
                new_arr[i] = resolve(o[i]);
                same = same && o[i] === new_arr[i];
            }
            return same ? o : new_arr;
        } else if (typeof o === 'object' && !!o && o._needsresolve) {
            const entries = Object.entries(o);
            if(entries.length === 0) {
                return o;
            }

            let i = entries.length;
            let j = 0;
            let same = true;
            let new_obj_entries = [];
            let promise = false;
            while(i > 0) {
                i--;
                if(entries[i][0] !== '_needsresolve') {
                    new_obj_entries[j] = [entries[i][0], resolve(entries[i][1])];
                    same = same && entries[i][1] === new_obj_entries[j][1];
                    promise = promise || ispromise(new_obj_entries[j][1]);
                    j++;
                }
            }
            return same ? (delete o._needsresolve, o) : promise 
                ? Promise.all(new_obj_entries.map(kv => Promise.resolve(kv[1]).then(v => [kv[0], v])))
                    .then(kvs => Object.fromEntries(kvs)) 
                : Object.fromEntries(new_obj_entries);
        } else {
            return o;
        }
    };

    class NodysseusError extends Error {
        constructor(node_id, ...params) {
            super(...params);

            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, NodysseusError);
            }

            this.node_id = node_id;
        }
    }

    const executeGraph = ({ cache, graph, cache_id}) => {
        let usecache = true;

        if (!cache.has(cache_id)) {
            cache.set(cache_id, new Map([["__handles", 1]]));
        } else {
            cache.get(cache_id).set("__handles", cache.get(cache_id).get("__handles") + 1);
        }

        if (!graph.nodes) {
            throw new Error(`Graph has no nodes! in: ${graph.in} out: ${graph.out}`)
        }

        if(graph._Proxy) {
            graph = graph._value;
        }

        const run_with_val = (node_id) => {
            return (graph_input_value) => {
                let is_node_cached = lib.no.runtime.is_cached(graph, node_id);
                let node = lib.no.runtime.get_node(graph, node_id);

                if(node === undefined) {
                    throw new Error(`Undefined node_id ${node_id}`)
                }

                const inputs = lib.no.runtime.get_edges_in(graph, node_id);

                if (node.ref === "arg" && (!inputs || inputs.length === 0)) {
                    return lib.utility.arg.fn(node, graph_input_value);
                }

                if (node.value !== undefined && !node.script && !node.ref) {
                    if(typeof node.value === 'string' && node.value.match(/[0-9]*/g)[0].length === node.value.length) {
                        const int = parseInt(node.value);
                        if(!isNaN(int)){
                            return int;
                        }
                    }

                    if(typeof node.value === 'string' && node.value.match(/[0-9.]*/g)[0].length === node.value.length) {
                        const float = parseFloat(node.value);
                        if(!isNaN(float)) {
                            return float;
                        }
                    }

                    if(typeof node.value !== 'string') {
                        return node.value;
                    }

                    
                    if(node.value.startsWith('{') || node.value.startsWith('[')) {
                        try {
                            return  JSON.parse(node.value.replaceAll("'", "\""));
                        } catch(e) { }
                    }

                    return node.value;
                }

                let node_ref;

                const ref = node.ref?.node_ref ?? typeof node.ref === 'string' ? node.ref : undefined;
                if (ref) {
                    node_ref = lib.no.runtime.get_node(graph, ref);
                    if(!node_ref) {
                        throw new Error(`Unable to find ref ${ref} for node ${node.name ?? node.id}`)
                    }
                } else {
                    node_ref = node;
                }

                let _needsresolve = false;

                const tryrun = (input) => {
                    if (input.type === "ref") {
                        return input.from;
                    } else if (input.from === "_graph_input_value" || input.from === graph.in) {
                        _needsresolve = _needsresolve || !!graph_input_value._needsresolve;
                        return graph_input_value;
                    } else if (input.type === "resolve") {
                        // if(!node_map.has(input.from)) {
                        //     throw new Error(`Input not found ${input.from} for node ${node_id}`)
                        // }

                        return resolve(run_with_val(input.from)(graph_input_value));
                    } else if (!input.as || node_ref.script) {
                        // if(!node_map.has(input.from)) {
                        //     throw new Error(`Input not found ${input.from} for node ${node_id}`)
                        // }

                        let res = run_with_val(input.from)(graph_input_value);

                        while (res?._Proxy) {
                            res = res._value;
                        }
                        
                        _needsresolve = _needsresolve || (!!res && typeof res === 'object' && !!res._needsresolve);

                        return res;
                    } else {
                        _needsresolve = true;
                        return createProxy(run_with_val, input, graph_input_value);
                    }
                };

                const input_data_map = new Map();
                let i = inputs.length;
                while(i > 0) {
                    i--;
                    input_data_map.set(inputs[i].from, tryrun(inputs[i]));
                }
                const data = {};
                let input;

                // grab inputs from state
                for (let i = 0; i < inputs.length; i++) {
                    input = inputs[i];

                    if (input.type === "ref") {
                        if (!input.as) {
                            throw new Error("references have to be named: " + node.id);
                        }
                        data[input.as] = input.from;
                    } else {
                        let state_data = input_data_map.get(input.from);

                        if (input.as) {
                            data[input.as] = state_data;
                        } else if (state_data !== undefined) {
                            Object.assign(data, state_data);//, {_needsresolve: !!data._needsresolve || !!state_data._needsresolve});
                        }
                    }
                }

                if (node_ref.nodes) {
                    const outid = `${node.id}/${node_ref.out ?? 'out'}`;
                    const combined_data_input = typeof graph_input_value === 'object' && !Array.isArray(graph_input_value) && data
                            ? Object.assign({}, graph_input_value, data) 
                            : inputs.length > 0 
                            ? data
                            : graph_input_value;

                    let hit = false;
                    if (!lib.no.runtime.get_node(graph, outid)) {
                        lib.no.runtime.expand_node(graph, node.id, node_ref);
                    }

                    if (is_node_cached && cache.get(cache_id).has(outid)) {
                        const val = cache.get(cache_id).get(outid);
                        hit = compare(val[1], combined_data_input);
                        if (hit) {
                            return val[0];
                        }
                    }

                    const res = run_with_val(outid)(combined_data_input);
                    if(typeof res === 'object' && !!res && !res._Proxy && !Array.isArray(res) && Object.keys(res).length > 0) {
                        if(_needsresolve || !!res._needsresolve) {
                            res._needsresolve = !!res._needsresolve || _needsresolve;
                        } else if(res.hasOwnProperty("_needsresolve")) {
                            delete res._needsresolve;
                        }
                    }
                    cache.get(cache_id).set(outid, [res, combined_data_input]);
                    return res;
                } else if (node_ref.script) {
                    const argset = new Set();
                    argset.add('_lib');
                    argset.add('_node');
                    argset.add('_node_inputs');
                    argset.add('_graph');
                    (inputs ?? []).map(i => i.as).forEach(i => i && argset.add(i));
                    let orderedargs = "";
                    const input_values = [];
                    for(let a of argset) {
                        input_values.push(
                            a === '_node' 
                            ? node 
                            : a === '_lib'
                            ? lib
                            : a === '_node_inputs'
                            ? data
                            : a === '_graph'
                            ? graph
                            : data[a]);
                        orderedargs += `${a},`;
                    }

                    if (is_node_cached && cache.get(cache_id).has(node.id)) {
                        const val = cache.get(cache_id).get(node.id);
                        let hit = compare(data, val[1]);
                        // hit = hit && compare(graph_input_value, val[2]);
                        if (hit) {
                            return val[0]
                        }
                    }


                    try {
                        const fn = lib.no.runtime.get_fn(graph, orderedargs, node_ref);

                        const is_iv_promised = input_values.reduce((acc, iv) => acc || ispromise(iv), false);
                        const results = is_iv_promised 
                            ? Promise.all(input_values.map(iv => Promise.resolve(iv))).then(iv => fn.apply(null, iv))
                            : fn.apply(null, input_values);

                        // don't cache things without arguments
                        // if (node_ref.args?.length > 0) {
                            cache.get(cache_id).set(node.id, [results, data]);
                        // }

                        if(typeof results === 'object' && !!results && !results._Proxy && !Array.isArray(results) && Object.keys(results).length > 0) {
                            if(_needsresolve || !!results._needsresolve) {
                                results._needsresolve = !!results._needsresolve || _needsresolve;
                            } else if(results.hasOwnProperty("_needsresolve")) {
                                delete results._needsresolve;
                            }
                        }

                        return results;
                    } catch (e) {
                        console.log(`error in node`);
                        console.error(e);
                        console.dir(node_ref);
                        console.log(data);
                        throw new AggregateError([
                            new NodysseusError(
                                node_id, 
                                e instanceof AggregateError ? "Error in node chain" : e
                            )]
                            .concat(e instanceof AggregateError ? e.errors : []));
                    }
                } else if(node_ref.extern) {
                    const extern = objectSafeGet(lib, node_ref.extern);
                    const args = extern.args.reduce((acc, arg) => {
                            if(arg === '_node'){
                                return [acc[0].concat([node]), acc[1]];
                            } else if (arg === '_node_inputs') {
                                return [acc[0].concat(extern.resolve ? resolve({...data, _needsresolve: true}) : data), acc[1]]
                            } else if (arg === '_graph') {
                                return [acc[0].concat(graph), acc[1]]
                            }
                            const value = extern.resolve === false ? data[arg] : resolve(data[arg]);
                            return [acc[0].concat([value]), ispromise(value) || acc[1]];
                        }, [[], false]);

                    try {
                        if (usecache && is_node_cached && cache.get(cache_id).has(node.id)) {
                            const val = cache.get(cache_id).get(node.id);
                            let hit = compare(args[0], val[1]);
                            // hit = hit && compare(graph_input_value, val[2]);
                            if (hit) {
                                return val[0]
                            }
                        }

                        if(args[1]) {
                            return Promise.all(args[0]).then(as => {
                                const res = extern.fn.apply(null, as);
                                cache.get(cache_id).set(node_id, [res, args[0]]);
                                return res;
                            })
                        } else {
                            const res = extern.fn.apply(null, args[0]);
                            cache.get(cache_id).set(node_id, [res, args[0]]);
                            return res;
                        }
                    } catch(e) {
                        throw new AggregateError([
                            new NodysseusError(
                                node_ref.id, 
                                e instanceof AggregateError ? "Error in node chain" : e
                            )]
                            .concat(e instanceof AggregateError ? e.errors : []));
                    }
                }

                if (is_node_cached && cache.get(cache_id).has(node.id)) {
                    const val = cache.get(cache_id).get(node.id);
                    let hit = compare(data, val[1]);
                    // hit = hit && compare(graph_input_value, val[2]);
                    if (hit) {
                        return val[0];
                    }
                }


                if(typeof data === 'object' && !!data && !data._Proxy && !Array.isArray(data) && Object.keys(data).length > 0) {
                    data._needsresolve = true;
                }

                const promised_data = Object.entries(data).reduce((acc, kv) => [acc[0].concat([kv]), acc[1] || (!!kv[1] && !kv[1]?._Proxy && ispromise(kv[1]))], [[], false]);
                
                if(promised_data[1]) {
                    return Promise.all(promised_data[0].map(kv => Promise.resolve(kv[1]).then(v => [kv[0], v])))
                        .then(Object.fromEntries)
                        .then(res => (cache.get(cache_id).set(node.id, [res, data]), res));
                }

                cache.get(cache_id).set(node.id, [data, data]);

                return data;
            }
        };

        return (node_id) => (graph_input_value) => resolve(run_with_val(node_id)(graph_input_value));
    };

    //////////
    // TODO: convert these to nodes

    const calculateLevels = (nodes, links, graph, selected) => {
        const find_childest = n => {
            const e = graph.edges.find(ed => ed.from === n);
            if (e) {
                return find_childest(e.to);
            } else {
                return n;
            }
        };
        selected = selected[0];
        const top = find_childest(selected);

        const levels = new Map();
        bfs(graph, (id, level) => levels.set(id, Math.min(levels.get(id) ?? Number.MAX_SAFE_INTEGER, level)))(top, 0);

        const parents = new Map(nodes.map(n => [n.node_id, links.filter(l => l.target.node_id === n.node_id).map(l => l.source.node_id)]));

        [...parents.values()].forEach(nps => {
            nps.sort((a, b) => parents.get(b).length - parents.get(a).length);
            for(let i = 0; i < nps.length * 0.5; i++) {
                if(i % 2 === 1) {
                    const tmp = nps[i];
                    const endidx = nps.length - 1 - Math.floor(i / 2);
                    nps[i] = nps[endidx];
                    nps[endidx] = tmp;
                }
            }
        });

        const children = new Map(nodes
            .map(n => [n.node_id, 
                links.filter(l => l.source.node_id === n.node_id)
                .map(l => l.target.node_id)
            ]));
        const siblings = new Map(nodes.map(n => [n.node_id, [...(new Set(children.get(n.node_id)?.flatMap(c => parents.get(c) ?? []) ?? [])).values()]]));
        const distance_from_selected = new Map();

        const connected_vertices = new Map(); //new Map(!fixed_vertices ? [] : fixed_vertices.nodes.flatMap(v => (v.nodes ?? []).map(n => [n, v.nodes])));

        const calculate_selected_graph = (s, i, c) => {
            const id = c || children.get(s)?.length > 0 ? (s + "_" + (c ?? children.get(s)[0])) : s;
            if (distance_from_selected.get(id) <= i) {
                return;
            }

            distance_from_selected.set(id, i);
            parents.get(s)?.forEach(p => { calculate_selected_graph(p, i + 1, s); });
            children.get(s)?.forEach(c => { calculate_selected_graph(c, i + 1); });
        };

        calculate_selected_graph(selected, 0);

        return {
            level_by_node: levels,
            parents,
            children,
            siblings,
            distance_from_selected,
            min: Math.min(...levels.values()),
            max: Math.max(...levels.values()),
            nodes_by_level: [...levels.entries()].reduce((acc, [n, l]) => (acc[l] ? acc[l].push(n) : acc[l] = [n], acc), {}),
            connected_vertices
        }
    };

    const bfs = (graph, fn) => {
        const visited = new Set();
        const iter = (id, level) => {
            if (visited.has(id)) {
                return;
            }

            fn(id, level);

            visited.add(id);

            for (const e of graph.edges) {
                if (e.to === id) {
                    iter(e.from, level + 1);
                }
            }
        };

        return iter;
    };

    const updateSimulationNodes = (dispatch, data) => {
        if(data.static) {
            const top = data.display_graph.out;
            const levels = new Map();
            const nodes = new Map();
            bfs(data.display_graph, (id, level) => {
                levels.set(id, Math.min(levels.get(id) ?? Number.MAX_SAFE_INTEGER, level));
                nodes.set(id, data.display_graph.nodes.find(n => n.id === id));
            })(top, 0);

            const parents = new Map([...nodes.values()].map(n => {
                const nps = data.display_graph.edges.filter(e => e.to === n.id).map(e => e.from);
                return [ n.id, nps]
            }));

            [...parents.values()].forEach(nps => {
                nps.sort((a, b) => parents.get(b).length - parents.get(a).length);
                for(let i = 0; i < nps.length * 0.5; i++) {
                    if(i % 2 === 1) {
                        const tmp = nps[i];
                        const endidx = nps.length - 1 - Math.floor(i / 2);
                        nps[i] = nps[endidx];
                        nps[endidx] = tmp;
                    }
                }
            });

            const children = new Map([...nodes.values()]
                .map(n => [n.id, data.display_graph.edges
                .filter(e => e.from === n.id)
                .map(e => e.to)]
            ));

            [...levels.entries()].reduce((acc, [n, l]) => (acc[l] ? acc[l].push(n) : acc[l] = [n], acc), {});

            const node_el_width = 196;
            const node_positions = new Map();
            [...nodes.values()].forEach(n => {
                const child = children.get(n.id)?.length ? children.get(n.id)[0] : 0;
                const parents_count = Math.min(8, parents.get(n.id)?.length) ?? 0;
                const siblings = children.get(n.id)?.length ? parents.get(children.get(n.id)[0]) : [n.id];
                const sibling_count = Math.max(siblings.length, 4);
                const increment = Math.PI * 2 / (Math.max(1, sibling_count - 1) * (Math.pow(Math.PI, 2 * (levels.get(n.id) - 1)) + 1));
                const offset = child ? node_positions.get(child)[2] : 0;
                const theta = ((siblings.findIndex(l => l == n.id) - (siblings.length === 1 ? 0 : 0.5)) * increment) + offset;
                const dist = !child ? 0 : (node_el_width * 0.75
                    + node_positions.get(child)[3]
                    + node_el_width * 0.25 * parents_count
                );
                    //+ (child ? node_positions.get(child)[3] : 0);

                node_positions.set(n.id,
                    [
                        n,
                        n.id + (children.get(n.id)?.length ? '_' + children.get(n.id)[0] : ''),
                        theta,
                        dist
                    ]);
            });

            for(let np of node_positions.values()) {
                const theta = np[2];
                const dist = np[3];
                np[2] = -dist * Math.cos(theta);
                np[3] = -dist * Math.sin(theta);
            }

            const node_data = {
                nodes: [...node_positions.values()].map(([n, c, x, y]) => ({
                    node_id: n.id,
                    node_child_id: c,
                    nested_node_count: n.nodes?.length,
                    nested_edge_count: n.edges?.length,
                    x,
                    y
                })),
                links: data.display_graph.edges.filter(e => levels.has(e.to)).map(e => ({
                    source: {
                        node_child_id: node_positions.get(e.from)[1],
                        node_id: node_positions.get(e.from)[0].id,
                        x: Math.floor(node_positions.get(e.from)[2]),
                        y: Math.floor(node_positions.get(e.from)[3])
                    },
                    target: {
                        node_child_id: node_positions.get(e.to)[1],
                        node_id: node_positions.get(e.to)[0].id,
                        x: Math.floor(node_positions.get(e.to)[2]),
                        y: Math.floor(node_positions.get(e.to)[3])
                    },
                    sibling_index_normalized: 0
                }))
            };
            requestAnimationFrame(() => {
                dispatch(s => s ? [resolve(data.sim_to_hyperapp), node_data] : s);
                requestAnimationFrame(() => {
                    node_data.nodes.forEach(n => {
                        const el = document.getElementById(`${data.html_id}-${n.node_child_id}`);
                        if(el) {
                            const x = n.x - node_el_width * 0.5;
                            const y = n.y ;
                            el.setAttribute('x', Math.floor(x - 20));
                            el.setAttribute('y', Math.floor(y - 20));
                        }
                    });

                    node_data.links.forEach(l => {
                        const el = document.getElementById(`link-${l.source.node_child_id}`);
                        const info_el = document.getElementById(`edge-info-${l.source.node_child_id}`);
                        const insert_el = document.getElementById(`insert-${l.source.node_child_id}`);
                        if(el && info_el) {
                            const source = {x: l.source.x - node_el_width * 0.5, y: l.source.y};
                            const target = {x: l.target.x - node_el_width * 0.5, y: l.target.y};
                            const length_x = Math.abs(source.x - target.x); 
                            const length_y = Math.abs(source.y - target.y); 
                            const length = Math.sqrt(length_x * length_x + length_y * length_y); 
                            const lerp_length = 24;
                            // return {selected_distance, selected_edge, source: {...source, x: source.x + (target.x - source.x) * lerp_length / length, y: source.y + (target.y - source.y) * lerp_length / length}, target: {...target, x: source.x + (target.x - source.x) * (1 - (lerp_length / length)), y: source.y + (target.y - source.y) * (1 - (lerp_length / length))}}"
                            el.setAttribute('x1', Math.floor(Math.floor(source.x + (target.x - source.x) * lerp_length / length)));
                            el.setAttribute('y1', Math.floor(Math.floor(source.y + (target.y - source.y) * lerp_length / length)));
                            el.setAttribute('x2', Math.floor(Math.floor(source.x + (target.x - source.x) * (1 - lerp_length / length))));
                            el.setAttribute('y2', Math.floor(Math.floor(source.y + (target.y - source.y) * (1 - lerp_length / length))));

                            info_el.setAttribute('x', Math.floor((l.sibling_index_normalized * 0.2 + 0.2) * (target.x - source.x) + source.x) + 16);
                            info_el.setAttribute('y', Math.floor((l.sibling_index_normalized * 0.2 + 0.2) * (target.y - source.y) + source.y));

                            if(insert_el) {
                                insert_el.setAttribute('x', Math.floor(Math.floor((source.x + target.x) * 0.5)));
                                insert_el.setAttribute('y', Math.floor(Math.floor((source.y + target.y) * 0.5)));
                            }
                        }
                    });

                    dispatch(s => s?.panzoom_selected_effect ? [s, [s.panzoom_selected_effect, {...s, ...node_data, selected: s.selected[0]}]] : s);
                });
            });
            return;
        }

        const simulation_node_data = new Map();
        data.simulation.nodes().forEach(n => {
            simulation_node_data.set(n.node_child_id, n);
        });

        const start_sim_node_size = simulation_node_data.size;
        
        const simulation_link_data = new Map();
        data.simulation.force('links').links().forEach(l => {
            simulation_link_data.set(l.source.node_child_id, l);
        });

        const start_sim_link_size = simulation_link_data.size;

        const main_node_map = new Map();

        const node_map = new Map(data.display_graph.nodes.map(n => [n.id, n]));
        const children_map = new Map(data.display_graph.nodes.map(n => [n.id, 
            data.display_graph.edges
                .filter(e => e.from === n.id)
                .map(e => e.to)
        ]));

        const order = [];
        const queue = [data.display_graph.out];

        const parents_map = new Map(data.display_graph.nodes.map(n => [n.id, 
            data.display_graph.edges
                .filter(e => e.to === n.id)
                .map(e => e.from)
            ]));

        while(queue.length > 0) {
            const node = queue.shift();
            order.push(node);

            const children = children_map.get(node);
            const node_child_id = children.length > 0 ? node + "_" + children[0] : node;
            main_node_map.set(node, node_child_id);

            parents_map.get(node).forEach(p => {queue.push(p);});
        }


        for(let ps of parents_map.values()) {
            let i = 0;
            ps.sort((a, b) => parents_map.get(a).length === parents_map.get(b).length 
                ? (simulation_node_data.get(main_node_map.get(a))?.hash ?? hashcode(a)) - (simulation_node_data.get(main_node_map.get(b)) ?? hashcode(b))
                : ((i++ % 2) * 2 - 1) * (parents_map.get(b).length - parents_map.get(a).length));
        }
        //// pushes all root nodes, not just display_graph.out
        // data.display_graph.nodes.forEach(n => {
        //     const children = children_map.get(n.id);
        //     const node_child_id = children.length > 0 ? n.id + "_" + children[0] : n.id;
        //     main_node_map.set(n.id, node_child_id);

            // if(children_map.get(n.id).length === 0) {
            //     queue.push(n.id);
            // }
        // });
        

        const nodes = order.flatMap(nid => {
            let n = node_map.get(nid);
            const children = children_map.get(n.id);
            const node_child_id = main_node_map.get(n.id);

            const node_hash = simulation_node_data.get(node_child_id)?.hash ?? hashcode(nid);
            const randpos = {x: (((node_hash * 0.254) % 256.0) / 256.0), y: ((node_hash * 0.874) % 256.0) / 256.0};

            const addorundefined = (a, b) => {
                return a === undefined || b === undefined ? undefined : a + b
            };

            const calculated_nodes = children.length === 0 ? [{
                node_id: n.id,
                node_child_id: n.id,
                hash: simulation_node_data.get(node_child_id)?.hash ?? hashcode(n.id),
                nested_node_count: n.nodes?.length,
                nested_edge_count: n.edges?.length,
                x: Math.floor(simulation_node_data.get(node_child_id)?.x 
                    ?? simulation_node_data.get(main_node_map.get(parents_map.get(n.id)?.[0]))?.x
                    ?? Math.floor(window.innerWidth * (randpos.x * .5 + .25))),
                y: Math.floor(simulation_node_data.get(node_child_id)?.y 
                    ?? addorundefined(simulation_node_data.get(main_node_map.get(parents_map.get(n.id)?.[0]))?.y, 128)
                    ?? Math.floor(window.innerHeight * (randpos.y * .5 + .25)))
            }] : children.map((c, i) => ({
                node_id: n.id,
                node_child_id: n.id + "_" + c,
                hash: simulation_node_data.get(node_child_id)?.hash ?? hashcode(n.id),
                sibling_index_normalized: parents_map.get(c).findIndex(p => p === n.id) / parents_map.get(c).length,
                nested_node_count: n.nodes?.length,
                nested_edge_count: n.edges?.length,
                x: Math.floor(simulation_node_data.get(node_child_id)?.x 
                    ?? simulation_node_data.get(main_node_map.get(parents_map.get(n.id)?.[0]))?.x
                    ?? addorundefined(
                        simulation_node_data.get(main_node_map.get(children_map.get(n.id)?.[0]))?.x, 
                        (parents_map.get(children_map.get(n.id)?.[0])?.findIndex(v => v === n.id) - (parents_map.get(children_map.get(n.id)?.[0])?.length - 1) * 0.5) * 256
                    )
                    ?? Math.floor(window.innerWidth * (randpos.x * .5 + .25))),
                y: Math.floor(simulation_node_data.get(node_child_id)?.y 
                    ?? addorundefined(256, simulation_node_data.get(main_node_map.get(parents_map.get(n.id)?.[0]))?.y)
                    ?? addorundefined(
                        -(196 + 32 * (parents_map.get(n.id).length ?? 0)),
                        simulation_node_data.get(main_node_map.get(children_map.get(n.id)?.[0]))?.y
                    )
                    ?? Math.floor(window.innerHeight * (randpos.y * .5 + .25)))
            }));

            calculated_nodes.map(n => simulation_node_data.set(n.node_child_id, n));

            return calculated_nodes;
        });

        const links = data.display_graph.edges
            .filter(e => main_node_map.has(e.from) && main_node_map.has(e.to))
            .map(e => {
                if (!(main_node_map.has(e.from) && main_node_map.has(e.to))) {
                    // won't throw - just doesn't display non main-graph nodes
                    throw new Error(`edge node undefined ${main_node_map.has(e.from) ? '' : '>'}${e.from} ${main_node_map.has(e.to) ? '' : '>'}${e.to} `);
                }

                simulation_link_data.get(e.from + "_" + e.to);
                return {
                    source: e.from + "_" + e.to,
                    from: e.from,
                    to: e.to,
                    target: main_node_map.get(e.to),
                    sibling_index_normalized: simulation_node_data.get(e.from + "_" + e.to).sibling_index_normalized,
                    strength: 2 * (1.5 - Math.abs(simulation_node_data.get(e.from + "_" + e.to).sibling_index_normalized - 0.5)) / (1 + 2 * Math.min(4, (parents_map.get(main_node_map.get(e.from))?.length ?? 0))),
                    distance: 128 
                        + 16 * (Math.min(4, parents_map.get(main_node_map.get(e.to))?.length ?? 0)) 
                };
            }).filter(l => !!l);


        if (typeof (links?.[0]?.source) === "string") {
            if (
                simulation_node_data.size !== start_sim_node_size ||
                simulation_link_data.size !== start_sim_link_size || 
                data.simulation.nodes()?.length !== nodes.length ||
                data.simulation.force('links')?.links().length !== links.length) {
                data.simulation.alpha(0.4);
            }

            data.simulation.nodes(nodes);
            data.simulation.force('links').links(links);
            // data.simulation.force('fuse_links').links(data.fuse_links);
        }

        data.simulation.force('link_direction')
            .y(n =>
                (((parents_map.get(n.node_id)?.length > 0 ? 1 : 0)
                    + (children_map.get(n.node_id)?.length > 0 ? -1 : 0)
                    + (children_map.get(n.node_id)?.length > 0 && n.node_child_id !== n.node_id + "_" + children_map.get(n.node_id)[0] ? -1 : 0))
                    * 8 + .5) * window.innerHeight)
            .strength(n => (!!parents_map.get(n.node_id)?.length === !children_map.get(n.node_id)?.length)
                || children_map.get(n.node_id)?.length > 0 && n.node_child_id !== n.node_id + "_" + children_map.get(n.node_id)[0] ? .025 : 0);


        data.simulation.force('collide').radius(96);
        // data.simulation.force('center').strength(n => (levels.parents_map.get(n.node_id)?.length ?? 0) * 0.25 + (levels.children_map.get(n.node_id)?.length ?? 0) * 0.25)
    };

    const graphToSimulationNodes = (data, payload) => {

        return {
            ...data,
            nodes,
            links,
            fuse_links
        }
    };

    const listenToEvent = (dispatch, props) => {
        const listener = (event) => requestAnimationFrame(() => dispatch(props.action, event.detail));

        requestAnimationFrame(() => addEventListener(props.type, listener));
        return () => removeEventListener(props.type, listener);
    };

    const listen = (type, action) => [listenToEvent, {type, action}];

    const graph_subscription = (dispatch, props) => {
        const listener = (graph) => {
            requestAnimationFrame(() =>  {
                dispatch(s => [{...s, display_graph: graph}, [s.update_sim_effect]]);
            });
        };

        lib.no.runtime.add_listener(props.graph, 'graphchange', 'update_hyperapp', listener);
        return () => lib.no.runtime.remove_listener(props.graph, 'graphchange', 'update_hyperapp');
    };

    const result_subscription = (dispatch, props) => {
        const listener = (graph, result) =>
            requestAnimationFrame(() => 
                dispatch(s => Object.assign({}, s, {error: false}, result)));
        

        const error_listener = (graph, error) =>
            requestAnimationFrame(() => dispatch(s => Object.assign({}, s, {error, display_graph: graph})));

        lib.no.runtime.add_listener(props.graph, 'graphrun', 'update_hyperapp_result_display', listener);
        lib.no.runtime.add_listener(props.graph, 'grapherror', 'update_hyperapp_error', error_listener);

        return () => (
            lib.no.runtime.remove_listener(props.graph, 'graphrun', 'update_hyperapp_result_display', listener),
            lib.no.runtime.remove_listener(props.graph, 'grapherror', 'update_hyperapp_error', error_listener)
        );
    };

    // Creates the simulation, updates the node elements when the simulation changes, and runs an action when the nodes have settled.
    // This is probably doing too much.
    const d3subscription = (dispatch, props) => {
        const simulation = lib.d3.forceSimulation()
            .force('charge', lib.d3.forceManyBody().strength(-64).distanceMax(256).distanceMin(64).strength(0))
            .force('collide', lib.d3.forceCollide(64))
            .force('links', lib.d3
                .forceLink([])
                .distance(l => l.distance ?? 128)
                .strength(l => l.strength)
                .id(n => n.node_child_id))
            .force('link_direction', lib.d3.forceY().strength(.01))
            .force('center', lib.d3.forceCenter().strength(0.01))
            // .force('fuse_links', lib.d3.forceLink([]).distance(128).strength(.1).id(n => n.node_child_id))
            // .force('link_siblings', lib.d3.forceX().strength(1))
            // .force('selected', lib.d3.forceRadial(0, window.innerWidth * 0.5, window.innerHeight * 0.5).strength(2))
            .velocityDecay(0.7)
            .alphaMin(.25);

        const abort_signal = { stop: false };
        simulation.stop();
        let htmlid;
        let stopped = false;
        let selected;
        const node_el_width = 256;
        const tick = () => {
            if(simulation.nodes().length === 0) {
                dispatch(s => [(htmlid = s.html_id, {...s, simulation}), [props.update, s]]);
            }

            const data = {
                nodes: simulation.nodes().map(n => {
                    return ({ ...n, x: ( Math.floor(n.x)), y: Math.floor(n.y) })
                }),
                links: simulation.force('links').links().map(l => ({
                    ...l,
                    as: l.as,
                    type: l.type,
                    source: ({
                        node_child_id: l.source.node_child_id,
                        node_id: l.source.node_id,
                        x: Math.floor(l.source.x),
                        y: Math.floor(l.source.y)
                    }),
                    target: ({
                        node_child_id: l.target.node_child_id,
                        node_id: l.target.node_id,
                        x: Math.floor(l.target.x),
                        y: Math.floor(l.target.y)
                    })
                }))};


            if (simulation.alpha() > simulation.alphaMin()) {
                const ids = simulation.nodes().map(n => n.node_id).join(',');
                stopped = false;
                simulation.tick();
                dispatch([s => (selected = s.selected[0], s.nodes.map(n => n.node_id).join(',') !== ids ? [props.action, data] 
                        : s.panzoom_selected_effect ? [s, [s.panzoom_selected_effect, {...s, nodes: simulation.nodes().map(n => ({...n, x: n.x - 8, y: n.y})), links: simulation.force('links').links(), prevent_dispatch: true, selected: s.selected[0]}]] : s)]);
                const visible_node_set = new Set();

                simulation.nodes().map(n => {
                    const el = document.getElementById(`${htmlid}-${n.node_child_id}`);
                    if(el) {
                        const x = n.x - node_el_width * 0.5;
                        const y = n.y ;
                        el.setAttribute('x', Math.floor(x - 20));
                        el.setAttribute('y', Math.floor(y - 20));

                        if(n.node_id === selected) ;
                    }
                });


                simulation.force('links').links().map(l => {
                    const el = document.getElementById(`link-${l.source.node_child_id}`);
                    const info_el = document.getElementById(`edge-info-${l.source.node_child_id}`);
                    const insert_el = document.getElementById(`insert-${l.source.node_child_id}`);
                    if(el && info_el) {
                        const source = {x: l.source.x - node_el_width * 0.5, y: l.source.y};
                        const target = {x: l.target.x - node_el_width * 0.5, y: l.target.y};
                        const length_x = Math.abs(source.x - target.x); 
                        const length_y = Math.abs(source.y - target.y); 
                        const length = Math.sqrt(length_x * length_x + length_y * length_y); 
                        const lerp_length = 24;
                        // return {selected_distance, selected_edge, source: {...source, x: source.x + (target.x - source.x) * lerp_length / length, y: source.y + (target.y - source.y) * lerp_length / length}, target: {...target, x: source.x + (target.x - source.x) * (1 - (lerp_length / length)), y: source.y + (target.y - source.y) * (1 - (lerp_length / length))}}"
                        el.setAttribute('x1', Math.floor(Math.floor(source.x + (target.x - source.x) * lerp_length / length)));
                        el.setAttribute('y1', Math.floor(Math.floor(source.y + (target.y - source.y) * lerp_length / length)));
                        el.setAttribute('x2', Math.floor(Math.floor(source.x + (target.x - source.x) * (1 - lerp_length / length))));
                        el.setAttribute('y2', Math.floor(Math.floor(source.y + (target.y - source.y) * (1 - lerp_length / length))));

                        info_el.setAttribute('x', Math.floor((l.sibling_index_normalized * 0.2 + 0.2) * (target.x - source.x) + source.x) + 16);
                        info_el.setAttribute('y', Math.floor((l.sibling_index_normalized * 0.2 + 0.2) * (target.y - source.y) + source.y));

                        if(insert_el) {
                            insert_el.setAttribute('x', Math.floor((source.x + target.x) * 0.5 - 16));
                            insert_el.setAttribute('y', Math.floor((source.y + target.y) * 0.5 - 16));
                        }

                        if (l.source.node_id === selected) {
                            visible_node_set.add(l.target.node_id);
                        } else if (l.target.node_id === selected) {
                            visible_node_set.add(l.source.node_id);
                        }
                    }
                });

                // iterate again to get grandparents
                simulation.force('links').links().map(l => {
                    if(visible_node_set.has(l.target.node_id) && !visible_node_set.has(l.source.node_id)) {
                        ({x: l.source.x - node_el_width * 0.5, y: l.source.y});
                    }
                });
            } else if(!stopped) {
                stopped = true; 
                dispatch([props.action, data]);
                requestAnimationFrame(() => {
                    dispatch(s => s?.panzoom_selected_effect ? [s, [s.panzoom_selected_effect, {...s, selected: s.selected[0]}]] : s);
                });
            }

            if (!abort_signal.stop) {
                requestAnimationFrame(tick);
            }
        };

        requestAnimationFrame(tick);

        return () => { abort_signal.stop = true; }
    };

    const keydownSubscription = (dispatch, options) => {
        const handler = ev => {
            if (ev.key === "s" && ev.ctrlKey) {
                ev.preventDefault();
            } else if (!ev.key) {
                return;
            }

            requestAnimationFrame(() => dispatch(options.action, ev));
        };
        requestAnimationFrame(() => addEventListener('keydown', handler));
        return () => removeEventListener('keydown', handler);
    };

    const expand_node = (data) => {
        const node_id = data.node_id;
        const node = data.display_graph.nodes.find(n => n.id === node_id);

        if (!(node && node.nodes)) {
            console.log('no nodes?');
            return { display_graph: data.display_graph, selected: [data.node_id] };
        }

        const flattened = lib.scripts.flattenNode(node, 1);

        const new_display_graph = {
            nodes: data.display_graph.nodes
                .filter(n => n.id !== node_id)
                .concat(flattened.flat_nodes),
            edges: data.display_graph.edges
                .map(e => ({
                    ...e,
                    from: e.from === node_id ? node.id + "/" + (node.out ?? 'out') : e.from,
                    to: e.to === node_id ? node.id + "/" + (node.in ?? 'in') : e.to
                }))
                .concat(flattened.flat_edges)
        };

        return { display_graph: { ...data.display_graph, ...new_display_graph }, selected: [node_id + '/' + (node.out ?? 'out')] };
    };

    const contract_all = (graph) => {
        const node_ids = new Set(graph.nodes.map(n => n.id));
        let display_graph = graph;
        graph.nodes.forEach(g => {
            if (g.id.endsWith("/out") && !node_ids.has(g.id.substring(0, g.id.length - 4))) {
                display_graph = contract_node({ node_id: g.id, display_graph }, true);
            }
        });

        return display_graph;
    };

    const contract_node = (data, keep_expanded = false) => {
        const node = data.display_graph.nodes.find(n => n.id === data.node_id);
        if (!node.nodes) {
            const slash_index = data.node_id.lastIndexOf('/');
            const node_id = slash_index >= 0 ? data.node_id.substring(0, slash_index) : data.node_id;
            const name = data.name ?? node_id;

            const inside_nodes = [Object.assign({}, node)];
            const inside_node_map = new Map();
            const dangling = new Set();
            inside_node_map.set(inside_nodes[0].id, inside_nodes[0]);
            const inside_edges = new Set();

            const q = data.display_graph.edges.filter(e => e.to === inside_nodes[0].id);

            let in_edge = [];

            while (q.length > 0) {
                const e = q.shift();
                dangling.delete(e.from);

                let this_dangling = 0;

                if (e.from !== data.node_id) {
                    data.display_graph.edges.filter(ie => ie.from === e.from).forEach(ie => {
                        if (!inside_node_map.has(ie.to)) {
                            this_dangling += 1;
                            dangling.add(ie.to);
                        }
                    });
                }

                if (this_dangling === 0) {


                    in_edge.filter(ie => ie.from === e.from).forEach(ie => {
                        inside_edges.add(ie);
                    });
                    in_edge = in_edge.filter(ie => ie.from !== e.from);

                    const old_node = inside_nodes.find(i => e.from === i.id);
                    let inside_node = old_node ?? Object.assign({}, data.display_graph.nodes.find(p => p.id === e.from));

                    inside_node_map.set(inside_node.id, inside_node);
                    inside_edges.add(e);
                    if (!old_node) {
                        delete inside_node.inputs;
                        inside_nodes.push(inside_node);
                    }

                    if (!inside_node.name?.endsWith(name + '/in')) {
                        data.display_graph.edges.filter(de => de.to === e.from).forEach(de => {
                            q.push(de);
                        });
                    }

                } else {
                    in_edge.push(e);
                }
            }

            let in_node_id = in_edge[0]?.to;

            if (in_edge.find(ie => ie.to !== in_node_id) || inside_nodes.length < 2) {
                return { display_graph: data.display_graph, selected: [data.node_id] };
            }

            const out_node = inside_nodes.find(n => n.id === data.node_id || n.name === name + "/out" || n.id === node_id + "/out");
            const out_node_id = out_node.id;

            const in_node = inside_node_map.get(in_node_id);

            let node_id_count = data.display_graph.nodes.filter(n => n.id === node_id).length;
            let final_node_id = node_id_count === 0 ? node_id : `${node_id}_${node_id_count}`;

            // if there's no in node, just return
            if (in_node_id && !in_node_id.endsWith('in')) {
                return {display_graph: data.display_graph, selected: [data.node_id]};
            }

            if (!in_node_id) {
                in_node_id = inside_nodes.find(n => n.id === node_id + "/in" || n.name === name + "/in")?.id;
            }

            const edges = [];
            for (const e of inside_edges) {
                edges.push({
                    ...e,
                    from: e.from.startsWith(node_id + "/")
                        ? e.from.substring(node_id.length + 1)
                        : e.from,
                    to: e.to.startsWith(node_id + "/")
                        ? e.to.substring(node_id.length + 1)
                        : e.to
                });
            }

            const new_display_graph = {
                nodes: data.display_graph.nodes
                    .filter(n => n.id !== data.node_id)
                    .filter(n => keep_expanded || !inside_node_map.has(n.id))
                    .concat([{
                        id: final_node_id,
                        name: name === data.node_id ? data.node_name : name,
                        in: in_node_id?.startsWith(node_id + '/') ? in_node_id.substring(node_id.length + 1) : in_node_id,
                        out: out_node_id.startsWith(node_id + '/') ? out_node_id.substring(node_id.length + 1) : out_node_id,
                        nodes: inside_nodes.map(n => ({
                            ...n,
                            id: n.id.startsWith(node_id + "/") ? n.id.substring(node_id.length + 1) : n.id,
                            name: !n.name?.startsWith(name + "/") ? n.name : n.name.substring(name.length + 1)
                        })),
                        edges
                    }]),
                edges: data.display_graph.edges
                    .filter(e => keep_expanded || !(inside_node_map.has(e.from) && inside_node_map.has(e.to)))
                    .map(e =>
                        e.from === data.node_id ? { ...e, from: final_node_id }
                            : e.to === in_node?.id ? { ...e, to: final_node_id }
                                : inside_node_map.has(e.to)
                                    ? { ...e, to: final_node_id }
                                    : e
                    )
            };

            return { display_graph: { ...data.display_graph, ...new_display_graph }, selected: [final_node_id] };
        }
    };

    const flattenNode = (graph, levels = -1) => {
        if (graph.nodes === undefined || levels === 0) {
            return graph;
        }

        // needs to not prefix base node because then flatten node can't run  next
        const prefix = graph.id ? `${graph.id}/` : '';
        graph.id ? `${graph.name}/` : '';

        return graph.nodes
            .map(n => Object.assign({}, n, { id: `${prefix}${n.id}` }))
            .map(g => flattenNode(g, levels - 1))
            .reduce((acc, n) => Object.assign({}, acc, {
                flat_nodes: acc.flat_nodes.concat(n.flat_nodes?.flat() ?? []).map(fn => {
                    // adjust for easy graph renaming
                    if ((fn.id === prefix + (graph.out ?? "out")) && graph.name) {
                        fn.name = graph.name + "/out";
                    } else if (graph.in && (fn.id === prefix + (graph.in ?? "/in")) && graph.name) {
                        fn.name = graph.name + "/in";
                    }
                    return fn
                }),
                flat_edges: acc.flat_edges.map(e => n.flat_nodes ?
                    e.to === n.id ?
                        Object.assign({}, e, { to: `${e.to}/${n.in ?? 'in'}` }) :
                        e.from === n.id ?
                            Object.assign({}, e, { from: `${e.from}/${n.out ?? 'out'}` }) :
                            e :
                    e).flat().concat(n.flat_edges).filter(e => e !== undefined)
            }), Object.assign({}, graph, {
                flat_nodes: graph.nodes
                    .map(n => Object.assign({}, n, { id: `${prefix}${n.id}` })),
                flat_edges: graph.edges
                    .map(e => ({ ...e, from: `${prefix}${e.from}`, to: `${prefix}${e.to}` }))
            }));
    };

    const objToGraph = (obj, path) => Object.entries(obj)
        .filter(e => e[0] !== '_value')
        .map(e => [e[0], typeof e[1] === 'object' && !!e[1] && !Array.isArray(e[1])
                    ? Object.assign(e[1].hasOwnProperty('_value') ? {value: e[1]._value} : {}, objToGraph(e[1], path ? `${path}.${e[0]}` : e[0]))
                    : {value: e[1]}]
        ).reduce((acc, n) => ({
            nodes: acc.nodes.concat(n[1].nodes ?? [])
                .concat([Object.assign({id: path ? `${path}.${n[0]}` : n[0], name: n[0]}, 
                    n[1].hasOwnProperty('value') 
                        ? {value: n[1].value} 
                        : n[1].hasOwnProperty('_value') 
                        ? {value: n[1]._value} 
                        : {})]),
            edges: acc.edges.concat(n[1].edges ?? []).concat(path ? [{to: path, from: `${path}.${n[0]}`}] : [])
        })
        , {nodes: [], edges: []});

    const findViewBox = (nodes, links, selected, node_el_width, htmlid, dimensions) => {
        const visible_nodes = [];
        const visible_node_set = new Set();
        let selected_pos;
        links.forEach(l => {
            const el = document.getElementById(`link-${l.source.node_child_id}`);
            const info_el = document.getElementById(`edge-info-${l.source.node_child_id}`);
            if(el && info_el) {
                const source = {x: l.source.x - node_el_width * 0.5, y: l.source.y};
                const target = {x: l.target.x - node_el_width * 0.5, y: l.target.y};

                if (l.source.node_id === selected) {
                    visible_nodes.push({x: target.x, y: target.y});
                    visible_node_set.add(l.target.node_id);
                } else if (l.target.node_id === selected) {
                    visible_nodes.push({x: source.x, y: source.y});
                    visible_node_set.add(l.source.node_id);
                }
            }
        });

        links.forEach(l => {
            if(visible_node_set.has(l.target.node_id) && !visible_node_set.has(l.source.node_id)) {
                const source = {x: l.source.x - node_el_width * 0.5, y: l.source.y};
                visible_nodes.push({x: source.x, y: source.y});
            }
        });

        nodes.forEach(n => {
            const el = document.getElementById(`${htmlid}-${n.node_child_id}`);
            if(el) {
                const x = n.x - node_el_width * 0.5;
                const y = n.y ;

                if(n.node_id === selected) {
                    visible_nodes.push({x, y});
                    selected_pos = {x, y};
                }
            }
        });

        const nodes_box = visible_nodes.reduce((acc, n) => ({min: {x: Math.min(acc.min.x, n.x - 24), y: Math.min(acc.min.y, n.y - 24)}, max: {x: Math.max(acc.max.x, n.x + node_el_width * 0.5 - 24), y: Math.max(acc.max.y, n.y + 24)}}), {min: {x: selected_pos ? (selected_pos.x - 96) : dimensions.x , y: selected_pos ? (selected_pos.y - 256) : dimensions.y}, max: {x: selected_pos ? (selected_pos.x + 96) : -dimensions.x, y: selected_pos ? (selected_pos.y + 128) : -dimensions.y}});
        const nodes_box_center = {x: (nodes_box.max.x + nodes_box.min.x) * 0.5, y: (nodes_box.max.y + nodes_box.min.y) * 0.5}; 
        const nodes_box_dimensions = {x: Math.max(dimensions.x * 0.5, Math.min(dimensions.x, (nodes_box.max.x - nodes_box.min.x))), y: Math.max(dimensions.y * 0.5, Math.min(dimensions.y, (nodes_box.max.y - nodes_box.min.y)))};
        const center = !selected_pos ? nodes_box_center : {x: (selected_pos.x + nodes_box_center.x * 3) * 0.25, y: (selected_pos.y + nodes_box_center.y * 3) * 0.25};

        return {nodes_box_dimensions, center};
    };

    const middleware = dispatch => (ha_action, ha_payload) => {
        const is_action_array_payload = Array.isArray(ha_action) 
            && ha_action.length === 2
            && (typeof ha_action[0] === 'function' 
                    || (ha_action[0].hasOwnProperty('fn') 
                        && ha_action[0].hasOwnProperty('graph')));

        const is_action_obj_payload = typeof ha_action === 'object' 
            && ha_action.hasOwnProperty('fn') 
            && ha_action.hasOwnProperty('graph') 
            && ha_action.hasOwnProperty('args');
        const action = is_action_array_payload ? ha_action[0] : ha_action;
        const payload = is_action_array_payload ? ha_action[1] : is_action_obj_payload ? {...ha_action.args, event: ha_payload} : ha_payload;

        return typeof action === 'object' && action.hasOwnProperty('fn') && action.hasOwnProperty('graph')
            ? dispatch((state, payload) => {
                try {
                    const execute_graph_fn = lib.no.executeGraphNode({graph: action.graph})(action.fn);
                    Object.defineProperty(execute_graph_fn, 'name', {value: action.fn, writable: false});
                    const result = action.stateonly 
                        ? execute_graph_fn(state)
                        : execute_graph_fn({state, payload});

                    if(!result) {
                        return state;
                    }

                    const effects = (result.effects ?? []).filter(e => e).map(e => {
                        if(typeof e === 'object' 
                        && e.hasOwnProperty('fn') 
                        && e.hasOwnProperty('graph')) {
                            const effect_fn = lib.no.executeGraphNode({graph: e.graph})(e.fn);
                            Object.defineProperty(effect_fn, 'name', {value: e.fn, writable: false});
                            return effect_fn;
                        }
                        return e
                    });//.map(fx => ispromise(fx) ? fx.catch(e => dispatch(s => [{...s, error: e}])) : fx);

                    if (ispromise(result)) {
                        // TODO: handle promises properly
                        return state;
                    }

                    return result.hasOwnProperty("state")
                        ? effects.length > 0 ? [result.state, ...effects] : result.state
                        : result.hasOwnProperty("action") && result.hasOwnProperty("payload") 
                        ? [result.action, result.payload]
                        : state;
                } catch(e) {
                    return {...state, error: e}
                }
            }, payload)
            : dispatch(action, payload)
    };

    /////////////////////////////////

    const cache = new Map();

    const generic_nodes = new Set([
        "get",
        "set",
        "delete",
        "object",

        "switch",
        "if",
        "flow",

        "html",
        "html_element",
        "html_text",
        "toggle",
        "input",
        "css_styles",

        "array",
        "filter",
        "map",
        "append",

        "utility",
        "log",
        "execute_graph",
        "arg",
        "apply",
        "partial",
        "fetch",
        "call",
        "default",
        "merge_objects",
        "sequence",
        "runnable",
        "run",
        "dispatch_runnable",
        "object_entries",
        "import_json",
        "event_publisher",
        "event_subscriber",

        "math",
        "add",
        "divide",
        "mult",
        "negate",

        "JSON",
        "stringify",
        "parse",

        "state",
        "modify_state_runnable",
        "initial_state_runnable",
        "set_display",

        "custom"
    ]);

    const ispromise = a => a?._Proxy ? false : typeof a?.then === 'function';
    const getorset = (map, id, value_fn) => map.has(id) ? map.get(id) : (map.set(id, value_fn()), map.get(id));

    const lib = {
        just: { 
            get: {
                args: ['target', 'path', 'def'],
                fn: (target, path, def) => {
                    return objectSafeGet(target?._Proxy ? target._value : target, path?._Proxy ? path._value : path, def?._Proxy ? def._value : def);
                },
            },
            set: objectSafeSet, 
            diff,
            diffApply
        },
        ha: { h: {args: ['dom_type', 'props', 'children'], fn: h}, app, text: {args: ['text'], fn: text}, memo: {args: ['view', 'props'], fn: memo} },
        no: {
            middleware,
            executeGraph: ({ state, graph, cache_id }) => executeGraph({ cache, state, graph, cache_id: cache_id ?? "main" })(graph.out)(state.get(graph.in)),
            executeGraphValue: ({ graph, cache_id }) => executeGraph({ cache, graph, cache_id: cache_id ?? "main" })(graph.out),
            executeGraphNode: ({ graph, cache_id }) => executeGraph({ cache, graph, cache_id: cache_id ?? "main" }),
            runGraph: (graph, node, args) => node !== undefined
                ? executeGraph({graph, cache, cache_id: "main"})(node)(args)
                : executeGraph({graph: graph.graph, cache, cache_id: "main"})(graph.fn)(graph.args),
            resolve,
            objToGraph,
            NodysseusError,
            runtime: (function(){
                console.log(self);
                const worker = document ? new Worker(new URL("worker-036fdb38.js", module.uri)) : false;
                const cache = new Map(); 
                const new_graph_cache = (graph) => () => ({
                    graph,
                    node_map: new Map(graph.nodes.map(n => [n.id, n])), 
                    in_edge_map: new Map(graph.nodes.map(n => [n.id, graph.edges.filter(e => e.to === n.id)])),
                    fn_cache: new Map(),
                    listeners: new Map()
                });
                const getorsetgraph = (graph, id, path, valfn) => getorset(getorset(cache, graph.id, new_graph_cache(graph))[path], id, valfn);
                const publish = (graph, event, data) => {
                    if(event === 'graphchange'){
                        cache.get(graph.id).graph = graph;
                    }
                    const listeners = getorsetgraph(graph, event, 'listeners', () => new Map());
                    for(let l of listeners.values()) {
                        if(typeof l === 'function') {
                            l(graph, data);
                        } else if(typeof fn === 'object' && fn.fn && fn.graph) {
                            lib.no.runGraph(fn.graph, fn.fn, Object.assign({}, fn.args ?? {}, {data}));
                        }
                    }

                };

                const rungraph = graph => {
                    cancelAnimationFrame(cache.get(graph.id).animrun);
                    cache.get(graph.id).animrun = requestAnimationFrame(() =>{
                        try {
                            graph = resolve(graph);
                            const gcache = cache.get(graph.id);
                            const last_result = gcache.last_result;
                            const result = lib.no.runGraph(graph, graph.out ?? 'main/out', last_result ?? {});
                            console.info(graph);
                            worker.postMessage({graph, fn: graph.out ?? 'main/out', args: last_result ?? {}});
                            Promise.resolve(result).then(res => {
                                gcache.last_result = res;
                                publish(graph, 'graphrun', res);
                            }).catch(e => publish(graph, 'grapherror', e));
                        } catch(e) {
                            publish(graph, 'grapherror', e);
                        }
                    });
                };

                const add_listener = (graph, event, listener_id, fn, remove) => {
                    if(remove) {
                        remove_listener(graph, event, listener_id);
                    }

                    const listeners = getorsetgraph(graph, event, 'listeners', () => new Map());
                    listeners.set(listener_id, fn);
                    
                    //TODO: rethink this maybe?
                    if(event !== 'graphchange') {
                        add_listener(graph, 'graphchange', 'rungraph', rungraph);
                    }
                };

                const remove_listener = (graph, event, listener_id) => {
                    const listeners = cache.get(graph.id).listeners;
                    for(let l of listeners.values()) {
                        l.delete(listener_id);
                    }
                    
                    //TODO: rethink this maybe?
                    if (listeners.size === 0) {
                        const graph_listeners = cache.get(graph.id).listeners;
                        graph_listeners.delete(event);
                        if (graph_listeners.size == 0 || 
                            (graph_listeners.size === 1 && graph_listeners.has('graphchange'))){
                            remove_listener(graph, 'graphchange', 'rungraph');
                        }
                    }
                };

                const update_graph = (graph) => {
                    graph = resolve(graph);
                    const new_cache = new_graph_cache(graph)();
                    cache.get(graph.id).node_map = new_cache.node_map;
                    cache.get(graph.id).in_edge_map = new_cache.in_edge_map;
                    publish(graph, 'graphchange');
                };

                const get_node = (graph, id) => getorsetgraph(resolve(graph), id, 'node_map', () => graph.nodes.find(n => n.id === id));
                const get_edges_in = (graph, id) => getorsetgraph(resolve(graph), id, 'in_edge_map', () => graph.edges.filter(e => e.to === id));

                return { 
                    add_graph: (graph) => {
                        const gcache = getorset(cache, graph.id, new_graph_cache(graph));
                        add_listener(graph, 'graphchange', 'update_gcache', g => gcache.graph = g);
                        publish(graph, 'graphchange');
                    },
                    is_cached: (graph, id) => getorset(cache, graph.id, new_graph_cache(graph)).node_map.has(id),
                    get_node,
                    get_edges_in,
                    get_fn: (graph, orderedargs, node_ref) => getorsetgraph(resolve(graph), orderedargs + node_ref.script, 'fn_cache', () => new Function(`return function _${(node_ref.name?.replace(/\W/g, "_") ?? node_ref.id).replace(/(\s|\/)/g, '_')}(${orderedargs}){${node_ref.script}}`)()),
                    update_graph,
                    edit_edge: (graph, edge, old_edge) => {
                        const gcache = getorset(cache, graph.id, new_graph_cache(resolve(graph)));
                        graph = gcache.graph;

                        gcache.in_edge_map.delete((old_edge ?? edge).to);
                        edge.as = edge.as ?? 'arg0';
                        // const next_edge = !edge.as 
                        //     ? lib.no.runGraph(cache.get('nodysseus_hyperapp').graph, 'next_edge', {edge, graph}) 
                        //     : edge;

                        const new_graph = {
                            ...graph,
                            edges: graph.edges.filter(e => !(e.to === (old_edge ?? edge).to && e.from === (old_edge ?? edge).from)).concat([edge])
                        };
                        publish(new_graph, 'graphchange');
                    },
                    add_node: (graph, node, edge) => {
                        // node = resolve(node);
                        // edge = resolve({...edge, _needsresolve: true});
                        const gcache = getorset(cache, graph.id, new_graph_cache(resolve(graph)));
                        graph = gcache.graph;
                        const graph_node = get_node(graph, node.id);


                        const old_edge_out = graph.edges.find(e => e.from === node.id);

                        gcache.node_map.delete(node.id);
                        gcache.in_edge_map.delete(node.id);
                        gcache.in_edge_map.delete(old_edge_out?.to);
                        gcache.fn_cache.delete(node.id);

                        if (graph_node?.nodes || graph_node?.ref && get_node(graph, graph_node.ref).nodes) {
                            for(let k of gcache.node_map.keys()) {
                                if(k.startsWith(node.id)) {
                                    gcache.node_map.delete(k);
                                }
                            }

                            for(let k of gcache.in_edge_map.keys()) {
                                if(k.startsWith(node.id)) {
                                    gcache.in_edge_map.delete(k);
                                }
                            }
                        }

                        const edge_out = edge ? lib.no.runGraph(cache.get('nodysseus_hyperapp').graph, 'next_edge', {edge, graph}) : undefined;

                        const edges_in = get_edges_in(graph, node.id);
                        if (edges_in && edges_in.length > 0) {
                            lib.no.runGraph(cache.get('nodysseus_hyperapp').graph, 'node_args', {node, nodes: graph.nodes});
                        }

                        const new_graph = {
                            ...graph, 
                            nodes: graph.nodes.filter(n => n.id !== node.id).concat([node]), 
                            edges: edge ? graph.edges.filter(e => !(e.from === edge_out.from && e.to === edge_out.to)).concat(edge_out) : graph.edges
                        };

                        publish(new_graph, 'graphchange');
                    },
                    delete_node: (graph, id) => {
                        const gcache = getorset(cache, graph.id, new_graph_cache(resolve(graph)));
                        graph = gcache.graph;

                        const parent_edge = graph.edges.find(e => e.from === id);
                        const child_edges = graph.edges.filter(e => e.to === id);

                        const current_child_edges = graph.edges.filter(e => e.to === parent_edge.to);
                        const new_child_edges = child_edges.map((e, i) => ({...e, to: parent_edge.to, as: i === 0 ? parent_edge.as : !e.as ? e.as : current_child_edges.find(ce => ce.as === e.as && ce.from !== id) ? e.as + '1' : e.as}));

                        const new_graph = {
                            ...graph,
                            nodes: graph.nodes.filter(n => n.id !== id),
                            edges: graph.edges.filter(e => e !== parent_edge && e.to !== id).concat(new_child_edges)
                        };

                        update_graph(new_graph);
                    },
                    add_listener,
                    add_listener_extern: {
                        args: ['graph', 'event', 'listener_id', 'fn'],
                        add_listener,
                    },
                    remove_listener,
                    publish: {
                        args: ['_graph', 'event', 'data'],
                        fn: publish
                    },
                    expand_node: (graph, id, node_ref) => {
                        // TODO: fix this mess
                        const gcache = getorset(cache, graph.id, new_graph_cache(graph));
                        graph = gcache.graph;
                        for (let i = 0; i < node_ref.edges.length; i++) {
                            const new_edge = Object.assign({}, node_ref.edges[i]);
                            new_edge.from = `${id}/${new_edge.from}`;
                            new_edge.to = `${id}/${new_edge.to}`;
                            // working_graph.edges.push(new_edge);
                            if(!gcache.in_edge_map.get(new_edge.to)?.find(e => e.from === new_edge.from && e.as === new_edge.as)) {
                                gcache.in_edge_map.set(new_edge.to, (gcache.in_edge_map.get(new_edge.to) ?? []).concat([new_edge]));
                            }
                            // in_edge_map.set(new_edge.to, (in_edge_map.get(new_edge.to) ?? []).concat([new_edge]))
                        }

                        for (const child of node_ref.nodes) {
                            const new_node = Object.assign({}, child);
                            new_node.id = `${id}/${child.id}`;
                            // working_graph.nodes.push(new_node)
                            if(!gcache.node_map.get(new_node.id)) {
                                gcache.node_map.set(new_node.id, new_node);
                            } 
                            // node_map.set(new_node.id, new_node);
                            const has_inputs = gcache.in_edge_map.has(new_node.id);
                            if (new_node.id === `${id}/${node_ref.in ?? 'in'}`) {
                                // in_edge_map.get(node.id).map(e => ({ ...e, to: `${node.id}/${node_ref.in ?? 'in'}` }))
                                //     .forEach(e => working_graph.edges.push(e));
                                if(!gcache.in_edge_map.has(new_node.id)) {
                                    const new_edges = [];
                                    gcache.in_edge_map.get(id).forEach(e => {
                                        new_edges.push({ ...e, to: `${id}/${node_ref.in ?? 'in'}`});
                                    });
                                    gcache.in_edge_map.set(new_node.id, new_edges);
                                }
                                // in_edge_map.set(new_node.id, working_graph.edges.filter(e => e.to === `${node.id}/${node_ref.in ?? 'in'}`))
                            } else if (!has_inputs) {
                                // in_edge_map.set(new_node.id, []);
                                gcache.in_edge_map.set(new_node.id, []);
                            }
                        }
                    }
                }
            })()
        },
        utility: {
            eq: ({a, b}) => a === b,
            arg: {
                args: ['_node', 'target'],
                resolve: false,
                fn: (node, target) => typeof node.value === 'string' 
                    ? node.value === '_args' 
                        ? target
                        : objectSafeGet(target, node.value) 
                    : node.value === '_graph'
                    ? graph
                    : node.value === '_node'
                    ? node
                    : node.value !== undefined && target !== undefined
                    ? target[node.value]
                    : undefined,
            },
            new_array: {
                args: ['_node_inputs'],
                resolve: false,
                fn: (args) => {
                    const arr = Object.keys(args)
                        .sort()
                        .reduce((acc, k) => [
                                acc[0].concat([args[k]]), 
                                acc[1] || ispromise(args[k])
                            ], [[], false]);
                    return arr[1] ? Promise.all(arr[0]) : arr[0];
                }
            },
            fetch: {
                args: ['url', 'params'],
                fn: fetch
            },
            call: {
                args: ['fn', 'args', 'self'],
                fn: (fn, args, self) => typeof self === 'function' ? self(...((args ?? []).reverse().reduce((acc, v) => [!acc[0] && v !== undefined, acc[0] || v !== undefined ? acc[1].concat([v]) : acc[1]], [false, []])[1].reverse())) : self[fn](...((args ?? []).reverse().reduce((acc, v) => [!acc[0] && v !== undefined, acc[0] || v !== undefined ? acc[1].concat([v]) : acc[1]], [false, []])[1].reverse()))
            },
            merge_objects: {
                args: ['_node_inputs'],
                resolve: false,
                fn: (args) => {
                    const keys = Object.keys(args).sort();
                    const promise = keys.reduce((acc, k) => acc || ispromise(args[k]), false);
                    return promise 
                        ? Promise.all(keys.map(k => Promise.resolve(args[k])))
                            .then(es => Object.assign({}, ...es.map(k => args[k]?._Proxy ? args[k]._value : args[k]).filter(a => a && typeof a === 'object'))) 
                        : Object.assign({}, ...keys.map(k => args[k]?._Proxy ? args[k]._value : args[k]).filter(a => a && typeof a === 'object'))
                        // Object.fromEntries(keys
                        //     .map(k => args[k]?._Proxy ? args[k]._value : args[k])
                        //     .flatMap(o => typeof o === 'object' && o ? Object.entries(o) : [])
                        // )
                }
            },
            add: {
                args: ["_node_inputs"],
                resolve: true,
                fn: (args) => Object.values(args).reduce((acc, v) => acc + v, 0)
            },
            mult: {
                args: ["_node_inputs"],
                resolve: true,
                fn: (args) => Object.values(args).reduce((acc, v) => acc * v, 1)
            },
            negate: {
                args: ["value"],
                resolve: true,
                fn: (value) => -value
            },
            divide: {
                args: ["_node_inputs"],
                resolve: true,
                fn: (args) => Object.values(args).reduce((acc, v) => acc / v, 1)
            }
        },
        JSON: {
            stringify: {
                args: ['object'],
                resolve: true,
                fn: (args) => JSON.stringify(args)
            },
            parse: {
                args: ['string'],
                resolve: true,
                fn: (args) => JSON.parse(args)
            }
        },
        scripts: { d3subscription, updateSimulationNodes, graphToSimulationNodes, expand_node, flattenNode, contract_node, keydownSubscription, calculateLevels, contract_all, listen, graph_subscription, result_subscription},
        d3: { forceSimulation, forceManyBody, forceCenter, forceLink, forceRadial, forceY, forceCollide, forceX },
        Fuse,
        ldjs,
        pz: {
            panzoom: (dispatch, sub_payload) => {
                let instance;
                let lastpanzoom = 0;
                const panzoom_selected_effect = (dispatch, payload) => {
                    if(!instance || !payload.selected){ return; }
                    lastpanzoom = performance.now();
                    const viewbox = findViewBox(
                        payload.nodes, 
                        payload.links, 
                        typeof payload.selected === 'string' ? payload.selected : payload.selected[0], 
                        payload.node_el_width, 
                        payload.html_id,
                        payload.dimensions
                    );
                    const x = payload.dimensions.x * 0.5 - viewbox.center.x;
                    const y = payload.dimensions.y * 0.5 - viewbox.center.y;
                    const scale = instance.getTransform().scale;
                    instance.moveTo(x, y);
                    instance.zoomTo(x, y, 1 / scale);

                    if(!payload.prevent_dispatch) {
                        dispatch(sub_payload.action, {event: 'effect_transform', transform: instance.getTransform()});
                    }
                };

                let init = requestAnimationFrame(() => {
                    instance = panzoom(document.getElementById(sub_payload.id), {
                        // onTouch: e => false,
                        filterKey: e => true,
                        smoothScroll: false
                    });
                    instance.on('panstart', e => performance.now() - lastpanzoom > 100 ? dispatch(sub_payload.action, {event: 'panstart', transform: e.getTransform()}) : undefined);
                    instance.moveTo(window.innerWidth * 0, window.innerHeight * 0.5);
                });
                requestAnimationFrame(() => dispatch(s => [{...s, panzoom_selected_effect}]));
                return () => { cancelAnimationFrame(init); instance?.dispose(); }
            }
        }
        // THREE
    };

    const runGraph = lib.no.runGraph;

    const add_default_nodes_and_edges = g => ({
                ...g, 
                nodes: g.nodes
                    .filter(n => !generic_nodes.has(n.id))
                    .concat(DEFAULT_GRAPH.nodes.filter(n => generic_nodes.has(n.id))),
                edges: g.edges
                    .filter(e => !generic_nodes.has(e.from))
                    .concat(DEFAULT_GRAPH.edges.filter(e => generic_nodes.has(e.to))) 
    });


    const nodysseus = function(html_id, display_graph) {
        const url_params = new URLSearchParams(document.location.search);
        const dispatch = runGraph(DEFAULT_GRAPH, "initialize_hyperapp_app", { 
            graph: DEFAULT_GRAPH, 
            display_graph: add_default_nodes_and_edges(display_graph),
            hash: window.location.hash ?? "",
            url_params,
            html_id,
            dimensions: {
                x: document.getElementById(html_id).clientWidth,
                y: document.getElementById(html_id).clientHeight
            },
            examples: examples.map(add_default_nodes_and_edges),
            readonly: false, 
            norun: url_params.get("norun") !== null,
            hide_types: false,
            offset: {x: 0, y: 0}
        });

        return () => requestAnimationFrame(() => dispatch.dispatch(s => undefined));
    };

    exports.nodysseus = nodysseus;
    exports.runGraph = runGraph;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
