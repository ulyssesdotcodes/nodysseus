(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x3) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x3, {
    get: (a2, b) => (typeof require !== "undefined" ? require : a2)[b]
  }) : x3)(function(x3) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x3 + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all2) => {
    for (var name2 in all2)
      __defProp(target, name2, { get: all2[name2], enumerable: true });
  };
  var __copyProps = (to, from3, except, desc) => {
    if (from3 && typeof from3 === "object" || typeof from3 === "function") {
      for (let key of __getOwnPropNames(from3))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toBinary = /* @__PURE__ */ (() => {
    var table = new Uint8Array(128);
    for (var i = 0; i < 64; i++)
      table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;
    return (base64) => {
      var n2 = base64.length, bytes = new Uint8Array((n2 - (base64[n2 - 1] == "=") - (base64[n2 - 2] == "=")) * 3 / 4 | 0);
      for (var i2 = 0, j = 0; i2 < n2; ) {
        var c0 = table[base64.charCodeAt(i2++)], c1 = table[base64.charCodeAt(i2++)];
        var c2 = table[base64.charCodeAt(i2++)], c3 = table[base64.charCodeAt(i2++)];
        bytes[j++] = c0 << 2 | c1 >> 4;
        bytes[j++] = c1 << 4 | c2 >> 2;
        bytes[j++] = c2 << 6 | c3;
      }
      return bytes;
    };
  })();

  // node_modules/lokijs/src/loki-indexed-adapter.js
  var require_loki_indexed_adapter = __commonJS({
    "node_modules/lokijs/src/loki-indexed-adapter.js"(exports, module2) {
      (function(root, factory2) {
        if (typeof define === "function" && define.amd) {
          define([], factory2);
        } else if (typeof exports === "object") {
          module2.exports = factory2();
        } else {
          root.LokiIndexedAdapter = factory2();
        }
      })(exports, function() {
        return function() {
          function LokiIndexedAdapter(appname, options) {
            this.app = "loki";
            this.options = options || {};
            if (typeof appname !== "undefined") {
              this.app = appname;
            }
            this.catalog = null;
            if (!this.checkAvailability()) {
              throw new Error("indexedDB does not seem to be supported for your environment");
            }
          }
          LokiIndexedAdapter.prototype.closeDatabase = function() {
            if (this.catalog && this.catalog.db) {
              this.catalog.db.close();
              this.catalog.db = null;
            }
          };
          LokiIndexedAdapter.prototype.checkAvailability = function() {
            if (typeof indexedDB !== "undefined" && indexedDB)
              return true;
            return false;
          };
          LokiIndexedAdapter.prototype.loadDatabase = function(dbname, callback) {
            var appName = this.app;
            var adapter = this;
            if (this.catalog === null || this.catalog.db === null) {
              this.catalog = new LokiCatalog(function(cat) {
                adapter.catalog = cat;
                adapter.loadDatabase(dbname, callback);
              });
              return;
            }
            this.catalog.getAppKey(appName, dbname, function(result) {
              if (typeof callback === "function") {
                if (result.id === 0) {
                  callback(null);
                  return;
                }
                callback(result.val);
              } else {
                console.log(result.val);
              }
            });
          };
          LokiIndexedAdapter.prototype.loadKey = LokiIndexedAdapter.prototype.loadDatabase;
          LokiIndexedAdapter.prototype.saveDatabase = function(dbname, dbstring, callback) {
            var appName = this.app;
            var adapter = this;
            function saveCallback(result) {
              if (result && result.success === true) {
                callback(null);
              } else {
                callback(new Error("Error saving database"));
              }
              if (adapter.options.closeAfterSave) {
                adapter.closeDatabase();
              }
            }
            if (this.catalog === null || this.catalog.db === null) {
              this.catalog = new LokiCatalog(function(cat) {
                adapter.saveDatabase(dbname, dbstring, saveCallback);
              });
              return;
            }
            this.catalog.setAppKey(appName, dbname, dbstring, saveCallback);
          };
          LokiIndexedAdapter.prototype.saveKey = LokiIndexedAdapter.prototype.saveDatabase;
          LokiIndexedAdapter.prototype.deleteDatabase = function(dbname, callback) {
            var appName = this.app;
            var adapter = this;
            if (this.catalog === null || this.catalog.db === null) {
              this.catalog = new LokiCatalog(function(cat) {
                adapter.catalog = cat;
                adapter.deleteDatabase(dbname, callback);
              });
              return;
            }
            this.catalog.getAppKey(appName, dbname, function(result) {
              var id3 = result.id;
              if (id3 !== 0) {
                adapter.catalog.deleteAppKey(id3, callback);
              } else if (typeof callback === "function") {
                callback({ success: true });
              }
            });
          };
          LokiIndexedAdapter.prototype.deleteKey = LokiIndexedAdapter.prototype.deleteDatabase;
          LokiIndexedAdapter.prototype.deleteDatabasePartitions = function(dbname) {
            var self2 = this;
            this.getDatabaseList(function(result) {
              result.forEach(function(str) {
                if (str.startsWith(dbname)) {
                  self2.deleteDatabase(str);
                }
              });
            });
          };
          LokiIndexedAdapter.prototype.getDatabaseList = function(callback) {
            var appName = this.app;
            var adapter = this;
            if (this.catalog === null || this.catalog.db === null) {
              this.catalog = new LokiCatalog(function(cat) {
                adapter.catalog = cat;
                adapter.getDatabaseList(callback);
              });
              return;
            }
            this.catalog.getAppKeys(appName, function(results) {
              var names = [];
              for (var idx = 0; idx < results.length; idx++) {
                names.push(results[idx].key);
              }
              if (typeof callback === "function") {
                callback(names);
              } else {
                names.forEach(function(obj) {
                  console.log(obj);
                });
              }
            });
          };
          LokiIndexedAdapter.prototype.getKeyList = LokiIndexedAdapter.prototype.getDatabaseList;
          LokiIndexedAdapter.prototype.getCatalogSummary = function(callback) {
            var appName = this.app;
            var adapter = this;
            if (this.catalog === null || this.catalog.db === null) {
              this.catalog = new LokiCatalog(function(cat) {
                adapter.catalog = cat;
                adapter.getCatalogSummary(callback);
              });
              return;
            }
            this.catalog.getAllKeys(function(results) {
              var entries = [];
              var obj, size, oapp, okey, oval;
              for (var idx = 0; idx < results.length; idx++) {
                obj = results[idx];
                oapp = obj.app || "";
                okey = obj.key || "";
                oval = obj.val || "";
                size = oapp.length * 2 + okey.length * 2 + oval.length + 1;
                entries.push({ "app": obj.app, "key": obj.key, "size": size });
              }
              if (typeof callback === "function") {
                callback(entries);
              } else {
                entries.forEach(function(obj2) {
                  console.log(obj2);
                });
              }
            });
          };
          function LokiCatalog(callback) {
            this.db = null;
            this.initializeLokiCatalog(callback);
          }
          LokiCatalog.prototype.initializeLokiCatalog = function(callback) {
            var openRequest = indexedDB.open("LokiCatalog", 1);
            var cat = this;
            openRequest.onupgradeneeded = function(e) {
              var thisDB = e.target.result;
              if (thisDB.objectStoreNames.contains("LokiAKV")) {
                thisDB.deleteObjectStore("LokiAKV");
              }
              if (!thisDB.objectStoreNames.contains("LokiAKV")) {
                var objectStore = thisDB.createObjectStore("LokiAKV", { keyPath: "id", autoIncrement: true });
                objectStore.createIndex("app", "app", { unique: false });
                objectStore.createIndex("key", "key", { unique: false });
                objectStore.createIndex("appkey", "appkey", { unique: true });
              }
            };
            openRequest.onsuccess = function(e) {
              cat.db = e.target.result;
              if (typeof callback === "function")
                callback(cat);
            };
            openRequest.onerror = function(e) {
              throw e;
            };
          };
          LokiCatalog.prototype.getAppKey = function(app2, key, callback) {
            var transaction = this.db.transaction(["LokiAKV"], "readonly");
            var store = transaction.objectStore("LokiAKV");
            var index2 = store.index("appkey");
            var appkey = app2 + "," + key;
            var request = index2.get(appkey);
            request.onsuccess = function(usercallback) {
              return function(e) {
                var lres = e.target.result;
                if (lres === null || typeof lres === "undefined") {
                  lres = {
                    id: 0,
                    success: false
                  };
                }
                if (typeof usercallback === "function") {
                  usercallback(lres);
                } else {
                  console.log(lres);
                }
              };
            }(callback);
            request.onerror = function(usercallback) {
              return function(e) {
                if (typeof usercallback === "function") {
                  usercallback({ id: 0, success: false });
                } else {
                  throw e;
                }
              };
            }(callback);
          };
          LokiCatalog.prototype.getAppKeyById = function(id3, callback, data2) {
            var transaction = this.db.transaction(["LokiAKV"], "readonly");
            var store = transaction.objectStore("LokiAKV");
            var request = store.get(id3);
            request.onsuccess = function(data3, usercallback) {
              return function(e) {
                if (typeof usercallback === "function") {
                  usercallback(e.target.result, data3);
                } else {
                  console.log(e.target.result);
                }
              };
            }(data2, callback);
          };
          LokiCatalog.prototype.setAppKey = function(app2, key, val, callback) {
            var transaction = this.db.transaction(["LokiAKV"], "readwrite");
            var store = transaction.objectStore("LokiAKV");
            var index2 = store.index("appkey");
            var appkey = app2 + "," + key;
            var request = index2.get(appkey);
            request.onsuccess = function(e) {
              var res = e.target.result;
              if (res === null || res === void 0) {
                res = {
                  app: app2,
                  key,
                  appkey: app2 + "," + key,
                  val
                };
              } else {
                res.val = val;
              }
              var requestPut = store.put(res);
              requestPut.onerror = function(usercallback) {
                return function(e2) {
                  if (typeof usercallback === "function") {
                    usercallback({ success: false });
                  } else {
                    console.error("LokiCatalog.setAppKey (set) onerror");
                    console.error(request.error);
                  }
                };
              }(callback);
              requestPut.onsuccess = function(usercallback) {
                return function(e2) {
                  if (typeof usercallback === "function") {
                    usercallback({ success: true });
                  }
                };
              }(callback);
            };
            request.onerror = function(usercallback) {
              return function(e) {
                if (typeof usercallback === "function") {
                  usercallback({ success: false });
                } else {
                  console.error("LokiCatalog.setAppKey (get) onerror");
                  console.error(request.error);
                }
              };
            }(callback);
          };
          LokiCatalog.prototype.deleteAppKey = function(id3, callback) {
            var transaction = this.db.transaction(["LokiAKV"], "readwrite");
            var store = transaction.objectStore("LokiAKV");
            var request = store.delete(id3);
            request.onsuccess = function(usercallback) {
              return function(evt) {
                if (typeof usercallback === "function")
                  usercallback({ success: true });
              };
            }(callback);
            request.onerror = function(usercallback) {
              return function(evt) {
                if (typeof usercallback === "function") {
                  usercallback({ success: false });
                } else {
                  console.error("LokiCatalog.deleteAppKey raised onerror");
                  console.error(request.error);
                }
              };
            }(callback);
          };
          LokiCatalog.prototype.getAppKeys = function(app2, callback) {
            var transaction = this.db.transaction(["LokiAKV"], "readonly");
            var store = transaction.objectStore("LokiAKV");
            var index2 = store.index("app");
            var singleKeyRange = IDBKeyRange.only(app2);
            var cursor = index2.openCursor(singleKeyRange);
            var localdata = [];
            cursor.onsuccess = function(data2, callback2) {
              return function(e) {
                var cursor2 = e.target.result;
                if (cursor2) {
                  var currObject = cursor2.value;
                  data2.push(currObject);
                  cursor2.continue();
                } else {
                  if (typeof callback2 === "function") {
                    callback2(data2);
                  } else {
                    console.log(data2);
                  }
                }
              };
            }(localdata, callback);
            cursor.onerror = function(usercallback) {
              return function(e) {
                if (typeof usercallback === "function") {
                  usercallback(null);
                } else {
                  console.error("LokiCatalog.getAppKeys raised onerror");
                  console.error(e);
                }
              };
            }(callback);
          };
          LokiCatalog.prototype.getAllKeys = function(callback) {
            var transaction = this.db.transaction(["LokiAKV"], "readonly");
            var store = transaction.objectStore("LokiAKV");
            var cursor = store.openCursor();
            var localdata = [];
            cursor.onsuccess = function(data2, callback2) {
              return function(e) {
                var cursor2 = e.target.result;
                if (cursor2) {
                  var currObject = cursor2.value;
                  data2.push(currObject);
                  cursor2.continue();
                } else {
                  if (typeof callback2 === "function") {
                    callback2(data2);
                  } else {
                    console.log(data2);
                  }
                }
              };
            }(localdata, callback);
            cursor.onerror = function(usercallback) {
              return function(e) {
                if (typeof usercallback === "function")
                  usercallback(null);
              };
            }(callback);
          };
          return LokiIndexedAdapter;
        }();
      });
    }
  });

  // node_modules/lokijs/src/lokijs.js
  var require_lokijs = __commonJS({
    "node_modules/lokijs/src/lokijs.js"(exports, module2) {
      (function(root, factory2) {
        if (typeof define === "function" && define.amd) {
          define([], factory2);
        } else if (typeof exports === "object") {
          module2.exports = factory2();
        } else {
          root.loki = factory2();
        }
      })(exports, function() {
        return function() {
          "use strict";
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          function deepFreeze(obj) {
            var prop, i;
            if (Array.isArray(obj)) {
              for (i = 0; i < obj.length; i++) {
                deepFreeze(obj[i]);
              }
              freeze(obj);
            } else if (obj !== null && typeof obj === "object") {
              for (prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                  deepFreeze(obj[prop]);
                }
              }
              freeze(obj);
            }
          }
          function freeze(obj) {
            if (!Object.isFrozen(obj)) {
              Object.freeze(obj);
            }
          }
          function unFreeze(obj) {
            if (!Object.isFrozen(obj)) {
              return obj;
            }
            return clone2(obj, "shallow");
          }
          var Utils = {
            copyProperties: function(src, dest) {
              var prop;
              for (prop in src) {
                dest[prop] = src[prop];
              }
            },
            resolveTransformObject: function(subObj, params2, depth) {
              var prop, pname;
              if (typeof depth !== "number") {
                depth = 0;
              }
              if (++depth >= 10)
                return subObj;
              for (prop in subObj) {
                if (typeof subObj[prop] === "string" && subObj[prop].indexOf("[%lktxp]") === 0) {
                  pname = subObj[prop].substring(8);
                  if (params2.hasOwnProperty(pname)) {
                    subObj[prop] = params2[pname];
                  }
                } else if (typeof subObj[prop] === "object") {
                  subObj[prop] = Utils.resolveTransformObject(subObj[prop], params2, depth);
                }
              }
              return subObj;
            },
            resolveTransformParams: function(transform, params2) {
              var idx, clonedStep, resolvedTransform = [];
              if (typeof params2 === "undefined")
                return transform;
              for (idx = 0; idx < transform.length; idx++) {
                clonedStep = clone2(transform[idx], "shallow-recurse-objects");
                resolvedTransform.push(Utils.resolveTransformObject(clonedStep, params2));
              }
              return resolvedTransform;
            },
            getIn: function(object2, path, usingDotNotation) {
              if (object2 == null) {
                return void 0;
              }
              if (!usingDotNotation) {
                return object2[path];
              }
              if (typeof path === "string") {
                path = path.split(".");
              }
              if (!Array.isArray(path)) {
                throw new Error("path must be a string or array. Found " + typeof path);
              }
              var index2 = 0, length3 = path.length;
              while (object2 != null && index2 < length3) {
                object2 = object2[path[index2++]];
              }
              return index2 && index2 == length3 ? object2 : void 0;
            }
          };
          var Comparators = {
            aeq: aeqHelper,
            lt: ltHelper,
            gt: gtHelper
          };
          function aeqHelper(prop1, prop2) {
            var cv1, cv2, t1, t2;
            if (prop1 === prop2)
              return true;
            if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {
              switch (prop1) {
                case void 0:
                  t1 = 1;
                  break;
                case null:
                  t1 = 1;
                  break;
                case false:
                  t1 = 3;
                  break;
                case true:
                  t1 = 4;
                  break;
                case "":
                  t1 = 5;
                  break;
                default:
                  t1 = prop1 === prop1 ? 9 : 0;
                  break;
              }
              switch (prop2) {
                case void 0:
                  t2 = 1;
                  break;
                case null:
                  t2 = 1;
                  break;
                case false:
                  t2 = 3;
                  break;
                case true:
                  t2 = 4;
                  break;
                case "":
                  t2 = 5;
                  break;
                default:
                  t2 = prop2 === prop2 ? 9 : 0;
                  break;
              }
              if (t1 !== 9 || t2 !== 9) {
                return t1 === t2;
              }
            }
            cv1 = Number(prop1);
            cv2 = Number(prop2);
            if (cv1 === cv1 || cv2 === cv2) {
              return cv1 === cv2;
            }
            cv1 = prop1.toString();
            cv2 = prop2.toString();
            return cv1 == cv2;
          }
          function ltHelper(prop1, prop2, equal) {
            var cv1, cv2, t1, t2;
            if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {
              switch (prop1) {
                case void 0:
                  t1 = 1;
                  break;
                case null:
                  t1 = 1;
                  break;
                case false:
                  t1 = 3;
                  break;
                case true:
                  t1 = 4;
                  break;
                case "":
                  t1 = 5;
                  break;
                default:
                  t1 = prop1 === prop1 ? 9 : 0;
                  break;
              }
              switch (prop2) {
                case void 0:
                  t2 = 1;
                  break;
                case null:
                  t2 = 1;
                  break;
                case false:
                  t2 = 3;
                  break;
                case true:
                  t2 = 4;
                  break;
                case "":
                  t2 = 5;
                  break;
                default:
                  t2 = prop2 === prop2 ? 9 : 0;
                  break;
              }
              if (t1 !== 9 || t2 !== 9) {
                return t1 === t2 ? equal : t1 < t2;
              }
            }
            cv1 = Number(prop1);
            cv2 = Number(prop2);
            if (cv1 === cv1 && cv2 === cv2) {
              if (cv1 < cv2)
                return true;
              if (cv1 > cv2)
                return false;
              return equal;
            }
            if (cv1 === cv1 && cv2 !== cv2) {
              return true;
            }
            if (cv2 === cv2 && cv1 !== cv1) {
              return false;
            }
            if (prop1 < prop2)
              return true;
            if (prop1 > prop2)
              return false;
            if (prop1 == prop2)
              return equal;
            cv1 = prop1.toString();
            cv2 = prop2.toString();
            if (cv1 < cv2) {
              return true;
            }
            if (cv1 == cv2) {
              return equal;
            }
            return false;
          }
          function gtHelper(prop1, prop2, equal) {
            var cv1, cv2, t1, t2;
            if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {
              switch (prop1) {
                case void 0:
                  t1 = 1;
                  break;
                case null:
                  t1 = 1;
                  break;
                case false:
                  t1 = 3;
                  break;
                case true:
                  t1 = 4;
                  break;
                case "":
                  t1 = 5;
                  break;
                default:
                  t1 = prop1 === prop1 ? 9 : 0;
                  break;
              }
              switch (prop2) {
                case void 0:
                  t2 = 1;
                  break;
                case null:
                  t2 = 1;
                  break;
                case false:
                  t2 = 3;
                  break;
                case true:
                  t2 = 4;
                  break;
                case "":
                  t2 = 5;
                  break;
                default:
                  t2 = prop2 === prop2 ? 9 : 0;
                  break;
              }
              if (t1 !== 9 || t2 !== 9) {
                return t1 === t2 ? equal : t1 > t2;
              }
            }
            cv1 = Number(prop1);
            cv2 = Number(prop2);
            if (cv1 === cv1 && cv2 === cv2) {
              if (cv1 > cv2)
                return true;
              if (cv1 < cv2)
                return false;
              return equal;
            }
            if (cv1 === cv1 && cv2 !== cv2) {
              return false;
            }
            if (cv2 === cv2 && cv1 !== cv1) {
              return true;
            }
            if (prop1 > prop2)
              return true;
            if (prop1 < prop2)
              return false;
            if (prop1 == prop2)
              return equal;
            cv1 = prop1.toString();
            cv2 = prop2.toString();
            if (cv1 > cv2) {
              return true;
            }
            if (cv1 == cv2) {
              return equal;
            }
            return false;
          }
          function sortHelper(prop1, prop2, desc) {
            if (Comparators.aeq(prop1, prop2))
              return 0;
            if (Comparators.lt(prop1, prop2, false)) {
              return desc ? 1 : -1;
            }
            if (Comparators.gt(prop1, prop2, false)) {
              return desc ? -1 : 1;
            }
            return 0;
          }
          function compoundeval(properties2, obj1, obj2) {
            var res = 0;
            var prop, field, val1, val2, arr, path;
            for (var i = 0, len = properties2.length; i < len; i++) {
              prop = properties2[i];
              field = prop[0];
              if (~field.indexOf(".")) {
                arr = field.split(".");
                val1 = Utils.getIn(obj1, arr, true);
                val2 = Utils.getIn(obj2, arr, true);
              } else {
                val1 = obj1[field];
                val2 = obj2[field];
              }
              res = sortHelper(val1, val2, prop[1]);
              if (res !== 0) {
                return res;
              }
            }
            return 0;
          }
          function dotSubScan(root, paths, fun, value, extra, poffset) {
            var pathOffset = poffset || 0;
            var path = paths[pathOffset];
            var valueFound = false;
            var element2;
            if (typeof root === "object" && path in root) {
              element2 = root[path];
            }
            if (pathOffset + 1 >= paths.length) {
              valueFound = fun(element2, value, extra);
            } else if (Array.isArray(element2)) {
              for (var index2 = 0, len = element2.length; index2 < len; index2 += 1) {
                valueFound = dotSubScan(element2[index2], paths, fun, value, extra, pathOffset + 1);
                if (valueFound === true) {
                  break;
                }
              }
            } else {
              valueFound = dotSubScan(element2, paths, fun, value, extra, pathOffset + 1);
            }
            return valueFound;
          }
          function containsCheckFn(a2) {
            if (typeof a2 === "string" || Array.isArray(a2)) {
              return function(b) {
                return a2.indexOf(b) !== -1;
              };
            } else if (typeof a2 === "object" && a2 !== null) {
              return function(b) {
                return hasOwnProperty.call(a2, b);
              };
            }
            return null;
          }
          function doQueryOp(val, op, record) {
            for (var p in op) {
              if (hasOwnProperty.call(op, p)) {
                return LokiOps[p](val, op[p], record);
              }
            }
            return false;
          }
          var LokiOps = {
            $eq: function(a2, b) {
              return a2 === b;
            },
            $aeq: function(a2, b) {
              return a2 == b;
            },
            $ne: function(a2, b) {
              if (b !== b) {
                return a2 === a2;
              }
              return a2 !== b;
            },
            $dteq: function(a2, b) {
              return Comparators.aeq(a2, b);
            },
            $gt: function(a2, b) {
              return Comparators.gt(a2, b, false);
            },
            $gte: function(a2, b) {
              return Comparators.gt(a2, b, true);
            },
            $lt: function(a2, b) {
              return Comparators.lt(a2, b, false);
            },
            $lte: function(a2, b) {
              return Comparators.lt(a2, b, true);
            },
            $jgt: function(a2, b) {
              return a2 > b;
            },
            $jgte: function(a2, b) {
              return a2 >= b;
            },
            $jlt: function(a2, b) {
              return a2 < b;
            },
            $jlte: function(a2, b) {
              return a2 <= b;
            },
            $between: function(a2, vals) {
              if (a2 === void 0 || a2 === null)
                return false;
              return Comparators.gt(a2, vals[0], true) && Comparators.lt(a2, vals[1], true);
            },
            $jbetween: function(a2, vals) {
              if (a2 === void 0 || a2 === null)
                return false;
              return a2 >= vals[0] && a2 <= vals[1];
            },
            $in: function(a2, b) {
              return b.indexOf(a2) !== -1;
            },
            $inSet: function(a2, b) {
              return b.has(a2);
            },
            $nin: function(a2, b) {
              return b.indexOf(a2) === -1;
            },
            $keyin: function(a2, b) {
              return a2 in b;
            },
            $nkeyin: function(a2, b) {
              return !(a2 in b);
            },
            $definedin: function(a2, b) {
              return b[a2] !== void 0;
            },
            $undefinedin: function(a2, b) {
              return b[a2] === void 0;
            },
            $regex: function(a2, b) {
              return b.test(a2);
            },
            $containsString: function(a2, b) {
              return typeof a2 === "string" && a2.indexOf(b) !== -1;
            },
            $containsNone: function(a2, b) {
              return !LokiOps.$containsAny(a2, b);
            },
            $containsAny: function(a2, b) {
              var checkFn = containsCheckFn(a2);
              if (checkFn !== null) {
                return Array.isArray(b) ? b.some(checkFn) : checkFn(b);
              }
              return false;
            },
            $contains: function(a2, b) {
              var checkFn = containsCheckFn(a2);
              if (checkFn !== null) {
                return Array.isArray(b) ? b.every(checkFn) : checkFn(b);
              }
              return false;
            },
            $elemMatch: function(a2, b) {
              if (Array.isArray(a2)) {
                return a2.some(function(item) {
                  return Object.keys(b).every(function(property) {
                    var filter = b[property];
                    if (!(typeof filter === "object" && filter)) {
                      filter = { $eq: filter };
                    }
                    if (property.indexOf(".") !== -1) {
                      return dotSubScan(item, property.split("."), doQueryOp, b[property], item);
                    }
                    return doQueryOp(item[property], filter, item);
                  });
                });
              }
              return false;
            },
            $type: function(a2, b, record) {
              var type = typeof a2;
              if (type === "object") {
                if (Array.isArray(a2)) {
                  type = "array";
                } else if (a2 instanceof Date) {
                  type = "date";
                }
              }
              return typeof b !== "object" ? type === b : doQueryOp(type, b, record);
            },
            $finite: function(a2, b) {
              return b === isFinite(a2);
            },
            $size: function(a2, b, record) {
              if (Array.isArray(a2)) {
                return typeof b !== "object" ? a2.length === b : doQueryOp(a2.length, b, record);
              }
              return false;
            },
            $len: function(a2, b, record) {
              if (typeof a2 === "string") {
                return typeof b !== "object" ? a2.length === b : doQueryOp(a2.length, b, record);
              }
              return false;
            },
            $where: function(a2, b) {
              return b(a2) === true;
            },
            $not: function(a2, b, record) {
              return !doQueryOp(a2, b, record);
            },
            $and: function(a2, b, record) {
              for (var idx = 0, len = b.length; idx < len; idx += 1) {
                if (!doQueryOp(a2, b[idx], record)) {
                  return false;
                }
              }
              return true;
            },
            $or: function(a2, b, record) {
              for (var idx = 0, len = b.length; idx < len; idx += 1) {
                if (doQueryOp(a2, b[idx], record)) {
                  return true;
                }
              }
              return false;
            },
            $exists: function(a2, b) {
              if (b) {
                return a2 !== void 0;
              } else {
                return a2 === void 0;
              }
            }
          };
          var valueLevelOps = ["$eq", "$aeq", "$ne", "$dteq", "$gt", "$gte", "$lt", "$lte", "$jgt", "$jgte", "$jlt", "$jlte", "$type"];
          valueLevelOps.forEach(function(op) {
            var fun = LokiOps[op];
            LokiOps["$" + op] = function(a2, spec, record) {
              if (typeof spec === "string") {
                return fun(a2, record[spec]);
              } else if (typeof spec === "function") {
                return fun(a2, spec(record));
              } else {
                throw new Error("Invalid argument to $$ matcher");
              }
            };
          });
          var indexedOps = {
            $eq: LokiOps.$eq,
            $aeq: true,
            $dteq: true,
            $gt: true,
            $gte: true,
            $lt: true,
            $lte: true,
            $in: true,
            $between: true
          };
          function clone2(data2, method) {
            if (data2 === null || data2 === void 0) {
              return null;
            }
            var cloneMethod = method || "parse-stringify", cloned;
            switch (cloneMethod) {
              case "parse-stringify":
                cloned = JSON.parse(JSON.stringify(data2));
                break;
              case "jquery-extend-deep":
                cloned = jQuery.extend(true, {}, data2);
                break;
              case "shallow":
                cloned = Object.create(data2.constructor.prototype);
                Object.keys(data2).map(function(i) {
                  cloned[i] = data2[i];
                });
                break;
              case "shallow-assign":
                cloned = Object.create(data2.constructor.prototype);
                Object.assign(cloned, data2);
                break;
              case "shallow-recurse-objects":
                cloned = clone2(data2, "shallow");
                var keys3 = Object.keys(data2);
                keys3.forEach(function(key) {
                  if (typeof data2[key] === "object" && data2[key].constructor.name === "Object") {
                    cloned[key] = clone2(data2[key], "shallow-recurse-objects");
                  } else if (Array.isArray(data2[key])) {
                    cloned[key] = cloneObjectArray(data2[key], "shallow-recurse-objects");
                  }
                });
                break;
              default:
                break;
            }
            return cloned;
          }
          function cloneObjectArray(objarray, method) {
            if (method == "parse-stringify") {
              return clone2(objarray, method);
            }
            var result = [];
            for (var i = 0, len = objarray.length; i < len; i++) {
              result[i] = clone2(objarray[i], method);
            }
            return result;
          }
          function localStorageAvailable() {
            try {
              return window && window.localStorage !== void 0 && window.localStorage !== null;
            } catch (e) {
              return false;
            }
          }
          function LokiEventEmitter() {
          }
          LokiEventEmitter.prototype.events = {};
          LokiEventEmitter.prototype.asyncListeners = false;
          LokiEventEmitter.prototype.on = function(eventName, listener) {
            var event;
            var self2 = this;
            if (Array.isArray(eventName)) {
              eventName.forEach(function(currentEventName) {
                self2.on(currentEventName, listener);
              });
              return listener;
            }
            event = this.events[eventName];
            if (!event) {
              event = this.events[eventName] = [];
            }
            event.push(listener);
            return listener;
          };
          LokiEventEmitter.prototype.emit = function(eventName) {
            var self2 = this;
            var selfArgs;
            if (eventName && this.events[eventName]) {
              if (this.events[eventName].length) {
                selfArgs = Array.prototype.slice.call(arguments, 1);
                this.events[eventName].forEach(function(listener) {
                  if (self2.asyncListeners) {
                    setTimeout(function() {
                      listener.apply(self2, selfArgs);
                    }, 1);
                  } else {
                    listener.apply(self2, selfArgs);
                  }
                });
              }
            } else {
              throw new Error("No event " + eventName + " defined");
            }
          };
          LokiEventEmitter.prototype.addListener = LokiEventEmitter.prototype.on;
          LokiEventEmitter.prototype.removeListener = function(eventName, listener) {
            var self2 = this;
            if (Array.isArray(eventName)) {
              eventName.forEach(function(currentEventName) {
                self2.removeListener(currentEventName, listener);
              });
              return;
            }
            if (this.events[eventName]) {
              var listeners = this.events[eventName];
              listeners.splice(listeners.indexOf(listener), 1);
            }
          };
          function Loki(filename, options) {
            this.filename = filename || "loki.db";
            this.collections = [];
            this.databaseVersion = 1.5;
            this.engineVersion = 1.5;
            this.autosave = false;
            this.autosaveInterval = 5e3;
            this.autosaveHandle = null;
            this.throttledSaves = true;
            this.options = {};
            this.persistenceMethod = null;
            this.persistenceAdapter = null;
            this.throttledSavePending = false;
            this.throttledCallbacks = [];
            this.verbose = options && options.hasOwnProperty("verbose") ? options.verbose : false;
            this.events = {
              "init": [],
              "loaded": [],
              "flushChanges": [],
              "close": [],
              "changes": [],
              "warning": []
            };
            var getENV = function() {
              if (typeof global !== "undefined" && (global.android || global.NSObject)) {
                return "NATIVESCRIPT";
              }
              if (typeof window === "undefined") {
                return "NODEJS";
              }
              if (typeof global !== "undefined" && global.window && typeof process !== "undefined") {
                return "NODEJS";
              }
              if (typeof document !== "undefined") {
                if (document.URL.indexOf("http://") === -1 && document.URL.indexOf("https://") === -1) {
                  return "CORDOVA";
                }
                return "BROWSER";
              }
              return "CORDOVA";
            };
            if (options && options.hasOwnProperty("env")) {
              this.ENV = options.env;
            } else {
              this.ENV = getENV();
            }
            if (this.ENV === "undefined") {
              this.ENV = "NODEJS";
            }
            this.configureOptions(options, true);
            this.on("init", this.clearChanges);
          }
          Loki.prototype = new LokiEventEmitter();
          Loki.prototype.constructor = Loki;
          Loki.prototype.getIndexedAdapter = function() {
            var adapter;
            if (typeof __require === "function") {
              adapter = require_loki_indexed_adapter();
            }
            return adapter;
          };
          Loki.prototype.configureOptions = function(options, initialConfig) {
            var defaultPersistence = {
              "NODEJS": "fs",
              "BROWSER": "localStorage",
              "CORDOVA": "localStorage",
              "MEMORY": "memory"
            }, persistenceMethods = {
              "fs": LokiFsAdapter,
              "localStorage": LokiLocalStorageAdapter,
              "memory": LokiMemoryAdapter
            };
            this.options = {};
            this.persistenceMethod = null;
            this.persistenceAdapter = null;
            if (typeof options !== "undefined") {
              this.options = options;
              if (this.options.hasOwnProperty("persistenceMethod")) {
                if (typeof persistenceMethods[options.persistenceMethod] == "function") {
                  this.persistenceMethod = options.persistenceMethod;
                  this.persistenceAdapter = new persistenceMethods[options.persistenceMethod]();
                }
              }
              if (this.options.hasOwnProperty("adapter")) {
                this.persistenceMethod = "adapter";
                this.persistenceAdapter = options.adapter;
                this.options.adapter = null;
                this.isIncremental = this.persistenceAdapter.mode === "incremental";
              }
              if (options.autoload && initialConfig) {
                var self2 = this;
                setTimeout(function() {
                  self2.loadDatabase(options, options.autoloadCallback);
                }, 1);
              }
              if (this.options.hasOwnProperty("autosaveInterval")) {
                this.autosaveDisable();
                this.autosaveInterval = parseInt(this.options.autosaveInterval, 10);
              }
              if (this.options.hasOwnProperty("autosave") && this.options.autosave) {
                this.autosaveDisable();
                this.autosave = true;
                if (this.options.hasOwnProperty("autosaveCallback")) {
                  this.autosaveEnable(options, options.autosaveCallback);
                } else {
                  this.autosaveEnable();
                }
              }
              if (this.options.hasOwnProperty("throttledSaves")) {
                this.throttledSaves = this.options.throttledSaves;
              }
            }
            if (!this.options.hasOwnProperty("serializationMethod")) {
              this.options.serializationMethod = "normal";
            }
            if (!this.options.hasOwnProperty("destructureDelimiter")) {
              this.options.destructureDelimiter = "$<\n";
            }
            if (this.persistenceAdapter === null) {
              this.persistenceMethod = defaultPersistence[this.ENV];
              if (this.persistenceMethod) {
                this.persistenceAdapter = new persistenceMethods[this.persistenceMethod]();
              }
            }
          };
          Loki.prototype.copy = function(options) {
            var databaseCopy = new Loki(this.filename, { env: "NA" });
            var clen, idx;
            options = options || {};
            databaseCopy.loadJSONObject(this, { retainDirtyFlags: true });
            if (options.hasOwnProperty("removeNonSerializable") && options.removeNonSerializable === true) {
              databaseCopy.autosaveHandle = null;
              databaseCopy.persistenceAdapter = null;
              clen = databaseCopy.collections.length;
              for (idx = 0; idx < clen; idx++) {
                databaseCopy.collections[idx].constraints = null;
                databaseCopy.collections[idx].ttl = null;
              }
            }
            return databaseCopy;
          };
          Loki.prototype.addCollection = function(name2, options) {
            var i, len = this.collections.length;
            if (options && options.disableMeta === true) {
              if (options.disableChangesApi === false) {
                throw new Error("disableMeta option cannot be passed as true when disableChangesApi is passed as false");
              }
              if (options.disableDeltaChangesApi === false) {
                throw new Error("disableMeta option cannot be passed as true when disableDeltaChangesApi is passed as false");
              }
              if (typeof options.ttl === "number" && options.ttl > 0) {
                throw new Error("disableMeta option cannot be passed as true when ttl is enabled");
              }
            }
            for (i = 0; i < len; i += 1) {
              if (this.collections[i].name === name2) {
                return this.collections[i];
              }
            }
            var collection = new Collection(name2, options);
            collection.isIncremental = this.isIncremental;
            this.collections.push(collection);
            if (this.verbose)
              collection.lokiConsoleWrapper = console;
            return collection;
          };
          Loki.prototype.loadCollection = function(collection) {
            if (!collection.name) {
              throw new Error("Collection must have a name property to be loaded");
            }
            this.collections.push(collection);
          };
          Loki.prototype.getCollection = function(collectionName) {
            var i, len = this.collections.length;
            for (i = 0; i < len; i += 1) {
              if (this.collections[i].name === collectionName) {
                return this.collections[i];
              }
            }
            this.emit("warning", "collection " + collectionName + " not found");
            return null;
          };
          Loki.prototype.renameCollection = function(oldName, newName) {
            var c2 = this.getCollection(oldName);
            if (c2) {
              c2.name = newName;
            }
            return c2;
          };
          Loki.prototype.listCollections = function() {
            var i = this.collections.length, colls = [];
            while (i--) {
              colls.push({
                name: this.collections[i].name,
                type: this.collections[i].objType,
                count: this.collections[i].data.length
              });
            }
            return colls;
          };
          Loki.prototype.removeCollection = function(collectionName) {
            var i, len = this.collections.length;
            for (i = 0; i < len; i += 1) {
              if (this.collections[i].name === collectionName) {
                var tmpcol = new Collection(collectionName, {});
                var curcol = this.collections[i];
                for (var prop in curcol) {
                  if (curcol.hasOwnProperty(prop) && tmpcol.hasOwnProperty(prop)) {
                    curcol[prop] = tmpcol[prop];
                  }
                }
                this.collections.splice(i, 1);
                return;
              }
            }
          };
          Loki.prototype.getName = function() {
            return this.name;
          };
          Loki.prototype.serializeReplacer = function(key, value) {
            switch (key) {
              case "autosaveHandle":
              case "persistenceAdapter":
              case "constraints":
              case "ttl":
                return null;
              case "throttledSavePending":
              case "throttledCallbacks":
                return void 0;
              case "lokiConsoleWrapper":
                return null;
              default:
                return value;
            }
          };
          Loki.prototype.serialize = function(options) {
            options = options || {};
            if (!options.hasOwnProperty("serializationMethod")) {
              options.serializationMethod = this.options.serializationMethod;
            }
            switch (options.serializationMethod) {
              case "normal":
                return JSON.stringify(this, this.serializeReplacer);
              case "pretty":
                return JSON.stringify(this, this.serializeReplacer, 2);
              case "destructured":
                return this.serializeDestructured();
              default:
                return JSON.stringify(this, this.serializeReplacer);
            }
          };
          Loki.prototype.toJson = Loki.prototype.serialize;
          Loki.prototype.serializeDestructured = function(options) {
            var idx, sidx, result, resultlen;
            var reconstruct = [];
            var dbcopy;
            options = options || {};
            if (!options.hasOwnProperty("partitioned")) {
              options.partitioned = false;
            }
            if (!options.hasOwnProperty("delimited")) {
              options.delimited = true;
            }
            if (!options.hasOwnProperty("delimiter")) {
              options.delimiter = this.options.destructureDelimiter;
            }
            if (options.partitioned === true && options.hasOwnProperty("partition") && options.partition >= 0) {
              return this.serializeCollection({
                delimited: options.delimited,
                delimiter: options.delimiter,
                collectionIndex: options.partition
              });
            }
            dbcopy = new Loki(this.filename);
            dbcopy.loadJSONObject(this);
            for (idx = 0; idx < dbcopy.collections.length; idx++) {
              dbcopy.collections[idx].data = [];
            }
            if (options.partitioned === true && options.partition === -1) {
              return dbcopy.serialize({
                serializationMethod: "normal"
              });
            }
            reconstruct.push(dbcopy.serialize({
              serializationMethod: "normal"
            }));
            dbcopy = null;
            for (idx = 0; idx < this.collections.length; idx++) {
              result = this.serializeCollection({
                delimited: options.delimited,
                delimiter: options.delimiter,
                collectionIndex: idx
              });
              if (options.partitioned === false && options.delimited === false) {
                if (!Array.isArray(result)) {
                  throw new Error("a nondelimited, non partitioned collection serialization did not return an expected array");
                }
                resultlen = result.length;
                for (sidx = 0; sidx < resultlen; sidx++) {
                  reconstruct.push(result[sidx]);
                  result[sidx] = null;
                }
                reconstruct.push("");
              } else {
                reconstruct.push(result);
              }
            }
            if (options.partitioned) {
              if (options.delimited) {
                return reconstruct;
              } else {
                return reconstruct;
              }
            } else {
              if (options.delimited) {
                reconstruct.push("");
                return reconstruct.join(options.delimiter);
              } else {
                reconstruct.push("");
                return reconstruct;
              }
            }
            reconstruct.push("");
            return reconstruct.join(delim);
          };
          Loki.prototype.serializeCollection = function(options) {
            var doccount, docidx, resultlines = [];
            options = options || {};
            if (!options.hasOwnProperty("delimited")) {
              options.delimited = true;
            }
            if (!options.hasOwnProperty("collectionIndex")) {
              throw new Error("serializeCollection called without 'collectionIndex' option");
            }
            doccount = this.collections[options.collectionIndex].data.length;
            resultlines = [];
            for (docidx = 0; docidx < doccount; docidx++) {
              resultlines.push(JSON.stringify(this.collections[options.collectionIndex].data[docidx]));
            }
            if (options.delimited) {
              resultlines.push("");
              return resultlines.join(options.delimiter);
            } else {
              return resultlines;
            }
          };
          Loki.prototype.deserializeDestructured = function(destructuredSource, options) {
            var workarray = [];
            var len, cdb;
            var idx, collIndex = 0, collCount, lineIndex = 1, done = false;
            var currLine, currObject;
            options = options || {};
            if (!options.hasOwnProperty("partitioned")) {
              options.partitioned = false;
            }
            if (!options.hasOwnProperty("delimited")) {
              options.delimited = true;
            }
            if (!options.hasOwnProperty("delimiter")) {
              options.delimiter = this.options.destructureDelimiter;
            }
            if (options.partitioned) {
              if (options.hasOwnProperty("partition")) {
                if (options.partition === -1) {
                  cdb = JSON.parse(destructuredSource[0]);
                  return cdb;
                }
                return this.deserializeCollection(destructuredSource[options.partition + 1], options);
              }
              cdb = JSON.parse(destructuredSource[0]);
              collCount = cdb.collections.length;
              for (collIndex = 0; collIndex < collCount; collIndex++) {
                cdb.collections[collIndex].data = this.deserializeCollection(destructuredSource[collIndex + 1], options);
              }
              return cdb;
            }
            if (options.delimited) {
              workarray = destructuredSource.split(options.delimiter);
              destructuredSource = null;
              len = workarray.length;
              if (len === 0) {
                return null;
              }
            } else {
              workarray = destructuredSource;
            }
            cdb = JSON.parse(workarray[0]);
            collCount = cdb.collections.length;
            workarray[0] = null;
            while (!done) {
              currLine = workarray[lineIndex];
              if (workarray[lineIndex] === "") {
                if (++collIndex > collCount) {
                  done = true;
                }
              } else {
                currObject = JSON.parse(workarray[lineIndex]);
                cdb.collections[collIndex].data.push(currObject);
              }
              workarray[lineIndex++] = null;
            }
            return cdb;
          };
          Loki.prototype.deserializeCollection = function(destructuredSource, options) {
            var workarray = [];
            var idx, len;
            options = options || {};
            if (!options.hasOwnProperty("partitioned")) {
              options.partitioned = false;
            }
            if (!options.hasOwnProperty("delimited")) {
              options.delimited = true;
            }
            if (!options.hasOwnProperty("delimiter")) {
              options.delimiter = this.options.destructureDelimiter;
            }
            if (options.delimited) {
              workarray = destructuredSource.split(options.delimiter);
              workarray.pop();
            } else {
              workarray = destructuredSource;
            }
            len = workarray.length;
            for (idx = 0; idx < len; idx++) {
              workarray[idx] = JSON.parse(workarray[idx]);
            }
            return workarray;
          };
          Loki.prototype.loadJSON = function(serializedDb, options) {
            var dbObject;
            if (serializedDb.length === 0) {
              dbObject = {};
            } else {
              switch (this.options.serializationMethod) {
                case "normal":
                case "pretty":
                  dbObject = JSON.parse(serializedDb);
                  break;
                case "destructured":
                  dbObject = this.deserializeDestructured(serializedDb);
                  break;
                default:
                  dbObject = JSON.parse(serializedDb);
                  break;
              }
            }
            this.loadJSONObject(dbObject, options);
          };
          Loki.prototype.loadJSONObject = function(dbObject, options) {
            var i = 0, len = dbObject.collections ? dbObject.collections.length : 0, coll, copyColl, clen, j, loader, collObj;
            this.name = dbObject.name;
            if (dbObject.hasOwnProperty("throttledSaves") && options && !options.hasOwnProperty("throttledSaves")) {
              this.throttledSaves = dbObject.throttledSaves;
            }
            this.collections = [];
            function makeLoader(coll2) {
              var collOptions = options[coll2.name];
              var inflater;
              if (collOptions.proto) {
                inflater = collOptions.inflate || Utils.copyProperties;
                return function(data2) {
                  var collObj2 = new collOptions.proto();
                  inflater(data2, collObj2);
                  return collObj2;
                };
              }
              return collOptions.inflate;
            }
            for (i; i < len; i += 1) {
              coll = dbObject.collections[i];
              copyColl = this.addCollection(coll.name, {
                disableChangesApi: coll.disableChangesApi,
                disableDeltaChangesApi: coll.disableDeltaChangesApi,
                disableMeta: coll.disableMeta,
                disableFreeze: coll.hasOwnProperty("disableFreeze") ? coll.disableFreeze : true
              });
              copyColl.adaptiveBinaryIndices = coll.hasOwnProperty("adaptiveBinaryIndices") ? coll.adaptiveBinaryIndices === true : false;
              copyColl.transactional = coll.transactional;
              copyColl.asyncListeners = coll.asyncListeners;
              copyColl.cloneObjects = coll.cloneObjects;
              copyColl.cloneMethod = coll.cloneMethod || "parse-stringify";
              copyColl.autoupdate = coll.autoupdate;
              copyColl.changes = coll.changes;
              copyColl.dirtyIds = coll.dirtyIds || [];
              if (options && options.retainDirtyFlags === true) {
                copyColl.dirty = coll.dirty;
              } else {
                copyColl.dirty = false;
              }
              clen = coll.data.length;
              j = 0;
              if (options && options.hasOwnProperty(coll.name)) {
                loader = makeLoader(coll);
                for (j; j < clen; j++) {
                  collObj = loader(coll.data[j]);
                  copyColl.data[j] = collObj;
                  copyColl.addAutoUpdateObserver(collObj);
                  if (!copyColl.disableFreeze) {
                    deepFreeze(copyColl.data[j]);
                  }
                }
              } else {
                for (j; j < clen; j++) {
                  copyColl.data[j] = coll.data[j];
                  copyColl.addAutoUpdateObserver(copyColl.data[j]);
                  if (!copyColl.disableFreeze) {
                    deepFreeze(copyColl.data[j]);
                  }
                }
              }
              copyColl.maxId = typeof coll.maxId === "undefined" ? 0 : coll.maxId;
              if (typeof coll.binaryIndices !== "undefined") {
                copyColl.binaryIndices = coll.binaryIndices;
              }
              if (typeof coll.transforms !== "undefined") {
                copyColl.transforms = coll.transforms;
              }
              copyColl.uniqueNames = [];
              if (coll.hasOwnProperty("uniqueNames")) {
                copyColl.uniqueNames = coll.uniqueNames;
              }
              if (typeof coll.DynamicViews === "undefined")
                continue;
              for (var idx = 0; idx < coll.DynamicViews.length; idx++) {
                var colldv = coll.DynamicViews[idx];
                var dv = copyColl.addDynamicView(colldv.name, colldv.options);
                dv.resultdata = colldv.resultdata;
                dv.resultsdirty = colldv.resultsdirty;
                dv.filterPipeline = colldv.filterPipeline;
                dv.sortCriteriaSimple = colldv.sortCriteriaSimple;
                dv.sortCriteria = colldv.sortCriteria;
                dv.sortFunction = null;
                dv.sortDirty = colldv.sortDirty;
                if (!copyColl.disableFreeze) {
                  deepFreeze(dv.filterPipeline);
                  if (dv.sortCriteriaSimple) {
                    deepFreeze(dv.sortCriteriaSimple);
                  } else if (dv.sortCriteria) {
                    deepFreeze(dv.sortCriteria);
                  }
                }
                dv.resultset.filteredrows = colldv.resultset.filteredrows;
                dv.resultset.filterInitialized = colldv.resultset.filterInitialized;
                dv.rematerialize({
                  removeWhereFilters: true
                });
              }
              if (dbObject.databaseVersion < 1.5) {
                copyColl.ensureAllIndexes(true);
                copyColl.dirty = true;
              }
            }
          };
          Loki.prototype.close = function(callback) {
            if (this.autosave) {
              this.autosaveDisable();
              if (this.autosaveDirty()) {
                this.saveDatabase(callback);
                callback = void 0;
              }
            }
            if (callback) {
              this.on("close", callback);
            }
            this.emit("close");
          };
          Loki.prototype.generateChangesNotification = function(arrayOfCollectionNames) {
            function getCollName(coll) {
              return coll.name;
            }
            var changes = [], selectedCollections = arrayOfCollectionNames || this.collections.map(getCollName);
            this.collections.forEach(function(coll) {
              if (selectedCollections.indexOf(getCollName(coll)) !== -1) {
                changes = changes.concat(coll.getChanges());
              }
            });
            return changes;
          };
          Loki.prototype.serializeChanges = function(collectionNamesArray) {
            return JSON.stringify(this.generateChangesNotification(collectionNamesArray));
          };
          Loki.prototype.clearChanges = function() {
            this.collections.forEach(function(coll) {
              if (coll.flushChanges) {
                coll.flushChanges();
              }
            });
          };
          function LokiMemoryAdapter(options) {
            this.hashStore = {};
            this.options = options || {};
            if (!this.options.hasOwnProperty("asyncResponses")) {
              this.options.asyncResponses = false;
            }
            if (!this.options.hasOwnProperty("asyncTimeout")) {
              this.options.asyncTimeout = 50;
            }
          }
          LokiMemoryAdapter.prototype.loadDatabase = function(dbname, callback) {
            var self2 = this;
            if (this.options.asyncResponses) {
              setTimeout(function() {
                if (self2.hashStore.hasOwnProperty(dbname)) {
                  callback(self2.hashStore[dbname].value);
                } else {
                  callback(null);
                }
              }, this.options.asyncTimeout);
            } else {
              if (this.hashStore.hasOwnProperty(dbname)) {
                callback(this.hashStore[dbname].value);
              } else {
                callback(null);
              }
            }
          };
          LokiMemoryAdapter.prototype.saveDatabase = function(dbname, dbstring, callback) {
            var self2 = this;
            var saveCount;
            if (this.options.asyncResponses) {
              setTimeout(function() {
                saveCount = self2.hashStore.hasOwnProperty(dbname) ? self2.hashStore[dbname].savecount : 0;
                self2.hashStore[dbname] = {
                  savecount: saveCount + 1,
                  lastsave: new Date(),
                  value: dbstring
                };
                callback();
              }, this.options.asyncTimeout);
            } else {
              saveCount = this.hashStore.hasOwnProperty(dbname) ? this.hashStore[dbname].savecount : 0;
              this.hashStore[dbname] = {
                savecount: saveCount + 1,
                lastsave: new Date(),
                value: dbstring
              };
              callback();
            }
          };
          LokiMemoryAdapter.prototype.deleteDatabase = function(dbname, callback) {
            if (this.hashStore.hasOwnProperty(dbname)) {
              delete this.hashStore[dbname];
            }
            if (typeof callback === "function") {
              callback();
            }
          };
          function LokiPartitioningAdapter(adapter, options) {
            this.mode = "reference";
            this.adapter = null;
            this.options = options || {};
            this.dbref = null;
            this.dbname = "";
            this.pageIterator = {};
            if (adapter) {
              if (adapter.mode === "reference") {
                throw new Error("LokiPartitioningAdapter cannot be instantiated with a reference mode adapter");
              } else {
                this.adapter = adapter;
              }
            } else {
              throw new Error("LokiPartitioningAdapter requires a (non-reference mode) adapter on construction");
            }
            if (!this.options.hasOwnProperty("paging")) {
              this.options.paging = false;
            }
            if (!this.options.hasOwnProperty("pageSize")) {
              this.options.pageSize = 25 * 1024 * 1024;
            }
            if (!this.options.hasOwnProperty("delimiter")) {
              this.options.delimiter = "$<\n";
            }
          }
          LokiPartitioningAdapter.prototype.loadDatabase = function(dbname, callback) {
            var self2 = this;
            this.dbname = dbname;
            this.dbref = new Loki(dbname);
            this.adapter.loadDatabase(dbname, function(result) {
              if (!result) {
                callback(result);
                return;
              }
              if (typeof result !== "string") {
                callback(new Error("LokiPartitioningAdapter received an unexpected response from inner adapter loadDatabase()"));
              }
              var db = JSON.parse(result);
              self2.dbref.loadJSONObject(db);
              db = null;
              var clen = self2.dbref.collections.length;
              if (self2.dbref.collections.length === 0) {
                callback(self2.dbref);
                return;
              }
              self2.pageIterator = {
                collection: 0,
                pageIndex: 0
              };
              self2.loadNextPartition(0, function() {
                callback(self2.dbref);
              });
            });
          };
          LokiPartitioningAdapter.prototype.loadNextPartition = function(partition, callback) {
            var keyname = this.dbname + "." + partition;
            var self2 = this;
            if (this.options.paging === true) {
              this.pageIterator.pageIndex = 0;
              this.loadNextPage(callback);
              return;
            }
            this.adapter.loadDatabase(keyname, function(result) {
              var data2 = self2.dbref.deserializeCollection(result, { delimited: true, collectionIndex: partition });
              self2.dbref.collections[partition].data = data2;
              if (++partition < self2.dbref.collections.length) {
                self2.loadNextPartition(partition, callback);
              } else {
                callback();
              }
            });
          };
          LokiPartitioningAdapter.prototype.loadNextPage = function(callback) {
            var keyname = this.dbname + "." + this.pageIterator.collection + "." + this.pageIterator.pageIndex;
            var self2 = this;
            this.adapter.loadDatabase(keyname, function(result) {
              var data2 = result.split(self2.options.delimiter);
              result = "";
              var dlen = data2.length;
              var idx;
              var isLastPage = data2[dlen - 1] === "";
              if (isLastPage) {
                data2.pop();
                dlen = data2.length;
                if (data2[dlen - 1] === "" && dlen === 1) {
                  data2.pop();
                  dlen = data2.length;
                }
              }
              for (idx = 0; idx < dlen; idx++) {
                self2.dbref.collections[self2.pageIterator.collection].data.push(JSON.parse(data2[idx]));
                data2[idx] = null;
              }
              data2 = [];
              if (isLastPage) {
                if (++self2.pageIterator.collection < self2.dbref.collections.length) {
                  self2.loadNextPartition(self2.pageIterator.collection, callback);
                } else {
                  callback();
                }
              } else {
                self2.pageIterator.pageIndex++;
                self2.loadNextPage(callback);
              }
            });
          };
          LokiPartitioningAdapter.prototype.exportDatabase = function(dbname, dbref, callback) {
            var self2 = this;
            var idx, clen = dbref.collections.length;
            this.dbref = dbref;
            this.dbname = dbname;
            this.dirtyPartitions = [-1];
            for (idx = 0; idx < clen; idx++) {
              if (dbref.collections[idx].dirty) {
                this.dirtyPartitions.push(idx);
              }
            }
            this.saveNextPartition(function(err) {
              callback(err);
            });
          };
          LokiPartitioningAdapter.prototype.saveNextPartition = function(callback) {
            var self2 = this;
            var partition = this.dirtyPartitions.shift();
            var keyname = this.dbname + (partition === -1 ? "" : "." + partition);
            if (this.options.paging && partition !== -1) {
              this.pageIterator = {
                collection: partition,
                docIndex: 0,
                pageIndex: 0
              };
              this.saveNextPage(function(err) {
                if (self2.dirtyPartitions.length === 0) {
                  callback(err);
                } else {
                  self2.saveNextPartition(callback);
                }
              });
              return;
            }
            var result = this.dbref.serializeDestructured({
              partitioned: true,
              delimited: true,
              partition
            });
            this.adapter.saveDatabase(keyname, result, function(err) {
              if (err) {
                callback(err);
                return;
              }
              if (self2.dirtyPartitions.length === 0) {
                callback(null);
              } else {
                self2.saveNextPartition(callback);
              }
            });
          };
          LokiPartitioningAdapter.prototype.saveNextPage = function(callback) {
            var self2 = this;
            var coll = this.dbref.collections[this.pageIterator.collection];
            var keyname = this.dbname + "." + this.pageIterator.collection + "." + this.pageIterator.pageIndex;
            var pageLen = 0, cdlen = coll.data.length, delimlen = this.options.delimiter.length;
            var serializedObject = "", pageBuilder = "";
            var doneWithPartition = false, doneWithPage = false;
            var pageSaveCallback = function(err) {
              pageBuilder = "";
              if (err) {
                callback(err);
              }
              if (doneWithPartition) {
                callback(null);
              } else {
                self2.pageIterator.pageIndex++;
                self2.saveNextPage(callback);
              }
            };
            if (coll.data.length === 0) {
              doneWithPartition = true;
            }
            while (true) {
              if (!doneWithPartition) {
                serializedObject = JSON.stringify(coll.data[this.pageIterator.docIndex]);
                pageBuilder += serializedObject;
                pageLen += serializedObject.length;
                if (++this.pageIterator.docIndex >= cdlen)
                  doneWithPartition = true;
              }
              if (pageLen >= this.options.pageSize)
                doneWithPage = true;
              if (!doneWithPage || doneWithPartition) {
                pageBuilder += this.options.delimiter;
                pageLen += delimlen;
              }
              if (doneWithPartition || doneWithPage) {
                this.adapter.saveDatabase(keyname, pageBuilder, pageSaveCallback);
                return;
              }
            }
          };
          function LokiFsAdapter() {
            try {
              this.fs = __require("fs");
            } catch (e) {
              this.fs = null;
            }
          }
          LokiFsAdapter.prototype.loadDatabase = function loadDatabase(dbname, callback) {
            var self2 = this;
            this.fs.stat(dbname, function(err, stats) {
              if (!err && stats.isFile()) {
                self2.fs.readFile(dbname, {
                  encoding: "utf8"
                }, function readFileCallback(err2, data2) {
                  if (err2) {
                    callback(new Error(err2));
                  } else {
                    callback(data2);
                  }
                });
              } else {
                callback(null);
              }
            });
          };
          LokiFsAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring, callback) {
            var self2 = this;
            var tmpdbname = dbname + "~";
            this.fs.writeFile(tmpdbname, dbstring, function writeFileCallback(err) {
              if (err) {
                callback(new Error(err));
              } else {
                self2.fs.rename(tmpdbname, dbname, callback);
              }
            });
          };
          LokiFsAdapter.prototype.deleteDatabase = function deleteDatabase(dbname, callback) {
            this.fs.unlink(dbname, function deleteDatabaseCallback(err) {
              if (err) {
                callback(new Error(err));
              } else {
                callback();
              }
            });
          };
          function LokiLocalStorageAdapter() {
          }
          LokiLocalStorageAdapter.prototype.loadDatabase = function loadDatabase(dbname, callback) {
            if (localStorageAvailable()) {
              callback(localStorage.getItem(dbname));
            } else {
              callback(new Error("localStorage is not available"));
            }
          };
          LokiLocalStorageAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring, callback) {
            if (localStorageAvailable()) {
              localStorage.setItem(dbname, dbstring);
              callback(null);
            } else {
              callback(new Error("localStorage is not available"));
            }
          };
          LokiLocalStorageAdapter.prototype.deleteDatabase = function deleteDatabase(dbname, callback) {
            if (localStorageAvailable()) {
              localStorage.removeItem(dbname);
              callback(null);
            } else {
              callback(new Error("localStorage is not available"));
            }
          };
          Loki.prototype.throttledSaveDrain = function(callback, options) {
            var self2 = this;
            var now3 = new Date().getTime();
            if (!this.throttledSaves) {
              callback(true);
            }
            options = options || {};
            if (!options.hasOwnProperty("recursiveWait")) {
              options.recursiveWait = true;
            }
            if (!options.hasOwnProperty("recursiveWaitLimit")) {
              options.recursiveWaitLimit = false;
            }
            if (!options.hasOwnProperty("recursiveWaitLimitDuration")) {
              options.recursiveWaitLimitDuration = 2e3;
            }
            if (!options.hasOwnProperty("started")) {
              options.started = new Date().getTime();
            }
            if (this.throttledSaves && this.throttledSavePending) {
              if (options.recursiveWait) {
                this.throttledCallbacks.push(function() {
                  if (self2.throttledSavePending) {
                    if (options.recursiveWaitLimit && now3 - options.started > options.recursiveWaitLimitDuration) {
                      callback(false);
                      return;
                    }
                    self2.throttledSaveDrain(callback, options);
                    return;
                  } else {
                    callback(true);
                    return;
                  }
                });
              } else {
                this.throttledCallbacks.push(callback);
                return;
              }
            } else {
              callback(true);
            }
          };
          Loki.prototype.loadDatabaseInternal = function(options, callback) {
            var cFun = callback || function(err, data2) {
              if (err) {
                throw err;
              }
            }, self2 = this;
            if (this.persistenceAdapter !== null) {
              this.persistenceAdapter.loadDatabase(this.filename, function loadDatabaseCallback(dbString) {
                if (typeof dbString === "string") {
                  var parseSuccess = false;
                  try {
                    self2.loadJSON(dbString, options || {});
                    parseSuccess = true;
                  } catch (err) {
                    cFun(err);
                  }
                  if (parseSuccess) {
                    cFun(null);
                    self2.emit("loaded", "database " + self2.filename + " loaded");
                  }
                } else {
                  if (!dbString) {
                    cFun(null);
                    self2.emit("loaded", "empty database " + self2.filename + " loaded");
                    return;
                  }
                  if (dbString instanceof Error) {
                    cFun(dbString);
                    return;
                  }
                  if (typeof dbString === "object") {
                    self2.loadJSONObject(dbString, options || {});
                    cFun(null);
                    self2.emit("loaded", "database " + self2.filename + " loaded");
                    return;
                  }
                  cFun("unexpected adapter response : " + dbString);
                }
              });
            } else {
              cFun(new Error("persistenceAdapter not configured"));
            }
          };
          Loki.prototype.loadDatabase = function(options, callback) {
            var self2 = this;
            if (!this.throttledSaves) {
              this.loadDatabaseInternal(options, callback);
              return;
            }
            this.throttledSaveDrain(function(success) {
              if (success) {
                self2.throttledSavePending = true;
                self2.loadDatabaseInternal(options, function(err) {
                  if (self2.throttledCallbacks.length === 0) {
                    self2.throttledSavePending = false;
                  } else {
                    self2.saveDatabase();
                  }
                  if (typeof callback === "function") {
                    callback(err);
                  }
                });
                return;
              } else {
                if (typeof callback === "function") {
                  callback(new Error("Unable to pause save throttling long enough to read database"));
                }
              }
            }, options);
          };
          Loki.prototype.saveDatabaseInternal = function(callback) {
            var cFun = callback || function(err) {
              if (err) {
                throw err;
              }
              return;
            };
            var self2 = this;
            if (!this.persistenceAdapter) {
              cFun(new Error("persistenceAdapter not configured"));
              return;
            }
            if (this.persistenceAdapter.mode === "incremental") {
              var cachedDirty;
              this.ignoreAutosave = true;
              this.persistenceAdapter.saveDatabase(
                this.filename,
                function getLokiCopy() {
                  self2.ignoreAutosave = false;
                  if (cachedDirty) {
                    cFun(new Error("adapter error - getLokiCopy called more than once"));
                    return;
                  }
                  var lokiCopy = self2.copy({ removeNonSerializable: true });
                  cachedDirty = self2.collections.map(function(collection) {
                    return [collection.dirty, collection.dirtyIds];
                  });
                  self2.collections.forEach(function(col) {
                    col.dirty = false;
                    col.dirtyIds = [];
                  });
                  return lokiCopy;
                },
                function exportDatabaseCallback(err) {
                  self2.ignoreAutosave = false;
                  if (err && cachedDirty) {
                    self2.collections.forEach(function(col, i) {
                      var cached = cachedDirty[i];
                      col.dirty = col.dirty || cached[0];
                      col.dirtyIds = col.dirtyIds.concat(cached[1]);
                    });
                  }
                  cFun(err);
                }
              );
            } else if (this.persistenceAdapter.mode === "reference" && typeof this.persistenceAdapter.exportDatabase === "function") {
              this.persistenceAdapter.exportDatabase(this.filename, this.copy({ removeNonSerializable: true }), function exportDatabaseCallback(err) {
                self2.autosaveClearFlags();
                cFun(err);
              });
            } else {
              this.autosaveClearFlags();
              this.persistenceAdapter.saveDatabase(this.filename, this.serialize(), function saveDatabasecallback(err) {
                cFun(err);
              });
            }
          };
          Loki.prototype.saveDatabase = function(callback) {
            if (!this.throttledSaves) {
              this.saveDatabaseInternal(callback);
              return;
            }
            if (this.throttledSavePending) {
              this.throttledCallbacks.push(callback);
              return;
            }
            var localCallbacks = this.throttledCallbacks;
            this.throttledCallbacks = [];
            localCallbacks.unshift(callback);
            this.throttledSavePending = true;
            var self2 = this;
            this.saveDatabaseInternal(function(err) {
              self2.throttledSavePending = false;
              localCallbacks.forEach(function(pcb) {
                if (typeof pcb === "function") {
                  setTimeout(function() {
                    pcb(err);
                  }, 1);
                }
              });
              if (self2.throttledCallbacks.length > 0) {
                self2.saveDatabase();
              }
            });
          };
          Loki.prototype.save = Loki.prototype.saveDatabase;
          Loki.prototype.deleteDatabase = function(options, callback) {
            var cFun = callback || function(err, data2) {
              if (err) {
                throw err;
              }
            };
            if (typeof options === "function" && !callback) {
              cFun = options;
            }
            if (this.persistenceAdapter !== null) {
              this.persistenceAdapter.deleteDatabase(this.filename, function deleteDatabaseCallback(err) {
                cFun(err);
              });
            } else {
              cFun(new Error("persistenceAdapter not configured"));
            }
          };
          Loki.prototype.autosaveDirty = function() {
            for (var idx = 0; idx < this.collections.length; idx++) {
              if (this.collections[idx].dirty) {
                return true;
              }
            }
            return false;
          };
          Loki.prototype.autosaveClearFlags = function() {
            for (var idx = 0; idx < this.collections.length; idx++) {
              this.collections[idx].dirty = false;
            }
          };
          Loki.prototype.autosaveEnable = function(options, callback) {
            this.autosave = true;
            var delay = 5e3, self2 = this;
            if (typeof this.autosaveInterval !== "undefined" && this.autosaveInterval !== null) {
              delay = this.autosaveInterval;
            }
            this.autosaveHandle = setInterval(function autosaveHandleInterval() {
              if (self2.autosaveDirty() && !self2.ignoreAutosave) {
                self2.saveDatabase(callback);
              }
            }, delay);
          };
          Loki.prototype.autosaveDisable = function() {
            if (typeof this.autosaveHandle !== "undefined" && this.autosaveHandle !== null) {
              clearInterval(this.autosaveHandle);
              this.autosaveHandle = null;
            }
          };
          function Resultset(collection, options) {
            options = options || {};
            this.collection = collection;
            this.filteredrows = [];
            this.filterInitialized = false;
            return this;
          }
          Resultset.prototype.reset = function() {
            if (this.filteredrows.length > 0) {
              this.filteredrows = [];
            }
            this.filterInitialized = false;
            return this;
          };
          Resultset.prototype.toJSON = function() {
            var copy2 = this.copy();
            copy2.collection = null;
            return copy2;
          };
          Resultset.prototype.limit = function(qty) {
            if (!this.filterInitialized && this.filteredrows.length === 0) {
              this.filteredrows = this.collection.prepareFullDocIndex();
            }
            var rscopy = new Resultset(this.collection);
            rscopy.filteredrows = this.filteredrows.slice(0, qty);
            rscopy.filterInitialized = true;
            return rscopy;
          };
          Resultset.prototype.offset = function(pos) {
            if (!this.filterInitialized && this.filteredrows.length === 0) {
              this.filteredrows = this.collection.prepareFullDocIndex();
            }
            var rscopy = new Resultset(this.collection);
            rscopy.filteredrows = this.filteredrows.slice(pos);
            rscopy.filterInitialized = true;
            return rscopy;
          };
          Resultset.prototype.copy = function() {
            var result = new Resultset(this.collection);
            if (this.filteredrows.length > 0) {
              result.filteredrows = this.filteredrows.slice();
            }
            result.filterInitialized = this.filterInitialized;
            return result;
          };
          Resultset.prototype.branch = Resultset.prototype.copy;
          Resultset.prototype.transform = function(transform, parameters) {
            var idx, step, rs = this;
            if (typeof transform === "string") {
              if (this.collection.transforms.hasOwnProperty(transform)) {
                transform = this.collection.transforms[transform];
              }
            }
            if (typeof transform !== "object" || !Array.isArray(transform)) {
              throw new Error("Invalid transform");
            }
            if (typeof parameters !== "undefined") {
              transform = Utils.resolveTransformParams(transform, parameters);
            }
            for (idx = 0; idx < transform.length; idx++) {
              step = transform[idx];
              switch (step.type) {
                case "find":
                  rs.find(step.value);
                  break;
                case "where":
                  rs.where(step.value);
                  break;
                case "simplesort":
                  rs.simplesort(step.property, step.desc || step.options);
                  break;
                case "compoundsort":
                  rs.compoundsort(step.value);
                  break;
                case "sort":
                  rs.sort(step.value);
                  break;
                case "limit":
                  rs = rs.limit(step.value);
                  break;
                case "offset":
                  rs = rs.offset(step.value);
                  break;
                case "map":
                  rs = rs.map(step.value, step.dataOptions);
                  break;
                case "eqJoin":
                  rs = rs.eqJoin(step.joinData, step.leftJoinKey, step.rightJoinKey, step.mapFun, step.dataOptions);
                  break;
                case "mapReduce":
                  rs = rs.mapReduce(step.mapFunction, step.reduceFunction);
                  break;
                case "update":
                  rs.update(step.value);
                  break;
                case "remove":
                  rs.remove();
                  break;
                default:
                  break;
              }
            }
            return rs;
          };
          Resultset.prototype.sort = function(comparefun) {
            if (!this.filterInitialized && this.filteredrows.length === 0) {
              this.filteredrows = this.collection.prepareFullDocIndex();
            }
            var wrappedComparer = function(userComparer, data2) {
              return function(a2, b) {
                return userComparer(data2[a2], data2[b]);
              };
            }(comparefun, this.collection.data);
            this.filteredrows.sort(wrappedComparer);
            return this;
          };
          Resultset.prototype.simplesort = function(propname, options) {
            var eff, targetEff = 10, dc = this.collection.data.length, frl = this.filteredrows.length, hasBinaryIndex = this.collection.binaryIndices.hasOwnProperty(propname);
            if (typeof options === "undefined" || options === false) {
              options = { desc: false };
            }
            if (options === true) {
              options = { desc: true };
            }
            if (frl === 0) {
              if (this.filterInitialized) {
                return this;
              }
              if (this.collection.binaryIndices.hasOwnProperty(propname)) {
                this.collection.ensureIndex(propname);
                this.filteredrows = this.collection.binaryIndices[propname].values.slice(0);
                if (options.desc) {
                  this.filteredrows.reverse();
                }
                return this;
              } else {
                this.filteredrows = this.collection.prepareFullDocIndex();
              }
            } else {
              if (!options.disableIndexIntersect && hasBinaryIndex) {
                eff = dc / frl;
                if (options.useJavascriptSorting) {
                  targetEff = 6;
                }
                if (eff <= targetEff || options.forceIndexIntersect) {
                  var idx, fr = this.filteredrows;
                  var io = {};
                  for (idx = 0; idx < frl; idx++) {
                    io[fr[idx]] = true;
                  }
                  var pv = this.collection.binaryIndices[propname].values;
                  this.filteredrows = pv.filter(function(n2) {
                    return io[n2];
                  });
                  if (options.desc) {
                    this.filteredrows.reverse();
                  }
                  return this;
                }
              }
            }
            if (options.useJavascriptSorting) {
              return this.sort(function(obj1, obj2) {
                if (obj1[propname] === obj2[propname])
                  return 0;
                if (obj1[propname] > obj2[propname])
                  return 1;
                if (obj1[propname] < obj2[propname])
                  return -1;
              });
            }
            var wrappedComparer = function(prop, desc, data2) {
              var val1, val2, arr;
              return function(a2, b) {
                if (~prop.indexOf(".")) {
                  arr = prop.split(".");
                  val1 = Utils.getIn(data2[a2], arr, true);
                  val2 = Utils.getIn(data2[b], arr, true);
                } else {
                  val1 = data2[a2][prop];
                  val2 = data2[b][prop];
                }
                return sortHelper(val1, val2, desc);
              };
            }(propname, options.desc, this.collection.data);
            this.filteredrows.sort(wrappedComparer);
            return this;
          };
          Resultset.prototype.compoundsort = function(properties2) {
            if (properties2.length === 0) {
              throw new Error("Invalid call to compoundsort, need at least one property");
            }
            var prop;
            if (properties2.length === 1) {
              prop = properties2[0];
              if (Array.isArray(prop)) {
                return this.simplesort(prop[0], prop[1]);
              }
              return this.simplesort(prop, false);
            }
            for (var i = 0, len = properties2.length; i < len; i += 1) {
              prop = properties2[i];
              if (!Array.isArray(prop)) {
                properties2[i] = [prop, false];
              }
            }
            if (!this.filterInitialized && this.filteredrows.length === 0) {
              this.filteredrows = this.collection.prepareFullDocIndex();
            }
            var wrappedComparer = function(props, data2) {
              return function(a2, b) {
                return compoundeval(props, data2[a2], data2[b]);
              };
            }(properties2, this.collection.data);
            this.filteredrows.sort(wrappedComparer);
            return this;
          };
          Resultset.prototype.findOr = function(expressionArray) {
            var fr = null, fri = 0, frlen = 0, docset = [], idxset = [], idx = 0, origCount = this.count();
            for (var ei = 0, elen = expressionArray.length; ei < elen; ei++) {
              fr = this.branch().find(expressionArray[ei]).filteredrows;
              frlen = fr.length;
              for (fri = 0; fri < frlen; fri++) {
                idx = fr[fri];
                if (idxset[idx] === void 0) {
                  idxset[idx] = true;
                  docset.push(idx);
                }
              }
            }
            this.filteredrows = docset;
            this.filterInitialized = true;
            return this;
          };
          Resultset.prototype.$or = Resultset.prototype.findOr;
          function precompileQuery(operator2, value) {
            if (operator2 === "$regex") {
              if (Array.isArray(value)) {
                value = new RegExp(value[0], value[1]);
              } else if (!(value instanceof RegExp)) {
                value = new RegExp(value);
              }
            } else if (typeof value === "object") {
              for (var key in value) {
                if (key === "$regex" || typeof value[key] === "object") {
                  value[key] = precompileQuery(key, value[key]);
                }
              }
            }
            return value;
          }
          Resultset.prototype.findAnd = function(expressionArray) {
            for (var i = 0, len = expressionArray.length; i < len; i++) {
              if (this.count() === 0) {
                return this;
              }
              this.find(expressionArray[i]);
            }
            return this;
          };
          Resultset.prototype.$and = Resultset.prototype.findAnd;
          Resultset.prototype.find = function(query, firstOnly) {
            if (this.collection.data.length === 0) {
              this.filteredrows = [];
              this.filterInitialized = true;
              return this;
            }
            var queryObject = query || "getAll", p, property, queryObjectOp, obj, operator2, value, key, searchByIndex = false, result = [], filters = [], index2 = null;
            firstOnly = firstOnly || false;
            if (typeof queryObject === "object") {
              for (p in queryObject) {
                obj = {};
                obj[p] = queryObject[p];
                filters.push(obj);
                if (hasOwnProperty.call(queryObject, p)) {
                  property = p;
                  queryObjectOp = queryObject[p];
                }
              }
              if (filters.length > 1) {
                return this.find({ "$and": filters }, firstOnly);
              }
            }
            if (!property || queryObject === "getAll") {
              if (firstOnly) {
                if (this.filterInitialized) {
                  this.filteredrows = this.filteredrows.slice(0, 1);
                } else {
                  this.filteredrows = this.collection.data.length > 0 ? [0] : [];
                  this.filterInitialized = true;
                }
              }
              return this;
            }
            if (property === "$and" || property === "$or") {
              this[property](queryObjectOp);
              if (firstOnly && this.filteredrows.length > 1) {
                this.filteredrows = this.filteredrows.slice(0, 1);
              }
              return this;
            }
            if (queryObjectOp === null || (typeof queryObjectOp !== "object" || queryObjectOp instanceof Date)) {
              operator2 = "$eq";
              value = queryObjectOp;
            } else if (typeof queryObjectOp === "object") {
              for (key in queryObjectOp) {
                if (hasOwnProperty.call(queryObjectOp, key)) {
                  operator2 = key;
                  value = queryObjectOp[key];
                  break;
                }
              }
            } else {
              throw new Error("Do not know what you want to do.");
            }
            if (operator2 === "$regex" || typeof value === "object") {
              value = precompileQuery(operator2, value);
            }
            var usingDotNotation = property.indexOf(".") !== -1;
            var doIndexCheck = !this.filterInitialized;
            if (doIndexCheck && this.collection.binaryIndices[property] && indexedOps[operator2]) {
              if (this.collection.adaptiveBinaryIndices !== true) {
                this.collection.ensureIndex(property);
              }
              searchByIndex = true;
              index2 = this.collection.binaryIndices[property];
            }
            if (!searchByIndex && operator2 === "$in" && Array.isArray(value) && typeof Set !== "undefined") {
              value = new Set(value);
              operator2 = "$inSet";
            }
            var fun = LokiOps[operator2];
            var t2 = this.collection.data;
            var i = 0, len = 0;
            var filter, rowIdx = 0, record;
            if (this.filterInitialized) {
              filter = this.filteredrows;
              len = filter.length;
              if (usingDotNotation) {
                property = property.split(".");
                for (i = 0; i < len; i++) {
                  rowIdx = filter[i];
                  record = t2[rowIdx];
                  if (dotSubScan(record, property, fun, value, record)) {
                    result.push(rowIdx);
                    if (firstOnly) {
                      this.filteredrows = result;
                      return this;
                    }
                  }
                }
              } else {
                for (i = 0; i < len; i++) {
                  rowIdx = filter[i];
                  record = t2[rowIdx];
                  if (fun(record[property], value, record)) {
                    result.push(rowIdx);
                    if (firstOnly) {
                      this.filteredrows = result;
                      return this;
                    }
                  }
                }
              }
            } else {
              if (!searchByIndex) {
                len = t2.length;
                if (usingDotNotation) {
                  property = property.split(".");
                  for (i = 0; i < len; i++) {
                    record = t2[i];
                    if (dotSubScan(record, property, fun, value, record)) {
                      result.push(i);
                      if (firstOnly) {
                        this.filteredrows = result;
                        this.filterInitialized = true;
                        return this;
                      }
                    }
                  }
                } else {
                  for (i = 0; i < len; i++) {
                    record = t2[i];
                    if (fun(record[property], value, record)) {
                      result.push(i);
                      if (firstOnly) {
                        this.filteredrows = result;
                        this.filterInitialized = true;
                        return this;
                      }
                    }
                  }
                }
              } else {
                var segm = this.collection.calculateRange(operator2, property, value);
                if (operator2 !== "$in") {
                  for (i = segm[0]; i <= segm[1]; i++) {
                    if (indexedOps[operator2] !== true) {
                      if (indexedOps[operator2](Utils.getIn(t2[index2.values[i]], property, usingDotNotation), value)) {
                        result.push(index2.values[i]);
                        if (firstOnly) {
                          this.filteredrows = result;
                          this.filterInitialized = true;
                          return this;
                        }
                      }
                    } else {
                      result.push(index2.values[i]);
                      if (firstOnly) {
                        this.filteredrows = result;
                        this.filterInitialized = true;
                        return this;
                      }
                    }
                  }
                } else {
                  for (i = 0, len = segm.length; i < len; i++) {
                    result.push(index2.values[segm[i]]);
                    if (firstOnly) {
                      this.filteredrows = result;
                      this.filterInitialized = true;
                      return this;
                    }
                  }
                }
              }
            }
            this.filteredrows = result;
            this.filterInitialized = true;
            return this;
          };
          Resultset.prototype.where = function(fun) {
            var viewFunction, result = [];
            if ("function" === typeof fun) {
              viewFunction = fun;
            } else {
              throw new TypeError("Argument is not a stored view or a function");
            }
            try {
              if (this.filterInitialized) {
                var j = this.filteredrows.length;
                while (j--) {
                  if (viewFunction(this.collection.data[this.filteredrows[j]]) === true) {
                    result.push(this.filteredrows[j]);
                  }
                }
                this.filteredrows = result;
                return this;
              } else {
                var k = this.collection.data.length;
                while (k--) {
                  if (viewFunction(this.collection.data[k]) === true) {
                    result.push(k);
                  }
                }
                this.filteredrows = result;
                this.filterInitialized = true;
                return this;
              }
            } catch (err) {
              throw err;
            }
          };
          Resultset.prototype.count = function() {
            if (this.filterInitialized) {
              return this.filteredrows.length;
            }
            return this.collection.count();
          };
          Resultset.prototype.data = function(options) {
            var result = [], data2 = this.collection.data, obj, len, i, method;
            options = options || {};
            if (options.removeMeta && !options.forceClones) {
              options.forceClones = true;
              options.forceCloneMethod = options.forceCloneMethod || "shallow";
            }
            if (!this.collection.disableDeltaChangesApi && this.collection.disableFreeze) {
              options.forceClones = true;
              options.forceCloneMethod = "parse-stringify";
            }
            if (!this.filterInitialized) {
              if (this.filteredrows.length === 0) {
                if (this.collection.cloneObjects || options.forceClones) {
                  len = data2.length;
                  method = options.forceCloneMethod || this.collection.cloneMethod;
                  for (i = 0; i < len; i++) {
                    obj = clone2(data2[i], method);
                    if (options.removeMeta) {
                      delete obj.$loki;
                      delete obj.meta;
                    }
                    result.push(obj);
                  }
                  return result;
                } else {
                  return data2.slice();
                }
              } else {
                this.filterInitialized = true;
              }
            }
            var fr = this.filteredrows;
            len = fr.length;
            if (this.collection.cloneObjects || options.forceClones) {
              method = options.forceCloneMethod || this.collection.cloneMethod;
              for (i = 0; i < len; i++) {
                obj = clone2(data2[fr[i]], method);
                if (options.removeMeta) {
                  delete obj.$loki;
                  delete obj.meta;
                }
                result.push(obj);
              }
            } else {
              for (i = 0; i < len; i++) {
                result.push(data2[fr[i]]);
              }
            }
            return result;
          };
          Resultset.prototype.update = function(updateFunction) {
            if (typeof updateFunction !== "function") {
              throw new TypeError("Argument is not a function");
            }
            if (!this.filterInitialized && this.filteredrows.length === 0) {
              this.filteredrows = this.collection.prepareFullDocIndex();
            }
            var obj, len = this.filteredrows.length, rcd = this.collection.data;
            for (var idx = 0; idx < len; idx++) {
              if (!this.disableFreeze || this.collection.cloneObjects || !this.collection.disableDeltaChangesApi) {
                obj = clone2(rcd[this.filteredrows[idx]], this.collection.cloneMethod);
                updateFunction(obj);
                this.collection.update(obj);
              } else {
                updateFunction(rcd[this.filteredrows[idx]]);
                this.collection.update(rcd[this.filteredrows[idx]]);
              }
            }
            return this;
          };
          Resultset.prototype.remove = function() {
            if (!this.filterInitialized && this.filteredrows.length === 0) {
              this.filteredrows = this.collection.prepareFullDocIndex();
            }
            this.collection.removeBatchByPositions(this.filteredrows);
            this.filteredrows = [];
            return this;
          };
          Resultset.prototype.mapReduce = function(mapFunction, reduceFunction) {
            try {
              return reduceFunction(this.data().map(mapFunction));
            } catch (err) {
              throw err;
            }
          };
          Resultset.prototype.eqJoin = function(joinData, leftJoinKey, rightJoinKey, mapFun, dataOptions) {
            var leftData = [], leftDataLength, rightData = [], rightDataLength, key, result = [], leftKeyisFunction = typeof leftJoinKey === "function", rightKeyisFunction = typeof rightJoinKey === "function", joinMap = {};
            leftData = this.data(dataOptions);
            leftDataLength = leftData.length;
            if (joinData instanceof Collection) {
              rightData = joinData.chain().data(dataOptions);
            } else if (joinData instanceof Resultset) {
              rightData = joinData.data(dataOptions);
            } else if (Array.isArray(joinData)) {
              rightData = joinData;
            } else {
              throw new TypeError("joinData needs to be an array or result set");
            }
            rightDataLength = rightData.length;
            for (var i = 0; i < rightDataLength; i++) {
              key = rightKeyisFunction ? rightJoinKey(rightData[i]) : rightData[i][rightJoinKey];
              joinMap[key] = rightData[i];
            }
            if (!mapFun) {
              mapFun = function(left, right) {
                return {
                  left,
                  right
                };
              };
            }
            for (var j = 0; j < leftDataLength; j++) {
              key = leftKeyisFunction ? leftJoinKey(leftData[j]) : leftData[j][leftJoinKey];
              result.push(mapFun(leftData[j], joinMap[key] || {}));
            }
            this.collection = new Collection("joinData");
            this.collection.insert(result);
            this.filteredrows = [];
            this.filterInitialized = false;
            return this;
          };
          Resultset.prototype.map = function(mapFun, dataOptions) {
            var data2 = this.data(dataOptions).map(mapFun);
            this.collection = new Collection("mappedData");
            this.collection.insert(data2);
            this.filteredrows = [];
            this.filterInitialized = false;
            return this;
          };
          function DynamicView(collection, name2, options) {
            this.collection = collection;
            this.name = name2;
            this.rebuildPending = false;
            this.options = options || {};
            if (!this.options.hasOwnProperty("persistent")) {
              this.options.persistent = false;
            }
            if (!this.options.hasOwnProperty("sortPriority")) {
              this.options.sortPriority = "passive";
            }
            if (!this.options.hasOwnProperty("minRebuildInterval")) {
              this.options.minRebuildInterval = 1;
            }
            this.resultset = new Resultset(collection);
            this.resultdata = [];
            this.resultsdirty = false;
            this.cachedresultset = null;
            this.filterPipeline = [];
            if (!this.collection.disableFreeze) {
              Object.freeze(this.filterPipeline);
            }
            this.sortFunction = null;
            this.sortCriteria = null;
            this.sortCriteriaSimple = null;
            this.sortDirty = false;
            this.events = {
              "rebuild": [],
              "filter": [],
              "sort": []
            };
          }
          DynamicView.prototype = new LokiEventEmitter();
          DynamicView.prototype.constructor = DynamicView;
          DynamicView.prototype.getSort = function() {
            return this.sortFunction || this.sortCriteria || this.sortCriteriaSimple;
          };
          DynamicView.prototype.rematerialize = function(options) {
            var fpl, fpi, idx;
            options = options || {};
            this.resultdata = [];
            this.resultsdirty = true;
            this.resultset = new Resultset(this.collection);
            if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
              this.sortDirty = true;
            }
            var wasFrozen = Object.isFrozen(this.filterPipeline);
            if (options.hasOwnProperty("removeWhereFilters")) {
              if (wasFrozen) {
                this.filterPipeline = this.filterPipeline.slice();
              }
              fpl = this.filterPipeline.length;
              fpi = fpl;
              while (fpi--) {
                if (this.filterPipeline[fpi].type === "where") {
                  if (fpi !== this.filterPipeline.length - 1) {
                    this.filterPipeline[fpi] = this.filterPipeline[this.filterPipeline.length - 1];
                  }
                  this.filterPipeline.length--;
                }
              }
            }
            var ofp = this.filterPipeline;
            this.filterPipeline = [];
            fpl = ofp.length;
            for (idx = 0; idx < fpl; idx++) {
              this.applyFind(ofp[idx].val, ofp[idx].uid);
            }
            if (wasFrozen) {
              Object.freeze(this.filterPipeline);
            }
            this.data();
            this.emit("rebuild", this);
            return this;
          };
          DynamicView.prototype.branchResultset = function(transform, parameters) {
            var rs = this.resultset.branch();
            if (typeof transform === "undefined") {
              return rs;
            }
            return rs.transform(transform, parameters);
          };
          DynamicView.prototype.toJSON = function() {
            var copy2 = new DynamicView(this.collection, this.name, this.options);
            copy2.resultset = this.resultset;
            copy2.resultdata = [];
            copy2.resultsdirty = true;
            copy2.filterPipeline = this.filterPipeline;
            copy2.sortFunction = this.sortFunction;
            copy2.sortCriteria = this.sortCriteria;
            copy2.sortCriteriaSimple = this.sortCriteriaSimple || null;
            copy2.sortDirty = this.sortDirty;
            copy2.collection = null;
            return copy2;
          };
          DynamicView.prototype.removeFilters = function(options) {
            options = options || {};
            this.rebuildPending = false;
            this.resultset.reset();
            this.resultdata = [];
            this.resultsdirty = true;
            this.cachedresultset = null;
            var wasFrozen = Object.isFrozen(this.filterPipeline);
            var filterChanged = this.filterPipeline.length > 0;
            this.filterPipeline = [];
            if (wasFrozen) {
              Object.freeze(this.filterPipeline);
            }
            this.sortFunction = null;
            this.sortCriteria = null;
            this.sortCriteriaSimple = null;
            this.sortDirty = false;
            if (options.queueSortPhase === true) {
              this.queueSortPhase();
            }
            if (filterChanged) {
              this.emit("filter");
            }
          };
          DynamicView.prototype.applySort = function(comparefun) {
            this.sortFunction = comparefun;
            this.sortCriteria = null;
            this.sortCriteriaSimple = null;
            this.queueSortPhase();
            this.emit("sort");
            return this;
          };
          DynamicView.prototype.applySimpleSort = function(propname, options) {
            this.sortCriteriaSimple = { propname, options: options || false };
            if (!this.collection.disableFreeze) {
              deepFreeze(this.sortCriteriaSimple);
            }
            this.sortCriteria = null;
            this.sortFunction = null;
            this.queueSortPhase();
            this.emit("sort");
            return this;
          };
          DynamicView.prototype.applySortCriteria = function(criteria) {
            this.sortCriteria = criteria;
            if (!this.collection.disableFreeze) {
              deepFreeze(this.sortCriteria);
            }
            this.sortCriteriaSimple = null;
            this.sortFunction = null;
            this.queueSortPhase();
            this.emit("sort");
            return this;
          };
          DynamicView.prototype.startTransaction = function() {
            this.cachedresultset = this.resultset.copy();
            return this;
          };
          DynamicView.prototype.commit = function() {
            this.cachedresultset = null;
            return this;
          };
          DynamicView.prototype.rollback = function() {
            this.resultset = this.cachedresultset;
            if (this.options.persistent) {
              this.resultdata = this.resultset.data();
              this.emit("rebuild", this);
            }
            return this;
          };
          DynamicView.prototype._indexOfFilterWithId = function(uid) {
            if (typeof uid === "string" || typeof uid === "number") {
              for (var idx = 0, len = this.filterPipeline.length; idx < len; idx += 1) {
                if (uid === this.filterPipeline[idx].uid) {
                  return idx;
                }
              }
            }
            return -1;
          };
          DynamicView.prototype._addFilter = function(filter) {
            var wasFrozen = Object.isFrozen(this.filterPipeline);
            if (wasFrozen) {
              this.filterPipeline = this.filterPipeline.slice();
            }
            if (!this.collection.disableFreeze) {
              deepFreeze(filter);
            }
            this.filterPipeline.push(filter);
            if (wasFrozen) {
              Object.freeze(this.filterPipeline);
            }
            this.resultset[filter.type](filter.val);
          };
          DynamicView.prototype.reapplyFilters = function() {
            this.resultset.reset();
            this.cachedresultset = null;
            if (this.options.persistent) {
              this.resultdata = [];
              this.resultsdirty = true;
            }
            var filters = this.filterPipeline;
            var wasFrozen = Object.isFrozen(filters);
            this.filterPipeline = [];
            for (var idx = 0, len = filters.length; idx < len; idx += 1) {
              this._addFilter(filters[idx]);
            }
            if (wasFrozen) {
              Object.freeze(this.filterPipeline);
            }
            if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
              this.queueSortPhase();
            } else {
              this.queueRebuildEvent();
            }
            this.emit("filter");
            return this;
          };
          DynamicView.prototype.applyFilter = function(filter) {
            var idx = this._indexOfFilterWithId(filter.uid);
            if (idx >= 0) {
              var wasFrozen = Object.isFrozen(this.filterPipeline);
              if (wasFrozen) {
                this.filterPipeline = this.filterPipeline.slice();
              }
              this.filterPipeline[idx] = filter;
              if (wasFrozen) {
                freeze(filter);
                Object.freeze(this.filterPipeline);
              }
              return this.reapplyFilters();
            }
            this.cachedresultset = null;
            if (this.options.persistent) {
              this.resultdata = [];
              this.resultsdirty = true;
            }
            this._addFilter(filter);
            if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
              this.queueSortPhase();
            } else {
              this.queueRebuildEvent();
            }
            this.emit("filter");
            return this;
          };
          DynamicView.prototype.applyFind = function(query, uid) {
            this.applyFilter({
              type: "find",
              val: query,
              uid
            });
            return this;
          };
          DynamicView.prototype.applyWhere = function(fun, uid) {
            this.applyFilter({
              type: "where",
              val: fun,
              uid
            });
            return this;
          };
          DynamicView.prototype.removeFilter = function(uid) {
            var idx = this._indexOfFilterWithId(uid);
            if (idx < 0) {
              throw new Error("Dynamic view does not contain a filter with ID: " + uid);
            }
            var wasFrozen = Object.isFrozen(this.filterPipeline);
            if (wasFrozen) {
              this.filterPipeline = this.filterPipeline.slice();
            }
            this.filterPipeline.splice(idx, 1);
            if (wasFrozen) {
              Object.freeze(this.filterPipeline);
            }
            this.reapplyFilters();
            return this;
          };
          DynamicView.prototype.count = function() {
            if (this.resultsdirty) {
              this.resultdata = this.resultset.data();
            }
            return this.resultset.count();
          };
          DynamicView.prototype.data = function(options) {
            if (this.sortDirty || this.resultsdirty) {
              this.performSortPhase({
                suppressRebuildEvent: true
              });
            }
            return this.options.persistent ? this.resultdata : this.resultset.data(options);
          };
          DynamicView.prototype.queueRebuildEvent = function() {
            if (this.rebuildPending) {
              return;
            }
            this.rebuildPending = true;
            var self2 = this;
            setTimeout(function() {
              if (self2.rebuildPending) {
                self2.rebuildPending = false;
                self2.emit("rebuild", self2);
              }
            }, this.options.minRebuildInterval);
          };
          DynamicView.prototype.queueSortPhase = function() {
            if (this.sortDirty) {
              return;
            }
            this.sortDirty = true;
            var self2 = this;
            if (this.options.sortPriority === "active") {
              setTimeout(function() {
                self2.performSortPhase();
              }, this.options.minRebuildInterval);
            } else {
              this.queueRebuildEvent();
            }
          };
          DynamicView.prototype.performSortPhase = function(options) {
            if (!this.sortDirty && !this.resultsdirty) {
              return;
            }
            options = options || {};
            if (this.sortDirty) {
              if (this.sortFunction) {
                this.resultset.sort(this.sortFunction);
              } else if (this.sortCriteria) {
                this.resultset.compoundsort(this.sortCriteria);
              } else if (this.sortCriteriaSimple) {
                this.resultset.simplesort(this.sortCriteriaSimple.propname, this.sortCriteriaSimple.options);
              }
              this.sortDirty = false;
            }
            if (this.options.persistent) {
              this.resultdata = this.resultset.data();
              this.resultsdirty = false;
            }
            if (!options.suppressRebuildEvent) {
              this.emit("rebuild", this);
            }
          };
          DynamicView.prototype.evaluateDocument = function(objIndex, isNew) {
            if (!this.resultset.filterInitialized) {
              if (this.options.persistent) {
                this.resultdata = this.resultset.data();
              }
              if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
                this.queueSortPhase();
              } else {
                this.queueRebuildEvent();
              }
              return;
            }
            var ofr = this.resultset.filteredrows;
            var oldPos = isNew ? -1 : ofr.indexOf(+objIndex);
            var oldlen = ofr.length;
            var evalResultset = new Resultset(this.collection);
            evalResultset.filteredrows = [objIndex];
            evalResultset.filterInitialized = true;
            var filter;
            for (var idx = 0, len = this.filterPipeline.length; idx < len; idx++) {
              filter = this.filterPipeline[idx];
              evalResultset[filter.type](filter.val);
            }
            var newPos = evalResultset.filteredrows.length === 0 ? -1 : 0;
            if (oldPos === -1 && newPos === -1)
              return;
            if (oldPos === -1 && newPos !== -1) {
              ofr.push(objIndex);
              if (this.options.persistent) {
                this.resultdata.push(this.collection.data[objIndex]);
              }
              if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
                this.queueSortPhase();
              } else {
                this.queueRebuildEvent();
              }
              return;
            }
            if (oldPos !== -1 && newPos === -1) {
              if (oldPos < oldlen - 1) {
                ofr.splice(oldPos, 1);
                if (this.options.persistent) {
                  this.resultdata.splice(oldPos, 1);
                }
              } else {
                ofr.length = oldlen - 1;
                if (this.options.persistent) {
                  this.resultdata.length = oldlen - 1;
                }
              }
              if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
                this.queueSortPhase();
              } else {
                this.queueRebuildEvent();
              }
              return;
            }
            if (oldPos !== -1 && newPos !== -1) {
              if (this.options.persistent) {
                this.resultdata[oldPos] = this.collection.data[objIndex];
              }
              if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
                this.queueSortPhase();
              } else {
                this.queueRebuildEvent();
              }
              return;
            }
          };
          DynamicView.prototype.removeDocument = function(objIndex) {
            var idx, rmidx, rmlen, rxo = {}, fxo = {};
            var adjels = [];
            var drs = this.resultset;
            var fr = this.resultset.filteredrows;
            var frlen = fr.length;
            if (!this.resultset.filterInitialized) {
              if (this.options.persistent) {
                this.resultdata = this.resultset.data();
              }
              if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
                this.queueSortPhase();
              } else {
                this.queueRebuildEvent();
              }
              return;
            }
            if (!Array.isArray(objIndex)) {
              objIndex = [objIndex];
            }
            rmlen = objIndex.length;
            for (rmidx = 0; rmidx < rmlen; rmidx++) {
              rxo[objIndex[rmidx]] = true;
            }
            for (idx = 0; idx < frlen; idx++) {
              if (rxo[fr[idx]])
                fxo[idx] = true;
            }
            if (Object.keys(fxo).length > 0) {
              this.resultset.filteredrows = this.resultset.filteredrows.filter(function(di, idx2) {
                return !fxo[idx2];
              });
              if (this.options.persistent) {
                this.resultdata = this.resultdata.filter(function(obj, idx2) {
                  return !fxo[idx2];
                });
              }
              if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
                this.queueSortPhase();
              } else {
                this.queueRebuildEvent();
              }
            }
            var filt = function(idx2) {
              return function(di) {
                return di < drs.filteredrows[idx2];
              };
            };
            frlen = drs.filteredrows.length;
            for (idx = 0; idx < frlen; idx++) {
              adjels = objIndex.filter(filt(idx));
              drs.filteredrows[idx] -= adjels.length;
            }
          };
          DynamicView.prototype.mapReduce = function(mapFunction, reduceFunction) {
            try {
              return reduceFunction(this.data().map(mapFunction));
            } catch (err) {
              throw err;
            }
          };
          function Collection(name2, options) {
            this.name = name2;
            this.data = [];
            this.idIndex = null;
            this.binaryIndices = {};
            this.constraints = {
              unique: {},
              exact: {}
            };
            this.uniqueNames = [];
            this.transforms = {};
            this.objType = name2;
            this.dirty = true;
            this.cachedIndex = null;
            this.cachedBinaryIndex = null;
            this.cachedData = null;
            var self2 = this;
            options = options || {};
            if (options.hasOwnProperty("unique")) {
              if (!Array.isArray(options.unique)) {
                options.unique = [options.unique];
              }
              options.unique.forEach(function(prop) {
                self2.uniqueNames.push(prop);
              });
            }
            if (options.hasOwnProperty("exact")) {
              options.exact.forEach(function(prop) {
                self2.constraints.exact[prop] = new ExactIndex(prop);
              });
            }
            this.adaptiveBinaryIndices = options.hasOwnProperty("adaptiveBinaryIndices") ? options.adaptiveBinaryIndices : true;
            this.transactional = options.hasOwnProperty("transactional") ? options.transactional : false;
            this.cloneObjects = options.hasOwnProperty("clone") ? options.clone : false;
            this.cloneMethod = options.hasOwnProperty("cloneMethod") ? options.cloneMethod : "parse-stringify";
            this.asyncListeners = options.hasOwnProperty("asyncListeners") ? options.asyncListeners : false;
            this.disableMeta = options.hasOwnProperty("disableMeta") ? options.disableMeta : false;
            this.disableChangesApi = options.hasOwnProperty("disableChangesApi") ? options.disableChangesApi : true;
            this.disableDeltaChangesApi = options.hasOwnProperty("disableDeltaChangesApi") ? options.disableDeltaChangesApi : true;
            if (this.disableChangesApi) {
              this.disableDeltaChangesApi = true;
            }
            this.autoupdate = options.hasOwnProperty("autoupdate") ? options.autoupdate : false;
            this.serializableIndices = options.hasOwnProperty("serializableIndices") ? options.serializableIndices : true;
            this.disableFreeze = options.hasOwnProperty("disableFreeze") ? options.disableFreeze : true;
            this.ttl = {
              age: null,
              ttlInterval: null,
              daemon: null
            };
            this.setTTL(options.ttl || -1, options.ttlInterval);
            this.maxId = 0;
            this.DynamicViews = [];
            this.events = {
              "insert": [],
              "update": [],
              "pre-insert": [],
              "pre-update": [],
              "close": [],
              "flushbuffer": [],
              "error": [],
              "delete": [],
              "warning": []
            };
            this.changes = [];
            this.dirtyIds = [];
            var indices = [];
            if (options && options.indices) {
              if (Object.prototype.toString.call(options.indices) === "[object Array]") {
                indices = options.indices;
              } else if (typeof options.indices === "string") {
                indices = [options.indices];
              } else {
                throw new TypeError("Indices needs to be a string or an array of strings");
              }
            }
            for (var idx = 0; idx < indices.length; idx++) {
              this.ensureIndex(indices[idx]);
            }
            function observerCallback(changes) {
              var changedObjects = typeof Set === "function" ? /* @__PURE__ */ new Set() : [];
              if (!changedObjects.add)
                changedObjects.add = function(object2) {
                  if (this.indexOf(object2) === -1)
                    this.push(object2);
                  return this;
                };
              changes.forEach(function(change2) {
                changedObjects.add(change2.object);
              });
              changedObjects.forEach(function(object2) {
                if (!hasOwnProperty.call(object2, "$loki"))
                  return self2.removeAutoUpdateObserver(object2);
                try {
                  self2.update(object2);
                } catch (err) {
                }
              });
            }
            this.observerCallback = observerCallback;
            function getChangeDelta(obj, old) {
              if (old) {
                return getObjectDelta(old, obj);
              } else {
                return JSON.parse(JSON.stringify(obj));
              }
            }
            this.getChangeDelta = getChangeDelta;
            function getObjectDelta(oldObject, newObject) {
              var propertyNames = newObject !== null && typeof newObject === "object" ? Object.keys(newObject) : null;
              if (propertyNames && propertyNames.length && ["string", "boolean", "number"].indexOf(typeof newObject) < 0) {
                var delta = {};
                for (var i = 0; i < propertyNames.length; i++) {
                  var propertyName2 = propertyNames[i];
                  if (newObject.hasOwnProperty(propertyName2)) {
                    if (!oldObject.hasOwnProperty(propertyName2) || self2.uniqueNames.indexOf(propertyName2) >= 0 || propertyName2 == "$loki" || propertyName2 == "meta") {
                      delta[propertyName2] = newObject[propertyName2];
                    } else {
                      var propertyDelta = getObjectDelta(oldObject[propertyName2], newObject[propertyName2]);
                      if (typeof propertyDelta !== "undefined" && propertyDelta != {}) {
                        delta[propertyName2] = propertyDelta;
                      }
                    }
                  }
                }
                return Object.keys(delta).length === 0 ? void 0 : delta;
              } else {
                return oldObject === newObject ? void 0 : newObject;
              }
            }
            this.getObjectDelta = getObjectDelta;
            function flushChanges() {
              self2.changes = [];
            }
            this.getChanges = function() {
              return self2.changes;
            };
            this.flushChanges = flushChanges;
            this.setChangesApi = function(enabled) {
              self2.disableChangesApi = !enabled;
              if (!enabled) {
                self2.disableDeltaChangesApi = false;
              }
            };
            this.on("delete", function deleteCallback(obj) {
              if (!self2.disableChangesApi) {
                self2.createChange(self2.name, "R", obj);
              }
            });
            this.on("warning", function(warning) {
              self2.lokiConsoleWrapper.warn(warning);
            });
            flushChanges();
          }
          Collection.prototype = new LokiEventEmitter();
          Collection.prototype.contructor = Collection;
          Collection.prototype.createChange = function(name2, op, obj, old) {
            this.changes.push({
              name: name2,
              operation: op,
              obj: op == "U" && !this.disableDeltaChangesApi ? this.getChangeDelta(obj, old) : JSON.parse(JSON.stringify(obj))
            });
          };
          Collection.prototype.insertMeta = function(obj) {
            var len, idx;
            if (this.disableMeta || !obj) {
              return;
            }
            if (Array.isArray(obj)) {
              len = obj.length;
              for (idx = 0; idx < len; idx++) {
                if (!obj[idx].hasOwnProperty("meta")) {
                  obj[idx].meta = {};
                }
                obj[idx].meta.created = new Date().getTime();
                obj[idx].meta.revision = 0;
              }
              return;
            }
            if (!obj.meta) {
              obj.meta = {};
            }
            obj.meta.created = new Date().getTime();
            obj.meta.revision = 0;
          };
          Collection.prototype.updateMeta = function(obj) {
            if (this.disableMeta || !obj) {
              return obj;
            }
            if (!this.disableFreeze) {
              obj = unFreeze(obj);
              obj.meta = unFreeze(obj.meta);
            }
            obj.meta.updated = new Date().getTime();
            obj.meta.revision += 1;
            return obj;
          };
          Collection.prototype.createInsertChange = function(obj) {
            this.createChange(this.name, "I", obj);
          };
          Collection.prototype.createUpdateChange = function(obj, old) {
            this.createChange(this.name, "U", obj, old);
          };
          Collection.prototype.insertMetaWithChange = function(obj) {
            this.insertMeta(obj);
            this.createInsertChange(obj);
          };
          Collection.prototype.updateMetaWithChange = function(obj, old, objFrozen) {
            obj = this.updateMeta(obj, objFrozen);
            this.createUpdateChange(obj, old);
            return obj;
          };
          Collection.prototype.lokiConsoleWrapper = {
            log: function() {
            },
            warn: function() {
            },
            error: function() {
            }
          };
          Collection.prototype.addAutoUpdateObserver = function(object2) {
            if (!this.autoupdate || typeof Object.observe !== "function")
              return;
            Object.observe(object2, this.observerCallback, ["add", "update", "delete", "reconfigure", "setPrototype"]);
          };
          Collection.prototype.removeAutoUpdateObserver = function(object2) {
            if (!this.autoupdate || typeof Object.observe !== "function")
              return;
            Object.unobserve(object2, this.observerCallback);
          };
          Collection.prototype.addTransform = function(name2, transform) {
            if (this.transforms.hasOwnProperty(name2)) {
              throw new Error("a transform by that name already exists");
            }
            this.transforms[name2] = transform;
          };
          Collection.prototype.getTransform = function(name2) {
            return this.transforms[name2];
          };
          Collection.prototype.setTransform = function(name2, transform) {
            this.transforms[name2] = transform;
          };
          Collection.prototype.removeTransform = function(name2) {
            delete this.transforms[name2];
          };
          Collection.prototype.byExample = function(template2) {
            var k, obj, query;
            query = [];
            for (k in template2) {
              if (!template2.hasOwnProperty(k))
                continue;
              query.push((obj = {}, obj[k] = template2[k], obj));
            }
            return {
              "$and": query
            };
          };
          Collection.prototype.findObject = function(template2) {
            return this.findOne(this.byExample(template2));
          };
          Collection.prototype.findObjects = function(template2) {
            return this.find(this.byExample(template2));
          };
          Collection.prototype.ttlDaemonFuncGen = function() {
            var collection = this;
            var age = this.ttl.age;
            return function ttlDaemon() {
              var now3 = Date.now();
              var toRemove = collection.chain().where(function daemonFilter(member) {
                var timestamp = member.meta.updated || member.meta.created;
                var diff = now3 - timestamp;
                return age < diff;
              });
              toRemove.remove();
            };
          };
          Collection.prototype.setTTL = function(age, interval2) {
            if (age < 0) {
              clearInterval(this.ttl.daemon);
            } else {
              this.ttl.age = age;
              this.ttl.ttlInterval = interval2;
              this.ttl.daemon = setInterval(this.ttlDaemonFuncGen(), interval2);
            }
          };
          Collection.prototype.prepareFullDocIndex = function() {
            var len = this.data.length;
            var indexes = new Array(len);
            for (var i = 0; i < len; i += 1) {
              indexes[i] = i;
            }
            return indexes;
          };
          Collection.prototype.configureOptions = function(options) {
            options = options || {};
            if (options.hasOwnProperty("adaptiveBinaryIndices")) {
              this.adaptiveBinaryIndices = options.adaptiveBinaryIndices;
              if (this.adaptiveBinaryIndices) {
                this.ensureAllIndexes();
              }
            }
          };
          Collection.prototype.ensureIndex = function(property, force) {
            if (typeof force === "undefined") {
              force = false;
            }
            if (property === null || property === void 0) {
              throw new Error("Attempting to set index without an associated property");
            }
            if (this.binaryIndices[property] && !force) {
              if (!this.binaryIndices[property].dirty)
                return;
            }
            if (this.adaptiveBinaryIndices === true && this.binaryIndices.hasOwnProperty(property) && !force) {
              return;
            }
            var index2 = {
              "name": property,
              "dirty": true,
              "values": this.prepareFullDocIndex()
            };
            this.binaryIndices[property] = index2;
            var wrappedComparer = function(prop, data2) {
              var val1, val2;
              var propPath = ~prop.indexOf(".") ? prop.split(".") : false;
              return function(a2, b) {
                if (propPath) {
                  val1 = Utils.getIn(data2[a2], propPath, true);
                  val2 = Utils.getIn(data2[b], propPath, true);
                } else {
                  val1 = data2[a2][prop];
                  val2 = data2[b][prop];
                }
                if (val1 !== val2) {
                  if (Comparators.lt(val1, val2, false))
                    return -1;
                  if (Comparators.gt(val1, val2, false))
                    return 1;
                }
                return 0;
              };
            }(property, this.data);
            index2.values.sort(wrappedComparer);
            index2.dirty = false;
            this.dirty = true;
          };
          Collection.prototype.checkAllIndexes = function(options) {
            var key, bIndices = this.binaryIndices;
            var results = [], result;
            for (key in bIndices) {
              if (hasOwnProperty.call(bIndices, key)) {
                result = this.checkIndex(key, options);
                if (!result) {
                  results.push(key);
                }
              }
            }
            return results;
          };
          Collection.prototype.checkIndex = function(property, options) {
            options = options || {};
            if (options.randomSamplingFactor && options.randomSampling !== false) {
              options.randomSampling = true;
            }
            options.randomSamplingFactor = options.randomSamplingFactor || 0.1;
            if (options.randomSamplingFactor < 0 || options.randomSamplingFactor > 1) {
              options.randomSamplingFactor = 0.1;
            }
            var valid = true, idx, iter, pos, len, biv;
            if (!this.binaryIndices.hasOwnProperty(property)) {
              throw new Error("called checkIndex on property without an index: " + property);
            }
            if (!this.adaptiveBinaryIndices) {
              this.ensureIndex(property);
            }
            biv = this.binaryIndices[property].values;
            len = biv.length;
            if (len !== this.data.length) {
              if (options.repair) {
                this.ensureIndex(property, true);
              }
              return false;
            }
            if (len === 0) {
              return true;
            }
            var usingDotNotation = property.indexOf(".") !== -1;
            if (len === 1) {
              valid = biv[0] === 0;
            } else {
              if (options.randomSampling) {
                if (!LokiOps.$lte(
                  Utils.getIn(this.data[biv[0]], property, usingDotNotation),
                  Utils.getIn(this.data[biv[1]], property, usingDotNotation)
                )) {
                  valid = false;
                }
                if (!LokiOps.$lte(
                  Utils.getIn(this.data[biv[len - 2]], property, usingDotNotation),
                  Utils.getIn(this.data[biv[len - 1]], property, usingDotNotation)
                )) {
                  valid = false;
                }
                if (valid) {
                  iter = Math.floor((len - 1) * options.randomSamplingFactor);
                  for (idx = 0; idx < iter - 1; idx++) {
                    pos = Math.floor(Math.random() * (len - 1));
                    if (!LokiOps.$lte(
                      Utils.getIn(this.data[biv[pos]], property, usingDotNotation),
                      Utils.getIn(this.data[biv[pos + 1]], property, usingDotNotation)
                    )) {
                      valid = false;
                      break;
                    }
                  }
                }
              } else {
                for (idx = 0; idx < len - 1; idx++) {
                  if (!LokiOps.$lte(
                    Utils.getIn(this.data[biv[idx]], property, usingDotNotation),
                    Utils.getIn(this.data[biv[idx + 1]], property, usingDotNotation)
                  )) {
                    valid = false;
                    break;
                  }
                }
              }
            }
            if (!valid && options.repair) {
              this.ensureIndex(property, true);
            }
            return valid;
          };
          Collection.prototype.getBinaryIndexValues = function(property) {
            var idx, idxvals = this.binaryIndices[property].values;
            var result = [];
            for (idx = 0; idx < idxvals.length; idx++) {
              result.push(Utils.getIn(this.data[idxvals[idx]], property, true));
            }
            return result;
          };
          Collection.prototype.getUniqueIndex = function(field, force) {
            var index2 = this.constraints.unique[field];
            if (!index2 && force) {
              return this.ensureUniqueIndex(field);
            }
            return index2;
          };
          Collection.prototype.ensureUniqueIndex = function(field) {
            var index2 = this.constraints.unique[field];
            if (!index2) {
              if (this.uniqueNames.indexOf(field) == -1) {
                this.uniqueNames.push(field);
              }
            }
            this.constraints.unique[field] = index2 = new UniqueIndex(field);
            this.data.forEach(function(obj) {
              index2.set(obj);
            });
            return index2;
          };
          Collection.prototype.ensureAllIndexes = function(force) {
            var key, bIndices = this.binaryIndices;
            for (key in bIndices) {
              if (hasOwnProperty.call(bIndices, key)) {
                this.ensureIndex(key, force);
              }
            }
          };
          Collection.prototype.flagBinaryIndexesDirty = function() {
            var key, bIndices = this.binaryIndices;
            for (key in bIndices) {
              if (hasOwnProperty.call(bIndices, key)) {
                bIndices[key].dirty = true;
              }
            }
          };
          Collection.prototype.flagBinaryIndexDirty = function(index2) {
            if (this.binaryIndices[index2])
              this.binaryIndices[index2].dirty = true;
          };
          Collection.prototype.count = function(query) {
            if (!query) {
              return this.data.length;
            }
            return this.chain().find(query).filteredrows.length;
          };
          Collection.prototype.ensureId = function() {
            if (this.idIndex) {
              return;
            }
            var data2 = this.data, i = 0;
            var len = data2.length;
            var index2 = new Array(len);
            for (i; i < len; i++) {
              index2[i] = data2[i].$loki;
            }
            this.idIndex = index2;
          };
          Collection.prototype.ensureIdAsync = function(callback) {
            this.async(function() {
              this.ensureId();
            }, callback);
          };
          Collection.prototype.addDynamicView = function(name2, options) {
            var dv = new DynamicView(this, name2, options);
            this.DynamicViews.push(dv);
            return dv;
          };
          Collection.prototype.removeDynamicView = function(name2) {
            this.DynamicViews = this.DynamicViews.filter(function(dv) {
              return dv.name !== name2;
            });
          };
          Collection.prototype.getDynamicView = function(name2) {
            for (var idx = 0; idx < this.DynamicViews.length; idx++) {
              if (this.DynamicViews[idx].name === name2) {
                return this.DynamicViews[idx];
              }
            }
            return null;
          };
          Collection.prototype.findAndUpdate = function(filterObject, updateFunction) {
            if (typeof filterObject === "function") {
              this.updateWhere(filterObject, updateFunction);
            } else {
              this.chain().find(filterObject).update(updateFunction);
            }
          };
          Collection.prototype.findAndRemove = function(filterObject) {
            this.chain().find(filterObject).remove();
          };
          Collection.prototype.insert = function(doc3, overrideAdaptiveIndices) {
            if (!Array.isArray(doc3)) {
              return this.insertOne(doc3);
            }
            var obj;
            var results = [];
            var adaptiveBatchOverride = overrideAdaptiveIndices && !this.cloneObjects && this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;
            if (adaptiveBatchOverride) {
              this.adaptiveBinaryIndices = false;
            }
            try {
              this.emit("pre-insert", doc3);
              for (var i = 0, len = doc3.length; i < len; i++) {
                obj = this.insertOne(doc3[i], true);
                if (!obj) {
                  return void 0;
                }
                results.push(obj);
              }
            } finally {
              if (adaptiveBatchOverride) {
                this.ensureAllIndexes();
                this.adaptiveBinaryIndices = true;
              }
            }
            this.emit("insert", results);
            results = this.cloneObjects ? clone2(results, this.cloneMethod) : results;
            return results.length === 1 ? results[0] : results;
          };
          Collection.prototype.insertOne = function(doc3, bulkInsert) {
            var err = null;
            var returnObj;
            if (typeof doc3 !== "object") {
              err = new TypeError("Document needs to be an object");
            } else if (doc3 === null) {
              err = new TypeError("Object cannot be null");
            }
            if (err !== null) {
              this.emit("error", err);
              throw err;
            }
            var obj = this.cloneObjects ? clone2(doc3, this.cloneMethod) : doc3;
            if (!this.disableFreeze) {
              obj = unFreeze(obj);
            }
            if (!this.disableMeta) {
              if (typeof obj.meta === "undefined") {
                obj.meta = {
                  revision: 0,
                  created: 0
                };
              } else if (!this.disableFreeze) {
                obj.meta = unFreeze(obj.meta);
              }
            }
            if (!bulkInsert) {
              this.emit("pre-insert", obj);
            }
            if (!this.add(obj)) {
              return void 0;
            }
            if (this.disableChangesApi) {
              this.insertMeta(obj);
            } else {
              this.insertMetaWithChange(obj);
            }
            if (!this.disableFreeze) {
              deepFreeze(obj);
            }
            returnObj = this.cloneObjects ? clone2(obj, this.cloneMethod) : obj;
            if (!bulkInsert) {
              this.emit("insert", returnObj);
            }
            this.addAutoUpdateObserver(returnObj);
            return returnObj;
          };
          Collection.prototype.clear = function(options) {
            var self2 = this;
            options = options || {};
            this.data = [];
            this.idIndex = null;
            this.cachedIndex = null;
            this.cachedBinaryIndex = null;
            this.cachedData = null;
            this.maxId = 0;
            this.DynamicViews = [];
            this.dirty = true;
            this.constraints = {
              unique: {},
              exact: {}
            };
            if (options.removeIndices === true) {
              this.binaryIndices = {};
              this.uniqueNames = [];
            } else {
              var keys3 = Object.keys(this.binaryIndices);
              keys3.forEach(function(biname) {
                self2.binaryIndices[biname].dirty = false;
                self2.binaryIndices[biname].values = [];
              });
            }
          };
          Collection.prototype.update = function(doc3) {
            var adaptiveBatchOverride, k, len;
            if (Array.isArray(doc3)) {
              len = doc3.length;
              adaptiveBatchOverride = !this.cloneObjects && this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;
              if (adaptiveBatchOverride) {
                this.adaptiveBinaryIndices = false;
              }
              try {
                for (k = 0; k < len; k += 1) {
                  this.update(doc3[k]);
                }
              } finally {
                if (adaptiveBatchOverride) {
                  this.ensureAllIndexes();
                  this.adaptiveBinaryIndices = true;
                }
              }
              return;
            }
            if (!hasOwnProperty.call(doc3, "$loki")) {
              throw new Error("Trying to update unsynced document. Please save the document first by using insert() or addMany()");
            }
            try {
              this.startTransaction();
              var arr = this.get(doc3.$loki, true), oldInternal, newInternal, position, self2 = this;
              if (!arr) {
                throw new Error("Trying to update a document not in collection.");
              }
              oldInternal = arr[0];
              position = arr[1];
              newInternal = this.cloneObjects || !this.disableDeltaChangesApi && this.disableFreeze ? clone2(doc3, this.cloneMethod) : doc3;
              this.emit("pre-update", doc3);
              this.uniqueNames.forEach(function(key2) {
                self2.getUniqueIndex(key2, true).update(oldInternal, newInternal);
              });
              this.data[position] = newInternal;
              if (newInternal !== doc3) {
                this.addAutoUpdateObserver(doc3);
              }
              for (var idx = 0; idx < this.DynamicViews.length; idx++) {
                this.DynamicViews[idx].evaluateDocument(position, false);
              }
              var key;
              if (this.adaptiveBinaryIndices) {
                var bIndices = this.binaryIndices;
                for (key in bIndices) {
                  this.adaptiveBinaryIndexUpdate(position, key);
                }
              } else {
                this.flagBinaryIndexesDirty();
              }
              this.idIndex[position] = newInternal.$loki;
              if (this.isIncremental) {
                this.dirtyIds.push(newInternal.$loki);
              }
              this.commit();
              this.dirty = true;
              if (this.disableChangesApi) {
                newInternal = this.updateMeta(newInternal);
              } else {
                newInternal = this.updateMetaWithChange(newInternal, oldInternal);
              }
              if (!this.disableFreeze) {
                deepFreeze(newInternal);
              }
              var returnObj;
              if (this.cloneObjects) {
                returnObj = clone2(newInternal, this.cloneMethod);
              } else {
                returnObj = newInternal;
              }
              this.emit("update", returnObj, oldInternal);
              return returnObj;
            } catch (err) {
              this.rollback();
              this.lokiConsoleWrapper.error(err.message);
              this.emit("error", err);
              throw err;
            }
          };
          Collection.prototype.add = function(obj) {
            if ("object" !== typeof obj) {
              throw new TypeError("Object being added needs to be an object");
            }
            if (typeof obj.$loki !== "undefined") {
              throw new Error("Document is already in collection, please use update()");
            }
            try {
              this.startTransaction();
              this.maxId++;
              if (isNaN(this.maxId)) {
                this.maxId = this.data[this.data.length - 1].$loki + 1;
              }
              var newId = this.maxId;
              obj.$loki = newId;
              if (!this.disableMeta) {
                obj.meta.version = 0;
              }
              for (var i = 0, len = this.uniqueNames.length; i < len; i++) {
                this.getUniqueIndex(this.uniqueNames[i], true).set(obj);
              }
              if (this.idIndex) {
                this.idIndex.push(newId);
              }
              if (this.isIncremental) {
                this.dirtyIds.push(newId);
              }
              this.data.push(obj);
              var addedPos = this.data.length - 1;
              var dvlen = this.DynamicViews.length;
              for (i = 0; i < dvlen; i++) {
                this.DynamicViews[i].evaluateDocument(addedPos, true);
              }
              if (this.adaptiveBinaryIndices) {
                var bIndices = this.binaryIndices;
                for (var key in bIndices) {
                  this.adaptiveBinaryIndexInsert(addedPos, key);
                }
              } else {
                this.flagBinaryIndexesDirty();
              }
              this.commit();
              this.dirty = true;
              return this.cloneObjects ? clone2(obj, this.cloneMethod) : obj;
            } catch (err) {
              this.rollback();
              this.lokiConsoleWrapper.error(err.message);
              this.emit("error", err);
              throw err;
            }
          };
          Collection.prototype.updateWhere = function(filterFunction, updateFunction) {
            var results = this.where(filterFunction), i = 0, obj;
            try {
              for (i; i < results.length; i++) {
                obj = updateFunction(results[i]);
                this.update(obj);
              }
            } catch (err) {
              this.rollback();
              this.lokiConsoleWrapper.error(err.message);
            }
          };
          Collection.prototype.removeWhere = function(query) {
            var list;
            if (typeof query === "function") {
              list = this.data.filter(query);
              this.remove(list);
            } else {
              this.chain().find(query).remove();
            }
          };
          Collection.prototype.removeDataOnly = function() {
            this.remove(this.data.slice());
          };
          Collection.prototype.removeBatchByPositions = function(positions) {
            var len = positions.length;
            var xo = {};
            var dlen, didx, idx;
            var bic = Object.keys(this.binaryIndices).length;
            var uic = Object.keys(this.constraints.unique).length;
            var adaptiveOverride = this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;
            var doc3, self2 = this;
            try {
              this.startTransaction();
              this.ensureId();
              for (idx = 0; idx < len; idx++) {
                xo[this.idIndex[positions[idx]]] = true;
              }
              dlen = this.DynamicViews.length;
              if (dlen > 0 || bic > 0 || uic > 0) {
                if (dlen > 0) {
                  for (didx = 0; didx < dlen; didx++) {
                    this.DynamicViews[didx].removeDocument(positions);
                  }
                }
                if (this.adaptiveBinaryIndices && !adaptiveOverride) {
                  var key, bIndices = this.binaryIndices;
                  for (key in bIndices) {
                    this.adaptiveBinaryIndexRemove(positions, key);
                  }
                } else {
                  this.flagBinaryIndexesDirty();
                }
                if (uic) {
                  this.uniqueNames.forEach(function(key2) {
                    var index2 = self2.getUniqueIndex(key2);
                    if (index2) {
                      for (idx = 0; idx < len; idx++) {
                        doc3 = self2.data[positions[idx]];
                        if (doc3[key2] !== null && doc3[key2] !== void 0) {
                          index2.remove(doc3[key2]);
                        }
                      }
                    }
                  });
                }
              }
              if (!this.disableChangesApi || this.events.delete.length > 1) {
                for (idx = 0; idx < len; idx++) {
                  this.emit("delete", this.data[positions[idx]]);
                }
              }
              this.data = this.data.filter(function(obj) {
                return !xo[obj.$loki];
              });
              if (this.isIncremental) {
                for (idx = 0; idx < len; idx++) {
                  this.dirtyIds.push(this.idIndex[positions[idx]]);
                }
              }
              this.idIndex = this.idIndex.filter(function(id3) {
                return !xo[id3];
              });
              if (this.adaptiveBinaryIndices && adaptiveOverride) {
                this.adaptiveBinaryIndices = false;
                this.ensureAllIndexes(true);
                this.adaptiveBinaryIndices = true;
              }
              this.commit();
              this.dirty = true;
            } catch (err) {
              this.rollback();
              if (adaptiveOverride) {
                this.adaptiveBinaryIndices = true;
              }
              this.lokiConsoleWrapper.error(err.message);
              this.emit("error", err);
              return null;
            }
          };
          Collection.prototype.removeBatch = function(batch) {
            var len = batch.length, dlen = this.data.length, idx;
            var xlt = {};
            var posx = [];
            for (idx = 0; idx < dlen; idx++) {
              xlt[this.data[idx].$loki] = idx;
            }
            for (idx = 0; idx < len; idx++) {
              if (typeof batch[idx] === "object") {
                posx.push(xlt[batch[idx].$loki]);
              } else {
                posx.push(xlt[batch[idx]]);
              }
            }
            this.removeBatchByPositions(posx);
          };
          Collection.prototype.remove = function(doc3) {
            var frozen;
            if (typeof doc3 === "number") {
              doc3 = this.get(doc3);
            }
            if ("object" !== typeof doc3) {
              throw new Error("Parameter is not an object");
            }
            if (Array.isArray(doc3)) {
              this.removeBatch(doc3);
              return;
            }
            if (!hasOwnProperty.call(doc3, "$loki")) {
              throw new Error("Object is not a document stored in the collection");
            }
            try {
              this.startTransaction();
              var arr = this.get(doc3.$loki, true), position = arr[1];
              var self2 = this;
              this.uniqueNames.forEach(function(key2) {
                if (doc3[key2] !== null && typeof doc3[key2] !== "undefined") {
                  var index2 = self2.getUniqueIndex(key2);
                  if (index2) {
                    index2.remove(doc3[key2]);
                  }
                }
              });
              for (var idx = 0; idx < this.DynamicViews.length; idx++) {
                this.DynamicViews[idx].removeDocument(position);
              }
              if (this.adaptiveBinaryIndices) {
                var key, bIndices = this.binaryIndices;
                for (key in bIndices) {
                  this.adaptiveBinaryIndexRemove(position, key);
                }
              } else {
                this.flagBinaryIndexesDirty();
              }
              this.data.splice(position, 1);
              this.removeAutoUpdateObserver(doc3);
              this.idIndex.splice(position, 1);
              if (this.isIncremental) {
                this.dirtyIds.push(doc3.$loki);
              }
              this.commit();
              this.dirty = true;
              this.emit("delete", arr[0]);
              if (!this.disableFreeze) {
                doc3 = unFreeze(doc3);
              }
              delete doc3.$loki;
              delete doc3.meta;
              if (!this.disableFreeze) {
                freeze(doc3);
              }
              return doc3;
            } catch (err) {
              this.rollback();
              this.lokiConsoleWrapper.error(err.message);
              this.emit("error", err);
              return null;
            }
          };
          Collection.prototype.get = function(id3, returnPosition) {
            if (!this.idIndex) {
              this.ensureId();
            }
            var retpos = returnPosition || false, data2 = this.idIndex, max2 = data2.length - 1, min2 = 0, mid = min2 + max2 >> 1;
            id3 = typeof id3 === "number" ? id3 : parseInt(id3, 10);
            if (isNaN(id3)) {
              throw new TypeError("Passed id is not an integer");
            }
            while (data2[min2] < data2[max2]) {
              mid = min2 + max2 >> 1;
              if (data2[mid] < id3) {
                min2 = mid + 1;
              } else {
                max2 = mid;
              }
            }
            if (max2 === min2 && data2[min2] === id3) {
              if (retpos) {
                return [this.data[min2], min2];
              }
              return this.data[min2];
            }
            return null;
          };
          Collection.prototype.getBinaryIndexPosition = function(dataPosition, binaryIndexName) {
            var val = Utils.getIn(this.data[dataPosition], binaryIndexName, true);
            var index2 = this.binaryIndices[binaryIndexName].values;
            var range = this.calculateRange("$eq", binaryIndexName, val);
            if (range[0] === 0 && range[1] === -1) {
              return null;
            }
            var min2 = range[0];
            var max2 = range[1];
            for (var idx = min2; idx <= max2; idx++) {
              if (index2[idx] === dataPosition)
                return idx;
            }
            return null;
          };
          Collection.prototype.adaptiveBinaryIndexInsert = function(dataPosition, binaryIndexName) {
            var usingDotNotation = binaryIndexName.indexOf(".") !== -1;
            var index2 = this.binaryIndices[binaryIndexName].values;
            var val = Utils.getIn(this.data[dataPosition], binaryIndexName, usingDotNotation);
            if (this.serializableIndices === true && val instanceof Date) {
              this.data[dataPosition][binaryIndexName] = val.getTime();
              val = Utils.getIn(this.data[dataPosition], binaryIndexName);
            }
            var idxPos = index2.length === 0 ? 0 : this.calculateRangeStart(binaryIndexName, val, true, usingDotNotation);
            this.binaryIndices[binaryIndexName].values.splice(idxPos, 0, dataPosition);
          };
          Collection.prototype.adaptiveBinaryIndexUpdate = function(dataPosition, binaryIndexName) {
            var idxPos, index2 = this.binaryIndices[binaryIndexName].values, len = index2.length;
            for (idxPos = 0; idxPos < len; idxPos++) {
              if (index2[idxPos] === dataPosition)
                break;
            }
            this.binaryIndices[binaryIndexName].values.splice(idxPos, 1);
            this.adaptiveBinaryIndexInsert(dataPosition, binaryIndexName);
          };
          Collection.prototype.adaptiveBinaryIndexRemove = function(dataPosition, binaryIndexName, removedFromIndexOnly) {
            var bi = this.binaryIndices[binaryIndexName];
            var len, idx, rmidx, rmlen, rxo = {};
            var curr, shift2, idxPos;
            if (Array.isArray(dataPosition)) {
              rmlen = dataPosition.length;
              if (rmlen === 1) {
                dataPosition = dataPosition[0];
              } else {
                for (rmidx = 0; rmidx < rmlen; rmidx++) {
                  rxo[dataPosition[rmidx]] = true;
                }
                bi.values = bi.values.filter(function(di) {
                  return !rxo[di];
                });
                if (removedFromIndexOnly === true) {
                  return;
                }
                var sortedPositions = dataPosition.slice();
                sortedPositions.sort(function(a2, b) {
                  return a2 - b;
                });
                len = bi.values.length;
                for (idx = 0; idx < len; idx++) {
                  curr = bi.values[idx];
                  shift2 = 0;
                  for (rmidx = 0; rmidx < rmlen && curr > sortedPositions[rmidx]; rmidx++) {
                    shift2++;
                  }
                  bi.values[idx] -= shift2;
                }
                return;
              }
            }
            idxPos = this.getBinaryIndexPosition(dataPosition, binaryIndexName);
            if (idxPos === null) {
              return null;
            }
            bi.values.splice(idxPos, 1);
            if (removedFromIndexOnly === true) {
              return;
            }
            len = bi.values.length;
            for (idx = 0; idx < len; idx++) {
              if (bi.values[idx] > dataPosition) {
                bi.values[idx]--;
              }
            }
          };
          Collection.prototype.calculateRangeStart = function(prop, val, adaptive, usingDotNotation) {
            var rcd = this.data;
            var index2 = this.binaryIndices[prop].values;
            var min2 = 0;
            var max2 = index2.length - 1;
            var mid = 0;
            if (index2.length === 0) {
              return -1;
            }
            var minVal = Utils.getIn(rcd[index2[min2]], prop, usingDotNotation);
            var maxVal = Utils.getIn(rcd[index2[max2]], prop, usingDotNotation);
            while (min2 < max2) {
              mid = min2 + max2 >> 1;
              if (Comparators.lt(Utils.getIn(rcd[index2[mid]], prop, usingDotNotation), val, false)) {
                min2 = mid + 1;
              } else {
                max2 = mid;
              }
            }
            var lbound = min2;
            if (Comparators.aeq(val, Utils.getIn(rcd[index2[lbound]], prop, usingDotNotation))) {
              return lbound;
            }
            if (Comparators.lt(val, Utils.getIn(rcd[index2[lbound]], prop, usingDotNotation), false)) {
              return adaptive ? lbound : lbound - 1;
            }
            return adaptive ? lbound + 1 : lbound;
          };
          Collection.prototype.calculateRangeEnd = function(prop, val, usingDotNotation) {
            var rcd = this.data;
            var index2 = this.binaryIndices[prop].values;
            var min2 = 0;
            var max2 = index2.length - 1;
            var mid = 0;
            if (index2.length === 0) {
              return -1;
            }
            var minVal = Utils.getIn(rcd[index2[min2]], prop, usingDotNotation);
            var maxVal = Utils.getIn(rcd[index2[max2]], prop, usingDotNotation);
            while (min2 < max2) {
              mid = min2 + max2 >> 1;
              if (Comparators.lt(val, Utils.getIn(rcd[index2[mid]], prop, usingDotNotation), false)) {
                max2 = mid;
              } else {
                min2 = mid + 1;
              }
            }
            var ubound = max2;
            if (Comparators.aeq(val, Utils.getIn(rcd[index2[ubound]], prop, usingDotNotation))) {
              return ubound;
            }
            if (Comparators.gt(val, Utils.getIn(rcd[index2[ubound]], prop, usingDotNotation), false)) {
              return ubound + 1;
            }
            if (Comparators.aeq(val, Utils.getIn(rcd[index2[ubound - 1]], prop, usingDotNotation))) {
              return ubound - 1;
            }
            return ubound;
          };
          Collection.prototype.calculateRange = function(op, prop, val) {
            var rcd = this.data;
            var index2 = this.binaryIndices[prop].values;
            var min2 = 0;
            var max2 = index2.length - 1;
            var mid = 0;
            var lbound, lval;
            var ubound, uval;
            if (rcd.length === 0) {
              return [0, -1];
            }
            var usingDotNotation = prop.indexOf(".") !== -1;
            var minVal = Utils.getIn(rcd[index2[min2]], prop, usingDotNotation);
            var maxVal = Utils.getIn(rcd[index2[max2]], prop, usingDotNotation);
            switch (op) {
              case "$eq":
              case "$aeq":
                if (Comparators.lt(val, minVal, false) || Comparators.gt(val, maxVal, false)) {
                  return [0, -1];
                }
                break;
              case "$dteq":
                if (Comparators.lt(val, minVal, false) || Comparators.gt(val, maxVal, false)) {
                  return [0, -1];
                }
                break;
              case "$gt":
                if (Comparators.gt(val, maxVal, true)) {
                  return [0, -1];
                }
                if (Comparators.gt(minVal, val, false)) {
                  return [min2, max2];
                }
                break;
              case "$gte":
                if (Comparators.gt(val, maxVal, false)) {
                  return [0, -1];
                }
                if (Comparators.gt(minVal, val, true)) {
                  return [min2, max2];
                }
                break;
              case "$lt":
                if (Comparators.lt(val, minVal, true)) {
                  return [0, -1];
                }
                if (Comparators.lt(maxVal, val, false)) {
                  return [min2, max2];
                }
                break;
              case "$lte":
                if (Comparators.lt(val, minVal, false)) {
                  return [0, -1];
                }
                if (Comparators.lt(maxVal, val, true)) {
                  return [min2, max2];
                }
                break;
              case "$between":
                if (Comparators.gt(val[0], maxVal, false)) {
                  return [0, -1];
                }
                if (Comparators.lt(val[1], minVal, false)) {
                  return [0, -1];
                }
                lbound = this.calculateRangeStart(prop, val[0], false, usingDotNotation);
                ubound = this.calculateRangeEnd(prop, val[1], usingDotNotation);
                if (lbound < 0)
                  lbound++;
                if (ubound > max2)
                  ubound--;
                if (!Comparators.gt(Utils.getIn(rcd[index2[lbound]], prop, usingDotNotation), val[0], true))
                  lbound++;
                if (!Comparators.lt(Utils.getIn(rcd[index2[ubound]], prop, usingDotNotation), val[1], true))
                  ubound--;
                if (ubound < lbound)
                  return [0, -1];
                return [lbound, ubound];
              case "$in":
                var idxset = [], segResult = [];
                for (var j = 0, len = val.length; j < len; j++) {
                  var seg = this.calculateRange("$eq", prop, val[j]);
                  for (var i = seg[0]; i <= seg[1]; i++) {
                    if (idxset[i] === void 0) {
                      idxset[i] = true;
                      segResult.push(i);
                    }
                  }
                }
                return segResult;
            }
            switch (op) {
              case "$eq":
              case "$aeq":
              case "$dteq":
              case "$gte":
              case "$lt":
                lbound = this.calculateRangeStart(prop, val, false, usingDotNotation);
                lval = Utils.getIn(rcd[index2[lbound]], prop, usingDotNotation);
                break;
              default:
                break;
            }
            switch (op) {
              case "$eq":
              case "$aeq":
              case "$dteq":
              case "$lte":
              case "$gt":
                ubound = this.calculateRangeEnd(prop, val, usingDotNotation);
                uval = Utils.getIn(rcd[index2[ubound]], prop, usingDotNotation);
                break;
              default:
                break;
            }
            switch (op) {
              case "$eq":
              case "$aeq":
              case "$dteq":
                if (!Comparators.aeq(lval, val)) {
                  return [0, -1];
                }
                return [lbound, ubound];
              case "$gt":
                if (!Comparators.aeq(Utils.getIn(rcd[index2[ubound]], prop, usingDotNotation), val)) {
                  return [ubound, max2];
                }
                return [ubound + 1, max2];
              case "$gte":
                if (!Comparators.aeq(Utils.getIn(rcd[index2[lbound]], prop, usingDotNotation), val)) {
                  return [lbound + 1, max2];
                }
                return [lbound, max2];
              case "$lt":
                if (!Comparators.aeq(Utils.getIn(rcd[index2[lbound]], prop, usingDotNotation), val)) {
                  return [min2, lbound];
                }
                return [min2, lbound - 1];
              case "$lte":
                if (!Comparators.aeq(Utils.getIn(rcd[index2[ubound]], prop, usingDotNotation), val)) {
                  return [min2, ubound - 1];
                }
                return [min2, ubound];
              default:
                return [0, rcd.length - 1];
            }
          };
          Collection.prototype.by = function(field, value) {
            var self2;
            if (value === void 0) {
              self2 = this;
              return function(value2) {
                return self2.by(field, value2);
              };
            }
            var result = this.getUniqueIndex(field, true).get(value);
            if (!this.cloneObjects) {
              return result;
            } else {
              return clone2(result, this.cloneMethod);
            }
          };
          Collection.prototype.findOne = function(query) {
            query = query || {};
            var result = this.chain().find(query, true).data();
            if (Array.isArray(result) && result.length === 0) {
              return null;
            } else {
              if (!this.cloneObjects) {
                return result[0];
              } else {
                return clone2(result[0], this.cloneMethod);
              }
            }
          };
          Collection.prototype.chain = function(transform, parameters) {
            var rs = new Resultset(this);
            if (typeof transform === "undefined") {
              return rs;
            }
            return rs.transform(transform, parameters);
          };
          Collection.prototype.find = function(query) {
            return this.chain().find(query).data();
          };
          Collection.prototype.findOneUnindexed = function(prop, value) {
            var i = this.data.length, doc3;
            while (i--) {
              if (Utils.getIn(this.data[i], prop, true) === value) {
                doc3 = this.data[i];
                return doc3;
              }
            }
            return null;
          };
          Collection.prototype.startTransaction = function() {
            if (this.transactional) {
              this.cachedData = clone2(this.data, this.cloneMethod);
              this.cachedIndex = this.idIndex;
              this.cachedBinaryIndex = this.binaryIndices;
              this.cachedDirtyIds = this.dirtyIds;
              for (var idx = 0; idx < this.DynamicViews.length; idx++) {
                this.DynamicViews[idx].startTransaction();
              }
            }
          };
          Collection.prototype.commit = function() {
            if (this.transactional) {
              this.cachedData = null;
              this.cachedIndex = null;
              this.cachedBinaryIndex = null;
              this.cachedDirtyIds = null;
              for (var idx = 0; idx < this.DynamicViews.length; idx++) {
                this.DynamicViews[idx].commit();
              }
            }
          };
          Collection.prototype.rollback = function() {
            if (this.transactional) {
              if (this.cachedData !== null && this.cachedIndex !== null) {
                this.data = this.cachedData;
                this.idIndex = this.cachedIndex;
                this.binaryIndices = this.cachedBinaryIndex;
                this.dirtyIds = this.cachedDirtyIds;
              }
              for (var idx = 0; idx < this.DynamicViews.length; idx++) {
                this.DynamicViews[idx].rollback();
              }
            }
          };
          Collection.prototype.async = function(fun, callback) {
            setTimeout(function() {
              if (typeof fun === "function") {
                fun();
                callback();
              } else {
                throw new TypeError("Argument passed for async execution is not a function");
              }
            }, 0);
          };
          Collection.prototype.where = function(fun) {
            return this.chain().where(fun).data();
          };
          Collection.prototype.mapReduce = function(mapFunction, reduceFunction) {
            try {
              return reduceFunction(this.data.map(mapFunction));
            } catch (err) {
              throw err;
            }
          };
          Collection.prototype.eqJoin = function(joinData, leftJoinProp, rightJoinProp, mapFun, dataOptions) {
            return new Resultset(this).eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun, dataOptions);
          };
          Collection.prototype.stages = {};
          Collection.prototype.getStage = function(name2) {
            if (!this.stages[name2]) {
              this.stages[name2] = {};
            }
            return this.stages[name2];
          };
          Collection.prototype.commitLog = [];
          Collection.prototype.stage = function(stageName, obj) {
            var copy2 = JSON.parse(JSON.stringify(obj));
            this.getStage(stageName)[obj.$loki] = copy2;
            return copy2;
          };
          Collection.prototype.commitStage = function(stageName, message) {
            var stage = this.getStage(stageName), prop, timestamp = new Date().getTime();
            for (prop in stage) {
              this.update(stage[prop]);
              this.commitLog.push({
                timestamp,
                message,
                data: JSON.parse(JSON.stringify(stage[prop]))
              });
            }
            this.stages[stageName] = {};
          };
          Collection.prototype.no_op = function() {
            return;
          };
          Collection.prototype.extract = function(field) {
            var i = 0, len = this.data.length, isDotNotation = isDeepProperty(field), result = [];
            for (i; i < len; i += 1) {
              result.push(deepProperty(this.data[i], field, isDotNotation));
            }
            return result;
          };
          Collection.prototype.max = function(field) {
            return Math.max.apply(null, this.extract(field));
          };
          Collection.prototype.min = function(field) {
            return Math.min.apply(null, this.extract(field));
          };
          Collection.prototype.maxRecord = function(field) {
            var i = 0, len = this.data.length, deep = isDeepProperty(field), result = {
              index: 0,
              value: void 0
            }, max2;
            for (i; i < len; i += 1) {
              if (max2 !== void 0) {
                if (max2 < deepProperty(this.data[i], field, deep)) {
                  max2 = deepProperty(this.data[i], field, deep);
                  result.index = this.data[i].$loki;
                }
              } else {
                max2 = deepProperty(this.data[i], field, deep);
                result.index = this.data[i].$loki;
              }
            }
            result.value = max2;
            return result;
          };
          Collection.prototype.minRecord = function(field) {
            var i = 0, len = this.data.length, deep = isDeepProperty(field), result = {
              index: 0,
              value: void 0
            }, min2;
            for (i; i < len; i += 1) {
              if (min2 !== void 0) {
                if (min2 > deepProperty(this.data[i], field, deep)) {
                  min2 = deepProperty(this.data[i], field, deep);
                  result.index = this.data[i].$loki;
                }
              } else {
                min2 = deepProperty(this.data[i], field, deep);
                result.index = this.data[i].$loki;
              }
            }
            result.value = min2;
            return result;
          };
          Collection.prototype.extractNumerical = function(field) {
            return this.extract(field).map(parseBase10).filter(Number).filter(function(n2) {
              return !isNaN(n2);
            });
          };
          Collection.prototype.avg = function(field) {
            return average(this.extractNumerical(field));
          };
          Collection.prototype.stdDev = function(field) {
            return standardDeviation(this.extractNumerical(field));
          };
          Collection.prototype.mode = function(field) {
            var dict = {}, data2 = this.extract(field);
            data2.forEach(function(obj) {
              if (dict[obj]) {
                dict[obj] += 1;
              } else {
                dict[obj] = 1;
              }
            });
            var max2, prop, mode;
            for (prop in dict) {
              if (max2) {
                if (max2 < dict[prop]) {
                  mode = prop;
                }
              } else {
                mode = prop;
                max2 = dict[prop];
              }
            }
            return mode;
          };
          Collection.prototype.median = function(field) {
            var values2 = this.extractNumerical(field);
            values2.sort(sub);
            var half = Math.floor(values2.length / 2);
            if (values2.length % 2) {
              return values2[half];
            } else {
              return (values2[half - 1] + values2[half]) / 2;
            }
          };
          function isDeepProperty(field) {
            return field.indexOf(".") !== -1;
          }
          function parseBase10(num) {
            return parseFloat(num, 10);
          }
          function isNotUndefined(obj) {
            return obj !== void 0;
          }
          function add3(a2, b) {
            return a2 + b;
          }
          function sub(a2, b) {
            return a2 - b;
          }
          function median(values2) {
            values2.sort(sub);
            var half = Math.floor(values2.length / 2);
            return values2.length % 2 ? values2[half] : (values2[half - 1] + values2[half]) / 2;
          }
          function average(array2) {
            return array2.reduce(add3, 0) / array2.length;
          }
          function standardDeviation(values2) {
            var avg = average(values2);
            var squareDiffs = values2.map(function(value) {
              var diff = value - avg;
              var sqrDiff = diff * diff;
              return sqrDiff;
            });
            var avgSquareDiff = average(squareDiffs);
            var stdDev = Math.sqrt(avgSquareDiff);
            return stdDev;
          }
          function deepProperty(obj, property, isDeep) {
            if (isDeep === false) {
              return obj[property];
            }
            var pieces = property.split("."), root = obj;
            while (pieces.length > 0) {
              root = root[pieces.shift()];
            }
            return root;
          }
          function binarySearch(array2, item, fun) {
            var lo = 0, hi = array2.length, compared, mid;
            while (lo < hi) {
              mid = lo + hi >> 1;
              compared = fun.apply(null, [item, array2[mid]]);
              if (compared === 0) {
                return {
                  found: true,
                  index: mid
                };
              } else if (compared < 0) {
                hi = mid;
              } else {
                lo = mid + 1;
              }
            }
            return {
              found: false,
              index: hi
            };
          }
          function BSonSort(fun) {
            return function(array2, item) {
              return binarySearch(array2, item, fun);
            };
          }
          function KeyValueStore() {
          }
          KeyValueStore.prototype = {
            keys: [],
            values: [],
            sort: function(a2, b) {
              return a2 < b ? -1 : a2 > b ? 1 : 0;
            },
            setSort: function(fun) {
              this.bs = new BSonSort(fun);
            },
            bs: function() {
              return new BSonSort(this.sort);
            },
            set: function(key, value) {
              var pos = this.bs(this.keys, key);
              if (pos.found) {
                this.values[pos.index] = value;
              } else {
                this.keys.splice(pos.index, 0, key);
                this.values.splice(pos.index, 0, value);
              }
            },
            get: function(key) {
              return this.values[binarySearch(this.keys, key, this.sort).index];
            }
          };
          function UniqueIndex(uniqueField) {
            this.field = uniqueField;
            this.keyMap = /* @__PURE__ */ Object.create(null);
            this.lokiMap = /* @__PURE__ */ Object.create(null);
          }
          UniqueIndex.prototype.keyMap = {};
          UniqueIndex.prototype.lokiMap = {};
          UniqueIndex.prototype.set = function(obj) {
            var fieldValue = obj[this.field];
            if (fieldValue !== null && typeof fieldValue !== "undefined") {
              if (this.keyMap[fieldValue]) {
                throw new Error("Duplicate key for property " + this.field + ": " + fieldValue);
              } else {
                this.keyMap[fieldValue] = obj;
                this.lokiMap[obj.$loki] = fieldValue;
              }
            }
          };
          UniqueIndex.prototype.get = function(key) {
            return this.keyMap[key];
          };
          UniqueIndex.prototype.byId = function(id3) {
            return this.keyMap[this.lokiMap[id3]];
          };
          UniqueIndex.prototype.update = function(obj, doc3) {
            if (this.lokiMap[obj.$loki] !== doc3[this.field]) {
              var old = this.lokiMap[obj.$loki];
              this.set(doc3);
              this.keyMap[old] = void 0;
            } else {
              this.keyMap[obj[this.field]] = doc3;
            }
          };
          UniqueIndex.prototype.remove = function(key) {
            var obj = this.keyMap[key];
            if (obj !== null && typeof obj !== "undefined") {
              this.keyMap[key] = void 0;
              this.lokiMap[obj.$loki] = void 0;
            } else {
              throw new Error("Key is not in unique index: " + this.field);
            }
          };
          UniqueIndex.prototype.clear = function() {
            this.keyMap = /* @__PURE__ */ Object.create(null);
            this.lokiMap = /* @__PURE__ */ Object.create(null);
          };
          function ExactIndex(exactField) {
            this.index = /* @__PURE__ */ Object.create(null);
            this.field = exactField;
          }
          ExactIndex.prototype = {
            set: function add4(key, val) {
              if (this.index[key]) {
                this.index[key].push(val);
              } else {
                this.index[key] = [val];
              }
            },
            remove: function remove2(key, val) {
              var idxSet = this.index[key];
              for (var i in idxSet) {
                if (idxSet[i] == val) {
                  idxSet.splice(i, 1);
                }
              }
              if (idxSet.length < 1) {
                this.index[key] = void 0;
              }
            },
            get: function get4(key) {
              return this.index[key];
            },
            clear: function clear(key) {
              this.index = {};
            }
          };
          function SortedIndex(sortedField) {
            this.field = sortedField;
          }
          SortedIndex.prototype = {
            keys: [],
            values: [],
            sort: function(a2, b) {
              return a2 < b ? -1 : a2 > b ? 1 : 0;
            },
            bs: function() {
              return new BSonSort(this.sort);
            },
            setSort: function(fun) {
              this.bs = new BSonSort(fun);
            },
            set: function(key, value) {
              var pos = binarySearch(this.keys, key, this.sort);
              if (pos.found) {
                this.values[pos.index].push(value);
              } else {
                this.keys.splice(pos.index, 0, key);
                this.values.splice(pos.index, 0, [value]);
              }
            },
            get: function(key) {
              var bsr = binarySearch(this.keys, key, this.sort);
              if (bsr.found) {
                return this.values[bsr.index];
              } else {
                return [];
              }
            },
            getLt: function(key) {
              var bsr = binarySearch(this.keys, key, this.sort);
              var pos = bsr.index;
              if (bsr.found)
                pos--;
              return this.getAll(key, 0, pos);
            },
            getGt: function(key) {
              var bsr = binarySearch(this.keys, key, this.sort);
              var pos = bsr.index;
              if (bsr.found)
                pos++;
              return this.getAll(key, pos, this.keys.length);
            },
            getAll: function(key, start, end) {
              var results = [];
              for (var i = start; i < end; i++) {
                results = results.concat(this.values[i]);
              }
              return results;
            },
            getPos: function(key) {
              return binarySearch(this.keys, key, this.sort);
            },
            remove: function(key, value) {
              var pos = binarySearch(this.keys, key, this.sort).index;
              var idxSet = this.values[pos];
              for (var i in idxSet) {
                if (idxSet[i] == value)
                  idxSet.splice(i, 1);
              }
              if (idxSet.length < 1) {
                this.keys.splice(pos, 1);
                this.values.splice(pos, 1);
              }
            },
            clear: function() {
              this.keys = [];
              this.values = [];
            }
          };
          Loki.deepFreeze = deepFreeze;
          Loki.freeze = freeze;
          Loki.unFreeze = unFreeze;
          Loki.LokiOps = LokiOps;
          Loki.Collection = Collection;
          Loki.DynamicView = DynamicView;
          Loki.Resultset = Resultset;
          Loki.KeyValueStore = KeyValueStore;
          Loki.LokiMemoryAdapter = LokiMemoryAdapter;
          Loki.LokiPartitioningAdapter = LokiPartitioningAdapter;
          Loki.LokiLocalStorageAdapter = LokiLocalStorageAdapter;
          Loki.LokiFsAdapter = LokiFsAdapter;
          Loki.persistenceAdapters = {
            fs: LokiFsAdapter,
            localStorage: LokiLocalStorageAdapter
          };
          Loki.aeq = aeqHelper;
          Loki.lt = ltHelper;
          Loki.gt = gtHelper;
          Loki.Comparators = Comparators;
          return Loki;
        }();
      });
    }
  });

  // node_modules/wheel/index.js
  var require_wheel = __commonJS({
    "node_modules/wheel/index.js"(exports, module2) {
      module2.exports = addWheelListener;
      module2.exports.addWheelListener = addWheelListener;
      module2.exports.removeWheelListener = removeWheelListener;
      function addWheelListener(element2, listener, useCapture) {
        element2.addEventListener("wheel", listener, useCapture);
      }
      function removeWheelListener(element2, listener, useCapture) {
        element2.removeEventListener("wheel", listener, useCapture);
      }
    }
  });

  // node_modules/bezier-easing/src/index.js
  var require_src = __commonJS({
    "node_modules/bezier-easing/src/index.js"(exports, module2) {
      var NEWTON_ITERATIONS = 4;
      var NEWTON_MIN_SLOPE = 1e-3;
      var SUBDIVISION_PRECISION = 1e-7;
      var SUBDIVISION_MAX_ITERATIONS = 10;
      var kSplineTableSize = 11;
      var kSampleStepSize = 1 / (kSplineTableSize - 1);
      var float32ArraySupported = typeof Float32Array === "function";
      function A(aA1, aA2) {
        return 1 - 3 * aA2 + 3 * aA1;
      }
      function B(aA1, aA2) {
        return 3 * aA2 - 6 * aA1;
      }
      function C2(aA1) {
        return 3 * aA1;
      }
      function calcBezier(aT, aA1, aA2) {
        return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C2(aA1)) * aT;
      }
      function getSlope(aT, aA1, aA2) {
        return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C2(aA1);
      }
      function binarySubdivide(aX, aA, aB, mX1, mX2) {
        var currentX, currentT, i = 0;
        do {
          currentT = aA + (aB - aA) / 2;
          currentX = calcBezier(currentT, mX1, mX2) - aX;
          if (currentX > 0) {
            aB = currentT;
          } else {
            aA = currentT;
          }
        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
        return currentT;
      }
      function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
        for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
          var currentSlope = getSlope(aGuessT, mX1, mX2);
          if (currentSlope === 0) {
            return aGuessT;
          }
          var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
          aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
      }
      function LinearEasing(x3) {
        return x3;
      }
      module2.exports = function bezier(mX1, mY1, mX2, mY2) {
        if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
          throw new Error("bezier x values must be in [0, 1] range");
        }
        if (mX1 === mY1 && mX2 === mY2) {
          return LinearEasing;
        }
        var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
        for (var i = 0; i < kSplineTableSize; ++i) {
          sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
        }
        function getTForX(aX) {
          var intervalStart = 0;
          var currentSample = 1;
          var lastSample = kSplineTableSize - 1;
          for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
          }
          --currentSample;
          var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
          var guessForT = intervalStart + dist * kSampleStepSize;
          var initialSlope = getSlope(guessForT, mX1, mX2);
          if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
          } else if (initialSlope === 0) {
            return guessForT;
          } else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
          }
        }
        return function BezierEasing(x3) {
          if (x3 === 0) {
            return 0;
          }
          if (x3 === 1) {
            return 1;
          }
          return calcBezier(getTForX(x3), mY1, mY2);
        };
      };
    }
  });

  // node_modules/amator/index.js
  var require_amator = __commonJS({
    "node_modules/amator/index.js"(exports, module2) {
      var BezierEasing = require_src();
      var animations = {
        ease: BezierEasing(0.25, 0.1, 0.25, 1),
        easeIn: BezierEasing(0.42, 0, 1, 1),
        easeOut: BezierEasing(0, 0, 0.58, 1),
        easeInOut: BezierEasing(0.42, 0, 0.58, 1),
        linear: BezierEasing(0, 0, 1, 1)
      };
      module2.exports = animate;
      module2.exports.makeAggregateRaf = makeAggregateRaf;
      module2.exports.sharedScheduler = makeAggregateRaf();
      function animate(source, target, options) {
        var start = /* @__PURE__ */ Object.create(null);
        var diff = /* @__PURE__ */ Object.create(null);
        options = options || {};
        var easing = typeof options.easing === "function" ? options.easing : animations[options.easing];
        if (!easing) {
          if (options.easing) {
            console.warn("Unknown easing function in amator: " + options.easing);
          }
          easing = animations.ease;
        }
        var step = typeof options.step === "function" ? options.step : noop2;
        var done = typeof options.done === "function" ? options.done : noop2;
        var scheduler = getScheduler(options.scheduler);
        var keys3 = Object.keys(target);
        keys3.forEach(function(key) {
          start[key] = source[key];
          diff[key] = target[key] - source[key];
        });
        var durationInMs = typeof options.duration === "number" ? options.duration : 400;
        var durationInFrames = Math.max(1, durationInMs * 0.06);
        var previousAnimationId;
        var frame2 = 0;
        previousAnimationId = scheduler.next(loop);
        return {
          cancel
        };
        function cancel() {
          scheduler.cancel(previousAnimationId);
          previousAnimationId = 0;
        }
        function loop() {
          var t2 = easing(frame2 / durationInFrames);
          frame2 += 1;
          setValues(t2);
          if (frame2 <= durationInFrames) {
            previousAnimationId = scheduler.next(loop);
            step(source);
          } else {
            previousAnimationId = 0;
            setTimeout(function() {
              done(source);
            }, 0);
          }
        }
        function setValues(t2) {
          keys3.forEach(function(key) {
            source[key] = diff[key] * t2 + start[key];
          });
        }
      }
      function noop2() {
      }
      function getScheduler(scheduler) {
        if (!scheduler) {
          var canRaf = typeof window !== "undefined" && window.requestAnimationFrame;
          return canRaf ? rafScheduler() : timeoutScheduler();
        }
        if (typeof scheduler.next !== "function")
          throw new Error("Scheduler is supposed to have next(cb) function");
        if (typeof scheduler.cancel !== "function")
          throw new Error("Scheduler is supposed to have cancel(handle) function");
        return scheduler;
      }
      function rafScheduler() {
        return {
          next: window.requestAnimationFrame.bind(window),
          cancel: window.cancelAnimationFrame.bind(window)
        };
      }
      function timeoutScheduler() {
        return {
          next: function(cb) {
            return setTimeout(cb, 1e3 / 60);
          },
          cancel: function(id3) {
            return clearTimeout(id3);
          }
        };
      }
      function makeAggregateRaf() {
        var frontBuffer = /* @__PURE__ */ new Set();
        var backBuffer = /* @__PURE__ */ new Set();
        var frameToken = 0;
        return {
          next,
          cancel: next,
          clearAll
        };
        function clearAll() {
          frontBuffer.clear();
          backBuffer.clear();
          cancelAnimationFrame(frameToken);
          frameToken = 0;
        }
        function next(callback) {
          backBuffer.add(callback);
          renderNextFrame();
        }
        function renderNextFrame() {
          if (!frameToken)
            frameToken = requestAnimationFrame(renderFrame);
        }
        function renderFrame() {
          frameToken = 0;
          var t2 = backBuffer;
          backBuffer = frontBuffer;
          frontBuffer = t2;
          frontBuffer.forEach(function(callback) {
            callback();
          });
          frontBuffer.clear();
        }
        function cancel(callback) {
          backBuffer.delete(callback);
        }
      }
    }
  });

  // node_modules/ngraph.events/index.js
  var require_ngraph = __commonJS({
    "node_modules/ngraph.events/index.js"(exports, module2) {
      module2.exports = function eventify(subject) {
        validateSubject(subject);
        var eventsStorage = createEventsStorage(subject);
        subject.on = eventsStorage.on;
        subject.off = eventsStorage.off;
        subject.fire = eventsStorage.fire;
        return subject;
      };
      function createEventsStorage(subject) {
        var registeredEvents = /* @__PURE__ */ Object.create(null);
        return {
          on: function(eventName, callback, ctx) {
            if (typeof callback !== "function") {
              throw new Error("callback is expected to be a function");
            }
            var handlers2 = registeredEvents[eventName];
            if (!handlers2) {
              handlers2 = registeredEvents[eventName] = [];
            }
            handlers2.push({ callback, ctx });
            return subject;
          },
          off: function(eventName, callback) {
            var wantToRemoveAll = typeof eventName === "undefined";
            if (wantToRemoveAll) {
              registeredEvents = /* @__PURE__ */ Object.create(null);
              return subject;
            }
            if (registeredEvents[eventName]) {
              var deleteAllCallbacksForEvent = typeof callback !== "function";
              if (deleteAllCallbacksForEvent) {
                delete registeredEvents[eventName];
              } else {
                var callbacks = registeredEvents[eventName];
                for (var i = 0; i < callbacks.length; ++i) {
                  if (callbacks[i].callback === callback) {
                    callbacks.splice(i, 1);
                  }
                }
              }
            }
            return subject;
          },
          fire: function(eventName) {
            var callbacks = registeredEvents[eventName];
            if (!callbacks) {
              return subject;
            }
            var fireArguments;
            if (arguments.length > 1) {
              fireArguments = Array.prototype.splice.call(arguments, 1);
            }
            for (var i = 0; i < callbacks.length; ++i) {
              var callbackInfo = callbacks[i];
              callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);
            }
            return subject;
          }
        };
      }
      function validateSubject(subject) {
        if (!subject) {
          throw new Error("Eventify cannot use falsy object as events subject");
        }
        var reservedWords = ["on", "fire", "off"];
        for (var i = 0; i < reservedWords.length; ++i) {
          if (subject.hasOwnProperty(reservedWords[i])) {
            throw new Error("Subject cannot be eventified, since it already has property '" + reservedWords[i] + "'");
          }
        }
      }
    }
  });

  // node_modules/panzoom/lib/kinetic.js
  var require_kinetic = __commonJS({
    "node_modules/panzoom/lib/kinetic.js"(exports, module2) {
      module2.exports = kinetic;
      function kinetic(getPoint, scroll, settings) {
        if (typeof settings !== "object") {
          settings = {};
        }
        var minVelocity = typeof settings.minVelocity === "number" ? settings.minVelocity : 5;
        var amplitude = typeof settings.amplitude === "number" ? settings.amplitude : 0.25;
        var cancelAnimationFrame2 = typeof settings.cancelAnimationFrame === "function" ? settings.cancelAnimationFrame : getCancelAnimationFrame();
        var requestAnimationFrame2 = typeof settings.requestAnimationFrame === "function" ? settings.requestAnimationFrame : getRequestAnimationFrame();
        var lastPoint;
        var timestamp;
        var timeConstant = 342;
        var ticker;
        var vx, targetX, ax;
        var vy, targetY, ay;
        var raf;
        return {
          start,
          stop,
          cancel: dispose
        };
        function dispose() {
          cancelAnimationFrame2(ticker);
          cancelAnimationFrame2(raf);
        }
        function start() {
          lastPoint = getPoint();
          ax = ay = vx = vy = 0;
          timestamp = new Date();
          cancelAnimationFrame2(ticker);
          cancelAnimationFrame2(raf);
          ticker = requestAnimationFrame2(track);
        }
        function track() {
          var now3 = Date.now();
          var elapsed = now3 - timestamp;
          timestamp = now3;
          var currentPoint = getPoint();
          var dx = currentPoint.x - lastPoint.x;
          var dy = currentPoint.y - lastPoint.y;
          lastPoint = currentPoint;
          var dt = 1e3 / (1 + elapsed);
          vx = 0.8 * dx * dt + 0.2 * vx;
          vy = 0.8 * dy * dt + 0.2 * vy;
          ticker = requestAnimationFrame2(track);
        }
        function stop() {
          cancelAnimationFrame2(ticker);
          cancelAnimationFrame2(raf);
          var currentPoint = getPoint();
          targetX = currentPoint.x;
          targetY = currentPoint.y;
          timestamp = Date.now();
          if (vx < -minVelocity || vx > minVelocity) {
            ax = amplitude * vx;
            targetX += ax;
          }
          if (vy < -minVelocity || vy > minVelocity) {
            ay = amplitude * vy;
            targetY += ay;
          }
          raf = requestAnimationFrame2(autoScroll);
        }
        function autoScroll() {
          var elapsed = Date.now() - timestamp;
          var moving = false;
          var dx = 0;
          var dy = 0;
          if (ax) {
            dx = -ax * Math.exp(-elapsed / timeConstant);
            if (dx > 0.5 || dx < -0.5)
              moving = true;
            else
              dx = ax = 0;
          }
          if (ay) {
            dy = -ay * Math.exp(-elapsed / timeConstant);
            if (dy > 0.5 || dy < -0.5)
              moving = true;
            else
              dy = ay = 0;
          }
          if (moving) {
            scroll(targetX + dx, targetY + dy);
            raf = requestAnimationFrame2(autoScroll);
          }
        }
      }
      function getCancelAnimationFrame() {
        if (typeof cancelAnimationFrame === "function")
          return cancelAnimationFrame;
        return clearTimeout;
      }
      function getRequestAnimationFrame() {
        if (typeof requestAnimationFrame === "function")
          return requestAnimationFrame;
        return function(handler) {
          return setTimeout(handler, 16);
        };
      }
    }
  });

  // node_modules/panzoom/lib/createTextSelectionInterceptor.js
  var require_createTextSelectionInterceptor = __commonJS({
    "node_modules/panzoom/lib/createTextSelectionInterceptor.js"(exports, module2) {
      module2.exports = createTextSelectionInterceptor;
      function createTextSelectionInterceptor(useFake) {
        if (useFake) {
          return {
            capture: noop2,
            release: noop2
          };
        }
        var dragObject;
        var prevSelectStart;
        var prevDragStart;
        var wasCaptured = false;
        return {
          capture,
          release
        };
        function capture(domObject) {
          wasCaptured = true;
          prevSelectStart = window.document.onselectstart;
          prevDragStart = window.document.ondragstart;
          window.document.onselectstart = disabled;
          dragObject = domObject;
          dragObject.ondragstart = disabled;
        }
        function release() {
          if (!wasCaptured)
            return;
          wasCaptured = false;
          window.document.onselectstart = prevSelectStart;
          if (dragObject)
            dragObject.ondragstart = prevDragStart;
        }
      }
      function disabled(e) {
        e.stopPropagation();
        return false;
      }
      function noop2() {
      }
    }
  });

  // node_modules/panzoom/lib/transform.js
  var require_transform = __commonJS({
    "node_modules/panzoom/lib/transform.js"(exports, module2) {
      module2.exports = Transform;
      function Transform() {
        this.x = 0;
        this.y = 0;
        this.scale = 1;
      }
    }
  });

  // node_modules/panzoom/lib/svgController.js
  var require_svgController = __commonJS({
    "node_modules/panzoom/lib/svgController.js"(exports, module2) {
      module2.exports = makeSvgController;
      module2.exports.canAttach = isSVGElement;
      function makeSvgController(svgElement, options) {
        if (!isSVGElement(svgElement)) {
          throw new Error("svg element is required for svg.panzoom to work");
        }
        var owner = svgElement.ownerSVGElement;
        if (!owner) {
          throw new Error(
            "Do not apply panzoom to the root <svg> element. Use its child instead (e.g. <g></g>). As of March 2016 only FireFox supported transform on the root element"
          );
        }
        if (!options.disableKeyboardInteraction) {
          owner.setAttribute("tabindex", 0);
        }
        var api = {
          getBBox,
          getScreenCTM,
          getOwner,
          applyTransform,
          initTransform
        };
        return api;
        function getOwner() {
          return owner;
        }
        function getBBox() {
          var bbox = svgElement.getBBox();
          return {
            left: bbox.x,
            top: bbox.y,
            width: bbox.width,
            height: bbox.height
          };
        }
        function getScreenCTM() {
          var ctm = owner.getCTM();
          if (!ctm) {
            return owner.getScreenCTM();
          }
          return ctm;
        }
        function initTransform(transform) {
          var screenCTM = svgElement.getCTM();
          if (screenCTM === null) {
            screenCTM = document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGMatrix();
          }
          transform.x = screenCTM.e;
          transform.y = screenCTM.f;
          transform.scale = screenCTM.a;
          owner.removeAttributeNS(null, "viewBox");
        }
        function applyTransform(transform) {
          svgElement.setAttribute("transform", "matrix(" + transform.scale + " 0 0 " + transform.scale + " " + transform.x + " " + transform.y + ")");
        }
      }
      function isSVGElement(element2) {
        return element2 && element2.ownerSVGElement && element2.getCTM;
      }
    }
  });

  // node_modules/panzoom/lib/domController.js
  var require_domController = __commonJS({
    "node_modules/panzoom/lib/domController.js"(exports, module2) {
      module2.exports = makeDomController;
      module2.exports.canAttach = isDomElement;
      function makeDomController(domElement, options) {
        var elementValid = isDomElement(domElement);
        if (!elementValid) {
          throw new Error("panzoom requires DOM element to be attached to the DOM tree");
        }
        var owner = domElement.parentElement;
        domElement.scrollTop = 0;
        if (!options.disableKeyboardInteraction) {
          owner.setAttribute("tabindex", 0);
        }
        var api = {
          getBBox,
          getOwner,
          applyTransform
        };
        return api;
        function getOwner() {
          return owner;
        }
        function getBBox() {
          return {
            left: 0,
            top: 0,
            width: domElement.clientWidth,
            height: domElement.clientHeight
          };
        }
        function applyTransform(transform) {
          domElement.style.transformOrigin = "0 0 0";
          domElement.style.transform = "matrix(" + transform.scale + ", 0, 0, " + transform.scale + ", " + transform.x + ", " + transform.y + ")";
        }
      }
      function isDomElement(element2) {
        return element2 && element2.parentElement && element2.style;
      }
    }
  });

  // node_modules/panzoom/index.js
  var require_panzoom = __commonJS({
    "node_modules/panzoom/index.js"(exports, module2) {
      "use strict";
      var wheel = require_wheel();
      var animate = require_amator();
      var eventify = require_ngraph();
      var kinetic = require_kinetic();
      var createTextSelectionInterceptor = require_createTextSelectionInterceptor();
      var domTextSelectionInterceptor = createTextSelectionInterceptor();
      var fakeTextSelectorInterceptor = createTextSelectionInterceptor(true);
      var Transform = require_transform();
      var makeSvgController = require_svgController();
      var makeDomController = require_domController();
      var defaultZoomSpeed = 1;
      var defaultDoubleTapZoomSpeed = 1.75;
      var doubleTapSpeedInMS = 300;
      var clickEventTimeInMS = 200;
      module2.exports = createPanZoom;
      function createPanZoom(domElement, options) {
        options = options || {};
        var panController = options.controller;
        if (!panController) {
          if (makeSvgController.canAttach(domElement)) {
            panController = makeSvgController(domElement, options);
          } else if (makeDomController.canAttach(domElement)) {
            panController = makeDomController(domElement, options);
          }
        }
        if (!panController) {
          throw new Error(
            "Cannot create panzoom for the current type of dom element"
          );
        }
        var owner = panController.getOwner();
        var storedCTMResult = { x: 0, y: 0 };
        var isDirty = false;
        var transform = new Transform();
        if (panController.initTransform) {
          panController.initTransform(transform);
        }
        var filterKey = typeof options.filterKey === "function" ? options.filterKey : noop2;
        var pinchSpeed = typeof options.pinchSpeed === "number" ? options.pinchSpeed : 1;
        var bounds = options.bounds;
        var maxZoom = typeof options.maxZoom === "number" ? options.maxZoom : Number.POSITIVE_INFINITY;
        var minZoom = typeof options.minZoom === "number" ? options.minZoom : 0;
        var boundsPadding = typeof options.boundsPadding === "number" ? options.boundsPadding : 0.05;
        var zoomDoubleClickSpeed = typeof options.zoomDoubleClickSpeed === "number" ? options.zoomDoubleClickSpeed : defaultDoubleTapZoomSpeed;
        var beforeWheel = options.beforeWheel || noop2;
        var beforeMouseDown = options.beforeMouseDown || noop2;
        var speed = typeof options.zoomSpeed === "number" ? options.zoomSpeed : defaultZoomSpeed;
        var transformOrigin = parseTransformOrigin(options.transformOrigin);
        var textSelection = options.enableTextSelection ? fakeTextSelectorInterceptor : domTextSelectionInterceptor;
        validateBounds(bounds);
        if (options.autocenter) {
          autocenter();
        }
        var frameAnimation;
        var lastTouchEndTime = 0;
        var lastTouchStartTime = 0;
        var pendingClickEventTimeout = 0;
        var lastMouseDownedEvent = null;
        var lastMouseDownTime2 = new Date();
        var lastSingleFingerOffset;
        var touchInProgress = false;
        var panstartFired = false;
        var mouseX;
        var mouseY;
        var clickX;
        var clickY;
        var pinchZoomLength;
        var smoothScroll;
        if ("smoothScroll" in options && !options.smoothScroll) {
          smoothScroll = rigidScroll();
        } else {
          smoothScroll = kinetic(getPoint, scroll, options.smoothScroll);
        }
        var moveByAnimation;
        var zoomToAnimation;
        var multiTouch;
        var paused = false;
        listenForEvents();
        var api = {
          dispose,
          moveBy: internalMoveBy,
          moveTo,
          smoothMoveTo,
          centerOn,
          zoomTo: publicZoomTo,
          zoomAbs,
          smoothZoom,
          smoothZoomAbs,
          showRectangle,
          pause,
          resume,
          isPaused,
          getTransform: getTransformModel,
          getMinZoom,
          setMinZoom,
          getMaxZoom,
          setMaxZoom,
          getTransformOrigin,
          setTransformOrigin,
          getZoomSpeed,
          setZoomSpeed
        };
        eventify(api);
        var initialX = typeof options.initialX === "number" ? options.initialX : transform.x;
        var initialY = typeof options.initialY === "number" ? options.initialY : transform.y;
        var initialZoom = typeof options.initialZoom === "number" ? options.initialZoom : transform.scale;
        if (initialX != transform.x || initialY != transform.y || initialZoom != transform.scale) {
          zoomAbs(initialX, initialY, initialZoom);
        }
        return api;
        function pause() {
          releaseEvents();
          paused = true;
        }
        function resume() {
          if (paused) {
            listenForEvents();
            paused = false;
          }
        }
        function isPaused() {
          return paused;
        }
        function showRectangle(rect) {
          var clientRect = owner.getBoundingClientRect();
          var size = transformToScreen(clientRect.width, clientRect.height);
          var rectWidth = rect.right - rect.left;
          var rectHeight = rect.bottom - rect.top;
          if (!Number.isFinite(rectWidth) || !Number.isFinite(rectHeight)) {
            throw new Error("Invalid rectangle");
          }
          var dw = size.x / rectWidth;
          var dh = size.y / rectHeight;
          var scale = Math.min(dw, dh);
          transform.x = -(rect.left + rectWidth / 2) * scale + size.x / 2;
          transform.y = -(rect.top + rectHeight / 2) * scale + size.y / 2;
          transform.scale = scale;
        }
        function transformToScreen(x3, y3) {
          if (panController.getScreenCTM) {
            var parentCTM = panController.getScreenCTM();
            var parentScaleX = parentCTM.a;
            var parentScaleY = parentCTM.d;
            var parentOffsetX = parentCTM.e;
            var parentOffsetY = parentCTM.f;
            storedCTMResult.x = x3 * parentScaleX - parentOffsetX;
            storedCTMResult.y = y3 * parentScaleY - parentOffsetY;
          } else {
            storedCTMResult.x = x3;
            storedCTMResult.y = y3;
          }
          return storedCTMResult;
        }
        function autocenter() {
          var w;
          var h2;
          var left = 0;
          var top2 = 0;
          var sceneBoundingBox = getBoundingBox();
          if (sceneBoundingBox) {
            left = sceneBoundingBox.left;
            top2 = sceneBoundingBox.top;
            w = sceneBoundingBox.right - sceneBoundingBox.left;
            h2 = sceneBoundingBox.bottom - sceneBoundingBox.top;
          } else {
            var ownerRect = owner.getBoundingClientRect();
            w = ownerRect.width;
            h2 = ownerRect.height;
          }
          var bbox = panController.getBBox();
          if (bbox.width === 0 || bbox.height === 0) {
            return;
          }
          var dh = h2 / bbox.height;
          var dw = w / bbox.width;
          var scale = Math.min(dw, dh);
          transform.x = -(bbox.left + bbox.width / 2) * scale + w / 2 + left;
          transform.y = -(bbox.top + bbox.height / 2) * scale + h2 / 2 + top2;
          transform.scale = scale;
        }
        function getTransformModel() {
          return transform;
        }
        function getMinZoom() {
          return minZoom;
        }
        function setMinZoom(newMinZoom) {
          minZoom = newMinZoom;
        }
        function getMaxZoom() {
          return maxZoom;
        }
        function setMaxZoom(newMaxZoom) {
          maxZoom = newMaxZoom;
        }
        function getTransformOrigin() {
          return transformOrigin;
        }
        function setTransformOrigin(newTransformOrigin) {
          transformOrigin = parseTransformOrigin(newTransformOrigin);
        }
        function getZoomSpeed() {
          return speed;
        }
        function setZoomSpeed(newSpeed) {
          if (!Number.isFinite(newSpeed)) {
            throw new Error("Zoom speed should be a number");
          }
          speed = newSpeed;
        }
        function getPoint() {
          return {
            x: transform.x,
            y: transform.y
          };
        }
        function moveTo(x3, y3) {
          transform.x = x3;
          transform.y = y3;
          keepTransformInsideBounds();
          triggerEvent("pan");
          makeDirty();
        }
        function moveBy(dx, dy) {
          moveTo(transform.x + dx, transform.y + dy);
        }
        function keepTransformInsideBounds() {
          var boundingBox = getBoundingBox();
          if (!boundingBox)
            return;
          var adjusted = false;
          var clientRect = getClientRect();
          var diff = boundingBox.left - clientRect.right;
          if (diff > 0) {
            transform.x += diff;
            adjusted = true;
          }
          diff = boundingBox.right - clientRect.left;
          if (diff < 0) {
            transform.x += diff;
            adjusted = true;
          }
          diff = boundingBox.top - clientRect.bottom;
          if (diff > 0) {
            transform.y += diff;
            adjusted = true;
          }
          diff = boundingBox.bottom - clientRect.top;
          if (diff < 0) {
            transform.y += diff;
            adjusted = true;
          }
          return adjusted;
        }
        function getBoundingBox() {
          if (!bounds)
            return;
          if (typeof bounds === "boolean") {
            var ownerRect = owner.getBoundingClientRect();
            var sceneWidth = ownerRect.width;
            var sceneHeight = ownerRect.height;
            return {
              left: sceneWidth * boundsPadding,
              top: sceneHeight * boundsPadding,
              right: sceneWidth * (1 - boundsPadding),
              bottom: sceneHeight * (1 - boundsPadding)
            };
          }
          return bounds;
        }
        function getClientRect() {
          var bbox = panController.getBBox();
          var leftTop = client(bbox.left, bbox.top);
          return {
            left: leftTop.x,
            top: leftTop.y,
            right: bbox.width * transform.scale + leftTop.x,
            bottom: bbox.height * transform.scale + leftTop.y
          };
        }
        function client(x3, y3) {
          return {
            x: x3 * transform.scale + transform.x,
            y: y3 * transform.scale + transform.y
          };
        }
        function makeDirty() {
          isDirty = true;
          frameAnimation = window.requestAnimationFrame(frame2);
        }
        function zoomByRatio(clientX, clientY, ratio) {
          if (isNaN4(clientX) || isNaN4(clientY) || isNaN4(ratio)) {
            throw new Error("zoom requires valid numbers");
          }
          var newScale = transform.scale * ratio;
          if (newScale < minZoom) {
            if (transform.scale === minZoom)
              return;
            ratio = minZoom / transform.scale;
          }
          if (newScale > maxZoom) {
            if (transform.scale === maxZoom)
              return;
            ratio = maxZoom / transform.scale;
          }
          var size = transformToScreen(clientX, clientY);
          transform.x = size.x - ratio * (size.x - transform.x);
          transform.y = size.y - ratio * (size.y - transform.y);
          if (bounds && boundsPadding === 1 && minZoom === 1) {
            transform.scale *= ratio;
            keepTransformInsideBounds();
          } else {
            var transformAdjusted = keepTransformInsideBounds();
            if (!transformAdjusted)
              transform.scale *= ratio;
          }
          triggerEvent("zoom");
          makeDirty();
        }
        function zoomAbs(clientX, clientY, zoomLevel) {
          var ratio = zoomLevel / transform.scale;
          zoomByRatio(clientX, clientY, ratio);
        }
        function centerOn(ui) {
          var parent = ui.ownerSVGElement;
          if (!parent)
            throw new Error("ui element is required to be within the scene");
          var clientRect = ui.getBoundingClientRect();
          var cx = clientRect.left + clientRect.width / 2;
          var cy = clientRect.top + clientRect.height / 2;
          var container = parent.getBoundingClientRect();
          var dx = container.width / 2 - cx;
          var dy = container.height / 2 - cy;
          internalMoveBy(dx, dy, true);
        }
        function smoothMoveTo(x3, y3) {
          internalMoveBy(x3 - transform.x, y3 - transform.y, true);
        }
        function internalMoveBy(dx, dy, smooth) {
          if (!smooth) {
            return moveBy(dx, dy);
          }
          if (moveByAnimation)
            moveByAnimation.cancel();
          var from3 = { x: 0, y: 0 };
          var to = { x: dx, y: dy };
          var lastX = 0;
          var lastY = 0;
          moveByAnimation = animate(from3, to, {
            step: function(v) {
              moveBy(v.x - lastX, v.y - lastY);
              lastX = v.x;
              lastY = v.y;
            }
          });
        }
        function scroll(x3, y3) {
          cancelZoomAnimation();
          moveTo(x3, y3);
        }
        function dispose() {
          releaseEvents();
        }
        function listenForEvents() {
          owner.addEventListener("mousedown", onMouseDown, { passive: false });
          owner.addEventListener("dblclick", onDoubleClick, { passive: false });
          owner.addEventListener("touchstart", onTouch, { passive: false });
          owner.addEventListener("keydown", onKeyDown, { passive: false });
          wheel.addWheelListener(owner, onMouseWheel, { passive: false });
          makeDirty();
        }
        function releaseEvents() {
          wheel.removeWheelListener(owner, onMouseWheel);
          owner.removeEventListener("mousedown", onMouseDown);
          owner.removeEventListener("keydown", onKeyDown);
          owner.removeEventListener("dblclick", onDoubleClick);
          owner.removeEventListener("touchstart", onTouch);
          if (frameAnimation) {
            window.cancelAnimationFrame(frameAnimation);
            frameAnimation = 0;
          }
          smoothScroll.cancel();
          releaseDocumentMouse();
          releaseTouches();
          textSelection.release();
          triggerPanEnd();
        }
        function frame2() {
          if (isDirty)
            applyTransform();
        }
        function applyTransform() {
          isDirty = false;
          panController.applyTransform(transform);
          triggerEvent("transform");
          frameAnimation = 0;
        }
        function onKeyDown(e) {
          var x3 = 0, y3 = 0, z = 0;
          if (e.keyCode === 38) {
            y3 = 1;
          } else if (e.keyCode === 40) {
            y3 = -1;
          } else if (e.keyCode === 37) {
            x3 = 1;
          } else if (e.keyCode === 39) {
            x3 = -1;
          } else if (e.keyCode === 189 || e.keyCode === 109) {
            z = 1;
          } else if (e.keyCode === 187 || e.keyCode === 107) {
            z = -1;
          }
          if (filterKey(e, x3, y3, z)) {
            return;
          }
          if (x3 || y3) {
            e.preventDefault();
            e.stopPropagation();
            var clientRect = owner.getBoundingClientRect();
            var offset = Math.min(clientRect.width, clientRect.height);
            var moveSpeedRatio = 0.05;
            var dx = offset * moveSpeedRatio * x3;
            var dy = offset * moveSpeedRatio * y3;
            internalMoveBy(dx, dy);
          }
          if (z) {
            var scaleMultiplier = getScaleMultiplier(z * 100);
            var offset = transformOrigin ? getTransformOriginOffset() : midPoint();
            publicZoomTo(offset.x, offset.y, scaleMultiplier);
          }
        }
        function midPoint() {
          var ownerRect = owner.getBoundingClientRect();
          return {
            x: ownerRect.width / 2,
            y: ownerRect.height / 2
          };
        }
        function onTouch(e) {
          beforeTouch(e);
          clearPendingClickEventTimeout();
          if (e.touches.length === 1) {
            return handleSingleFingerTouch(e, e.touches[0]);
          } else if (e.touches.length === 2) {
            pinchZoomLength = getPinchZoomLength(e.touches[0], e.touches[1]);
            multiTouch = true;
            startTouchListenerIfNeeded();
          }
        }
        function beforeTouch(e) {
          if (options.onTouch && !options.onTouch(e)) {
            return;
          }
          e.stopPropagation();
          e.preventDefault();
        }
        function beforeDoubleClick(e) {
          clearPendingClickEventTimeout();
          if (options.onDoubleClick && !options.onDoubleClick(e)) {
            return;
          }
          e.preventDefault();
          e.stopPropagation();
        }
        function handleSingleFingerTouch(e) {
          lastTouchStartTime = new Date();
          var touch = e.touches[0];
          var offset = getOffsetXY(touch);
          lastSingleFingerOffset = offset;
          var point = transformToScreen(offset.x, offset.y);
          mouseX = point.x;
          mouseY = point.y;
          clickX = mouseX;
          clickY = mouseY;
          smoothScroll.cancel();
          startTouchListenerIfNeeded();
        }
        function startTouchListenerIfNeeded() {
          if (touchInProgress) {
            return;
          }
          touchInProgress = true;
          document.addEventListener("touchmove", handleTouchMove);
          document.addEventListener("touchend", handleTouchEnd);
          document.addEventListener("touchcancel", handleTouchEnd);
        }
        function handleTouchMove(e) {
          if (e.touches.length === 1) {
            e.stopPropagation();
            var touch = e.touches[0];
            var offset = getOffsetXY(touch);
            var point = transformToScreen(offset.x, offset.y);
            var dx = point.x - mouseX;
            var dy = point.y - mouseY;
            if (dx !== 0 && dy !== 0) {
              triggerPanStart();
            }
            mouseX = point.x;
            mouseY = point.y;
            internalMoveBy(dx, dy);
          } else if (e.touches.length === 2) {
            multiTouch = true;
            var t1 = e.touches[0];
            var t2 = e.touches[1];
            var currentPinchLength = getPinchZoomLength(t1, t2);
            var scaleMultiplier = 1 + (currentPinchLength / pinchZoomLength - 1) * pinchSpeed;
            var firstTouchPoint = getOffsetXY(t1);
            var secondTouchPoint = getOffsetXY(t2);
            mouseX = (firstTouchPoint.x + secondTouchPoint.x) / 2;
            mouseY = (firstTouchPoint.y + secondTouchPoint.y) / 2;
            if (transformOrigin) {
              var offset = getTransformOriginOffset();
              mouseX = offset.x;
              mouseY = offset.y;
            }
            publicZoomTo(mouseX, mouseY, scaleMultiplier);
            pinchZoomLength = currentPinchLength;
            e.stopPropagation();
            e.preventDefault();
          }
        }
        function clearPendingClickEventTimeout() {
          if (pendingClickEventTimeout) {
            clearTimeout(pendingClickEventTimeout);
            pendingClickEventTimeout = 0;
          }
        }
        function handlePotentialClickEvent(e) {
          if (!options.onClick)
            return;
          clearPendingClickEventTimeout();
          var dx = mouseX - clickX;
          var dy = mouseY - clickY;
          var l = Math.sqrt(dx * dx + dy * dy);
          if (l > 5)
            return;
          pendingClickEventTimeout = setTimeout(function() {
            pendingClickEventTimeout = 0;
            options.onClick(e);
          }, doubleTapSpeedInMS);
        }
        function handleTouchEnd(e) {
          clearPendingClickEventTimeout();
          if (e.touches.length > 0) {
            var offset = getOffsetXY(e.touches[0]);
            var point = transformToScreen(offset.x, offset.y);
            mouseX = point.x;
            mouseY = point.y;
          } else {
            var now3 = new Date();
            if (now3 - lastTouchEndTime < doubleTapSpeedInMS) {
              if (transformOrigin) {
                var offset = getTransformOriginOffset();
                smoothZoom(offset.x, offset.y, zoomDoubleClickSpeed);
              } else {
                smoothZoom(lastSingleFingerOffset.x, lastSingleFingerOffset.y, zoomDoubleClickSpeed);
              }
            } else if (now3 - lastTouchStartTime < clickEventTimeInMS) {
              handlePotentialClickEvent(e);
            }
            lastTouchEndTime = now3;
            triggerPanEnd();
            releaseTouches();
          }
        }
        function getPinchZoomLength(finger1, finger2) {
          var dx = finger1.clientX - finger2.clientX;
          var dy = finger1.clientY - finger2.clientY;
          return Math.sqrt(dx * dx + dy * dy);
        }
        function onDoubleClick(e) {
          beforeDoubleClick(e);
          var offset = getOffsetXY(e);
          if (transformOrigin) {
            offset = getTransformOriginOffset();
          }
          smoothZoom(offset.x, offset.y, zoomDoubleClickSpeed);
        }
        function onMouseDown(e) {
          clearPendingClickEventTimeout();
          if (beforeMouseDown(e))
            return;
          lastMouseDownedEvent = e;
          lastMouseDownTime2 = new Date();
          if (touchInProgress) {
            e.stopPropagation();
            return false;
          }
          var isLeftButton = e.button === 1 && window.event !== null || e.button === 0;
          if (!isLeftButton)
            return;
          smoothScroll.cancel();
          var offset = getOffsetXY(e);
          var point = transformToScreen(offset.x, offset.y);
          clickX = mouseX = point.x;
          clickY = mouseY = point.y;
          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", onMouseUp);
          textSelection.capture(e.target || e.srcElement);
          return false;
        }
        function onMouseMove(e) {
          if (touchInProgress)
            return;
          triggerPanStart();
          var offset = getOffsetXY(e);
          var point = transformToScreen(offset.x, offset.y);
          var dx = point.x - mouseX;
          var dy = point.y - mouseY;
          mouseX = point.x;
          mouseY = point.y;
          internalMoveBy(dx, dy);
        }
        function onMouseUp() {
          var now3 = new Date();
          if (now3 - lastMouseDownTime2 < clickEventTimeInMS)
            handlePotentialClickEvent(lastMouseDownedEvent);
          textSelection.release();
          triggerPanEnd();
          releaseDocumentMouse();
        }
        function releaseDocumentMouse() {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
          panstartFired = false;
        }
        function releaseTouches() {
          document.removeEventListener("touchmove", handleTouchMove);
          document.removeEventListener("touchend", handleTouchEnd);
          document.removeEventListener("touchcancel", handleTouchEnd);
          panstartFired = false;
          multiTouch = false;
          touchInProgress = false;
        }
        function onMouseWheel(e) {
          if (beforeWheel(e))
            return;
          smoothScroll.cancel();
          var delta = e.deltaY;
          if (e.deltaMode > 0)
            delta *= 100;
          var scaleMultiplier = getScaleMultiplier(delta);
          if (scaleMultiplier !== 1) {
            var offset = transformOrigin ? getTransformOriginOffset() : getOffsetXY(e);
            publicZoomTo(offset.x, offset.y, scaleMultiplier);
            e.preventDefault();
          }
        }
        function getOffsetXY(e) {
          var offsetX, offsetY;
          var ownerRect = owner.getBoundingClientRect();
          offsetX = e.clientX - ownerRect.left;
          offsetY = e.clientY - ownerRect.top;
          return { x: offsetX, y: offsetY };
        }
        function smoothZoom(clientX, clientY, scaleMultiplier) {
          var fromValue = transform.scale;
          var from3 = { scale: fromValue };
          var to = { scale: scaleMultiplier * fromValue };
          smoothScroll.cancel();
          cancelZoomAnimation();
          zoomToAnimation = animate(from3, to, {
            step: function(v) {
              zoomAbs(clientX, clientY, v.scale);
            },
            done: triggerZoomEnd
          });
        }
        function smoothZoomAbs(clientX, clientY, toScaleValue) {
          var fromValue = transform.scale;
          var from3 = { scale: fromValue };
          var to = { scale: toScaleValue };
          smoothScroll.cancel();
          cancelZoomAnimation();
          zoomToAnimation = animate(from3, to, {
            step: function(v) {
              zoomAbs(clientX, clientY, v.scale);
            }
          });
        }
        function getTransformOriginOffset() {
          var ownerRect = owner.getBoundingClientRect();
          return {
            x: ownerRect.width * transformOrigin.x,
            y: ownerRect.height * transformOrigin.y
          };
        }
        function publicZoomTo(clientX, clientY, scaleMultiplier) {
          smoothScroll.cancel();
          cancelZoomAnimation();
          return zoomByRatio(clientX, clientY, scaleMultiplier);
        }
        function cancelZoomAnimation() {
          if (zoomToAnimation) {
            zoomToAnimation.cancel();
            zoomToAnimation = null;
          }
        }
        function getScaleMultiplier(delta) {
          var sign = Math.sign(delta);
          var deltaAdjustedSpeed = Math.min(0.25, Math.abs(speed * delta / 128));
          return 1 - sign * deltaAdjustedSpeed;
        }
        function triggerPanStart() {
          if (!panstartFired) {
            triggerEvent("panstart");
            panstartFired = true;
            smoothScroll.start();
          }
        }
        function triggerPanEnd() {
          if (panstartFired) {
            if (!multiTouch)
              smoothScroll.stop();
            triggerEvent("panend");
          }
        }
        function triggerZoomEnd() {
          triggerEvent("zoomend");
        }
        function triggerEvent(name2) {
          api.fire(name2, api);
        }
      }
      function parseTransformOrigin(options) {
        if (!options)
          return;
        if (typeof options === "object") {
          if (!isNumber2(options.x) || !isNumber2(options.y))
            failTransformOrigin(options);
          return options;
        }
        failTransformOrigin();
      }
      function failTransformOrigin(options) {
        console.error(options);
        throw new Error(
          [
            "Cannot parse transform origin.",
            "Some good examples:",
            '  "center center" can be achieved with {x: 0.5, y: 0.5}',
            '  "top center" can be achieved with {x: 0.5, y: 0}',
            '  "bottom right" can be achieved with {x: 1, y: 1}'
          ].join("\n")
        );
      }
      function noop2() {
      }
      function validateBounds(bounds) {
        var boundsType = typeof bounds;
        if (boundsType === "undefined" || boundsType === "boolean")
          return;
        var validBounds = isNumber2(bounds.left) && isNumber2(bounds.top) && isNumber2(bounds.bottom) && isNumber2(bounds.right);
        if (!validBounds)
          throw new Error(
            "Bounds object is not valid. It can be: undefined, boolean (true|false) or an object {left, top, right, bottom}"
          );
      }
      function isNumber2(x3) {
        return Number.isFinite(x3);
      }
      function isNaN4(value) {
        if (Number.isNaN) {
          return Number.isNaN(value);
        }
        return value !== value;
      }
      function rigidScroll() {
        return {
          start: noop2,
          stop: noop2,
          cancel: noop2
        };
      }
      function autoRun() {
        if (typeof document === "undefined")
          return;
        var scripts = document.getElementsByTagName("script");
        if (!scripts)
          return;
        var panzoomScript;
        for (var i = 0; i < scripts.length; ++i) {
          var x3 = scripts[i];
          if (x3.src && x3.src.match(/\bpanzoom(\.min)?\.js/)) {
            panzoomScript = x3;
            break;
          }
        }
        if (!panzoomScript)
          return;
        var query = panzoomScript.getAttribute("query");
        if (!query)
          return;
        var globalName = panzoomScript.getAttribute("name") || "pz";
        var started = Date.now();
        tryAttach();
        function tryAttach() {
          var el = document.querySelector(query);
          if (!el) {
            var now3 = Date.now();
            var elapsed = now3 - started;
            if (elapsed < 2e3) {
              setTimeout(tryAttach, 100);
              return;
            }
            console.error("Cannot find the panzoom element", globalName);
            return;
          }
          var options = collectOptions(panzoomScript);
          console.log(options);
          window[globalName] = createPanZoom(el, options);
        }
        function collectOptions(script) {
          var attrs = script.attributes;
          var options = {};
          for (var j = 0; j < attrs.length; ++j) {
            var attr = attrs[j];
            var nameValue = getPanzoomAttributeNameValue(attr);
            if (nameValue) {
              options[nameValue.name] = nameValue.value;
            }
          }
          return options;
        }
        function getPanzoomAttributeNameValue(attr) {
          if (!attr.name)
            return;
          var isPanZoomAttribute = attr.name[0] === "p" && attr.name[1] === "z" && attr.name[2] === "-";
          if (!isPanZoomAttribute)
            return;
          var name2 = attr.name.substr(3);
          var value = JSON.parse(attr.value);
          return { name: name2, value };
        }
      }
      autoRun();
    }
  });

  // node_modules/simple-peer/simplepeer.min.js
  var require_simplepeer_min = __commonJS({
    "node_modules/simple-peer/simplepeer.min.js"(exports, module2) {
      (function(e) {
        if ("object" == typeof exports && "undefined" != typeof module2)
          module2.exports = e();
        else if ("function" == typeof define && define.amd)
          define([], e);
        else {
          var t2;
          t2 = "undefined" == typeof window ? "undefined" == typeof global ? "undefined" == typeof self ? this : self : global : window, t2.SimplePeer = e();
        }
      })(function() {
        var t2 = Math.floor, n2 = Math.abs, r = Math.pow;
        return function() {
          function d(s, e, n3) {
            function t3(o, i) {
              if (!e[o]) {
                if (!s[o]) {
                  var l = "function" == typeof __require && __require;
                  if (!i && l)
                    return l(o, true);
                  if (r2)
                    return r2(o, true);
                  var c2 = new Error("Cannot find module '" + o + "'");
                  throw c2.code = "MODULE_NOT_FOUND", c2;
                }
                var a3 = e[o] = { exports: {} };
                s[o][0].call(a3.exports, function(e2) {
                  var r3 = s[o][1][e2];
                  return t3(r3 || e2);
                }, a3, a3.exports, d, s, e, n3);
              }
              return e[o].exports;
            }
            for (var r2 = "function" == typeof __require && __require, a2 = 0; a2 < n3.length; a2++)
              t3(n3[a2]);
            return t3;
          }
          return d;
        }()({ 1: [function(e, t3, n3) {
          "use strict";
          function r2(e2) {
            var t4 = e2.length;
            if (0 < t4 % 4)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var n4 = e2.indexOf("=");
            -1 === n4 && (n4 = t4);
            var r3 = n4 === t4 ? 0 : 4 - n4 % 4;
            return [n4, r3];
          }
          function a2(e2, t4, n4) {
            return 3 * (t4 + n4) / 4 - n4;
          }
          function o(e2) {
            var t4, n4, o2 = r2(e2), d2 = o2[0], s2 = o2[1], l2 = new p(a2(e2, d2, s2)), c3 = 0, f2 = 0 < s2 ? d2 - 4 : d2;
            for (n4 = 0; n4 < f2; n4 += 4)
              t4 = u[e2.charCodeAt(n4)] << 18 | u[e2.charCodeAt(n4 + 1)] << 12 | u[e2.charCodeAt(n4 + 2)] << 6 | u[e2.charCodeAt(n4 + 3)], l2[c3++] = 255 & t4 >> 16, l2[c3++] = 255 & t4 >> 8, l2[c3++] = 255 & t4;
            return 2 === s2 && (t4 = u[e2.charCodeAt(n4)] << 2 | u[e2.charCodeAt(n4 + 1)] >> 4, l2[c3++] = 255 & t4), 1 === s2 && (t4 = u[e2.charCodeAt(n4)] << 10 | u[e2.charCodeAt(n4 + 1)] << 4 | u[e2.charCodeAt(n4 + 2)] >> 2, l2[c3++] = 255 & t4 >> 8, l2[c3++] = 255 & t4), l2;
          }
          function d(e2) {
            return c2[63 & e2 >> 18] + c2[63 & e2 >> 12] + c2[63 & e2 >> 6] + c2[63 & e2];
          }
          function s(e2, t4, n4) {
            for (var r3, a3 = [], o2 = t4; o2 < n4; o2 += 3)
              r3 = (16711680 & e2[o2] << 16) + (65280 & e2[o2 + 1] << 8) + (255 & e2[o2 + 2]), a3.push(d(r3));
            return a3.join("");
          }
          function l(e2) {
            for (var t4, n4 = e2.length, r3 = n4 % 3, a3 = [], o2 = 16383, d2 = 0, l2 = n4 - r3; d2 < l2; d2 += o2)
              a3.push(s(e2, d2, d2 + o2 > l2 ? l2 : d2 + o2));
            return 1 === r3 ? (t4 = e2[n4 - 1], a3.push(c2[t4 >> 2] + c2[63 & t4 << 4] + "==")) : 2 === r3 && (t4 = (e2[n4 - 2] << 8) + e2[n4 - 1], a3.push(c2[t4 >> 10] + c2[63 & t4 >> 4] + c2[63 & t4 << 2] + "=")), a3.join("");
          }
          n3.byteLength = function(e2) {
            var t4 = r2(e2), n4 = t4[0], a3 = t4[1];
            return 3 * (n4 + a3) / 4 - a3;
          }, n3.toByteArray = o, n3.fromByteArray = l;
          for (var c2 = [], u = [], p = "undefined" == typeof Uint8Array ? Array : Uint8Array, f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", g = 0, _ = f.length; g < _; ++g)
            c2[g] = f[g], u[f.charCodeAt(g)] = g;
          u[45] = 62, u[95] = 63;
        }, {}], 2: [function() {
        }, {}], 3: [function(e, t3, n3) {
          (function() {
            (function() {
              "use strict";
              var t4 = String.fromCharCode, o = Math.min;
              function d(e2) {
                if (2147483647 < e2)
                  throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
                var t5 = new Uint8Array(e2);
                return t5.__proto__ = s.prototype, t5;
              }
              function s(e2, t5, n4) {
                if ("number" == typeof e2) {
                  if ("string" == typeof t5)
                    throw new TypeError('The "string" argument must be of type string. Received type number');
                  return p(e2);
                }
                return l(e2, t5, n4);
              }
              function l(e2, t5, n4) {
                if ("string" == typeof e2)
                  return f(e2, t5);
                if (ArrayBuffer.isView(e2))
                  return g(e2);
                if (null == e2)
                  throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
                if (K(e2, ArrayBuffer) || e2 && K(e2.buffer, ArrayBuffer))
                  return _(e2, t5, n4);
                if ("number" == typeof e2)
                  throw new TypeError('The "value" argument must not be of type number. Received type number');
                var r2 = e2.valueOf && e2.valueOf();
                if (null != r2 && r2 !== e2)
                  return s.from(r2, t5, n4);
                var a2 = h2(e2);
                if (a2)
                  return a2;
                if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e2[Symbol.toPrimitive])
                  return s.from(e2[Symbol.toPrimitive]("string"), t5, n4);
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
              }
              function c2(e2) {
                if ("number" != typeof e2)
                  throw new TypeError('"size" argument must be of type number');
                else if (0 > e2)
                  throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
              }
              function u(e2, t5, n4) {
                return c2(e2), 0 >= e2 ? d(e2) : void 0 === t5 ? d(e2) : "string" == typeof n4 ? d(e2).fill(t5, n4) : d(e2).fill(t5);
              }
              function p(e2) {
                return c2(e2), d(0 > e2 ? 0 : 0 | m2(e2));
              }
              function f(e2, t5) {
                if (("string" != typeof t5 || "" === t5) && (t5 = "utf8"), !s.isEncoding(t5))
                  throw new TypeError("Unknown encoding: " + t5);
                var n4 = 0 | b(e2, t5), r2 = d(n4), a2 = r2.write(e2, t5);
                return a2 !== n4 && (r2 = r2.slice(0, a2)), r2;
              }
              function g(e2) {
                for (var t5 = 0 > e2.length ? 0 : 0 | m2(e2.length), n4 = d(t5), r2 = 0; r2 < t5; r2 += 1)
                  n4[r2] = 255 & e2[r2];
                return n4;
              }
              function _(e2, t5, n4) {
                if (0 > t5 || e2.byteLength < t5)
                  throw new RangeError('"offset" is outside of buffer bounds');
                if (e2.byteLength < t5 + (n4 || 0))
                  throw new RangeError('"length" is outside of buffer bounds');
                var r2;
                return r2 = void 0 === t5 && void 0 === n4 ? new Uint8Array(e2) : void 0 === n4 ? new Uint8Array(e2, t5) : new Uint8Array(e2, t5, n4), r2.__proto__ = s.prototype, r2;
              }
              function h2(e2) {
                if (s.isBuffer(e2)) {
                  var t5 = 0 | m2(e2.length), n4 = d(t5);
                  return 0 === n4.length ? n4 : (e2.copy(n4, 0, 0, t5), n4);
                }
                return void 0 === e2.length ? "Buffer" === e2.type && Array.isArray(e2.data) ? g(e2.data) : void 0 : "number" != typeof e2.length || X(e2.length) ? d(0) : g(e2);
              }
              function m2(e2) {
                if (e2 >= 2147483647)
                  throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
                return 0 | e2;
              }
              function b(e2, t5) {
                if (s.isBuffer(e2))
                  return e2.length;
                if (ArrayBuffer.isView(e2) || K(e2, ArrayBuffer))
                  return e2.byteLength;
                if ("string" != typeof e2)
                  throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e2);
                var n4 = e2.length, r2 = 2 < arguments.length && true === arguments[2];
                if (!r2 && 0 === n4)
                  return 0;
                for (var a2 = false; ; )
                  switch (t5) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                      return n4;
                    case "utf8":
                    case "utf-8":
                      return H(e2).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return 2 * n4;
                    case "hex":
                      return n4 >>> 1;
                    case "base64":
                      return z(e2).length;
                    default:
                      if (a2)
                        return r2 ? -1 : H(e2).length;
                      t5 = ("" + t5).toLowerCase(), a2 = true;
                  }
              }
              function y3(e2, t5, n4) {
                var r2 = false;
                if ((void 0 === t5 || 0 > t5) && (t5 = 0), t5 > this.length)
                  return "";
                if ((void 0 === n4 || n4 > this.length) && (n4 = this.length), 0 >= n4)
                  return "";
                if (n4 >>>= 0, t5 >>>= 0, n4 <= t5)
                  return "";
                for (e2 || (e2 = "utf8"); ; )
                  switch (e2) {
                    case "hex":
                      return P(this, t5, n4);
                    case "utf8":
                    case "utf-8":
                      return x3(this, t5, n4);
                    case "ascii":
                      return D(this, t5, n4);
                    case "latin1":
                    case "binary":
                      return I(this, t5, n4);
                    case "base64":
                      return A(this, t5, n4);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return M(this, t5, n4);
                    default:
                      if (r2)
                        throw new TypeError("Unknown encoding: " + e2);
                      e2 = (e2 + "").toLowerCase(), r2 = true;
                  }
              }
              function C2(e2, t5, n4) {
                var r2 = e2[t5];
                e2[t5] = e2[n4], e2[n4] = r2;
              }
              function R(e2, t5, n4, r2, a2) {
                if (0 === e2.length)
                  return -1;
                if ("string" == typeof n4 ? (r2 = n4, n4 = 0) : 2147483647 < n4 ? n4 = 2147483647 : -2147483648 > n4 && (n4 = -2147483648), n4 = +n4, X(n4) && (n4 = a2 ? 0 : e2.length - 1), 0 > n4 && (n4 = e2.length + n4), n4 >= e2.length) {
                  if (a2)
                    return -1;
                  n4 = e2.length - 1;
                } else if (0 > n4)
                  if (a2)
                    n4 = 0;
                  else
                    return -1;
                if ("string" == typeof t5 && (t5 = s.from(t5, r2)), s.isBuffer(t5))
                  return 0 === t5.length ? -1 : E(e2, t5, n4, r2, a2);
                if ("number" == typeof t5)
                  return t5 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? a2 ? Uint8Array.prototype.indexOf.call(e2, t5, n4) : Uint8Array.prototype.lastIndexOf.call(e2, t5, n4) : E(e2, [t5], n4, r2, a2);
                throw new TypeError("val must be string, number or Buffer");
              }
              function E(e2, t5, n4, r2, a2) {
                function o2(e3, t6) {
                  return 1 === d2 ? e3[t6] : e3.readUInt16BE(t6 * d2);
                }
                var d2 = 1, s2 = e2.length, l2 = t5.length;
                if (void 0 !== r2 && (r2 = (r2 + "").toLowerCase(), "ucs2" === r2 || "ucs-2" === r2 || "utf16le" === r2 || "utf-16le" === r2)) {
                  if (2 > e2.length || 2 > t5.length)
                    return -1;
                  d2 = 2, s2 /= 2, l2 /= 2, n4 /= 2;
                }
                var c3;
                if (a2) {
                  var u2 = -1;
                  for (c3 = n4; c3 < s2; c3++)
                    if (o2(e2, c3) !== o2(t5, -1 === u2 ? 0 : c3 - u2))
                      -1 !== u2 && (c3 -= c3 - u2), u2 = -1;
                    else if (-1 === u2 && (u2 = c3), c3 - u2 + 1 === l2)
                      return u2 * d2;
                } else
                  for (n4 + l2 > s2 && (n4 = s2 - l2), c3 = n4; 0 <= c3; c3--) {
                    for (var p2 = true, f2 = 0; f2 < l2; f2++)
                      if (o2(e2, c3 + f2) !== o2(t5, f2)) {
                        p2 = false;
                        break;
                      }
                    if (p2)
                      return c3;
                  }
                return -1;
              }
              function w(e2, t5, n4, r2) {
                n4 = +n4 || 0;
                var a2 = e2.length - n4;
                r2 ? (r2 = +r2, r2 > a2 && (r2 = a2)) : r2 = a2;
                var o2 = t5.length;
                r2 > o2 / 2 && (r2 = o2 / 2);
                for (var d2, s2 = 0; s2 < r2; ++s2) {
                  if (d2 = parseInt(t5.substr(2 * s2, 2), 16), X(d2))
                    return s2;
                  e2[n4 + s2] = d2;
                }
                return s2;
              }
              function S2(e2, t5, n4, r2) {
                return G(H(t5, e2.length - n4), e2, n4, r2);
              }
              function T(e2, t5, n4, r2) {
                return G(Y(t5), e2, n4, r2);
              }
              function v(e2, t5, n4, r2) {
                return T(e2, t5, n4, r2);
              }
              function k(e2, t5, n4, r2) {
                return G(z(t5), e2, n4, r2);
              }
              function L(e2, t5, n4, r2) {
                return G(V(t5, e2.length - n4), e2, n4, r2);
              }
              function A(e2, t5, n4) {
                return 0 === t5 && n4 === e2.length ? $.fromByteArray(e2) : $.fromByteArray(e2.slice(t5, n4));
              }
              function x3(e2, t5, n4) {
                n4 = o(e2.length, n4);
                for (var r2 = [], a2 = t5; a2 < n4; ) {
                  var d2 = e2[a2], s2 = null, l2 = 239 < d2 ? 4 : 223 < d2 ? 3 : 191 < d2 ? 2 : 1;
                  if (a2 + l2 <= n4) {
                    var c3, u2, p2, f2;
                    1 === l2 ? 128 > d2 && (s2 = d2) : 2 === l2 ? (c3 = e2[a2 + 1], 128 == (192 & c3) && (f2 = (31 & d2) << 6 | 63 & c3, 127 < f2 && (s2 = f2))) : 3 === l2 ? (c3 = e2[a2 + 1], u2 = e2[a2 + 2], 128 == (192 & c3) && 128 == (192 & u2) && (f2 = (15 & d2) << 12 | (63 & c3) << 6 | 63 & u2, 2047 < f2 && (55296 > f2 || 57343 < f2) && (s2 = f2))) : 4 === l2 ? (c3 = e2[a2 + 1], u2 = e2[a2 + 2], p2 = e2[a2 + 3], 128 == (192 & c3) && 128 == (192 & u2) && 128 == (192 & p2) && (f2 = (15 & d2) << 18 | (63 & c3) << 12 | (63 & u2) << 6 | 63 & p2, 65535 < f2 && 1114112 > f2 && (s2 = f2))) : void 0;
                  }
                  null === s2 ? (s2 = 65533, l2 = 1) : 65535 < s2 && (s2 -= 65536, r2.push(55296 | 1023 & s2 >>> 10), s2 = 56320 | 1023 & s2), r2.push(s2), a2 += l2;
                }
                return N(r2);
              }
              function N(e2) {
                var n4 = e2.length;
                if (n4 <= 4096)
                  return t4.apply(String, e2);
                for (var r2 = "", a2 = 0; a2 < n4; )
                  r2 += t4.apply(String, e2.slice(a2, a2 += 4096));
                return r2;
              }
              function D(e2, n4, r2) {
                var a2 = "";
                r2 = o(e2.length, r2);
                for (var d2 = n4; d2 < r2; ++d2)
                  a2 += t4(127 & e2[d2]);
                return a2;
              }
              function I(e2, n4, r2) {
                var a2 = "";
                r2 = o(e2.length, r2);
                for (var d2 = n4; d2 < r2; ++d2)
                  a2 += t4(e2[d2]);
                return a2;
              }
              function P(e2, t5, n4) {
                var r2 = e2.length;
                (!t5 || 0 > t5) && (t5 = 0), (!n4 || 0 > n4 || n4 > r2) && (n4 = r2);
                for (var a2 = "", o2 = t5; o2 < n4; ++o2)
                  a2 += W(e2[o2]);
                return a2;
              }
              function M(e2, n4, r2) {
                for (var a2 = e2.slice(n4, r2), o2 = "", d2 = 0; d2 < a2.length; d2 += 2)
                  o2 += t4(a2[d2] + 256 * a2[d2 + 1]);
                return o2;
              }
              function O(e2, t5, n4) {
                if (0 != e2 % 1 || 0 > e2)
                  throw new RangeError("offset is not uint");
                if (e2 + t5 > n4)
                  throw new RangeError("Trying to access beyond buffer length");
              }
              function F(e2, t5, n4, r2, a2, o2) {
                if (!s.isBuffer(e2))
                  throw new TypeError('"buffer" argument must be a Buffer instance');
                if (t5 > a2 || t5 < o2)
                  throw new RangeError('"value" argument is out of bounds');
                if (n4 + r2 > e2.length)
                  throw new RangeError("Index out of range");
              }
              function B(e2, t5, n4, r2) {
                if (n4 + r2 > e2.length)
                  throw new RangeError("Index out of range");
                if (0 > n4)
                  throw new RangeError("Index out of range");
              }
              function U(e2, t5, n4, r2, a2) {
                return t5 = +t5, n4 >>>= 0, a2 || B(e2, t5, n4, 4, 34028234663852886e22, -34028234663852886e22), J.write(e2, t5, n4, r2, 23, 4), n4 + 4;
              }
              function j(e2, t5, n4, r2, a2) {
                return t5 = +t5, n4 >>>= 0, a2 || B(e2, t5, n4, 8, 17976931348623157e292, -17976931348623157e292), J.write(e2, t5, n4, r2, 52, 8), n4 + 8;
              }
              function q(e2) {
                if (e2 = e2.split("=")[0], e2 = e2.trim().replace(Q, ""), 2 > e2.length)
                  return "";
                for (; 0 != e2.length % 4; )
                  e2 += "=";
                return e2;
              }
              function W(e2) {
                return 16 > e2 ? "0" + e2.toString(16) : e2.toString(16);
              }
              function H(e2, t5) {
                t5 = t5 || 1 / 0;
                for (var n4, r2 = e2.length, a2 = null, o2 = [], d2 = 0; d2 < r2; ++d2) {
                  if (n4 = e2.charCodeAt(d2), 55295 < n4 && 57344 > n4) {
                    if (!a2) {
                      if (56319 < n4) {
                        -1 < (t5 -= 3) && o2.push(239, 191, 189);
                        continue;
                      } else if (d2 + 1 === r2) {
                        -1 < (t5 -= 3) && o2.push(239, 191, 189);
                        continue;
                      }
                      a2 = n4;
                      continue;
                    }
                    if (56320 > n4) {
                      -1 < (t5 -= 3) && o2.push(239, 191, 189), a2 = n4;
                      continue;
                    }
                    n4 = (a2 - 55296 << 10 | n4 - 56320) + 65536;
                  } else
                    a2 && -1 < (t5 -= 3) && o2.push(239, 191, 189);
                  if (a2 = null, 128 > n4) {
                    if (0 > (t5 -= 1))
                      break;
                    o2.push(n4);
                  } else if (2048 > n4) {
                    if (0 > (t5 -= 2))
                      break;
                    o2.push(192 | n4 >> 6, 128 | 63 & n4);
                  } else if (65536 > n4) {
                    if (0 > (t5 -= 3))
                      break;
                    o2.push(224 | n4 >> 12, 128 | 63 & n4 >> 6, 128 | 63 & n4);
                  } else if (1114112 > n4) {
                    if (0 > (t5 -= 4))
                      break;
                    o2.push(240 | n4 >> 18, 128 | 63 & n4 >> 12, 128 | 63 & n4 >> 6, 128 | 63 & n4);
                  } else
                    throw new Error("Invalid code point");
                }
                return o2;
              }
              function Y(e2) {
                for (var t5 = [], n4 = 0; n4 < e2.length; ++n4)
                  t5.push(255 & e2.charCodeAt(n4));
                return t5;
              }
              function V(e2, t5) {
                for (var n4, r2, a2, o2 = [], d2 = 0; d2 < e2.length && !(0 > (t5 -= 2)); ++d2)
                  n4 = e2.charCodeAt(d2), r2 = n4 >> 8, a2 = n4 % 256, o2.push(a2), o2.push(r2);
                return o2;
              }
              function z(e2) {
                return $.toByteArray(q(e2));
              }
              function G(e2, t5, n4, r2) {
                for (var a2 = 0; a2 < r2 && !(a2 + n4 >= t5.length || a2 >= e2.length); ++a2)
                  t5[a2 + n4] = e2[a2];
                return a2;
              }
              function K(e2, t5) {
                return e2 instanceof t5 || null != e2 && null != e2.constructor && null != e2.constructor.name && e2.constructor.name === t5.name;
              }
              function X(e2) {
                return e2 !== e2;
              }
              var $ = e("base64-js"), J = e("ieee754");
              n3.Buffer = s, n3.SlowBuffer = function(e2) {
                return +e2 != e2 && (e2 = 0), s.alloc(+e2);
              }, n3.INSPECT_MAX_BYTES = 50;
              n3.kMaxLength = 2147483647, s.TYPED_ARRAY_SUPPORT = function() {
                try {
                  var e2 = new Uint8Array(1);
                  return e2.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                    return 42;
                  } }, 42 === e2.foo();
                } catch (t5) {
                  return false;
                }
              }(), s.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s.prototype, "parent", { enumerable: true, get: function() {
                return s.isBuffer(this) ? this.buffer : void 0;
              } }), Object.defineProperty(s.prototype, "offset", { enumerable: true, get: function() {
                return s.isBuffer(this) ? this.byteOffset : void 0;
              } }), "undefined" != typeof Symbol && null != Symbol.species && s[Symbol.species] === s && Object.defineProperty(s, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false }), s.poolSize = 8192, s.from = function(e2, t5, n4) {
                return l(e2, t5, n4);
              }, s.prototype.__proto__ = Uint8Array.prototype, s.__proto__ = Uint8Array, s.alloc = function(e2, t5, n4) {
                return u(e2, t5, n4);
              }, s.allocUnsafe = function(e2) {
                return p(e2);
              }, s.allocUnsafeSlow = function(e2) {
                return p(e2);
              }, s.isBuffer = function(e2) {
                return null != e2 && true === e2._isBuffer && e2 !== s.prototype;
              }, s.compare = function(e2, t5) {
                if (K(e2, Uint8Array) && (e2 = s.from(e2, e2.offset, e2.byteLength)), K(t5, Uint8Array) && (t5 = s.from(t5, t5.offset, t5.byteLength)), !s.isBuffer(e2) || !s.isBuffer(t5))
                  throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                if (e2 === t5)
                  return 0;
                for (var n4 = e2.length, r2 = t5.length, d2 = 0, l2 = o(n4, r2); d2 < l2; ++d2)
                  if (e2[d2] !== t5[d2]) {
                    n4 = e2[d2], r2 = t5[d2];
                    break;
                  }
                return n4 < r2 ? -1 : r2 < n4 ? 1 : 0;
              }, s.isEncoding = function(e2) {
                switch ((e2 + "").toLowerCase()) {
                  case "hex":
                  case "utf8":
                  case "utf-8":
                  case "ascii":
                  case "latin1":
                  case "binary":
                  case "base64":
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return true;
                  default:
                    return false;
                }
              }, s.concat = function(e2, t5) {
                if (!Array.isArray(e2))
                  throw new TypeError('"list" argument must be an Array of Buffers');
                if (0 === e2.length)
                  return s.alloc(0);
                var n4;
                if (t5 === void 0)
                  for (t5 = 0, n4 = 0; n4 < e2.length; ++n4)
                    t5 += e2[n4].length;
                var r2 = s.allocUnsafe(t5), a2 = 0;
                for (n4 = 0; n4 < e2.length; ++n4) {
                  var o2 = e2[n4];
                  if (K(o2, Uint8Array) && (o2 = s.from(o2)), !s.isBuffer(o2))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                  o2.copy(r2, a2), a2 += o2.length;
                }
                return r2;
              }, s.byteLength = b, s.prototype._isBuffer = true, s.prototype.swap16 = function() {
                var e2 = this.length;
                if (0 != e2 % 2)
                  throw new RangeError("Buffer size must be a multiple of 16-bits");
                for (var t5 = 0; t5 < e2; t5 += 2)
                  C2(this, t5, t5 + 1);
                return this;
              }, s.prototype.swap32 = function() {
                var e2 = this.length;
                if (0 != e2 % 4)
                  throw new RangeError("Buffer size must be a multiple of 32-bits");
                for (var t5 = 0; t5 < e2; t5 += 4)
                  C2(this, t5, t5 + 3), C2(this, t5 + 1, t5 + 2);
                return this;
              }, s.prototype.swap64 = function() {
                var e2 = this.length;
                if (0 != e2 % 8)
                  throw new RangeError("Buffer size must be a multiple of 64-bits");
                for (var t5 = 0; t5 < e2; t5 += 8)
                  C2(this, t5, t5 + 7), C2(this, t5 + 1, t5 + 6), C2(this, t5 + 2, t5 + 5), C2(this, t5 + 3, t5 + 4);
                return this;
              }, s.prototype.toString = function() {
                var e2 = this.length;
                return 0 === e2 ? "" : 0 === arguments.length ? x3(this, 0, e2) : y3.apply(this, arguments);
              }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(e2) {
                if (!s.isBuffer(e2))
                  throw new TypeError("Argument must be a Buffer");
                return this === e2 || 0 === s.compare(this, e2);
              }, s.prototype.inspect = function() {
                var e2 = "", t5 = n3.INSPECT_MAX_BYTES;
                return e2 = this.toString("hex", 0, t5).replace(/(.{2})/g, "$1 ").trim(), this.length > t5 && (e2 += " ... "), "<Buffer " + e2 + ">";
              }, s.prototype.compare = function(e2, t5, n4, r2, a2) {
                if (K(e2, Uint8Array) && (e2 = s.from(e2, e2.offset, e2.byteLength)), !s.isBuffer(e2))
                  throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e2);
                if (void 0 === t5 && (t5 = 0), void 0 === n4 && (n4 = e2 ? e2.length : 0), void 0 === r2 && (r2 = 0), void 0 === a2 && (a2 = this.length), 0 > t5 || n4 > e2.length || 0 > r2 || a2 > this.length)
                  throw new RangeError("out of range index");
                if (r2 >= a2 && t5 >= n4)
                  return 0;
                if (r2 >= a2)
                  return -1;
                if (t5 >= n4)
                  return 1;
                if (t5 >>>= 0, n4 >>>= 0, r2 >>>= 0, a2 >>>= 0, this === e2)
                  return 0;
                for (var d2 = a2 - r2, l2 = n4 - t5, c3 = o(d2, l2), u2 = this.slice(r2, a2), p2 = e2.slice(t5, n4), f2 = 0; f2 < c3; ++f2)
                  if (u2[f2] !== p2[f2]) {
                    d2 = u2[f2], l2 = p2[f2];
                    break;
                  }
                return d2 < l2 ? -1 : l2 < d2 ? 1 : 0;
              }, s.prototype.includes = function(e2, t5, n4) {
                return -1 !== this.indexOf(e2, t5, n4);
              }, s.prototype.indexOf = function(e2, t5, n4) {
                return R(this, e2, t5, n4, true);
              }, s.prototype.lastIndexOf = function(e2, t5, n4) {
                return R(this, e2, t5, n4, false);
              }, s.prototype.write = function(e2, t5, n4, r2) {
                if (void 0 === t5)
                  r2 = "utf8", n4 = this.length, t5 = 0;
                else if (void 0 === n4 && "string" == typeof t5)
                  r2 = t5, n4 = this.length, t5 = 0;
                else if (isFinite(t5))
                  t5 >>>= 0, isFinite(n4) ? (n4 >>>= 0, void 0 === r2 && (r2 = "utf8")) : (r2 = n4, n4 = void 0);
                else
                  throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                var a2 = this.length - t5;
                if ((void 0 === n4 || n4 > a2) && (n4 = a2), 0 < e2.length && (0 > n4 || 0 > t5) || t5 > this.length)
                  throw new RangeError("Attempt to write outside buffer bounds");
                r2 || (r2 = "utf8");
                for (var o2 = false; ; )
                  switch (r2) {
                    case "hex":
                      return w(this, e2, t5, n4);
                    case "utf8":
                    case "utf-8":
                      return S2(this, e2, t5, n4);
                    case "ascii":
                      return T(this, e2, t5, n4);
                    case "latin1":
                    case "binary":
                      return v(this, e2, t5, n4);
                    case "base64":
                      return k(this, e2, t5, n4);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return L(this, e2, t5, n4);
                    default:
                      if (o2)
                        throw new TypeError("Unknown encoding: " + r2);
                      r2 = ("" + r2).toLowerCase(), o2 = true;
                  }
              }, s.prototype.toJSON = function() {
                return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
              };
              s.prototype.slice = function(e2, t5) {
                var n4 = this.length;
                e2 = ~~e2, t5 = t5 === void 0 ? n4 : ~~t5, 0 > e2 ? (e2 += n4, 0 > e2 && (e2 = 0)) : e2 > n4 && (e2 = n4), 0 > t5 ? (t5 += n4, 0 > t5 && (t5 = 0)) : t5 > n4 && (t5 = n4), t5 < e2 && (t5 = e2);
                var r2 = this.subarray(e2, t5);
                return r2.__proto__ = s.prototype, r2;
              }, s.prototype.readUIntLE = function(e2, t5, n4) {
                e2 >>>= 0, t5 >>>= 0, n4 || O(e2, t5, this.length);
                for (var r2 = this[e2], a2 = 1, o2 = 0; ++o2 < t5 && (a2 *= 256); )
                  r2 += this[e2 + o2] * a2;
                return r2;
              }, s.prototype.readUIntBE = function(e2, t5, n4) {
                e2 >>>= 0, t5 >>>= 0, n4 || O(e2, t5, this.length);
                for (var r2 = this[e2 + --t5], a2 = 1; 0 < t5 && (a2 *= 256); )
                  r2 += this[e2 + --t5] * a2;
                return r2;
              }, s.prototype.readUInt8 = function(e2, t5) {
                return e2 >>>= 0, t5 || O(e2, 1, this.length), this[e2];
              }, s.prototype.readUInt16LE = function(e2, t5) {
                return e2 >>>= 0, t5 || O(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
              }, s.prototype.readUInt16BE = function(e2, t5) {
                return e2 >>>= 0, t5 || O(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
              }, s.prototype.readUInt32LE = function(e2, t5) {
                return e2 >>>= 0, t5 || O(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + 16777216 * this[e2 + 3];
              }, s.prototype.readUInt32BE = function(e2, t5) {
                return e2 >>>= 0, t5 || O(e2, 4, this.length), 16777216 * this[e2] + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
              }, s.prototype.readIntLE = function(e2, t5, n4) {
                e2 >>>= 0, t5 >>>= 0, n4 || O(e2, t5, this.length);
                for (var a2 = this[e2], o2 = 1, d2 = 0; ++d2 < t5 && (o2 *= 256); )
                  a2 += this[e2 + d2] * o2;
                return o2 *= 128, a2 >= o2 && (a2 -= r(2, 8 * t5)), a2;
              }, s.prototype.readIntBE = function(e2, t5, n4) {
                e2 >>>= 0, t5 >>>= 0, n4 || O(e2, t5, this.length);
                for (var a2 = t5, o2 = 1, d2 = this[e2 + --a2]; 0 < a2 && (o2 *= 256); )
                  d2 += this[e2 + --a2] * o2;
                return o2 *= 128, d2 >= o2 && (d2 -= r(2, 8 * t5)), d2;
              }, s.prototype.readInt8 = function(e2, t5) {
                return e2 >>>= 0, t5 || O(e2, 1, this.length), 128 & this[e2] ? -1 * (255 - this[e2] + 1) : this[e2];
              }, s.prototype.readInt16LE = function(e2, t5) {
                e2 >>>= 0, t5 || O(e2, 2, this.length);
                var n4 = this[e2] | this[e2 + 1] << 8;
                return 32768 & n4 ? 4294901760 | n4 : n4;
              }, s.prototype.readInt16BE = function(e2, t5) {
                e2 >>>= 0, t5 || O(e2, 2, this.length);
                var n4 = this[e2 + 1] | this[e2] << 8;
                return 32768 & n4 ? 4294901760 | n4 : n4;
              }, s.prototype.readInt32LE = function(e2, t5) {
                return e2 >>>= 0, t5 || O(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
              }, s.prototype.readInt32BE = function(e2, t5) {
                return e2 >>>= 0, t5 || O(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
              }, s.prototype.readFloatLE = function(e2, t5) {
                return e2 >>>= 0, t5 || O(e2, 4, this.length), J.read(this, e2, true, 23, 4);
              }, s.prototype.readFloatBE = function(e2, t5) {
                return e2 >>>= 0, t5 || O(e2, 4, this.length), J.read(this, e2, false, 23, 4);
              }, s.prototype.readDoubleLE = function(e2, t5) {
                return e2 >>>= 0, t5 || O(e2, 8, this.length), J.read(this, e2, true, 52, 8);
              }, s.prototype.readDoubleBE = function(e2, t5) {
                return e2 >>>= 0, t5 || O(e2, 8, this.length), J.read(this, e2, false, 52, 8);
              }, s.prototype.writeUIntLE = function(e2, t5, n4, a2) {
                if (e2 = +e2, t5 >>>= 0, n4 >>>= 0, !a2) {
                  var o2 = r(2, 8 * n4) - 1;
                  F(this, e2, t5, n4, o2, 0);
                }
                var d2 = 1, s2 = 0;
                for (this[t5] = 255 & e2; ++s2 < n4 && (d2 *= 256); )
                  this[t5 + s2] = 255 & e2 / d2;
                return t5 + n4;
              }, s.prototype.writeUIntBE = function(e2, t5, n4, a2) {
                if (e2 = +e2, t5 >>>= 0, n4 >>>= 0, !a2) {
                  var o2 = r(2, 8 * n4) - 1;
                  F(this, e2, t5, n4, o2, 0);
                }
                var d2 = n4 - 1, s2 = 1;
                for (this[t5 + d2] = 255 & e2; 0 <= --d2 && (s2 *= 256); )
                  this[t5 + d2] = 255 & e2 / s2;
                return t5 + n4;
              }, s.prototype.writeUInt8 = function(e2, t5, n4) {
                return e2 = +e2, t5 >>>= 0, n4 || F(this, e2, t5, 1, 255, 0), this[t5] = 255 & e2, t5 + 1;
              }, s.prototype.writeUInt16LE = function(e2, t5, n4) {
                return e2 = +e2, t5 >>>= 0, n4 || F(this, e2, t5, 2, 65535, 0), this[t5] = 255 & e2, this[t5 + 1] = e2 >>> 8, t5 + 2;
              }, s.prototype.writeUInt16BE = function(e2, t5, n4) {
                return e2 = +e2, t5 >>>= 0, n4 || F(this, e2, t5, 2, 65535, 0), this[t5] = e2 >>> 8, this[t5 + 1] = 255 & e2, t5 + 2;
              }, s.prototype.writeUInt32LE = function(e2, t5, n4) {
                return e2 = +e2, t5 >>>= 0, n4 || F(this, e2, t5, 4, 4294967295, 0), this[t5 + 3] = e2 >>> 24, this[t5 + 2] = e2 >>> 16, this[t5 + 1] = e2 >>> 8, this[t5] = 255 & e2, t5 + 4;
              }, s.prototype.writeUInt32BE = function(e2, t5, n4) {
                return e2 = +e2, t5 >>>= 0, n4 || F(this, e2, t5, 4, 4294967295, 0), this[t5] = e2 >>> 24, this[t5 + 1] = e2 >>> 16, this[t5 + 2] = e2 >>> 8, this[t5 + 3] = 255 & e2, t5 + 4;
              }, s.prototype.writeIntLE = function(e2, t5, n4, a2) {
                if (e2 = +e2, t5 >>>= 0, !a2) {
                  var o2 = r(2, 8 * n4 - 1);
                  F(this, e2, t5, n4, o2 - 1, -o2);
                }
                var d2 = 0, s2 = 1, l2 = 0;
                for (this[t5] = 255 & e2; ++d2 < n4 && (s2 *= 256); )
                  0 > e2 && 0 === l2 && 0 !== this[t5 + d2 - 1] && (l2 = 1), this[t5 + d2] = 255 & (e2 / s2 >> 0) - l2;
                return t5 + n4;
              }, s.prototype.writeIntBE = function(e2, t5, n4, a2) {
                if (e2 = +e2, t5 >>>= 0, !a2) {
                  var o2 = r(2, 8 * n4 - 1);
                  F(this, e2, t5, n4, o2 - 1, -o2);
                }
                var d2 = n4 - 1, s2 = 1, l2 = 0;
                for (this[t5 + d2] = 255 & e2; 0 <= --d2 && (s2 *= 256); )
                  0 > e2 && 0 === l2 && 0 !== this[t5 + d2 + 1] && (l2 = 1), this[t5 + d2] = 255 & (e2 / s2 >> 0) - l2;
                return t5 + n4;
              }, s.prototype.writeInt8 = function(e2, t5, n4) {
                return e2 = +e2, t5 >>>= 0, n4 || F(this, e2, t5, 1, 127, -128), 0 > e2 && (e2 = 255 + e2 + 1), this[t5] = 255 & e2, t5 + 1;
              }, s.prototype.writeInt16LE = function(e2, t5, n4) {
                return e2 = +e2, t5 >>>= 0, n4 || F(this, e2, t5, 2, 32767, -32768), this[t5] = 255 & e2, this[t5 + 1] = e2 >>> 8, t5 + 2;
              }, s.prototype.writeInt16BE = function(e2, t5, n4) {
                return e2 = +e2, t5 >>>= 0, n4 || F(this, e2, t5, 2, 32767, -32768), this[t5] = e2 >>> 8, this[t5 + 1] = 255 & e2, t5 + 2;
              }, s.prototype.writeInt32LE = function(e2, t5, n4) {
                return e2 = +e2, t5 >>>= 0, n4 || F(this, e2, t5, 4, 2147483647, -2147483648), this[t5] = 255 & e2, this[t5 + 1] = e2 >>> 8, this[t5 + 2] = e2 >>> 16, this[t5 + 3] = e2 >>> 24, t5 + 4;
              }, s.prototype.writeInt32BE = function(e2, t5, n4) {
                return e2 = +e2, t5 >>>= 0, n4 || F(this, e2, t5, 4, 2147483647, -2147483648), 0 > e2 && (e2 = 4294967295 + e2 + 1), this[t5] = e2 >>> 24, this[t5 + 1] = e2 >>> 16, this[t5 + 2] = e2 >>> 8, this[t5 + 3] = 255 & e2, t5 + 4;
              }, s.prototype.writeFloatLE = function(e2, t5, n4) {
                return U(this, e2, t5, true, n4);
              }, s.prototype.writeFloatBE = function(e2, t5, n4) {
                return U(this, e2, t5, false, n4);
              }, s.prototype.writeDoubleLE = function(e2, t5, n4) {
                return j(this, e2, t5, true, n4);
              }, s.prototype.writeDoubleBE = function(e2, t5, n4) {
                return j(this, e2, t5, false, n4);
              }, s.prototype.copy = function(e2, t5, n4, r2) {
                if (!s.isBuffer(e2))
                  throw new TypeError("argument should be a Buffer");
                if (n4 || (n4 = 0), r2 || 0 === r2 || (r2 = this.length), t5 >= e2.length && (t5 = e2.length), t5 || (t5 = 0), 0 < r2 && r2 < n4 && (r2 = n4), r2 === n4)
                  return 0;
                if (0 === e2.length || 0 === this.length)
                  return 0;
                if (0 > t5)
                  throw new RangeError("targetStart out of bounds");
                if (0 > n4 || n4 >= this.length)
                  throw new RangeError("Index out of range");
                if (0 > r2)
                  throw new RangeError("sourceEnd out of bounds");
                r2 > this.length && (r2 = this.length), e2.length - t5 < r2 - n4 && (r2 = e2.length - t5 + n4);
                var a2 = r2 - n4;
                if (this === e2 && "function" == typeof Uint8Array.prototype.copyWithin)
                  this.copyWithin(t5, n4, r2);
                else if (this === e2 && n4 < t5 && t5 < r2)
                  for (var o2 = a2 - 1; 0 <= o2; --o2)
                    e2[o2 + t5] = this[o2 + n4];
                else
                  Uint8Array.prototype.set.call(e2, this.subarray(n4, r2), t5);
                return a2;
              }, s.prototype.fill = function(e2, t5, n4, r2) {
                if ("string" == typeof e2) {
                  if ("string" == typeof t5 ? (r2 = t5, t5 = 0, n4 = this.length) : "string" == typeof n4 && (r2 = n4, n4 = this.length), void 0 !== r2 && "string" != typeof r2)
                    throw new TypeError("encoding must be a string");
                  if ("string" == typeof r2 && !s.isEncoding(r2))
                    throw new TypeError("Unknown encoding: " + r2);
                  if (1 === e2.length) {
                    var a2 = e2.charCodeAt(0);
                    ("utf8" === r2 && 128 > a2 || "latin1" === r2) && (e2 = a2);
                  }
                } else
                  "number" == typeof e2 && (e2 &= 255);
                if (0 > t5 || this.length < t5 || this.length < n4)
                  throw new RangeError("Out of range index");
                if (n4 <= t5)
                  return this;
                t5 >>>= 0, n4 = n4 === void 0 ? this.length : n4 >>> 0, e2 || (e2 = 0);
                var o2;
                if ("number" == typeof e2)
                  for (o2 = t5; o2 < n4; ++o2)
                    this[o2] = e2;
                else {
                  var d2 = s.isBuffer(e2) ? e2 : s.from(e2, r2), l2 = d2.length;
                  if (0 === l2)
                    throw new TypeError('The value "' + e2 + '" is invalid for argument "value"');
                  for (o2 = 0; o2 < n4 - t5; ++o2)
                    this[o2 + t5] = d2[o2 % l2];
                }
                return this;
              };
              var Q = /[^+/0-9A-Za-z-_]/g;
            }).call(this);
          }).call(this, e("buffer").Buffer);
        }, { "base64-js": 1, buffer: 3, ieee754: 9 }], 4: [function(e, t3, n3) {
          (function(a2) {
            (function() {
              function r2() {
                let e2;
                try {
                  e2 = n3.storage.getItem("debug");
                } catch (e3) {
                }
                return !e2 && "undefined" != typeof a2 && "env" in a2 && (e2 = a2.env.DEBUG), e2;
              }
              n3.formatArgs = function(e2) {
                if (e2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e2[0] + (this.useColors ? "%c " : " ") + "+" + t3.exports.humanize(this.diff), !this.useColors)
                  return;
                const n4 = "color: " + this.color;
                e2.splice(1, 0, n4, "color: inherit");
                let r3 = 0, a3 = 0;
                e2[0].replace(/%[a-zA-Z%]/g, (e3) => {
                  "%%" === e3 || (r3++, "%c" === e3 && (a3 = r3));
                }), e2.splice(a3, 0, n4);
              }, n3.save = function(e2) {
                try {
                  e2 ? n3.storage.setItem("debug", e2) : n3.storage.removeItem("debug");
                } catch (e3) {
                }
              }, n3.load = r2, n3.useColors = function() {
                return !!("undefined" != typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs)) || !("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && 31 <= parseInt(RegExp.$1, 10) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
              }, n3.storage = function() {
                try {
                  return localStorage;
                } catch (e2) {
                }
              }(), n3.destroy = (() => {
                let e2 = false;
                return () => {
                  e2 || (e2 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
                };
              })(), n3.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], n3.log = console.debug || console.log || (() => {
              }), t3.exports = e("./common")(n3);
              const { formatters: o } = t3.exports;
              o.j = function(e2) {
                try {
                  return JSON.stringify(e2);
                } catch (e3) {
                  return "[UnexpectedJSONParseError]: " + e3.message;
                }
              };
            }).call(this);
          }).call(this, e("_process"));
        }, { "./common": 5, _process: 12 }], 5: [function(e, t3) {
          t3.exports = function(t4) {
            function r2(e2) {
              function t5(...e3) {
                if (!t5.enabled)
                  return;
                const a3 = t5, o3 = +new Date(), i = o3 - (n3 || o3);
                a3.diff = i, a3.prev = n3, a3.curr = o3, n3 = o3, e3[0] = r2.coerce(e3[0]), "string" != typeof e3[0] && e3.unshift("%O");
                let d = 0;
                e3[0] = e3[0].replace(/%([a-zA-Z%])/g, (t6, n4) => {
                  if ("%%" === t6)
                    return "%";
                  d++;
                  const o4 = r2.formatters[n4];
                  if ("function" == typeof o4) {
                    const n5 = e3[d];
                    t6 = o4.call(a3, n5), e3.splice(d, 1), d--;
                  }
                  return t6;
                }), r2.formatArgs.call(a3, e3);
                const s = a3.log || r2.log;
                s.apply(a3, e3);
              }
              let n3, o2 = null;
              return t5.namespace = e2, t5.useColors = r2.useColors(), t5.color = r2.selectColor(e2), t5.extend = a2, t5.destroy = r2.destroy, Object.defineProperty(t5, "enabled", { enumerable: true, configurable: false, get: () => null === o2 ? r2.enabled(e2) : o2, set: (e3) => {
                o2 = e3;
              } }), "function" == typeof r2.init && r2.init(t5), t5;
            }
            function a2(e2, t5) {
              const n3 = r2(this.namespace + ("undefined" == typeof t5 ? ":" : t5) + e2);
              return n3.log = this.log, n3;
            }
            function o(e2) {
              return e2.toString().substring(2, e2.toString().length - 2).replace(/\.\*\?$/, "*");
            }
            return r2.debug = r2, r2.default = r2, r2.coerce = function(e2) {
              return e2 instanceof Error ? e2.stack || e2.message : e2;
            }, r2.disable = function() {
              const e2 = [...r2.names.map(o), ...r2.skips.map(o).map((e3) => "-" + e3)].join(",");
              return r2.enable(""), e2;
            }, r2.enable = function(e2) {
              r2.save(e2), r2.names = [], r2.skips = [];
              let t5;
              const n3 = ("string" == typeof e2 ? e2 : "").split(/[\s,]+/), a3 = n3.length;
              for (t5 = 0; t5 < a3; t5++)
                n3[t5] && (e2 = n3[t5].replace(/\*/g, ".*?"), "-" === e2[0] ? r2.skips.push(new RegExp("^" + e2.substr(1) + "$")) : r2.names.push(new RegExp("^" + e2 + "$")));
            }, r2.enabled = function(e2) {
              if ("*" === e2[e2.length - 1])
                return true;
              let t5, n3;
              for (t5 = 0, n3 = r2.skips.length; t5 < n3; t5++)
                if (r2.skips[t5].test(e2))
                  return false;
              for (t5 = 0, n3 = r2.names.length; t5 < n3; t5++)
                if (r2.names[t5].test(e2))
                  return true;
              return false;
            }, r2.humanize = e("ms"), r2.destroy = function() {
              console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
            }, Object.keys(t4).forEach((e2) => {
              r2[e2] = t4[e2];
            }), r2.names = [], r2.skips = [], r2.formatters = {}, r2.selectColor = function(e2) {
              let t5 = 0;
              for (let n3 = 0; n3 < e2.length; n3++)
                t5 = (t5 << 5) - t5 + e2.charCodeAt(n3), t5 |= 0;
              return r2.colors[n2(t5) % r2.colors.length];
            }, r2.enable(r2.load()), r2;
          };
        }, { ms: 11 }], 6: [function(e, t3) {
          "use strict";
          function n3(e2, t4) {
            for (const n4 in t4)
              Object.defineProperty(e2, n4, { value: t4[n4], enumerable: true, configurable: true });
            return e2;
          }
          t3.exports = function(e2, t4, r2) {
            if (!e2 || "string" == typeof e2)
              throw new TypeError("Please pass an Error to err-code");
            r2 || (r2 = {}), "object" == typeof t4 && (r2 = t4, t4 = ""), t4 && (r2.code = t4);
            try {
              return n3(e2, r2);
            } catch (t5) {
              r2.message = e2.message, r2.stack = e2.stack;
              const a2 = function() {
              };
              a2.prototype = Object.create(Object.getPrototypeOf(e2));
              const o = n3(new a2(), r2);
              return o;
            }
          };
        }, {}], 7: [function(e, t3) {
          "use strict";
          function n3(e2) {
            console && console.warn && console.warn(e2);
          }
          function r2() {
            r2.init.call(this);
          }
          function a2(e2) {
            if ("function" != typeof e2)
              throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e2);
          }
          function o(e2) {
            return void 0 === e2._maxListeners ? r2.defaultMaxListeners : e2._maxListeners;
          }
          function i(e2, t4, r3, i2) {
            var d2, s2, l2;
            if (a2(r3), s2 = e2._events, void 0 === s2 ? (s2 = e2._events = /* @__PURE__ */ Object.create(null), e2._eventsCount = 0) : (void 0 !== s2.newListener && (e2.emit("newListener", t4, r3.listener ? r3.listener : r3), s2 = e2._events), l2 = s2[t4]), void 0 === l2)
              l2 = s2[t4] = r3, ++e2._eventsCount;
            else if ("function" == typeof l2 ? l2 = s2[t4] = i2 ? [r3, l2] : [l2, r3] : i2 ? l2.unshift(r3) : l2.push(r3), d2 = o(e2), 0 < d2 && l2.length > d2 && !l2.warned) {
              l2.warned = true;
              var c3 = new Error("Possible EventEmitter memory leak detected. " + l2.length + " " + (t4 + " listeners added. Use emitter.setMaxListeners() to increase limit"));
              c3.name = "MaxListenersExceededWarning", c3.emitter = e2, c3.type = t4, c3.count = l2.length, n3(c3);
            }
            return e2;
          }
          function d() {
            if (!this.fired)
              return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
          }
          function s(e2, t4, n4) {
            var r3 = { fired: false, wrapFn: void 0, target: e2, type: t4, listener: n4 }, a3 = d.bind(r3);
            return a3.listener = n4, r3.wrapFn = a3, a3;
          }
          function l(e2, t4, n4) {
            var r3 = e2._events;
            if (r3 === void 0)
              return [];
            var a3 = r3[t4];
            return void 0 === a3 ? [] : "function" == typeof a3 ? n4 ? [a3.listener || a3] : [a3] : n4 ? f(a3) : u(a3, a3.length);
          }
          function c2(e2) {
            var t4 = this._events;
            if (t4 !== void 0) {
              var n4 = t4[e2];
              if ("function" == typeof n4)
                return 1;
              if (void 0 !== n4)
                return n4.length;
            }
            return 0;
          }
          function u(e2, t4) {
            for (var n4 = Array(t4), r3 = 0; r3 < t4; ++r3)
              n4[r3] = e2[r3];
            return n4;
          }
          function p(e2, t4) {
            for (; t4 + 1 < e2.length; t4++)
              e2[t4] = e2[t4 + 1];
            e2.pop();
          }
          function f(e2) {
            for (var t4 = Array(e2.length), n4 = 0; n4 < t4.length; ++n4)
              t4[n4] = e2[n4].listener || e2[n4];
            return t4;
          }
          function g(e2, t4, n4) {
            "function" == typeof e2.on && _(e2, "error", t4, n4);
          }
          function _(e2, t4, n4, r3) {
            if ("function" == typeof e2.on)
              r3.once ? e2.once(t4, n4) : e2.on(t4, n4);
            else if ("function" == typeof e2.addEventListener)
              e2.addEventListener(t4, function a3(o2) {
                r3.once && e2.removeEventListener(t4, a3), n4(o2);
              });
            else
              throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e2);
          }
          var h2, m2 = "object" == typeof Reflect ? Reflect : null, b = m2 && "function" == typeof m2.apply ? m2.apply : function(e2, t4, n4) {
            return Function.prototype.apply.call(e2, t4, n4);
          };
          h2 = m2 && "function" == typeof m2.ownKeys ? m2.ownKeys : Object.getOwnPropertySymbols ? function(e2) {
            return Object.getOwnPropertyNames(e2).concat(Object.getOwnPropertySymbols(e2));
          } : function(e2) {
            return Object.getOwnPropertyNames(e2);
          };
          var y3 = Number.isNaN || function(e2) {
            return e2 !== e2;
          };
          t3.exports = r2, t3.exports.once = function(e2, t4) {
            return new Promise(function(n4, r3) {
              function a3(n5) {
                e2.removeListener(t4, o2), r3(n5);
              }
              function o2() {
                "function" == typeof e2.removeListener && e2.removeListener("error", a3), n4([].slice.call(arguments));
              }
              _(e2, t4, o2, { once: true }), "error" !== t4 && g(e2, a3, { once: true });
            });
          }, r2.EventEmitter = r2, r2.prototype._events = void 0, r2.prototype._eventsCount = 0, r2.prototype._maxListeners = void 0;
          var C2 = 10;
          Object.defineProperty(r2, "defaultMaxListeners", { enumerable: true, get: function() {
            return C2;
          }, set: function(e2) {
            if ("number" != typeof e2 || 0 > e2 || y3(e2))
              throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e2 + ".");
            C2 = e2;
          } }), r2.init = function() {
            (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
          }, r2.prototype.setMaxListeners = function(e2) {
            if ("number" != typeof e2 || 0 > e2 || y3(e2))
              throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e2 + ".");
            return this._maxListeners = e2, this;
          }, r2.prototype.getMaxListeners = function() {
            return o(this);
          }, r2.prototype.emit = function(e2) {
            for (var t4 = [], n4 = 1; n4 < arguments.length; n4++)
              t4.push(arguments[n4]);
            var r3 = "error" === e2, a3 = this._events;
            if (a3 !== void 0)
              r3 = r3 && a3.error === void 0;
            else if (!r3)
              return false;
            if (r3) {
              var o2;
              if (0 < t4.length && (o2 = t4[0]), o2 instanceof Error)
                throw o2;
              var d2 = new Error("Unhandled error." + (o2 ? " (" + o2.message + ")" : ""));
              throw d2.context = o2, d2;
            }
            var s2 = a3[e2];
            if (s2 === void 0)
              return false;
            if ("function" == typeof s2)
              b(s2, this, t4);
            else
              for (var l2 = s2.length, c3 = u(s2, l2), n4 = 0; n4 < l2; ++n4)
                b(c3[n4], this, t4);
            return true;
          }, r2.prototype.addListener = function(e2, t4) {
            return i(this, e2, t4, false);
          }, r2.prototype.on = r2.prototype.addListener, r2.prototype.prependListener = function(e2, t4) {
            return i(this, e2, t4, true);
          }, r2.prototype.once = function(e2, t4) {
            return a2(t4), this.on(e2, s(this, e2, t4)), this;
          }, r2.prototype.prependOnceListener = function(e2, t4) {
            return a2(t4), this.prependListener(e2, s(this, e2, t4)), this;
          }, r2.prototype.removeListener = function(e2, t4) {
            var n4, r3, o2, d2, s2;
            if (a2(t4), r3 = this._events, void 0 === r3)
              return this;
            if (n4 = r3[e2], void 0 === n4)
              return this;
            if (n4 === t4 || n4.listener === t4)
              0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r3[e2], r3.removeListener && this.emit("removeListener", e2, n4.listener || t4));
            else if ("function" != typeof n4) {
              for (o2 = -1, d2 = n4.length - 1; 0 <= d2; d2--)
                if (n4[d2] === t4 || n4[d2].listener === t4) {
                  s2 = n4[d2].listener, o2 = d2;
                  break;
                }
              if (0 > o2)
                return this;
              0 === o2 ? n4.shift() : p(n4, o2), 1 === n4.length && (r3[e2] = n4[0]), void 0 !== r3.removeListener && this.emit("removeListener", e2, s2 || t4);
            }
            return this;
          }, r2.prototype.off = r2.prototype.removeListener, r2.prototype.removeAllListeners = function(e2) {
            var t4, n4, r3;
            if (n4 = this._events, void 0 === n4)
              return this;
            if (void 0 === n4.removeListener)
              return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n4[e2] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n4[e2]), this;
            if (0 === arguments.length) {
              var a3, o2 = Object.keys(n4);
              for (r3 = 0; r3 < o2.length; ++r3)
                a3 = o2[r3], "removeListener" !== a3 && this.removeAllListeners(a3);
              return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
            }
            if (t4 = n4[e2], "function" == typeof t4)
              this.removeListener(e2, t4);
            else if (void 0 !== t4)
              for (r3 = t4.length - 1; 0 <= r3; r3--)
                this.removeListener(e2, t4[r3]);
            return this;
          }, r2.prototype.listeners = function(e2) {
            return l(this, e2, true);
          }, r2.prototype.rawListeners = function(e2) {
            return l(this, e2, false);
          }, r2.listenerCount = function(e2, t4) {
            return "function" == typeof e2.listenerCount ? e2.listenerCount(t4) : c2.call(e2, t4);
          }, r2.prototype.listenerCount = c2, r2.prototype.eventNames = function() {
            return 0 < this._eventsCount ? h2(this._events) : [];
          };
        }, {}], 8: [function(e, t3) {
          t3.exports = function() {
            if ("undefined" == typeof globalThis)
              return null;
            var e2 = { RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection, RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription, RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate };
            return e2.RTCPeerConnection ? e2 : null;
          };
        }, {}], 9: [function(e, a2, o) {
          o.read = function(t3, n3, a3, o2, l) {
            var c2, u, p = 8 * l - o2 - 1, f = (1 << p) - 1, g = f >> 1, _ = -7, h2 = a3 ? l - 1 : 0, b = a3 ? -1 : 1, d = t3[n3 + h2];
            for (h2 += b, c2 = d & (1 << -_) - 1, d >>= -_, _ += p; 0 < _; c2 = 256 * c2 + t3[n3 + h2], h2 += b, _ -= 8)
              ;
            for (u = c2 & (1 << -_) - 1, c2 >>= -_, _ += o2; 0 < _; u = 256 * u + t3[n3 + h2], h2 += b, _ -= 8)
              ;
            if (0 === c2)
              c2 = 1 - g;
            else {
              if (c2 === f)
                return u ? NaN : (d ? -1 : 1) * (1 / 0);
              u += r(2, o2), c2 -= g;
            }
            return (d ? -1 : 1) * u * r(2, c2 - o2);
          }, o.write = function(a3, o2, l, u, p, f) {
            var h2, b, y3, g = Math.LN2, _ = Math.log, C2 = 8 * f - p - 1, R = (1 << C2) - 1, E = R >> 1, w = 23 === p ? r(2, -24) - r(2, -77) : 0, S2 = u ? 0 : f - 1, T = u ? 1 : -1, d = 0 > o2 || 0 === o2 && 0 > 1 / o2 ? 1 : 0;
            for (o2 = n2(o2), isNaN(o2) || o2 === 1 / 0 ? (b = isNaN(o2) ? 1 : 0, h2 = R) : (h2 = t2(_(o2) / g), 1 > o2 * (y3 = r(2, -h2)) && (h2--, y3 *= 2), o2 += 1 <= h2 + E ? w / y3 : w * r(2, 1 - E), 2 <= o2 * y3 && (h2++, y3 /= 2), h2 + E >= R ? (b = 0, h2 = R) : 1 <= h2 + E ? (b = (o2 * y3 - 1) * r(2, p), h2 += E) : (b = o2 * r(2, E - 1) * r(2, p), h2 = 0)); 8 <= p; a3[l + S2] = 255 & b, S2 += T, b /= 256, p -= 8)
              ;
            for (h2 = h2 << p | b, C2 += p; 0 < C2; a3[l + S2] = 255 & h2, S2 += T, h2 /= 256, C2 -= 8)
              ;
            a3[l + S2 - T] |= 128 * d;
          };
        }, {}], 10: [function(e, t3) {
          t3.exports = "function" == typeof Object.create ? function(e2, t4) {
            t4 && (e2.super_ = t4, e2.prototype = Object.create(t4.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } }));
          } : function(e2, t4) {
            if (t4) {
              e2.super_ = t4;
              var n3 = function() {
              };
              n3.prototype = t4.prototype, e2.prototype = new n3(), e2.prototype.constructor = e2;
            }
          };
        }, {}], 11: [function(e, t3) {
          var r2 = Math.round;
          function a2(e2) {
            if (e2 += "", !(100 < e2.length)) {
              var t4 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e2);
              if (t4) {
                var r3 = parseFloat(t4[1]), n3 = (t4[2] || "ms").toLowerCase();
                return "years" === n3 || "year" === n3 || "yrs" === n3 || "yr" === n3 || "y" === n3 ? 315576e5 * r3 : "weeks" === n3 || "week" === n3 || "w" === n3 ? 6048e5 * r3 : "days" === n3 || "day" === n3 || "d" === n3 ? 864e5 * r3 : "hours" === n3 || "hour" === n3 || "hrs" === n3 || "hr" === n3 || "h" === n3 ? 36e5 * r3 : "minutes" === n3 || "minute" === n3 || "mins" === n3 || "min" === n3 || "m" === n3 ? 6e4 * r3 : "seconds" === n3 || "second" === n3 || "secs" === n3 || "sec" === n3 || "s" === n3 ? 1e3 * r3 : "milliseconds" === n3 || "millisecond" === n3 || "msecs" === n3 || "msec" === n3 || "ms" === n3 ? r3 : void 0;
              }
            }
          }
          function o(e2) {
            var t4 = n2(e2);
            return 864e5 <= t4 ? r2(e2 / 864e5) + "d" : 36e5 <= t4 ? r2(e2 / 36e5) + "h" : 6e4 <= t4 ? r2(e2 / 6e4) + "m" : 1e3 <= t4 ? r2(e2 / 1e3) + "s" : e2 + "ms";
          }
          function i(e2) {
            var t4 = n2(e2);
            return 864e5 <= t4 ? s(e2, t4, 864e5, "day") : 36e5 <= t4 ? s(e2, t4, 36e5, "hour") : 6e4 <= t4 ? s(e2, t4, 6e4, "minute") : 1e3 <= t4 ? s(e2, t4, 1e3, "second") : e2 + " ms";
          }
          function s(e2, t4, a3, n3) {
            return r2(e2 / a3) + " " + n3 + (t4 >= 1.5 * a3 ? "s" : "");
          }
          var l = 24 * (60 * 6e4);
          t3.exports = function(e2, t4) {
            t4 = t4 || {};
            var n3 = typeof e2;
            if ("string" == n3 && 0 < e2.length)
              return a2(e2);
            if ("number" === n3 && isFinite(e2))
              return t4.long ? i(e2) : o(e2);
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e2));
          };
        }, {}], 12: [function(e, t3) {
          function n3() {
            throw new Error("setTimeout has not been defined");
          }
          function r2() {
            throw new Error("clearTimeout has not been defined");
          }
          function a2(t4) {
            if (c2 === setTimeout)
              return setTimeout(t4, 0);
            if ((c2 === n3 || !c2) && setTimeout)
              return c2 = setTimeout, setTimeout(t4, 0);
            try {
              return c2(t4, 0);
            } catch (n4) {
              try {
                return c2.call(null, t4, 0);
              } catch (n5) {
                return c2.call(this, t4, 0);
              }
            }
          }
          function o(t4) {
            if (u === clearTimeout)
              return clearTimeout(t4);
            if ((u === r2 || !u) && clearTimeout)
              return u = clearTimeout, clearTimeout(t4);
            try {
              return u(t4);
            } catch (n4) {
              try {
                return u.call(null, t4);
              } catch (n5) {
                return u.call(this, t4);
              }
            }
          }
          function i() {
            _ && f && (_ = false, f.length ? g = f.concat(g) : h2 = -1, g.length && d());
          }
          function d() {
            if (!_) {
              var e2 = a2(i);
              _ = true;
              for (var t4 = g.length; t4; ) {
                for (f = g, g = []; ++h2 < t4; )
                  f && f[h2].run();
                h2 = -1, t4 = g.length;
              }
              f = null, _ = false, o(e2);
            }
          }
          function s(e2, t4) {
            this.fun = e2, this.array = t4;
          }
          function l() {
          }
          var c2, u, p = t3.exports = {};
          (function() {
            try {
              c2 = "function" == typeof setTimeout ? setTimeout : n3;
            } catch (t4) {
              c2 = n3;
            }
            try {
              u = "function" == typeof clearTimeout ? clearTimeout : r2;
            } catch (t4) {
              u = r2;
            }
          })();
          var f, g = [], _ = false, h2 = -1;
          p.nextTick = function(e2) {
            var t4 = Array(arguments.length - 1);
            if (1 < arguments.length)
              for (var n4 = 1; n4 < arguments.length; n4++)
                t4[n4 - 1] = arguments[n4];
            g.push(new s(e2, t4)), 1 !== g.length || _ || a2(d);
          }, s.prototype.run = function() {
            this.fun.apply(null, this.array);
          }, p.title = "browser", p.browser = true, p.env = {}, p.argv = [], p.version = "", p.versions = {}, p.on = l, p.addListener = l, p.once = l, p.off = l, p.removeListener = l, p.removeAllListeners = l, p.emit = l, p.prependListener = l, p.prependOnceListener = l, p.listeners = function() {
            return [];
          }, p.binding = function() {
            throw new Error("process.binding is not supported");
          }, p.cwd = function() {
            return "/";
          }, p.chdir = function() {
            throw new Error("process.chdir is not supported");
          }, p.umask = function() {
            return 0;
          };
        }, {}], 13: [function(e, t3) {
          (function(e2) {
            (function() {
              let n3;
              t3.exports = "function" == typeof queueMicrotask ? queueMicrotask.bind("undefined" == typeof window ? e2 : window) : (e3) => (n3 || (n3 = Promise.resolve())).then(e3).catch((e4) => setTimeout(() => {
                throw e4;
              }, 0));
            }).call(this);
          }).call(this, "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
        }, {}], 14: [function(e, t3) {
          (function(n3, r2) {
            (function() {
              "use strict";
              var a2 = e("safe-buffer").Buffer, o = r2.crypto || r2.msCrypto;
              t3.exports = o && o.getRandomValues ? function(e2, t4) {
                if (e2 > 4294967295)
                  throw new RangeError("requested too many random bytes");
                var r3 = a2.allocUnsafe(e2);
                if (0 < e2)
                  if (65536 < e2)
                    for (var i = 0; i < e2; i += 65536)
                      o.getRandomValues(r3.slice(i, i + 65536));
                  else
                    o.getRandomValues(r3);
                return "function" == typeof t4 ? n3.nextTick(function() {
                  t4(null, r3);
                }) : r3;
              } : function() {
                throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
              };
            }).call(this);
          }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
        }, { _process: 12, "safe-buffer": 30 }], 15: [function(e, t3) {
          "use strict";
          function n3(e2, t4) {
            e2.prototype = Object.create(t4.prototype), e2.prototype.constructor = e2, e2.__proto__ = t4;
          }
          function r2(e2, t4, r3) {
            function a3(e3, n4, r4) {
              return "string" == typeof t4 ? t4 : t4(e3, n4, r4);
            }
            r3 || (r3 = Error);
            var o2 = function(e3) {
              function t5(t6, n4, r4) {
                return e3.call(this, a3(t6, n4, r4)) || this;
              }
              return n3(t5, e3), t5;
            }(r3);
            o2.prototype.name = r3.name, o2.prototype.code = e2, s[e2] = o2;
          }
          function a2(e2, t4) {
            if (Array.isArray(e2)) {
              var n4 = e2.length;
              return e2 = e2.map(function(e3) {
                return e3 + "";
              }), 2 < n4 ? "one of ".concat(t4, " ").concat(e2.slice(0, n4 - 1).join(", "), ", or ") + e2[n4 - 1] : 2 === n4 ? "one of ".concat(t4, " ").concat(e2[0], " or ").concat(e2[1]) : "of ".concat(t4, " ").concat(e2[0]);
            }
            return "of ".concat(t4, " ").concat(e2 + "");
          }
          function o(e2, t4, n4) {
            return e2.substr(!n4 || 0 > n4 ? 0 : +n4, t4.length) === t4;
          }
          function i(e2, t4, n4) {
            return (void 0 === n4 || n4 > e2.length) && (n4 = e2.length), e2.substring(n4 - t4.length, n4) === t4;
          }
          function d(e2, t4, n4) {
            return "number" != typeof n4 && (n4 = 0), !(n4 + t4.length > e2.length) && -1 !== e2.indexOf(t4, n4);
          }
          var s = {};
          r2("ERR_INVALID_OPT_VALUE", function(e2, t4) {
            return 'The value "' + t4 + '" is invalid for option "' + e2 + '"';
          }, TypeError), r2("ERR_INVALID_ARG_TYPE", function(e2, t4, n4) {
            var r3;
            "string" == typeof t4 && o(t4, "not ") ? (r3 = "must not be", t4 = t4.replace(/^not /, "")) : r3 = "must be";
            var s2;
            if (i(e2, " argument"))
              s2 = "The ".concat(e2, " ").concat(r3, " ").concat(a2(t4, "type"));
            else {
              var l = d(e2, ".") ? "property" : "argument";
              s2 = 'The "'.concat(e2, '" ').concat(l, " ").concat(r3, " ").concat(a2(t4, "type"));
            }
            return s2 += ". Received type ".concat(typeof n4), s2;
          }, TypeError), r2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), r2("ERR_METHOD_NOT_IMPLEMENTED", function(e2) {
            return "The " + e2 + " method is not implemented";
          }), r2("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), r2("ERR_STREAM_DESTROYED", function(e2) {
            return "Cannot call " + e2 + " after a stream was destroyed";
          }), r2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), r2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), r2("ERR_STREAM_WRITE_AFTER_END", "write after end"), r2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), r2("ERR_UNKNOWN_ENCODING", function(e2) {
            return "Unknown encoding: " + e2;
          }, TypeError), r2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t3.exports.codes = s;
        }, {}], 16: [function(e, t3) {
          (function(n3) {
            (function() {
              "use strict";
              function r2(e2) {
                return this instanceof r2 ? void (d.call(this, e2), s.call(this, e2), this.allowHalfOpen = true, e2 && (false === e2.readable && (this.readable = false), false === e2.writable && (this.writable = false), false === e2.allowHalfOpen && (this.allowHalfOpen = false, this.once("end", a2)))) : new r2(e2);
              }
              function a2() {
                this._writableState.ended || n3.nextTick(o, this);
              }
              function o(e2) {
                e2.end();
              }
              var i = Object.keys || function(e2) {
                var t4 = [];
                for (var n4 in e2)
                  t4.push(n4);
                return t4;
              };
              t3.exports = r2;
              var d = e("./_stream_readable"), s = e("./_stream_writable");
              e("inherits")(r2, d);
              for (var l, c2 = i(s.prototype), u = 0; u < c2.length; u++)
                l = c2[u], r2.prototype[l] || (r2.prototype[l] = s.prototype[l]);
              Object.defineProperty(r2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
                return this._writableState.highWaterMark;
              } }), Object.defineProperty(r2.prototype, "writableBuffer", { enumerable: false, get: function() {
                return this._writableState && this._writableState.getBuffer();
              } }), Object.defineProperty(r2.prototype, "writableLength", { enumerable: false, get: function() {
                return this._writableState.length;
              } }), Object.defineProperty(r2.prototype, "destroyed", { enumerable: false, get: function() {
                return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
              }, set: function(e2) {
                void 0 === this._readableState || void 0 === this._writableState || (this._readableState.destroyed = e2, this._writableState.destroyed = e2);
              } });
            }).call(this);
          }).call(this, e("_process"));
        }, { "./_stream_readable": 18, "./_stream_writable": 20, _process: 12, inherits: 10 }], 17: [function(e, t3) {
          "use strict";
          function n3(e2) {
            return this instanceof n3 ? void r2.call(this, e2) : new n3(e2);
          }
          t3.exports = n3;
          var r2 = e("./_stream_transform");
          e("inherits")(n3, r2), n3.prototype._transform = function(e2, t4, n4) {
            n4(null, e2);
          };
        }, { "./_stream_transform": 19, inherits: 10 }], 18: [function(e, t3) {
          (function(n3, r2) {
            (function() {
              "use strict";
              function a2(e2) {
                return P.from(e2);
              }
              function o(e2) {
                return P.isBuffer(e2) || e2 instanceof M;
              }
              function i(e2, t4, n4) {
                return "function" == typeof e2.prependListener ? e2.prependListener(t4, n4) : void (e2._events && e2._events[t4] ? Array.isArray(e2._events[t4]) ? e2._events[t4].unshift(n4) : e2._events[t4] = [n4, e2._events[t4]] : e2.on(t4, n4));
              }
              function d(t4, n4, r3) {
                A = A || e("./_stream_duplex"), t4 = t4 || {}, "boolean" != typeof r3 && (r3 = n4 instanceof A), this.objectMode = !!t4.objectMode, r3 && (this.objectMode = this.objectMode || !!t4.readableObjectMode), this.highWaterMark = H(this, t4, "readableHighWaterMark", r3), this.buffer = new j(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = false !== t4.emitClose, this.autoDestroy = !!t4.autoDestroy, this.destroyed = false, this.defaultEncoding = t4.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t4.encoding && (!F && (F = e("string_decoder/").StringDecoder), this.decoder = new F(t4.encoding), this.encoding = t4.encoding);
              }
              function s(t4) {
                if (A = A || e("./_stream_duplex"), !(this instanceof s))
                  return new s(t4);
                var n4 = this instanceof A;
                this._readableState = new d(t4, this, n4), this.readable = true, t4 && ("function" == typeof t4.read && (this._read = t4.read), "function" == typeof t4.destroy && (this._destroy = t4.destroy)), I.call(this);
              }
              function l(e2, t4, n4, r3, o2) {
                x3("readableAddChunk", t4);
                var i2 = e2._readableState;
                if (null === t4)
                  i2.reading = false, g(e2, i2);
                else {
                  var d2;
                  if (o2 || (d2 = u(i2, t4)), d2)
                    X(e2, d2);
                  else if (!(i2.objectMode || t4 && 0 < t4.length))
                    r3 || (i2.reading = false, m2(e2, i2));
                  else if ("string" == typeof t4 || i2.objectMode || Object.getPrototypeOf(t4) === P.prototype || (t4 = a2(t4)), r3)
                    i2.endEmitted ? X(e2, new K()) : c2(e2, i2, t4, true);
                  else if (i2.ended)
                    X(e2, new z());
                  else {
                    if (i2.destroyed)
                      return false;
                    i2.reading = false, i2.decoder && !n4 ? (t4 = i2.decoder.write(t4), i2.objectMode || 0 !== t4.length ? c2(e2, i2, t4, false) : m2(e2, i2)) : c2(e2, i2, t4, false);
                  }
                }
                return !i2.ended && (i2.length < i2.highWaterMark || 0 === i2.length);
              }
              function c2(e2, t4, n4, r3) {
                t4.flowing && 0 === t4.length && !t4.sync ? (t4.awaitDrain = 0, e2.emit("data", n4)) : (t4.length += t4.objectMode ? 1 : n4.length, r3 ? t4.buffer.unshift(n4) : t4.buffer.push(n4), t4.needReadable && _(e2)), m2(e2, t4);
              }
              function u(e2, t4) {
                var n4;
                return o(t4) || "string" == typeof t4 || void 0 === t4 || e2.objectMode || (n4 = new V("chunk", ["string", "Buffer", "Uint8Array"], t4)), n4;
              }
              function p(e2) {
                return 1073741824 <= e2 ? e2 = 1073741824 : (e2--, e2 |= e2 >>> 1, e2 |= e2 >>> 2, e2 |= e2 >>> 4, e2 |= e2 >>> 8, e2 |= e2 >>> 16, e2++), e2;
              }
              function f(e2, t4) {
                return 0 >= e2 || 0 === t4.length && t4.ended ? 0 : t4.objectMode ? 1 : e2 === e2 ? (e2 > t4.highWaterMark && (t4.highWaterMark = p(e2)), e2 <= t4.length ? e2 : t4.ended ? t4.length : (t4.needReadable = true, 0)) : t4.flowing && t4.length ? t4.buffer.head.data.length : t4.length;
              }
              function g(e2, t4) {
                if (x3("onEofChunk"), !t4.ended) {
                  if (t4.decoder) {
                    var n4 = t4.decoder.end();
                    n4 && n4.length && (t4.buffer.push(n4), t4.length += t4.objectMode ? 1 : n4.length);
                  }
                  t4.ended = true, t4.sync ? _(e2) : (t4.needReadable = false, !t4.emittedReadable && (t4.emittedReadable = true, h2(e2)));
                }
              }
              function _(e2) {
                var t4 = e2._readableState;
                x3("emitReadable", t4.needReadable, t4.emittedReadable), t4.needReadable = false, t4.emittedReadable || (x3("emitReadable", t4.flowing), t4.emittedReadable = true, n3.nextTick(h2, e2));
              }
              function h2(e2) {
                var t4 = e2._readableState;
                x3("emitReadable_", t4.destroyed, t4.length, t4.ended), !t4.destroyed && (t4.length || t4.ended) && (e2.emit("readable"), t4.emittedReadable = false), t4.needReadable = !t4.flowing && !t4.ended && t4.length <= t4.highWaterMark, S2(e2);
              }
              function m2(e2, t4) {
                t4.readingMore || (t4.readingMore = true, n3.nextTick(b, e2, t4));
              }
              function b(e2, t4) {
                for (; !t4.reading && !t4.ended && (t4.length < t4.highWaterMark || t4.flowing && 0 === t4.length); ) {
                  var n4 = t4.length;
                  if (x3("maybeReadMore read 0"), e2.read(0), n4 === t4.length)
                    break;
                }
                t4.readingMore = false;
              }
              function y3(e2) {
                return function() {
                  var t4 = e2._readableState;
                  x3("pipeOnDrain", t4.awaitDrain), t4.awaitDrain && t4.awaitDrain--, 0 === t4.awaitDrain && D(e2, "data") && (t4.flowing = true, S2(e2));
                };
              }
              function C2(e2) {
                var t4 = e2._readableState;
                t4.readableListening = 0 < e2.listenerCount("readable"), t4.resumeScheduled && !t4.paused ? t4.flowing = true : 0 < e2.listenerCount("data") && e2.resume();
              }
              function R(e2) {
                x3("readable nexttick read 0"), e2.read(0);
              }
              function E(e2, t4) {
                t4.resumeScheduled || (t4.resumeScheduled = true, n3.nextTick(w, e2, t4));
              }
              function w(e2, t4) {
                x3("resume", t4.reading), t4.reading || e2.read(0), t4.resumeScheduled = false, e2.emit("resume"), S2(e2), t4.flowing && !t4.reading && e2.read(0);
              }
              function S2(e2) {
                var t4 = e2._readableState;
                for (x3("flow", t4.flowing); t4.flowing && null !== e2.read(); )
                  ;
              }
              function T(e2, t4) {
                if (0 === t4.length)
                  return null;
                var n4;
                return t4.objectMode ? n4 = t4.buffer.shift() : !e2 || e2 >= t4.length ? (n4 = t4.decoder ? t4.buffer.join("") : 1 === t4.buffer.length ? t4.buffer.first() : t4.buffer.concat(t4.length), t4.buffer.clear()) : n4 = t4.buffer.consume(e2, t4.decoder), n4;
              }
              function v(e2) {
                var t4 = e2._readableState;
                x3("endReadable", t4.endEmitted), t4.endEmitted || (t4.ended = true, n3.nextTick(k, t4, e2));
              }
              function k(e2, t4) {
                if (x3("endReadableNT", e2.endEmitted, e2.length), !e2.endEmitted && 0 === e2.length && (e2.endEmitted = true, t4.readable = false, t4.emit("end"), e2.autoDestroy)) {
                  var n4 = t4._writableState;
                  (!n4 || n4.autoDestroy && n4.finished) && t4.destroy();
                }
              }
              function L(e2, t4) {
                for (var n4 = 0, r3 = e2.length; n4 < r3; n4++)
                  if (e2[n4] === t4)
                    return n4;
                return -1;
              }
              t3.exports = s;
              var A;
              s.ReadableState = d;
              var x3, N = e("events").EventEmitter, D = function(e2, t4) {
                return e2.listeners(t4).length;
              }, I = e("./internal/streams/stream"), P = e("buffer").Buffer, M = r2.Uint8Array || function() {
              }, O = e("util");
              x3 = O && O.debuglog ? O.debuglog("stream") : function() {
              };
              var F, B, U, j = e("./internal/streams/buffer_list"), q = e("./internal/streams/destroy"), W = e("./internal/streams/state"), H = W.getHighWaterMark, Y = e("../errors").codes, V = Y.ERR_INVALID_ARG_TYPE, z = Y.ERR_STREAM_PUSH_AFTER_EOF, G = Y.ERR_METHOD_NOT_IMPLEMENTED, K = Y.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
              e("inherits")(s, I);
              var X = q.errorOrDestroy, $ = ["error", "close", "destroy", "pause", "resume"];
              Object.defineProperty(s.prototype, "destroyed", { enumerable: false, get: function() {
                return void 0 !== this._readableState && this._readableState.destroyed;
              }, set: function(e2) {
                this._readableState && (this._readableState.destroyed = e2);
              } }), s.prototype.destroy = q.destroy, s.prototype._undestroy = q.undestroy, s.prototype._destroy = function(e2, t4) {
                t4(e2);
              }, s.prototype.push = function(e2, t4) {
                var n4, r3 = this._readableState;
                return r3.objectMode ? n4 = true : "string" == typeof e2 && (t4 = t4 || r3.defaultEncoding, t4 !== r3.encoding && (e2 = P.from(e2, t4), t4 = ""), n4 = true), l(this, e2, t4, false, n4);
              }, s.prototype.unshift = function(e2) {
                return l(this, e2, null, true, false);
              }, s.prototype.isPaused = function() {
                return false === this._readableState.flowing;
              }, s.prototype.setEncoding = function(t4) {
                F || (F = e("string_decoder/").StringDecoder);
                var n4 = new F(t4);
                this._readableState.decoder = n4, this._readableState.encoding = this._readableState.decoder.encoding;
                for (var r3 = this._readableState.buffer.head, a3 = ""; null !== r3; )
                  a3 += n4.write(r3.data), r3 = r3.next;
                return this._readableState.buffer.clear(), "" !== a3 && this._readableState.buffer.push(a3), this._readableState.length = a3.length, this;
              };
              s.prototype.read = function(e2) {
                x3("read", e2), e2 = parseInt(e2, 10);
                var t4 = this._readableState, r3 = e2;
                if (0 !== e2 && (t4.emittedReadable = false), 0 === e2 && t4.needReadable && ((0 === t4.highWaterMark ? 0 < t4.length : t4.length >= t4.highWaterMark) || t4.ended))
                  return x3("read: emitReadable", t4.length, t4.ended), 0 === t4.length && t4.ended ? v(this) : _(this), null;
                if (e2 = f(e2, t4), 0 === e2 && t4.ended)
                  return 0 === t4.length && v(this), null;
                var a3 = t4.needReadable;
                x3("need readable", a3), (0 === t4.length || t4.length - e2 < t4.highWaterMark) && (a3 = true, x3("length less than watermark", a3)), t4.ended || t4.reading ? (a3 = false, x3("reading or ended", a3)) : a3 && (x3("do read"), t4.reading = true, t4.sync = true, 0 === t4.length && (t4.needReadable = true), this._read(t4.highWaterMark), t4.sync = false, !t4.reading && (e2 = f(r3, t4)));
                var o2;
                return o2 = 0 < e2 ? T(e2, t4) : null, null === o2 ? (t4.needReadable = t4.length <= t4.highWaterMark, e2 = 0) : (t4.length -= e2, t4.awaitDrain = 0), 0 === t4.length && (!t4.ended && (t4.needReadable = true), r3 !== e2 && t4.ended && v(this)), null !== o2 && this.emit("data", o2), o2;
              }, s.prototype._read = function() {
                X(this, new G("_read()"));
              }, s.prototype.pipe = function(e2, t4) {
                function r3(e3, t5) {
                  x3("onunpipe"), e3 === p2 && t5 && false === t5.hasUnpiped && (t5.hasUnpiped = true, o2());
                }
                function a3() {
                  x3("onend"), e2.end();
                }
                function o2() {
                  x3("cleanup"), e2.removeListener("close", l2), e2.removeListener("finish", c3), e2.removeListener("drain", h3), e2.removeListener("error", s2), e2.removeListener("unpipe", r3), p2.removeListener("end", a3), p2.removeListener("end", u2), p2.removeListener("data", d2), m3 = true, f2.awaitDrain && (!e2._writableState || e2._writableState.needDrain) && h3();
                }
                function d2(t5) {
                  x3("ondata");
                  var n4 = e2.write(t5);
                  x3("dest.write", n4), false === n4 && ((1 === f2.pipesCount && f2.pipes === e2 || 1 < f2.pipesCount && -1 !== L(f2.pipes, e2)) && !m3 && (x3("false write response, pause", f2.awaitDrain), f2.awaitDrain++), p2.pause());
                }
                function s2(t5) {
                  x3("onerror", t5), u2(), e2.removeListener("error", s2), 0 === D(e2, "error") && X(e2, t5);
                }
                function l2() {
                  e2.removeListener("finish", c3), u2();
                }
                function c3() {
                  x3("onfinish"), e2.removeListener("close", l2), u2();
                }
                function u2() {
                  x3("unpipe"), p2.unpipe(e2);
                }
                var p2 = this, f2 = this._readableState;
                switch (f2.pipesCount) {
                  case 0:
                    f2.pipes = e2;
                    break;
                  case 1:
                    f2.pipes = [f2.pipes, e2];
                    break;
                  default:
                    f2.pipes.push(e2);
                }
                f2.pipesCount += 1, x3("pipe count=%d opts=%j", f2.pipesCount, t4);
                var g2 = (!t4 || false !== t4.end) && e2 !== n3.stdout && e2 !== n3.stderr, _2 = g2 ? a3 : u2;
                f2.endEmitted ? n3.nextTick(_2) : p2.once("end", _2), e2.on("unpipe", r3);
                var h3 = y3(p2);
                e2.on("drain", h3);
                var m3 = false;
                return p2.on("data", d2), i(e2, "error", s2), e2.once("close", l2), e2.once("finish", c3), e2.emit("pipe", p2), f2.flowing || (x3("pipe resume"), p2.resume()), e2;
              }, s.prototype.unpipe = function(e2) {
                var t4 = this._readableState, n4 = { hasUnpiped: false };
                if (0 === t4.pipesCount)
                  return this;
                if (1 === t4.pipesCount)
                  return e2 && e2 !== t4.pipes ? this : (e2 || (e2 = t4.pipes), t4.pipes = null, t4.pipesCount = 0, t4.flowing = false, e2 && e2.emit("unpipe", this, n4), this);
                if (!e2) {
                  var r3 = t4.pipes, a3 = t4.pipesCount;
                  t4.pipes = null, t4.pipesCount = 0, t4.flowing = false;
                  for (var o2 = 0; o2 < a3; o2++)
                    r3[o2].emit("unpipe", this, { hasUnpiped: false });
                  return this;
                }
                var d2 = L(t4.pipes, e2);
                return -1 === d2 ? this : (t4.pipes.splice(d2, 1), t4.pipesCount -= 1, 1 === t4.pipesCount && (t4.pipes = t4.pipes[0]), e2.emit("unpipe", this, n4), this);
              }, s.prototype.on = function(e2, t4) {
                var r3 = I.prototype.on.call(this, e2, t4), a3 = this._readableState;
                return "data" === e2 ? (a3.readableListening = 0 < this.listenerCount("readable"), false !== a3.flowing && this.resume()) : "readable" == e2 && !a3.endEmitted && !a3.readableListening && (a3.readableListening = a3.needReadable = true, a3.flowing = false, a3.emittedReadable = false, x3("on readable", a3.length, a3.reading), a3.length ? _(this) : !a3.reading && n3.nextTick(R, this)), r3;
              }, s.prototype.addListener = s.prototype.on, s.prototype.removeListener = function(e2, t4) {
                var r3 = I.prototype.removeListener.call(this, e2, t4);
                return "readable" === e2 && n3.nextTick(C2, this), r3;
              }, s.prototype.removeAllListeners = function(e2) {
                var t4 = I.prototype.removeAllListeners.apply(this, arguments);
                return ("readable" === e2 || void 0 === e2) && n3.nextTick(C2, this), t4;
              }, s.prototype.resume = function() {
                var e2 = this._readableState;
                return e2.flowing || (x3("resume"), e2.flowing = !e2.readableListening, E(this, e2)), e2.paused = false, this;
              }, s.prototype.pause = function() {
                return x3("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (x3("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
              }, s.prototype.wrap = function(e2) {
                var t4 = this, r3 = this._readableState, a3 = false;
                for (var o2 in e2.on("end", function() {
                  if (x3("wrapped end"), r3.decoder && !r3.ended) {
                    var e3 = r3.decoder.end();
                    e3 && e3.length && t4.push(e3);
                  }
                  t4.push(null);
                }), e2.on("data", function(n4) {
                  if ((x3("wrapped data"), r3.decoder && (n4 = r3.decoder.write(n4)), !(r3.objectMode && (null === n4 || void 0 === n4))) && (r3.objectMode || n4 && n4.length)) {
                    var o3 = t4.push(n4);
                    o3 || (a3 = true, e2.pause());
                  }
                }), e2)
                  void 0 === this[o2] && "function" == typeof e2[o2] && (this[o2] = function(t5) {
                    return function() {
                      return e2[t5].apply(e2, arguments);
                    };
                  }(o2));
                for (var i2 = 0; i2 < $.length; i2++)
                  e2.on($[i2], this.emit.bind(this, $[i2]));
                return this._read = function(t5) {
                  x3("wrapped _read", t5), a3 && (a3 = false, e2.resume());
                }, this;
              }, "function" == typeof Symbol && (s.prototype[Symbol.asyncIterator] = function() {
                return void 0 === B && (B = e("./internal/streams/async_iterator")), B(this);
              }), Object.defineProperty(s.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
                return this._readableState.highWaterMark;
              } }), Object.defineProperty(s.prototype, "readableBuffer", { enumerable: false, get: function() {
                return this._readableState && this._readableState.buffer;
              } }), Object.defineProperty(s.prototype, "readableFlowing", { enumerable: false, get: function() {
                return this._readableState.flowing;
              }, set: function(e2) {
                this._readableState && (this._readableState.flowing = e2);
              } }), s._fromList = T, Object.defineProperty(s.prototype, "readableLength", { enumerable: false, get: function() {
                return this._readableState.length;
              } }), "function" == typeof Symbol && (s.from = function(t4, n4) {
                return void 0 === U && (U = e("./internal/streams/from")), U(s, t4, n4);
              });
            }).call(this);
          }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
        }, { "../errors": 15, "./_stream_duplex": 16, "./internal/streams/async_iterator": 21, "./internal/streams/buffer_list": 22, "./internal/streams/destroy": 23, "./internal/streams/from": 25, "./internal/streams/state": 27, "./internal/streams/stream": 28, _process: 12, buffer: 3, events: 7, inherits: 10, "string_decoder/": 31, util: 2 }], 19: [function(e, t3) {
          "use strict";
          function n3(e2, t4) {
            var n4 = this._transformState;
            n4.transforming = false;
            var r3 = n4.writecb;
            if (null === r3)
              return this.emit("error", new s());
            n4.writechunk = null, n4.writecb = null, null != t4 && this.push(t4), r3(e2);
            var a3 = this._readableState;
            a3.reading = false, (a3.needReadable || a3.length < a3.highWaterMark) && this._read(a3.highWaterMark);
          }
          function r2(e2) {
            return this instanceof r2 ? void (u.call(this, e2), this._transformState = { afterTransform: n3.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e2 && ("function" == typeof e2.transform && (this._transform = e2.transform), "function" == typeof e2.flush && (this._flush = e2.flush)), this.on("prefinish", a2)) : new r2(e2);
          }
          function a2() {
            var e2 = this;
            "function" != typeof this._flush || this._readableState.destroyed ? o(this, null, null) : this._flush(function(t4, n4) {
              o(e2, t4, n4);
            });
          }
          function o(e2, t4, n4) {
            if (t4)
              return e2.emit("error", t4);
            if (null != n4 && e2.push(n4), e2._writableState.length)
              throw new c2();
            if (e2._transformState.transforming)
              throw new l();
            return e2.push(null);
          }
          t3.exports = r2;
          var i = e("../errors").codes, d = i.ERR_METHOD_NOT_IMPLEMENTED, s = i.ERR_MULTIPLE_CALLBACK, l = i.ERR_TRANSFORM_ALREADY_TRANSFORMING, c2 = i.ERR_TRANSFORM_WITH_LENGTH_0, u = e("./_stream_duplex");
          e("inherits")(r2, u), r2.prototype.push = function(e2, t4) {
            return this._transformState.needTransform = false, u.prototype.push.call(this, e2, t4);
          }, r2.prototype._transform = function(e2, t4, n4) {
            n4(new d("_transform()"));
          }, r2.prototype._write = function(e2, t4, n4) {
            var r3 = this._transformState;
            if (r3.writecb = n4, r3.writechunk = e2, r3.writeencoding = t4, !r3.transforming) {
              var a3 = this._readableState;
              (r3.needTransform || a3.needReadable || a3.length < a3.highWaterMark) && this._read(a3.highWaterMark);
            }
          }, r2.prototype._read = function() {
            var e2 = this._transformState;
            null === e2.writechunk || e2.transforming ? e2.needTransform = true : (e2.transforming = true, this._transform(e2.writechunk, e2.writeencoding, e2.afterTransform));
          }, r2.prototype._destroy = function(e2, t4) {
            u.prototype._destroy.call(this, e2, function(e3) {
              t4(e3);
            });
          };
        }, { "../errors": 15, "./_stream_duplex": 16, inherits: 10 }], 20: [function(e, t3) {
          (function(n3, r2) {
            (function() {
              "use strict";
              function a2(e2) {
                var t4 = this;
                this.next = null, this.entry = null, this.finish = function() {
                  v(t4, e2);
                };
              }
              function o(e2) {
                return x3.from(e2);
              }
              function i(e2) {
                return x3.isBuffer(e2) || e2 instanceof N;
              }
              function d() {
              }
              function s(t4, n4, r3) {
                k = k || e("./_stream_duplex"), t4 = t4 || {}, "boolean" != typeof r3 && (r3 = n4 instanceof k), this.objectMode = !!t4.objectMode, r3 && (this.objectMode = this.objectMode || !!t4.writableObjectMode), this.highWaterMark = P(this, t4, "writableHighWaterMark", r3), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
                var o2 = false === t4.decodeStrings;
                this.decodeStrings = !o2, this.defaultEncoding = t4.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(e2) {
                  m2(n4, e2);
                }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = false !== t4.emitClose, this.autoDestroy = !!t4.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a2(this);
              }
              function l(t4) {
                k = k || e("./_stream_duplex");
                var n4 = this instanceof k;
                return n4 || V.call(l, this) ? void (this._writableState = new s(t4, this, n4), this.writable = true, t4 && ("function" == typeof t4.write && (this._write = t4.write), "function" == typeof t4.writev && (this._writev = t4.writev), "function" == typeof t4.destroy && (this._destroy = t4.destroy), "function" == typeof t4.final && (this._final = t4.final)), A.call(this)) : new l(t4);
              }
              function c2(e2, t4) {
                var r3 = new W();
                Y(e2, r3), n3.nextTick(t4, r3);
              }
              function u(e2, t4, r3, a3) {
                var o2;
                return null === r3 ? o2 = new q() : "string" != typeof r3 && !t4.objectMode && (o2 = new O("chunk", ["string", "Buffer"], r3)), !o2 || (Y(e2, o2), n3.nextTick(a3, o2), false);
              }
              function p(e2, t4, n4) {
                return e2.objectMode || false === e2.decodeStrings || "string" != typeof t4 || (t4 = x3.from(t4, n4)), t4;
              }
              function f(e2, t4, n4, r3, a3, o2) {
                if (!n4) {
                  var i2 = p(t4, r3, a3);
                  r3 !== i2 && (n4 = true, a3 = "buffer", r3 = i2);
                }
                var d2 = t4.objectMode ? 1 : r3.length;
                t4.length += d2;
                var s2 = t4.length < t4.highWaterMark;
                if (s2 || (t4.needDrain = true), t4.writing || t4.corked) {
                  var l2 = t4.lastBufferedRequest;
                  t4.lastBufferedRequest = { chunk: r3, encoding: a3, isBuf: n4, callback: o2, next: null }, l2 ? l2.next = t4.lastBufferedRequest : t4.bufferedRequest = t4.lastBufferedRequest, t4.bufferedRequestCount += 1;
                } else
                  g(e2, t4, false, d2, r3, a3, o2);
                return s2;
              }
              function g(e2, t4, n4, r3, a3, o2, i2) {
                t4.writelen = r3, t4.writecb = i2, t4.writing = true, t4.sync = true, t4.destroyed ? t4.onwrite(new j("write")) : n4 ? e2._writev(a3, t4.onwrite) : e2._write(a3, o2, t4.onwrite), t4.sync = false;
              }
              function _(e2, t4, r3, a3, o2) {
                --t4.pendingcb, r3 ? (n3.nextTick(o2, a3), n3.nextTick(S2, e2, t4), e2._writableState.errorEmitted = true, Y(e2, a3)) : (o2(a3), e2._writableState.errorEmitted = true, Y(e2, a3), S2(e2, t4));
              }
              function h2(e2) {
                e2.writing = false, e2.writecb = null, e2.length -= e2.writelen, e2.writelen = 0;
              }
              function m2(e2, t4) {
                var r3 = e2._writableState, a3 = r3.sync, o2 = r3.writecb;
                if ("function" != typeof o2)
                  throw new B();
                if (h2(r3), t4)
                  _(e2, r3, a3, t4, o2);
                else {
                  var i2 = R(r3) || e2.destroyed;
                  i2 || r3.corked || r3.bufferProcessing || !r3.bufferedRequest || C2(e2, r3), a3 ? n3.nextTick(b, e2, r3, i2, o2) : b(e2, r3, i2, o2);
                }
              }
              function b(e2, t4, n4, r3) {
                n4 || y3(e2, t4), t4.pendingcb--, r3(), S2(e2, t4);
              }
              function y3(e2, t4) {
                0 === t4.length && t4.needDrain && (t4.needDrain = false, e2.emit("drain"));
              }
              function C2(e2, t4) {
                t4.bufferProcessing = true;
                var n4 = t4.bufferedRequest;
                if (e2._writev && n4 && n4.next) {
                  var r3 = t4.bufferedRequestCount, o2 = Array(r3), i2 = t4.corkedRequestsFree;
                  i2.entry = n4;
                  for (var d2 = 0, s2 = true; n4; )
                    o2[d2] = n4, n4.isBuf || (s2 = false), n4 = n4.next, d2 += 1;
                  o2.allBuffers = s2, g(e2, t4, true, t4.length, o2, "", i2.finish), t4.pendingcb++, t4.lastBufferedRequest = null, i2.next ? (t4.corkedRequestsFree = i2.next, i2.next = null) : t4.corkedRequestsFree = new a2(t4), t4.bufferedRequestCount = 0;
                } else {
                  for (; n4; ) {
                    var l2 = n4.chunk, c3 = n4.encoding, u2 = n4.callback, p2 = t4.objectMode ? 1 : l2.length;
                    if (g(e2, t4, false, p2, l2, c3, u2), n4 = n4.next, t4.bufferedRequestCount--, t4.writing)
                      break;
                  }
                  null === n4 && (t4.lastBufferedRequest = null);
                }
                t4.bufferedRequest = n4, t4.bufferProcessing = false;
              }
              function R(e2) {
                return e2.ending && 0 === e2.length && null === e2.bufferedRequest && !e2.finished && !e2.writing;
              }
              function E(e2, t4) {
                e2._final(function(n4) {
                  t4.pendingcb--, n4 && Y(e2, n4), t4.prefinished = true, e2.emit("prefinish"), S2(e2, t4);
                });
              }
              function w(e2, t4) {
                t4.prefinished || t4.finalCalled || ("function" != typeof e2._final || t4.destroyed ? (t4.prefinished = true, e2.emit("prefinish")) : (t4.pendingcb++, t4.finalCalled = true, n3.nextTick(E, e2, t4)));
              }
              function S2(e2, t4) {
                var n4 = R(t4);
                if (n4 && (w(e2, t4), 0 === t4.pendingcb && (t4.finished = true, e2.emit("finish"), t4.autoDestroy))) {
                  var r3 = e2._readableState;
                  (!r3 || r3.autoDestroy && r3.endEmitted) && e2.destroy();
                }
                return n4;
              }
              function T(e2, t4, r3) {
                t4.ending = true, S2(e2, t4), r3 && (t4.finished ? n3.nextTick(r3) : e2.once("finish", r3)), t4.ended = true, e2.writable = false;
              }
              function v(e2, t4, n4) {
                var r3 = e2.entry;
                for (e2.entry = null; r3; ) {
                  var a3 = r3.callback;
                  t4.pendingcb--, a3(n4), r3 = r3.next;
                }
                t4.corkedRequestsFree.next = e2;
              }
              t3.exports = l;
              var k;
              l.WritableState = s;
              var L = { deprecate: e("util-deprecate") }, A = e("./internal/streams/stream"), x3 = e("buffer").Buffer, N = r2.Uint8Array || function() {
              }, D = e("./internal/streams/destroy"), I = e("./internal/streams/state"), P = I.getHighWaterMark, M = e("../errors").codes, O = M.ERR_INVALID_ARG_TYPE, F = M.ERR_METHOD_NOT_IMPLEMENTED, B = M.ERR_MULTIPLE_CALLBACK, U = M.ERR_STREAM_CANNOT_PIPE, j = M.ERR_STREAM_DESTROYED, q = M.ERR_STREAM_NULL_VALUES, W = M.ERR_STREAM_WRITE_AFTER_END, H = M.ERR_UNKNOWN_ENCODING, Y = D.errorOrDestroy;
              e("inherits")(l, A), s.prototype.getBuffer = function() {
                for (var e2 = this.bufferedRequest, t4 = []; e2; )
                  t4.push(e2), e2 = e2.next;
                return t4;
              }, function() {
                try {
                  Object.defineProperty(s.prototype, "buffer", { get: L.deprecate(function() {
                    return this.getBuffer();
                  }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
                } catch (e2) {
                }
              }();
              var V;
              "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (V = Function.prototype[Symbol.hasInstance], Object.defineProperty(l, Symbol.hasInstance, { value: function(e2) {
                return !!V.call(this, e2) || !(this !== l) && e2 && e2._writableState instanceof s;
              } })) : V = function(e2) {
                return e2 instanceof this;
              }, l.prototype.pipe = function() {
                Y(this, new U());
              }, l.prototype.write = function(e2, t4, n4) {
                var r3 = this._writableState, a3 = false, s2 = !r3.objectMode && i(e2);
                return s2 && !x3.isBuffer(e2) && (e2 = o(e2)), "function" == typeof t4 && (n4 = t4, t4 = null), s2 ? t4 = "buffer" : !t4 && (t4 = r3.defaultEncoding), "function" != typeof n4 && (n4 = d), r3.ending ? c2(this, n4) : (s2 || u(this, r3, e2, n4)) && (r3.pendingcb++, a3 = f(this, r3, s2, e2, t4, n4)), a3;
              }, l.prototype.cork = function() {
                this._writableState.corked++;
              }, l.prototype.uncork = function() {
                var e2 = this._writableState;
                e2.corked && (e2.corked--, !e2.writing && !e2.corked && !e2.bufferProcessing && e2.bufferedRequest && C2(this, e2));
              }, l.prototype.setDefaultEncoding = function(e2) {
                if ("string" == typeof e2 && (e2 = e2.toLowerCase()), !(-1 < ["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e2 + "").toLowerCase())))
                  throw new H(e2);
                return this._writableState.defaultEncoding = e2, this;
              }, Object.defineProperty(l.prototype, "writableBuffer", { enumerable: false, get: function() {
                return this._writableState && this._writableState.getBuffer();
              } }), Object.defineProperty(l.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
                return this._writableState.highWaterMark;
              } }), l.prototype._write = function(e2, t4, n4) {
                n4(new F("_write()"));
              }, l.prototype._writev = null, l.prototype.end = function(e2, t4, n4) {
                var r3 = this._writableState;
                return "function" == typeof e2 ? (n4 = e2, e2 = null, t4 = null) : "function" == typeof t4 && (n4 = t4, t4 = null), null !== e2 && void 0 !== e2 && this.write(e2, t4), r3.corked && (r3.corked = 1, this.uncork()), r3.ending || T(this, r3, n4), this;
              }, Object.defineProperty(l.prototype, "writableLength", { enumerable: false, get: function() {
                return this._writableState.length;
              } }), Object.defineProperty(l.prototype, "destroyed", { enumerable: false, get: function() {
                return void 0 !== this._writableState && this._writableState.destroyed;
              }, set: function(e2) {
                this._writableState && (this._writableState.destroyed = e2);
              } }), l.prototype.destroy = D.destroy, l.prototype._undestroy = D.undestroy, l.prototype._destroy = function(e2, t4) {
                t4(e2);
              };
            }).call(this);
          }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
        }, { "../errors": 15, "./_stream_duplex": 16, "./internal/streams/destroy": 23, "./internal/streams/state": 27, "./internal/streams/stream": 28, _process: 12, buffer: 3, inherits: 10, "util-deprecate": 32 }], 21: [function(e, t3) {
          (function(n3) {
            (function() {
              "use strict";
              function r2(e2, t4, n4) {
                return t4 in e2 ? Object.defineProperty(e2, t4, { value: n4, enumerable: true, configurable: true, writable: true }) : e2[t4] = n4, e2;
              }
              function a2(e2, t4) {
                return { value: e2, done: t4 };
              }
              function o(e2) {
                var t4 = e2[c2];
                if (null !== t4) {
                  var n4 = e2[h2].read();
                  null !== n4 && (e2[g] = null, e2[c2] = null, e2[u] = null, t4(a2(n4, false)));
                }
              }
              function i(e2) {
                n3.nextTick(o, e2);
              }
              function d(e2, t4) {
                return function(n4, r3) {
                  e2.then(function() {
                    return t4[f] ? void n4(a2(void 0, true)) : void t4[_](n4, r3);
                  }, r3);
                };
              }
              var s, l = e("./end-of-stream"), c2 = Symbol("lastResolve"), u = Symbol("lastReject"), p = Symbol("error"), f = Symbol("ended"), g = Symbol("lastPromise"), _ = Symbol("handlePromise"), h2 = Symbol("stream"), m2 = Object.getPrototypeOf(function() {
              }), b = Object.setPrototypeOf((s = { get stream() {
                return this[h2];
              }, next: function() {
                var e2 = this, t4 = this[p];
                if (null !== t4)
                  return Promise.reject(t4);
                if (this[f])
                  return Promise.resolve(a2(void 0, true));
                if (this[h2].destroyed)
                  return new Promise(function(t5, r4) {
                    n3.nextTick(function() {
                      e2[p] ? r4(e2[p]) : t5(a2(void 0, true));
                    });
                  });
                var r3, o2 = this[g];
                if (o2)
                  r3 = new Promise(d(o2, this));
                else {
                  var i2 = this[h2].read();
                  if (null !== i2)
                    return Promise.resolve(a2(i2, false));
                  r3 = new Promise(this[_]);
                }
                return this[g] = r3, r3;
              } }, r2(s, Symbol.asyncIterator, function() {
                return this;
              }), r2(s, "return", function() {
                var e2 = this;
                return new Promise(function(t4, n4) {
                  e2[h2].destroy(null, function(e3) {
                    return e3 ? void n4(e3) : void t4(a2(void 0, true));
                  });
                });
              }), s), m2);
              t3.exports = function(e2) {
                var t4, n4 = Object.create(b, (t4 = {}, r2(t4, h2, { value: e2, writable: true }), r2(t4, c2, { value: null, writable: true }), r2(t4, u, { value: null, writable: true }), r2(t4, p, { value: null, writable: true }), r2(t4, f, { value: e2._readableState.endEmitted, writable: true }), r2(t4, _, { value: function(e3, t5) {
                  var r3 = n4[h2].read();
                  r3 ? (n4[g] = null, n4[c2] = null, n4[u] = null, e3(a2(r3, false))) : (n4[c2] = e3, n4[u] = t5);
                }, writable: true }), t4));
                return n4[g] = null, l(e2, function(e3) {
                  if (e3 && "ERR_STREAM_PREMATURE_CLOSE" !== e3.code) {
                    var t5 = n4[u];
                    return null !== t5 && (n4[g] = null, n4[c2] = null, n4[u] = null, t5(e3)), void (n4[p] = e3);
                  }
                  var r3 = n4[c2];
                  null !== r3 && (n4[g] = null, n4[c2] = null, n4[u] = null, r3(a2(void 0, true))), n4[f] = true;
                }), e2.on("readable", i.bind(null, n4)), n4;
              };
            }).call(this);
          }).call(this, e("_process"));
        }, { "./end-of-stream": 24, _process: 12 }], 22: [function(e, t3) {
          "use strict";
          function n3(e2, t4) {
            var n4 = Object.keys(e2);
            if (Object.getOwnPropertySymbols) {
              var r3 = Object.getOwnPropertySymbols(e2);
              t4 && (r3 = r3.filter(function(t5) {
                return Object.getOwnPropertyDescriptor(e2, t5).enumerable;
              })), n4.push.apply(n4, r3);
            }
            return n4;
          }
          function r2(e2) {
            for (var t4, r3 = 1; r3 < arguments.length; r3++)
              t4 = null == arguments[r3] ? {} : arguments[r3], r3 % 2 ? n3(Object(t4), true).forEach(function(n4) {
                a2(e2, n4, t4[n4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t4)) : n3(Object(t4)).forEach(function(n4) {
                Object.defineProperty(e2, n4, Object.getOwnPropertyDescriptor(t4, n4));
              });
            return e2;
          }
          function a2(e2, t4, n4) {
            return t4 in e2 ? Object.defineProperty(e2, t4, { value: n4, enumerable: true, configurable: true, writable: true }) : e2[t4] = n4, e2;
          }
          function o(e2, t4) {
            if (!(e2 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }
          function i(e2, t4) {
            for (var n4, r3 = 0; r3 < t4.length; r3++)
              n4 = t4[r3], n4.enumerable = n4.enumerable || false, n4.configurable = true, "value" in n4 && (n4.writable = true), Object.defineProperty(e2, n4.key, n4);
          }
          function d(e2, t4, n4) {
            return t4 && i(e2.prototype, t4), n4 && i(e2, n4), e2;
          }
          function s(e2, t4, n4) {
            u.prototype.copy.call(e2, t4, n4);
          }
          var l = e("buffer"), u = l.Buffer, p = e("util"), f = p.inspect, g = f && f.custom || "inspect";
          t3.exports = function() {
            function e2() {
              o(this, e2), this.head = null, this.tail = null, this.length = 0;
            }
            return d(e2, [{ key: "push", value: function(e3) {
              var t4 = { data: e3, next: null };
              0 < this.length ? this.tail.next = t4 : this.head = t4, this.tail = t4, ++this.length;
            } }, { key: "unshift", value: function(e3) {
              var t4 = { data: e3, next: this.head };
              0 === this.length && (this.tail = t4), this.head = t4, ++this.length;
            } }, { key: "shift", value: function() {
              if (0 !== this.length) {
                var e3 = this.head.data;
                return this.head = 1 === this.length ? this.tail = null : this.head.next, --this.length, e3;
              }
            } }, { key: "clear", value: function() {
              this.head = this.tail = null, this.length = 0;
            } }, { key: "join", value: function(e3) {
              if (0 === this.length)
                return "";
              for (var t4 = this.head, n4 = "" + t4.data; t4 = t4.next; )
                n4 += e3 + t4.data;
              return n4;
            } }, { key: "concat", value: function(e3) {
              if (0 === this.length)
                return u.alloc(0);
              for (var t4 = u.allocUnsafe(e3 >>> 0), n4 = this.head, r3 = 0; n4; )
                s(n4.data, t4, r3), r3 += n4.data.length, n4 = n4.next;
              return t4;
            } }, { key: "consume", value: function(e3, t4) {
              var n4;
              return e3 < this.head.data.length ? (n4 = this.head.data.slice(0, e3), this.head.data = this.head.data.slice(e3)) : e3 === this.head.data.length ? n4 = this.shift() : n4 = t4 ? this._getString(e3) : this._getBuffer(e3), n4;
            } }, { key: "first", value: function() {
              return this.head.data;
            } }, { key: "_getString", value: function(e3) {
              var t4 = this.head, r3 = 1, a3 = t4.data;
              for (e3 -= a3.length; t4 = t4.next; ) {
                var o2 = t4.data, i2 = e3 > o2.length ? o2.length : e3;
                if (a3 += i2 === o2.length ? o2 : o2.slice(0, e3), e3 -= i2, 0 === e3) {
                  i2 === o2.length ? (++r3, this.head = t4.next ? t4.next : this.tail = null) : (this.head = t4, t4.data = o2.slice(i2));
                  break;
                }
                ++r3;
              }
              return this.length -= r3, a3;
            } }, { key: "_getBuffer", value: function(e3) {
              var t4 = u.allocUnsafe(e3), r3 = this.head, a3 = 1;
              for (r3.data.copy(t4), e3 -= r3.data.length; r3 = r3.next; ) {
                var o2 = r3.data, i2 = e3 > o2.length ? o2.length : e3;
                if (o2.copy(t4, t4.length - e3, 0, i2), e3 -= i2, 0 === e3) {
                  i2 === o2.length ? (++a3, this.head = r3.next ? r3.next : this.tail = null) : (this.head = r3, r3.data = o2.slice(i2));
                  break;
                }
                ++a3;
              }
              return this.length -= a3, t4;
            } }, { key: g, value: function(e3, t4) {
              return f(this, r2({}, t4, { depth: 0, customInspect: false }));
            } }]), e2;
          }();
        }, { buffer: 3, util: 2 }], 23: [function(e, t3) {
          (function(e2) {
            (function() {
              "use strict";
              function n3(e3, t4) {
                a2(e3, t4), r2(e3);
              }
              function r2(e3) {
                e3._writableState && !e3._writableState.emitClose || e3._readableState && !e3._readableState.emitClose || e3.emit("close");
              }
              function a2(e3, t4) {
                e3.emit("error", t4);
              }
              t3.exports = { destroy: function(t4, o) {
                var i = this, d = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
                return d || s ? (o ? o(t4) : t4 && (this._writableState ? !this._writableState.errorEmitted && (this._writableState.errorEmitted = true, e2.nextTick(a2, this, t4)) : e2.nextTick(a2, this, t4)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t4 || null, function(t5) {
                  !o && t5 ? i._writableState ? i._writableState.errorEmitted ? e2.nextTick(r2, i) : (i._writableState.errorEmitted = true, e2.nextTick(n3, i, t5)) : e2.nextTick(n3, i, t5) : o ? (e2.nextTick(r2, i), o(t5)) : e2.nextTick(r2, i);
                }), this);
              }, undestroy: function() {
                this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
              }, errorOrDestroy: function(e3, t4) {
                var n4 = e3._readableState, r3 = e3._writableState;
                n4 && n4.autoDestroy || r3 && r3.autoDestroy ? e3.destroy(t4) : e3.emit("error", t4);
              } };
            }).call(this);
          }).call(this, e("_process"));
        }, { _process: 12 }], 24: [function(e, t3) {
          "use strict";
          function n3(e2) {
            var t4 = false;
            return function() {
              if (!t4) {
                t4 = true;
                for (var n4 = arguments.length, r3 = Array(n4), a3 = 0; a3 < n4; a3++)
                  r3[a3] = arguments[a3];
                e2.apply(this, r3);
              }
            };
          }
          function r2() {
          }
          function a2(e2) {
            return e2.setHeader && "function" == typeof e2.abort;
          }
          function o(e2, t4, d) {
            if ("function" == typeof t4)
              return o(e2, null, t4);
            t4 || (t4 = {}), d = n3(d || r2);
            var s = t4.readable || false !== t4.readable && e2.readable, l = t4.writable || false !== t4.writable && e2.writable, c2 = function() {
              e2.writable || p();
            }, u = e2._writableState && e2._writableState.finished, p = function() {
              l = false, u = true, s || d.call(e2);
            }, f = e2._readableState && e2._readableState.endEmitted, g = function() {
              s = false, f = true, l || d.call(e2);
            }, _ = function(t5) {
              d.call(e2, t5);
            }, h2 = function() {
              var t5;
              return s && !f ? (e2._readableState && e2._readableState.ended || (t5 = new i()), d.call(e2, t5)) : l && !u ? (e2._writableState && e2._writableState.ended || (t5 = new i()), d.call(e2, t5)) : void 0;
            }, m2 = function() {
              e2.req.on("finish", p);
            };
            return a2(e2) ? (e2.on("complete", p), e2.on("abort", h2), e2.req ? m2() : e2.on("request", m2)) : l && !e2._writableState && (e2.on("end", c2), e2.on("close", c2)), e2.on("end", g), e2.on("finish", p), false !== t4.error && e2.on("error", _), e2.on("close", h2), function() {
              e2.removeListener("complete", p), e2.removeListener("abort", h2), e2.removeListener("request", m2), e2.req && e2.req.removeListener("finish", p), e2.removeListener("end", c2), e2.removeListener("close", c2), e2.removeListener("finish", p), e2.removeListener("end", g), e2.removeListener("error", _), e2.removeListener("close", h2);
            };
          }
          var i = e("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
          t3.exports = o;
        }, { "../../../errors": 15 }], 25: [function(e, t3) {
          t3.exports = function() {
            throw new Error("Readable.from is not available in the browser");
          };
        }, {}], 26: [function(e, t3) {
          "use strict";
          function n3(e2) {
            var t4 = false;
            return function() {
              t4 || (t4 = true, e2.apply(void 0, arguments));
            };
          }
          function r2(e2) {
            if (e2)
              throw e2;
          }
          function a2(e2) {
            return e2.setHeader && "function" == typeof e2.abort;
          }
          function o(t4, r3, o2, i2) {
            i2 = n3(i2);
            var d2 = false;
            t4.on("close", function() {
              d2 = true;
            }), l === void 0 && (l = e("./end-of-stream")), l(t4, { readable: r3, writable: o2 }, function(e2) {
              return e2 ? i2(e2) : void (d2 = true, i2());
            });
            var s2 = false;
            return function(e2) {
              if (!d2)
                return s2 ? void 0 : (s2 = true, a2(t4) ? t4.abort() : "function" == typeof t4.destroy ? t4.destroy() : void i2(e2 || new p("pipe")));
            };
          }
          function i(e2) {
            e2();
          }
          function d(e2, t4) {
            return e2.pipe(t4);
          }
          function s(e2) {
            return e2.length ? "function" == typeof e2[e2.length - 1] ? e2.pop() : r2 : r2;
          }
          var l, c2 = e("../../../errors").codes, u = c2.ERR_MISSING_ARGS, p = c2.ERR_STREAM_DESTROYED;
          t3.exports = function() {
            for (var e2 = arguments.length, t4 = Array(e2), n4 = 0; n4 < e2; n4++)
              t4[n4] = arguments[n4];
            var r3 = s(t4);
            if (Array.isArray(t4[0]) && (t4 = t4[0]), 2 > t4.length)
              throw new u("streams");
            var a3, l2 = t4.map(function(e3, n5) {
              var d2 = n5 < t4.length - 1;
              return o(e3, d2, 0 < n5, function(e4) {
                a3 || (a3 = e4), e4 && l2.forEach(i), d2 || (l2.forEach(i), r3(a3));
              });
            });
            return t4.reduce(d);
          };
        }, { "../../../errors": 15, "./end-of-stream": 24 }], 27: [function(e, n3) {
          "use strict";
          function r2(e2, t3, n4) {
            return null == e2.highWaterMark ? t3 ? e2[n4] : null : e2.highWaterMark;
          }
          var a2 = e("../../../errors").codes.ERR_INVALID_OPT_VALUE;
          n3.exports = { getHighWaterMark: function(e2, n4, o, i) {
            var d = r2(n4, i, o);
            if (null != d) {
              if (!(isFinite(d) && t2(d) === d) || 0 > d) {
                var s = i ? o : "highWaterMark";
                throw new a2(s, d);
              }
              return t2(d);
            }
            return e2.objectMode ? 16 : 16384;
          } };
        }, { "../../../errors": 15 }], 28: [function(e, t3) {
          t3.exports = e("events").EventEmitter;
        }, { events: 7 }], 29: [function(e, t3, n3) {
          n3 = t3.exports = e("./lib/_stream_readable.js"), n3.Stream = n3, n3.Readable = n3, n3.Writable = e("./lib/_stream_writable.js"), n3.Duplex = e("./lib/_stream_duplex.js"), n3.Transform = e("./lib/_stream_transform.js"), n3.PassThrough = e("./lib/_stream_passthrough.js"), n3.finished = e("./lib/internal/streams/end-of-stream.js"), n3.pipeline = e("./lib/internal/streams/pipeline.js");
        }, { "./lib/_stream_duplex.js": 16, "./lib/_stream_passthrough.js": 17, "./lib/_stream_readable.js": 18, "./lib/_stream_transform.js": 19, "./lib/_stream_writable.js": 20, "./lib/internal/streams/end-of-stream.js": 24, "./lib/internal/streams/pipeline.js": 26 }], 30: [function(e, t3, n3) {
          function r2(e2, t4) {
            for (var n4 in e2)
              t4[n4] = e2[n4];
          }
          function a2(e2, t4, n4) {
            return i(e2, t4, n4);
          }
          var o = e("buffer"), i = o.Buffer;
          i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t3.exports = o : (r2(o, n3), n3.Buffer = a2), a2.prototype = Object.create(i.prototype), r2(i, a2), a2.from = function(e2, t4, n4) {
            if ("number" == typeof e2)
              throw new TypeError("Argument must not be a number");
            return i(e2, t4, n4);
          }, a2.alloc = function(e2, t4, n4) {
            if ("number" != typeof e2)
              throw new TypeError("Argument must be a number");
            var r3 = i(e2);
            return void 0 === t4 ? r3.fill(0) : "string" == typeof n4 ? r3.fill(t4, n4) : r3.fill(t4), r3;
          }, a2.allocUnsafe = function(e2) {
            if ("number" != typeof e2)
              throw new TypeError("Argument must be a number");
            return i(e2);
          }, a2.allocUnsafeSlow = function(e2) {
            if ("number" != typeof e2)
              throw new TypeError("Argument must be a number");
            return o.SlowBuffer(e2);
          };
        }, { buffer: 3 }], 31: [function(e, t3, n3) {
          "use strict";
          function r2(e2) {
            if (!e2)
              return "utf8";
            for (var t4; ; )
              switch (e2) {
                case "utf8":
                case "utf-8":
                  return "utf8";
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return "utf16le";
                case "latin1":
                case "binary":
                  return "latin1";
                case "base64":
                case "ascii":
                case "hex":
                  return e2;
                default:
                  if (t4)
                    return;
                  e2 = ("" + e2).toLowerCase(), t4 = true;
              }
          }
          function a2(e2) {
            var t4 = r2(e2);
            if ("string" != typeof t4 && (m2.isEncoding === b || !b(e2)))
              throw new Error("Unknown encoding: " + e2);
            return t4 || e2;
          }
          function o(e2) {
            this.encoding = a2(e2);
            var t4;
            switch (this.encoding) {
              case "utf16le":
                this.text = u, this.end = p, t4 = 4;
                break;
              case "utf8":
                this.fillLast = c2, t4 = 4;
                break;
              case "base64":
                this.text = f, this.end = g, t4 = 3;
                break;
              default:
                return this.write = _, void (this.end = h2);
            }
            this.lastNeed = 0, this.lastTotal = 0, this.lastChar = m2.allocUnsafe(t4);
          }
          function d(e2) {
            if (127 >= e2)
              return 0;
            return 6 == e2 >> 5 ? 2 : 14 == e2 >> 4 ? 3 : 30 == e2 >> 3 ? 4 : 2 == e2 >> 6 ? -1 : -2;
          }
          function s(e2, t4, n4) {
            var r3 = t4.length - 1;
            if (r3 < n4)
              return 0;
            var a3 = d(t4[r3]);
            return 0 <= a3 ? (0 < a3 && (e2.lastNeed = a3 - 1), a3) : --r3 < n4 || -2 === a3 ? 0 : (a3 = d(t4[r3]), 0 <= a3) ? (0 < a3 && (e2.lastNeed = a3 - 2), a3) : --r3 < n4 || -2 === a3 ? 0 : (a3 = d(t4[r3]), 0 <= a3 ? (0 < a3 && (2 === a3 ? a3 = 0 : e2.lastNeed = a3 - 3), a3) : 0);
          }
          function l(e2, t4) {
            if (128 != (192 & t4[0]))
              return e2.lastNeed = 0, "\uFFFD";
            if (1 < e2.lastNeed && 1 < t4.length) {
              if (128 != (192 & t4[1]))
                return e2.lastNeed = 1, "\uFFFD";
              if (2 < e2.lastNeed && 2 < t4.length && 128 != (192 & t4[2]))
                return e2.lastNeed = 2, "\uFFFD";
            }
          }
          function c2(e2) {
            var t4 = this.lastTotal - this.lastNeed, n4 = l(this, e2, t4);
            return void 0 === n4 ? this.lastNeed <= e2.length ? (e2.copy(this.lastChar, t4, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void (e2.copy(this.lastChar, t4, 0, e2.length), this.lastNeed -= e2.length) : n4;
          }
          function u(e2, t4) {
            if (0 == (e2.length - t4) % 2) {
              var n4 = e2.toString("utf16le", t4);
              if (n4) {
                var r3 = n4.charCodeAt(n4.length - 1);
                if (55296 <= r3 && 56319 >= r3)
                  return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e2[e2.length - 2], this.lastChar[1] = e2[e2.length - 1], n4.slice(0, -1);
              }
              return n4;
            }
            return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e2[e2.length - 1], e2.toString("utf16le", t4, e2.length - 1);
          }
          function p(e2) {
            var t4 = e2 && e2.length ? this.write(e2) : "";
            if (this.lastNeed) {
              var n4 = this.lastTotal - this.lastNeed;
              return t4 + this.lastChar.toString("utf16le", 0, n4);
            }
            return t4;
          }
          function f(e2, t4) {
            var r3 = (e2.length - t4) % 3;
            return 0 == r3 ? e2.toString("base64", t4) : (this.lastNeed = 3 - r3, this.lastTotal = 3, 1 == r3 ? this.lastChar[0] = e2[e2.length - 1] : (this.lastChar[0] = e2[e2.length - 2], this.lastChar[1] = e2[e2.length - 1]), e2.toString("base64", t4, e2.length - r3));
          }
          function g(e2) {
            var t4 = e2 && e2.length ? this.write(e2) : "";
            return this.lastNeed ? t4 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t4;
          }
          function _(e2) {
            return e2.toString(this.encoding);
          }
          function h2(e2) {
            return e2 && e2.length ? this.write(e2) : "";
          }
          var m2 = e("safe-buffer").Buffer, b = m2.isEncoding || function(e2) {
            switch (e2 = "" + e2, e2 && e2.toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
              case "raw":
                return true;
              default:
                return false;
            }
          };
          n3.StringDecoder = o, o.prototype.write = function(e2) {
            if (0 === e2.length)
              return "";
            var t4, n4;
            if (this.lastNeed) {
              if (t4 = this.fillLast(e2), void 0 === t4)
                return "";
              n4 = this.lastNeed, this.lastNeed = 0;
            } else
              n4 = 0;
            return n4 < e2.length ? t4 ? t4 + this.text(e2, n4) : this.text(e2, n4) : t4 || "";
          }, o.prototype.end = function(e2) {
            var t4 = e2 && e2.length ? this.write(e2) : "";
            return this.lastNeed ? t4 + "\uFFFD" : t4;
          }, o.prototype.text = function(e2, t4) {
            var n4 = s(this, e2, t4);
            if (!this.lastNeed)
              return e2.toString("utf8", t4);
            this.lastTotal = n4;
            var r3 = e2.length - (n4 - this.lastNeed);
            return e2.copy(this.lastChar, 0, r3), e2.toString("utf8", t4, r3);
          }, o.prototype.fillLast = function(e2) {
            return this.lastNeed <= e2.length ? (e2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void (e2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e2.length), this.lastNeed -= e2.length);
          };
        }, { "safe-buffer": 30 }], 32: [function(e, t3) {
          (function(e2) {
            (function() {
              function n3(t4) {
                try {
                  if (!e2.localStorage)
                    return false;
                } catch (e3) {
                  return false;
                }
                var n4 = e2.localStorage[t4];
                return null != n4 && "true" === (n4 + "").toLowerCase();
              }
              t3.exports = function(e3, t4) {
                function r2() {
                  if (!a2) {
                    if (n3("throwDeprecation"))
                      throw new Error(t4);
                    else
                      n3("traceDeprecation") ? console.trace(t4) : console.warn(t4);
                    a2 = true;
                  }
                  return e3.apply(this, arguments);
                }
                if (n3("noDeprecation"))
                  return e3;
                var a2 = false;
                return r2;
              };
            }).call(this);
          }).call(this, "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
        }, {}], "/": [function(e, t3) {
          function n3(e2) {
            return e2.replace(/a=ice-options:trickle\s\n/g, "");
          }
          function r2(e2) {
            console.warn(e2);
          }
          const a2 = e("debug")("simple-peer"), o = e("get-browser-rtc"), i = e("randombytes"), d = e("readable-stream"), s = e("queue-microtask"), l = e("err-code"), { Buffer: c2 } = e("buffer"), u = 65536;
          class p extends d.Duplex {
            constructor(e2) {
              if (e2 = Object.assign({ allowHalfOpen: false }, e2), super(e2), this._id = i(4).toString("hex").slice(0, 7), this._debug("new peer %o", e2), this.channelName = e2.initiator ? e2.channelName || i(20).toString("hex") : null, this.initiator = e2.initiator || false, this.channelConfig = e2.channelConfig || p.channelConfig, this.channelNegotiated = this.channelConfig.negotiated, this.config = Object.assign({}, p.config, e2.config), this.offerOptions = e2.offerOptions || {}, this.answerOptions = e2.answerOptions || {}, this.sdpTransform = e2.sdpTransform || ((e3) => e3), this.streams = e2.streams || (e2.stream ? [e2.stream] : []), this.trickle = void 0 === e2.trickle || e2.trickle, this.allowHalfTrickle = void 0 !== e2.allowHalfTrickle && e2.allowHalfTrickle, this.iceCompleteTimeout = e2.iceCompleteTimeout || 5e3, this.destroyed = false, this.destroying = false, this._connected = false, this.remoteAddress = void 0, this.remoteFamily = void 0, this.remotePort = void 0, this.localAddress = void 0, this.localFamily = void 0, this.localPort = void 0, this._wrtc = e2.wrtc && "object" == typeof e2.wrtc ? e2.wrtc : o(), !this._wrtc)
                if ("undefined" == typeof window)
                  throw l(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
                else
                  throw l(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
              this._pcReady = false, this._channelReady = false, this._iceComplete = false, this._iceCompleteTimer = null, this._channel = null, this._pendingCandidates = [], this._isNegotiating = false, this._firstNegotiation = true, this._batchedNegotiation = false, this._queuedNegotiation = false, this._sendersAwaitingStable = [], this._senderMap = /* @__PURE__ */ new Map(), this._closingInterval = null, this._remoteTracks = [], this._remoteStreams = [], this._chunk = null, this._cb = null, this._interval = null;
              try {
                this._pc = new this._wrtc.RTCPeerConnection(this.config);
              } catch (e3) {
                return void this.destroy(l(e3, "ERR_PC_CONSTRUCTOR"));
              }
              this._isReactNativeWebrtc = "number" == typeof this._pc._peerConnectionId, this._pc.oniceconnectionstatechange = () => {
                this._onIceStateChange();
              }, this._pc.onicegatheringstatechange = () => {
                this._onIceStateChange();
              }, this._pc.onconnectionstatechange = () => {
                this._onConnectionStateChange();
              }, this._pc.onsignalingstatechange = () => {
                this._onSignalingStateChange();
              }, this._pc.onicecandidate = (e3) => {
                this._onIceCandidate(e3);
              }, "object" == typeof this._pc.peerIdentity && this._pc.peerIdentity.catch((e3) => {
                this.destroy(l(e3, "ERR_PC_PEER_IDENTITY"));
              }), this.initiator || this.channelNegotiated ? this._setupData({ channel: this._pc.createDataChannel(this.channelName, this.channelConfig) }) : this._pc.ondatachannel = (e3) => {
                this._setupData(e3);
              }, this.streams && this.streams.forEach((e3) => {
                this.addStream(e3);
              }), this._pc.ontrack = (e3) => {
                this._onTrack(e3);
              }, this._debug("initial negotiation"), this._needsNegotiation(), this._onFinishBound = () => {
                this._onFinish();
              }, this.once("finish", this._onFinishBound);
            }
            get bufferSize() {
              return this._channel && this._channel.bufferedAmount || 0;
            }
            get connected() {
              return this._connected && "open" === this._channel.readyState;
            }
            address() {
              return { port: this.localPort, family: this.localFamily, address: this.localAddress };
            }
            signal(e2) {
              if (!this.destroying) {
                if (this.destroyed)
                  throw l(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
                if ("string" == typeof e2)
                  try {
                    e2 = JSON.parse(e2);
                  } catch (t4) {
                    e2 = {};
                  }
                this._debug("signal()"), e2.renegotiate && this.initiator && (this._debug("got request to renegotiate"), this._needsNegotiation()), e2.transceiverRequest && this.initiator && (this._debug("got request for transceiver"), this.addTransceiver(e2.transceiverRequest.kind, e2.transceiverRequest.init)), e2.candidate && (this._pc.remoteDescription && this._pc.remoteDescription.type ? this._addIceCandidate(e2.candidate) : this._pendingCandidates.push(e2.candidate)), e2.sdp && this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(e2)).then(() => {
                  this.destroyed || (this._pendingCandidates.forEach((e3) => {
                    this._addIceCandidate(e3);
                  }), this._pendingCandidates = [], "offer" === this._pc.remoteDescription.type && this._createAnswer());
                }).catch((e3) => {
                  this.destroy(l(e3, "ERR_SET_REMOTE_DESCRIPTION"));
                }), e2.sdp || e2.candidate || e2.renegotiate || e2.transceiverRequest || this.destroy(l(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
              }
            }
            _addIceCandidate(e2) {
              const t4 = new this._wrtc.RTCIceCandidate(e2);
              this._pc.addIceCandidate(t4).catch((e3) => {
                !t4.address || t4.address.endsWith(".local") ? r2("Ignoring unsupported ICE candidate.") : this.destroy(l(e3, "ERR_ADD_ICE_CANDIDATE"));
              });
            }
            send(e2) {
              if (!this.destroying) {
                if (this.destroyed)
                  throw l(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
                this._channel.send(e2);
              }
            }
            addTransceiver(e2, t4) {
              if (!this.destroying) {
                if (this.destroyed)
                  throw l(new Error("cannot addTransceiver after peer is destroyed"), "ERR_DESTROYED");
                if (this._debug("addTransceiver()"), this.initiator)
                  try {
                    this._pc.addTransceiver(e2, t4), this._needsNegotiation();
                  } catch (e3) {
                    this.destroy(l(e3, "ERR_ADD_TRANSCEIVER"));
                  }
                else
                  this.emit("signal", { type: "transceiverRequest", transceiverRequest: { kind: e2, init: t4 } });
              }
            }
            addStream(e2) {
              if (!this.destroying) {
                if (this.destroyed)
                  throw l(new Error("cannot addStream after peer is destroyed"), "ERR_DESTROYED");
                this._debug("addStream()"), e2.getTracks().forEach((t4) => {
                  this.addTrack(t4, e2);
                });
              }
            }
            addTrack(e2, t4) {
              if (this.destroying)
                return;
              if (this.destroyed)
                throw l(new Error("cannot addTrack after peer is destroyed"), "ERR_DESTROYED");
              this._debug("addTrack()");
              const n4 = this._senderMap.get(e2) || /* @__PURE__ */ new Map();
              let r3 = n4.get(t4);
              if (!r3)
                r3 = this._pc.addTrack(e2, t4), n4.set(t4, r3), this._senderMap.set(e2, n4), this._needsNegotiation();
              else if (r3.removed)
                throw l(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED");
              else
                throw l(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
            }
            replaceTrack(e2, t4, n4) {
              if (this.destroying)
                return;
              if (this.destroyed)
                throw l(new Error("cannot replaceTrack after peer is destroyed"), "ERR_DESTROYED");
              this._debug("replaceTrack()");
              const r3 = this._senderMap.get(e2), a3 = r3 ? r3.get(n4) : null;
              if (!a3)
                throw l(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
              t4 && this._senderMap.set(t4, r3), null == a3.replaceTrack ? this.destroy(l(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK")) : a3.replaceTrack(t4);
            }
            removeTrack(e2, t4) {
              if (this.destroying)
                return;
              if (this.destroyed)
                throw l(new Error("cannot removeTrack after peer is destroyed"), "ERR_DESTROYED");
              this._debug("removeSender()");
              const n4 = this._senderMap.get(e2), r3 = n4 ? n4.get(t4) : null;
              if (!r3)
                throw l(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
              try {
                r3.removed = true, this._pc.removeTrack(r3);
              } catch (e3) {
                "NS_ERROR_UNEXPECTED" === e3.name ? this._sendersAwaitingStable.push(r3) : this.destroy(l(e3, "ERR_REMOVE_TRACK"));
              }
              this._needsNegotiation();
            }
            removeStream(e2) {
              if (!this.destroying) {
                if (this.destroyed)
                  throw l(new Error("cannot removeStream after peer is destroyed"), "ERR_DESTROYED");
                this._debug("removeSenders()"), e2.getTracks().forEach((t4) => {
                  this.removeTrack(t4, e2);
                });
              }
            }
            _needsNegotiation() {
              this._debug("_needsNegotiation"), this._batchedNegotiation || (this._batchedNegotiation = true, s(() => {
                this._batchedNegotiation = false, this.initiator || !this._firstNegotiation ? (this._debug("starting batched negotiation"), this.negotiate()) : this._debug("non-initiator initial negotiation request discarded"), this._firstNegotiation = false;
              }));
            }
            negotiate() {
              if (!this.destroying) {
                if (this.destroyed)
                  throw l(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
                this.initiator ? this._isNegotiating ? (this._queuedNegotiation = true, this._debug("already negotiating, queueing")) : (this._debug("start negotiation"), setTimeout(() => {
                  this._createOffer();
                }, 0)) : this._isNegotiating ? (this._queuedNegotiation = true, this._debug("already negotiating, queueing")) : (this._debug("requesting negotiation from initiator"), this.emit("signal", { type: "renegotiate", renegotiate: true })), this._isNegotiating = true;
              }
            }
            destroy(e2) {
              this._destroy(e2, () => {
              });
            }
            _destroy(e2, t4) {
              this.destroyed || this.destroying || (this.destroying = true, this._debug("destroying (error: %s)", e2 && (e2.message || e2)), s(() => {
                if (this.destroyed = true, this.destroying = false, this._debug("destroy (error: %s)", e2 && (e2.message || e2)), this.readable = this.writable = false, this._readableState.ended || this.push(null), this._writableState.finished || this.end(), this._connected = false, this._pcReady = false, this._channelReady = false, this._remoteTracks = null, this._remoteStreams = null, this._senderMap = null, clearInterval(this._closingInterval), this._closingInterval = null, clearInterval(this._interval), this._interval = null, this._chunk = null, this._cb = null, this._onFinishBound && this.removeListener("finish", this._onFinishBound), this._onFinishBound = null, this._channel) {
                  try {
                    this._channel.close();
                  } catch (e3) {
                  }
                  this._channel.onmessage = null, this._channel.onopen = null, this._channel.onclose = null, this._channel.onerror = null;
                }
                if (this._pc) {
                  try {
                    this._pc.close();
                  } catch (e3) {
                  }
                  this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ontrack = null, this._pc.ondatachannel = null;
                }
                this._pc = null, this._channel = null, e2 && this.emit("error", e2), this.emit("close"), t4();
              }));
            }
            _setupData(e2) {
              if (!e2.channel)
                return this.destroy(l(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
              this._channel = e2.channel, this._channel.binaryType = "arraybuffer", "number" == typeof this._channel.bufferedAmountLowThreshold && (this._channel.bufferedAmountLowThreshold = u), this.channelName = this._channel.label, this._channel.onmessage = (e3) => {
                this._onChannelMessage(e3);
              }, this._channel.onbufferedamountlow = () => {
                this._onChannelBufferedAmountLow();
              }, this._channel.onopen = () => {
                this._onChannelOpen();
              }, this._channel.onclose = () => {
                this._onChannelClose();
              }, this._channel.onerror = (e3) => {
                const t5 = e3.error instanceof Error ? e3.error : new Error(`Datachannel error: ${e3.message} ${e3.filename}:${e3.lineno}:${e3.colno}`);
                this.destroy(l(t5, "ERR_DATA_CHANNEL"));
              };
              let t4 = false;
              this._closingInterval = setInterval(() => {
                this._channel && "closing" === this._channel.readyState ? (t4 && this._onChannelClose(), t4 = true) : t4 = false;
              }, 5e3);
            }
            _read() {
            }
            _write(e2, t4, n4) {
              if (this.destroyed)
                return n4(l(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
              if (this._connected) {
                try {
                  this.send(e2);
                } catch (e3) {
                  return this.destroy(l(e3, "ERR_DATA_CHANNEL"));
                }
                this._channel.bufferedAmount > u ? (this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount), this._cb = n4) : n4(null);
              } else
                this._debug("write before connect"), this._chunk = e2, this._cb = n4;
            }
            _onFinish() {
              if (!this.destroyed) {
                const e2 = () => {
                  setTimeout(() => this.destroy(), 1e3);
                };
                this._connected ? e2() : this.once("connect", e2);
              }
            }
            _startIceCompleteTimeout() {
              this.destroyed || this._iceCompleteTimer || (this._debug("started iceComplete timeout"), this._iceCompleteTimer = setTimeout(() => {
                this._iceComplete || (this._iceComplete = true, this._debug("iceComplete timeout completed"), this.emit("iceTimeout"), this.emit("_iceComplete"));
              }, this.iceCompleteTimeout));
            }
            _createOffer() {
              this.destroyed || this._pc.createOffer(this.offerOptions).then((e2) => {
                if (this.destroyed)
                  return;
                this.trickle || this.allowHalfTrickle || (e2.sdp = n3(e2.sdp)), e2.sdp = this.sdpTransform(e2.sdp);
                const t4 = () => {
                  if (!this.destroyed) {
                    const t5 = this._pc.localDescription || e2;
                    this._debug("signal"), this.emit("signal", { type: t5.type, sdp: t5.sdp });
                  }
                };
                this._pc.setLocalDescription(e2).then(() => {
                  this._debug("createOffer success"), this.destroyed || (this.trickle || this._iceComplete ? t4() : this.once("_iceComplete", t4));
                }).catch((e3) => {
                  this.destroy(l(e3, "ERR_SET_LOCAL_DESCRIPTION"));
                });
              }).catch((e2) => {
                this.destroy(l(e2, "ERR_CREATE_OFFER"));
              });
            }
            _requestMissingTransceivers() {
              this._pc.getTransceivers && this._pc.getTransceivers().forEach((e2) => {
                e2.mid || !e2.sender.track || e2.requested || (e2.requested = true, this.addTransceiver(e2.sender.track.kind));
              });
            }
            _createAnswer() {
              this.destroyed || this._pc.createAnswer(this.answerOptions).then((e2) => {
                if (this.destroyed)
                  return;
                this.trickle || this.allowHalfTrickle || (e2.sdp = n3(e2.sdp)), e2.sdp = this.sdpTransform(e2.sdp);
                const t4 = () => {
                  if (!this.destroyed) {
                    const t5 = this._pc.localDescription || e2;
                    this._debug("signal"), this.emit("signal", { type: t5.type, sdp: t5.sdp }), this.initiator || this._requestMissingTransceivers();
                  }
                };
                this._pc.setLocalDescription(e2).then(() => {
                  this.destroyed || (this.trickle || this._iceComplete ? t4() : this.once("_iceComplete", t4));
                }).catch((e3) => {
                  this.destroy(l(e3, "ERR_SET_LOCAL_DESCRIPTION"));
                });
              }).catch((e2) => {
                this.destroy(l(e2, "ERR_CREATE_ANSWER"));
              });
            }
            _onConnectionStateChange() {
              this.destroyed || "failed" === this._pc.connectionState && this.destroy(l(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
            }
            _onIceStateChange() {
              if (this.destroyed)
                return;
              const e2 = this._pc.iceConnectionState, t4 = this._pc.iceGatheringState;
              this._debug("iceStateChange (connection: %s) (gathering: %s)", e2, t4), this.emit("iceStateChange", e2, t4), ("connected" === e2 || "completed" === e2) && (this._pcReady = true, this._maybeReady()), "failed" === e2 && this.destroy(l(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE")), "closed" === e2 && this.destroy(l(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
            }
            getStats(e2) {
              const t4 = (e3) => ("[object Array]" === Object.prototype.toString.call(e3.values) && e3.values.forEach((t5) => {
                Object.assign(e3, t5);
              }), e3);
              0 === this._pc.getStats.length || this._isReactNativeWebrtc ? this._pc.getStats().then((n4) => {
                const r3 = [];
                n4.forEach((e3) => {
                  r3.push(t4(e3));
                }), e2(null, r3);
              }, (t5) => e2(t5)) : 0 < this._pc.getStats.length ? this._pc.getStats((n4) => {
                if (this.destroyed)
                  return;
                const r3 = [];
                n4.result().forEach((e3) => {
                  const n5 = {};
                  e3.names().forEach((t5) => {
                    n5[t5] = e3.stat(t5);
                  }), n5.id = e3.id, n5.type = e3.type, n5.timestamp = e3.timestamp, r3.push(t4(n5));
                }), e2(null, r3);
              }, (t5) => e2(t5)) : e2(null, []);
            }
            _maybeReady() {
              if (this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady), this._connected || this._connecting || !this._pcReady || !this._channelReady)
                return;
              this._connecting = true;
              const e2 = () => {
                this.destroyed || this.getStats((t4, n4) => {
                  if (this.destroyed)
                    return;
                  t4 && (n4 = []);
                  const r3 = {}, a3 = {}, o2 = {};
                  let i2 = false;
                  n4.forEach((e3) => {
                    ("remotecandidate" === e3.type || "remote-candidate" === e3.type) && (r3[e3.id] = e3), ("localcandidate" === e3.type || "local-candidate" === e3.type) && (a3[e3.id] = e3), ("candidatepair" === e3.type || "candidate-pair" === e3.type) && (o2[e3.id] = e3);
                  });
                  const d2 = (e3) => {
                    i2 = true;
                    let t5 = a3[e3.localCandidateId];
                    t5 && (t5.ip || t5.address) ? (this.localAddress = t5.ip || t5.address, this.localPort = +t5.port) : t5 && t5.ipAddress ? (this.localAddress = t5.ipAddress, this.localPort = +t5.portNumber) : "string" == typeof e3.googLocalAddress && (t5 = e3.googLocalAddress.split(":"), this.localAddress = t5[0], this.localPort = +t5[1]), this.localAddress && (this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4");
                    let n5 = r3[e3.remoteCandidateId];
                    n5 && (n5.ip || n5.address) ? (this.remoteAddress = n5.ip || n5.address, this.remotePort = +n5.port) : n5 && n5.ipAddress ? (this.remoteAddress = n5.ipAddress, this.remotePort = +n5.portNumber) : "string" == typeof e3.googRemoteAddress && (n5 = e3.googRemoteAddress.split(":"), this.remoteAddress = n5[0], this.remotePort = +n5[1]), this.remoteAddress && (this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4"), this._debug("connect local: %s:%s remote: %s:%s", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);
                  };
                  if (n4.forEach((e3) => {
                    "transport" === e3.type && e3.selectedCandidatePairId && d2(o2[e3.selectedCandidatePairId]), ("googCandidatePair" === e3.type && "true" === e3.googActiveConnection || ("candidatepair" === e3.type || "candidate-pair" === e3.type) && e3.selected) && d2(e3);
                  }), !i2 && (!Object.keys(o2).length || Object.keys(a3).length))
                    return void setTimeout(e2, 100);
                  if (this._connecting = false, this._connected = true, this._chunk) {
                    try {
                      this.send(this._chunk);
                    } catch (e4) {
                      return this.destroy(l(e4, "ERR_DATA_CHANNEL"));
                    }
                    this._chunk = null, this._debug('sent chunk from "write before connect"');
                    const e3 = this._cb;
                    this._cb = null, e3(null);
                  }
                  "number" != typeof this._channel.bufferedAmountLowThreshold && (this._interval = setInterval(() => this._onInterval(), 150), this._interval.unref && this._interval.unref()), this._debug("connect"), this.emit("connect");
                });
              };
              e2();
            }
            _onInterval() {
              this._cb && this._channel && !(this._channel.bufferedAmount > u) && this._onChannelBufferedAmountLow();
            }
            _onSignalingStateChange() {
              this.destroyed || ("stable" === this._pc.signalingState && (this._isNegotiating = false, this._debug("flushing sender queue", this._sendersAwaitingStable), this._sendersAwaitingStable.forEach((e2) => {
                this._pc.removeTrack(e2), this._queuedNegotiation = true;
              }), this._sendersAwaitingStable = [], this._queuedNegotiation ? (this._debug("flushing negotiation queue"), this._queuedNegotiation = false, this._needsNegotiation()) : (this._debug("negotiated"), this.emit("negotiated"))), this._debug("signalingStateChange %s", this._pc.signalingState), this.emit("signalingStateChange", this._pc.signalingState));
            }
            _onIceCandidate(e2) {
              this.destroyed || (e2.candidate && this.trickle ? this.emit("signal", { type: "candidate", candidate: { candidate: e2.candidate.candidate, sdpMLineIndex: e2.candidate.sdpMLineIndex, sdpMid: e2.candidate.sdpMid } }) : !e2.candidate && !this._iceComplete && (this._iceComplete = true, this.emit("_iceComplete")), e2.candidate && this._startIceCompleteTimeout());
            }
            _onChannelMessage(e2) {
              if (this.destroyed)
                return;
              let t4 = e2.data;
              t4 instanceof ArrayBuffer && (t4 = c2.from(t4)), this.push(t4);
            }
            _onChannelBufferedAmountLow() {
              if (!this.destroyed && this._cb) {
                this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
                const e2 = this._cb;
                this._cb = null, e2(null);
              }
            }
            _onChannelOpen() {
              this._connected || this.destroyed || (this._debug("on channel open"), this._channelReady = true, this._maybeReady());
            }
            _onChannelClose() {
              this.destroyed || (this._debug("on channel close"), this.destroy());
            }
            _onTrack(e2) {
              this.destroyed || e2.streams.forEach((t4) => {
                this._debug("on track"), this.emit("track", e2.track, t4), this._remoteTracks.push({ track: e2.track, stream: t4 }), this._remoteStreams.some((e3) => e3.id === t4.id) || (this._remoteStreams.push(t4), s(() => {
                  this._debug("on stream"), this.emit("stream", t4);
                }));
              });
            }
            _debug() {
              const e2 = [].slice.call(arguments);
              e2[0] = "[" + this._id + "] " + e2[0], a2.apply(null, e2);
            }
          }
          p.WEBRTC_SUPPORT = !!o(), p.config = { iceServers: [{ urls: ["stun:stun.l.google.com:19302", "stun:global.stun.twilio.com:3478"] }], sdpSemantics: "unified-plan" }, p.channelConfig = {}, t3.exports = p;
        }, { buffer: 3, debug: 4, "err-code": 6, "get-browser-rtc": 8, "queue-microtask": 13, randombytes: 14, "readable-stream": 29 }] }, {}, [])("/");
      });
    }
  });

  // src/nodysseus.ts
  var import_lokijs = __toESM(require_lokijs(), 1);

  // src/util.ts
  var util_exports = {};
  __export(util_exports, {
    WRAPPED_KIND: () => WRAPPED_KIND,
    ancestor_graph: () => ancestor_graph,
    base_graph: () => base_graph,
    base_node: () => base_node,
    combineEnv: () => combineEnv,
    compareObjects: () => compareObjects,
    contract_node: () => contract_node,
    create_randid: () => create_randid,
    expand_node: () => expand_node,
    flattenNode: () => flattenNode,
    isWrappedPromise: () => isWrappedPromise,
    isgraph: () => isgraph,
    ispromise: () => ispromise,
    mapMaybePromise: () => mapMaybePromise,
    mergeEnv: () => mergeEnv,
    mergeLib: () => mergeLib,
    newEnv: () => newEnv,
    newLib: () => newLib,
    node_args: () => node_args,
    runnableId: () => runnableId,
    wrapPromise: () => wrapPromise,
    wrapPromiseAll: () => wrapPromiseAll
  });

  // src/types.ts
  var isNodeValue = (n2) => n2 && !!n2.value;
  var isNodeGraph = (n2) => n2 && !!n2.nodes;
  var isNodeScript = (n2) => n2 && !!n2?.script;
  var isNodeRef = (n2) => n2 && !!n2?.ref;
  var AP = "ap";
  var isApFunction = (a2) => a2 && a2.__kind === "apFunction";
  var isApFunctorLike = (a2) => !!a2 && (typeof a2 === "function" || isApFunction(a2) || isApRunnable(a2) || isFunctorRunnable(a2));
  var CONST = "const";
  var FUNCTOR = "functor";
  var isRunnable = (r) => isValue(r) || isConstRunnable(r) || isApRunnable(r) || isFunctorRunnable(r);
  var isError = (r) => r instanceof Error;
  var isValue = (r) => {
    const result = r;
    return !isError(result) && result?.__kind === "result";
  };
  var isConstRunnable = (r) => !(r instanceof Error) && r?.__kind == CONST;
  var isApRunnable = (r) => !(r instanceof Error) && r?.__kind == AP;
  var isFunctorRunnable = (r) => !(r instanceof Error) && r?.__kind == FUNCTOR;
  var isLib = (lib) => lib?.__kind === "lib";
  var isEnv = (env) => env?.__kind === "env";
  var isArgs = (args2) => typeof args2?.get === "function";

  // src/util.ts
  var WRAPPED_KIND = "wrapped";
  var ispromise = (a2) => a2 && typeof a2.then === "function" && !isWrappedPromise(a2);
  var isWrappedPromise = (a2) => a2 && a2.__kind === WRAPPED_KIND;
  var isgraph = (g) => g && g.out !== void 0 && g.nodes !== void 0 && g.edges !== void 0;
  var tryCatch = (fn, t2, c2) => {
    try {
      return fn(t2);
    } catch (e) {
      if (c2) {
        return wrapPromise(c2(e));
      }
      throw e;
    }
  };
  var wrapPromise = (t2, c2) => isWrappedPromise(t2) ? t2 : {
    __kind: WRAPPED_KIND,
    then: (fn) => wrapPromise(ispromise(t2) ? c2 ? t2.then(fn).catch(c2) : t2.then(fn) : tryCatch(fn, t2, c2)),
    value: t2
  };
  var wrapPromiseAll = (wrappedPromises) => {
    const hasPromise = wrappedPromises.reduce((acc, wrappedPromise) => acc || ispromise(wrappedPromise.value), false);
    return wrapPromise(hasPromise ? Promise.all(wrappedPromises.map((wp) => Promise.resolve(wp.value))) : wrappedPromises.map((wp) => wp.value));
  };
  var mapMaybePromise = (a2, fn) => ispromise(a2) ? a2.then(fn) : fn(a2);
  var base_node = (node) => node.ref || node.extern ? { id: node.id, value: node.value, name: node.name, ref: node.ref } : base_graph(node);
  var base_graph = (graph) => ({ id: graph.id, value: graph.value, name: graph.name, nodes: graph.nodes, edges: graph.edges, edges_in: graph.edges_in, out: graph.out });
  var create_randid = () => Math.random().toString(36).substring(2, 9);
  var isFlattenedGraph = (g) => !!g.flat_nodes;
  var flattenNode = (graph, levels = -1) => !isNodeGraph(graph) || !graph.nodes || levels <= 0 ? graph : Object.values(graph.nodes).map((g) => flattenNode(g, levels - 1)).reduce((acc, n2) => isFlattenedGraph(n2) ? Object.assign({}, acc, {
    flat_nodes: Object.assign(acc.flat_nodes, Object.fromEntries(Object.values(n2.flat_nodes).map((fn) => {
      if (fn.id === (graph.out || "out") && graph.name) {
        fn.name = graph.name;
      }
      return [fn.id, fn];
    }))),
    flat_edges: Object.assign(acc.flat_edges, n2.flat_edges)
  }) : acc, {
    flat_nodes: graph.nodes,
    flat_edges: graph.edges
  });
  var expand_node = (data2) => {
    const nolib2 = data2.nolib;
    const node_id = data2.node_id;
    const node = data2.editingGraph.nodes[node_id];
    if (!isNodeGraph(node)) {
      console.log("no nodes?");
      return { editingGraph: data2.editingGraph, selected: [data2.node_id] };
    }
    const args_node = Object.values(node.edges).find((e) => e.to === node.out && e.as === "args")?.from;
    const in_edges = nolib2.no.runtime.get_edges_in(data2.editingGraph.id, node_id);
    const flattened2 = flattenNode(node, 1);
    const new_id_map = isFlattenedGraph(flattened2) ? Object.values(flattened2.flat_nodes).reduce((acc, n2) => nolib2.no.runtime.get_node(data2.editingGraph, n2.id) ? (acc[n2.id] = create_randid(), acc) : n2, {}) : flattened2;
    isFlattenedGraph(flattened2) && nolib2.no.runtime.add_nodes_edges(data2.editingGraph.id, Object.values(flattened2.flat_nodes).map((n2) => ({ ...n2, id: new_id_map[n2.id] ?? n2.id })), Object.values(flattened2.flat_edges).concat(in_edges.map((e) => ({ ...e, to: new_id_map[args_node] ?? args_node }))).concat([{ ...data2.editingGraph.edges[node_id], from: node.out }]).map((e) => ({ ...e, from: new_id_map[e.from] ?? e.from, to: new_id_map[e.to] ?? e.to })), in_edges.concat([data2.editingGraph.edges[node_id]]), [node_id], nolib2);
    return { editingGraph: data2.editingGraph, selected: [new_id_map[node.out ?? "out"] ?? node.out ?? "out"] };
  };
  var contract_node = (data2, keep_expanded = false) => {
    const nolib2 = data2.nolib;
    const node = data2.editingGraph.nodes[data2.node_id];
    const node_id = data2.node_id;
    if (!isNodeGraph(node)) {
      const inside_nodes = [Object.assign({}, node)];
      const inside_node_map = /* @__PURE__ */ new Map();
      inside_node_map.set(inside_nodes[0].id, inside_nodes[0]);
      const inside_edges = /* @__PURE__ */ new Set();
      const q = nolib2.no.runtime.get_edges_in(data2.editingGraph.id, inside_nodes[0].id);
      let in_edge = [];
      let args_edge;
      while (q.length > 0) {
        const e = q.shift();
        if (e.to === node.id && e.as === "args") {
          args_edge = e;
        }
        in_edge.filter((ie3) => ie3.from === e.from).forEach((ie3) => {
          inside_edges.add(ie3);
        });
        in_edge = in_edge.filter((ie3) => ie3.from !== e.from);
        const old_node = inside_nodes.find((i) => e.from === i.id);
        let inside_node = old_node || Object.assign({}, data2.editingGraph.nodes[e.from]);
        inside_node_map.set(inside_node.id, inside_node);
        inside_edges.add(e);
        if (!old_node) {
          inside_nodes.push(inside_node);
        }
        if (!args_edge || e.from !== args_edge.from) {
          nolib2.no.runtime.get_edges_in(data2.editingGraph, e.from).forEach((de) => q.push(de));
        }
      }
      let args_node_id = args_edge ? args_edge.from : void 0;
      if (in_edge.find((ie3) => ie3.to !== args_node_id) || inside_nodes.length < 2) {
        return { editingGraph: data2.editingGraph, selected: [data2.node_id] };
      }
      const out_node_id = data2.node_id;
      let node_id_count = data2.editingGraph.nodes[node_id] ? 1 : 0;
      let final_node_id = node_id_count === 1 ? node_id : `${node_id}_${node_id_count}`;
      const edges = {};
      for (const e of inside_edges) {
        const from3 = e.from.startsWith(node_id + "/") ? e.from.substring(node_id.length + 1) : e.from;
        edges[from3] = {
          ...e,
          from: from3,
          to: e.to.startsWith(node_id + "/") ? e.to.substring(node_id.length + 1) : e.to
        };
      }
      const edgesToRemove = [];
      const edgesToAdd = [
        { ...nolib2.no.runtime.get_edge_out(data2.editingGraph, data2.node_id), from: final_node_id },
        ...nolib2.no.runtime.get_edges_in(data2.editingGraph, args_node_id).map((e) => ({ ...e, to: final_node_id }))
      ];
      for (let newn of inside_node_map.keys()) {
        nolib2.no.runtime.get_edges_in(data2.editingGraph, newn).filter((e) => inside_node_map.has(e.from)).forEach((e) => edgesToRemove.push(e));
      }
      for (const newn of inside_node_map.keys()) {
        nolib2.no.runtime.delete_node(data2.editingGraph.id, newn, nolib2, false);
      }
      nolib2.no.runtime.add_node(data2.editingGraph.id, {
        id: final_node_id,
        name: node.name ?? (isNodeValue(node) ? node.value : void 0),
        out: out_node_id.startsWith(node_id + "/") ? out_node_id.substring(node_id.length + 1) : out_node_id,
        nodes: Object.fromEntries(inside_nodes.map((n2) => [n2.id.startsWith(node_id + "/") ? n2.id.substring(node_id.length + 1) : n2.id, {
          ...n2,
          id: n2.id.startsWith(node_id + "/") ? n2.id.substring(node_id.length + 1) : n2.id
        }])),
        edges
      });
      nolib2.no.runtime.update_edges(data2.editingGraph.id, edgesToAdd, edgesToRemove, nolib2);
      return { selected: [final_node_id] };
    }
  };
  var ancestor_graph = (node_id, from_graph, nolib2) => {
    let edges_in;
    let queue = [node_id];
    const graph = { ...from_graph, nodes: {}, edges: {} };
    while (queue.length > 0) {
      let node_id2 = queue.pop();
      graph.nodes[node_id2] = { ...nolib2.no.runtime.get_node(from_graph, node_id2) };
      edges_in = nolib2.no.runtime.get_edges_in(from_graph, node_id2);
      graph.edges = Object.assign(graph.edges, Object.fromEntries(edges_in.map((e) => [e.from, e])));
      edges_in.forEach((e) => queue.push(e.from));
    }
    return graph;
  };
  var node_args = (nolib2, graph, node_id) => {
    const node = nolib2.no.runtime.get_node(graph, node_id);
    if (!node) {
      return [];
    }
    const node_ref = node?.ref ? nolib2.no.runtime.get_ref(node.ref) : node;
    const edges_in = nolib2.no.runtime.get_edges_in(graph, node_id);
    const edge_out = nolib2.no.runtime.get_edge_out(graph, node_id);
    const node_out = edge_out && edge_out.as === "parameters" && nolib2.no.runtime.get_node(graph, edge_out.to);
    const node_out_args = node_out?.ref === "runnable" && Object.values(ancestor_graph(node_out.id, graph, nolib2).nodes).filter(isNodeRef).filter((n2) => n2.ref === "arg").map((a2) => a2.value?.includes(".") ? a2.value?.substring(0, a2.value?.indexOf(".")) : a2.value).map((a2) => [a2, "any"]);
    const nextIndexedArg = "arg" + (edges_in?.filter((l) => l.as?.startsWith("arg") && new RegExp("[0-9]+").test(l.as.substring(3))).map((l) => parseInt(l.as.substring(3))) ?? []).reduce((acc, i) => acc > i ? acc : i + 1, 0);
    const externfn = node_ref?.ref === "extern" && nolib2.extern.get.fn({}, nolib2, node_ref?.value, void 0, void 0, nolib2);
    const externArgs = externfn && (Array.isArray(externfn.args) ? externfn.args.map((a2) => {
      const argColonIdx = a2.indexOf(":");
      return [argColonIdx >= 0 ? a2.substring(0, argColonIdx) : a2, "any"];
    }) : Object.entries(externfn.args));
    const baseargs = externfn ? externArgs ? externArgs : ["args"] : isNodeGraph(node_ref) ? Object.values(node_ref?.nodes).filter(isNodeRef).filter((n2) => n2.ref === "arg" && !n2.value?.split(":")[1]?.toLowerCase()?.includes("internal")).map((n2) => n2.value).filter((a2) => a2).map((a2) => [a2, "any"]) ?? [] : [];
    const typedArgsMap = new Map(baseargs.filter((a2) => !a2.includes(".") && !a2[0].startsWith("_")).concat(
      externArgs && externArgs.map((a2) => a2[0]).includes("_node_args") || baseargs.map((a2) => a2[0]).includes("_args") || node.ref === void 0 && !node.value ? [[nextIndexedArg, { type: "any", additionalArg: true }]] : []
    ).concat(node_out_args ? node_out_args : []));
    return [...typedArgsMap].concat(edges_in?.filter((e) => !typedArgsMap.has(e.as)).map((e) => [e.as, "any"])).map((a2) => ({ exists: !!edges_in?.find((e) => e.as === a2[0]), name: a2[0], ...typeof a2[1] === "object" ? a2[1] : { type: a2[1] } }));
  };
  var newEnv = (data2, _output, env) => ({ __kind: "env", data: data2?.size > 0 ? env?.data?.size ? new Map([...env.data, ...data2]) : data2 : /* @__PURE__ */ new Map(), _output, env: env?.env });
  var combineEnv = (data2, env, node_id, _output) => {
    if (isEnv(data2)) {
      throw new Error("Can't create an env with env data");
    }
    if (!data2?.has("__graphid")) {
      data2.set("__graphid", env.data.get("__graphid"));
    }
    return { __kind: "env", data: data2, env, node_id, _output };
  };
  var mergeEnv = (data2, env) => {
    if (isRunnable(data2)) {
      throw new Error("Can't merge a runnable");
    }
    const _output = isArgs(data2) && data2.has("_output") ? data2.get("_output") : false;
    return data2.size > 0 ? {
      __kind: "env",
      data: env?.data?.size > 0 ? new Map([...env.data, ...data2, ["_output", void 0]]) : data2.has("_output") ? new Map([...data2]) : data2,
      env: env.env,
      _output: _output === false ? env._output : isValue(_output) ? _output.value : data2.get("_output")
    } : env;
  };
  var newLib = (data2) => ({ __kind: "lib", data: data2 });
  var mergeLib = (a2, b) => a2 ? {
    __kind: "lib",
    data: Object.assign({}, isLib(a2) ? isArgs(a2.data) ? Object.fromEntries(a2.data) : a2.data : isArgs(a2) ? Object.fromEntries(a2) : a2, b.data)
  } : b;
  var runnableId = (runnable) => isConstRunnable(runnable) ? `${runnable.graph.id}/${runnable.fn}` : false;
  function compareObjects(value1, value2, isUpdate = false) {
    if (value1._needsresolve || value2._needsresolve) {
      return false;
    }
    const keys1 = Object.keys(value1);
    const keys22 = !isUpdate && Object.keys(value2);
    if (!isUpdate && keys1.length !== keys22.length) {
      return false;
    }
    for (let key of keys1) {
      if (key === "__args") {
        continue;
      }
      if (value1[key] === value2[key]) {
        continue;
      }
      return false;
    }
    return true;
  }

  // src/generic.js
  var generic = {
    "id": "generic",
    "nodes": {
      "simple": {
        "id": "simple",
        "out": "out",
        "category": "templates",
        "edges": [
          {
            "from": "qgbinm2",
            "to": "8dy573e",
            "as": "children"
          },
          {
            "from": "8dy573e",
            "to": "out",
            "as": "display"
          },
          {
            "from": "output_val",
            "to": "out",
            "as": "value"
          },
          {
            "from": "args",
            "to": "out",
            "as": "args"
          }
        ],
        "nodes": [
          {
            "id": "args"
          },
          {
            "id": "qgbinm2",
            "value": "Hello, world!",
            "ref": "html_text"
          },
          {
            "id": "8dy573e",
            "ref": "html_element"
          },
          {
            "id": "output_val",
            "value": "some output"
          },
          {
            "id": "out",
            "ref": "return",
            "name": "simple"
          }
        ]
      },
      "log": {
        "id": "log",
        "description": "Prints value to console.log",
        "category": "debug",
        "out": "out",
        "nodes": [
          {
            "id": "in"
          },
          {
            "id": "value",
            "ref": "arg",
            "value": "value"
          },
          {
            "id": "graph_value",
            "ref": "arg",
            "value": "__graph_value"
          },
          {
            "id": "out",
            "args": [],
            "ref": "script",
            "value": "graph_value ? console.log(graph_value, value) : console.log(value); return value"
          }
        ],
        "edges": [
          {
            "from": "in",
            "to": "out",
            "as": "input",
            "type": "ref"
          },
          {
            "from": "graph_value",
            "to": "out",
            "as": "graph_value"
          },
          {
            "from": "value",
            "to": "out",
            "as": "value"
          }
        ]
      },
      "math": {
        "id": "math",
        "category": "math",
        "ref": "extern",
        "value": "extern.math"
      },
      "expect": {
        "id": "expect",
        "category": "debug",
        "ref": "extern",
        "value": "extern.expect"
      },
      "fetch": {
        "id": "fetch",
        "category": "network",
        "name": "fetch",
        "description": "Uses the <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API'>Fetch API</a> to get data.",
        "ref": "extern",
        "value": "extern.fetch"
      },
      "call": {
        "id": "call",
        "name": "call",
        "category": "functions",
        "description": "Calls `self.fn` with `args`. If `self is not found, uses the node's context.",
        "ref": "extern",
        "value": "extern.call"
      },
      "stringify": {
        "id": "stringify",
        "name": "stringify",
        "category": "data",
        "description": "<a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify'>JSON.stringify</a> the `value` argument",
        "ref": "extern",
        "value": "extern.stringify"
      },
      "parse": {
        "id": "parse",
        "name": "parse",
        "category": "data",
        "description": "<a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify'>JSON.parse</a> the `value` argument",
        "ref": "extern",
        "value": "extern.parse"
      },
      "add": {
        "id": "add",
        "ref": "extern",
        "category": "math",
        "value": "extern.add",
        "description": "The javascript <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Addition'>+ operator</a>"
      },
      "mult": {
        "id": "mult",
        "ref": "extern",
        "value": "extern.mult",
        "category": "math",
        "description": "The javascript <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Multiplication'>* operator</a>"
      },
      "divide": {
        "id": "divide",
        "ref": "extern",
        "value": "extern.divide",
        "category": "math",
        "description": "The javascript <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Division'>/ operator</a>"
      },
      "negate": {
        "id": "negate",
        "ref": "extern",
        "value": "extern.negate",
        "category": "math",
        "description": "The javascript <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Subtraction'>- operator</a>"
      },
      "and": {
        "id": "and",
        "ref": "extern",
        "value": "extern.and",
        "category": "math",
        "description": "The javascript <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND'>&& operator</a>"
      },
      "random": {
        "id": "random",
        "description": "Returns a function that returns a different random number whenever called. An optional seed makes this sequence deterministic.",
        "out": "out",
        "nodes": {
          "args": {
            "id": "args"
          },
          "output_val": {
            "id": "output_val",
            "value": "return function() {\n        var t = b << 9, r = a * 5; r = (r << 7 | r >>> 25) * 9;\n        c ^= a; d ^= b;\n        b ^= c; a ^= d; c ^= t;\n        d = d << 11 | d >>> 21;\n        return (r >>> 0) / 4294967296;\n    }",
            "ref": "script"
          },
          "out": {
            "id": "out",
            "ref": "return",
            "name": "random"
          },
          "2a5n0mp": {
            "id": "2a5n0mp",
            "name": "128"
          },
          "4twtzbr": {
            "id": "4twtzbr",
            "value": "seed",
            "ref": "arg"
          },
          "t9tt2mz": {
            "id": "t9tt2mz",
            "name": "4"
          },
          "x0wph6o": {
            "id": "x0wph6o",
            "value": "seedb",
            "ref": "arg"
          },
          "95fj04c": {
            "id": "95fj04c",
            "ref": "default"
          },
          "srhd9iq": {
            "id": "srhd9iq",
            "value": "0"
          },
          "xge647g": {
            "id": "xge647g",
            "ref": "default"
          },
          "kplcozz": {
            "id": "kplcozz",
            "value": "0"
          },
          "33tvjok": {
            "id": "33tvjok",
            "value": "seedc",
            "ref": "arg"
          },
          "ucxkozy": {
            "id": "ucxkozy",
            "ref": "default"
          },
          "lyzm9a3": {
            "id": "lyzm9a3",
            "value": "0"
          },
          "ku4v2h1": {
            "id": "ku4v2h1",
            "value": "seedd",
            "ref": "arg"
          }
        },
        "edges": {
          "output_val": {
            "from": "output_val",
            "to": "out",
            "as": "value"
          },
          "args": {
            "from": "args",
            "to": "out",
            "as": "args"
          },
          "2a5n0mp": {
            "from": "2a5n0mp",
            "to": "args",
            "as": "seed"
          },
          "4twtzbr": {
            "from": "4twtzbr",
            "to": "output_val",
            "as": "a"
          },
          "t9tt2mz": {
            "from": "t9tt2mz",
            "to": "args",
            "as": "seedb"
          },
          "x0wph6o": {
            "from": "x0wph6o",
            "to": "95fj04c",
            "as": "value"
          },
          "95fj04c": {
            "from": "95fj04c",
            "to": "output_val",
            "as": "b"
          },
          "srhd9iq": {
            "from": "srhd9iq",
            "to": "95fj04c",
            "as": "otherwise"
          },
          "33tvjok": {
            "from": "33tvjok",
            "to": "xge647g",
            "as": "value"
          },
          "kplcozz": {
            "from": "kplcozz",
            "to": "xge647g",
            "as": "otherwise"
          },
          "xge647g": {
            "from": "xge647g",
            "to": "output_val",
            "as": "c"
          },
          "ku4v2h1": {
            "from": "ku4v2h1",
            "to": "ucxkozy",
            "as": "value"
          },
          "lyzm9a3": {
            "from": "lyzm9a3",
            "to": "ucxkozy",
            "as": "otherwise"
          },
          "ucxkozy": {
            "from": "ucxkozy",
            "to": "output_val",
            "as": "d"
          }
        },
        "edges_in": {
          "out": {
            "output_val": {
              "from": "output_val",
              "to": "out",
              "as": "value"
            },
            "args": {
              "from": "args",
              "to": "out",
              "as": "args"
            }
          },
          "args": {
            "2a5n0mp": {
              "from": "2a5n0mp",
              "to": "args",
              "as": "seed"
            },
            "t9tt2mz": {
              "from": "t9tt2mz",
              "to": "args",
              "as": "seedb"
            }
          },
          "output_val": {
            "4twtzbr": {
              "from": "4twtzbr",
              "to": "output_val",
              "as": "a"
            },
            "95fj04c": {
              "from": "95fj04c",
              "to": "output_val",
              "as": "b"
            },
            "xge647g": {
              "from": "xge647g",
              "to": "output_val",
              "as": "c"
            },
            "ucxkozy": {
              "from": "ucxkozy",
              "to": "output_val",
              "as": "d"
            }
          },
          "95fj04c": {
            "x0wph6o": {
              "from": "x0wph6o",
              "to": "95fj04c",
              "as": "value"
            },
            "srhd9iq": {
              "from": "srhd9iq",
              "to": "95fj04c",
              "as": "otherwise"
            }
          },
          "xge647g": {
            "33tvjok": {
              "from": "33tvjok",
              "to": "xge647g",
              "as": "value"
            },
            "kplcozz": {
              "from": "kplcozz",
              "to": "xge647g",
              "as": "otherwise"
            }
          },
          "ucxkozy": {
            "ku4v2h1": {
              "from": "ku4v2h1",
              "to": "ucxkozy",
              "as": "value"
            },
            "lyzm9a3": {
              "from": "lyzm9a3",
              "to": "ucxkozy",
              "as": "otherwise"
            }
          }
        }
      },
      "liftarraypromise": {
        "id": "liftarraypromise",
        "ref": "extern",
        "value": "extern.liftarraypromise",
        "category": "data",
        "description": "If an array contains a promise, wrap the whole array with `Promise.all`."
      },
      "typeof": {
        "id": "typeof",
        "ref": "extern",
        "category": "data",
        "value": "extern.typeof",
        "description": "javascript typeof operator"
      },
      "new": {
        "id": "new",
        "ref": "extern",
        "category": "functions",
        "value": "extern.construct",
        "description": "javascript constructor"
      },
      "addEventListeners": {
        "id": "addEventListeners",
        "ref": "extern",
        "category": "events",
        "value": "extern.addEventListeners",
        "description": "add js event listeners to a target"
      },
      "ancestors": {
        "id": "ancestors",
        "out": "out",
        "category": "util",
        "description": "Gets the ancestors of the `node` in `graph`",
        "nodes": [
          {
            "id": "in"
          },
          {
            "id": "graph",
            "ref": "arg",
            "value": "graph"
          },
          {
            "id": "node",
            "ref": "arg",
            "value": "node"
          },
          {
            "id": "out",
            "ref": "script",
            "value": "const parents = (id) => (graph ?? _graph).edges.filter(e => e.to === id).flatMap(e => parents(e.from)).concat([id]); return parents(node ?? graph.out ?? 'out')"
          }
        ],
        "edges": [
          {
            "from": "in",
            "to": "out",
            "as": "_",
            "type": "ref"
          },
          {
            "from": "graph",
            "to": "out",
            "as": "graph"
          },
          {
            "from": "node",
            "to": "out",
            "as": "node"
          }
        ]
      },
      "append": {
        "id": "append",
        "category": "data",
        "description": "Appends `item` to `array`. `item` can be a single item or an array.",
        "nodes": [
          {
            "id": "in"
          },
          {
            "id": "array",
            "ref": "arg",
            "value": "array"
          },
          {
            "id": "item",
            "ref": "arg",
            "value": "item"
          },
          {
            "id": "out",
            "ref": "script",
            "value": "return array.concat(Array.isArray(item) ? item : [item])"
          }
        ],
        "edges": [
          {
            "from": "in",
            "to": "out",
            "as": "_",
            "type": "ref"
          },
          {
            "from": "array",
            "to": "out",
            "as": "array"
          },
          {
            "from": "item",
            "to": "out",
            "as": "item"
          }
        ]
      },
      "concat": {
        "id": "concat",
        "category": "data",
        "description": "Concats `items` to `array`.",
        "nodes": [
          {
            "id": "array",
            "ref": "arg",
            "value": "array"
          },
          {
            "id": "items",
            "ref": "arg",
            "value": "items"
          },
          {
            "id": "out",
            "args": [
              "item",
              "array"
            ],
            "ref": "script",
            "value": "return (array ?? []).concat(items ?? [])"
          }
        ],
        "edges": [
          {
            "from": "array",
            "to": "out",
            "as": "array"
          },
          {
            "from": "items",
            "to": "out",
            "as": "items"
          }
        ]
      },
      "filter_eq": {
        "id": "filter_eq",
        "name": "filter_eq",
        "category": "data",
        "description": "Filters `array` for items where `item.key` === `value`",
        "out": "lahq5z4",
        "nodes": [
          {
            "id": "lahq5z4",
            "args": [],
            "name": "filter/out",
            "ref": "script",
            "value": "return arr.filter(v => v[key] === value)"
          },
          {
            "id": "pfoypo5",
            "args": [],
            "ref": "arg",
            "value": "key"
          },
          {
            "id": "zinx621",
            "args": [],
            "ref": "arg",
            "value": "value"
          },
          {
            "id": "x2sz5kb",
            "args": [],
            "ref": "arg",
            "value": "array"
          },
          {
            "id": "74n1jfm",
            "args": [],
            "name": "filter/in"
          }
        ],
        "edges": [
          {
            "from": "pfoypo5",
            "to": "lahq5z4",
            "as": "key"
          },
          {
            "from": "zinx621",
            "to": "lahq5z4",
            "as": "value"
          },
          {
            "from": "x2sz5kb",
            "to": "lahq5z4",
            "as": "arr"
          },
          {
            "from": "74n1jfm",
            "to": "lahq5z4",
            "as": "input"
          }
        ]
      },
      "default": {
        "id": "default",
        "out": "out",
        "category": "data",
        "description": "Returns `value` if it's defined, if not then returns `otherwise`",
        "nodes": [
          {
            "id": "value",
            "ref": "arg",
            "value": "value"
          },
          {
            "id": "is_value_value",
            "ref": "arg",
            "value": "value"
          },
          {
            "id": "graph_value",
            "ref": "arg",
            "value": "__graph_value"
          },
          {
            "id": "otherwise_is",
            "ref": "arg",
            "value": "otherwise"
          },
          {
            "id": "otherwise_if",
            "ref": "arg",
            "value": "otherwise"
          },
          {
            "id": "otherwise_value",
            "ref": "arg",
            "value": "otherwise"
          },
          {
            "id": "is_otherwise",
            "ref": "script",
            "value": "return otherwise !== undefined && otherwise !== null"
          },
          {
            "id": "if_otherwise",
            "ref": "if"
          },
          {
            "id": "is_value",
            "ref": "script",
            "value": "return value !== undefined"
          },
          {
            "id": "if_value",
            "ref": "if"
          },
          {
            "id": "out",
            "ref": "return"
          }
        ],
        "edges": [
          {
            "from": "otherwise_if",
            "to": "if_otherwise",
            "as": "true"
          },
          {
            "from": "otherwise_is",
            "to": "is_otherwise",
            "as": "otherwise"
          },
          {
            "from": "is_otherwise",
            "to": "if_otherwise",
            "as": "pred"
          },
          {
            "from": "graph_value",
            "to": "if_otherwise",
            "as": "false"
          },
          {
            "from": "is_value_value",
            "to": "is_value",
            "as": "value"
          },
          {
            "from": "value",
            "to": "if_value",
            "as": "true"
          },
          {
            "from": "is_value",
            "to": "if_value",
            "as": "pred"
          },
          {
            "from": "otherwise_value",
            "to": "if_value",
            "as": "false"
          },
          {
            "from": "if_value",
            "to": "out",
            "as": "value"
          }
        ]
      },
      "switch": { "id": "switch", "ref": "extern", "value": "extern.switch" },
      "compare": { "id": "compare", "ref": "extern", "value": "compare" },
      "if": {
        "id": "if",
        "out": "out",
        "category": "flow",
        "description": "If `pred` exists in the node's context, return the value from the `true` branch. Otherwise, return the value from the `false` branch.",
        "nodes": [
          {
            "id": "pred",
            "ref": "arg",
            "value": "pred"
          },
          {
            "id": "true",
            "ref": "arg",
            "value": "true"
          },
          {
            "id": "false",
            "ref": "arg",
            "value": "false"
          },
          {
            "id": "predval",
            "ref": "script",
            "value": "return !!pred ? 'true_val' : 'false_val'"
          },
          {
            "id": "out",
            "ref": "extern",
            "value": "extern.switch"
          }
        ],
        "edges": [
          {
            "from": "true",
            "to": "out",
            "as": "true_val"
          },
          {
            "from": "false",
            "to": "out",
            "as": "false_val"
          },
          {
            "from": "pred",
            "to": "predval",
            "as": "pred"
          },
          {
            "from": "predval",
            "to": "out",
            "as": "input"
          }
        ]
      },
      "find_node": {
        "id": "find_node",
        "category": "util",
        "description": "Find the node with id `node_id` in `nodes`.",
        "ref": "script",
        "value": "if(!node_id){ return undefined } const nid = typeof node_id === 'string' ? node_id : node_id[0]; return nodes.find(n => n.id === nid || n.node_id === nid)"
      },
      "svg_text": {
        "id": "svg_text",
        "category": "html",
        "description": "Returns a hyperapp `svg` text element with `text` and `props`",
        "out": "out",
        "nodes": [
          {
            "id": "text",
            "ref": "arg",
            "value": "text"
          },
          {
            "id": "props",
            "ref": "arg",
            "value": "props"
          },
          {
            "id": "dom_type",
            "value": "text"
          },
          {
            "id": "text_el",
            "ref": "html_text"
          },
          {
            "id": "children",
            "ref": "script",
            "value": "return [text]"
          },
          {
            "id": "out",
            "ref": "html_element"
          }
        ],
        "edges": [
          {
            "from": "dom_type",
            "to": "out",
            "as": "dom_type"
          },
          {
            "from": "text",
            "to": "text_el",
            "as": "text"
          },
          {
            "from": "text_el",
            "to": "children",
            "as": "text"
          },
          {
            "from": "props",
            "to": "out",
            "as": "props"
          },
          {
            "from": "children",
            "to": "out",
            "as": "children"
          }
        ]
      },
      "runnable_return": {
        "id": "runnable_return",
        "description": "Combines `return` and `runnable` into one node.",
        "category": "flow",
        "out": "out",
        "nodes": [
          {
            "id": "return",
            "ref": "arg",
            "value": "return"
          },
          {
            "id": "display",
            "ref": "arg",
            "value": "display"
          },
          {
            "id": "subscribe",
            "ref": "arg",
            "value": "subscribe"
          },
          {
            "id": "publish",
            "ref": "arg",
            "value": "publish"
          },
          {
            "id": "return_edge_input",
            "ref": "input_edge",
            "value": "return"
          },
          {
            "id": "return_edge_arg",
            "ref": "arg",
            "value": "return_edge",
            "type": [
              "local",
              "internal"
            ]
          },
          {
            "id": "return_edge",
            "ref": "default"
          },
          {
            "id": "display_edge_input",
            "ref": "input_edge",
            "value": "display"
          },
          {
            "id": "display_edge_arg",
            "ref": "arg",
            "value": "display_edge",
            "type": [
              "local",
              "internal"
            ]
          },
          {
            "id": "display_edge",
            "ref": "default"
          },
          {
            "id": "publish_edge_input",
            "ref": "input_edge",
            "value": "publish"
          },
          {
            "id": "publish_edge_arg",
            "ref": "arg",
            "value": "publish_edge",
            "type": [
              "local",
              "internal"
            ]
          },
          {
            "id": "publish_edge",
            "ref": "default"
          },
          {
            "id": "subscribe_edge_input",
            "ref": "input_edge",
            "value": "subscribe"
          },
          {
            "id": "subscribe_edge_arg",
            "ref": "arg",
            "value": "subscribe_edge",
            "type": [
              "local",
              "internal"
            ]
          },
          {
            "id": "subscribe_edge",
            "ref": "default"
          },
          {
            "id": "args",
            "ref": "arg",
            "value": "args"
          },
          {
            "id": "merge_args",
            "ref": "merge_objects"
          },
          {
            "id": "return_node",
            "ref": "return"
          },
          {
            "id": "out",
            "ref": "runnable"
          }
        ],
        "edges": [
          {
            "from": "return_edge_arg",
            "to": "return_edge",
            "as": "value"
          },
          {
            "from": "return_edge_input",
            "to": "return_edge",
            "as": "otherwise"
          },
          {
            "from": "display_edge_arg",
            "to": "display_edge",
            "as": "value"
          },
          {
            "from": "display_edge_input",
            "to": "display_edge",
            "as": "otherwise"
          },
          {
            "from": "publish_edge_arg",
            "to": "publish_edge",
            "as": "value"
          },
          {
            "from": "publish_edge_input",
            "to": "publish_edge",
            "as": "otherwise"
          },
          {
            "from": "subscribe_edge_arg",
            "to": "subscribe_edge",
            "as": "value"
          },
          {
            "from": "subscribe_edge_input",
            "to": "subscribe_edge",
            "as": "otherwise"
          },
          {
            "from": "return_edge",
            "to": "return_node",
            "as": "return_edge"
          },
          {
            "from": "display_edge",
            "to": "return_node",
            "as": "display_edge"
          },
          {
            "from": "subscribe_edge",
            "to": "return_node",
            "as": "subscribe_edge"
          },
          {
            "from": "publish_edge",
            "to": "return_node",
            "as": "publish_edge"
          },
          {
            "from": "args",
            "to": "return_node",
            "as": "args"
          },
          {
            "from": "return_node",
            "to": "out",
            "as": "fn"
          }
        ]
      },
      "return": {
        "id": "return",
        "category": "flow",
        "description": "Creates an inline graph with args, pub/sub, etc. See docs for more detail.",
        "ref": "extern",
        "value": "extern.return"
      },
      "fold": {
        "id": "fold",
        "category": "data",
        "ref": "extern",
        "value": "extern.fold"
      },
      "runnable": {
        "id": "runnable",
        "category": "flow",
        "ref": "extern",
        "value": "extern.runnable"
      },
      "ap": {
        "id": "ap",
        "category": "flow",
        "ref": "extern",
        "value": "extern.ap"
      },
      "script": {
        "id": "script",
        "category": "functions",
        "description": "Runs this as a javascript function. `return` is needed at the end of the script to return anything.",
        "ref": "extern",
        "value": "extern.script"
      },
      "extern": {
        "id": "extern",
        "category": "nodysseus",
        "description": "Uses a function from the nodysseus extern library directly"
      },
      "array": {
        "id": "array",
        "name": "array",
        "category": "data",
        "description": "Create an array from all the inputs in alphabetical order",
        "ref": "extern",
        "value": "extern.new_array"
      },
      "create_fn": {
        "id": "create_fn",
        "ref": "extern",
        "category": "functions",
        "value": "extern.create_fn"
      },
      "merge_objects": {
        "id": "merge_objects",
        "category": "data",
        "description": "Merge the keys of two objects, in descending alphabetical order priority (`Object.assign(...inputs)`).",
        "ref": "extern",
        "value": "extern.merge_objects"
      },
      "merge_objects_mutable": {
        "id": "merge_objects_mutable",
        "category": "data",
        "description": "Merge the keys of one or more objects into the target object, in descending alphabetical order priority (`Object.assign(...inputs)`).",
        "ref": "extern",
        "value": "extern.merge_objects_mutable"
      },
      "get": {
        "id": "get",
        "category": "data",
        "description": "Get the value at the path of object. Accepts a `.` separated path e.g. get(target, 'a.b.c') returns target.a.b.c",
        "out": "out",
        "nodes": [
          {
            "id": "target",
            "ref": "arg",
            "value": "target: default"
          },
          {
            "id": "path",
            "ref": "arg",
            "value": "path"
          },
          {
            "id": "graph_value",
            "ref": "arg",
            "value": "__graph_value"
          },
          {
            "id": "otherwise",
            "ref": "arg",
            "value": "otherwise"
          },
          {
            "id": "out",
            "ref": "extern",
            "value": "extern.get"
          }
        ],
        "edges": [
          {
            "from": "graph_value",
            "to": "out",
            "as": "graphval"
          },
          {
            "from": "otherwise",
            "to": "out",
            "as": "def"
          },
          {
            "from": "path",
            "to": "out",
            "as": "path"
          },
          {
            "from": "target",
            "to": "out",
            "as": "target"
          }
        ]
      },
      "arg": {
        "id": "arg",
        "category": "flow",
        "description": "Get an input to the graph this is a part of.",
        "ref": "extern",
        "value": "extern.arg"
      },
      "set_mutable": {
        "id": "set_mutable",
        "description": "Sets `target` value at `path` to `value` and returns the object.",
        "category": "data",
        "ref": "extern",
        "value": "extern.set_mutable",
        "_out": "out",
        "_nodes": [
          {
            "id": "path",
            "ref": "arg",
            "value": "path"
          },
          {
            "id": "target",
            "ref": "arg",
            "value": "target"
          },
          {
            "id": "value",
            "ref": "arg",
            "value": "value"
          },
          {
            "id": "out",
            "ref": "extern",
            "value": "extern.set_mutable"
          }
        ],
        "_edges": [
          {
            "from": "path",
            "to": "out",
            "as": "path"
          },
          {
            "from": "target",
            "to": "out",
            "as": "target"
          },
          {
            "from": "value",
            "to": "out",
            "as": "value"
          }
        ]
      },
      "set": {
        "id": "set",
        "category": "data",
        "description": "Returns a new object with the property at `path` (or the node's value) on `target` set to `value`. Accepts a `.` separated path e.g. set(target, 'a.b', 'c') returns {...target, a: {...target.a, b: 'c'}}",
        "type": "(target: any, value: any, path: string) => any",
        "ref": "extern",
        "value": "extern.set"
      },
      "modify": {
        "id": "modify",
        "category": "data",
        "description": "Returns a new object with the property at `path` (or the node's value) on `target` modified with `fn`. Accepts a `.` separated path e.g. set(target, 'a.b', 'c') returns {...target, a: {...target.a, b: 'c'}}",
        "type": "(target: any, value: any, path: string) => any",
        "ref": "extern",
        "value": "extern.modify"
      },
      "delete": {
        "id": "delete",
        "category": "data",
        "description": "Deletes `target` property at `path`",
        "ref": "extern",
        "value": "extern.delete"
      },
      "tapbutton": {
        "id": "tapbutton",
        "category": "html",
        "nodes": [
          {
            "id": "args"
          },
          {
            "id": "8dy573e",
            "ref": "html_element"
          },
          {
            "id": "out",
            "name": "tapbutton",
            "ref": "return"
          },
          {
            "id": "qgbinm2",
            "value": "button",
            "ref": "html_element"
          },
          { "id": "label", "ref": "arg", "value": "__graph_value" },
          {
            "id": "9fogdzn",
            "value": "signal",
            "ref": "html_text"
          },
          {
            "id": "ehximpo"
          },
          {
            "id": "4stvov8",
            "ref": "ap"
          },
          {
            "id": "8ywgts7",
            "ref": "state"
          },
          {
            "id": "v089o3o",
            "value": "signal.set",
            "ref": "arg"
          },
          {
            "id": "k3rjgad"
          },
          {
            "id": "76he898",
            "value": "true"
          },
          {
            "id": "nhmeamz",
            "ref": "ap"
          },
          {
            "id": "7mj35x5"
          },
          {
            "id": "bim5wsv",
            "value": "signal.set",
            "ref": "arg"
          },
          {
            "id": "4mha35d",
            "value": "false"
          },
          {
            "id": "hbo5tmq",
            "ref": "array"
          },
          {
            "id": "lgx7u5i",
            "ref": "html_text"
          },
          {
            "id": "g19y12v",
            "value": "signal.state",
            "ref": "arg"
          },
          {
            "id": "9vqinsg"
          },
          {
            "id": "i38qweq",
            "value": "none"
          },
          {
            "id": "eemfhib",
            "value": "signal.state",
            "ref": "arg"
          },
          {
            "id": "n2a984s_arr",
            "ref": "array"
          },
          {
            "id": "n2a984s",
            "ref": "ap"
          },
          {
            "id": "a14g4yc",
            "value": "ontap",
            "ref": "arg"
          }
        ],
        "edges": [
          {
            "from": "8dy573e",
            "to": "out",
            "as": "display"
          },
          {
            "from": "args",
            "to": "out",
            "as": "args"
          },
          { "from": "label", "to": "9fogdzn", "as": "text" },
          {
            "from": "9fogdzn",
            "to": "qgbinm2",
            "as": "children"
          },
          {
            "from": "ehximpo",
            "to": "qgbinm2",
            "as": "props"
          },
          {
            "from": "8ywgts7",
            "to": "args",
            "as": "signal"
          },
          {
            "from": "v089o3o",
            "to": "4stvov8",
            "as": "fn"
          },
          {
            "from": "k3rjgad",
            "to": "4stvov8",
            "as": "args"
          },
          {
            "from": "76he898",
            "to": "k3rjgad",
            "as": "value"
          },
          {
            "from": "4stvov8",
            "to": "ehximpo",
            "as": "onpointerdown"
          },
          {
            "from": "bim5wsv",
            "to": "nhmeamz",
            "as": "fn"
          },
          {
            "from": "7mj35x5",
            "to": "nhmeamz",
            "as": "args"
          },
          {
            "from": "4mha35d",
            "to": "7mj35x5",
            "as": "value"
          },
          {
            "from": "hbo5tmq",
            "to": "8dy573e",
            "as": "children"
          },
          {
            "from": "qgbinm2",
            "to": "hbo5tmq",
            "as": "arg1"
          },
          {
            "from": "lgx7u5i",
            "to": "_hbo5tmq",
            "as": "arg2"
          },
          {
            "from": "g19y12v",
            "to": "lgx7u5i",
            "as": "text"
          },
          {
            "from": "9vqinsg",
            "to": "ehximpo",
            "as": "style"
          },
          {
            "from": "i38qweq",
            "to": "9vqinsg",
            "as": "userSelect"
          },
          {
            "from": "eemfhib",
            "to": "8dy573e",
            "as": "value"
          },
          {
            "from": "n2a984s",
            "to": "ehximpo",
            "as": "onpointerup"
          },
          {
            "from": "nhmeamz",
            "to": "n2a984s_arr",
            "as": "arg0"
          },
          {
            "from": "a14g4yc",
            "to": "n2a984s_arr",
            "as": "arg1"
          },
          {
            "from": "n2a984s_arr",
            "to": "n2a984s",
            "as": "fn"
          }
        ],
        "out": "out"
      },
      "graphchangecache": {
        "id": "graphchangecache",
        "out": "out",
        "nodes": {
          "value": {
            "id": "value",
            "ref": "arg",
            "value": "value"
          },
          "graphid": {
            "id": "graphid",
            "ref": "arg",
            "value": "__graphid"
          },
          "recache": {
            "id": "recache",
            "ref": "arg",
            "value": "recache"
          },
          "cachevalue_state": {
            "id": "cachevalue_state",
            "value": "_cachevalue.state",
            "ref": "arg"
          },
          "pred_cachevalue_state": {
            "id": "pred_cachevalue_state",
            "value": "_cachevalue.state",
            "ref": "arg"
          },
          "pred_cache_state": {
            "id": "pred_cache_state",
            "value": "const docache = _reset || (recache === undefined ? (cachevaluestate === undefined || cachevaluestate === null) : (recache !== false && (typeof recache !== 'object' || Object.keys(recache).length > 0)))\n\nreturn docache;",
            "ref": "script"
          },
          "ap_cache_value": {
            "id": "ap_cache_value",
            "ref": "arg",
            "value": "value: default"
          },
          "ap_cache_args": {
            "id": "ap_cache_args"
          },
          "ap_cache_fn": {
            "id": "ap_cache_fn",
            "value": "_cachevalue.set",
            "ref": "arg"
          },
          "cache": {
            "id": "cache",
            "ref": "ap"
          },
          "if_cache_state": {
            "id": "if_cache_state",
            "ref": "if"
          },
          "cache_state": {
            "id": "cache_state",
            "ref": "state"
          },
          "cache_return_args": {
            "id": "cache_return_args"
          },
          "cache_return": {
            "id": "cache_return",
            "ref": "return"
          },
          "recache_button_fn": {
            "id": "recache_button_fn",
            "value": "_cachevalue.set",
            "ref": "arg"
          },
          "recache_button_fn_args": {
            "id": "recache_button_fn_args"
          },
          "recache_button_fn_value": {
            "id": "recache_button_fn_value",
            "ref": "arg",
            "value": "value"
          },
          "recache_button_ap": {
            "id": "recache_button_ap",
            "ref": "ap"
          },
          "recache_button": {
            "id": "recache_button",
            "value": "reset",
            "ref": "tapbutton"
          },
          "out": {
            "id": "out",
            "name": "graphchangecache",
            "ref": "return"
          },
          "fy9ee3e": {
            "id": "fy9ee3e"
          },
          "7rk5v07": {
            "id": "7rk5v07",
            "ref": "ap"
          },
          "gecwhp1": {
            "id": "gecwhp1",
            "value": "_reset.set",
            "ref": "arg"
          },
          "uwfswa7": {
            "id": "uwfswa7"
          },
          "eh9nyb7": {
            "id": "eh9nyb7",
            "value": "true"
          },
          "wx3yoem": {
            "id": "wx3yoem",
            "ref": "state"
          },
          "h56r87n": {
            "id": "h56r87n",
            "value": "_reset.state",
            "ref": "arg"
          },
          "xbhq0f0": {
            "id": "xbhq0f0",
            "value": "true"
          },
          "kqnga6d": {
            "id": "kqnga6d",
            "ref": "array"
          },
          "9w2cqoc": {
            "id": "9w2cqoc",
            "value": "0",
            "ref": "get"
          },
          "w7nd0t8": {
            "id": "w7nd0t8",
            "ref": "ap"
          },
          "mixjulh": {
            "id": "mixjulh",
            "value": "true"
          },
          "5647gh5": {
            "id": "5647gh5"
          },
          "atqq2qu": {
            "id": "atqq2qu",
            "value": "false"
          },
          "wa4gr84": {
            "id": "wa4gr84",
            "value": "_reset.set",
            "ref": "arg"
          }
        },
        "edges": {
          "ap_cache_value": {
            "from": "ap_cache_value",
            "to": "ap_cache_args",
            "as": "value"
          },
          "ap_cache_args": {
            "from": "ap_cache_args",
            "to": "cache",
            "as": "args"
          },
          "ap_cache_fn": {
            "from": "ap_cache_fn",
            "to": "cache",
            "as": "fn"
          },
          "pred_cachevalue_state": {
            "from": "pred_cachevalue_state",
            "to": "pred_cache_state",
            "as": "cachevaluestate"
          },
          "recache": {
            "from": "recache",
            "to": "pred_cache_state",
            "as": "recache"
          },
          "cachevalue_state": {
            "from": "cachevalue_state",
            "to": "if_cache_state",
            "as": "false"
          },
          "cache": {
            "from": "cache",
            "to": "kqnga6d",
            "as": "arg0"
          },
          "pred_cache_state": {
            "from": "pred_cache_state",
            "to": "if_cache_state",
            "as": "pred"
          },
          "if_cache_state": {
            "from": "if_cache_state",
            "to": "cache_return",
            "as": "value"
          },
          "cache_state": {
            "from": "cache_state",
            "to": "cache_return_args",
            "as": "_cachevalue"
          },
          "cache_return_args": {
            "from": "cache_return_args",
            "to": "out",
            "as": "args"
          },
          "cache_return": {
            "from": "cache_return",
            "to": "out",
            "as": "value"
          },
          "recache_button_fn_value": {
            "from": "recache_button_fn_value",
            "to": "recache_button_fn_args",
            "as": "value"
          },
          "recache_button_fn_args": {
            "from": "recache_button_fn_args",
            "to": "recache_button_ap",
            "as": "args"
          },
          "recache_button_fn": {
            "from": "recache_button_fn",
            "to": "recache_button_ap",
            "as": "fn"
          },
          "recache_button_ap": {
            "from": "recache_button_ap",
            "to": "recache_button",
            "as": "ontap"
          },
          "recache_button": {
            "from": "recache_button",
            "to": "out",
            "as": "display"
          },
          "fy9ee3e": {
            "from": "fy9ee3e",
            "to": "out",
            "as": "subscribe"
          },
          "7rk5v07": {
            "from": "7rk5v07",
            "to": "fy9ee3e",
            "as": "graphchange"
          },
          "gecwhp1": {
            "from": "gecwhp1",
            "to": "7rk5v07",
            "as": "fn"
          },
          "uwfswa7": {
            "from": "uwfswa7",
            "to": "7rk5v07",
            "as": "args"
          },
          "eh9nyb7": {
            "from": "eh9nyb7",
            "to": "uwfswa7",
            "as": "value"
          },
          "wx3yoem": {
            "from": "wx3yoem",
            "to": "cache_return_args",
            "as": "_reset"
          },
          "h56r87n": {
            "from": "h56r87n",
            "to": "pred_cache_state",
            "as": "_reset"
          },
          "xbhq0f0": {
            "from": "xbhq0f0",
            "to": "cache",
            "as": "run"
          },
          "kqnga6d": {
            "from": "kqnga6d",
            "to": "9w2cqoc",
            "as": "target"
          },
          "9w2cqoc": {
            "from": "9w2cqoc",
            "to": "if_cache_state",
            "as": "true"
          },
          "w7nd0t8": {
            "from": "w7nd0t8",
            "to": "kqnga6d",
            "as": "arg1"
          },
          "mixjulh": {
            "from": "mixjulh",
            "to": "w7nd0t8",
            "as": "run"
          },
          "5647gh5": {
            "from": "5647gh5",
            "to": "w7nd0t8",
            "as": "args"
          },
          "atqq2qu": {
            "from": "atqq2qu",
            "to": "5647gh5",
            "as": "value"
          },
          "wa4gr84": {
            "from": "wa4gr84",
            "to": "w7nd0t8",
            "as": "fn"
          }
        }
      },
      "cache": {
        "id": "cache",
        "out": "out",
        "nodes": {
          "value": {
            "id": "value",
            "ref": "arg",
            "value": "value"
          },
          "graphid": {
            "id": "graphid",
            "ref": "arg",
            "value": "__graphid"
          },
          "recache": {
            "id": "recache",
            "ref": "arg",
            "value": "recache"
          },
          "cachevalue_state": {
            "id": "cachevalue_state",
            "value": "_cachevalue.state",
            "ref": "arg"
          },
          "pred_cachevalue_state": {
            "id": "pred_cachevalue_state",
            "value": "_cachevalue.state",
            "ref": "arg"
          },
          "pred_cachevalue": {
            "id": "pred_cachevalue",
            "value": "_cachevalue",
            "ref": "arg"
          },
          "pred_cache_state": {
            "id": "pred_cache_state",
            "value": "const docache = recache === undefined ? (cachevaluestate === undefined || cachevaluestate === null) : (recache !== false && (typeof recache !== 'object' || Object.keys(recache).length > 0));\n\nreturn docache;",
            "ref": "script"
          },
          "ap_cache_value": {
            "id": "ap_cache_value",
            "ref": "arg",
            "value": "value: default"
          },
          "ap_cache_args": {
            "id": "ap_cache_args"
          },
          "ap_cache_run": {
            "id": "ap_cache_run",
            "value": "true"
          },
          "ap_cache_fn": {
            "id": "ap_cache_fn",
            "value": "_cachevalue.set",
            "ref": "arg"
          },
          "cache": {
            "id": "cache",
            "ref": "ap"
          },
          "if_cache_state": {
            "id": "if_cache_state",
            "ref": "if"
          },
          "cache_state": {
            "id": "cache_state",
            "ref": "state"
          },
          "cache_return_args": {
            "id": "cache_return_args"
          },
          "cache_return": {
            "id": "cache_return",
            "ref": "return"
          },
          "recache_button_fn": {
            "id": "recache_button_fn",
            "value": "_cachevalue.set",
            "ref": "arg"
          },
          "recache_button_fn_args": {
            "id": "recache_button_fn_args"
          },
          "recache_button_fn_value": {
            "id": "recache_button_fn_value",
            "value": "undefined"
          },
          "recache_button_ap": {
            "id": "recache_button_ap",
            "ref": "ap"
          },
          "recache_button": {
            "id": "recache_button",
            "value": "recache",
            "ref": "tapbutton"
          },
          "out": {
            "id": "out",
            "ref": "return",
            "name": "cache"
          },
          "jb9ua5s": {
            "id": "jb9ua5s",
            "ref": "refval"
          }
        },
        "edges": {
          "ap_cache_value": {
            "from": "ap_cache_value",
            "to": "ap_cache_args",
            "as": "value"
          },
          "ap_cache_args": {
            "from": "ap_cache_args",
            "to": "cache",
            "as": "args"
          },
          "ap_cache_run": {
            "from": "ap_cache_run",
            "to": "cache",
            "as": "run"
          },
          "ap_cache_fn": {
            "from": "ap_cache_fn",
            "to": "cache",
            "as": "fn"
          },
          "pred_cachevalue_state": {
            "from": "pred_cachevalue_state",
            "to": "pred_cache_state",
            "as": "cachevaluestate"
          },
          "recache": {
            "from": "recache",
            "to": "pred_cache_state",
            "as": "recache"
          },
          "cachevalue_state": {
            "from": "cachevalue_state",
            "to": "if_cache_state",
            "as": "false"
          },
          "cache": {
            "from": "cache",
            "to": "if_cache_state",
            "as": "true"
          },
          "pred_cachevalue": {
            "from": "pred_cachevalue",
            "to": "pred_cache_state",
            "as": "cachevalue"
          },
          "pred_cache_state": {
            "from": "pred_cache_state",
            "to": "if_cache_state",
            "as": "pred"
          },
          "if_cache_state": {
            "from": "if_cache_state",
            "to": "cache_return",
            "as": "value"
          },
          "cache_state": {
            "from": "cache_state",
            "to": "cache_return_args",
            "as": "_cachevalue"
          },
          "cache_return_args": {
            "from": "cache_return_args",
            "to": "out",
            "as": "args"
          },
          "cache_return": {
            "from": "cache_return",
            "to": "out",
            "as": "value"
          },
          "recache_button_fn_value": {
            "from": "recache_button_fn_value",
            "to": "recache_button_fn_args",
            "as": "value"
          },
          "recache_button_fn_args": {
            "from": "recache_button_fn_args",
            "to": "recache_button_ap",
            "as": "args"
          },
          "recache_button_fn": {
            "from": "recache_button_fn",
            "to": "recache_button_ap",
            "as": "fn"
          },
          "recache_button_ap": {
            "from": "recache_button_ap",
            "to": "recache_button",
            "as": "ontap"
          },
          "recache_button": {
            "from": "recache_button",
            "to": "out",
            "as": "display"
          }
        }
      },
      "isunchanged": {
        "id": "isunchanged",
        "category": "data",
        "description": "Returns true if `value` is unchanged otherwise `false`.",
        "nodes": [
          {
            "id": "in"
          },
          {
            "id": "eq_fn_value",
            "ref": "arg",
            "value": "value"
          },
          { "id": "eq_fn_if", "ref": "arg", "value": "eq_fn" },
          { "id": "eq_fn_cache", "ref": "arg", "value": "eq_fn" },
          {
            "id": "cache_value",
            "ref": "arg",
            "value": "value"
          },
          {
            "id": "fn",
            "ref": "arg",
            "value": "fn"
          },
          {
            "id": "cached",
            "ref": "arg",
            "value": "cached",
            "type": "internal"
          },
          {
            "id": "eq_default",
            "ref": "eq"
          },
          {
            "id": "eq_runnable",
            "ref": "runnable"
          },
          {
            "id": "fn_runnable",
            "ref": "default"
          },
          {
            "id": "eq_fn_runnable",
            "ref": "script",
            "value": "return {...fn, args: {...(fn.args ?? {}), a, b}}"
          },
          { "id": "eq_fn", "ref": "run" },
          { "id": "eq_fn_return_args" },
          { "id": "cache", "ref": "set_arg", "value": "cached" },
          { "id": "if_eq_fn", "ref": "if" },
          { "id": "out", "ref": "return" }
        ],
        "edges": [
          {
            "from": "eq_default",
            "to": "eq_runnable",
            "as": "fn"
          },
          {
            "from": "eq_runnable",
            "to": "fn_runnable",
            "as": "otherwise"
          },
          {
            "from": "fn",
            "to": "fn_runnable",
            "as": "value"
          },
          {
            "from": "fn_runnable",
            "to": "eq_fn_runnable",
            "as": "fn"
          },
          {
            "from": "eq_fn_value",
            "to": "eq_fn_runnable",
            "as": "a"
          },
          {
            "from": "cached",
            "to": "eq_fn_runnable",
            "as": "b"
          },
          {
            "from": "eq_fn_runnable",
            "to": "eq_fn",
            "as": "runnable"
          },
          {
            "from": "eq_fn_if",
            "to": "if_eq_fn",
            "as": "pred"
          },
          {
            "from": "eq_fn",
            "to": "eq_fn_return_args",
            "as": "eq_fn"
          },
          {
            "from": "cache_value",
            "to": "cache",
            "as": "value"
          },
          {
            "from": "eq_fn_cache",
            "to": "cache",
            "as": "eq"
          },
          {
            "from": "cache",
            "to": "out",
            "as": "false"
          }
        ]
      },
      "refval": {
        "id": "refval",
        "ref": "extern",
        "value": "extern.refval"
      },
      "state": {
        "id": "state",
        "name": "state",
        "out": "out",
        "category": "data",
        "ref": "extern",
        "value": "extern.state"
      },
      "publish_event": {
        "id": "publish_event",
        "category": "events",
        "description": "Publishes a `name` (or this node's value) event with the data `value`.",
        "out": "out",
        "nodes": [
          {
            "id": "value",
            "ref": "arg",
            "value": "data"
          },
          {
            "id": "arg_name",
            "ref": "arg",
            "value": "name"
          },
          {
            "id": "graph_value",
            "ref": "arg",
            "value": "__graph_value"
          },
          {
            "id": "update_event",
            "ref": "arg",
            "value": "name"
          },
          {
            "id": "update_data",
            "ref": "arg",
            "value": "data"
          },
          {
            "id": "name",
            "ref": "default"
          },
          {
            "id": "update",
            "ref": "script",
            "value": "return _lib.no.runtime.publish(event_name, event_data)"
          },
          {
            "id": "ap_args"
          },
          {
            "id": "update_runnable",
            "ref": "runnable"
          },
          {
            "id": "out",
            "ref": "ap"
          }
        ],
        "edges": [
          {
            "from": "arg_name",
            "to": "name",
            "as": "value"
          },
          {
            "from": "graph_value",
            "to": "name",
            "as": "otherwise"
          },
          {
            "from": "name",
            "to": "update",
            "as": "event_name"
          },
          {
            "from": "value",
            "to": "ap_args",
            "as": "event_data"
          },
          {
            "from": "update_data",
            "to": "update",
            "as": "event_data"
          },
          {
            "from": "update",
            "to": "update_runnable",
            "as": "fn"
          },
          {
            "from": "update_runnable",
            "to": "out",
            "as": "fn"
          },
          {
            "from": "ap_args",
            "to": "out",
            "as": "args"
          }
        ]
      },
      "event_publisher_onchange": {
        "id": "event_publisher_onchange",
        "category": "events",
        "description": "Publishes a `name` (or this node's value) event with the data `value` when `value` changes.",
        "out": "out",
        "nodes": [
          {
            "id": "value",
            "ref": "arg",
            "value": "value"
          },
          {
            "id": "value_out",
            "ref": "arg",
            "value": "value"
          },
          {
            "id": "value_eq_a",
            "ref": "arg",
            "value": "a"
          },
          {
            "id": "value_eq_b",
            "ref": "arg",
            "value": "b"
          },
          {
            "id": "value_eq_fn",
            "ref": "script",
            "value": "return _lib.compare(a, b)"
          },
          {
            "id": "value_eq",
            "ref": "runnable"
          },
          {
            "id": "value_unchanged",
            "ref": "isunchanged"
          },
          {
            "id": "publisher",
            "ref": "event_publisher"
          },
          {
            "id": "out",
            "ref": "if"
          }
        ],
        "edges": [
          {
            "from": "value",
            "to": "value_eq",
            "as": "value"
          },
          {
            "from": "value_eq_a",
            "to": "value_eq_fn",
            "as": "a"
          },
          {
            "from": "value_eq_b",
            "to": "value_eq_fn",
            "as": "b"
          },
          {
            "from": "value_eq_fn",
            "to": "value_eq",
            "as": "fn"
          },
          {
            "from": "value_eq",
            "to": "value_unchanged",
            "as": "fn"
          },
          {
            "from": "value_unchanged",
            "to": "out",
            "as": "pred"
          },
          {
            "from": "publisher",
            "to": "out",
            "as": "false"
          },
          {
            "from": "value_out",
            "to": "out",
            "as": "true"
          }
        ]
      },
      "input_value": {
        "id": "input_value",
        "out": "out",
        "nodes": {
          "out": {
            "id": "out",
            "name": "input_value",
            "ref": "return"
          },
          "cfuymky": {
            "id": "cfuymky",
            "value": '{"a": 1, "b": {"c": 2, "d": 3}}'
          },
          "4d8qcss": {
            "id": "4d8qcss",
            "ref": "html_text"
          },
          "rpys4rr": {
            "id": "rpys4rr",
            "value": "value",
            "ref": "arg"
          },
          "1znvqbi": {
            "id": "1znvqbi",
            "value": "_stored.value",
            "ref": "arg"
          },
          "qwz3ftj": {
            "id": "qwz3ftj",
            "ref": "script",
            "value": "return typeof object !== 'object' || Array.isArray(object) || Object.getPrototypeOf(object) === Object.prototype ? JSON.stringify(object) : Object.getPrototypeOf(object) ? Object.getPrototypeOf(object).constructor.name : `${object}`"
          },
          "5a6pljw": {
            "id": "5a6pljw",
            "value": "pre",
            "ref": "html_element"
          },
          "17pcf8z": {
            "id": "17pcf8z",
            "value": "2"
          },
          "hm2lkjh": {
            "id": "hm2lkjh"
          },
          "9ukj84k": {
            "id": "9ukj84k",
            "ref": "refval"
          },
          "1c4vbjw": {
            "id": "1c4vbjw",
            "ref": "ap"
          },
          "dqau7vz": {
            "id": "dqau7vz",
            "value": "_stored.set",
            "ref": "arg"
          },
          "wo0j48j": {
            "id": "wo0j48j"
          },
          "rg59xbc": {
            "id": "rg59xbc",
            "value": "true"
          },
          "args": {
            "id": "args"
          }
        },
        "edges": {
          "5a6pljw": {
            "from": "5a6pljw",
            "to": "out",
            "as": "display"
          },
          "cfuymky": {
            "from": "cfuymky",
            "to": "args",
            "as": "value"
          },
          "4d8qcss": {
            "from": "4d8qcss",
            "to": "5a6pljw",
            "as": "children"
          },
          "1znvqbi": {
            "from": "1znvqbi",
            "to": "qwz3ftj",
            "as": "object"
          },
          "17pcf8z": {
            "from": "17pcf8z",
            "to": "qwz3ftj",
            "as": "spacer"
          },
          "qwz3ftj": {
            "from": "qwz3ftj",
            "to": "4d8qcss",
            "as": "text"
          },
          "rpys4rr": {
            "from": "rpys4rr",
            "to": "wo0j48j",
            "as": "value"
          },
          "hm2lkjh": {
            "from": "hm2lkjh",
            "to": "out",
            "as": "args"
          },
          "9ukj84k": {
            "from": "9ukj84k",
            "to": "hm2lkjh",
            "as": "_stored"
          },
          "1c4vbjw": {
            "from": "1c4vbjw",
            "to": "out",
            "as": "value"
          },
          "dqau7vz": {
            "from": "dqau7vz",
            "to": "1c4vbjw",
            "as": "fn"
          },
          "wo0j48j": {
            "from": "wo0j48j",
            "to": "1c4vbjw",
            "as": "args"
          },
          "rg59xbc": {
            "from": "rg59xbc",
            "to": "1c4vbjw",
            "as": "run"
          }
        },
        "edges_in": {
          "out": {
            "5a6pljw": {
              "from": "5a6pljw",
              "to": "out",
              "as": "display"
            },
            "hm2lkjh": {
              "from": "hm2lkjh",
              "to": "out",
              "as": "args"
            },
            "1c4vbjw": {
              "from": "1c4vbjw",
              "to": "out",
              "as": "value"
            }
          },
          "args": {
            "cfuymky": {
              "from": "cfuymky",
              "to": "args",
              "as": "value"
            }
          },
          "5a6pljw": {
            "4d8qcss": {
              "from": "4d8qcss",
              "to": "5a6pljw",
              "as": "children"
            }
          },
          "qwz3ftj": {
            "1znvqbi": {
              "from": "1znvqbi",
              "to": "qwz3ftj",
              "as": "object"
            },
            "17pcf8z": {
              "from": "17pcf8z",
              "to": "qwz3ftj",
              "as": "spacer"
            }
          },
          "4d8qcss": {
            "qwz3ftj": {
              "from": "qwz3ftj",
              "to": "4d8qcss",
              "as": "text"
            }
          },
          "wo0j48j": {
            "rpys4rr": {
              "from": "rpys4rr",
              "to": "wo0j48j",
              "as": "value"
            }
          },
          "hm2lkjh": {
            "9ukj84k": {
              "from": "9ukj84k",
              "to": "hm2lkjh",
              "as": "_stored"
            }
          },
          "1c4vbjw": {
            "dqau7vz": {
              "from": "dqau7vz",
              "to": "1c4vbjw",
              "as": "fn"
            },
            "wo0j48j": {
              "from": "wo0j48j",
              "to": "1c4vbjw",
              "as": "args"
            },
            "rg59xbc": {
              "from": "rg59xbc",
              "to": "1c4vbjw",
              "as": "run"
            }
          }
        }
      },
      "event_subscriber": {
        "id": "event_subscriber",
        "category": "events",
        "description": "Returns the last value of the `name` (or this node's value) event.",
        "out": "out",
        "nodes": [
          {
            "id": "name",
            "ref": "arg",
            "value": "name"
          },
          {
            "id": "onevent",
            "ref": "arg",
            "value": "onevent",
            "type": "local"
          },
          {
            "id": "data",
            "ref": "arg",
            "value": "_data: internal",
            "type": "internal"
          },
          {
            "id": "data_listener",
            "ref": "arg",
            "value": "_data: internal"
          },
          {
            "id": "data_log",
            "ref": "log"
          },
          {
            "id": "add_listener",
            "ref": "script",
            "value": "_lib.no.runtime.add_listener(event ?? __graph_value, 'evt-listener-' + _graph.id, (data) => { let update = true; if(onevent){ update = _lib.no.run(onevent.graph, onevent.fn, {...onevent.args, data, prev}); } if(update){ _lib.no.runtime.update_args(_graph, {_data: data.data}) } }, false); return _lib.no.runtime.get_args(_graph)['_data'];"
          },
          {
            "id": "out",
            "ref": "default"
          }
        ],
        "edges": [
          {
            "from": "name",
            "to": "add_listener",
            "as": "event"
          },
          {
            "from": "onevent",
            "to": "add_listener",
            "as": "onevent"
          },
          {
            "from": "data_listener",
            "to": "add_listener",
            "as": "prev"
          },
          {
            "from": "add_listener",
            "to": "out",
            "as": "otherwise"
          },
          {
            "from": "data",
            "to": "out",
            "as": "value"
          }
        ]
      },
      "events_broadcast_channel": {
        "id": "events_broadcast_channel",
        "category": "events",
        "description": "Runs `runnable` when a message is received from the events <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel'>broadcast channel</a>. Can be used to communicate between tabs or worker processes.",
        "out": "out",
        "nodes": [
          {
            "id": "arg_onmessage",
            "ref": "arg",
            "value": "onmessage"
          },
          {
            "id": "message_data",
            "ref": "arg",
            "value": "message.data.data"
          },
          {
            "id": "message_name",
            "ref": "arg",
            "value": "message.data.name"
          },
          {
            "id": "publish_event",
            "ref": "event_publisher"
          },
          {
            "id": "publish_event_runnable",
            "ref": "runnable"
          },
          {
            "id": "onmessageseq",
            "ref": "sequence"
          },
          {
            "id": "setup_bc",
            "ref": "script",
            "value": "const bc = new BroadcastChannel('events'); bc.onmessage = e => { _lib.no.run(onmessage.graph, onmessage.fn, {message: e}, _lib); }; return bc;"
          },
          {
            "id": "out",
            "ref": "return",
            "name": "events_broadcast_channel"
          }
        ],
        "edges": [
          {
            "from": "message_data",
            "to": "publish_event",
            "as": "value"
          },
          {
            "from": "message_name",
            "to": "publish_event",
            "as": "name"
          },
          {
            "from": "publish_event",
            "to": "publish_event_runnable",
            "as": "fn"
          },
          {
            "from": "publish_event_runnable",
            "to": "onmessageseq",
            "as": "arg0"
          },
          {
            "from": "arg_onmessage",
            "to": "onmessageseq",
            "as": "arg1"
          },
          {
            "from": "onmessageseq",
            "to": "setup_bc",
            "as": "onmessage"
          },
          {
            "from": "setup_bc",
            "to": "out",
            "as": "value"
          }
        ]
      },
      "reduce": {
        "id": "reduce",
        "category": "data",
        "description": "<a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce'>Aray.reduce</a> the `array` with `fn`. Arguments for `fn` are `previous`, `current`, `index`, `array`, and a unique per nested loop `key`.",
        "name": "reduce",
        "in": "m3b5wg3",
        "out": "tgurdpo",
        "nodes": [
          {
            "id": "tgurdpo",
            "ref": "call",
            "name": "out"
          },
          {
            "id": "key",
            "ref": "arg",
            "value": "key"
          },
          {
            "id": "rielyq8",
            "value": "reduce",
            "name": "rielyq8"
          },
          {
            "ref": "arg",
            "id": "1rre4bx",
            "value": "array",
            "name": "1rre4bx"
          },
          {
            "ref": "arg",
            "id": "6g75abk",
            "value": "fn",
            "name": "6g75abk"
          },
          {
            "id": "w0zzawl",
            "ref": "array",
            "name": "w0zzawl"
          },
          {
            "id": "args",
            "ref": "arg",
            "value": "args",
            "type": "local"
          },
          {
            "id": "initial",
            "ref": "arg",
            "value": "initial"
          },
          {
            "id": "pdljod1",
            "name": "pdljod1",
            "ref": "script",
            "value": "return (previous, current, index, array) => _lib.no.run(fn?.graph ?? _graph, fn?.fn ?? fn, Object.assign({}, args ?? {}, fn.args ?? {}, {previous, current, index, array, key: outer_key ? `${index}_${outer_key}` : `${index}`}), _lib);"
          },
          {
            "id": "2lvs5dj",
            "ref": "script",
            "value": "return _graph",
            "name": "2lvs5dj"
          }
        ],
        "edges": [
          {
            "from": "rielyq8",
            "to": "tgurdpo",
            "as": "fn"
          },
          {
            "from": "1rre4bx",
            "to": "tgurdpo",
            "as": "self"
          },
          {
            "from": "w0zzawl",
            "to": "tgurdpo",
            "as": "args",
            "type": "resolve"
          },
          {
            "from": "pdljod1",
            "to": "w0zzawl",
            "as": "a0"
          },
          {
            "from": "initial",
            "to": "w0zzawl",
            "as": "a1"
          },
          {
            "from": "2lvs5dj",
            "to": "pdljod1",
            "as": "graph"
          },
          {
            "from": "key",
            "to": "pdljod1",
            "as": "outer_key"
          },
          {
            "from": "args",
            "to": "pdljod1",
            "as": "args"
          },
          {
            "from": "6g75abk",
            "to": "pdljod1",
            "as": "fn"
          }
        ]
      },
      "map": {
        "id": "map",
        "out": "out",
        "category": "data",
        "ref": "extern",
        "value": "extern.map",
        "description": "<a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map'>Aray.map</a> the `array` with `fn`. Arguments for `fn` are `element`, `index`, `array`, and a unique per nested loop `key`."
      },
      "filter": {
        "id": "filter",
        "category": "data",
        "description": "<a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter'>Aray.filter</a> the `array` with `fn`. Arguments for `fn` are `element`, `index`, `array`, and a unique per nested loop `key`.",
        "out": "out",
        "nodes": [
          {
            "id": "object",
            "ref": "arg",
            "value": "array"
          },
          {
            "id": "pred_fn",
            "ref": "arg",
            "value": "fn"
          },
          {
            "id": "el_currentValue",
            "ref": "arg",
            "value": "currentValue"
          },
          {
            "id": "pred_fn_args"
          },
          {
            "id": "run_pred",
            "value": "true"
          },
          {
            "id": "pred_element_fn",
            "ref": "extern",
            "value": "extern.ap"
          },
          {
            "id": "currentValue",
            "ref": "arg",
            "value": "currentValue"
          },
          {
            "id": "previousValue",
            "ref": "arg",
            "value": "previousValue"
          },
          {
            "id": "pred_append",
            "ref": "script",
            "value": "if(pred !== false && pred !== undefined && pred !== null){ arr.push(value); } return arr;"
          },
          {
            "id": "pred_append_fn_args",
            "value": '{"previousValue": "undefined", "currentValue": "undefined"}'
          },
          {
            "id": "pred_append_fn",
            "ref": "runnable"
          },
          {
            "id": "initial",
            "value": "[]"
          },
          {
            "id": "fold",
            "ref": "extern",
            "value": "extern.fold"
          },
          {
            "id": "out",
            "ref": "return"
          }
        ],
        "edges": [
          {
            "from": "el_currentValue",
            "to": "pred_fn_args",
            "as": "element"
          },
          {
            "from": "pred_fn_args",
            "to": "pred_element_fn",
            "as": "args"
          },
          {
            "from": "pred_fn",
            "to": "pred_element_fn",
            "as": "fn"
          },
          {
            "from": "run_pred",
            "to": "pred_element_fn",
            "as": "run"
          },
          {
            "from": "currentValue",
            "to": "pred_append",
            "as": "value"
          },
          {
            "from": "previousValue",
            "to": "pred_append",
            "as": "arr"
          },
          {
            "from": "pred_element_fn",
            "to": "pred_append",
            "as": "pred"
          },
          {
            "from": "pred_append",
            "to": "pred_append_fn",
            "as": "fn"
          },
          {
            "from": "pred_append_fn_args",
            "to": "pred_append_fn",
            "as": "parameters"
          },
          {
            "from": "pred_append_fn",
            "to": "fold",
            "as": "fn"
          },
          {
            "from": "object",
            "to": "fold",
            "as": "object"
          },
          {
            "from": "initial",
            "to": "fold",
            "as": "initial"
          },
          {
            "from": "fold",
            "to": "out",
            "as": "value"
          }
        ]
      },
      "sequence": {
        "id": "sequence",
        "description": "Create a new runnable that runs the input runnables in sequence.",
        "name": "sequence",
        "category": "flow",
        "__out": "out",
        "_ref": "extern",
        "_value": "extern.sequence",
        "nodes": [
          {
            "id": "args",
            "ref": "arg",
            "value": "_args"
          },
          {
            "id": "fn",
            "ref": "script",
            "value": "console.log(args); return Object.values(args)"
          },
          {
            "id": "out",
            "ref": "ap"
          }
        ],
        "edges": [
          {
            "from": "args",
            "to": "fn",
            "as": "args"
          },
          {
            "from": "fn",
            "to": "out",
            "as": "fn"
          }
        ],
        "_nodes": [
          {
            "id": "args",
            "ref": "arg",
            "value": "__args"
          },
          {
            "id": "runnables",
            "ref": "arg",
            "value": "runnables"
          },
          {
            "id": "seq_ap_args",
            "ref": "arg",
            "value": "_args"
          },
          {
            "id": "seq_ap_par_args",
            "ref": "arg",
            "value": "__args.__args"
          },
          {
            "id": "delete_seq_ap_args",
            "ref": "script",
            "value": "const newargs = {...args, runnables, _seq_keys: Object.keys(args)}; return newargs"
          },
          {
            "id": "new_seq_ap_args",
            "ref": "script",
            "value": "return args"
          },
          {
            "id": "delete_args",
            "ref": "script",
            "value": "const ret = {...target}; delete ret.args; return ret;"
          },
          {
            "id": "seq_fold_currentValue",
            "ref": "arg",
            "value": "currentValue.1"
          },
          {
            "id": "seq_ap_run",
            "value": "true"
          },
          {
            "id": "seq_ap",
            "ref": "ap"
          },
          {
            "id": "seq_ap_runnable",
            "ref": "runnable"
          },
          {
            "id": "seq_fold",
            "ref": "fold"
          },
          {
            "id": "out_runnable",
            "ref": "runnable"
          },
          {
            "id": "out",
            "ref": "ap"
          }
        ],
        "_edges": [
          {
            "from": "args",
            "to": "delete_args",
            "as": "target"
          },
          {
            "from": "args",
            "to": "_seq_fold",
            "as": "object"
          },
          {
            "from": "seq_ap_args",
            "to": "new_seq_ap_args",
            "as": "args"
          },
          {
            "from": "delete_args",
            "to": "_seq_fold",
            "as": "object"
          },
          {
            "from": "runnables",
            "to": "seq_fold",
            "as": "object"
          },
          {
            "from": "seq_ap_run",
            "to": "seq_ap",
            "as": "run"
          },
          {
            "from": "seq_fold_currentValue",
            "to": "seq_ap",
            "as": "fn"
          },
          {
            "from": "seq_ap",
            "to": "seq_ap_runnable",
            "as": "fn"
          },
          {
            "from": "delete_args",
            "to": "delete_seq_ap_args",
            "as": "target"
          },
          {
            "from": "seq_ap_args",
            "to": "delete_seq_ap_args",
            "as": "args"
          },
          {
            "from": "seq_ap_par_args",
            "to": "delete_seq_ap_args",
            "as": "parargs"
          },
          {
            "from": "new_seq_ap_args",
            "to": "_seq_ap",
            "as": "args"
          },
          {
            "from": "seq_ap_runnable",
            "to": "seq_fold",
            "as": "fn"
          },
          {
            "from": "seq_fold",
            "to": "out_runnable",
            "as": "fn"
          },
          {
            "from": "delete_seq_ap_args",
            "to": "out",
            "as": "args"
          },
          {
            "from": "runnables",
            "to": "delete_seq_ap_args",
            "as": "runnables"
          },
          {
            "from": "out_runnable",
            "to": "out",
            "as": "fn"
          }
        ]
      },
      "import_json": {
        "id": "import_json",
        "description": "Imports the node or nodes found at the `url`.",
        "name": "import_json",
        "category": "nodysseus",
        "out": "out",
        "nodes": [
          {
            "id": "lapeojg",
            "ref": "script",
            "value": "import_graph.forEach(_lib.no.runtime.add_ref); _lib.no.runtime.change_graph(_lib.no.runtime.get_graph(graphid))",
            "name": "out"
          },
          {
            "id": "out",
            "ref": "return"
          },
          {
            "id": "3zfjt1h",
            "ref": "call"
          },
          {
            "id": "05eag47",
            "ref": "arg",
            "value": "name"
          },
          {
            "id": "graphid",
            "ref": "arg",
            "value": "__graphid"
          },
          {
            "id": "2vtokcl",
            "ref": "script",
            "value": "return fetch(url);"
          },
          {
            "id": "i9x02is",
            "value": "json"
          },
          {
            "id": "irr99xz",
            "ref": "arg",
            "value": "url"
          }
        ],
        "edges": [
          {
            "as": "import_graph",
            "from": "3zfjt1h",
            "to": "lapeojg"
          },
          {
            "from": "graphid",
            "to": "lapeojg",
            "as": "graphid"
          },
          {
            "from": "05eag47",
            "to": "lapeojg",
            "as": "name"
          },
          {
            "from": "lapeojg",
            "to": "out",
            "as": "value"
          },
          {
            "as": "self",
            "from": "2vtokcl",
            "to": "3zfjt1h"
          },
          {
            "from": "i9x02is",
            "to": "3zfjt1h",
            "as": "fn"
          },
          {
            "from": "irr99xz",
            "to": "2vtokcl",
            "as": "url"
          }
        ]
      },
      "object_entries": {
        "id": "object_entries",
        "category": "data",
        "description": "Calls <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries'>Object.entries</a> on `object`.",
        "name": "object_entries",
        "in": "tkd4tqn",
        "out": "j8c79uf",
        "nodes": [
          {
            "name": "out",
            "id": "j8c79uf",
            "ref": "filter"
          },
          {
            "id": "hfexsuu",
            "ref": "script",
            "value": "return !key?.startsWith('_');"
          },
          {
            "id": "runnable_args",
            "value": '{"element": "undefined"}'
          },
          {
            "id": "runnable",
            "ref": "runnable"
          },
          {
            "id": "bgi2g37",
            "ref": "script",
            "value": "return obj instanceof Map ? [...obj.entries()] : Object.entries(obj)"
          },
          {
            "id": "7gqcw0o",
            "ref": "arg",
            "value": "0.0"
          },
          {
            "id": "kpakw50",
            "ref": "arg",
            "value": "object"
          }
        ],
        "edges": [
          {
            "from": "runnable_args",
            "to": "runnable",
            "as": "parameters"
          },
          {
            "from": "hfexsuu",
            "to": "runnable",
            "as": "fn"
          },
          {
            "from": "runnable",
            "to": "j8c79uf",
            "as": "fn"
          },
          {
            "from": "bgi2g37",
            "to": "j8c79uf",
            "as": "array"
          },
          {
            "from": "7gqcw0o",
            "to": "hfexsuu",
            "as": "key"
          },
          {
            "from": "kpakw50",
            "to": "bgi2g37",
            "as": "obj"
          }
        ]
      },
      "css_styles": {
        "id": "css_styles",
        "category": "html",
        "description": "Creates a style element from `css_object`. Inputs to the object should be labeled with css selectors, and inputs to those objects with css properties.",
        "name": "css_styles",
        "in": "xw3pmx7",
        "out": "out",
        "nodes": [
          {
            "id": "out",
            "ref": "return",
            "name": "css_styles"
          },
          {
            "id": "5yxmxua",
            "ref": "html_element",
            "name": "out"
          },
          {
            "id": "vgv61zj",
            "ref": "html_text"
          },
          {
            "id": "jstjx7g"
          },
          {
            "id": "h40e3j9",
            "value": "style"
          },
          {
            "id": "xw3pmx7",
            "name": "in"
          },
          {
            "id": "jlgp7uy",
            "ref": "call",
            "name": "named_obj/out"
          },
          {
            "id": "o1j78dd",
            "value": "result-view"
          },
          {
            "id": "ij4z84e",
            "ref": "map"
          },
          {
            "id": "q3pwj9j",
            "value": "join"
          },
          {
            "id": "d6h3gdw",
            "ref": "array"
          },
          {
            "id": "j8c79uf",
            "name": "object_entries",
            "ref": "object_entries"
          },
          {
            "id": "n9g4wyq",
            "ref": "runnable"
          },
          {
            "id": "z63iaay",
            "ref": "script",
            "value": 'return "\\n";'
          },
          {
            "id": "vwsgweb",
            "ref": "default"
          },
          {
            "id": "aelf1a7",
            "ref": "script",
            "value": "return key + '{' + value + '}'",
            "name": "out"
          },
          {
            "id": "mkwx4yx"
          },
          {
            "id": "fzr4mkv",
            "ref": "arg",
            "value": "css_object"
          },
          {
            "id": "5eqf77t",
            "value": "element.0",
            "ref": "arg"
          },
          {
            "id": "5pwetw5",
            "ref": "if"
          },
          {
            "id": "o5ojdyc",
            "ref": "script",
            "value": 'return key.startsWith("@keyframes")'
          },
          {
            "id": "1hpnid4",
            "ref": "call"
          },
          {
            "id": "slj7ynn/jlgp7uy",
            "ref": "call",
            "name": "named_obj/out"
          },
          {
            "id": "ft1oksl",
            "ref": "arg",
            "value": "element.0"
          },
          {
            "id": "bbbp82v",
            "ref": "map"
          },
          {
            "id": "cp66ig5",
            "value": "join"
          },
          {
            "id": "uwq9u81",
            "ref": "array"
          },
          {
            "id": "slj7ynn/ij4z84e",
            "ref": "map"
          },
          {
            "id": "slj7ynn/q3pwj9j",
            "value": "join"
          },
          {
            "id": "slj7ynn/d6h3gdw",
            "ref": "array"
          },
          {
            "id": "i1ifamx",
            "ref": "object_entries"
          },
          {
            "id": "druspar_args",
            "value": '{"element": ""}'
          },
          {
            "id": "n9g4wyq_args",
            "value": '{"element": ""}'
          },
          {
            "id": "slj7ynn/n9g4wyq_args",
            "value": '{"element": ""}'
          },
          {
            "id": "slj7ynn/druspar_args",
            "value": '{"element": ""}'
          },
          {
            "id": "druspar",
            "ref": "runnable"
          },
          {
            "id": "gth1wc2",
            "ref": "script",
            "value": 'return "\\n";'
          },
          {
            "id": "slj7ynn/j8c79uf",
            "name": "object_entries",
            "ref": "object_entries"
          },
          {
            "id": "slj7ynn/n9g4wyq",
            "ref": "runnable"
          },
          {
            "id": "slj7ynn/z63iaay",
            "ref": "script",
            "value": 'return "\\n";'
          },
          {
            "id": "y25dg2n",
            "value": "element.1",
            "ref": "arg"
          },
          {
            "id": "0d4yh8u",
            "ref": "script",
            "value": `return key + ': ' + value + ";";`
          },
          {
            "id": "slj7ynn/vwsgweb",
            "ref": "default"
          },
          {
            "id": "slj7ynn/aelf1a7",
            "ref": "script",
            "value": "return key + '{' + value + '}'",
            "name": "out"
          },
          {
            "id": "h13a9fd",
            "ref": "arg",
            "value": "element.0"
          },
          {
            "id": "h7me3v8",
            "ref": "arg",
            "value": "element.1"
          },
          {
            "id": "slj7ynn/mkwx4yx"
          },
          {
            "id": "slj7ynn/fzr4mkv",
            "ref": "arg",
            "value": "element.1"
          },
          {
            "id": "slj7ynn/5eqf77t",
            "value": "element.0",
            "ref": "arg"
          },
          {
            "id": "slj7ynn/1hpnid4",
            "ref": "call"
          },
          {
            "id": "slj7ynn/bbbp82v",
            "ref": "map"
          },
          {
            "id": "slj7ynn/cp66ig5",
            "value": "join"
          },
          {
            "id": "slj7ynn/uwq9u81",
            "ref": "array"
          },
          {
            "id": "slj7ynn/i1ifamx",
            "ref": "object_entries"
          },
          {
            "id": "slj7ynn/druspar",
            "ref": "runnable"
          },
          {
            "id": "slj7ynn/gth1wc2",
            "ref": "script",
            "value": 'return "\\n";'
          },
          {
            "id": "slj7ynn/y25dg2n",
            "value": "element.1",
            "ref": "arg"
          },
          {
            "id": "slj7ynn/0d4yh8u",
            "ref": "script",
            "value": `return key + ': ' + value + ";";`
          },
          {
            "id": "slj7ynn/h13a9fd",
            "ref": "arg",
            "value": "element.0"
          },
          {
            "id": "slj7ynn/h7me3v8",
            "ref": "arg",
            "value": "element.1"
          }
        ],
        "edges": [
          {
            "from": "5yxmxua",
            "to": "out",
            "as": "value"
          },
          {
            "from": "vgv61zj",
            "to": "5yxmxua",
            "as": "children"
          },
          {
            "from": "jstjx7g",
            "to": "5yxmxua",
            "as": "props"
          },
          {
            "from": "h40e3j9",
            "to": "5yxmxua",
            "as": "dom_type"
          },
          {
            "from": "xw3pmx7",
            "to": "5yxmxua",
            "as": "arg3"
          },
          {
            "from": "jlgp7uy",
            "to": "vgv61zj",
            "as": "text"
          },
          {
            "from": "o1j78dd",
            "to": "jstjx7g",
            "as": "key"
          },
          {
            "from": "ij4z84e",
            "to": "jlgp7uy",
            "as": "self"
          },
          {
            "from": "q3pwj9j",
            "to": "jlgp7uy",
            "as": "fn"
          },
          {
            "from": "d6h3gdw",
            "to": "jlgp7uy",
            "as": "args"
          },
          {
            "from": "j8c79uf",
            "to": "ij4z84e",
            "as": "array"
          },
          {
            "as": "fn",
            "from": "n9g4wyq",
            "to": "ij4z84e"
          },
          {
            "from": "z63iaay",
            "to": "d6h3gdw",
            "as": "arg0"
          },
          {
            "from": "vwsgweb",
            "to": "j8c79uf",
            "as": "object"
          },
          {
            "as": "fn",
            "from": "aelf1a7",
            "to": "n9g4wyq"
          },
          {
            "from": "mkwx4yx",
            "to": "vwsgweb",
            "as": "otherwise"
          },
          {
            "from": "fzr4mkv",
            "to": "vwsgweb",
            "as": "value"
          },
          {
            "from": "5eqf77t",
            "to": "aelf1a7",
            "as": "key"
          },
          {
            "from": "5pwetw5",
            "to": "aelf1a7",
            "as": "value"
          },
          {
            "from": "o5ojdyc",
            "to": "5pwetw5",
            "as": "pred"
          },
          {
            "as": "false",
            "from": "1hpnid4",
            "to": "5pwetw5"
          },
          {
            "from": "slj7ynn/jlgp7uy",
            "to": "5pwetw5",
            "as": "true"
          },
          {
            "as": "key",
            "from": "ft1oksl",
            "to": "o5ojdyc"
          },
          {
            "from": "bbbp82v",
            "to": "1hpnid4",
            "as": "self"
          },
          {
            "from": "cp66ig5",
            "to": "1hpnid4",
            "as": "fn"
          },
          {
            "from": "uwq9u81",
            "to": "1hpnid4",
            "as": "args"
          },
          {
            "from": "slj7ynn/ij4z84e",
            "to": "slj7ynn/jlgp7uy",
            "as": "self"
          },
          {
            "from": "slj7ynn/q3pwj9j",
            "to": "slj7ynn/jlgp7uy",
            "as": "fn"
          },
          {
            "from": "slj7ynn/d6h3gdw",
            "to": "slj7ynn/jlgp7uy",
            "as": "args"
          },
          {
            "from": "i1ifamx",
            "to": "bbbp82v",
            "as": "array"
          },
          {
            "from": "slj7ynn/druspar_args",
            "as": "parameters",
            "to": "slj7ynn/druspar"
          },
          {
            "from": "slj7ynn/n9g4wyq_args",
            "as": "parameters",
            "to": "slj7ynn/n9g4wyq"
          },
          {
            "from": "n9g4wyq_args",
            "as": "parameters",
            "to": "n9g4wyq"
          },
          {
            "from": "druspar_args",
            "as": "parameters",
            "to": "druspar"
          },
          {
            "as": "fn",
            "from": "druspar",
            "to": "bbbp82v"
          },
          {
            "from": "gth1wc2",
            "to": "uwq9u81",
            "as": "arg0"
          },
          {
            "from": "slj7ynn/j8c79uf",
            "to": "slj7ynn/ij4z84e",
            "as": "array"
          },
          {
            "as": "fn",
            "from": "slj7ynn/n9g4wyq",
            "to": "slj7ynn/ij4z84e"
          },
          {
            "from": "slj7ynn/z63iaay",
            "to": "slj7ynn/d6h3gdw",
            "as": "arg0"
          },
          {
            "from": "y25dg2n",
            "to": "i1ifamx",
            "as": "object"
          },
          {
            "as": "fn",
            "from": "0d4yh8u",
            "to": "druspar"
          },
          {
            "from": "slj7ynn/vwsgweb",
            "to": "slj7ynn/j8c79uf",
            "as": "object"
          },
          {
            "as": "fn",
            "from": "slj7ynn/aelf1a7",
            "to": "slj7ynn/n9g4wyq"
          },
          {
            "from": "h13a9fd",
            "to": "0d4yh8u",
            "as": "key"
          },
          {
            "from": "h7me3v8",
            "to": "0d4yh8u",
            "as": "value"
          },
          {
            "from": "slj7ynn/mkwx4yx",
            "to": "slj7ynn/vwsgweb",
            "as": "otherwise"
          },
          {
            "from": "slj7ynn/fzr4mkv",
            "to": "slj7ynn/vwsgweb",
            "as": "value"
          },
          {
            "from": "slj7ynn/5eqf77t",
            "to": "slj7ynn/aelf1a7",
            "as": "key"
          },
          {
            "as": "value",
            "from": "slj7ynn/1hpnid4",
            "to": "slj7ynn/aelf1a7"
          },
          {
            "from": "slj7ynn/bbbp82v",
            "to": "slj7ynn/1hpnid4",
            "as": "self"
          },
          {
            "from": "slj7ynn/cp66ig5",
            "to": "slj7ynn/1hpnid4",
            "as": "fn"
          },
          {
            "from": "slj7ynn/uwq9u81",
            "to": "slj7ynn/1hpnid4",
            "as": "args"
          },
          {
            "from": "slj7ynn/i1ifamx",
            "to": "slj7ynn/bbbp82v",
            "as": "array"
          },
          {
            "as": "fn",
            "from": "slj7ynn/druspar",
            "to": "slj7ynn/bbbp82v"
          },
          {
            "from": "slj7ynn/gth1wc2",
            "to": "slj7ynn/uwq9u81",
            "as": "arg0"
          },
          {
            "from": "slj7ynn/y25dg2n",
            "to": "slj7ynn/i1ifamx",
            "as": "object"
          },
          {
            "as": "fn",
            "from": "slj7ynn/0d4yh8u",
            "to": "slj7ynn/druspar"
          },
          {
            "from": "slj7ynn/h13a9fd",
            "to": "slj7ynn/0d4yh8u",
            "as": "key"
          },
          {
            "from": "slj7ynn/h7me3v8",
            "to": "slj7ynn/0d4yh8u",
            "as": "value"
          }
        ]
      },
      "css_anim": {
        "id": "css_anim",
        "category": "html",
        "description": "Creates a css animation string. For use with `css_styles`.",
        "name": "css_anim",
        "in": "cawqofn",
        "out": "spy9h48",
        "nodes": [
          {
            "name": "out",
            "id": "spy9h48",
            "ref": "script",
            "value": 'return Object.fromEntries((Array.isArray(arr[0]) ? arr[0] : arr).map((v, i, a) => [Math.floor((i / a.length)*100) + "%", v]))'
          },
          {
            "id": "cawqofn",
            "ref": "array",
            "name": "in"
          }
        ],
        "edges": [
          {
            "as": "arr",
            "from": "cawqofn",
            "to": "spy9h48",
            "type": "resolve"
          }
        ]
      },
      "input": {
        "category": "html",
        "edges": [
          {
            "from": "gvkhkfw",
            "to": "nn4twx9",
            "as": "children"
          },
          {
            "from": "7rhq0q5",
            "to": "nn4twx9",
            "as": "_"
          },
          {
            "from": "4972gx3",
            "to": "gvkhkfw",
            "as": "arg1"
          },
          {
            "from": "1ldhfah",
            "to": "gvkhkfw",
            "as": "arg0"
          },
          {
            "from": "ee5i5r2",
            "to": "4972gx3",
            "as": "dom_type"
          },
          {
            "from": "ro8n2gc",
            "to": "4972gx3",
            "as": "props"
          },
          {
            "from": "wet0jdv",
            "to": "1ldhfah",
            "as": "children"
          },
          {
            "from": "gcuxiw9",
            "to": "1ldhfah",
            "as": "props"
          },
          {
            "from": "875c1wk",
            "to": "1ldhfah",
            "as": "dom_type"
          },
          {
            "from": "t6q6rvf",
            "to": "ro8n2gc",
            "as": "arg0"
          },
          {
            "from": "rjwtb3c",
            "to": "ro8n2gc",
            "as": "props"
          },
          {
            "from": "utkc9o6",
            "to": "wet0jdv",
            "as": "arg0"
          },
          {
            "from": "jxl9r29",
            "to": "gcuxiw9",
            "as": "for"
          },
          {
            "from": "2zxw9oo",
            "to": "t6q6rvf",
            "as": "onkeydown"
          },
          {
            "from": "i7y9dyy",
            "to": "t6q6rvf",
            "as": "onchange"
          },
          {
            "from": "vks4vul",
            "to": "rjwtb3c",
            "as": "value"
          },
          {
            "from": "ddfgy2s",
            "to": "rjwtb3c",
            "as": "otherwise"
          },
          {
            "from": "trd8ptp",
            "to": "utkc9o6",
            "as": "text"
          },
          {
            "from": "zfrrk0z",
            "to": "jxl9r29",
            "as": "value"
          },
          {
            "to": "2zxw9oo",
            "from": "qseh2tb",
            "as": "fn",
            "type": "ref"
          },
          {
            "from": "b0j8nyq",
            "to": "i7y9dyy",
            "as": "dispatch"
          },
          {
            "from": "eotod0l",
            "to": "i7y9dyy",
            "as": "seq"
          },
          {
            "from": "qxwvdfe",
            "to": "i7y9dyy",
            "as": "value"
          },
          {
            "from": "0dnqo5l",
            "to": "i7y9dyy",
            "as": "onchange_fn"
          },
          {
            "from": "1wps21n",
            "to": "qseh2tb",
            "as": "a1"
          },
          {
            "from": "y5q7mbn",
            "to": "qseh2tb",
            "as": "a0"
          },
          {
            "from": "qjc0zt6",
            "to": "eotod0l",
            "as": "arg"
          },
          {
            "from": "widk6u6",
            "to": "qjc0zt6",
            "as": "fn"
          },
          {
            "from": "506ntvb",
            "to": "qjc0zt6",
            "as": "value"
          },
          {
            "from": "4ck1vaf",
            "to": "widk6u6",
            "as": "fn"
          }
        ],
        "nodes": [
          {
            "id": "nn4twx9",
            "ref": "html_element",
            "inputs": [
              {
                "from": "bw4iez5/gvkhkfw",
                "to": "bw4iez5/nn4twx9",
                "as": "children"
              },
              {
                "from": "bw4iez5/7rhq0q5",
                "to": "bw4iez5/nn4twx9",
                "as": "props"
              }
            ],
            "name": "out"
          },
          {
            "id": "gvkhkfw",
            "ref": "array"
          },
          {
            "id": "7rhq0q5",
            "name": "in"
          },
          {
            "id": "1ldhfah",
            "ref": "html_element",
            "name": "label"
          },
          {
            "id": "4972gx3",
            "ref": "html_element"
          },
          {
            "id": "wet0jdv",
            "ref": "array"
          },
          {
            "id": "gcuxiw9"
          },
          {
            "id": "875c1wk",
            "value": "label"
          },
          {
            "id": "ee5i5r2",
            "value": "input"
          },
          {
            "id": "ro8n2gc",
            "ref": "merge_objects"
          },
          {
            "id": "n1qcxu2",
            "value": "true"
          },
          {
            "id": "utkc9o6",
            "ref": "html_text"
          },
          {
            "id": "jxl9r29",
            "ref": "script",
            "value": 'return "input-" + name;'
          },
          {
            "id": "t6q6rvf"
          },
          {
            "id": "rjwtb3c",
            "ref": "default"
          },
          {
            "id": "varubwp"
          },
          {
            "id": "trd8ptp",
            "ref": "arg",
            "value": "name"
          },
          {
            "id": "zfrrk0z",
            "ref": "arg",
            "value": "name"
          },
          {
            "id": "2zxw9oo",
            "ref": "run",
            "name": "stop_propagation"
          },
          {
            "id": "sjw3rie",
            "ref": "default"
          },
          {
            "id": "vks4vul",
            "ref": "arg",
            "value": "props"
          },
          {
            "id": "ddfgy2s"
          },
          {
            "id": "671rzr9",
            "ref": "arg",
            "value": "name"
          },
          {
            "id": "ccir2fl",
            "ref": "arg",
            "value": "name"
          },
          {
            "id": "qseh2tb",
            "ref": "array"
          },
          {
            "id": "i7y9dyy",
            "ref": "runnable"
          },
          {
            "id": "fihihz0",
            "ref": "arg",
            "value": "oninput"
          },
          {
            "id": "1wps21n",
            "name": "stop propagation effect",
            "out": "hj2cig0",
            "nodes": [
              {
                "id": "hj2cig0",
                "ref": "array",
                "name": "stop propagation effect"
              },
              {
                "id": "1pvaim9",
                "ref": "run"
              },
              {
                "id": "0o86xp3",
                "ref": "arg",
                "value": "1"
              },
              {
                "id": "d60jwms",
                "ref": "script",
                "value": "payload.stopPropagation();"
              },
              {
                "id": "xgbubrq",
                "ref": "arg",
                "value": "1"
              }
            ],
            "edges": [
              {
                "from": "1pvaim9",
                "to": "hj2cig0",
                "as": "a0"
              },
              {
                "from": "0o86xp3",
                "to": "hj2cig0",
                "as": "a1"
              },
              {
                "from": "d60jwms",
                "to": "1pvaim9",
                "as": "fn",
                "type": "ref"
              },
              {
                "from": "xgbubrq",
                "to": "d60jwms",
                "as": "payload"
              }
            ]
          },
          {
            "id": "y5q7mbn",
            "ref": "arg",
            "value": "0"
          },
          {
            "id": "y9bkhqc"
          },
          {
            "id": "6m6m1hq_1/ocuonub/qjc0zt6",
            "ref": "event_publisher"
          },
          {
            "id": "nb2sswc",
            "ref": "arg",
            "value": "name"
          },
          {
            "id": "6m6m1hq_1/ocuonub/506ntvb",
            "value": "event.target.value",
            "ref": "arg"
          },
          {
            "id": "6m6m1hq_1/ocuonub/4ck1vaf",
            "ref": "arg",
            "value": "name"
          }
        ],
        "out": "nn4twx9",
        "in": "7rhq0q5",
        "name": "input",
        "id": "input"
      },
      "html_text": {
        "id": "html_text",
        "category": "html",
        "description": "Some HTML plaintext of `text` (or this node's value). Usually used as a child of html_element.",
        "out": "out",
        "nodes": [
          {
            "id": "arg_text",
            "ref": "arg",
            "value": "text"
          },
          {
            "id": "value_text",
            "ref": "arg",
            "value": "__graph_value"
          },
          {
            "id": "text",
            "ref": "default"
          },
          {
            "id": "text_value",
            "value": "text_value"
          },
          {
            "id": "out"
          }
        ],
        "edges": [
          {
            "from": "text_value",
            "to": "out",
            "as": "dom_type"
          },
          {
            "from": "arg_text",
            "to": "text",
            "as": "value"
          },
          {
            "from": "value_text",
            "to": "text",
            "as": "otherwise"
          },
          {
            "from": "text",
            "to": "out",
            "as": "text"
          }
        ]
      },
      "html_element": {
        "id": "html_element",
        "category": "html",
        "out": "out_ret",
        "description": "An HTML Element. `children` is an array of html_element or html_text, `props` are the attributes for the html element as an object, `dom_type` (or this node's value) is the dom type, `memo` refers to <a target='_blank' href='https://github.com/jorgebucaran/hyperapp/blob/main/docs/api/memo.md'>hyperapp's memo</a>.",
        "nodes": [
          {
            "id": "children",
            "ref": "arg",
            "value": "children"
          },
          {
            "id": "props",
            "ref": "arg",
            "value": "props"
          },
          {
            "id": "dom_type",
            "ref": "arg",
            "value": "dom_type"
          },
          {
            "id": "memo",
            "ref": "arg",
            "value": "memo"
          },
          {
            "id": "value",
            "ref": "arg",
            "value": "value"
          },
          {
            "id": "element_dt",
            "ref": "arg",
            "value": "element.dom_type"
          },
          {
            "id": "element",
            "ref": "arg",
            "value": "element"
          },
          {
            "id": "element_tv",
            "ref": "arg",
            "value": "element.text_value"
          },
          {
            "id": "div",
            "value": "div"
          },
          {
            "id": "dom_type_value",
            "ref": "default"
          },
          {
            "id": "graph_value",
            "ref": "arg",
            "value": "__graph_value"
          },
          {
            "id": "filter_children_fn",
            "ref": "script",
            "value": "return !!(element_dt || element_tv)"
          },
          {
            "id": "filter_children_fn_runnable_args",
            "value": '{"element": "undefined"}'
          },
          {
            "id": "filter_children_fn_runnable",
            "ref": "runnable"
          },
          {
            "id": "fill_children_fn",
            "ref": "script",
            "value": "return element?.el ?? typeof element === 'string' ? {dom_type: 'text_value', text: element} : element"
          },
          {
            "id": "fill_children_fn_runnable_args",
            "value": '{"element": "undefined"}'
          },
          {
            "id": "fill_children_fn_runnable",
            "ref": "runnable"
          },
          {
            "id": "wrapped_children",
            "ref": "script",
            "value": "return Array.isArray(children) ? children : children !== undefined ? [children] : []"
          },
          {
            "id": "filter_children",
            "ref": "filter"
          },
          {
            "id": "fill_children",
            "ref": "map"
          },
          {
            "id": "fill_props",
            "ref": "script",
            "value": "return props ?? {}"
          },
          {
            "id": "dom_type_def",
            "ref": "default"
          },
          {
            "id": "out",
            "ref": "script",
            "value": "if(!(typeof dom_type === 'string' && typeof children === 'object')){ throw new Error('invalid element');} return {dom_type, props, children: children, memo, value}"
          },
          {
            "id": "out_ret",
            "ref": "return"
          }
        ],
        "edges": [
          {
            "from": "children",
            "to": "wrapped_children",
            "as": "children"
          },
          {
            "from": "wrapped_children",
            "to": "fill_children",
            "as": "array"
          },
          {
            "from": "props",
            "to": "fill_props",
            "as": "props"
          },
          {
            "from": "memo",
            "to": "out",
            "as": "memo"
          },
          {
            "from": "element_dt",
            "to": "filter_children_fn",
            "as": "element_dt"
          },
          {
            "from": "element_tv",
            "to": "filter_children_fn",
            "as": "element_tv"
          },
          {
            "from": "filter_children_fn_runnable_args",
            "to": "filter_children_fn_runnable",
            "as": "parameters"
          },
          {
            "from": "filter_children_fn",
            "to": "filter_children_fn_runnable",
            "as": "fn"
          },
          {
            "from": "filter_children_fn_runnable",
            "to": "filter_children",
            "as": "fn"
          },
          {
            "from": "element",
            "to": "fill_children_fn",
            "as": "element"
          },
          {
            "from": "fill_children_fn_runnable_args",
            "to": "fill_children_fn_runnable",
            "as": "parameters"
          },
          {
            "from": "fill_children_fn",
            "to": "fill_children_fn_runnable",
            "as": "fn"
          },
          {
            "from": "fill_children_fn_runnable",
            "to": "fill_children",
            "as": "fn"
          },
          {
            "from": "fill_children",
            "to": "filter_children",
            "as": "array"
          },
          {
            "from": "filter_children",
            "to": "out",
            "as": "children"
          },
          {
            "from": "value",
            "to": "out",
            "as": "value"
          },
          {
            "from": "fill_props",
            "to": "out",
            "as": "props"
          },
          {
            "from": "dom_type",
            "to": "dom_type_def",
            "as": "value"
          },
          {
            "from": "div",
            "to": "dom_type_value",
            "as": "otherwise"
          },
          {
            "from": "graph_value",
            "to": "dom_type_value",
            "as": "value"
          },
          {
            "from": "dom_type_value",
            "to": "dom_type_def",
            "as": "otherwise"
          },
          {
            "from": "dom_type_def",
            "to": "out",
            "as": "dom_type"
          },
          {
            "from": "out",
            "to": "out_ret",
            "as": "value"
          }
        ]
      },
      "icon": {
        "id": "icon",
        "description": "A ionicon in hyperapp format.",
        "category": "html",
        "name": "icon",
        "out": "c2sko9c",
        "nodes": [
          {
            "id": "c2sko9c",
            "ref": "html_element",
            "name": "icon"
          },
          {
            "id": "2lr3ihi",
            "value": "span"
          },
          {
            "id": "empty_obj",
            "value": {}
          },
          {
            "id": "props",
            "ref": "arg",
            "value": "props"
          },
          {
            "id": "props_pred",
            "ref": "arg",
            "value": "props"
          },
          { "id": "iconclass", "value": "material-icons-outlined" },
          {
            "id": "defined_props",
            "ref": "if"
          },
          {
            "id": "name_path",
            "value": "name"
          },
          {
            "id": "a0jb5es",
            "ref": "set",
            "value": "class"
          },
          {
            "id": "s5x2r1f",
            "ref": "arg",
            "value": "icon"
          }
        ],
        "edges": [
          {
            "from": "2lr3ihi",
            "to": "c2sko9c",
            "as": "dom_type"
          },
          {
            "from": "props",
            "to": "defined_props",
            "as": "true"
          },
          {
            "from": "props_pred",
            "to": "defined_props",
            "as": "pred"
          },
          {
            "from": "empty_obj",
            "to": "defined_props",
            "as": "false"
          },
          {
            "from": "defined_props",
            "to": "a0jb5es",
            "as": "target"
          },
          { "from": "iconclass", "to": "a0jb5es", "as": "value" },
          {
            "from": "a0jb5es",
            "to": "c2sko9c",
            "as": "props"
          },
          {
            "from": "s5x2r1f",
            "to": "c2sko9c",
            "as": "children"
          }
        ]
      },
      "not": {
        "id": "not",
        "ref": "script",
        "category": "data",
        "value": "return !target"
      },
      "canvas_behind_editor": {
        "id": "canvas_behind_editor",
        "category": "html",
        "nodes": [
          {
            "id": "args"
          },
          {
            "id": "5a6pljw",
            "ref": "html_element"
          },
          {
            "id": "h2e7s9l",
            "value": "canvas"
          },
          {
            "id": "imr2dvi",
            "ref": "html_element"
          },
          {
            "id": "09epq8r",
            "ref": "array"
          },
          {
            "id": "af9fknz",
            "value": "canvas",
            "ref": "html_element"
          },
          {
            "id": "cilv4od"
          },
          {
            "id": "zvop9wi",
            "value": "canvas_id",
            "ref": "arg"
          },
          {
            "id": "zvop9wi_2",
            "value": "canvas_id",
            "ref": "arg"
          },
          {
            "id": "qe7qvud",
            "ref": "css_styles"
          },
          {
            "id": "45uuwjl"
          },
          {
            "id": "ejd0zjg"
          },
          {
            "id": "50811j9",
            "ref": "set"
          },
          {
            "id": "vmabx98",
            "value": "return `#${canvas_id}`",
            "ref": "script"
          },
          {
            "id": "ah2tu3m",
            "value": "canvas_id",
            "ref": "arg"
          },
          {
            "id": "cxwaij4"
          },
          {
            "id": "8cq1yfs",
            "value": "return window.innerWidth",
            "ref": "script"
          },
          {
            "id": "q96l549",
            "value": "return window.innerHeight",
            "ref": "script"
          },
          {
            "id": "icdi8jh",
            "value": "1"
          },
          {
            "id": "b6e9ux3",
            "value": "relative"
          },
          {
            "id": "zq4ni3x"
          },
          {
            "id": "uzulnsq",
            "value": "absolute"
          },
          {
            "id": "aoi9bi9",
            "value": "unset"
          },
          {
            "id": "3ucsio2"
          },
          {
            "id": "jzduiha",
            "value": "32"
          },
          {
            "id": "kup95dw",
            "value": "64"
          },
          {
            "id": "75jvde6",
            "value": "fixed",
            "name": ""
          },
          {
            "id": "0uhor53",
            "value": "100%"
          },
          {
            "id": "ag93b9f",
            "value": "100%"
          },
          {
            "id": "zgmfuzy",
            "value": "0"
          },
          {
            "id": "dx3qg99",
            "value": "0",
            "name": ""
          },
          {
            "id": "z54r0bl"
          },
          {
            "id": "tok49em",
            "value": "4"
          },
          {
            "id": "out",
            "name": "canvas_behind_editor",
            "ref": "return"
          }
        ],
        "edges": [
          {
            "from": "args",
            "to": "out",
            "as": "args"
          },
          {
            "from": "imr2dvi",
            "to": "out",
            "as": "value"
          },
          {
            "from": "h2e7s9l",
            "to": "args",
            "as": "canvas_id"
          },
          {
            "from": "09epq8r",
            "to": "imr2dvi",
            "as": "children"
          },
          {
            "from": "af9fknz",
            "to": "09epq8r",
            "as": "arg0"
          },
          {
            "from": "cilv4od",
            "to": "af9fknz",
            "as": "props"
          },
          {
            "from": "zvop9wi",
            "to": "cilv4od",
            "as": "id"
          },
          {
            "from": "zvop9wi_2",
            "to": "cilv4od",
            "as": "key"
          },
          {
            "from": "qe7qvud",
            "to": "09epq8r",
            "as": "arg1"
          },
          {
            "from": "50811j9",
            "to": "qe7qvud",
            "as": "css_object"
          },
          {
            "from": "45uuwjl",
            "to": "50811j9",
            "as": "target"
          },
          {
            "from": "vmabx98",
            "to": "50811j9",
            "as": "path"
          },
          {
            "from": "ah2tu3m",
            "to": "vmabx98",
            "as": "canvas_id"
          },
          {
            "from": "cxwaij4",
            "to": "50811j9",
            "as": "value"
          },
          {
            "from": "75jvde6",
            "to": "cxwaij4",
            "as": "position"
          },
          {
            "from": "8cq1yfs",
            "to": "cilv4od",
            "as": "width"
          },
          {
            "from": "q96l549",
            "to": "cilv4od",
            "as": "height"
          },
          {
            "from": "icdi8jh",
            "to": "cxwaij4",
            "as": "z-index"
          },
          {
            "from": "jzduiha",
            "to": "ejd0zjg",
            "as": "z-index"
          },
          {
            "from": "b6e9ux3",
            "to": "ejd0zjg",
            "as": "position"
          },
          {
            "from": "zq4ni3x",
            "to": "45uuwjl",
            "as": "#node-editor-result"
          },
          {
            "from": "uzulnsq",
            "to": "zq4ni3x",
            "as": "position"
          },
          {
            "from": "aoi9bi9",
            "to": "zq4ni3x",
            "as": "z-index"
          },
          {
            "from": "kup95dw",
            "to": "3ucsio2",
            "as": "z-index"
          },
          {
            "from": "3ucsio2",
            "to": "45uuwjl",
            "as": "#node-info-wrapper, #graph-actions"
          },
          {
            "from": "0uhor53",
            "to": "cxwaij4",
            "as": "width"
          },
          {
            "from": "ag93b9f",
            "to": "cxwaij4",
            "as": "height"
          },
          {
            "from": "dx3qg99",
            "to": "cxwaij4",
            "as": "top"
          },
          {
            "from": "zgmfuzy",
            "to": "cxwaij4",
            "as": "left"
          },
          {
            "from": "ejd0zjg",
            "to": "45uuwjl",
            "as": "#node-editor-editor"
          },
          {
            "from": "z54r0bl",
            "to": "45uuwjl",
            "as": "#node-editor-error"
          },
          {
            "from": "tok49em",
            "to": "z54r0bl",
            "as": "z-index"
          }
        ],
        "out": "out"
      },
      "import_module": {
        "id": "import_module",
        "category": "javascript",
        "description": "Dynamically import an es6 module",
        "ref": "extern",
        "value": "extern.import_module"
      },
      "import": {
        "id": "import",
        "out": "out",
        "category": "nodysseus",
        "nodes": {
          "args": {
            "id": "args"
          },
          "8dy573e": {
            "id": "8dy573e",
            "ref": "html_element"
          },
          "out": {
            "id": "out",
            "name": "import",
            "ref": "return"
          },
          "arcnyff": {
            "id": "arcnyff",
            "ref": "array"
          },
          "qgbinm2": {
            "id": "qgbinm2",
            "value": "Upload a json file",
            "ref": "html_text"
          },
          "rtrp3nj": {
            "id": "rtrp3nj",
            "value": "input",
            "ref": "html_element"
          },
          "vnibm4q": {
            "id": "vnibm4q"
          },
          "07fjn2b": {
            "id": "07fjn2b",
            "value": "file"
          },
          "rdt0k55": {
            "id": "rdt0k55",
            "value": ".json"
          },
          "jmqcpll": {
            "id": "jmqcpll",
            "ref": "runnable"
          },
          "o9ukwn8": {
            "id": "o9ukwn8",
            "value": "event.target.files.0",
            "ref": "arg"
          },
          "1672j69": {
            "id": "1672j69",
            "value": "text",
            "ref": "call"
          },
          "jvoijof": {
            "id": "jvoijof",
            "ref": "parse"
          },
          "uymxrxe": {
            "id": "uymxrxe",
            "ref": "map"
          },
          "yu0e7mk": {
            "id": "yu0e7mk",
            "ref": "runnable"
          },
          "3z8hhss": {
            "id": "3z8hhss",
            "value": "element",
            "ref": "arg"
          },
          "ij46kiv": {
            "id": "ij46kiv",
            "value": "return ({id: graph.id, value: graph.value, name: graph.name, nodes: graph.nodes, edges: graph.edges, out: graph.out})",
            "ref": "script"
          },
          "hcp6xds": {
            "id": "hcp6xds",
            "ref": "log"
          },
          "cixrltc": {
            "id": "cixrltc",
            "value": "_lib.no.runtime.add_ref(graph); return graph;",
            "ref": "script"
          },
          "sl7qlmj": {
            "id": "sl7qlmj",
            "value": "scripts.save_graph",
            "ref": "call"
          },
          "ukrwz7a": {
            "id": "ukrwz7a"
          },
          "xr7en45": {
            "id": "xr7en45"
          },
          "o58l5no": {
            "id": "o58l5no"
          },
          "n8fhfq0": {
            "id": "n8fhfq0"
          }
        },
        "edges": {
          "8dy573e": {
            "from": "8dy573e",
            "to": "out",
            "as": "display"
          },
          "args": {
            "from": "args",
            "to": "out",
            "as": "args"
          },
          "arcnyff": {
            "from": "arcnyff",
            "to": "8dy573e",
            "as": "children"
          },
          "qgbinm2": {
            "from": "qgbinm2",
            "to": "arcnyff",
            "as": "arg0"
          },
          "rtrp3nj": {
            "from": "rtrp3nj",
            "to": "arcnyff",
            "as": "arg1"
          },
          "vnibm4q": {
            "from": "vnibm4q",
            "to": "rtrp3nj",
            "as": "props"
          },
          "07fjn2b": {
            "from": "07fjn2b",
            "to": "vnibm4q",
            "as": "type"
          },
          "rdt0k55": {
            "from": "rdt0k55",
            "to": "vnibm4q",
            "as": "accept"
          },
          "jmqcpll": {
            "from": "jmqcpll",
            "to": "vnibm4q",
            "as": "onchange"
          },
          "o9ukwn8": {
            "from": "o9ukwn8",
            "to": "1672j69",
            "as": "self"
          },
          "1672j69": {
            "from": "1672j69",
            "to": "jvoijof",
            "as": "string"
          },
          "uymxrxe": {
            "from": "uymxrxe",
            "to": "jmqcpll",
            "as": "fn"
          },
          "jvoijof": {
            "from": "jvoijof",
            "to": "uymxrxe",
            "as": "array"
          },
          "yu0e7mk": {
            "from": "yu0e7mk",
            "to": "uymxrxe",
            "as": "fn"
          },
          "3z8hhss": {
            "from": "3z8hhss",
            "to": "ij46kiv",
            "as": "graph"
          },
          "ij46kiv": {
            "from": "ij46kiv",
            "to": "hcp6xds",
            "as": "value"
          },
          "hcp6xds": {
            "from": "hcp6xds",
            "to": "cixrltc",
            "as": "graph"
          },
          "sl7qlmj": {
            "from": "sl7qlmj",
            "to": "yu0e7mk",
            "as": "fn"
          },
          "cixrltc": {
            "from": "cixrltc",
            "to": "sl7qlmj",
            "as": "args"
          },
          "ukrwz7a": {
            "from": "ukrwz7a",
            "to": "jmqcpll",
            "as": "parameters"
          },
          "xr7en45": {
            "from": "xr7en45",
            "to": "ukrwz7a",
            "as": "event"
          },
          "o58l5no": {
            "from": "o58l5no",
            "to": "yu0e7mk",
            "as": "parameters"
          },
          "n8fhfq0": {
            "from": "n8fhfq0",
            "to": "o58l5no",
            "as": "element"
          }
        }
      },
      "import_nodes": {
        "id": "import_nodes",
        "description": "Imports the passed in `nodes`",
        "name": "import_nodes",
        "category": "nodysseus",
        "nodes": [
          {
            "id": "v10aosf",
            "name": "import_nodes",
            "ref": "return"
          },
          {
            "id": "uymxrxe",
            "ref": "map"
          },
          {
            "id": "mvg23pd"
          },
          {
            "id": "jvoijof",
            "ref": "parse"
          },
          {
            "id": "yu0e7mk",
            "ref": "runnable"
          },
          {
            "id": "ffu9m49",
            "value": "nodes",
            "ref": "arg"
          },
          {
            "id": "sl7qlmj",
            "value": "scripts.save_graph",
            "ref": "call"
          },
          {
            "id": "cixrltc",
            "value": "_lib.no.runtime.change_graph(graph); return graph;",
            "ref": "script"
          },
          {
            "id": "odeeqm8",
            "value": "return _lib;",
            "ref": "script"
          },
          {
            "id": "hcp6xds",
            "ref": "log"
          },
          {
            "id": "ij46kiv",
            "value": "return ({id: graph.id, value: graph.value, name: graph.name, nodes: graph.nodes, edges: graph.edges, out: graph.out})",
            "ref": "script"
          },
          {
            "id": "3z8hhss",
            "value": "element",
            "ref": "arg"
          }
        ],
        "edges": [
          {
            "from": "uymxrxe",
            "to": "v10aosf",
            "as": "value"
          },
          {
            "from": "mvg23pd",
            "to": "v10aosf",
            "as": "args"
          },
          {
            "from": "jvoijof",
            "to": "uymxrxe",
            "as": "array"
          },
          {
            "from": "yu0e7mk",
            "to": "uymxrxe",
            "as": "fn"
          },
          {
            "from": "ffu9m49",
            "to": "jvoijof",
            "as": "string"
          },
          {
            "from": "sl7qlmj",
            "to": "yu0e7mk",
            "as": "fn"
          },
          {
            "from": "cixrltc",
            "to": "sl7qlmj",
            "as": "args"
          },
          {
            "from": "odeeqm8",
            "to": "sl7qlmj",
            "as": "self"
          },
          {
            "from": "hcp6xds",
            "to": "cixrltc",
            "as": "graph"
          },
          {
            "from": "ij46kiv",
            "to": "hcp6xds",
            "as": "value"
          },
          {
            "from": "3z8hhss",
            "to": "ij46kiv",
            "as": "graph"
          }
        ],
        "out": "v10aosf"
      },
      "offscreen-canvas": {
        "id": "offscreen-canvas",
        "category": "html",
        "description": "Creates an offscreen canvas for rendering WebGL content. Multiple canvases can be created to allow switching content on a canvas behind the node editor or the info popup canvas.",
        "name": "offscreen-canvas",
        "nodes": [
          {
            "id": "0g1zopd",
            "name": "create-offscreen-canvas",
            "ref": "return"
          },
          {
            "id": "ein7naf",
            "ref": "if"
          },
          {
            "id": "9p0focj"
          },
          {
            "id": "98f35dl",
            "value": "return !!window.OffscreenCanvas",
            "ref": "script"
          },
          {
            "id": "dzb8l3m",
            "value": "canvas",
            "ref": "html_element"
          },
          {
            "id": "c2vbqba"
          },
          {
            "id": "hdn9zr5",
            "value": "offscreen"
          },
          {
            "id": "o40rphy"
          },
          {
            "id": "p6vd4i7",
            "value": "canvas_id",
            "ref": "arg"
          },
          {
            "id": "lik4fr6",
            "value": "return window.innerWidth;",
            "ref": "script"
          },
          {
            "id": "5q5ltj4",
            "value": "return window.innerHeight",
            "ref": "script"
          },
          {
            "id": "w7dugd7",
            "value": "return window.innerWidth;",
            "ref": "script"
          },
          {
            "id": "1wirpfe",
            "value": "return window.innerHeight",
            "ref": "script"
          },
          {
            "id": "16rxy2o",
            "value": "hidden"
          }
        ],
        "edges": [
          {
            "from": "ein7naf",
            "to": "0g1zopd",
            "as": "value"
          },
          {
            "from": "9p0focj",
            "to": "0g1zopd",
            "as": "args"
          },
          {
            "from": "98f35dl",
            "to": "ein7naf",
            "as": "pred"
          },
          {
            "from": "dzb8l3m",
            "to": "ein7naf",
            "as": "false"
          },
          {
            "from": "c2vbqba",
            "to": "dzb8l3m",
            "as": "props"
          },
          {
            "from": "hdn9zr5",
            "to": "c2vbqba",
            "as": "key"
          },
          {
            "from": "o40rphy",
            "to": "c2vbqba",
            "as": "style"
          },
          {
            "from": "p6vd4i7",
            "to": "c2vbqba",
            "as": "id"
          },
          {
            "from": "lik4fr6",
            "to": "c2vbqba",
            "as": "width"
          },
          {
            "from": "5q5ltj4",
            "to": "c2vbqba",
            "as": "height"
          },
          {
            "from": "w7dugd7",
            "to": "o40rphy",
            "as": "width"
          },
          {
            "from": "1wirpfe",
            "to": "o40rphy",
            "as": "height"
          },
          {
            "from": "16rxy2o",
            "to": "o40rphy",
            "as": "visibility"
          }
        ],
        "out": "0g1zopd"
      },
      "delete_ref": {
        "id": "delete_ref",
        "name": "delete_ref",
        "out": "main/out",
        "category": "nodysseus",
        "nodes": {
          "args": {
            "id": "args"
          },
          "jklqh38": {
            "id": "jklqh38",
            "ref": "html_element"
          },
          "6qkew20": {
            "id": "6qkew20",
            "ref": "array"
          },
          "zihm1kd": {
            "id": "zihm1kd"
          },
          "3b7bnzm": {
            "id": "3b7bnzm",
            "ref": "state"
          },
          "pcx97n4": {
            "id": "pcx97n4",
            "value": "input",
            "ref": "html_element"
          },
          "rk7hcxc": {
            "id": "rk7hcxc"
          },
          "b8wohxv": {
            "id": "b8wohxv",
            "value": "select"
          },
          "x200f4j": {
            "id": "x200f4j",
            "value": "export-list"
          },
          "et5g0m1": {
            "id": "et5g0m1",
            "ref": "map"
          },
          "9tv13iq": {
            "id": "9tv13iq",
            "value": "return _lib.no.runtime.refs()",
            "ref": "script"
          },
          "dd6st1b": {
            "id": "dd6st1b",
            "value": "element",
            "ref": "arg"
          },
          "2yur4h7": {
            "id": "2yur4h7",
            "ref": "runnable"
          },
          "xdot36k": {
            "id": "xdot36k"
          },
          "1edrrwq": {
            "id": "1edrrwq",
            "value": "option",
            "ref": "html_element"
          },
          "skqnl08": {
            "id": "skqnl08",
            "ref": "html_text"
          },
          "3y8pyc2": {
            "id": "3y8pyc2",
            "value": "datalist",
            "ref": "html_element"
          },
          "tfwqhqf": {
            "id": "tfwqhqf",
            "value": "export-list"
          },
          "tad7830": {
            "id": "tad7830",
            "ref": "state"
          },
          "jdufmth": {
            "id": "jdufmth",
            "value": "namespace.state",
            "ref": "arg"
          },
          "898n6f7": {
            "id": "898n6f7",
            "ref": "ap"
          },
          "9jvfgj1": {
            "id": "9jvfgj1",
            "value": "namespace.set",
            "ref": "arg"
          },
          "j2c518b": {
            "id": "j2c518b"
          },
          "qpiqhgp": {
            "id": "qpiqhgp",
            "value": "event.target.value",
            "ref": "arg"
          },
          "main/out": {
            "id": "main/out",
            "name": "delete_ref",
            "ref": "return"
          },
          "8dy573e": {
            "id": "8dy573e",
            "value": "button",
            "ref": "html_element"
          },
          "n7aaoju": {
            "id": "n7aaoju",
            "value": "delete",
            "ref": "html_text"
          },
          "ibmy4bt": {
            "id": "ibmy4bt",
            "ref": "runnable"
          },
          "jdoak4g": {
            "id": "jdoak4g",
            "value": 'localStorage.removeItem(ns);\nlocalStorage.setItem("graph_list", JSON.stringify(JSON.parse(localStorage.getItem("graph_list")).filter(g => g !== ns)))\n_lib.no.runtime.remove_ref(ns);',
            "ref": "script"
          },
          "a32fufq": {
            "id": "a32fufq",
            "ref": "icon"
          },
          "pfmdyvv": {
            "id": "pfmdyvv"
          },
          "9cwkm4z": {
            "id": "9cwkm4z",
            "value": "delete"
          },
          "h10oho6": {
            "id": "h10oho6",
            "ref": "if"
          },
          "2r1dra9": {
            "id": "2r1dra9",
            "value": "check"
          },
          "semslq4": {
            "id": "semslq4",
            "value": "console.log(namespace);\nconst ref = _lib.no.runtime.refs().find(r => r === namespace);\nreturn ref",
            "ref": "script"
          },
          "vffalrt": {
            "id": "vffalrt",
            "value": "namespace.state",
            "ref": "arg"
          },
          "vqk5ztl": {
            "id": "vqk5ztl"
          },
          "ygewxjl": {
            "id": "ygewxjl"
          },
          "i153jv4": {
            "id": "i153jv4",
            "ref": "ap"
          },
          "nxihxr3": {
            "id": "nxihxr3",
            "ref": "array"
          },
          "pdox5d1": {
            "id": "pdox5d1",
            "value": "graphupdate",
            "ref": "publish_event"
          },
          "qvl4qif": {
            "id": "qvl4qif",
            "value": "__graphid",
            "ref": "arg"
          },
          "dqujder": {
            "id": "dqujder"
          },
          "7c6mxi9": {
            "id": "7c6mxi9",
            "ref": "array"
          },
          "00fj2qe": {
            "id": "00fj2qe",
            "value": "graphupdate",
            "ref": "publish_event"
          },
          "rgoguh4": {
            "id": "rgoguh4"
          },
          "o2uz727": {
            "id": "o2uz727",
            "value": "__graphid",
            "ref": "arg"
          }
        },
        "edges": {
          "args": {
            "from": "args",
            "to": "main/out",
            "as": "args"
          },
          "n7aaoju": {
            "from": "n7aaoju",
            "to": "8dy573e",
            "as": "children"
          },
          "jklqh38": {
            "from": "jklqh38",
            "to": "main/out",
            "as": "display"
          },
          "6qkew20": {
            "from": "6qkew20",
            "to": "jklqh38",
            "as": "children"
          },
          "zihm1kd": {
            "from": "zihm1kd",
            "to": "8dy573e",
            "as": "props"
          },
          "tad7830": {
            "from": "tad7830",
            "to": "args",
            "as": "namespace"
          },
          "jdufmth": {
            "from": "jdufmth",
            "to": "jdoak4g",
            "as": "ns"
          },
          "3b7bnzm": {
            "from": "3b7bnzm",
            "to": "args",
            "as": "hrefstate"
          },
          "pcx97n4": {
            "from": "pcx97n4",
            "to": "6qkew20",
            "as": "arg2"
          },
          "rk7hcxc": {
            "from": "rk7hcxc",
            "to": "pcx97n4",
            "as": "props"
          },
          "b8wohxv": {
            "from": "b8wohxv",
            "to": "rk7hcxc",
            "as": "type"
          },
          "x200f4j": {
            "from": "x200f4j",
            "to": "rk7hcxc",
            "as": "list"
          },
          "3y8pyc2": {
            "from": "3y8pyc2",
            "to": "6qkew20",
            "as": "arg3"
          },
          "et5g0m1": {
            "from": "et5g0m1",
            "to": "3y8pyc2",
            "as": "children"
          },
          "9tv13iq": {
            "from": "9tv13iq",
            "to": "et5g0m1",
            "as": "array"
          },
          "2yur4h7": {
            "from": "2yur4h7",
            "to": "et5g0m1",
            "as": "fn"
          },
          "dd6st1b": {
            "from": "dd6st1b",
            "to": "skqnl08",
            "as": "text"
          },
          "xdot36k": {
            "from": "xdot36k",
            "to": "3y8pyc2",
            "as": "props"
          },
          "1edrrwq": {
            "from": "1edrrwq",
            "to": "2yur4h7",
            "as": "fn"
          },
          "skqnl08": {
            "from": "skqnl08",
            "to": "1edrrwq",
            "as": "children"
          },
          "tfwqhqf": {
            "from": "tfwqhqf",
            "to": "xdot36k",
            "as": "id"
          },
          "898n6f7": {
            "from": "898n6f7",
            "to": "rk7hcxc",
            "as": "onchange"
          },
          "9jvfgj1": {
            "from": "9jvfgj1",
            "to": "7c6mxi9",
            "as": "arg0"
          },
          "j2c518b": {
            "from": "j2c518b",
            "to": "898n6f7",
            "as": "args"
          },
          "qpiqhgp": {
            "from": "qpiqhgp",
            "to": "j2c518b",
            "as": "value"
          },
          "8dy573e": {
            "from": "8dy573e",
            "to": "6qkew20",
            "as": "arg4"
          },
          "ibmy4bt": {
            "from": "ibmy4bt",
            "to": "nxihxr3",
            "as": "arg0"
          },
          "jdoak4g": {
            "from": "jdoak4g",
            "to": "ibmy4bt",
            "as": "fn"
          },
          "a32fufq": {
            "from": "a32fufq",
            "to": "6qkew20",
            "as": "arg5"
          },
          "pfmdyvv": {
            "from": "pfmdyvv",
            "to": "a32fufq",
            "as": "props"
          },
          "9cwkm4z": {
            "from": "9cwkm4z",
            "to": "h10oho6",
            "as": "true"
          },
          "h10oho6": {
            "from": "h10oho6",
            "to": "a32fufq",
            "as": "icon"
          },
          "2r1dra9": {
            "from": "2r1dra9",
            "to": "h10oho6",
            "as": "false"
          },
          "semslq4": {
            "from": "semslq4",
            "to": "h10oho6",
            "as": "pred"
          },
          "vffalrt": {
            "from": "vffalrt",
            "to": "semslq4",
            "as": "namespace"
          },
          "vqk5ztl": {
            "from": "vqk5ztl",
            "to": "2yur4h7",
            "as": "parameters"
          },
          "ygewxjl": {
            "from": "ygewxjl",
            "to": "vqk5ztl",
            "as": "element"
          },
          "i153jv4": {
            "from": "i153jv4",
            "to": "zihm1kd",
            "as": "onclick"
          },
          "nxihxr3": {
            "from": "nxihxr3",
            "to": "i153jv4",
            "as": "fn"
          },
          "pdox5d1": {
            "from": "pdox5d1",
            "to": "nxihxr3",
            "as": "arg1"
          },
          "qvl4qif": {
            "from": "qvl4qif",
            "to": "dqujder",
            "as": "graphid"
          },
          "dqujder": {
            "from": "dqujder",
            "to": "pdox5d1",
            "as": "data"
          },
          "7c6mxi9": {
            "from": "7c6mxi9",
            "to": "898n6f7",
            "as": "fn"
          },
          "rgoguh4": {
            "from": "rgoguh4",
            "to": "00fj2qe",
            "as": "data"
          },
          "o2uz727": {
            "from": "o2uz727",
            "to": "rgoguh4",
            "as": "graphid"
          },
          "00fj2qe": {
            "from": "00fj2qe",
            "to": "7c6mxi9",
            "as": "arg1"
          }
        }
      },
      "changed": {
        "id": "changed",
        "category": "data",
        "description": "Returns true if `value` has changed",
        "name": "changed",
        "nodes": [
          {
            "id": "p8v5ed5",
            "name": "changed",
            "ref": "return"
          },
          {
            "id": "14mzqe3"
          },
          {
            "id": "vs4opfd",
            "ref": "return"
          },
          {
            "id": "3l4ufol"
          },
          {
            "id": "jlmvbt7",
            "value": "comparison",
            "ref": "get"
          },
          {
            "id": "izbtl3g",
            "value": "value",
            "ref": "arg"
          },
          {
            "id": "mm880mz",
            "ref": "cache"
          },
          {
            "id": "kw0x0bm",
            "value": "state.value",
            "ref": "set_mutable"
          },
          {
            "id": "qqzgl4i"
          },
          {
            "id": "f0ticbo"
          },
          {
            "id": "fvvux6n",
            "value": "value",
            "ref": "arg"
          },
          {
            "id": "2cvrnm9",
            "value": "initial",
            "ref": "arg"
          },
          {
            "id": "uqm4o4b",
            "value": "state",
            "ref": "arg"
          },
          {
            "id": "a59coum",
            "value": "return state != value;",
            "ref": "script"
          },
          {
            "id": "pt5nb1r",
            "value": "state.value",
            "ref": "arg"
          },
          {
            "id": "hkxrk6s",
            "value": "value",
            "ref": "arg"
          }
        ],
        "edges": [
          {
            "from": "14mzqe3",
            "to": "p8v5ed5",
            "as": "args"
          },
          {
            "from": "vs4opfd",
            "to": "p8v5ed5",
            "as": "value"
          },
          {
            "from": "3l4ufol",
            "to": "vs4opfd",
            "as": "args"
          },
          {
            "from": "jlmvbt7",
            "to": "vs4opfd",
            "as": "value"
          },
          {
            "from": "izbtl3g",
            "to": "3l4ufol",
            "as": "value"
          },
          {
            "from": "mm880mz",
            "to": "3l4ufol",
            "as": "state"
          },
          {
            "from": "kw0x0bm",
            "to": "jlmvbt7",
            "as": "target"
          },
          {
            "from": "qqzgl4i",
            "to": "mm880mz",
            "as": "value"
          },
          {
            "from": "f0ticbo",
            "to": "kw0x0bm",
            "as": "target"
          },
          {
            "from": "fvvux6n",
            "to": "kw0x0bm",
            "as": "value"
          },
          {
            "from": "2cvrnm9",
            "to": "qqzgl4i",
            "as": "value"
          },
          {
            "from": "uqm4o4b",
            "to": "f0ticbo",
            "as": "state"
          },
          {
            "from": "a59coum",
            "to": "f0ticbo",
            "as": "comparison"
          },
          {
            "from": "pt5nb1r",
            "to": "a59coum",
            "as": "state"
          },
          {
            "from": "hkxrk6s",
            "to": "a59coum",
            "as": "value"
          }
        ],
        "out": "p8v5ed5"
      },
      "webgl": {
        "id": "webgl",
        "category": "graphics",
        "description": "Creates a webgl program with vertex shader `vtx`, fragment shader `frg`, in gl context `gl`.",
        "nodes": [
          {
            "id": "j219svq"
          },
          {
            "id": "04xuprq"
          },
          {
            "id": "jidlrdv",
            "value": `return document.getElementById("node-editor-info-canvas").getContext('webgl2')`,
            "ref": "script"
          },
          {
            "id": "gkv4bqi",
            "ref": "cache"
          },
          {
            "id": "ea0tgct",
            "value": "vtx",
            "ref": "arg"
          },
          {
            "id": "rh45l5q",
            "value": "gl",
            "ref": "arg"
          },
          {
            "id": "hzz1ww4",
            "value": "return gl.VERTEX_SHADER;",
            "ref": "script"
          },
          {
            "id": "qjktjzv",
            "value": "gl",
            "ref": "arg"
          },
          {
            "id": "bu3m3jq",
            "ref": "load_shader"
          },
          {
            "id": "camgxqu",
            "ref": "load_shader"
          },
          {
            "id": "3j7l8wk",
            "value": "gl",
            "ref": "arg"
          },
          {
            "id": "wrpwzyg",
            "value": "gl",
            "ref": "arg"
          },
          {
            "id": "l41589j",
            "value": "frg",
            "ref": "arg"
          },
          {
            "id": "5luq4y5",
            "value": "return gl.FRAGMENT_SHADER;",
            "ref": "script"
          },
          {
            "id": "esayius",
            "value": "gl",
            "ref": "arg"
          },
          {
            "id": "2mgzzwp",
            "ref": "return"
          },
          {
            "id": "bkeent2",
            "value": "shaderProgram",
            "ref": "arg"
          },
          {
            "id": "qbj2tl2",
            "value": "gl",
            "ref": "arg"
          },
          {
            "id": "wyb1z00",
            "name": ""
          },
          {
            "id": "8njh1mx",
            "value": "gl",
            "ref": "arg"
          },
          {
            "id": "ca17ykm",
            "value": "gl",
            "ref": "arg"
          },
          {
            "id": "out",
            "name": "webgl",
            "ref": "return"
          },
          {
            "id": "ng2kjpd",
            "value": "buffer",
            "ref": "arg"
          },
          {
            "id": "7i0o3pn",
            "value": "return `#version 300 es\n\n    precision highp float;\n\n\n\n    out vec2 texCoord;\n\n    void main() {\n      float x = float((gl_VertexID & 1) << 2);\n      float y = float((gl_VertexID & 2) << 1);\n      texCoord.x = x * 0.5;\n      texCoord.y = y * 0.5;\n      gl_Position = vec4(x - 1.0, y - 1.0, 0, 1);\n    }\n  `;",
            "ref": "script"
          },
          {
            "id": "p2ibbe3",
            "value": "return {\n    program: shaderProgram,\n    attribLocations: {\n    },\n    uniformLocations: {\n      dataBuffer: gl.getUniformLocation(shaderProgram, 'uData')\n    },\n  };\n",
            "ref": "script"
          },
          {
            "id": "8dy573e/8dy573e",
            "out": "8dy573e/8dy573e",
            "nodes": [
              {
                "id": "8dy573e/8dy573e",
                "ref": "html_element"
              },
              {
                "id": "8dy573e/576gi1y",
                "ref": "array"
              },
              {
                "id": "8dy573e/t6fz346",
                "ref": "css_styles"
              },
              {
                "id": "8dy573e/21xxdy8"
              },
              {
                "id": "8dy573e/cuio21r"
              },
              {
                "id": "8dy573e/dx424v3",
                "value": "block"
              }
            ],
            "edges": [
              {
                "from": "8dy573e/576gi1y",
                "to": "8dy573e/8dy573e",
                "as": "children"
              },
              {
                "from": "8dy573e/t6fz346",
                "to": "8dy573e/576gi1y",
                "as": "arg2"
              },
              {
                "from": "8dy573e/21xxdy8",
                "to": "8dy573e/t6fz346",
                "as": "css_object"
              },
              {
                "from": "8dy573e/cuio21r",
                "to": "8dy573e/21xxdy8",
                "as": "#node-editor-info-canvas"
              },
              {
                "from": "8dy573e/dx424v3",
                "to": "8dy573e/cuio21r",
                "as": "display"
              }
            ]
          },
          {
            "id": "1lgkj23",
            "value": "gl",
            "ref": "arg"
          },
          {
            "id": "derz1cv",
            "value": "vtx",
            "ref": "arg"
          },
          {
            "id": "duubxl9",
            "value": "frg",
            "ref": "arg"
          },
          {
            "id": "5pjjo2a",
            "value": "return `#version 300 es\n\n    precision highp float;\n\n    uniform int uData[1024];\n\n    in vec2 texCoord;\n\n    out vec4 fragmentColor;\n    \n    void main() {\n      int idx = int(floor(1024.*gl_FragCoord.x/300.0));\n      float val = float(uData[idx]) / 128.;\n      fragmentColor = vec4(val,val,val, 1.0);\n    }\n  `;",
            "ref": "script"
          },
          {
            "id": "4r5fc0b",
            "value": "buffer",
            "ref": "arg"
          },
          {
            "id": "fbru2p5",
            "value": "const shaderProgram = gl.createProgram();\n  gl.attachShader(shaderProgram, vertexShader);\n  gl.attachShader(shaderProgram, fragmentShader);\n  gl.linkProgram(shaderProgram);\n\n  // If creating the shader program failed, alert\n\n  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n    throw new Error(gl.getProgramInfoLog(shaderProgram));\n    return null;\n  }\n\n  return shaderProgram;",
            "ref": "script"
          },
          {
            "id": "01l4ilv",
            "value": "  gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque\n  gl.clearDepth(1.0);                 // Clear everything\n\n  // Clear the canvas before we start drawing on it.\n\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n  // Tell WebGL to use our program when drawing\n  \n\n  gl.useProgram(programInfo.program);\ngl.uniform1fv(programInfo.uniformLocations.dataBuffer, buffers.data);\n\n  {\n    const offset = 0;\n    const vertexCount = 3;\n    gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);\n  }",
            "name": "",
            "ref": "script"
          },
          {
            "id": "tfz84l0",
            "ref": "cache"
          },
          {
            "id": "5bt6mgs",
            "ref": "cache"
          },
          {
            "id": "njrst9d",
            "value": "const valBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, valBuffer);\n\ngl.bufferData(gl.ARRAY_BUFFER, buffer.data, gl.STATIC_DRAW);\n\nreturn {\n  val: valBuffer,\n  data: buffer.data\n}",
            "name": "",
            "ref": "script"
          }
        ],
        "edges": [
          {
            "from": "8dy573e/8dy573e",
            "to": "out",
            "as": "display"
          },
          {
            "from": "j219svq",
            "to": "out",
            "as": "subscribe"
          },
          {
            "from": "04xuprq",
            "to": "out",
            "as": "args"
          },
          {
            "from": "jidlrdv",
            "to": "gkv4bqi",
            "as": "value"
          },
          {
            "from": "gkv4bqi",
            "to": "04xuprq",
            "as": "gl"
          },
          {
            "from": "7i0o3pn",
            "to": "04xuprq",
            "as": "vtx"
          },
          {
            "from": "5pjjo2a",
            "to": "04xuprq",
            "as": "frg"
          },
          {
            "from": "ea0tgct",
            "to": "bu3m3jq",
            "as": "source"
          },
          {
            "from": "hzz1ww4",
            "to": "bu3m3jq",
            "as": "shader_type"
          },
          {
            "from": "rh45l5q",
            "to": "hzz1ww4",
            "as": "gl"
          },
          {
            "from": "qjktjzv",
            "to": "bu3m3jq",
            "as": "gl"
          },
          {
            "from": "l41589j",
            "to": "camgxqu",
            "as": "source"
          },
          {
            "from": "5luq4y5",
            "to": "camgxqu",
            "as": "shader_type"
          },
          {
            "from": "3j7l8wk",
            "to": "camgxqu",
            "as": "gl"
          },
          {
            "from": "wrpwzyg",
            "to": "5luq4y5",
            "as": "gl"
          },
          {
            "from": "2mgzzwp",
            "to": "out",
            "as": "value"
          },
          {
            "from": "wyb1z00",
            "to": "2mgzzwp",
            "as": "args"
          },
          {
            "from": "bkeent2",
            "to": "p2ibbe3",
            "as": "shaderProgram"
          },
          {
            "from": "qbj2tl2",
            "to": "p2ibbe3",
            "as": "gl"
          },
          {
            "from": "esayius",
            "to": "fbru2p5",
            "as": "gl"
          },
          {
            "from": "01l4ilv",
            "to": "2mgzzwp",
            "as": "value"
          },
          {
            "from": "8njh1mx",
            "to": "njrst9d",
            "as": "gl"
          },
          {
            "from": "ca17ykm",
            "to": "01l4ilv",
            "as": "gl"
          },
          {
            "from": "camgxqu",
            "to": "fbru2p5",
            "as": "fragmentShader"
          },
          {
            "from": "bu3m3jq",
            "to": "fbru2p5",
            "as": "vertexShader"
          },
          {
            "from": "ng2kjpd",
            "to": "njrst9d",
            "as": "buffer"
          },
          {
            "from": "1lgkj23",
            "to": "wyb1z00",
            "as": "gl"
          },
          {
            "from": "derz1cv",
            "to": "wyb1z00",
            "as": "vtx"
          },
          {
            "from": "duubxl9",
            "to": "wyb1z00",
            "as": "frg"
          },
          {
            "from": "njrst9d",
            "to": "01l4ilv",
            "as": "buffers"
          },
          {
            "from": "4r5fc0b",
            "to": "wyb1z00",
            "as": "buffer"
          },
          {
            "from": "tfz84l0",
            "to": "wyb1z00",
            "as": "shaderProgram"
          },
          {
            "from": "fbru2p5",
            "to": "tfz84l0",
            "as": "value"
          },
          {
            "from": "5bt6mgs",
            "to": "01l4ilv",
            "as": "programInfo"
          },
          {
            "from": "p2ibbe3",
            "to": "5bt6mgs",
            "as": "value"
          }
        ],
        "out": "out"
      },
      "load_shader": {
        "id": "load_shader",
        "category": "graphics",
        "description": "Loads the `source` shader program in webgl context `gl`",
        "name": "load_shader",
        "nodes": [
          {
            "id": "37nc07d"
          },
          {
            "id": "c0cr54c",
            "value": "const shader = gl.createShader(shader_type);\n\n  // Send the source to the shader object\n\n  gl.shaderSource(shader, source);\n\n  // Compile the shader program\n\n  gl.compileShader(shader);\n\n  // See if it compiled successfully\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n    return null;\n  }\n\n  return shader;",
            "name": "",
            "ref": "script"
          },
          {
            "id": "l3qddzc",
            "value": "gl",
            "ref": "arg"
          },
          {
            "id": "e5uhxrd",
            "value": "source",
            "ref": "arg"
          },
          {
            "id": "6o4os08",
            "value": "shader_type",
            "ref": "arg"
          },
          {
            "id": "bu3m3jq",
            "name": "export",
            "ref": "return"
          }
        ],
        "edges": [
          {
            "from": "37nc07d",
            "to": "bu3m3jq",
            "as": "args"
          },
          {
            "from": "c0cr54c",
            "to": "bu3m3jq",
            "as": "value"
          },
          {
            "from": "l3qddzc",
            "to": "c0cr54c",
            "as": "gl"
          },
          {
            "from": "e5uhxrd",
            "to": "c0cr54c",
            "as": "source"
          },
          {
            "from": "6o4os08",
            "to": "c0cr54c",
            "as": "shader_type"
          }
        ],
        "out": "bu3m3jq"
      },
      "subscribe_many": {
        "id": "subscribe_many",
        "name": "subscribe_many",
        "nodes": [
          {
            "id": "ld37qq4",
            "name": "subscribe_many",
            "ref": "return"
          },
          {
            "id": "ndna6vl"
          },
          {
            "id": "r0v26jn",
            "name": "",
            "ref": "reduce"
          },
          {
            "id": "0n8k0b7",
            "value": "events",
            "ref": "arg"
          },
          {
            "id": "kd528s8",
            "name": "",
            "ref": "runnable"
          },
          {
            "id": "rxoook3",
            "ref": "merge_objects"
          },
          {
            "id": "daykk9b"
          },
          {
            "id": "6kwqo8l",
            "value": "previous",
            "name": "",
            "ref": "arg"
          },
          {
            "id": "bzkaiyo",
            "name": "",
            "ref": "set"
          },
          {
            "id": "hsq8vrp",
            "value": "base",
            "ref": "arg"
          },
          {
            "id": "5mzlv42"
          },
          {
            "id": "pkd8b0p",
            "value": "current",
            "ref": "arg"
          },
          {
            "id": "8zi1gzy",
            "value": "runnable",
            "ref": "arg"
          },
          {
            "id": "9716t7q",
            "name": "",
            "ref": "sequence"
          },
          {
            "id": "hi50l05",
            "ref": "get"
          },
          {
            "id": "opox5xi",
            "value": "base",
            "ref": "arg"
          },
          {
            "id": "5szjf17",
            "value": "current",
            "ref": "arg"
          },
          {
            "id": "it3evdr"
          },
          {
            "id": "qd1bvw9"
          },
          {
            "id": "6barb7g",
            "ref": "cache"
          },
          {
            "id": "i7tgtne",
            "value": "evt_runnable",
            "ref": "arg"
          },
          {
            "id": "7rpfcmk",
            "ref": "cache"
          },
          {
            "id": "xk6e7zh"
          },
          {
            "id": "pf10ku6",
            "ref": "runnable"
          },
          {
            "id": "km7iwa0",
            "ref": "set_mutable"
          },
          {
            "id": "zyqw0ko",
            "value": "datacache",
            "ref": "arg"
          },
          {
            "id": "f0roa3q",
            "value": "current",
            "ref": "arg"
          },
          {
            "id": "rat3zkt",
            "value": "data",
            "ref": "arg"
          },
          {
            "id": "2mcffa6",
            "value": "base",
            "ref": "arg"
          }
        ],
        "edges": [
          {
            "from": "ndna6vl",
            "to": "ld37qq4",
            "as": "args"
          },
          {
            "from": "r0v26jn",
            "to": "ld37qq4",
            "as": "return"
          },
          {
            "from": "0n8k0b7",
            "to": "r0v26jn",
            "as": "array"
          },
          {
            "from": "kd528s8",
            "to": "r0v26jn",
            "as": "fn"
          },
          {
            "from": "2mcffa6",
            "to": "r0v26jn",
            "as": "initial"
          },
          {
            "from": "rxoook3",
            "to": "kd528s8",
            "as": "fn"
          },
          {
            "from": "daykk9b",
            "to": "kd528s8",
            "as": "args"
          },
          {
            "from": "hsq8vrp",
            "to": "daykk9b",
            "as": "base"
          },
          {
            "from": "5mzlv42",
            "to": "bzkaiyo",
            "as": "target"
          },
          {
            "from": "pkd8b0p",
            "to": "bzkaiyo",
            "as": "path"
          },
          {
            "from": "opox5xi",
            "to": "hi50l05",
            "as": "target"
          },
          {
            "from": "5szjf17",
            "to": "hi50l05",
            "as": "path"
          },
          {
            "from": "9716t7q",
            "to": "bzkaiyo",
            "as": "value"
          },
          {
            "from": "8zi1gzy",
            "to": "daykk9b",
            "as": "evt_runnable"
          },
          {
            "from": "it3evdr",
            "to": "9716t7q",
            "as": "args"
          },
          {
            "from": "6barb7g",
            "to": "it3evdr",
            "as": "data"
          },
          {
            "from": "qd1bvw9",
            "to": "6barb7g",
            "as": "value"
          },
          {
            "from": "xk6e7zh",
            "to": "7rpfcmk",
            "as": "value"
          },
          {
            "from": "7rpfcmk",
            "to": "daykk9b",
            "as": "datacache"
          },
          {
            "from": "hi50l05",
            "to": "9716t7q",
            "as": "arg2"
          },
          {
            "from": "pf10ku6",
            "to": "9716t7q",
            "as": "arg0"
          },
          {
            "from": "km7iwa0",
            "to": "pf10ku6",
            "as": "fn"
          },
          {
            "from": "zyqw0ko",
            "to": "km7iwa0",
            "as": "target"
          },
          {
            "from": "f0roa3q",
            "to": "km7iwa0",
            "as": "path"
          },
          {
            "from": "rat3zkt",
            "to": "km7iwa0",
            "as": "value"
          },
          {
            "from": "6kwqo8l",
            "to": "rxoook3",
            "as": "arg0"
          },
          {
            "from": "bzkaiyo",
            "to": "rxoook3",
            "as": "arg1"
          },
          {
            "from": "i7tgtne",
            "to": "9716t7q",
            "as": "arg1"
          }
        ],
        "out": "ld37qq4"
      },
      "slider": {
        "id": "slider",
        "nodes": {
          "5mog0bc": {
            "id": "5mog0bc",
            "value": "input",
            "ref": "html_element"
          },
          "24q0egm": {
            "id": "24q0egm"
          },
          "mpbvtrq": {
            "id": "mpbvtrq",
            "value": "range"
          },
          "y407zfo": {
            "id": "y407zfo",
            "ref": "html_element"
          },
          "sb9qdgy": {
            "id": "sb9qdgy",
            "ref": "array"
          },
          "kyu6h8m": {
            "id": "kyu6h8m",
            "ref": "html_text"
          },
          "yv0o41n": {
            "id": "yv0o41n",
            "ref": "default"
          },
          "z3jopgg": {
            "id": "z3jopgg",
            "value": "step",
            "ref": "arg"
          },
          "racg3p7": {
            "id": "racg3p7",
            "value": "label",
            "ref": "arg"
          },
          "0i85qjj": {
            "id": "0i85qjj"
          },
          "u4k2auv": {
            "id": "u4k2auv",
            "value": "Slider"
          },
          "a6rdag9": {
            "id": "a6rdag9"
          },
          "sxjhepz": {
            "id": "sxjhepz"
          },
          "93rx3ru": {
            "id": "93rx3ru",
            "value": "flex"
          },
          "q8ugbch": {
            "id": "q8ugbch",
            "value": "row"
          },
          "doz740g": {
            "id": "doz740g",
            "ref": "html_text"
          },
          "gibdj45": {
            "id": "gibdj45",
            "value": "event.target.value",
            "ref": "arg"
          },
          "parseval": {
            "id": "parseval",
            "value": "return parseFloat(val)",
            "ref": "script"
          },
          "q09a315": {
            "id": "q09a315",
            "value": "0.01",
            "ref": ""
          },
          "7c2vt3d": {
            "id": "7c2vt3d",
            "ref": "default"
          },
          "fd7yax9": {
            "id": "fd7yax9",
            "value": "min",
            "ref": "arg"
          },
          "r1ah7g2": {
            "id": "r1ah7g2",
            "value": "0.0"
          },
          "bts7694": {
            "id": "bts7694",
            "value": "_sliderstate.state",
            "ref": "arg"
          },
          "slidervalpublish": {
            "id": "slidervalpublish",
            "value": "true"
          },
          "t1deznd": {
            "id": "t1deznd",
            "ref": "refval"
          },
          "ewycyaq": {
            "id": "ewycyaq",
            "ref": "default"
          },
          "old0t0c": {
            "id": "old0t0c",
            "ref": "ap"
          },
          "ezx9hxj": {
            "id": "ezx9hxj"
          },
          "l5bzesi": {
            "id": "l5bzesi",
            "value": "_sliderval.set",
            "ref": "arg"
          },
          "vgishln": {
            "id": "vgishln",
            "value": "_sliderval",
            "ref": "arg"
          },
          "sv49nso": {
            "id": "sv49nso",
            "value": "_sliderval.value",
            "ref": "arg"
          },
          "n4i4t17": {
            "id": "n4i4t17",
            "value": "_sliderval",
            "ref": "arg"
          },
          "out": {
            "id": "out",
            "name": "slider",
            "ref": "return"
          },
          "2wp8ffd": {
            "id": "2wp8ffd",
            "ref": "array"
          },
          "4dh6wzn": {
            "id": "4dh6wzn",
            "value": "oninput",
            "ref": "arg"
          },
          "1dhoyv2": {
            "id": "1dhoyv2",
            "value": "return !isNaN(argmax) ? argmax : !isNaN(graphval) ? graphval : 1.0",
            "ref": "script"
          },
          "4subc0j": {
            "id": "4subc0j",
            "value": "__graph_value",
            "ref": "arg"
          },
          "x4vnm62": {
            "id": "x4vnm62",
            "value": "max",
            "ref": "arg"
          },
          "gvk9hec": {
            "id": "gvk9hec",
            "ref": "state"
          },
          "v0qabyr": {
            "id": "v0qabyr",
            "ref": "ap"
          },
          "d86emo2": {
            "id": "d86emo2",
            "ref": "array"
          },
          "8f3izp7": {
            "id": "8f3izp7",
            "value": "onchange",
            "ref": "arg"
          },
          "gtpf6x9": {
            "id": "gtpf6x9",
            "value": "_sliderstate.set",
            "ref": "arg"
          },
          "oqbuspj": {
            "id": "oqbuspj"
          },
          "nrhhdip": {
            "id": "nrhhdip",
            "value": "return parseFloat(val)",
            "ref": "script"
          },
          "z8c7kcy": {
            "id": "z8c7kcy",
            "value": "event.target.value",
            "ref": "arg"
          },
          "tksk4wc": {
            "id": "tksk4wc",
            "ref": "default"
          },
          "d1wcpk1": {
            "id": "d1wcpk1",
            "value": "_sliderstate.state",
            "ref": "arg"
          },
          "av63lw9": {
            "id": "av63lw9",
            "value": "if(val.value === undefined && state.state !== undefined) {\n  val.set.fn(state.state)\n}\n\nreturn val;",
            "ref": "script"
          },
          "tjzn9ne": {
            "id": "tjzn9ne",
            "value": "_sliderstate",
            "ref": "arg"
          },
          "ku4l1v6": {
            "id": "ku4l1v6",
            "value": "value",
            "ref": "get"
          },
          "h19qe28": {
            "id": "h19qe28",
            "value": "true"
          },
          "fgmcy0x": {
            "id": "fgmcy0x",
            "value": "true"
          }
        },
        "edges": {
          "24q0egm": {
            "from": "24q0egm",
            "to": "5mog0bc",
            "as": "props"
          },
          "mpbvtrq": {
            "from": "mpbvtrq",
            "to": "24q0egm",
            "as": "type"
          },
          "sb9qdgy": {
            "from": "sb9qdgy",
            "to": "y407zfo",
            "as": "children"
          },
          "yv0o41n": {
            "from": "yv0o41n",
            "to": "24q0egm",
            "as": "step"
          },
          "q09a315": {
            "from": "q09a315",
            "to": "yv0o41n",
            "as": "otherwise"
          },
          "z3jopgg": {
            "from": "z3jopgg",
            "to": "yv0o41n",
            "as": "value"
          },
          "5mog0bc": {
            "from": "5mog0bc",
            "to": "sb9qdgy",
            "as": "arg1"
          },
          "0i85qjj": {
            "from": "0i85qjj",
            "to": "out",
            "as": "args"
          },
          "u4k2auv": {
            "from": "u4k2auv",
            "to": "0i85qjj",
            "as": "label"
          },
          "a6rdag9": {
            "from": "a6rdag9",
            "to": "y407zfo",
            "as": "props"
          },
          "sxjhepz": {
            "from": "sxjhepz",
            "to": "a6rdag9",
            "as": "style"
          },
          "93rx3ru": {
            "from": "93rx3ru",
            "to": "sxjhepz",
            "as": "display"
          },
          "q8ugbch": {
            "from": "q8ugbch",
            "to": "sxjhepz",
            "as": "flex-direction"
          },
          "doz740g": {
            "from": "doz740g",
            "to": "sb9qdgy",
            "as": "arg0"
          },
          "kyu6h8m": {
            "from": "kyu6h8m",
            "to": "sb9qdgy",
            "as": "arg2"
          },
          "racg3p7": {
            "from": "racg3p7",
            "to": "doz740g",
            "as": "text"
          },
          "ewycyaq": {
            "from": "ewycyaq",
            "to": "kyu6h8m",
            "as": "text"
          },
          "r1ah7g2": {
            "from": "r1ah7g2",
            "to": "7c2vt3d",
            "as": "otherwise"
          },
          "fd7yax9": {
            "from": "fd7yax9",
            "to": "7c2vt3d",
            "as": "value"
          },
          "7c2vt3d": {
            "from": "7c2vt3d",
            "to": "24q0egm",
            "as": "min"
          },
          "bts7694": {
            "from": "bts7694",
            "to": "ewycyaq",
            "as": "otherwise"
          },
          "t1deznd": {
            "from": "t1deznd",
            "to": "0i85qjj",
            "as": "_sliderval"
          },
          "slidervalpublish": {
            "from": "slidervalpublish",
            "to": "t1deznd",
            "as": "publish"
          },
          "sv49nso": {
            "from": "sv49nso",
            "to": "tksk4wc",
            "as": "value"
          },
          "ezx9hxj": {
            "from": "ezx9hxj",
            "to": "old0t0c",
            "as": "args"
          },
          "old0t0c": {
            "from": "old0t0c",
            "to": "24q0egm",
            "as": "oninput"
          },
          "vgishln": {
            "from": "vgishln",
            "to": "ku4l1v6",
            "as": "target"
          },
          "gibdj45": {
            "from": "gibdj45",
            "to": "parseval",
            "as": "val"
          },
          "parseval": {
            "from": "parseval",
            "to": "ezx9hxj",
            "as": "value"
          },
          "n4i4t17": {
            "from": "n4i4t17",
            "to": "av63lw9",
            "as": "val"
          },
          "y407zfo": {
            "from": "y407zfo",
            "to": "out",
            "as": "display"
          },
          "2wp8ffd": {
            "from": "2wp8ffd",
            "to": "old0t0c",
            "as": "fn"
          },
          "l5bzesi": {
            "from": "l5bzesi",
            "to": "2wp8ffd",
            "as": "arg0"
          },
          "4dh6wzn": {
            "from": "4dh6wzn",
            "to": "2wp8ffd",
            "as": "arg1"
          },
          "x4vnm62": {
            "from": "x4vnm62",
            "to": "1dhoyv2",
            "as": "argmax"
          },
          "4subc0j": {
            "from": "4subc0j",
            "to": "1dhoyv2",
            "as": "graphval"
          },
          "1dhoyv2": {
            "from": "1dhoyv2",
            "to": "24q0egm",
            "as": "max"
          },
          "gvk9hec": {
            "from": "gvk9hec",
            "to": "0i85qjj",
            "as": "_sliderstate"
          },
          "oqbuspj": {
            "from": "oqbuspj",
            "to": "v0qabyr",
            "as": "args"
          },
          "d86emo2": {
            "from": "d86emo2",
            "to": "v0qabyr",
            "as": "fn"
          },
          "gtpf6x9": {
            "from": "gtpf6x9",
            "to": "d86emo2",
            "as": "arg0"
          },
          "8f3izp7": {
            "from": "8f3izp7",
            "to": "d86emo2",
            "as": "arg1"
          },
          "nrhhdip": {
            "from": "nrhhdip",
            "to": "oqbuspj",
            "as": "value"
          },
          "z8c7kcy": {
            "from": "z8c7kcy",
            "to": "nrhhdip",
            "as": "val"
          },
          "v0qabyr": {
            "from": "v0qabyr",
            "to": "24q0egm",
            "as": "onchange"
          },
          "tksk4wc": {
            "from": "tksk4wc",
            "to": "24q0egm",
            "as": "value"
          },
          "d1wcpk1": {
            "from": "d1wcpk1",
            "to": "tksk4wc",
            "as": "otherwise"
          },
          "av63lw9": {
            "from": "av63lw9",
            "to": "y407zfo",
            "as": "value"
          },
          "tjzn9ne": {
            "from": "tjzn9ne",
            "to": "av63lw9",
            "as": "state"
          },
          "ku4l1v6": {
            "from": "ku4l1v6",
            "to": "ewycyaq",
            "as": "value"
          },
          "h19qe28": {
            "from": "h19qe28",
            "to": "gvk9hec",
            "as": "persist"
          },
          "fgmcy0x": {
            "from": "fgmcy0x",
            "to": "gvk9hec",
            "as": "publish"
          }
        },
        "edges_in": {
          "5mog0bc": {
            "24q0egm": {
              "from": "24q0egm",
              "to": "5mog0bc",
              "as": "props"
            }
          },
          "24q0egm": {
            "mpbvtrq": {
              "from": "mpbvtrq",
              "to": "24q0egm",
              "as": "type"
            },
            "yv0o41n": {
              "from": "yv0o41n",
              "to": "24q0egm",
              "as": "step"
            },
            "7c2vt3d": {
              "from": "7c2vt3d",
              "to": "24q0egm",
              "as": "min"
            },
            "old0t0c": {
              "from": "old0t0c",
              "to": "24q0egm",
              "as": "oninput"
            },
            "1dhoyv2": {
              "from": "1dhoyv2",
              "to": "24q0egm",
              "as": "max"
            },
            "v0qabyr": {
              "from": "v0qabyr",
              "to": "24q0egm",
              "as": "onchange"
            },
            "tksk4wc": {
              "from": "tksk4wc",
              "to": "24q0egm",
              "as": "value"
            }
          },
          "y407zfo": {
            "sb9qdgy": {
              "from": "sb9qdgy",
              "to": "y407zfo",
              "as": "children"
            },
            "a6rdag9": {
              "from": "a6rdag9",
              "to": "y407zfo",
              "as": "props"
            },
            "av63lw9": {
              "from": "av63lw9",
              "to": "y407zfo",
              "as": "value"
            }
          },
          "yv0o41n": {
            "q09a315": {
              "from": "q09a315",
              "to": "yv0o41n",
              "as": "otherwise"
            },
            "z3jopgg": {
              "from": "z3jopgg",
              "to": "yv0o41n",
              "as": "value"
            }
          },
          "sb9qdgy": {
            "5mog0bc": {
              "from": "5mog0bc",
              "to": "sb9qdgy",
              "as": "arg1"
            },
            "doz740g": {
              "from": "doz740g",
              "to": "sb9qdgy",
              "as": "arg0"
            },
            "kyu6h8m": {
              "from": "kyu6h8m",
              "to": "sb9qdgy",
              "as": "arg2"
            }
          },
          "out": {
            "0i85qjj": {
              "from": "0i85qjj",
              "to": "out",
              "as": "args"
            },
            "y407zfo": {
              "from": "y407zfo",
              "to": "out",
              "as": "display"
            }
          },
          "0i85qjj": {
            "u4k2auv": {
              "from": "u4k2auv",
              "to": "0i85qjj",
              "as": "label"
            },
            "t1deznd": {
              "from": "t1deznd",
              "to": "0i85qjj",
              "as": "_sliderval"
            },
            "gvk9hec": {
              "from": "gvk9hec",
              "to": "0i85qjj",
              "as": "_sliderstate"
            }
          },
          "t1deznd": {
            "slidervalpublish": {
              "from": "slidervalpublish",
              "to": "t1deznd",
              "as": "publish"
            }
          },
          "a6rdag9": {
            "sxjhepz": {
              "from": "sxjhepz",
              "to": "a6rdag9",
              "as": "style"
            }
          },
          "sxjhepz": {
            "93rx3ru": {
              "from": "93rx3ru",
              "to": "sxjhepz",
              "as": "display"
            },
            "q8ugbch": {
              "from": "q8ugbch",
              "to": "sxjhepz",
              "as": "flex-direction"
            }
          },
          "doz740g": {
            "racg3p7": {
              "from": "racg3p7",
              "to": "doz740g",
              "as": "text"
            }
          },
          "kyu6h8m": {
            "ewycyaq": {
              "from": "ewycyaq",
              "to": "kyu6h8m",
              "as": "text"
            }
          },
          "7c2vt3d": {
            "r1ah7g2": {
              "from": "r1ah7g2",
              "to": "7c2vt3d",
              "as": "otherwise"
            },
            "fd7yax9": {
              "from": "fd7yax9",
              "to": "7c2vt3d",
              "as": "value"
            }
          },
          "ewycyaq": {
            "bts7694": {
              "from": "bts7694",
              "to": "ewycyaq",
              "as": "otherwise"
            },
            "ku4l1v6": {
              "from": "ku4l1v6",
              "to": "ewycyaq",
              "as": "value"
            }
          },
          "tksk4wc": {
            "sv49nso": {
              "from": "sv49nso",
              "to": "tksk4wc",
              "as": "value"
            },
            "d1wcpk1": {
              "from": "d1wcpk1",
              "to": "tksk4wc",
              "as": "otherwise"
            }
          },
          "old0t0c": {
            "ezx9hxj": {
              "from": "ezx9hxj",
              "to": "old0t0c",
              "as": "args"
            },
            "2wp8ffd": {
              "from": "2wp8ffd",
              "to": "old0t0c",
              "as": "fn"
            }
          },
          "ku4l1v6": {
            "vgishln": {
              "from": "vgishln",
              "to": "ku4l1v6",
              "as": "target"
            }
          },
          "parseval": {
            "gibdj45": {
              "from": "gibdj45",
              "to": "parseval",
              "as": "val"
            }
          },
          "ezx9hxj": {
            "parseval": {
              "from": "parseval",
              "to": "ezx9hxj",
              "as": "value"
            }
          },
          "av63lw9": {
            "n4i4t17": {
              "from": "n4i4t17",
              "to": "av63lw9",
              "as": "val"
            },
            "tjzn9ne": {
              "from": "tjzn9ne",
              "to": "av63lw9",
              "as": "state"
            }
          },
          "2wp8ffd": {
            "l5bzesi": {
              "from": "l5bzesi",
              "to": "2wp8ffd",
              "as": "arg0"
            },
            "4dh6wzn": {
              "from": "4dh6wzn",
              "to": "2wp8ffd",
              "as": "arg1"
            }
          },
          "1dhoyv2": {
            "x4vnm62": {
              "from": "x4vnm62",
              "to": "1dhoyv2",
              "as": "argmax"
            },
            "4subc0j": {
              "from": "4subc0j",
              "to": "1dhoyv2",
              "as": "graphval"
            }
          },
          "v0qabyr": {
            "oqbuspj": {
              "from": "oqbuspj",
              "to": "v0qabyr",
              "as": "args"
            },
            "d86emo2": {
              "from": "d86emo2",
              "to": "v0qabyr",
              "as": "fn"
            }
          },
          "d86emo2": {
            "gtpf6x9": {
              "from": "gtpf6x9",
              "to": "d86emo2",
              "as": "arg0"
            },
            "8f3izp7": {
              "from": "8f3izp7",
              "to": "d86emo2",
              "as": "arg1"
            }
          },
          "oqbuspj": {
            "nrhhdip": {
              "from": "nrhhdip",
              "to": "oqbuspj",
              "as": "value"
            }
          },
          "nrhhdip": {
            "z8c7kcy": {
              "from": "z8c7kcy",
              "to": "nrhhdip",
              "as": "val"
            }
          },
          "gvk9hec": {
            "h19qe28": {
              "from": "h19qe28",
              "to": "gvk9hec",
              "as": "persist"
            },
            "fgmcy0x": {
              "from": "fgmcy0x",
              "to": "gvk9hec",
              "as": "publish"
            }
          }
        },
        "out": "out"
      },
      "export": {
        "id": "export",
        "out": "main/out",
        "category": "nodysseus",
        "nodes": {
          "args": {
            "id": "args"
          },
          "main/out": {
            "id": "main/out",
            "name": "export",
            "ref": "return"
          },
          "jklqh38": {
            "id": "jklqh38",
            "ref": "html_element"
          },
          "8dy573e": {
            "id": "8dy573e",
            "value": "a",
            "ref": "html_element"
          },
          "6qkew20": {
            "id": "6qkew20",
            "ref": "array"
          },
          "zihm1kd": {
            "id": "zihm1kd"
          },
          "2dz33fg": {
            "id": "2dz33fg",
            "value": "_new"
          },
          "n7aaoju": {
            "id": "n7aaoju",
            "value": "Export",
            "ref": "html_text"
          },
          "jdoak4g": {
            "id": "jdoak4g",
            "value": "return ns + '.json';",
            "ref": "script"
          },
          "3b7bnzm": {
            "id": "3b7bnzm",
            "ref": "state"
          },
          "ug26ugw": {
            "id": "ug26ugw",
            "value": "hrefstate.state",
            "name": "",
            "ref": "arg"
          },
          "pni2xuu": {
            "id": "pni2xuu",
            "value": "href",
            "ref": "log"
          },
          "pcx97n4": {
            "id": "pcx97n4",
            "value": "input",
            "ref": "html_element"
          },
          "rk7hcxc": {
            "id": "rk7hcxc"
          },
          "b8wohxv": {
            "id": "b8wohxv",
            "value": "select"
          },
          "x200f4j": {
            "id": "x200f4j",
            "value": "export-list"
          },
          "et5g0m1": {
            "id": "et5g0m1",
            "ref": "map"
          },
          "9tv13iq": {
            "id": "9tv13iq",
            "value": "return _lib.no.runtime.refs()",
            "ref": "script"
          },
          "dd6st1b": {
            "id": "dd6st1b",
            "value": "element",
            "ref": "arg"
          },
          "2yur4h7": {
            "id": "2yur4h7",
            "ref": "runnable"
          },
          "xdot36k": {
            "id": "xdot36k"
          },
          "1edrrwq": {
            "id": "1edrrwq",
            "value": "option",
            "ref": "html_element"
          },
          "skqnl08": {
            "id": "skqnl08",
            "ref": "html_text"
          },
          "3y8pyc2": {
            "id": "3y8pyc2",
            "value": "datalist",
            "ref": "html_element"
          },
          "tfwqhqf": {
            "id": "tfwqhqf",
            "value": "export-list"
          },
          "xp4pv1h": {
            "id": "xp4pv1h",
            "value": "return element",
            "ref": "script"
          },
          "i5wnhvh": {
            "id": "i5wnhvh",
            "ref": "ap"
          },
          "mp0ce5t": {
            "id": "mp0ce5t",
            "value": "hrefstate.set",
            "ref": "arg"
          },
          "zucq3k4": {
            "id": "zucq3k4"
          },
          "8470sfe": {
            "id": "8470sfe",
            "value": "return URL.createObjectURL(file)",
            "ref": "script"
          },
          "hke54sp": {
            "id": "hke54sp",
            "value": 'return new Blob([json], {type: "application/json"})',
            "ref": "script"
          },
          "syfso39": {
            "id": "syfso39",
            "ref": "stringify"
          },
          "kaiwusy": {
            "id": "kaiwusy",
            "value": "mapout",
            "ref": "log"
          },
          "db0reg4": {
            "id": "db0reg4",
            "ref": "map"
          },
          "0pnyh3t": {
            "id": "0pnyh3t",
            "value": "mapin",
            "ref": "log"
          },
          "l4o1umt": {
            "id": "l4o1umt",
            "value": "return _lib.no.runtime.refs().filter(r => r.startsWith('@' + namespace + '.') || r === namespace)",
            "ref": "script"
          },
          "w78q6vm": {
            "id": "w78q6vm",
            "value": "ns",
            "ref": "log"
          },
          "959i120": {
            "id": "959i120",
            "ref": "runnable"
          },
          "a1vqjzz": {
            "id": "a1vqjzz",
            "value": "element",
            "ref": "arg"
          },
          "1148sh5": {
            "id": "1148sh5",
            "value": "2"
          },
          "1axuplc": {
            "id": "1axuplc",
            "value": "event.target.value",
            "ref": "arg"
          },
          "tad7830": {
            "id": "tad7830",
            "ref": "state"
          },
          "jdufmth": {
            "id": "jdufmth",
            "value": "namespace.state",
            "ref": "arg"
          },
          "91lhfar_arr": {
            "id": "91lhfar_arr",
            "ref": "array"
          },
          "91lhfar": {
            "id": "91lhfar",
            "ref": "ap"
          },
          "898n6f7": {
            "id": "898n6f7",
            "ref": "ap"
          },
          "9jvfgj1": {
            "id": "9jvfgj1",
            "value": "namespace.set",
            "ref": "arg"
          },
          "j2c518b": {
            "id": "j2c518b"
          },
          "qpiqhgp": {
            "id": "qpiqhgp",
            "value": "event.target.value",
            "ref": "arg"
          },
          "x8ik3x4": {
            "id": "x8ik3x4",
            "value": "const graph = {...ref};\ndelete graph._nodes_old;\ndelete graph._edges_old;\nreturn graph;",
            "ref": "script"
          },
          "6ag8lnc": {
            "id": "6ag8lnc"
          },
          "9rf8bds": {
            "id": "9rf8bds"
          },
          "690ivn1": {
            "id": "690ivn1",
            "value": "val",
            "ref": "log"
          },
          "zpv5bk2": {
            "id": "zpv5bk2"
          },
          "6dadrg0": {
            "id": "6dadrg0",
            "value": "event",
            "ref": "arg"
          },
          "i60dlmh": {
            "id": "i60dlmh"
          },
          "g7pa2bl": {
            "id": "g7pa2bl"
          },
          "8zvzwb5": {
            "id": "8zvzwb5",
            "value": "return _lib.no.runtime.get_ref(ref);",
            "ref": "script"
          }
        },
        "edges": {
          "args": {
            "from": "args",
            "to": "main/out",
            "as": "args"
          },
          "n7aaoju": {
            "from": "n7aaoju",
            "to": "8dy573e",
            "as": "children"
          },
          "jklqh38": {
            "from": "jklqh38",
            "to": "main/out",
            "as": "display"
          },
          "6qkew20": {
            "from": "6qkew20",
            "to": "jklqh38",
            "as": "children"
          },
          "8dy573e": {
            "from": "8dy573e",
            "to": "6qkew20",
            "as": "arg0"
          },
          "zihm1kd": {
            "from": "zihm1kd",
            "to": "8dy573e",
            "as": "props"
          },
          "2dz33fg": {
            "from": "2dz33fg",
            "to": "zihm1kd",
            "as": "target"
          },
          "tad7830": {
            "from": "tad7830",
            "to": "args",
            "as": "namespace"
          },
          "jdufmth": {
            "from": "jdufmth",
            "to": "jdoak4g",
            "as": "ns"
          },
          "jdoak4g": {
            "from": "jdoak4g",
            "to": "zihm1kd",
            "as": "download"
          },
          "3b7bnzm": {
            "from": "3b7bnzm",
            "to": "args",
            "as": "hrefstate"
          },
          "pni2xuu": {
            "from": "pni2xuu",
            "to": "zihm1kd",
            "as": "href"
          },
          "ug26ugw": {
            "from": "ug26ugw",
            "to": "pni2xuu",
            "as": "value"
          },
          "pcx97n4": {
            "from": "pcx97n4",
            "to": "6qkew20",
            "as": "arg2"
          },
          "rk7hcxc": {
            "from": "rk7hcxc",
            "to": "pcx97n4",
            "as": "props"
          },
          "b8wohxv": {
            "from": "b8wohxv",
            "to": "rk7hcxc",
            "as": "type"
          },
          "x200f4j": {
            "from": "x200f4j",
            "to": "rk7hcxc",
            "as": "list"
          },
          "3y8pyc2": {
            "from": "3y8pyc2",
            "to": "6qkew20",
            "as": "arg3"
          },
          "et5g0m1": {
            "from": "et5g0m1",
            "to": "3y8pyc2",
            "as": "children"
          },
          "9tv13iq": {
            "from": "9tv13iq",
            "to": "et5g0m1",
            "as": "array"
          },
          "2yur4h7": {
            "from": "2yur4h7",
            "to": "et5g0m1",
            "as": "fn"
          },
          "dd6st1b": {
            "from": "dd6st1b",
            "to": "xp4pv1h",
            "as": "element"
          },
          "xdot36k": {
            "from": "xdot36k",
            "to": "3y8pyc2",
            "as": "props"
          },
          "1edrrwq": {
            "from": "1edrrwq",
            "to": "2yur4h7",
            "as": "fn"
          },
          "skqnl08": {
            "from": "skqnl08",
            "to": "1edrrwq",
            "as": "children"
          },
          "xp4pv1h": {
            "from": "xp4pv1h",
            "to": "skqnl08",
            "as": "text"
          },
          "tfwqhqf": {
            "from": "tfwqhqf",
            "to": "xdot36k",
            "as": "id"
          },
          "zucq3k4": {
            "from": "zucq3k4",
            "to": "i5wnhvh",
            "as": "args"
          },
          "8470sfe": {
            "from": "8470sfe",
            "to": "zucq3k4",
            "as": "value"
          },
          "hke54sp": {
            "from": "hke54sp",
            "to": "8470sfe",
            "as": "file"
          },
          "syfso39": {
            "from": "syfso39",
            "to": "hke54sp",
            "as": "json"
          },
          "1148sh5": {
            "from": "1148sh5",
            "to": "syfso39",
            "as": "spacer"
          },
          "kaiwusy": {
            "from": "kaiwusy",
            "to": "syfso39",
            "as": "object"
          },
          "db0reg4": {
            "from": "db0reg4",
            "to": "kaiwusy",
            "as": "value"
          },
          "959i120": {
            "from": "959i120",
            "to": "db0reg4",
            "as": "fn"
          },
          "0pnyh3t": {
            "from": "0pnyh3t",
            "to": "db0reg4",
            "as": "array"
          },
          "l4o1umt": {
            "from": "l4o1umt",
            "to": "0pnyh3t",
            "as": "value"
          },
          "w78q6vm": {
            "from": "w78q6vm",
            "to": "l4o1umt",
            "as": "namespace"
          },
          "1axuplc": {
            "from": "1axuplc",
            "to": "w78q6vm",
            "as": "value"
          },
          "x8ik3x4": {
            "from": "x8ik3x4",
            "to": "959i120",
            "as": "fn"
          },
          "a1vqjzz": {
            "from": "a1vqjzz",
            "to": "8zvzwb5",
            "as": "ref"
          },
          "mp0ce5t": {
            "from": "mp0ce5t",
            "to": "i5wnhvh",
            "as": "fn"
          },
          "91lhfar": {
            "from": "91lhfar",
            "to": "rk7hcxc",
            "as": "onchange"
          },
          "i5wnhvh": {
            "from": "i5wnhvh",
            "to": "91lhfar_arr",
            "as": "arg1"
          },
          "898n6f7": {
            "from": "898n6f7",
            "to": "91lhfar_arr",
            "as": "arg0"
          },
          "91lhfar_arr": {
            "from": "91lhfar_arr",
            "to": "91lhfar",
            "as": "fn"
          },
          "9jvfgj1": {
            "from": "9jvfgj1",
            "to": "898n6f7",
            "as": "fn"
          },
          "qpiqhgp": {
            "from": "qpiqhgp",
            "to": "j2c518b",
            "as": "value"
          },
          "6ag8lnc": {
            "from": "6ag8lnc",
            "to": "2yur4h7",
            "as": "parameters"
          },
          "9rf8bds": {
            "from": "9rf8bds",
            "to": "6ag8lnc",
            "as": "element"
          },
          "690ivn1": {
            "from": "690ivn1",
            "to": "898n6f7",
            "as": "args"
          },
          "j2c518b": {
            "from": "j2c518b",
            "to": "690ivn1",
            "as": "value"
          },
          "zpv5bk2": {
            "from": "zpv5bk2",
            "to": "91lhfar",
            "as": "args"
          },
          "6dadrg0": {
            "from": "6dadrg0",
            "to": "zpv5bk2",
            "as": "event"
          },
          "i60dlmh": {
            "from": "i60dlmh",
            "to": "959i120",
            "as": "parameters"
          },
          "g7pa2bl": {
            "from": "g7pa2bl",
            "to": "i60dlmh",
            "as": "element"
          },
          "8zvzwb5": {
            "from": "8zvzwb5",
            "to": "x8ik3x4",
            "as": "ref"
          }
        }
      },
      "assetmanager": {
        "id": "assetmanager",
        "out": "out",
        "nodes": {
          "args": {
            "id": "args"
          },
          "qgbinm2": {
            "id": "qgbinm2",
            "value": "input",
            "ref": "html_element"
          },
          "8dy573e": {
            "id": "8dy573e",
            "ref": "html_element"
          },
          "output_val": {
            "id": "output_val",
            "value": "some output"
          },
          "out": {
            "id": "out",
            "ref": "return",
            "name": "assetmanager"
          },
          "46kgw03": {
            "id": "46kgw03",
            "value": "\nconsole.log(_lib);\n\nreturn _lib.list_assets();",
            "ref": "script"
          },
          "4nx9x10": {
            "id": "4nx9x10",
            "ref": "log"
          },
          "rrgshuq": {
            "id": "rrgshuq",
            "value": "select",
            "ref": "html_element"
          },
          "chkprox": {
            "id": "chkprox",
            "ref": "map"
          },
          "5hesw9s": {
            "id": "5hesw9s",
            "value": "return _lib.no.runtime.list_assets()",
            "ref": "script"
          },
          "49od031": {
            "id": "49od031",
            "ref": "runnable"
          },
          "h1z2zqq": {
            "id": "h1z2zqq",
            "value": "element",
            "ref": "arg"
          },
          "znw0jq1": {
            "id": "znw0jq1",
            "value": "option",
            "ref": "html_element"
          },
          "xiv2pw0": {
            "id": "xiv2pw0"
          },
          "yx1sv0e": {
            "id": "yx1sv0e"
          },
          "zk03lef": {
            "id": "zk03lef"
          },
          "23vrr6n": {
            "id": "23vrr6n",
            "value": "element",
            "ref": "arg"
          },
          "md80upr": {
            "id": "md80upr"
          },
          "zhoffc7": {
            "id": "zhoffc7",
            "ref": "array"
          },
          "4zueto7": {
            "id": "4zueto7"
          },
          "5ndg5og": {
            "id": "5ndg5og",
            "value": "file"
          },
          "10ozygd": {
            "id": "10ozygd",
            "ref": "runnable"
          },
          "6zb4hho": {
            "id": "6zb4hho",
            "value": "event.target.files",
            "ref": "arg"
          },
          "6c04ryh": {
            "id": "6c04ryh",
            "value": "_lib.no.runtime.add_asset(name, files[0])",
            "ref": "script"
          },
          "d4sx4ej": {
            "id": "d4sx4ej",
            "value": "assetname",
            "ref": "arg"
          },
          "drkjew9": {
            "id": "drkjew9"
          },
          "12i36ht": {
            "id": "12i36ht",
            "ref": "state"
          },
          "gwslf7p": {
            "id": "gwslf7p"
          },
          "g6loz00": {
            "id": "g6loz00",
            "ref": "ap"
          },
          "7ny91r3": {
            "id": "7ny91r3",
            "value": "event.target.value",
            "ref": "arg"
          },
          "vg773lv": {
            "id": "vg773lv",
            "value": "return _lib.no.runtime.get_asset(asset);",
            "ref": "script"
          },
          "jhyu5pk": {
            "id": "jhyu5pk"
          },
          "gnuhmpf": {
            "id": "gnuhmpf",
            "value": "_asset.set",
            "ref": "arg"
          },
          "dh814lx": {
            "id": "dh814lx",
            "value": "_asset.state",
            "ref": "arg"
          },
          "mhqejl5": {
            "id": "mhqejl5",
            "value": "file",
            "ref": "set"
          },
          "1090db5": {
            "id": "1090db5",
            "ref": "if"
          },
          "xuyat95": {
            "id": "xuyat95",
            "ref": "if"
          },
          "mk4gru0": {
            "id": "mk4gru0",
            "value": "assetname",
            "ref": "arg"
          },
          "9ucfrui": {
            "id": "9ucfrui",
            "ref": "ap"
          },
          "1ts2j8n": {
            "id": "1ts2j8n"
          },
          "gzki6r1": {
            "id": "gzki6r1",
            "value": "return _lib.no.runtime.get_asset(asset);",
            "ref": "script"
          },
          "l7ahauw": {
            "id": "l7ahauw",
            "value": "assetname",
            "ref": "arg"
          },
          "nhruqy5": {
            "id": "nhruqy5",
            "value": "true"
          },
          "g7ew1lp": {
            "id": "g7ew1lp",
            "value": "_asset.set",
            "ref": "arg"
          },
          "riqk7hm": {
            "id": "riqk7hm",
            "value": "_asset.state",
            "ref": "arg"
          },
          "b9gbfro": {
            "id": "b9gbfro",
            "value": "_asset.state",
            "ref": "arg"
          }
        },
        "edges": {
          "qgbinm2": {
            "from": "qgbinm2",
            "to": "zhoffc7",
            "as": "arg2"
          },
          "8dy573e": {
            "from": "8dy573e",
            "to": "mhqejl5",
            "as": "target"
          },
          "args": {
            "from": "args",
            "to": "out",
            "as": "args"
          },
          "rrgshuq": {
            "from": "rrgshuq",
            "to": "zhoffc7",
            "as": "arg3"
          },
          "chkprox": {
            "from": "chkprox",
            "to": "rrgshuq",
            "as": "children"
          },
          "5hesw9s": {
            "from": "5hesw9s",
            "to": "chkprox",
            "as": "array"
          },
          "49od031": {
            "from": "49od031",
            "to": "chkprox",
            "as": "fn"
          },
          "h1z2zqq": {
            "from": "h1z2zqq",
            "to": "xiv2pw0",
            "as": "value"
          },
          "znw0jq1": {
            "from": "znw0jq1",
            "to": "49od031",
            "as": "fn"
          },
          "xiv2pw0": {
            "from": "xiv2pw0",
            "to": "znw0jq1",
            "as": "props"
          },
          "yx1sv0e": {
            "from": "yx1sv0e",
            "to": "49od031",
            "as": "parameters"
          },
          "zk03lef": {
            "from": "zk03lef",
            "to": "yx1sv0e",
            "as": "element"
          },
          "23vrr6n": {
            "from": "23vrr6n",
            "to": "znw0jq1",
            "as": "children"
          },
          "md80upr": {
            "from": "md80upr",
            "to": "drkjew9",
            "as": "event"
          },
          "zhoffc7": {
            "from": "zhoffc7",
            "to": "8dy573e",
            "as": "children"
          },
          "4zueto7": {
            "from": "4zueto7",
            "to": "qgbinm2",
            "as": "props"
          },
          "5ndg5og": {
            "from": "5ndg5og",
            "to": "4zueto7",
            "as": "type"
          },
          "10ozygd": {
            "from": "10ozygd",
            "to": "4zueto7",
            "as": "onchange"
          },
          "6zb4hho": {
            "from": "6zb4hho",
            "to": "6c04ryh",
            "as": "files"
          },
          "6c04ryh": {
            "from": "6c04ryh",
            "to": "10ozygd",
            "as": "fn"
          },
          "d4sx4ej": {
            "from": "d4sx4ej",
            "to": "6c04ryh",
            "as": "name"
          },
          "drkjew9": {
            "from": "drkjew9",
            "to": "10ozygd",
            "as": "parameters"
          },
          "12i36ht": {
            "from": "12i36ht",
            "to": "args",
            "as": "_asset"
          },
          "gwslf7p": {
            "from": "gwslf7p",
            "to": "rrgshuq",
            "as": "props"
          },
          "g6loz00": {
            "from": "g6loz00",
            "to": "gwslf7p",
            "as": "onchange"
          },
          "7ny91r3": {
            "from": "7ny91r3",
            "to": "vg773lv",
            "as": "asset"
          },
          "vg773lv": {
            "from": "vg773lv",
            "to": "jhyu5pk",
            "as": "value"
          },
          "jhyu5pk": {
            "from": "jhyu5pk",
            "to": "g6loz00",
            "as": "args"
          },
          "gnuhmpf": {
            "from": "gnuhmpf",
            "to": "g6loz00",
            "as": "fn"
          },
          "dh814lx": {
            "from": "dh814lx",
            "to": "gwslf7p",
            "as": "value"
          },
          "mhqejl5": {
            "from": "mhqejl5",
            "to": "out",
            "as": "value"
          },
          "b9gbfro": {
            "from": "b9gbfro",
            "to": "1090db5",
            "as": "true"
          },
          "riqk7hm": {
            "from": "riqk7hm",
            "to": "1090db5",
            "as": "pred"
          },
          "xuyat95": {
            "from": "xuyat95",
            "to": "1090db5",
            "as": "false"
          },
          "9ucfrui": {
            "from": "9ucfrui",
            "to": "xuyat95",
            "as": "true"
          },
          "mk4gru0": {
            "from": "mk4gru0",
            "to": "xuyat95",
            "as": "pred"
          },
          "g7ew1lp": {
            "from": "g7ew1lp",
            "to": "9ucfrui",
            "as": "fn"
          },
          "nhruqy5": {
            "from": "nhruqy5",
            "to": "9ucfrui",
            "as": "run"
          },
          "1ts2j8n": {
            "from": "1ts2j8n",
            "to": "9ucfrui",
            "as": "args"
          },
          "gzki6r1": {
            "from": "gzki6r1",
            "to": "1ts2j8n",
            "as": "value"
          },
          "l7ahauw": {
            "from": "l7ahauw",
            "to": "gzki6r1",
            "as": "asset"
          },
          "1090db5": {
            "from": "1090db5",
            "to": "mhqejl5",
            "as": "value"
          }
        },
        "edges_in": {
          "zhoffc7": {
            "qgbinm2": {
              "from": "qgbinm2",
              "to": "zhoffc7",
              "as": "arg2"
            },
            "rrgshuq": {
              "from": "rrgshuq",
              "to": "zhoffc7",
              "as": "arg3"
            }
          },
          "mhqejl5": {
            "8dy573e": {
              "from": "8dy573e",
              "to": "mhqejl5",
              "as": "target"
            },
            "1090db5": {
              "from": "1090db5",
              "to": "mhqejl5",
              "as": "value"
            }
          },
          "out": {
            "args": {
              "from": "args",
              "to": "out",
              "as": "args"
            },
            "mhqejl5": {
              "from": "mhqejl5",
              "to": "out",
              "as": "value"
            }
          },
          "rrgshuq": {
            "chkprox": {
              "from": "chkprox",
              "to": "rrgshuq",
              "as": "children"
            },
            "gwslf7p": {
              "from": "gwslf7p",
              "to": "rrgshuq",
              "as": "props"
            }
          },
          "chkprox": {
            "5hesw9s": {
              "from": "5hesw9s",
              "to": "chkprox",
              "as": "array"
            },
            "49od031": {
              "from": "49od031",
              "to": "chkprox",
              "as": "fn"
            }
          },
          "xiv2pw0": {
            "h1z2zqq": {
              "from": "h1z2zqq",
              "to": "xiv2pw0",
              "as": "value"
            }
          },
          "49od031": {
            "znw0jq1": {
              "from": "znw0jq1",
              "to": "49od031",
              "as": "fn"
            },
            "yx1sv0e": {
              "from": "yx1sv0e",
              "to": "49od031",
              "as": "parameters"
            }
          },
          "znw0jq1": {
            "xiv2pw0": {
              "from": "xiv2pw0",
              "to": "znw0jq1",
              "as": "props"
            },
            "23vrr6n": {
              "from": "23vrr6n",
              "to": "znw0jq1",
              "as": "children"
            }
          },
          "yx1sv0e": {
            "zk03lef": {
              "from": "zk03lef",
              "to": "yx1sv0e",
              "as": "element"
            }
          },
          "drkjew9": {
            "md80upr": {
              "from": "md80upr",
              "to": "drkjew9",
              "as": "event"
            }
          },
          "8dy573e": {
            "zhoffc7": {
              "from": "zhoffc7",
              "to": "8dy573e",
              "as": "children"
            }
          },
          "qgbinm2": {
            "4zueto7": {
              "from": "4zueto7",
              "to": "qgbinm2",
              "as": "props"
            }
          },
          "4zueto7": {
            "5ndg5og": {
              "from": "5ndg5og",
              "to": "4zueto7",
              "as": "type"
            },
            "10ozygd": {
              "from": "10ozygd",
              "to": "4zueto7",
              "as": "onchange"
            }
          },
          "6c04ryh": {
            "6zb4hho": {
              "from": "6zb4hho",
              "to": "6c04ryh",
              "as": "files"
            },
            "d4sx4ej": {
              "from": "d4sx4ej",
              "to": "6c04ryh",
              "as": "name"
            }
          },
          "10ozygd": {
            "6c04ryh": {
              "from": "6c04ryh",
              "to": "10ozygd",
              "as": "fn"
            },
            "drkjew9": {
              "from": "drkjew9",
              "to": "10ozygd",
              "as": "parameters"
            }
          },
          "args": {
            "12i36ht": {
              "from": "12i36ht",
              "to": "args",
              "as": "_asset"
            }
          },
          "gwslf7p": {
            "g6loz00": {
              "from": "g6loz00",
              "to": "gwslf7p",
              "as": "onchange"
            },
            "dh814lx": {
              "from": "dh814lx",
              "to": "gwslf7p",
              "as": "value"
            }
          },
          "vg773lv": {
            "7ny91r3": {
              "from": "7ny91r3",
              "to": "vg773lv",
              "as": "asset"
            }
          },
          "jhyu5pk": {
            "vg773lv": {
              "from": "vg773lv",
              "to": "jhyu5pk",
              "as": "value"
            }
          },
          "g6loz00": {
            "jhyu5pk": {
              "from": "jhyu5pk",
              "to": "g6loz00",
              "as": "args"
            },
            "gnuhmpf": {
              "from": "gnuhmpf",
              "to": "g6loz00",
              "as": "fn"
            }
          },
          "1090db5": {
            "b9gbfro": {
              "from": "b9gbfro",
              "to": "1090db5",
              "as": "true"
            },
            "riqk7hm": {
              "from": "riqk7hm",
              "to": "1090db5",
              "as": "pred"
            },
            "xuyat95": {
              "from": "xuyat95",
              "to": "1090db5",
              "as": "false"
            }
          },
          "xuyat95": {
            "9ucfrui": {
              "from": "9ucfrui",
              "to": "xuyat95",
              "as": "true"
            },
            "mk4gru0": {
              "from": "mk4gru0",
              "to": "xuyat95",
              "as": "pred"
            }
          },
          "9ucfrui": {
            "g7ew1lp": {
              "from": "g7ew1lp",
              "to": "9ucfrui",
              "as": "fn"
            },
            "nhruqy5": {
              "from": "nhruqy5",
              "to": "9ucfrui",
              "as": "run"
            },
            "1ts2j8n": {
              "from": "1ts2j8n",
              "to": "9ucfrui",
              "as": "args"
            }
          },
          "1ts2j8n": {
            "gzki6r1": {
              "from": "gzki6r1",
              "to": "1ts2j8n",
              "as": "value"
            }
          },
          "gzki6r1": {
            "l7ahauw": {
              "from": "l7ahauw",
              "to": "gzki6r1",
              "as": "asset"
            }
          }
        }
      },
      "fit": {
        "id": "fit",
        "out": "out",
        "nodes": {
          "args": {
            "id": "args"
          },
          "qgbinm2": {
            "id": "qgbinm2",
            "value": "Hello, world!",
            "ref": "html_text"
          },
          "8dy573e": {
            "id": "8dy573e",
            "ref": "html_element"
          },
          "output_val": {
            "id": "output_val",
            "value": "const ap0 = a0 === undefined ? 0 : a0;\nconst bp0 = b0 === undefined ? 1 : b0;\nconst lerp = (x - ap0) / (bp0 - ap0);\nconst result = a1 + lerp * (b1 - a1);\nreturn clamp ? Math.min(Math.max(result, Math.min(a1, b1)), Math.max(a1, b1)) : result",
            "ref": "script"
          },
          "out": {
            "id": "out",
            "name": "fit",
            "ref": "return"
          },
          "5locpe3": {
            "id": "5locpe3",
            "value": "oldLow",
            "ref": "arg"
          },
          "a8kr545": {
            "id": "a8kr545",
            "value": "oldHigh",
            "ref": "arg"
          },
          "s9mrg9v": {
            "id": "s9mrg9v",
            "value": "newLow",
            "ref": "arg"
          },
          "y1hnt8t": {
            "id": "y1hnt8t",
            "value": "newHigh",
            "ref": "arg"
          },
          "fma0geo": {
            "id": "fma0geo",
            "value": "value",
            "ref": "arg"
          },
          "s351p91": {
            "id": "s351p91",
            "value": "clamp",
            "ref": "arg"
          }
        },
        "edges": {
          "qgbinm2": {
            "from": "qgbinm2",
            "to": "8dy573e",
            "as": "children"
          },
          "8dy573e": {
            "from": "8dy573e",
            "to": "out",
            "as": "display"
          },
          "output_val": {
            "from": "output_val",
            "to": "out",
            "as": "value"
          },
          "args": {
            "from": "args",
            "to": "out",
            "as": "args"
          },
          "5locpe3": {
            "from": "5locpe3",
            "to": "output_val",
            "as": "a0"
          },
          "a8kr545": {
            "from": "a8kr545",
            "to": "output_val",
            "as": "b0"
          },
          "s9mrg9v": {
            "from": "s9mrg9v",
            "to": "output_val",
            "as": "a1"
          },
          "y1hnt8t": {
            "from": "y1hnt8t",
            "to": "output_val",
            "as": "b1"
          },
          "fma0geo": {
            "from": "fma0geo",
            "to": "output_val",
            "as": "x"
          },
          "s351p91": {
            "from": "s351p91",
            "to": "output_val",
            "as": "clamp"
          }
        },
        "edges_in": {
          "8dy573e": {
            "qgbinm2": {
              "from": "qgbinm2",
              "to": "8dy573e",
              "as": "children"
            }
          },
          "out": {
            "8dy573e": {
              "from": "8dy573e",
              "to": "out",
              "as": "display"
            },
            "output_val": {
              "from": "output_val",
              "to": "out",
              "as": "value"
            },
            "args": {
              "from": "args",
              "to": "out",
              "as": "args"
            }
          },
          "output_val": {
            "5locpe3": {
              "from": "5locpe3",
              "to": "output_val",
              "as": "a0"
            },
            "a8kr545": {
              "from": "a8kr545",
              "to": "output_val",
              "as": "b0"
            },
            "s9mrg9v": {
              "from": "s9mrg9v",
              "to": "output_val",
              "as": "a1"
            },
            "y1hnt8t": {
              "from": "y1hnt8t",
              "to": "output_val",
              "as": "b1"
            },
            "fma0geo": {
              "from": "fma0geo",
              "to": "output_val",
              "as": "x"
            },
            "s351p91": {
              "from": "s351p91",
              "to": "output_val",
              "as": "clamp"
            }
          }
        }
      },
      "switch_inputs": {
        "id": "switch_inputs",
        "out": "out",
        "nodes": {
          "args": {
            "id": "args"
          },
          "8dy573e": {
            "id": "8dy573e",
            "ref": "html_element"
          },
          "out": {
            "id": "out",
            "name": "switch_inputs_local",
            "ref": "return"
          },
          "6280gtl": {
            "id": "6280gtl",
            "ref": "get"
          },
          "gqi2qi3": {
            "id": "gqi2qi3",
            "value": "select",
            "ref": "html_element"
          },
          "9r6mj9s": {
            "id": "9r6mj9s"
          },
          "8f9x43u": {
            "id": "8f9x43u",
            "ref": "ap"
          },
          "2j5rxq0": {
            "id": "2j5rxq0"
          },
          "q0h1zer": {
            "id": "q0h1zer",
            "value": "event.target.value",
            "ref": "arg"
          },
          "hyw65dk": {
            "id": "hyw65dk",
            "value": "_chosen.set",
            "ref": "arg"
          },
          "ddhrxjw": {
            "id": "ddhrxjw",
            "ref": "map"
          },
          "4ujfj58": {
            "id": "4ujfj58",
            "value": 'return (object instanceof Map ? [...object.keys()] : Object.keys(object)).filter(k => !k.startsWith("_"))',
            "ref": "script"
          },
          "s35ms5l": {
            "id": "s35ms5l",
            "value": "_args",
            "ref": "arg"
          },
          "jdajqk3": {
            "id": "jdajqk3",
            "ref": "runnable"
          },
          "evpcvvi": {
            "id": "evpcvvi",
            "value": "option",
            "ref": "html_element"
          },
          "86zvrx4": {
            "id": "86zvrx4",
            "value": "element",
            "ref": "arg"
          },
          "m24351r": {
            "id": "m24351r"
          },
          "1s77djh": {
            "id": "1s77djh",
            "value": "element",
            "ref": "arg"
          },
          "65wrg0t": {
            "id": "65wrg0t",
            "ref": "state"
          },
          "y5r6re6": {
            "id": "y5r6re6",
            "value": "_args",
            "ref": "arg"
          },
          "0adxu2g": {
            "id": "0adxu2g"
          },
          "vz8dmxf": {
            "id": "vz8dmxf"
          },
          "77z7u64": {
            "id": "77z7u64",
            "ref": "ap"
          },
          "4w1wh15": {
            "id": "4w1wh15",
            "value": "true"
          },
          "fob1r0t": {
            "id": "fob1r0t",
            "value": "_chosen.state",
            "ref": "arg"
          },
          "7uzzghh": {
            "id": "7uzzghh",
            "value": "_chosen.state",
            "ref": "arg"
          },
          "meoy2m1": {
            "id": "meoy2m1",
            "ref": "default"
          },
          "p53f7fz": {
            "id": "p53f7fz",
            "value": 'return (args instanceof Map ? [...args.keys()] : Object.keys(args)).filter(k => !k.startsWith("_"))[0];',
            "ref": "script"
          },
          "c8500l8": {
            "id": "c8500l8",
            "value": "_args",
            "ref": "arg"
          },
          "dqzwfa3": {
            "id": "dqzwfa3",
            "ref": "default"
          },
          "y1oibqk": {
            "id": "y1oibqk",
            "value": 'return (args instanceof Map ? [...args.keys()] : Object.keys(args)).filter(k => !k.startsWith("_"))[0];',
            "ref": "script"
          },
          "pbl7fry": {
            "id": "pbl7fry",
            "value": "_args",
            "ref": "arg"
          }
        },
        "edges": {
          "8dy573e": {
            "from": "8dy573e",
            "to": "out",
            "as": "display"
          },
          "args": {
            "from": "args",
            "to": "out",
            "as": "args"
          },
          "6280gtl": {
            "from": "6280gtl",
            "to": "77z7u64",
            "as": "fn"
          },
          "ddhrxjw": {
            "from": "ddhrxjw",
            "to": "gqi2qi3",
            "as": "children"
          },
          "9r6mj9s": {
            "from": "9r6mj9s",
            "to": "gqi2qi3",
            "as": "props"
          },
          "8f9x43u": {
            "from": "8f9x43u",
            "to": "9r6mj9s",
            "as": "onchange"
          },
          "hyw65dk": {
            "from": "hyw65dk",
            "to": "8f9x43u",
            "as": "fn"
          },
          "2j5rxq0": {
            "from": "2j5rxq0",
            "to": "8f9x43u",
            "as": "args"
          },
          "q0h1zer": {
            "from": "q0h1zer",
            "to": "2j5rxq0",
            "as": "value"
          },
          "jdajqk3": {
            "from": "jdajqk3",
            "to": "ddhrxjw",
            "as": "fn"
          },
          "4ujfj58": {
            "from": "4ujfj58",
            "to": "ddhrxjw",
            "as": "array"
          },
          "s35ms5l": {
            "from": "s35ms5l",
            "to": "4ujfj58",
            "as": "object"
          },
          "evpcvvi": {
            "from": "evpcvvi",
            "to": "jdajqk3",
            "as": "fn"
          },
          "m24351r": {
            "from": "m24351r",
            "to": "evpcvvi",
            "as": "props"
          },
          "86zvrx4": {
            "from": "86zvrx4",
            "to": "evpcvvi",
            "as": "children"
          },
          "1s77djh": {
            "from": "1s77djh",
            "to": "m24351r",
            "as": "value"
          },
          "gqi2qi3": {
            "from": "gqi2qi3",
            "to": "8dy573e",
            "as": "children"
          },
          "65wrg0t": {
            "from": "65wrg0t",
            "to": "args",
            "as": "_chosen"
          },
          "y5r6re6": {
            "from": "y5r6re6",
            "to": "6280gtl",
            "as": "target"
          },
          "0adxu2g": {
            "from": "0adxu2g",
            "to": "jdajqk3",
            "as": "parameters"
          },
          "vz8dmxf": {
            "from": "vz8dmxf",
            "to": "0adxu2g",
            "as": "element"
          },
          "77z7u64": {
            "from": "77z7u64",
            "to": "out",
            "as": "value"
          },
          "4w1wh15": {
            "from": "4w1wh15",
            "to": "77z7u64",
            "as": "run"
          },
          "fob1r0t": {
            "from": "fob1r0t",
            "to": "dqzwfa3",
            "as": "value"
          },
          "7uzzghh": {
            "from": "7uzzghh",
            "to": "meoy2m1",
            "as": "value"
          },
          "meoy2m1": {
            "from": "meoy2m1",
            "to": "6280gtl",
            "as": "path"
          },
          "c8500l8": {
            "from": "c8500l8",
            "to": "p53f7fz",
            "as": "args"
          },
          "p53f7fz": {
            "from": "p53f7fz",
            "to": "meoy2m1",
            "as": "otherwise"
          },
          "dqzwfa3": {
            "from": "dqzwfa3",
            "to": "9r6mj9s",
            "as": "arg0"
          },
          "pbl7fry": {
            "from": "pbl7fry",
            "to": "y1oibqk",
            "as": "args"
          },
          "y1oibqk": {
            "from": "y1oibqk",
            "to": "dqzwfa3",
            "as": "otherwise"
          }
        }
      },
      "store_file": {
        "id": "store_file",
        "category": "nodysseus",
        "nodes": [
          {
            "id": "args"
          },
          {
            "id": "8dy573e",
            "ref": "html_element"
          },
          {
            "id": "arcnyff",
            "ref": "array"
          },
          {
            "id": "qgbinm2",
            "value": "Upload a json file",
            "ref": "html_text"
          },
          {
            "id": "rtrp3nj",
            "value": "input",
            "ref": "html_element"
          },
          {
            "id": "vnibm4q"
          },
          {
            "id": "07fjn2b",
            "value": "file"
          },
          {
            "id": "jmqcpll",
            "ref": "runnable"
          },
          {
            "id": "o9ukwn8",
            "value": "event.target.files.0",
            "ref": "arg"
          },
          {
            "id": "out",
            "name": "store_file",
            "ref": "return"
          },
          {
            "id": "1672j69",
            "value": "arrayBuffer",
            "ref": "call"
          },
          {
            "id": "qzp14wr",
            "value": "add_asset",
            "ref": "extern"
          },
          {
            "id": "v99fk3p",
            "ref": "array"
          },
          {
            "id": "y58g8pm",
            "value": "img",
            "ref": "html_element"
          },
          {
            "id": "pldugnx"
          },
          {
            "id": "ceomp2r",
            "ref": "array"
          },
          {
            "id": "uyspmvr",
            "value": "get_asset",
            "ref": "extern"
          },
          {
            "id": "psxdib2",
            "ref": "return"
          },
          {
            "id": "nxdj21x"
          },
          {
            "id": "gsrb9e6"
          },
          {
            "id": "4j186m3",
            "value": "50vh"
          },
          {
            "id": "rdt0k55",
            "value": "image/*"
          },
          {
            "id": "gi30q1h"
          },
          {
            "id": "0clgvk2",
            "value": "event.target.files.0.type",
            "ref": "arg"
          },
          {
            "id": "yj9sw4x",
            "value": "asset",
            "ref": "arg"
          },
          {
            "id": "c0gcfke",
            "value": "asset.data",
            "ref": "arg"
          },
          {
            "id": "qh60wjb",
            "value": "asset.type",
            "ref": "arg"
          },
          {
            "id": "ncih0ts",
            "value": "asset_id",
            "ref": "arg"
          },
          {
            "id": "zugbd71",
            "ref": "if"
          },
          {
            "id": "fmostjp",
            "value": "get_asset",
            "ref": "extern"
          },
          {
            "id": "hj6upcm",
            "ref": "array"
          },
          {
            "id": "eviegts",
            "value": "asset_id",
            "ref": "arg"
          },
          {
            "id": "kldqqu0",
            "value": "asset.type",
            "ref": "arg"
          },
          {
            "id": "ic7fy1m",
            "value": "asset.data",
            "ref": "arg"
          },
          {
            "id": "yx80n2x",
            "ref": "return"
          },
          {
            "id": "2qd7694",
            "value": "const blob = new Blob([data], {type: filetype})\nconst url = URL.createObjectURL(blob);\nreturn url",
            "ref": "script"
          },
          {
            "id": "5mfdcg0"
          },
          {
            "id": "izkowx6",
            "ref": "default"
          },
          {
            "id": "i6lfbjh",
            "value": "__graph_value",
            "ref": "arg"
          },
          {
            "id": "b444vmf",
            "ref": "default"
          },
          {
            "id": "lpet497",
            "value": "asset_id",
            "ref": "arg"
          },
          {
            "id": "lkz76u7",
            "value": "__graph_value",
            "ref": "arg"
          },
          {
            "id": "6t8kqs9",
            "ref": "default"
          },
          {
            "id": "ke8lvin",
            "value": "__graph_value",
            "ref": "arg"
          },
          {
            "id": "j7ct5iw",
            "value": "const blob = new Blob([data], {type: filetype})\nconst url = URL.createObjectURL(blob);\nreturn url",
            "ref": "script"
          }
        ],
        "edges": [
          {
            "from": "8dy573e",
            "to": "out",
            "as": "display"
          },
          {
            "from": "args",
            "to": "out",
            "as": "args"
          },
          {
            "from": "arcnyff",
            "to": "8dy573e",
            "as": "children"
          },
          {
            "from": "rtrp3nj",
            "to": "arcnyff",
            "as": "arg1"
          },
          {
            "from": "vnibm4q",
            "to": "rtrp3nj",
            "as": "props"
          },
          {
            "from": "07fjn2b",
            "to": "vnibm4q",
            "as": "type"
          },
          {
            "from": "rdt0k55",
            "to": "vnibm4q",
            "as": "accept"
          },
          {
            "from": "jmqcpll",
            "to": "vnibm4q",
            "as": "onchange"
          },
          {
            "from": "o9ukwn8",
            "to": "1672j69",
            "as": "self"
          },
          {
            "from": "qzp14wr",
            "to": "jmqcpll",
            "as": "fn"
          },
          {
            "from": "v99fk3p",
            "to": "qzp14wr",
            "as": "args"
          },
          {
            "from": "y58g8pm",
            "to": "arcnyff",
            "as": "arg2"
          },
          {
            "from": "ceomp2r",
            "to": "uyspmvr",
            "as": "args"
          },
          {
            "from": "nxdj21x",
            "to": "psxdib2",
            "as": "args"
          },
          {
            "from": "qgbinm2",
            "to": "arcnyff",
            "as": "arg0"
          },
          {
            "from": "psxdib2",
            "to": "pldugnx",
            "as": "src"
          },
          {
            "from": "pldugnx",
            "to": "y58g8pm",
            "as": "props"
          },
          {
            "from": "gsrb9e6",
            "to": "pldugnx",
            "as": "style"
          },
          {
            "from": "4j186m3",
            "to": "gsrb9e6",
            "as": "max-width"
          },
          {
            "from": "gi30q1h",
            "to": "v99fk3p",
            "as": "arg1"
          },
          {
            "from": "1672j69",
            "to": "gi30q1h",
            "as": "data"
          },
          {
            "from": "0clgvk2",
            "to": "gi30q1h",
            "as": "type"
          },
          {
            "from": "qh60wjb",
            "to": "j7ct5iw",
            "as": "filetype"
          },
          {
            "from": "c0gcfke",
            "to": "j7ct5iw",
            "as": "data"
          },
          {
            "from": "j7ct5iw",
            "to": "zugbd71",
            "as": "true"
          },
          {
            "from": "yj9sw4x",
            "to": "zugbd71",
            "as": "pred"
          },
          {
            "from": "yx80n2x",
            "to": "out",
            "as": "value"
          },
          {
            "from": "uyspmvr",
            "to": "nxdj21x",
            "as": "asset"
          },
          {
            "from": "zugbd71",
            "to": "psxdib2",
            "as": "value"
          },
          {
            "from": "hj6upcm",
            "to": "fmostjp",
            "as": "args"
          },
          {
            "from": "kldqqu0",
            "to": "2qd7694",
            "as": "filetype"
          },
          {
            "from": "ic7fy1m",
            "to": "2qd7694",
            "as": "data"
          },
          {
            "from": "2qd7694",
            "to": "yx80n2x",
            "as": "value"
          },
          {
            "from": "5mfdcg0",
            "to": "yx80n2x",
            "as": "args"
          },
          {
            "from": "fmostjp",
            "to": "5mfdcg0",
            "as": "asset"
          },
          {
            "from": "izkowx6",
            "to": "ceomp2r",
            "as": "arg0"
          },
          {
            "from": "i6lfbjh",
            "to": "izkowx6",
            "as": "otherwise"
          },
          {
            "from": "ncih0ts",
            "to": "izkowx6",
            "as": "value"
          },
          {
            "from": "lkz76u7",
            "to": "b444vmf",
            "as": "otherwise"
          },
          {
            "from": "lpet497",
            "to": "b444vmf",
            "as": "value"
          },
          {
            "from": "b444vmf",
            "to": "v99fk3p",
            "as": "arg0"
          },
          {
            "from": "6t8kqs9",
            "to": "hj6upcm",
            "as": "arg0"
          },
          {
            "from": "eviegts",
            "to": "6t8kqs9",
            "as": "value"
          },
          {
            "from": "ke8lvin",
            "to": "6t8kqs9",
            "as": "otherwise"
          }
        ],
        "out": "out"
      }
    },
    "edges": {}
  };
  Object.values(generic.nodes).map((graph) => {
    if (graph.nodes && Array.isArray(graph.nodes)) {
      graph.nodes = Object.fromEntries(graph.nodes.map((g) => [g.id, g]));
      graph.edges = Object.fromEntries(graph.edges.map((e) => [e.from, e]));
    }
  });
  var generic_default = generic;

  // src/externs.ts
  var create_fn = (runnable, lib) => {
    const graph = ancestor_graph(runnable.fn, runnable.graph, lib.data);
    const graphArgs = new Set(Object.values(graph.nodes).filter(isNodeRef).filter((n2) => n2.ref === "arg").map((a2) => a2.value));
    const argToProperties = (arg) => arg.includes(".") ? arg.split(".").join('"]?.["') : arg;
    const baseArgs = resolve_args(new Map([...graphArgs].map((a2) => [a2, nodysseus_get(runnable.env, a2, lib)])), lib, { resolvePromises: true });
    const create8 = ({ value: baseArgs2 }) => {
      graph.id = runnable.fn + "-fn";
      let text3 = "";
      const _extern_args = {};
      Object.values(graph.nodes).forEach((n2) => {
        if (isNodeRef(n2) && n2.ref === "arg") {
          return;
        }
        const noderef = isNodeRef(n2) ? lib.data.no.runtime.get_ref(n2.ref) : n2;
        if (noderef.id === "script") {
          let inputs = Object.values(graph.edges_in[n2.id] ?? []).map((edge) => ({ edge, node: Object.values(graph.nodes).find((n3) => n3.id === edge.from) }));
          text3 += `function fn_${n2.id}(){
${inputs.map((input) => `let ${input.edge.as} = ${isNodeRef(input.node) && input.node.ref === "arg" ? `fnargs["${argToProperties(input.node.value)}"] ?? baseArgs["${argToProperties(input.node.value)}"]` : `fn_${input.node.id}()`};`).join("\n")}

${isNodeScript(n2) ? n2.script : n2.value}}

`;
        } else if (noderef.ref == "extern") {
          _extern_args[n2.id] = {};
          const extern = nodysseus_get(lib.data, noderef.value, lib);
          let inputs = Object.values(graph.edges_in[n2.id] ?? []).map((edge) => ({ edge, node: Object.values(graph.nodes).find((n3) => n3.id === edge.from) }));
          const varset = [];
          extern.args.map((a2) => {
            if (a2 === "__graph_value" || a2 === "_node") {
              _extern_args[n2.id][a2] = a2 === "__graph_value" ? !isNodeScript(n2) ? n2.value : void 0 : "_node" ? n2 : void 0;
              varset.push(`let ${a2} = _extern_args["${n2.id}"]["${a2}"];`);
            } else if (a2 === "_node_args") {
              varset.push(`let ${a2} = {
${inputs.map((input) => `${input.edge.as}: ${isNodeRef(input.node) && input.node.ref === "arg" ? `(fnargs["${argToProperties(input.node.value)}"] ?? baseArgs.${input.node.value})` : `fn_${input.edge.from}()`}`).join(",\n")}};`);
            } else {
              const input = inputs.find((i) => i.edge.as === a2);
              if (!input) {
                varset.push(`let ${a2} = undefined;`);
              } else {
                const inputNode = Object.values(graph.nodes).find((n3) => n3.id === input.edge.from);
                varset.push(`let ${a2} = ${isNodeRef(inputNode) && inputNode.ref === "arg" ? `(fnargs["${argToProperties(input.edge.as)}"] ?? baseArgs.${input.edge.as})` : `fn_${input.edge.from}()`};`);
              }
            }
          });
          text3 += `function fn_${n2.id}(){
${varset.join("\n")}
return (${extern.fn.toString()})(${extern.args.join(", ")})}

`;
        } else if (noderef.id === "get") {
          let inputs = Object.values(graph.edges_in[n2.id] ?? []).map((edge) => ({ edge, node: Object.values(graph.nodes).find((n3) => n3.id === edge.from) }));
          text3 += `function fn_${n2.id}(){
${inputs.map((input) => `let ${input.edge.as} = ${isNodeRef(input.node) && input.node.ref === "arg" ? input.node.value === "_lib" ? "_lib" : `(fnargs["${argToProperties(input.node.value)}"] ?? baseArgs.${input.node.value})` : `fn_${input.node.id}()`};`).join("\n")}

return target["${argToProperties(isNodeRef(n2) ? n2.value : "undefined")}"]}

`;
        } else {
          text3 += `function fn_${n2.id}(){
return ${noderef.value}}

`;
        }
      });
      const fninputs = graph.edges_in[runnable.fn];
      text3 += `return fn_${runnable.fn}()`;
      const fn = new Function("fnargs", "baseArgs", "_extern_args", "import_util", "_lib", text3);
      return (args2) => fn(args2 ? isArgs(args2) ? resolve_args(args2, lib, {}).value : isEnv(args2) ? resolve_args(args2.data, lib, {}).value : args2 : {}, baseArgs2, _extern_args, util_exports, lib.data);
    };
    return wrapPromise(baseArgs).then((r) => isError(r) ? r : create8(r)).value;
  };
  var now = (scale) => performance.now() * (scale ?? 1);
  var expect = (a2, b, value) => {
    if (a2 === b)
      return a2;
    else {
      console.log("a:");
      console.log(a2);
      console.log("b:");
      console.log(b);
      throw new Error(`${value}: Value a does not match value b`);
    }
  };

  // src/nodysseus.ts
  var generic_nodes = generic_default.nodes;
  var Nodysseus = () => {
    const isBrowser2 = typeof window !== "undefined";
    const persistdb = new import_lokijs.default("nodysseus_persist.db", {
      env: isBrowser2 ? "BROWSER" : "NODEJS",
      persistenceMethod: "memory"
    });
    const refsdb = persistdb.addCollection("refs", { unique: ["id"] });
    const db = new import_lokijs.default("nodysseus.db", {
      env: isBrowser2 ? "BROWSER" : "NODEJS",
      persistenceMethod: "memory"
    });
    return {
      refs: {
        ...lokidbToStore(refsdb),
        add_node: () => {
        },
        add_nodes_edges: () => {
        },
        remove_edge: () => {
        },
        add_edge: () => {
        },
        remove_node: () => {
        }
      },
      parents: mapStore(),
      state: mapStore(),
      fns: mapStore(),
      assets: {
        get: (id3) => {
          throw new Error("not implemented");
        },
        set: (id3, value) => {
          throw new Error("not implemented");
        },
        delete: (id3) => {
          throw new Error("not implemented");
        },
        clear: () => {
          throw new Error("not implemented");
        },
        keys: () => {
          throw new Error("not implemented");
        }
      },
      persist: {
        get: (id3) => {
          throw new Error("not implemented");
        },
        set: (id3, value) => {
          throw new Error("not implemented");
        },
        delete: (id3) => {
          throw new Error("not implemented");
        },
        clear: () => {
          throw new Error("not implemented");
        },
        keys: () => {
          throw new Error("not implemented");
        }
      }
    };
  };
  var mapStore = () => {
    const map3 = /* @__PURE__ */ new Map();
    return {
      get: (id3) => map3.get(id3),
      set: (id3, data2) => map3.set(id3, data2),
      delete: (id3) => map3.delete(id3),
      clear: () => map3.clear(),
      keys: () => [...map3.keys()]
    };
  };
  var lokidbToStore = (collection) => ({
    set: (id3, data2) => {
      const existing = collection.by("id", id3);
      if (existing) {
        collection.update(Object.assign(existing, { data: data2 }));
      } else {
        collection.insert({ id: id3, data: data2 });
      }
    },
    get: (id3) => collection.by("id", id3)?.data,
    delete: (id3) => {
      const existing = collection.by("id", id3);
      if (existing !== void 0) {
        collection.remove(existing);
      }
    },
    clear: () => collection.clear(),
    keys: () => collection.where((_) => true).map((v) => v.id)
  });
  var nodysseus;
  var resfetch = typeof fetch !== "undefined" ? fetch : (urlstr, params2) => import("node:https").then((https) => new Promise((resolve2, reject2) => {
    const url = new URL(urlstr);
    const req = https.request({
      hostname: url.hostname,
      port: url.port,
      path: url.pathname + url.search,
      headers: params2.headers,
      method: params2.method.toUpperCase()
    }, async (response) => {
      const buffer = [];
      for await (const chunk of response) {
        buffer.push(chunk);
      }
      const data2 = Buffer.concat(buffer).toString();
      resolve2(data2);
    });
    if (params2.body) {
      req.write(params2.body);
    }
    req.end();
  }));
  function set_mutable(obj, propsArg, value) {
    var props, lastProp;
    if (Array.isArray(propsArg)) {
      props = propsArg.slice(0);
    }
    if (typeof propsArg == "string") {
      props = propsArg.split(".");
    }
    if (typeof propsArg == "symbol") {
      props = [propsArg];
    }
    if (!Array.isArray(props)) {
      throw new Error("props arg must be an array, a string or a symbol");
    }
    lastProp = props.pop();
    if (!lastProp) {
      return false;
    }
    var thisProp;
    while (thisProp = props.shift()) {
      if (typeof obj[thisProp] == "undefined") {
        obj[thisProp] = {};
      }
      obj = obj[thisProp];
      if (!obj || typeof obj != "object") {
        return false;
      }
    }
    obj[lastProp] = value;
    return true;
  }
  var nodysseus_get = (obj, propsArg, lib, defaultValue = void 0, props = [], options = {}) => {
    let objArg = obj;
    obj = isEnv(obj) ? obj.data : obj;
    let level = 0;
    if (!obj) {
      return defaultValue;
    }
    const naive = isArgs(obj) ? obj.get(propsArg) : obj[propsArg];
    if (naive !== void 0) {
      return naive;
    }
    var prop;
    if (props.length === 0) {
      if (typeof propsArg == "string") {
        if (propsArg.includes(".")) {
          props = propsArg.split(".");
        } else {
          props.push(propsArg);
        }
      }
      if (typeof propsArg == "symbol" || typeof propsArg === "number") {
        props.push(propsArg);
      }
    }
    if (!Array.isArray(props)) {
      throw new Error("props arg must be an array, a string or a symbol");
    }
    while (props.length) {
      if (obj && isRunnable(obj)) {
        const ran = run_runnable(obj, lib, void 0, options);
        if (ispromise(ran)) {
          obj = ran;
          continue;
        } else if (isValue(ran)) {
          obj = ran.value;
          continue;
        }
      }
      if (obj && ispromise(obj)) {
        return obj.then((r) => props.length > 0 ? nodysseus_get(r, propsArg, lib, defaultValue, props) : r);
      }
      prop = props[0];
      if (obj === void 0 || typeof obj !== "object" || !(isArgs(obj) ? obj.has(prop) : obj[prop] !== void 0 || obj.hasOwnProperty && obj.hasOwnProperty(prop))) {
        return isEnv(objArg) ? nodysseus_get(objArg.env, propsArg, lib, defaultValue, props) : defaultValue;
      }
      props.shift();
      obj = isArgs(obj) ? obj.get(prop) : obj[prop];
      if (obj && ispromise(obj)) {
        return obj.then((r) => props.length > 0 ? nodysseus_get(r, propsArg, lib, defaultValue, props) : r);
      }
      level += 1;
    }
    return obj;
  };
  function compare(value1, value2) {
    if (value1 === value2) {
      return true;
    }
    if (value1 !== value1 && value2 !== value2) {
      return true;
    }
    if (!!value1 !== !!value2) {
      return false;
    }
    if (typeof value1 !== typeof value2) {
      return false;
    }
    if (typeof value1 === "function" || typeof value2 === "function") {
      return false;
    }
    if (Array.isArray(value1)) {
      return compareArrays(value1, value2);
    }
    if (typeof value1 === "object" && typeof value2 === "object") {
      if (value1.fn && value1.fn === value2.fn && compare(value1.graph, value2.graph) && compare(value1.args, value2.args)) {
        return true;
      }
      if (value1 instanceof Map && value2 instanceof Map) {
        return compareArrays([...value1.entries()], [...value2.entries()]);
      }
      if (value1 instanceof Set && value2 instanceof Set) {
        return compareArrays(Array.from(value1), Array.from(value2));
      }
      return compareObjects(value1, value2);
    }
    return compareNativeSubrefs(value1, value2);
  }
  function compareNativeSubrefs(value1, value2) {
    return value1.toString() === value2.toString();
  }
  function compareArrays(value1, value2) {
    var len = value1.length;
    if (len != value2.length) {
      return false;
    }
    var alike = true;
    for (var i = 0; i < len; i++) {
      if (!compare(value1[i], value2[i])) {
        alike = false;
        break;
      }
    }
    return alike;
  }
  var hashcode = function(str, seed = 0) {
    let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
    let i = str.length, ch;
    while (i > 0) {
      i--;
      ch = str.charCodeAt(i);
      h1 = Math.imul(h1 ^ ch, 2654435761);
      h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
    h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
    return 4294967296 * (2097151 & h2) + (h1 >>> 0);
  };
  var NodysseusError = class extends Error {
    node_id;
    constructor(node_id, ...params2) {
      super(...params2);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, NodysseusError);
      }
      this.node_id = node_id;
    }
  };
  var node_value = (node) => {
    if (typeof node.value !== "string") {
      return node.value;
    }
    if (node.value === "undefined") {
      return void 0;
    }
    if (typeof node.value === "string") {
      if (node.value.startsWith('"') && node.value.endsWith('"')) {
        return node.value.substring(1, node.value.length - 1);
      }
      if (node.value.startsWith("{") || node.value.startsWith("[")) {
        try {
          return JSON.parse(node.value.replaceAll("'", '"'));
        } catch (e) {
        }
      }
      if (node.value.startsWith("0x")) {
        const int = parseInt(node.value);
        if (!isNaN(int)) {
          return int;
        }
      }
      if (node.value.match(/-?[0-9.]*/g)[0].length === node.value.length) {
        const float = parseFloat(node.value);
        if (!isNaN(float)) {
          return float;
        }
      }
      if (node.value === "false" || node.value === "true") {
        return node.value === "true";
      }
    }
    return node.value;
  };
  var node_nodes = (node, node_id, data2, graph_input_value, lib, options) => {
    return run_graph(node, node_id, combineEnv(data2, graph_input_value, node_id, graph_input_value._output), lib, options);
  };
  var node_script = (node, nodeArgs, lib, options) => {
    let orderedargs = ["", ...nodeArgs.keys()].join(", ");
    const data2 = resolve_args(nodeArgs, lib, options.resolvePromises ? options : { ...options, resolvePromises: true });
    const name2 = node.name ? node.name.replace(/\W/g, "_") : node.id;
    const fn = lib.data.no.runtime.get_fn(node.id, name2, orderedargs, node.script ?? node.value);
    return wrapPromise(data2).then((promisedData) => lib.data.no.of(fn.apply(null, [lib.data, node, data2, ...Object.values(isError(promisedData) ? promisedData : promisedData?.value ?? {})]))).value;
  };
  var run_extern = (extern, data2, lib, options, node, graphArgs) => {
    if (graphArgs?._output && graphArgs._output !== "value" && !extern.outputs?.[graphArgs._output]) {
      return void 0;
    }
    let argColonIdx;
    let argspromise = false;
    const isArgsArray = Array.isArray(extern.args);
    const externArgs = isArgsArray ? extern.args.map((a2) => {
      argColonIdx = a2.indexOf(":");
      return [argColonIdx >= 0 ? a2.substring(0, argColonIdx) : a2, "any"];
    }) : Object.entries(extern.args);
    const args2 = typeof extern === "function" ? resolve_args(data2, lib, options) : externArgs.map(([arg, argType]) => {
      let newval;
      if (arg === "_node") {
        newval = node;
      } else if (arg === "_node_args") {
        newval = extern.rawArgs ? data2 : resolve_args(data2, lib, options);
        newval = ispromise(newval) ? newval.then((v) => isError(v) ? v : v?.value) : extern.rawArgs ? newval : newval.value;
      } else if (arg == "_lib") {
        newval = lib;
      } else if (arg == "_graph_input_value") {
        newval = graphArgs;
      } else if (arg == "_runoptions") {
        newval = options;
      } else if (arg == "__graphid") {
        newval = graphArgs.data.get("__graphid").value;
      } else if (arg == "_output") {
        newval = graphArgs._output;
      } else {
        newval = extern.rawArgs ? data2.get(arg) : run_runnable(data2.get(arg), lib, /* @__PURE__ */ new Map(), options);
        while (isConstRunnable(newval) && !extern.rawArgs) {
          newval = run_runnable(newval, lib, /* @__PURE__ */ new Map(), options);
        }
        newval = ispromise(newval) ? newval.then((v) => isError(v) ? v : v?.value) : newval && !extern.rawArgs ? newval.value : newval;
      }
      argspromise ||= ispromise(newval);
      return newval;
    });
    argspromise ||= ispromise(args2);
    if (argspromise && !extern.promiseArgs) {
      return (Array.isArray(args2) ? Promise.all(args2) : args2.then((v) => isValue(v) ? v.value.args : v)).then((as) => {
        const res = (typeof extern === "function" ? extern : extern.fn).apply(null, isArgsArray ? as : [Object.fromEntries(externArgs.map((a2, idx) => [a2[0], as[idx]]))]);
        return mapMaybePromise(res, (res2) => extern.rawArgs ? res2 : lib.data.no.of(res2));
      });
    } else if (!ispromise(args2)) {
      const resArgs = Array.isArray(args2) ? args2 : isValue(args2) ? args2.value.args : args2;
      const res = (typeof extern === "function" ? extern : extern.fn).apply(null, isArgsArray ? resArgs : [Object.fromEntries(externArgs.map((a2, idx) => [a2[0], resArgs[idx]]))]);
      return mapMaybePromise(res, (res2) => extern.rawArgs ? res2 : lib.data.no.of(res2));
    }
  };
  var node_extern = (node, data2, graphArgs, lib, options) => {
    const libExternFn = node.value.startsWith("extern.") && node.value.substring(7);
    return run_extern(libExternFn ? lib.data.extern[libExternFn] : nodysseus_get(lib.data, node.value, lib), data2, lib, options, node, graphArgs);
  };
  var resolve_args = (data2, lib, options) => {
    let is_promise = false;
    const result = {};
    for (let k of data2.keys()) {
      let val = data2.get(k);
      const resarg = (argval) => wrapPromise(isValue(argval) ? argval.value : argval).then((runnable) => isConstRunnable(runnable) ? resarg(run_runnable(runnable, lib, void 0, options)) : runnable).value;
      val = resarg(val);
      if (val instanceof Error) {
        return val;
      }
      is_promise = is_promise || !!val && ispromise(val);
      result[k] = val;
    }
    if (is_promise && options.resolvePromises) {
      const promises2 = [];
      Object.entries(result).forEach((kv) => {
        promises2.push(Promise.resolve(kv[1]).then((pv) => isError(pv) ? pv : [kv[0], isValue(pv) ? pv?.value : pv]));
      });
      return Promise.all(promises2).then(Object.fromEntries).then((v) => lib.data.no.of(v));
    }
    for (let k of Object.keys(result)) {
      if (k.startsWith("__")) {
        delete result[k];
      } else if (isValue(result[k])) {
        result[k] = result[k].value;
      }
    }
    return lib.data.no.of(result);
  };
  var node_data = (nodeArgs, graphArgs, lib, options) => {
    return nodeArgs.size === 0 ? lib.data.no.of(void 0) : resolve_args(nodeArgs, lib, options);
  };
  var createFunctorRunnable = (fn, parameters, lib, options) => {
    const argsval = parameters && run_runnable(parameters, lib, void 0, options);
    const ret = fn && mapMaybePromise(argsval, (args2) => isError(args2) ? args2 : lib.data.no.of({
      __kind: FUNCTOR,
      parameters: args2 ? [...new Set(args2.value ? Object.keys(args2.value).map((k) => k.includes(".") ? k.substring(0, k.indexOf(".")) : k) : [])] : [],
      env: fn.env,
      graph: fn.graph,
      fn: fn.fn,
      lib: fn.lib
    }));
    return ret;
  };
  var run_runnable = (runnable, lib, args2 = /* @__PURE__ */ new Map(), options = {}) => {
    if (runnable === void 0 || isError(runnable)) {
      return runnable;
    }
    switch (runnable.__kind) {
      case CONST:
        return wrapPromise(
          run_graph(runnable.graph, runnable.fn, mergeEnv(args2, runnable.env), runnable.lib, options),
          (e) => handleError(e, lib, runnable.env, runnable.graph, runnable.fn)
        ).value;
      case AP:
        return run_ap_runnable(runnable, args2, lib, options);
      case FUNCTOR:
        return wrapPromise(
          run_functor_runnable(runnable, args2, lib, options),
          (e) => handleError(e, lib, runnable.env, runnable.graph, runnable.fn)
        ).value;
    }
    return runnable;
  };
  var run_node = (node, nodeArgs, graphArgs, lib, options) => {
    if (isRunnable(node)) {
      if (isError(node)) {
        return node;
      } else if (isValue(node)) {
        return node;
      } else if (isApRunnable(node)) {
        throw new Error("Unexpected node");
      } else {
        const graphid = graphArgs.data.get("__graphid").value;
        const nodegraphargs = node.env ?? newEnv(/* @__PURE__ */ new Map(), graphArgs._output);
        nodegraphargs.data.set("__graphid", graphid ?? lib.data.no.of(node.graph.id));
        lib = mergeLib(node.lib, lib);
        return node_nodes(node.graph, node.fn, nodeArgs, nodegraphargs, lib, options);
      }
    } else if (isNodeRef(node)) {
      if (node.ref === "arg") {
        const resval = nolib.no.arg(node, graphArgs, lib, node.value, options);
        return wrapPromise(resval).then((resval2) => resval2 && typeof resval2 === "object" && isValue(resval2) ? resval2 : lib.data.no.of(resval2)).value;
      } else if (node.ref === "extern") {
        return node_extern(node, nodeArgs, graphArgs, lib, options);
      } else if (node.ref === "script") {
        return (graphArgs._output === void 0 || graphArgs._output === "value") && node_script(node, nodeArgs, lib, options);
      }
      const graphid = graphArgs.data.get("__graphid").value;
      const newgraphid = `${graphid}/${node.id}`;
      const newGraphArgs = newEnv((/* @__PURE__ */ new Map()).set("__graphid", lib.data.no.of(newgraphid)), graphArgs._output);
      return wrapPromise(lib.data.no.runtime.get_ref(node.ref), (e) => handleError(e, lib, graphArgs, graphid, node)).then((node_ref) => {
        if (!node_ref) {
          throw new Error(`Unable to find ref ${node.ref} for node ${node.name || node.id}`);
        }
        lib.data.no.runtime.set_parent(newgraphid, graphid);
        const result = run_node(node_ref, node.value ? new Map(nodeArgs).set("__graph_value", lib.data.no.of(node.value)) : nodeArgs, newGraphArgs, lib, options);
        return result;
      }).value;
    } else if (isNodeGraph(node)) {
      return node_nodes(node, node.out ?? "out", nodeArgs, graphArgs, lib, options);
    } else if (isNodeScript(node)) {
      return node_script(node, nodeArgs, lib, options);
    } else if (Object.hasOwn(node, "value")) {
      return lib.data.no.of(node_value(node));
    } else {
      return node_data(nodeArgs, graphArgs, lib, options);
    }
  };
  var create_data = (node_id, graph, graphArgs, lib, options) => {
    return wrapPromise(lib.data.no.runtime.get_edges_in(graph, node_id)).then((inputs) => {
      const data2 = /* @__PURE__ */ new Map();
      let input;
      const newgraphargs = graphArgs._output ? mergeEnv((/* @__PURE__ */ new Map()).set("_output", void 0), graphArgs) : graphArgs;
      for (let i = 0; i < inputs.length; i++) {
        input = inputs[i];
        const val = { __kind: CONST, graph, fn: input.from, env: newgraphargs, lib };
        if (data2.has(input.as)) {
          const as_set = /* @__PURE__ */ new Set();
          inputs.forEach((e) => {
            if (as_set.has(e.as)) {
              throw new NodysseusError(nodysseus_get(graphArgs, "__graphid", lib, void 0, void 0, options).value + "/" + node_id, `Multiple input edges have the same label "${e.as}"`);
            }
            as_set.add(e.as);
          });
        }
        data2.set(input.as, val);
      }
      return data2;
    }).value;
  };
  var handleError = (e, lib, env, graph, node) => {
    console.log(`error in node`);
    if (e instanceof AggregateError) {
      e.errors.map(console.error);
    } else {
      console.error(e);
    }
    if (e instanceof NodysseusError) {
      lib.data.no.runtime.publish("grapherror", e);
      return e;
    }
    const parentest = lib.data.no.runtime.get_parentest(graph);
    let error_node = parentest ? graph : node;
    lib.data.no.runtime.publish("grapherror", new NodysseusError(
      nodysseus_get(env, "__graphid", lib)?.value + "/" + error_node.id,
      e instanceof AggregateError ? "Error in node chain" : e
    ));
    return e;
  };
  var run_graph = (graph, node_id, env, lib, options) => {
    const newgraph = graph;
    const node = lib.data.no.runtime.get_node(newgraph, node_id);
    if (!node) {
      return;
    }
    try {
      return wrapPromise(node).then((node2) => wrapPromise(create_data(node_id, newgraph, env, lib, options)).then((data2) => ({ node: node2, data: data2 })).value).then(({ node: node2, data: data2 }) => {
        const graphid = env.data.get("__graphid").value;
        if (!graphid.includes("/")) {
          lib.data.no.runtime.publish("noderun", { graph: newgraph, node_id });
        }
        if (options.profile && !nolib.no.runtime.get_parentest(env.data.get("__graphid").value)) {
          const edgePath = (edge) => {
            const edgeout = nolib.no.runtime.get_edge_out(newgraph, edge);
            return edgeout && !ispromise(edgeout) ? [nolib.no.runtime.get_edge_out(newgraph, edge).as].concat(edgePath(nolib.no.runtime.get_edge_out(newgraph, edge).to)) : ["promise"];
          };
          let path = edgePath(node_id).reverse().join(" -> ");
          let start = performance.now();
          const id3 = `${path} - ${env.data.get("__graphid").value}/${node2.id} (${node2.ref})`;
          if (!options.timings) {
            options.timings = {};
          }
          const result = run_node(node2, data2, env, lib, options);
          const isResPromise = ispromise(result);
          if (!ispromise(result) && options?.profile && id3) {
            options.timings[id3] = (options.timings[id3] ?? 0) + (performance.now() - start);
          }
          return isResPromise && options.profile && id3 ? result.then((v) => {
            options.timings[id3] = (options.timings[id3] ?? 0) + (performance.now() - start);
            return v;
          }) : result;
        } else {
          return run_node(node2, data2, env, lib, options);
        }
      }).value;
    } catch (e) {
      return handleError(e, lib, env, graph, node);
    }
  };
  var run_functor_runnable = (runnable, args2, lib, options) => {
    const execArgs = new Map(runnable.parameters?.map((k) => [k, nodysseus_get(args2, k, lib)]) ?? []);
    const newRunnable = {
      __kind: CONST,
      env: combineEnv((execArgs ?? /* @__PURE__ */ new Map()).set("__graphid", runnable.env.data.get("__graphid")), runnable.env, runnable.fn),
      fn: runnable.fn,
      graph: runnable.graph,
      lib: runnable.lib
    };
    return run_runnable(newRunnable, lib, void 0, options);
  };
  var run_ap_runnable = (runnable, args2, lib, options) => {
    return wrapPromise(isRunnable(runnable.args) ? run_runnable(runnable.args, lib, args2, { ...options, resolvePromises: false }) : lib.data.no.of(runnable.args?.data ?? args2)).then((ranArgs) => {
      const execArgs = isValue(ranArgs) ? ranArgs.value instanceof Map ? ranArgs.value : new Map([...Object.entries(ranArgs.value)].filter((kv) => kv[0] !== "__graphid").map((kv) => [kv[0], lib.data.no.of(kv[1])])) : ranArgs instanceof Map ? ranArgs : /* @__PURE__ */ new Map();
      const ret = (Array.isArray(runnable.fn) ? runnable.fn : [runnable.fn]).map((rfn) => {
        return typeof rfn === "function" ? wrapPromise(rfn(execArgs)).then((r) => lib.data.no.of(r)).value : isApFunction(rfn) ? run_extern(rfn, execArgs, lib, options) : run_runnable(
          rfn,
          runnable.lib,
          execArgs,
          options
        );
      });
      return Array.isArray(runnable.fn) ? wrapPromiseAll(ret.map((v) => wrapPromise(v))) : wrapPromise(ret[0]);
    }).then((v) => {
      return isError(v) ? v : v?.value;
    }).value;
  };
  var getorset = (map3, id3, value_fn = void 0) => {
    let val = map3.get(id3);
    if (val) {
      return val;
    } else {
      let val2 = value_fn();
      if (val2 !== void 0) {
        map3.set(id3, val2);
      }
      return val2;
    }
  };
  var initStore = (store = void 0) => {
    if (store !== void 0) {
      nodysseus = store;
    } else if (!nodysseus) {
      nodysseus = Nodysseus();
    }
    if (!nolib.no.runtime) {
      nolib.no.runtime = nolib.no.runtimefn();
    }
  };
  var run = (node, args2 = /* @__PURE__ */ new Map(), options = {}) => {
    initStore(options.store ?? nodysseus);
    let _lib = mergeLib(options.lib, newLib(nolib));
    if (isRunnable(node)) {
      if (isValue(node)) {
        return node.value;
      } else if (isError(node)) {
        return node;
      }
    }
    isRunnable(node) && isFunctorRunnable(node) && !_lib.data.no.runtime.get_ref(node.graph.id) && _lib.data.no.runtime.change_graph(node.graph);
    if (!(args2 instanceof Map)) {
      args2 = new Map(Object.entries(args2));
    }
    const res = run_runnable(
      isRunnable(node) ? { ...node, lib: node.lib ? mergeLib(node.lib, _lib) : _lib } : {
        ...node,
        __kind: CONST,
        env: node.env ?? newEnv((/* @__PURE__ */ new Map()).set("__graphid", _lib.data.no.of(node.graph.id))),
        lib: mergeLib(node.lib, _lib)
      },
      _lib,
      args2,
      options
    );
    return wrapPromise(res).then((r) => isValue(r) ? r?.value : r).then((v) => (options.profile && console.log(JSON.stringify(options.timings, null, 2)), isArgs(v) ? Object.fromEntries(v) : v)).value;
  };
  var nolib = {
    no: {
      of: (value) => ispromise(value) ? value.then(nolib.no.of) : isValue(value) ? value : { __kind: "result", value },
      arg: (node, target, lib, value, options) => {
        value = node.value;
        let valuetype, nodevalue;
        let colonIdx = value.indexOf(":");
        if (colonIdx >= 0) {
          nodevalue = value.substring(0, colonIdx);
          valuetype = value.substring(colonIdx + 2);
        } else {
          nodevalue = value;
        }
        const newtarget = () => {
          const newt = new Map(target.data);
          for (let k in newt) {
            if (k.startsWith("_")) {
              newt.delete(k);
            }
          }
          return newt;
        };
        const parenttarget = () => {
          const newt = new Map(target.env.data);
          for (let k in newt) {
            if (k.startsWith("_")) {
              newt.delete(k);
            }
          }
          return newt;
        };
        const ret = nodevalue === void 0 || target === void 0 ? void 0 : nodevalue === "_node" ? node : nodevalue.startsWith("_node.") ? node[nodevalue.substring("_node.".length)] : nodevalue.startsWith("_lib.") ? nodysseus_get(lib.data, nodevalue.substring("_lib.".length), lib) : nodevalue === "_args" ? newtarget() : nodevalue === "__args" ? parenttarget() : nodysseus_get(
          node.type === "local" || node.type?.includes?.("local") ? newtarget() : node.type === "parent" || node.type?.includes?.("parent") ? target.env : target,
          nodevalue,
          lib
        );
        let resolveret = (rr) => wrapPromise(rr).then((rrr) => isValue(rrr) ? rrr.value : rrr).then((rrr) => isConstRunnable(rrr) && valuetype !== "raw" ? resolveret(run_runnable(rrr, lib, /* @__PURE__ */ new Map(), options)) : rrr).value;
        return resolveret(ret);
      },
      base_graph,
      base_node,
      NodysseusError,
      runtime: void 0,
      wrapPromise,
      runtimefn: function() {
        const polyfillRequestAnimationFrame = requestAnimationFrame;
        Object.values(generic_nodes).forEach((graph) => {
          if (isNodeGraph(graph)) {
            graph.edges_in = Object.values(graph.edges).reduce((acc, edge) => ({ ...acc, [edge.to]: { ...acc[edge.to] ?? {}, [edge.from]: edge } }), {});
          }
        });
        const event_listeners = /* @__PURE__ */ new Map();
        const event_listeners_by_graph = /* @__PURE__ */ new Map();
        const event_data = /* @__PURE__ */ new Map();
        let animationframe;
        let animationerrors = [];
        let pause = false;
        let eventsBroadcastChannel = new BroadcastChannel("events");
        let clientUuid = typeof crypto === "undefined" ? Math.random().toFixed(4).substring(2) : crypto.randomUUID();
        eventsBroadcastChannel.onmessage = (message) => {
          runpublish(message.data.data, message.data.event, nolib);
        };
        const runpublish = (data2, event, lib, options = {}, broadcast = true) => {
          if (event.startsWith("bc")) {
            event = event.substring(3);
          } else if (broadcast && event !== "noderun" && event !== "animationframe" && event !== "show_all") {
            try {
              if (typeof window !== "undefined" && !event.startsWith("graph")) {
                eventsBroadcastChannel.postMessage({ source: clientUuid, event: `bc-${event}`, data: data2 });
              } else if (event === "grapherror") {
                eventsBroadcastChannel.postMessage({ source: clientUuid, event: `bc-${event}`, data: { message: data2.message, node_id: data2.node_id, stack: data2.stack } });
              }
            } catch (e) {
              console.error(e);
            }
          }
          event_data.set(event, data2);
          const listeners = getorset(event_listeners, event, () => /* @__PURE__ */ new Map());
          if (!pause) {
            for (let l of listeners.values()) {
              if (typeof l === "function") {
                l(data2, lib, { ...options, timings: {} });
              } else if (typeof l === "object" && l.fn && l.graph) {
                run(
                  l,
                  Object.assign({}, l.args || {}, { data: data2 }),
                  { ...options, lib: mergeLib(l.lib, lib) }
                );
              }
            }
          }
          if (event === "animationframe" && listeners.size > 0 && !animationframe && animationerrors.length == 0) {
            animationframe = polyfillRequestAnimationFrame(() => {
              animationframe = false;
              publish2("animationframe", void 0, lib, options);
            });
          }
        };
        const publish2 = (event, data2, lib, options = {}, broadcast = true) => {
          if (typeof data2 === "object" && ispromise(data2)) {
            data2.then((d) => runpublish(d, event, lib, options, broadcast));
          } else {
            runpublish(data2, event, lib, options, broadcast);
          }
          return data2;
        };
        const add_listener = (event, listener_id, input_fn, remove2 = false, graph_id = false, prevent_initial_trigger = false, lib = { __kind: "lib", data: nolib }, options = {}) => {
          if (ispromise(input_fn)) {
            return input_fn.then((fn2) => add_listener(event, listener_id, fn2, remove2, graph_id, prevent_initial_trigger, lib, options));
          }
          const listeners = getorset(event_listeners, event, () => /* @__PURE__ */ new Map());
          const fn = typeof input_fn === "function" ? input_fn : (args2) => {
            run(input_fn, args2, { ...options, lib: mergeLib(input_fn.lib, lib) });
          };
          if (!listeners.has(listener_id)) {
            if (!prevent_initial_trigger) {
              polyfillRequestAnimationFrame(() => {
                if (event_data.has(event)) {
                  fn(event_data.get(event));
                }
              });
            }
            if (graph_id) {
              const graph_id_listeners = getorset(
                event_listeners_by_graph,
                graph_id,
                () => /* @__PURE__ */ new Map()
              );
              graph_id_listeners.set(event, listener_id);
            }
            if (event === "animationframe") {
              polyfillRequestAnimationFrame(() => publish2(event, void 0, lib, options));
            }
          }
          if (remove2) {
            remove_listener(event, listener_id);
          }
          listeners.set(listener_id, fn);
        };
        add_listener("grapherror", "__system", (e) => animationerrors.push(e));
        add_listener("graphchange", "__system", (e) => {
          if (animationerrors.length > 0) {
            event_listeners.get("animationframe")?.clear();
          }
          animationerrors.splice(0, animationerrors.length);
        });
        add_listener("argsupdate", "__system", ({ graphid, changes, mutate }, lib, options) => {
          if (mutate) {
            const current = nolib.no.runtime.get_args(graphid);
            changes.forEach((change2) => set_mutable(current, change2[0], change2[1]));
          } else {
            update_args(graphid, changes, lib);
          }
        });
        add_listener("cachedelete", "__system", (e) => {
          nodysseus.state.clear();
        });
        add_listener("listenersclear", "__system", (e) => {
          for (let eventListener of event_listeners.entries()) {
            if (eventListener[0] !== "__system") {
              eventListener[1].clear();
            }
          }
          event_listeners_by_graph.clear();
        });
        const remove_listener = (event, listener_id) => {
          if (event === "*") {
            [...event_listeners.values()].forEach((e) => e.delete(listener_id));
          } else {
            const listeners = getorset(event_listeners, event, () => /* @__PURE__ */ new Map());
            listeners.delete(listener_id);
          }
        };
        const remove_graph_listeners = (graph_id, event) => {
          const graph_listeners = (graph_id === "*" ? [...event_listeners_by_graph.values()] : [event_listeners_by_graph.get(graph_id)]).filter((gl) => gl).map((gl) => [...gl.entries()]).flat();
          if (graph_listeners) {
            for (const evt of graph_listeners) {
              getorset(event_listeners, evt[0])?.delete(evt[1]);
            }
          }
        };
        const change_graph = (graph, lib, addToStore = true) => {
          const parent = get_parentest(graph);
          if (parent) {
            (lib.data ?? lib).no.runtime.update_graph(parent, lib);
          } else {
            publish2("graphchange", graph, lib);
            publish2("graphupdate", graph, lib);
          }
        };
        let updatepublish = {};
        const update_args = (graph, args2, lib) => {
          const graphid = typeof graph === "string" ? graph : graph.id;
          let prevargs = nodysseus.state.get(graphid);
          if (prevargs === void 0) {
            prevargs = {};
            nodysseus.state.set(graphid, prevargs);
          }
          if (!compareObjects(args2, prevargs, true)) {
            Object.assign(prevargs, args2);
            const updatedgraph = get_parentest(graphid) ?? get_graph(graphid);
            if (!ispromise(updatedgraph) && (!updatepublish[updatedgraph.id] || updatepublish[updatedgraph.id] + 16 < performance.now())) {
              updatepublish[updatedgraph.id] = performance.now();
              requestAnimationFrame(() => {
                updatepublish[updatedgraph.id] = false;
                publish2("graphupdate", updatedgraph, lib);
              });
            }
          }
        };
        const get_ref = (id3, otherwise) => {
          return wrapPromise(generic_nodes[id3] ?? nodysseus.refs.get(id3)).then((graph) => {
            return graph ?? (otherwise && nodysseus.refs.set(id3, { ...otherwise, id: id3, nodes: { ...otherwise.nodes, [otherwise.out ?? "out"]: { ...otherwise.nodes[otherwise.out ?? "out"], name: id3 } } }));
          }).value;
        };
        const add_ref = (graph) => {
          return (Array.isArray(graph) ? graph : [graph]).map((graph2) => {
            if (generic_nodes[graph2.id] === void 0) {
              return nodysseus.refs.set(graph2.id, graph2);
            }
          })[0];
        };
        const remove_ref = (id3) => {
          if (nodysseus.refs.keys().includes(id3)) {
            nodysseus.refs.delete(id3);
          } else {
            nodysseus.refs.keys().filter((k) => k.startsWith(`@${id3}`)).forEach((k) => nodysseus.refs.delete(k));
          }
        };
        const get_node = (graph, id3) => wrapPromise(get_graph(graph)).then((g) => g?.nodes[id3]).value;
        const get_edge = (graph, from3) => wrapPromise(get_graph(graph)).then((g) => g?.edges[from3]).value;
        const get_edges_in = (graph, id3) => wrapPromise(get_graph(graph)).then((g) => {
          if (!g.edges_in) {
            g.edges_in = Object.values(g.edges).reduce((acc, edge) => ({ ...acc, [edge.to]: { ...acc[edge.to] ?? {}, [edge.from]: edge } }), {});
          }
          const idEdgesIn = g.edges_in?.[id3];
          if (idEdgesIn !== void 0) {
            return Object.values(idEdgesIn);
          } else if (g.edges_in === void 0) {
            return Object.values(g.edges).filter((e) => e.to === id3);
          }
          return [];
        }).value;
        const get_edge_out = get_edge;
        const get_args = (graph) => nodysseus.state.get(typeof graph === "string" ? graph : graph.id) ?? {};
        const get_graph = (graph) => wrapPromise(
          nodysseus.refs.get(typeof graph === "string" ? graph : graph.id)
        ).then((g) => {
          return isNodeGraph(g) ? g : typeof graph !== "string" && isNodeGraph(graph) ? graph : void 0;
        }).value;
        const get_parent = (graph) => {
          const parent = nodysseus.parents.get(
            typeof graph === "string" ? graph : graph.id
          );
          return parent ? get_graph(parent.parent) : void 0;
        };
        const get_parentest = (graph) => {
          const parent = nodysseus.parents.get(
            typeof graph === "string" ? graph : graph.id
          );
          return parent && parent.parentest && get_graph(parent.parentest);
        };
        const get_path = (graph, path) => {
          graph = get_graph(graph);
          let pathSplit = path.split(".");
          let node = graph.out || "out";
          while (pathSplit.length > 0 && node) {
            let pathval = pathSplit.shift();
            const edge = get_edges_in(graph, node).find((e) => e.as === pathval);
            node = edge ? edge.from : void 0;
          }
          return node;
        };
        return {
          run,
          get_ref,
          add_ref,
          add_refs: (gs) => gs.forEach((g) => nodysseus.refs.set(g.id, g)),
          remove_ref,
          get_node,
          get_edge,
          get_edges_in,
          get_edge_out,
          get_parent,
          get_parentest,
          get_fn: (id3, name2, orderedargs, script) => {
            const fnid = id3;
            let fn = nodysseus.fns.get(fnid + orderedargs);
            if (!fn || fn.script !== script) {
              const update = !!fn;
              fn = Object.assign(fn ?? {}, {
                script,
                fn: new Function(
                  `return function _${name2.replace(
                    /(\s|\/)/g,
                    "_"
                  )}(_lib, _node, _graph_input_value${orderedargs}){${script}}`
                )()
              });
              nodysseus.fns.set(fnid + orderedargs, fn);
            }
            return fn.fn;
          },
          change_graph,
          update_graph: (graphid, lib) => publish2("graphupdate", { graphid }, lib),
          update_args,
          delete_cache: () => {
            publish2("cachedelete", {}, newLib(nolib));
          },
          clearListeners: () => {
            publish2("listenersclear", {}, newLib(nolib));
          },
          get_graph,
          get_args,
          get_path,
          add_asset: (id3, b) => nolib.no.runtime.store.assets.set(id3, b),
          get_asset: (id3, b) => id3 && nolib.no.runtime.store.assets.get(id3),
          list_assets: () => nolib.no.runtime.store.assets.keys(),
          remove_asset: (id3) => nolib.no.runtime.store.assets.remove(id3),
          refs: () => nodysseus.refs.keys(),
          ref_graphs: () => nodysseus.refs.keys(),
          update_edges: (graph, add3, remove2 = [], lib, dryRun = false) => {
            const graphId = typeof graph === "string" ? graph : graph.id;
            if (Array.isArray(remove2)) {
              remove2.map((e) => nodysseus.refs.remove_edge(graphId, e));
            } else if (typeof remove2 === "object") {
              nodysseus.refs.remove_edge(graphId, remove2);
            }
            if (Array.isArray(add3)) {
              add3.map((e) => nodysseus.refs.add_edge(graphId, e));
            } else if (typeof add3 === "object") {
              nodysseus.refs.add_edge(graphId, add3);
            }
            change_graph(nodysseus.refs.get(graphId), lib);
          },
          add_node: (graph, node, lib) => {
            if (!(node && typeof node === "object" && node.id)) {
              throw new Error(`Invalid node: ${JSON.stringify(node)}`);
            }
            const graphId = typeof graph === "string" ? graph : graph.id;
            nodysseus.refs.add_node(graphId, node);
            change_graph(nodysseus.refs.get(graphId), lib);
          },
          add_nodes_edges: (graph, nodes, edges, remove_edges, remove_nodes, lib) => {
            const graphId = typeof graph === "string" ? graph : graph.id;
            nodysseus.refs.add_nodes_edges(graphId, nodes, edges, remove_edges, remove_nodes);
            change_graph(nodysseus.refs.get(graphId), lib);
          },
          delete_node: (graph, id3, lib, changeEdges = true) => {
            wrapPromise(get_graph(graph)).then((graph2) => {
              const graphId = typeof graph2 === "string" ? graph2 : graph2.id;
              const parent_edge = (lib.data ?? lib).no.runtime.get_edge_out(graphId, id3);
              const child_edges = (lib.data ?? lib).no.runtime.get_edges_in(graphId, id3);
              const current_child_edges = (lib.data ?? lib).no.runtime.get_edges_in(graphId, parent_edge.to);
              const new_child_edges = child_edges.map((e, i) => ({
                ...e,
                to: parent_edge.to,
                as: i === 0 ? parent_edge.as : !e.as ? e.as : current_child_edges.find(
                  (ce) => ce.as === e.as && ce.from !== id3
                ) ? e.as + "1" : e.as
              }));
              const newnodes = { ...graph2.nodes };
              delete newnodes[id3];
              nodysseus.refs.remove_node(graphId, id3);
              if (changeEdges !== void 0) {
                child_edges.map((e) => nodysseus.refs.remove_edge(graphId, e));
                new_child_edges.map((e) => nodysseus.refs.add_edge(graphId, e));
                change_graph(nodysseus.refs.get(graphId), lib);
              }
            });
          },
          add_listener,
          add_listener_extern: {
            args: ["event", "listener_id", "fn"],
            add_listener
          },
          remove_listener,
          remove_graph_listeners,
          togglePause: (newPause) => pause = newPause,
          publish: publish2,
          set_parent: (graph, parent) => {
            const graphid = graph;
            const parentid = parent;
            const parent_parent = nodysseus.parents.get(parentid);
            const parentest = (parent_parent ? parent_parent.parentest : false) || parentid;
            const new_parent = {
              id: graphid,
              parent: parentid,
              parentest
            };
            nodysseus.parents.set(graphid, new_parent);
          },
          undo: (id3) => nodysseus.refs.undo && nodysseus.refs.undo(id3),
          redo: (id3) => nodysseus.refs.redo && nodysseus.refs.redo(id3),
          store: nodysseus
        };
      }
    },
    extern: {
      ap: {
        rawArgs: true,
        promiseArgs: true,
        args: ["fn", "args", "run", "_lib"],
        fn: (fn, args2, run2, lib) => {
          const resolveRunnable = (runnable) => (isRunnable(runnable) && isConstRunnable(runnable) ? wrapPromise(run_runnable(runnable, lib)).then((r) => resolveRunnable(isValue(r) ? r.value : r)) : wrapPromise(runnable)).then((r) => isValue(r) ? r.value : r).value;
          const apRunnable = (fnRunnable, run3) => ({
            __kind: AP,
            fn: Array.isArray(fnRunnable) ? fnRunnable.filter((v) => v) : fnRunnable,
            args: args2 ?? (run3 ? fn.env : void 0),
            lib
          });
          return wrapPromise(run_runnable(fn, lib)).then((fnr) => isValue(fnr) ? Array.isArray(fnr.value) ? fnr.value.map((fnrv) => resolveRunnable(fnrv)) : resolveRunnable(fnr) : fnr).then((fnr) => !(Array.isArray(fnr) ? fnr : [fnr]).filter((fnrv) => fnrv).every(isApFunctorLike) ? fnr : run2 ? run_runnable(apRunnable(fnr, run2), lib) : apRunnable(fnr, run2)).then((res) => lib.data.no.of(res)).value;
        }
      },
      create_fn: {
        args: ["runnable", "_lib"],
        fn: create_fn
      },
      switch: {
        rawArgs: true,
        args: ["input", "_node_args", "_lib", "_runoptions"],
        fn: (input, args2, lib, options) => {
          const inputval = run_runnable(input, lib, void 0, options);
          return ispromise(inputval) ? inputval.then((ival) => isError(ival) ? ival : run_runnable(isArgs(args2) ? args2.get(ival?.value) : args2[ival?.value], lib, void 0, options)) : isError(inputval) ? inputval : run_runnable(args2.get(inputval?.value), lib, void 0, options);
        }
      },
      resolve: {
        rawArgs: false,
        args: ["object", "_lib"],
        fn: (object2, lib) => {
          return Object.fromEntries(Object.entries(object2).map((e) => [e[0], run_runnable(e[1], lib)]));
        }
      },
      map: {
        rawArgs: true,
        args: ["fn", "array", "_lib", "_runoptions"],
        fn: (fn, array2, lib, options) => wrapPromise(run_runnable(array2, lib, void 0, options)).then((arr) => isValue(arr) ? arr.value : arr).then((arr) => Array.isArray(arr) ? wrapPromise(run_runnable(fn, lib, void 0, options)).then((fnr) => isError(fnr) ? fnr : fnr.value).then((fnr) => isApFunctorLike(fnr) ? wrapPromiseAll(arr.map(
          (element2, index2) => typeof fnr === "function" ? fnr(mergeEnv(/* @__PURE__ */ new Map([["element", lib.data.no.of(element2)], ["index", lib.data.no.of(index2)]]), fn.env)) : run_runnable(fnr, lib, /* @__PURE__ */ new Map([["element", lib.data.no.of(element2)], ["index", lib.data.no.of(index2)]]), options)
        ).map((v) => wrapPromise(v).then((v2) => isValue(v2) ? v2.value : v2))).then((vs) => lib.data.no.of(vs)) : isError(fnr) ? fnr : arr) : arr).value
      },
      fold: {
        rawArgs: true,
        args: ["fn", "object", "initial", "_lib", "_runoptions"],
        fn: (fn, object2, initial, lib, options) => wrapPromise(run_runnable(object2, lib, void 0, options)).then((ov) => isError(ov) ? ov : ov.value).then((objectvalue) => objectvalue === void 0 ? void 0 : isError(objectvalue) ? objectvalue : wrapPromise(run_runnable(fn, lib, void 0, options)).then((fnr) => isError(fnr) ? fnr : fnr.value).then((fnrunnable) => wrapPromise(run_runnable(initial, lib, void 0, options)).then((initial2) => isError(initial2) ? initial2 : initial2.value).then((initial2) => {
          const mapobjarr = (mapobj, mapfn, mapinit) => typeof mapobj.reduce === "function" ? mapobj.reduce(mapfn, mapinit) : Object.entries(mapobj).sort((a2, b) => a2[0].localeCompare(b[0])).reduce(mapfn, mapinit);
          initial2 = initial2 ?? (typeof objectvalue.reduce === "function" ? [] : {});
          let errored = false;
          const errorlistener = (error) => errored = true;
          const ret = mapobjarr(
            objectvalue,
            (previousValue, currentValue) => !errored && wrapPromise(previousValue).then((prevVal) => {
              const args2 = (/* @__PURE__ */ new Map()).set("previousValue", lib.data.no.of(prevVal)).set("currentValue", lib.data.no.of(currentValue));
              return typeof fnrunnable === "function" ? fnrunnable(args2) : run_runnable(
                fnrunnable,
                lib,
                args2,
                options
              );
            }).then((rv) => {
              if (isError(rv)) {
                errored = true;
                return rv;
              }
              return rv.value;
            }).value,
            initial2
          );
          return lib.data.no.of(ret);
        }))).value
      },
      _sequence: {
        args: ["_node_args", "_lib", "__graphid"],
        fn: (_args, lib, graphid) => {
          return lib.data.extern.ap.fn(lib.data.no.of(Object.values(_args)), void 0, lib.data.no.of(false), lib);
        }
      },
      runnable: {
        rawArgs: true,
        args: ["fn", "parameters", "_lib", "_runoptions"],
        fn: createFunctorRunnable
      },
      expect: {
        args: ["a", "b", "__graph_value"],
        fn: expect
      },
      entries: {
        args: ["object"],
        fn: (obj) => {
          return Object.entries(obj);
        }
      },
      fromEntries: {
        args: ["entries"],
        fn: (entries) => {
          return Object.fromEntries(entries);
        }
      },
      refval: {
        rawArgs: true,
        outputs: {
          display: true
        },
        args: ["onframe", "_lib", "__graphid", "_runoptions", "_output", "initial", "publish"],
        fn: (onframe, lib, graphid, options, output, initial, publish2) => {
          const args2 = lib.data.no.runtime.get_args(graphid);
          let store = args2["store"] ?? {
            graphid,
            set: {
              __kind: "apFunction",
              fn: (value) => {
                if (store["publish"]) {
                  lib.data.no.runtime.publish("argsupdate", { graphid, changes: [["store.value", value]], mutate: true }, lib, options);
                } else {
                  store["value"] = value;
                }
                return value;
              },
              args: ["value"]
            },
            publish: wrapPromise(run_runnable(publish2, lib, void 0, options)).then((p) => isValue(p) ? p.value : p).then((p) => {
              const args3 = lib.data.no.runtime.get_args(graphid)["store"];
              if (args3) {
                args3["publish"] = p;
              }
              return p;
            }).value,
            value: void 0
          };
          if (!args2["store"]) {
            lib.data.no.runtime.update_args(graphid, { store }, lib);
            if (initial) {
              wrapPromise(run_runnable(initial, lib, void 0, options)).then((res) => isValue(res) ? res.value : res).then((value) => {
                store.value = value;
              }).value;
            }
          }
          return output === "display" ? { dom_type: "div", props: {}, children: [{ dom_type: "text_value", text: JSON.stringify(store.value) }] } : store;
        }
      },
      state: {
        rawArgs: true,
        outputs: {
          display: true
        },
        args: ["value", "_lib", "__graphid", "_runoptions", "_output", "persist", "publish"],
        fn: (value, lib, graphid, options, output, persist, publish2) => {
          let rawstate = lib.data.no.runtime.get_args(graphid)["state"];
          return wrapPromise(publish2 && run_runnable(publish2, lib, void 0, options)).then((publish3) => isValue(publish3) ? publish3.value : publish3).then((publish3) => wrapPromise(persist && run_runnable(persist, lib, void 0, options)).then((persist2) => isValue(persist2) ? persist2.value : persist2).then((persist2) => ({ publish: publish3, persist: persist2 })).value).then(rawstate !== void 0 ? (v) => v : ({ publish: publish3, persist: persist2 }) => {
            const persistedState = persist2 && rawstate === void 0 && nodysseus.persist.get(graphid);
            const initialState = wrapPromise(persistedState).then((ps) => ps ? JSON.parse(ps) : value && (rawstate === void 0 || rawstate === null) ? wrapPromise(run_runnable(value, lib, void 0, options)).then((result) => isValue(result) ? result.value : result) : void 0);
            return initialState ? initialState.then((initial) => {
              if (publish3) {
                lib.data.no.runtime.publish("argsupdate", { graphid, changes: { state: initial }, mutate: false }, lib, options, true);
              } else {
                lib.data.no.runtime.update_args(graphid, { state: initial });
              }
            }).then(() => ({ publish: publish3, persist: persist2 })).value : { publish: publish3, persist: persist2 };
          }).then(({ persist: persist2, publish: publish3 }) => wrapPromise(rawstate).then((rawstate2) => isValue(rawstate2) ? rawstate2.value : rawstate2).then((state) => ({ publish: publish3, persist: persist2, state })).value).then(({ persist: persist2, publish: publish3, state }) => output === "display" ? lib.data.no.of({ dom_type: "div", props: {}, children: [{ dom_type: "text_value", text: JSON.stringify(state) }] }) : {
            graphid,
            set: {
              __kind: "apFunction",
              promiseArgs: true,
              fn: (value2) => {
                const result = value2 === void 0 || value2 === null ? void 0 : run_runnable(value2, lib, void 0, { resolvePromises: false });
                const promiseresult = ispromise(result) ? result.then((r) => isValue(r) ? r.value : r) : isValue(result) ? result.value : result;
                const isresultpromise = ispromise(promiseresult);
                if (publish3) {
                  lib.data.no.runtime.publish("argsupdate", { graphid, changes: { state: promiseresult }, mutate: false }, lib, options, true);
                } else {
                  lib.data.no.runtime.update_args(graphid, { state: promiseresult }, lib);
                }
                if (!isresultpromise && persist2) {
                  nodysseus.persist.set(graphid, JSON.stringify(promiseresult));
                }
                return isresultpromise ? promiseresult.then((pr) => {
                  if (persist2) {
                    nodysseus.persist.set(graphid, JSON.stringify(pr));
                  }
                  if (publish3) {
                    lib.data.no.runtime.publish("argsupdate", { graphid, changes: { state: pr }, mutate: false }, lib, options, true);
                  } else {
                    lib.data.no.runtime.update_args(graphid, { state: pr }, lib);
                  }
                  return pr;
                }) : promiseresult;
              },
              args: ["value"]
            },
            state
          }).value;
        }
      },
      return: {
        outputs: {
          display: true,
          lib: true
        },
        resolve: false,
        rawArgs: true,
        promiseArgs: true,
        args: [
          "value",
          "display",
          "subscribe",
          "metadata",
          "args",
          "lib",
          "_node",
          "_graph",
          "_graph_input_value",
          "_lib",
          "_runoptions"
        ],
        fn: (value, display, subscribe2, metadata, argsfn, lib, _node, _graph, _args, _lib, options) => {
          const output = _args._output;
          const edgemap = { value, display, subscribe: subscribe2, metadata, lib };
          if (output === "display" && !edgemap[output]) {
            return;
          }
          const runedge = output && output === display ? display : edgemap[output] ? output : "value";
          const return_result = (_lib2, args2) => {
            args2 = args2 && !isArgs(args2) ? new Map(Object.entries(args2)) : args2;
            const runnable = edgemap[runedge] ? edgemap[runedge] : runedge === "value" && !value && display ? display : _lib2.data.no.of(void 0);
            if (isRunnable(runnable) && !isError(runnable) && !isValue(runnable) && !isApRunnable(runnable)) {
              runnable.env = combineEnv(runnable.env.data, newEnv(args2, _lib2.data.no.of(runedge === "display" ? "display" : "value"), runnable.env));
            }
            if (lib !== void 0) {
              runnable.lib = _lib2;
            }
            const runedgeresult = run_runnable(runnable, _lib2, void 0, options);
            if (edgemap.subscribe) {
              const graphid = subscribe2.env.data.get("__graphid").value;
              const newgraphid = graphid + "/" + _node.id;
              wrapPromise(run_runnable(
                edgemap.subscribe,
                _lib2,
                args2,
                { ...options, resolvePromises: true }
              )).then((subscriptions) => isValue(subscriptions) ? subscriptions.value : subscriptions).then((subscriptions) => subscriptions && Object.entries(subscriptions).forEach((kv) => kv[1] && _lib2.data.no.runtime.add_listener(
                kv[0],
                "subscribe-" + newgraphid,
                kv[1],
                false,
                graphid,
                true,
                _lib2,
                options
              )));
            }
            return runedgeresult;
          };
          const ret = wrapPromise(run_runnable(lib, _lib, void 0, { ...options, resolvePromises: true })).then((lib2) => isError(lib2) ? lib2 : lib2?.value).then((lib2) => wrapPromise(argsfn ? run_runnable({
            ...argsfn,
            lib: mergeLib(lib2, _lib)
          }, _lib, void 0, { ...options, isNoResolve: true, resolvePromises: true }) : void 0).then((args2) => return_result(mergeLib(lib2, _lib), isValue(args2) ? args2?.value : args2))).value;
          return ret;
        }
      },
      compare: {
        args: ["_node_args"],
        fn: (args2) => compare(args2[0], args2[1])
      },
      eq: ({ a: a2, b }) => a2 === b,
      get: {
        args: ["_graph", "target", "path", "def", "graphval", "_lib"],
        fn: (graph, target, path, def, graph_value, lib) => {
          return nodysseus_get(
            target,
            graph_value || path,
            lib,
            def
          );
        }
      },
      set: {
        args: ["target: default", "path", "value", "__graph_value"],
        fn: (target, path, value, nodevalue) => {
          const keys3 = (nodevalue || path).split(".");
          const check = (o, v, k) => k.length === 1 ? { ...o, [k[0]]: v } : o?.hasOwn?.(k[0]) ? {
            ...o,
            [k[0]]: check(o[k[0]], v, k.slice(1))
          } : o;
          const ret = value !== void 0 && ispromise(value) || ispromise(target) ? Promise.all([
            Promise.resolve(value),
            Promise.resolve(target)
          ]).then((vt) => vt[1] !== void 0 && check(vt[1], vt[0], keys3)) : check(target, value, keys3);
          return ret;
        }
      },
      set_mutable: {
        args: ["target", "path", "value", "__graph_value"],
        fn: (target, path, value, nodevalue) => {
          function set3(obj, propsArg, value2) {
            var props, lastProp;
            if (Array.isArray(propsArg)) {
              props = propsArg.slice(0);
            }
            if (typeof propsArg == "string") {
              props = propsArg.split(".");
            }
            if (typeof propsArg == "symbol") {
              props = [propsArg];
            }
            if (!Array.isArray(props)) {
              throw new Error("props arg must be an array, a string or a symbol");
            }
            lastProp = props.pop();
            if (!lastProp) {
              return false;
            }
            var thisProp;
            while (thisProp = props.shift()) {
              if (typeof obj[thisProp] == "undefined") {
                obj[thisProp] = {};
              }
              obj = obj[thisProp];
              if (!obj || typeof obj != "object") {
                return false;
              }
            }
            obj[lastProp] = value2;
            return true;
          }
          if (target && (nodevalue || path)) {
            set3(target, nodevalue || path, value);
          }
          return target;
        }
      },
      liftarraypromise: {
        args: ["array"],
        resolve: true,
        fn: (array2) => {
          const isarraypromise = array2.reduce(
            (acc, v) => acc || ispromise(v),
            false
          );
          return isarraypromise ? Promise.all(array2) : array2;
        }
      },
      script: {
        args: ["_node", "_node_args", "_graph", "_lib", "_runoptions", "_output"],
        fn: (node, node_inputs, graph, _lib, options, _output) => node_script(
          node,
          node_inputs,
          _lib,
          options
        )
      },
      new_array: {
        args: ["_node_args", "__graph_value"],
        fn: (args2, nodevalue) => nodevalue ? nodevalue.split(/,\s+/) : wrapPromiseAll(Object.entries(args2).sort((akv, bkv) => akv[0].localeCompare(bkv[0])).map((kv) => wrapPromise(kv[1]))).then((r) => r.map((rv) => isValue(rv) ? rv.value : rv)).value
      },
      fetch: {
        resolve: true,
        args: ["__graph_value", "url", "params"],
        fn: (nodevalue, url, params2) => resfetch(url || nodevalue, params2)
      },
      import_module: {
        args: ["url", "__graph_value"],
        fn: (url, graphvalue) => (url || graphvalue) && import(url || graphvalue)
      },
      update_args: {
        promiseArgs: true,
        args: ["path", "value", "__graphid", "_lib"],
        resolve: false,
        fn: (path, value, graphid, lib) => {
          const pathresult = run_runnable(path, lib);
          path = isValue(pathresult) ? pathresult.value : pathresult;
          const result = value === void 0 || value === null ? void 0 : run_runnable(value, lib);
          if (isError(pathresult)) {
            throw pathresult;
          }
          const promiseresult = ispromise(result) ? result.then((r) => isValue(r) ? r.value : r) : isValue(result) ? result.value : result;
          lib.data.no.runtime.update_args(graphid, { [path]: promiseresult });
          return promiseresult;
        }
      },
      call: {
        resolve: true,
        args: { "__graph_value": "system", "self": { type: "any", default: true }, "fn": "value", "args": "array", "_lib": "lib" },
        fn: ({ __graph_value, self: self2, fn, args: args2, _lib }) => {
          let nodevalue = __graph_value;
          const runfn = (args3) => {
            if (typeof self2 === "function") {
              return Array.isArray(args3) ? self2(
                ...args3.reverse().reduce(
                  (acc, v) => [
                    !acc[0] && v !== void 0,
                    acc[0] || v !== void 0 ? acc[1].concat([v._Proxy ? v._value : v]) : acc[1]
                  ],
                  [false, []]
                )[1].reverse()
              ) : self2(args3 === void 0 ? [] : args3);
            } else {
              const ng_fn = nodysseus_get(self2 ?? _lib.data, fn || nodevalue, _lib);
              const ng_self = (fn || nodevalue).includes(".") ? nodysseus_get(self2, (fn || nodevalue).substring(0, (fn || nodevalue).lastIndexOf(".")), _lib) : self2;
              const fnargs = Array.isArray(args3) ? (args3 || []).reverse().reduce(
                (acc, v) => [
                  !acc[0] && v !== void 0,
                  acc[0] || v !== void 0 ? acc[1].concat([v._Proxy ? v._value : v]) : acc[1]
                ],
                [false, []]
              )[1].reverse() : args3 === void 0 ? [] : [args3];
              const ret = _lib.data.no.of(ispromise(ng_fn) ? ng_fn.then((f) => f.apply(fnargs)) : ng_fn.apply(ng_self, fnargs));
              return ret;
            }
          };
          return ispromise(args2) ? args2.then(runfn) : runfn(args2);
        }
      },
      merge_objects_mutable: {
        args: ["target", "_node_args"],
        fn: (target, args2) => {
          const keys3 = Object.keys(args2).filter((k) => k !== "target").sort();
          const resolved = {};
          keys3.forEach(
            (k) => resolved[k] = args2[k]?.value ? args2[k].value : args2[k]
          );
          const promise = keys3.reduce(
            (acc, k) => acc || ispromise(resolved[k]),
            false
          );
          return promise ? Promise.all(keys3.map((k) => Promise.resolve(resolved[k]))).then(
            (es) => Object.assign(
              {},
              ...es.filter((a2) => a2 && typeof a2 === "object")
            )
          ) : Object.assign(
            target,
            ...keys3.map(
              (k) => resolved[k] && resolved[k]?.value ? resolved[k].value : resolved[k]
            ).filter((a2) => a2 && typeof a2 === "object")
          );
        }
      },
      merge_objects: {
        args: ["_node_args"],
        resolve: false,
        fn: (args2) => nolib.extern.merge_objects_mutable.fn({}, args2)
      },
      delete: {
        args: ["target", "path"],
        resolve: false,
        fn: (target, path) => {
          while (target && target._Proxy) {
            target = target._value;
          }
          const newval = Object.assign({}, target);
          delete newval[path];
          return newval;
        }
      },
      now: {
        args: ["scale"],
        fn: now
      },
      math: {
        args: ["__graph_value", "_node_args"],
        resolve: true,
        fn: (graph_value, args2) => Math[graph_value](...Object.entries(args2).filter((kv) => kv[0] !== "__graph_value").sort((a2, b) => a2[0].localeCompare(b[0])).map((kv) => kv[1]))
      },
      add: {
        args: ["_node_args"],
        resolve: true,
        fn: (args2) => Object.entries(args2).sort((a2, b) => a2[0].localeCompare(b[0])).map((kv) => kv[1]).reduce((acc, v) => acc + v)
      },
      and: {
        args: ["_node_args"],
        resolve: true,
        fn: (args2) => Object.values(args2).reduce((acc, v) => acc && !!v, true)
      },
      mult: {
        args: ["_node_args"],
        resolve: true,
        fn: (args2) => Object.values(args2).reduce((acc, v) => acc * v, 1)
      },
      negate: {
        args: ["value"],
        resolve: true,
        fn: (value) => -value
      },
      divide: {
        args: ["_node_args"],
        resolve: true,
        fn: (args2) => Object.values(args2).reduce((acc, v) => acc / v, 1)
      },
      modify: {
        args: ["target", "path", "fn", "_node", "_lib", "_graph_input_value", "_runoptions"],
        resolve: false,
        fn: (target, path, fn, node, _lib, args2, options) => {
          while (target?._Proxy) {
            target = target._value;
          }
          const keys3 = (node.value || path).split(".");
          const check = (o, fn2, k) => k.length === 1 ? {
            ...o,
            [k[0]]: run_graph(fn2.graph, fn2.fn, {
              ...args2,
              value: o[k[0]]
            }, _lib, options),
            _needsresolve: true
          } : o?.hasOwn?.(k[0]) ? {
            ...o,
            [k[0]]: check(o[k[0]], fn2, k.slice(1)),
            _needsresolve: true
          } : o;
          return check(target, fn, keys3);
        }
      },
      properties: {
        getOwnEnumerables: function(obj) {
          return this._getPropertyNames(obj, true, false, this._enumerable);
        },
        getOwnNonenumerables: function(obj) {
          return this._getPropertyNames(obj, true, false, this._notEnumerable);
        },
        getOwnEnumerablesAndNonenumerables: function(obj) {
          return this._getPropertyNames(
            obj,
            true,
            false,
            this._enumerableAndNotEnumerable
          );
        },
        getPrototypeEnumerables: function(obj) {
          return this._getPropertyNames(obj, false, true, this._enumerable);
        },
        getPrototypeNonenumerables: function(obj) {
          return this._getPropertyNames(obj, false, true, this._notEnumerable);
        },
        getPrototypeEnumerablesAndNonenumerables: function(obj) {
          return this._getPropertyNames(
            obj,
            false,
            true,
            this._enumerableAndNotEnumerable
          );
        },
        getOwnAndPrototypeEnumerables: function(obj) {
          return this._getPropertyNames(obj, true, true, this._enumerable);
        },
        getOwnAndPrototypeNonenumerables: function(obj) {
          return this._getPropertyNames(obj, true, true, this._notEnumerable);
        },
        getOwnAndPrototypeEnumerablesAndNonenumerables: function(obj, includeArgs) {
          return this._getPropertyNames(
            obj,
            true,
            true,
            this._enumerableAndNotEnumerable,
            includeArgs
          );
        },
        _enumerable: function(obj, prop) {
          return obj.propertyIsEnumerable(prop);
        },
        _notEnumerable: function(obj, prop) {
          return !obj.propertyIsEnumerable(prop);
        },
        _enumerableAndNotEnumerable: function(obj, prop) {
          return true;
        },
        _getPropertyNames: function getAllPropertyNames(obj, iterateSelfBool, iteratePrototypeBool, includePropCb, includeArgs) {
          var props = [];
          do {
            if (iterateSelfBool) {
              Object.getOwnPropertyNames(obj).forEach(function(prop) {
                if (props.indexOf(prop) === -1 && includePropCb(obj, prop)) {
                  props.push(prop);
                }
              });
            }
            if (!iteratePrototypeBool) {
              break;
            }
            iterateSelfBool = true;
          } while (obj = Object.getPrototypeOf(obj));
          return props;
        }
      },
      stringify: {
        args: ["object", "spacer"],
        resolve: true,
        fn: (obj, spacer) => JSON.stringify(
          obj,
          (key, value) => value?._Proxy ? value._value : value,
          spacer
        )
      },
      parse: {
        args: ["string"],
        resolve: true,
        fn: (args2) => JSON.parse(args2)
      },
      typeof: {
        args: ["value"],
        fn: (value) => typeof value
      },
      construct: {
        args: ["args", "__graph_value", "_lib"],
        fn: (args2, nodevalue, _lib) => new (Function.prototype.bind.apply(
          nodysseus_get(_lib.data, nodevalue, _lib, typeof window !== "undefined" ? window[nodevalue] : self[nodevalue]),
          [null, ...args2 === void 0 ? [] : Array.isArray(args2) ? args2 : [args2]]
        ))()
      },
      addEventListeners: {
        args: ["target", "_node_args", "_lib"],
        fn: (target, nodeargs, lib) => {
          Object.entries(nodeargs).filter((kv) => kv[0] !== "target").forEach(([k, fn]) => target[k] = (event) => fn && run_runnable(fn, lib, (/* @__PURE__ */ new Map()).set("event", event)));
          return target;
        }
      }
    }
  };

  // node_modules/hyperapp/index.js
  var SSR_NODE = 1;
  var TEXT_NODE = 3;
  var EMPTY_OBJ = {};
  var EMPTY_ARR = [];
  var SVG_NS = "http://www.w3.org/2000/svg";
  var id = (a2) => a2;
  var map = EMPTY_ARR.map;
  var isArray = Array.isArray;
  var enqueue = typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : setTimeout;
  var createClass = (obj) => {
    var out = "";
    if (typeof obj === "string")
      return obj;
    if (isArray(obj)) {
      for (var k = 0, tmp; k < obj.length; k++) {
        if (tmp = createClass(obj[k])) {
          out += (out && " ") + tmp;
        }
      }
    } else {
      for (var k in obj) {
        if (obj[k])
          out += (out && " ") + k;
      }
    }
    return out;
  };
  var shouldRestart = (a2, b) => {
    for (var k in { ...a2, ...b }) {
      if (typeof (isArray(a2[k]) ? a2[k][0] : a2[k]) === "function") {
        b[k] = a2[k];
      } else if (a2[k] !== b[k])
        return true;
    }
  };
  var patchSubs = (oldSubs, newSubs = EMPTY_ARR, dispatch2) => {
    for (var subs = [], i = 0, oldSub, newSub; i < oldSubs.length || i < newSubs.length; i++) {
      oldSub = oldSubs[i];
      newSub = newSubs[i];
      subs.push(
        newSub && newSub !== true ? !oldSub || newSub[0] !== oldSub[0] || shouldRestart(newSub[1], oldSub[1]) ? [
          newSub[0],
          newSub[1],
          (oldSub && oldSub[2](), newSub[0](dispatch2, newSub[1]))
        ] : oldSub : oldSub && oldSub[2]()
      );
    }
    return subs;
  };
  var getKey = (vdom) => vdom == null ? vdom : vdom.key;
  var patchProperty = (node, key, oldValue, newValue, listener, isSvg) => {
    if (key === "style") {
      for (var k in { ...oldValue, ...newValue }) {
        oldValue = newValue == null || newValue[k] == null ? "" : newValue[k];
        if (k[0] === "-") {
          node[key].setProperty(k, oldValue);
        } else {
          node[key][k] = oldValue;
        }
      }
    } else if (key[0] === "o" && key[1] === "n") {
      if (!((node.events || (node.events = {}))[key = key.slice(2)] = newValue)) {
        node.removeEventListener(key, listener);
      } else if (!oldValue) {
        node.addEventListener(key, listener);
      }
    } else if (!isSvg && key !== "list" && key !== "form" && key in node) {
      node[key] = newValue == null ? "" : newValue;
    } else if (newValue == null || newValue === false) {
      node.removeAttribute(key);
    } else {
      node.setAttribute(key, newValue);
    }
  };
  var createNode = (vdom, listener, isSvg) => {
    var props = vdom.props;
    var node = vdom.type === TEXT_NODE ? document.createTextNode(vdom.tag) : (isSvg = isSvg || vdom.tag === "svg") ? document.createElementNS(SVG_NS, vdom.tag, props.is && props) : document.createElement(vdom.tag, props.is && props);
    for (var k in props) {
      patchProperty(node, k, null, props[k], listener, isSvg);
    }
    for (var i = 0; i < vdom.children.length; i++) {
      node.appendChild(
        createNode(
          vdom.children[i] = maybeVNode(vdom.children[i]),
          listener,
          isSvg
        )
      );
    }
    return vdom.node = node;
  };
  var patch = (parent, node, oldVNode, newVNode, listener, isSvg) => {
    if (oldVNode === newVNode) {
    } else if (oldVNode != null && oldVNode.type === TEXT_NODE && newVNode.type === TEXT_NODE) {
      if (oldVNode.tag !== newVNode.tag)
        node.nodeValue = newVNode.tag;
    } else if (oldVNode == null || oldVNode.tag !== newVNode.tag) {
      node = parent.insertBefore(
        createNode(newVNode = maybeVNode(newVNode), listener, isSvg),
        node
      );
      if (oldVNode != null) {
        parent.removeChild(oldVNode.node);
      }
    } else {
      var tmpVKid;
      var oldVKid;
      var oldKey;
      var newKey;
      var oldProps = oldVNode.props;
      var newProps = newVNode.props;
      var oldVKids = oldVNode.children;
      var newVKids = newVNode.children;
      var oldHead = 0;
      var newHead = 0;
      var oldTail = oldVKids.length - 1;
      var newTail = newVKids.length - 1;
      isSvg = isSvg || newVNode.tag === "svg";
      for (var i in { ...oldProps, ...newProps }) {
        if ((i === "value" || i === "selected" || i === "checked" ? node[i] : oldProps[i]) !== newProps[i]) {
          patchProperty(node, i, oldProps[i], newProps[i], listener, isSvg);
        }
      }
      while (newHead <= newTail && oldHead <= oldTail) {
        if ((oldKey = getKey(oldVKids[oldHead])) == null || oldKey !== getKey(newVKids[newHead])) {
          break;
        }
        patch(
          node,
          oldVKids[oldHead].node,
          oldVKids[oldHead],
          newVKids[newHead] = maybeVNode(
            newVKids[newHead++],
            oldVKids[oldHead++]
          ),
          listener,
          isSvg
        );
      }
      while (newHead <= newTail && oldHead <= oldTail) {
        if ((oldKey = getKey(oldVKids[oldTail])) == null || oldKey !== getKey(newVKids[newTail])) {
          break;
        }
        patch(
          node,
          oldVKids[oldTail].node,
          oldVKids[oldTail],
          newVKids[newTail] = maybeVNode(
            newVKids[newTail--],
            oldVKids[oldTail--]
          ),
          listener,
          isSvg
        );
      }
      if (oldHead > oldTail) {
        while (newHead <= newTail) {
          node.insertBefore(
            createNode(
              newVKids[newHead] = maybeVNode(newVKids[newHead++]),
              listener,
              isSvg
            ),
            (oldVKid = oldVKids[oldHead]) && oldVKid.node
          );
        }
      } else if (newHead > newTail) {
        while (oldHead <= oldTail) {
          node.removeChild(oldVKids[oldHead++].node);
        }
      } else {
        for (var keyed = {}, newKeyed = {}, i = oldHead; i <= oldTail; i++) {
          if ((oldKey = oldVKids[i].key) != null) {
            keyed[oldKey] = oldVKids[i];
          }
        }
        while (newHead <= newTail) {
          oldKey = getKey(oldVKid = oldVKids[oldHead]);
          newKey = getKey(
            newVKids[newHead] = maybeVNode(newVKids[newHead], oldVKid)
          );
          if (newKeyed[oldKey] || newKey != null && newKey === getKey(oldVKids[oldHead + 1])) {
            if (oldKey == null) {
              node.removeChild(oldVKid.node);
            }
            oldHead++;
            continue;
          }
          if (newKey == null || oldVNode.type === SSR_NODE) {
            if (oldKey == null) {
              patch(
                node,
                oldVKid && oldVKid.node,
                oldVKid,
                newVKids[newHead],
                listener,
                isSvg
              );
              newHead++;
            }
            oldHead++;
          } else {
            if (oldKey === newKey) {
              patch(
                node,
                oldVKid.node,
                oldVKid,
                newVKids[newHead],
                listener,
                isSvg
              );
              newKeyed[newKey] = true;
              oldHead++;
            } else {
              if ((tmpVKid = keyed[newKey]) != null) {
                patch(
                  node,
                  node.insertBefore(tmpVKid.node, oldVKid && oldVKid.node),
                  tmpVKid,
                  newVKids[newHead],
                  listener,
                  isSvg
                );
                newKeyed[newKey] = true;
              } else {
                patch(
                  node,
                  oldVKid && oldVKid.node,
                  null,
                  newVKids[newHead],
                  listener,
                  isSvg
                );
              }
            }
            newHead++;
          }
        }
        while (oldHead <= oldTail) {
          if (getKey(oldVKid = oldVKids[oldHead++]) == null) {
            node.removeChild(oldVKid.node);
          }
        }
        for (var i in keyed) {
          if (newKeyed[i] == null) {
            node.removeChild(keyed[i].node);
          }
        }
      }
    }
    return newVNode.node = node;
  };
  var propsChanged = (a2, b) => {
    for (var k in a2)
      if (a2[k] !== b[k])
        return true;
    for (var k in b)
      if (a2[k] !== b[k])
        return true;
  };
  var maybeVNode = (newVNode, oldVNode) => newVNode !== true && newVNode !== false && newVNode ? typeof newVNode.tag === "function" ? ((!oldVNode || oldVNode.memo == null || propsChanged(oldVNode.memo, newVNode.memo)) && ((oldVNode = newVNode.tag(newVNode.memo)).memo = newVNode.memo), oldVNode) : newVNode : text("");
  var recycleNode = (node) => node.nodeType === TEXT_NODE ? text(node.nodeValue, node) : createVNode(
    node.nodeName.toLowerCase(),
    EMPTY_OBJ,
    map.call(node.childNodes, recycleNode),
    SSR_NODE,
    node
  );
  var createVNode = (tag, { key, ...props }, children, type, node) => ({
    tag,
    props,
    key,
    children,
    type,
    node
  });
  var memo = (tag, memo2) => ({ tag, memo: memo2 });
  var text = (value, node) => createVNode(value, EMPTY_OBJ, EMPTY_ARR, TEXT_NODE, node);
  var h = (tag, { class: c2, ...props }, children = EMPTY_ARR) => createVNode(
    tag,
    { ...props, ...c2 ? { class: createClass(c2) } : EMPTY_OBJ },
    isArray(children) ? children : [children]
  );
  var app = ({
    node,
    view: view2,
    subscriptions,
    dispatch: dispatch2 = id,
    init: init2 = EMPTY_OBJ
  }) => {
    var vdom = node && recycleNode(node);
    var subs = [];
    var state;
    var busy;
    var update = (newState) => {
      if (state !== newState) {
        if ((state = newState) == null)
          dispatch2 = subscriptions = render = id;
        if (subscriptions)
          subs = patchSubs(subs, subscriptions(state), dispatch2);
        if (view2 && !busy)
          enqueue(render, busy = true);
      }
    };
    var render = () => node = patch(
      node.parentNode,
      node,
      vdom,
      vdom = view2(state),
      listener,
      busy = false
    );
    var listener = function(event) {
      dispatch2(this.events[event.type], event);
    };
    return (dispatch2 = dispatch2(
      (action, props) => typeof action === "function" ? dispatch2(action(state, props)) : isArray(action) ? typeof action[0] === "function" ? dispatch2(action[0], action[1]) : action.slice(1).map(
        (fx) => fx && fx !== true && (fx[0] || fx)(dispatch2, fx[1]),
        update(action[0])
      ) : update(action)
    ))(init2), dispatch2;
  };

  // node_modules/fuse.js/dist/fuse.esm.js
  function isArray2(value) {
    return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
  }
  var INFINITY = 1 / 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    let result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function toString2(value) {
    return value == null ? "" : baseToString(value);
  }
  function isString(value) {
    return typeof value === "string";
  }
  function isNumber(value) {
    return typeof value === "number";
  }
  function isBoolean(value) {
    return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
  }
  function isObject(value) {
    return typeof value === "object";
  }
  function isObjectLike(value) {
    return isObject(value) && value !== null;
  }
  function isDefined(value) {
    return value !== void 0 && value !== null;
  }
  function isBlank(value) {
    return !value.trim().length;
  }
  function getTag(value) {
    return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
  }
  var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
  var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
  var PATTERN_LENGTH_TOO_LARGE = (max2) => `Pattern length exceeds max of ${max2}.`;
  var MISSING_KEY_PROPERTY = (name2) => `Missing ${name2} property in key`;
  var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
  var hasOwn = Object.prototype.hasOwnProperty;
  var KeyStore = class {
    constructor(keys3) {
      this._keys = [];
      this._keyMap = {};
      let totalWeight = 0;
      keys3.forEach((key) => {
        let obj = createKey(key);
        totalWeight += obj.weight;
        this._keys.push(obj);
        this._keyMap[obj.id] = obj;
        totalWeight += obj.weight;
      });
      this._keys.forEach((key) => {
        key.weight /= totalWeight;
      });
    }
    get(keyId) {
      return this._keyMap[keyId];
    }
    keys() {
      return this._keys;
    }
    toJSON() {
      return JSON.stringify(this._keys);
    }
  };
  function createKey(key) {
    let path = null;
    let id3 = null;
    let src = null;
    let weight = 1;
    let getFn = null;
    if (isString(key) || isArray2(key)) {
      src = key;
      path = createKeyPath(key);
      id3 = createKeyId(key);
    } else {
      if (!hasOwn.call(key, "name")) {
        throw new Error(MISSING_KEY_PROPERTY("name"));
      }
      const name2 = key.name;
      src = name2;
      if (hasOwn.call(key, "weight")) {
        weight = key.weight;
        if (weight <= 0) {
          throw new Error(INVALID_KEY_WEIGHT_VALUE(name2));
        }
      }
      path = createKeyPath(name2);
      id3 = createKeyId(name2);
      getFn = key.getFn;
    }
    return { path, id: id3, weight, src, getFn };
  }
  function createKeyPath(key) {
    return isArray2(key) ? key : key.split(".");
  }
  function createKeyId(key) {
    return isArray2(key) ? key.join(".") : key;
  }
  function get(obj, path) {
    let list = [];
    let arr = false;
    const deepGet = (obj2, path2, index2) => {
      if (!isDefined(obj2)) {
        return;
      }
      if (!path2[index2]) {
        list.push(obj2);
      } else {
        let key = path2[index2];
        const value = obj2[key];
        if (!isDefined(value)) {
          return;
        }
        if (index2 === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
          list.push(toString2(value));
        } else if (isArray2(value)) {
          arr = true;
          for (let i = 0, len = value.length; i < len; i += 1) {
            deepGet(value[i], path2, index2 + 1);
          }
        } else if (path2.length) {
          deepGet(value, path2, index2 + 1);
        }
      }
    };
    deepGet(obj, isString(path) ? path.split(".") : path, 0);
    return arr ? list : list[0];
  }
  var MatchOptions = {
    includeMatches: false,
    findAllMatches: false,
    minMatchCharLength: 1
  };
  var BasicOptions = {
    isCaseSensitive: false,
    includeScore: false,
    keys: [],
    shouldSort: true,
    sortFn: (a2, b) => a2.score === b.score ? a2.idx < b.idx ? -1 : 1 : a2.score < b.score ? -1 : 1
  };
  var FuzzyOptions = {
    location: 0,
    threshold: 0.6,
    distance: 100
  };
  var AdvancedOptions = {
    useExtendedSearch: false,
    getFn: get,
    ignoreLocation: false,
    ignoreFieldNorm: false,
    fieldNormWeight: 1
  };
  var Config = {
    ...BasicOptions,
    ...MatchOptions,
    ...FuzzyOptions,
    ...AdvancedOptions
  };
  var SPACE = /[^ ]+/g;
  function norm(weight = 1, mantissa = 3) {
    const cache2 = /* @__PURE__ */ new Map();
    const m2 = Math.pow(10, mantissa);
    return {
      get(value) {
        const numTokens = value.match(SPACE).length;
        if (cache2.has(numTokens)) {
          return cache2.get(numTokens);
        }
        const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
        const n2 = parseFloat(Math.round(norm2 * m2) / m2);
        cache2.set(numTokens, n2);
        return n2;
      },
      clear() {
        cache2.clear();
      }
    };
  }
  var FuseIndex = class {
    constructor({
      getFn = Config.getFn,
      fieldNormWeight = Config.fieldNormWeight
    } = {}) {
      this.norm = norm(fieldNormWeight, 3);
      this.getFn = getFn;
      this.isCreated = false;
      this.setIndexRecords();
    }
    setSources(docs = []) {
      this.docs = docs;
    }
    setIndexRecords(records = []) {
      this.records = records;
    }
    setKeys(keys3 = []) {
      this.keys = keys3;
      this._keysMap = {};
      keys3.forEach((key, idx) => {
        this._keysMap[key.id] = idx;
      });
    }
    create() {
      if (this.isCreated || !this.docs.length) {
        return;
      }
      this.isCreated = true;
      if (isString(this.docs[0])) {
        this.docs.forEach((doc3, docIndex) => {
          this._addString(doc3, docIndex);
        });
      } else {
        this.docs.forEach((doc3, docIndex) => {
          this._addObject(doc3, docIndex);
        });
      }
      this.norm.clear();
    }
    add(doc3) {
      const idx = this.size();
      if (isString(doc3)) {
        this._addString(doc3, idx);
      } else {
        this._addObject(doc3, idx);
      }
    }
    removeAt(idx) {
      this.records.splice(idx, 1);
      for (let i = idx, len = this.size(); i < len; i += 1) {
        this.records[i].i -= 1;
      }
    }
    getValueForItemAtKeyId(item, keyId) {
      return item[this._keysMap[keyId]];
    }
    size() {
      return this.records.length;
    }
    _addString(doc3, docIndex) {
      if (!isDefined(doc3) || isBlank(doc3)) {
        return;
      }
      let record = {
        v: doc3,
        i: docIndex,
        n: this.norm.get(doc3)
      };
      this.records.push(record);
    }
    _addObject(doc3, docIndex) {
      let record = { i: docIndex, $: {} };
      this.keys.forEach((key, keyIndex) => {
        let value = key.getFn ? key.getFn(doc3) : this.getFn(doc3, key.path);
        if (!isDefined(value)) {
          return;
        }
        if (isArray2(value)) {
          let subRecords = [];
          const stack = [{ nestedArrIndex: -1, value }];
          while (stack.length) {
            const { nestedArrIndex, value: value2 } = stack.pop();
            if (!isDefined(value2)) {
              continue;
            }
            if (isString(value2) && !isBlank(value2)) {
              let subRecord = {
                v: value2,
                i: nestedArrIndex,
                n: this.norm.get(value2)
              };
              subRecords.push(subRecord);
            } else if (isArray2(value2)) {
              value2.forEach((item, k) => {
                stack.push({
                  nestedArrIndex: k,
                  value: item
                });
              });
            } else
              ;
          }
          record.$[keyIndex] = subRecords;
        } else if (isString(value) && !isBlank(value)) {
          let subRecord = {
            v: value,
            n: this.norm.get(value)
          };
          record.$[keyIndex] = subRecord;
        }
      });
      this.records.push(record);
    }
    toJSON() {
      return {
        keys: this.keys,
        records: this.records
      };
    }
  };
  function createIndex(keys3, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
    const myIndex = new FuseIndex({ getFn, fieldNormWeight });
    myIndex.setKeys(keys3.map(createKey));
    myIndex.setSources(docs);
    myIndex.create();
    return myIndex;
  }
  function parseIndex(data2, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
    const { keys: keys3, records } = data2;
    const myIndex = new FuseIndex({ getFn, fieldNormWeight });
    myIndex.setKeys(keys3);
    myIndex.setIndexRecords(records);
    return myIndex;
  }
  function computeScore$1(pattern, {
    errors = 0,
    currentLocation = 0,
    expectedLocation = 0,
    distance = Config.distance,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    const accuracy = errors / pattern.length;
    if (ignoreLocation) {
      return accuracy;
    }
    const proximity = Math.abs(expectedLocation - currentLocation);
    if (!distance) {
      return proximity ? 1 : accuracy;
    }
    return accuracy + proximity / distance;
  }
  function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
    let indices = [];
    let start = -1;
    let end = -1;
    let i = 0;
    for (let len = matchmask.length; i < len; i += 1) {
      let match = matchmask[i];
      if (match && start === -1) {
        start = i;
      } else if (!match && start !== -1) {
        end = i - 1;
        if (end - start + 1 >= minMatchCharLength) {
          indices.push([start, end]);
        }
        start = -1;
      }
    }
    if (matchmask[i - 1] && i - start >= minMatchCharLength) {
      indices.push([start, i - 1]);
    }
    return indices;
  }
  var MAX_BITS = 32;
  function search(text3, pattern, patternAlphabet, {
    location: location2 = Config.location,
    distance = Config.distance,
    threshold = Config.threshold,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    includeMatches = Config.includeMatches,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    if (pattern.length > MAX_BITS) {
      throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
    }
    const patternLen = pattern.length;
    const textLen = text3.length;
    const expectedLocation = Math.max(0, Math.min(location2, textLen));
    let currentThreshold = threshold;
    let bestLocation = expectedLocation;
    const computeMatches = minMatchCharLength > 1 || includeMatches;
    const matchMask = computeMatches ? Array(textLen) : [];
    let index2;
    while ((index2 = text3.indexOf(pattern, bestLocation)) > -1) {
      let score2 = computeScore$1(pattern, {
        currentLocation: index2,
        expectedLocation,
        distance,
        ignoreLocation
      });
      currentThreshold = Math.min(score2, currentThreshold);
      bestLocation = index2 + patternLen;
      if (computeMatches) {
        let i = 0;
        while (i < patternLen) {
          matchMask[index2 + i] = 1;
          i += 1;
        }
      }
    }
    bestLocation = -1;
    let lastBitArr = [];
    let finalScore = 1;
    let binMax = patternLen + textLen;
    const mask = 1 << patternLen - 1;
    for (let i = 0; i < patternLen; i += 1) {
      let binMin = 0;
      let binMid = binMax;
      while (binMin < binMid) {
        const score3 = computeScore$1(pattern, {
          errors: i,
          currentLocation: expectedLocation + binMid,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (score3 <= currentThreshold) {
          binMin = binMid;
        } else {
          binMax = binMid;
        }
        binMid = Math.floor((binMax - binMin) / 2 + binMin);
      }
      binMax = binMid;
      let start = Math.max(1, expectedLocation - binMid + 1);
      let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
      let bitArr = Array(finish + 2);
      bitArr[finish + 1] = (1 << i) - 1;
      for (let j = finish; j >= start; j -= 1) {
        let currentLocation = j - 1;
        let charMatch = patternAlphabet[text3.charAt(currentLocation)];
        if (computeMatches) {
          matchMask[currentLocation] = +!!charMatch;
        }
        bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
        if (i) {
          bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
        }
        if (bitArr[j] & mask) {
          finalScore = computeScore$1(pattern, {
            errors: i,
            currentLocation,
            expectedLocation,
            distance,
            ignoreLocation
          });
          if (finalScore <= currentThreshold) {
            currentThreshold = finalScore;
            bestLocation = currentLocation;
            if (bestLocation <= expectedLocation) {
              break;
            }
            start = Math.max(1, 2 * expectedLocation - bestLocation);
          }
        }
      }
      const score2 = computeScore$1(pattern, {
        errors: i + 1,
        currentLocation: expectedLocation,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 > currentThreshold) {
        break;
      }
      lastBitArr = bitArr;
    }
    const result = {
      isMatch: bestLocation >= 0,
      score: Math.max(1e-3, finalScore)
    };
    if (computeMatches) {
      const indices = convertMaskToIndices(matchMask, minMatchCharLength);
      if (!indices.length) {
        result.isMatch = false;
      } else if (includeMatches) {
        result.indices = indices;
      }
    }
    return result;
  }
  function createPatternAlphabet(pattern) {
    let mask = {};
    for (let i = 0, len = pattern.length; i < len; i += 1) {
      const char = pattern.charAt(i);
      mask[char] = (mask[char] || 0) | 1 << len - i - 1;
    }
    return mask;
  }
  var BitapSearch = class {
    constructor(pattern, {
      location: location2 = Config.location,
      threshold = Config.threshold,
      distance = Config.distance,
      includeMatches = Config.includeMatches,
      findAllMatches = Config.findAllMatches,
      minMatchCharLength = Config.minMatchCharLength,
      isCaseSensitive = Config.isCaseSensitive,
      ignoreLocation = Config.ignoreLocation
    } = {}) {
      this.options = {
        location: location2,
        threshold,
        distance,
        includeMatches,
        findAllMatches,
        minMatchCharLength,
        isCaseSensitive,
        ignoreLocation
      };
      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
      this.chunks = [];
      if (!this.pattern.length) {
        return;
      }
      const addChunk = (pattern2, startIndex) => {
        this.chunks.push({
          pattern: pattern2,
          alphabet: createPatternAlphabet(pattern2),
          startIndex
        });
      };
      const len = this.pattern.length;
      if (len > MAX_BITS) {
        let i = 0;
        const remainder = len % MAX_BITS;
        const end = len - remainder;
        while (i < end) {
          addChunk(this.pattern.substr(i, MAX_BITS), i);
          i += MAX_BITS;
        }
        if (remainder) {
          const startIndex = len - MAX_BITS;
          addChunk(this.pattern.substr(startIndex), startIndex);
        }
      } else {
        addChunk(this.pattern, 0);
      }
    }
    searchIn(text3) {
      const { isCaseSensitive, includeMatches } = this.options;
      if (!isCaseSensitive) {
        text3 = text3.toLowerCase();
      }
      if (this.pattern === text3) {
        let result2 = {
          isMatch: true,
          score: 0
        };
        if (includeMatches) {
          result2.indices = [[0, text3.length - 1]];
        }
        return result2;
      }
      const {
        location: location2,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        ignoreLocation
      } = this.options;
      let allIndices = [];
      let totalScore = 0;
      let hasMatches = false;
      this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
        const { isMatch, score: score2, indices } = search(text3, pattern, alphabet, {
          location: location2 + startIndex,
          distance,
          threshold,
          findAllMatches,
          minMatchCharLength,
          includeMatches,
          ignoreLocation
        });
        if (isMatch) {
          hasMatches = true;
        }
        totalScore += score2;
        if (isMatch && indices) {
          allIndices = [...allIndices, ...indices];
        }
      });
      let result = {
        isMatch: hasMatches,
        score: hasMatches ? totalScore / this.chunks.length : 1
      };
      if (hasMatches && includeMatches) {
        result.indices = allIndices;
      }
      return result;
    }
  };
  var BaseMatch = class {
    constructor(pattern) {
      this.pattern = pattern;
    }
    static isMultiMatch(pattern) {
      return getMatch(pattern, this.multiRegex);
    }
    static isSingleMatch(pattern) {
      return getMatch(pattern, this.singleRegex);
    }
    search() {
    }
  };
  function getMatch(pattern, exp) {
    const matches = pattern.match(exp);
    return matches ? matches[1] : null;
  }
  var ExactMatch = class extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return "exact";
    }
    static get multiRegex() {
      return /^="(.*)"$/;
    }
    static get singleRegex() {
      return /^=(.*)$/;
    }
    search(text3) {
      const isMatch = text3 === this.pattern;
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, this.pattern.length - 1]
      };
    }
  };
  var InverseExactMatch = class extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return "inverse-exact";
    }
    static get multiRegex() {
      return /^!"(.*)"$/;
    }
    static get singleRegex() {
      return /^!(.*)$/;
    }
    search(text3) {
      const index2 = text3.indexOf(this.pattern);
      const isMatch = index2 === -1;
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, text3.length - 1]
      };
    }
  };
  var PrefixExactMatch = class extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return "prefix-exact";
    }
    static get multiRegex() {
      return /^\^"(.*)"$/;
    }
    static get singleRegex() {
      return /^\^(.*)$/;
    }
    search(text3) {
      const isMatch = text3.startsWith(this.pattern);
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, this.pattern.length - 1]
      };
    }
  };
  var InversePrefixExactMatch = class extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return "inverse-prefix-exact";
    }
    static get multiRegex() {
      return /^!\^"(.*)"$/;
    }
    static get singleRegex() {
      return /^!\^(.*)$/;
    }
    search(text3) {
      const isMatch = !text3.startsWith(this.pattern);
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, text3.length - 1]
      };
    }
  };
  var SuffixExactMatch = class extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return "suffix-exact";
    }
    static get multiRegex() {
      return /^"(.*)"\$$/;
    }
    static get singleRegex() {
      return /^(.*)\$$/;
    }
    search(text3) {
      const isMatch = text3.endsWith(this.pattern);
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [text3.length - this.pattern.length, text3.length - 1]
      };
    }
  };
  var InverseSuffixExactMatch = class extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return "inverse-suffix-exact";
    }
    static get multiRegex() {
      return /^!"(.*)"\$$/;
    }
    static get singleRegex() {
      return /^!(.*)\$$/;
    }
    search(text3) {
      const isMatch = !text3.endsWith(this.pattern);
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, text3.length - 1]
      };
    }
  };
  var FuzzyMatch = class extends BaseMatch {
    constructor(pattern, {
      location: location2 = Config.location,
      threshold = Config.threshold,
      distance = Config.distance,
      includeMatches = Config.includeMatches,
      findAllMatches = Config.findAllMatches,
      minMatchCharLength = Config.minMatchCharLength,
      isCaseSensitive = Config.isCaseSensitive,
      ignoreLocation = Config.ignoreLocation
    } = {}) {
      super(pattern);
      this._bitapSearch = new BitapSearch(pattern, {
        location: location2,
        threshold,
        distance,
        includeMatches,
        findAllMatches,
        minMatchCharLength,
        isCaseSensitive,
        ignoreLocation
      });
    }
    static get type() {
      return "fuzzy";
    }
    static get multiRegex() {
      return /^"(.*)"$/;
    }
    static get singleRegex() {
      return /^(.*)$/;
    }
    search(text3) {
      return this._bitapSearch.searchIn(text3);
    }
  };
  var IncludeMatch = class extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return "include";
    }
    static get multiRegex() {
      return /^'"(.*)"$/;
    }
    static get singleRegex() {
      return /^'(.*)$/;
    }
    search(text3) {
      let location2 = 0;
      let index2;
      const indices = [];
      const patternLen = this.pattern.length;
      while ((index2 = text3.indexOf(this.pattern, location2)) > -1) {
        location2 = index2 + patternLen;
        indices.push([index2, location2 - 1]);
      }
      const isMatch = !!indices.length;
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices
      };
    }
  };
  var searchers = [
    ExactMatch,
    IncludeMatch,
    PrefixExactMatch,
    InversePrefixExactMatch,
    InverseSuffixExactMatch,
    SuffixExactMatch,
    InverseExactMatch,
    FuzzyMatch
  ];
  var searchersLen = searchers.length;
  var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
  var OR_TOKEN = "|";
  function parseQuery(pattern, options = {}) {
    return pattern.split(OR_TOKEN).map((item) => {
      let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
      let results = [];
      for (let i = 0, len = query.length; i < len; i += 1) {
        const queryItem = query[i];
        let found = false;
        let idx = -1;
        while (!found && ++idx < searchersLen) {
          const searcher = searchers[idx];
          let token = searcher.isMultiMatch(queryItem);
          if (token) {
            results.push(new searcher(token, options));
            found = true;
          }
        }
        if (found) {
          continue;
        }
        idx = -1;
        while (++idx < searchersLen) {
          const searcher = searchers[idx];
          let token = searcher.isSingleMatch(queryItem);
          if (token) {
            results.push(new searcher(token, options));
            break;
          }
        }
      }
      return results;
    });
  }
  var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
  var ExtendedSearch = class {
    constructor(pattern, {
      isCaseSensitive = Config.isCaseSensitive,
      includeMatches = Config.includeMatches,
      minMatchCharLength = Config.minMatchCharLength,
      ignoreLocation = Config.ignoreLocation,
      findAllMatches = Config.findAllMatches,
      location: location2 = Config.location,
      threshold = Config.threshold,
      distance = Config.distance
    } = {}) {
      this.query = null;
      this.options = {
        isCaseSensitive,
        includeMatches,
        minMatchCharLength,
        findAllMatches,
        ignoreLocation,
        location: location2,
        threshold,
        distance
      };
      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
      this.query = parseQuery(this.pattern, this.options);
    }
    static condition(_, options) {
      return options.useExtendedSearch;
    }
    searchIn(text3) {
      const query = this.query;
      if (!query) {
        return {
          isMatch: false,
          score: 1
        };
      }
      const { includeMatches, isCaseSensitive } = this.options;
      text3 = isCaseSensitive ? text3 : text3.toLowerCase();
      let numMatches = 0;
      let allIndices = [];
      let totalScore = 0;
      for (let i = 0, qLen = query.length; i < qLen; i += 1) {
        const searchers2 = query[i];
        allIndices.length = 0;
        numMatches = 0;
        for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
          const searcher = searchers2[j];
          const { isMatch, indices, score: score2 } = searcher.search(text3);
          if (isMatch) {
            numMatches += 1;
            totalScore += score2;
            if (includeMatches) {
              const type = searcher.constructor.type;
              if (MultiMatchSet.has(type)) {
                allIndices = [...allIndices, ...indices];
              } else {
                allIndices.push(indices);
              }
            }
          } else {
            totalScore = 0;
            numMatches = 0;
            allIndices.length = 0;
            break;
          }
        }
        if (numMatches) {
          let result = {
            isMatch: true,
            score: totalScore / numMatches
          };
          if (includeMatches) {
            result.indices = allIndices;
          }
          return result;
        }
      }
      return {
        isMatch: false,
        score: 1
      };
    }
  };
  var registeredSearchers = [];
  function register(...args2) {
    registeredSearchers.push(...args2);
  }
  function createSearcher(pattern, options) {
    for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
      let searcherClass = registeredSearchers[i];
      if (searcherClass.condition(pattern, options)) {
        return new searcherClass(pattern, options);
      }
    }
    return new BitapSearch(pattern, options);
  }
  var LogicalOperator = {
    AND: "$and",
    OR: "$or"
  };
  var KeyType = {
    PATH: "$path",
    PATTERN: "$val"
  };
  var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
  var isPath = (query) => !!query[KeyType.PATH];
  var isLeaf = (query) => !isArray2(query) && isObject(query) && !isExpression(query);
  var convertToExplicit = (query) => ({
    [LogicalOperator.AND]: Object.keys(query).map((key) => ({
      [key]: query[key]
    }))
  });
  function parse(query, options, { auto = true } = {}) {
    const next = (query2) => {
      let keys3 = Object.keys(query2);
      const isQueryPath = isPath(query2);
      if (!isQueryPath && keys3.length > 1 && !isExpression(query2)) {
        return next(convertToExplicit(query2));
      }
      if (isLeaf(query2)) {
        const key = isQueryPath ? query2[KeyType.PATH] : keys3[0];
        const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
        if (!isString(pattern)) {
          throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
        }
        const obj = {
          keyId: createKeyId(key),
          pattern
        };
        if (auto) {
          obj.searcher = createSearcher(pattern, options);
        }
        return obj;
      }
      let node = {
        children: [],
        operator: keys3[0]
      };
      keys3.forEach((key) => {
        const value = query2[key];
        if (isArray2(value)) {
          value.forEach((item) => {
            node.children.push(next(item));
          });
        }
      });
      return node;
    };
    if (!isExpression(query)) {
      query = convertToExplicit(query);
    }
    return next(query);
  }
  function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
    results.forEach((result) => {
      let totalScore = 1;
      result.matches.forEach(({ key, norm: norm2, score: score2 }) => {
        const weight = key ? key.weight : null;
        totalScore *= Math.pow(
          score2 === 0 && weight ? Number.EPSILON : score2,
          (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
        );
      });
      result.score = totalScore;
    });
  }
  function transformMatches(result, data2) {
    const matches = result.matches;
    data2.matches = [];
    if (!isDefined(matches)) {
      return;
    }
    matches.forEach((match) => {
      if (!isDefined(match.indices) || !match.indices.length) {
        return;
      }
      const { indices, value } = match;
      let obj = {
        indices,
        value
      };
      if (match.key) {
        obj.key = match.key.src;
      }
      if (match.idx > -1) {
        obj.refIndex = match.idx;
      }
      data2.matches.push(obj);
    });
  }
  function transformScore(result, data2) {
    data2.score = result.score;
  }
  function format(results, docs, {
    includeMatches = Config.includeMatches,
    includeScore = Config.includeScore
  } = {}) {
    const transformers = [];
    if (includeMatches)
      transformers.push(transformMatches);
    if (includeScore)
      transformers.push(transformScore);
    return results.map((result) => {
      const { idx } = result;
      const data2 = {
        item: docs[idx],
        refIndex: idx
      };
      if (transformers.length) {
        transformers.forEach((transformer) => {
          transformer(result, data2);
        });
      }
      return data2;
    });
  }
  var Fuse = class {
    constructor(docs, options = {}, index2) {
      this.options = { ...Config, ...options };
      if (this.options.useExtendedSearch && false) {
        throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
      }
      this._keyStore = new KeyStore(this.options.keys);
      this.setCollection(docs, index2);
    }
    setCollection(docs, index2) {
      this._docs = docs;
      if (index2 && !(index2 instanceof FuseIndex)) {
        throw new Error(INCORRECT_INDEX_TYPE);
      }
      this._myIndex = index2 || createIndex(this.options.keys, this._docs, {
        getFn: this.options.getFn,
        fieldNormWeight: this.options.fieldNormWeight
      });
    }
    add(doc3) {
      if (!isDefined(doc3)) {
        return;
      }
      this._docs.push(doc3);
      this._myIndex.add(doc3);
    }
    remove(predicate = () => false) {
      const results = [];
      for (let i = 0, len = this._docs.length; i < len; i += 1) {
        const doc3 = this._docs[i];
        if (predicate(doc3, i)) {
          this.removeAt(i);
          i -= 1;
          len -= 1;
          results.push(doc3);
        }
      }
      return results;
    }
    removeAt(idx) {
      this._docs.splice(idx, 1);
      this._myIndex.removeAt(idx);
    }
    getIndex() {
      return this._myIndex;
    }
    search(query, { limit = -1 } = {}) {
      const {
        includeMatches,
        includeScore,
        shouldSort,
        sortFn,
        ignoreFieldNorm
      } = this.options;
      let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
      computeScore(results, { ignoreFieldNorm });
      if (shouldSort) {
        results.sort(sortFn);
      }
      if (isNumber(limit) && limit > -1) {
        results = results.slice(0, limit);
      }
      return format(results, this._docs, {
        includeMatches,
        includeScore
      });
    }
    _searchStringList(query) {
      const searcher = createSearcher(query, this.options);
      const { records } = this._myIndex;
      const results = [];
      records.forEach(({ v: text3, i: idx, n: norm2 }) => {
        if (!isDefined(text3)) {
          return;
        }
        const { isMatch, score: score2, indices } = searcher.searchIn(text3);
        if (isMatch) {
          results.push({
            item: text3,
            idx,
            matches: [{ score: score2, value: text3, norm: norm2, indices }]
          });
        }
      });
      return results;
    }
    _searchLogical(query) {
      const expression = parse(query, this.options);
      const evaluate = (node, item, idx) => {
        if (!node.children) {
          const { keyId, searcher } = node;
          const matches = this._findMatches({
            key: this._keyStore.get(keyId),
            value: this._myIndex.getValueForItemAtKeyId(item, keyId),
            searcher
          });
          if (matches && matches.length) {
            return [
              {
                idx,
                item,
                matches
              }
            ];
          }
          return [];
        }
        const res = [];
        for (let i = 0, len = node.children.length; i < len; i += 1) {
          const child = node.children[i];
          const result = evaluate(child, item, idx);
          if (result.length) {
            res.push(...result);
          } else if (node.operator === LogicalOperator.AND) {
            return [];
          }
        }
        return res;
      };
      const records = this._myIndex.records;
      const resultMap = {};
      const results = [];
      records.forEach(({ $: item, i: idx }) => {
        if (isDefined(item)) {
          let expResults = evaluate(expression, item, idx);
          if (expResults.length) {
            if (!resultMap[idx]) {
              resultMap[idx] = { idx, item, matches: [] };
              results.push(resultMap[idx]);
            }
            expResults.forEach(({ matches }) => {
              resultMap[idx].matches.push(...matches);
            });
          }
        }
      });
      return results;
    }
    _searchObjectList(query) {
      const searcher = createSearcher(query, this.options);
      const { keys: keys3, records } = this._myIndex;
      const results = [];
      records.forEach(({ $: item, i: idx }) => {
        if (!isDefined(item)) {
          return;
        }
        let matches = [];
        keys3.forEach((key, keyIndex) => {
          matches.push(
            ...this._findMatches({
              key,
              value: item[keyIndex],
              searcher
            })
          );
        });
        if (matches.length) {
          results.push({
            idx,
            item,
            matches
          });
        }
      });
      return results;
    }
    _findMatches({ key, value, searcher }) {
      if (!isDefined(value)) {
        return [];
      }
      let matches = [];
      if (isArray2(value)) {
        value.forEach(({ v: text3, i: idx, n: norm2 }) => {
          if (!isDefined(text3)) {
            return;
          }
          const { isMatch, score: score2, indices } = searcher.searchIn(text3);
          if (isMatch) {
            matches.push({
              score: score2,
              key,
              value: text3,
              idx,
              norm: norm2,
              indices
            });
          }
        });
      } else {
        const { v: text3, n: norm2 } = value;
        const { isMatch, score: score2, indices } = searcher.searchIn(text3);
        if (isMatch) {
          matches.push({ score: score2, key, value: text3, norm: norm2, indices });
        }
      }
      return matches;
    }
  };
  Fuse.version = "6.6.2";
  Fuse.createIndex = createIndex;
  Fuse.parseIndex = parseIndex;
  Fuse.config = Config;
  {
    Fuse.parseQuery = parse;
  }
  {
    register(ExtendedSearch);
  }

  // src/editor/util.ts
  var pz = __toESM(require_panzoom(), 1);

  // node_modules/d3-force/src/center.js
  function center_default(x3, y3) {
    var nodes, strength = 1;
    if (x3 == null)
      x3 = 0;
    if (y3 == null)
      y3 = 0;
    function force() {
      var i, n2 = nodes.length, node, sx = 0, sy = 0;
      for (i = 0; i < n2; ++i) {
        node = nodes[i], sx += node.x, sy += node.y;
      }
      for (sx = (sx / n2 - x3) * strength, sy = (sy / n2 - y3) * strength, i = 0; i < n2; ++i) {
        node = nodes[i], node.x -= sx, node.y -= sy;
      }
    }
    force.initialize = function(_) {
      nodes = _;
    };
    force.x = function(_) {
      return arguments.length ? (x3 = +_, force) : x3;
    };
    force.y = function(_) {
      return arguments.length ? (y3 = +_, force) : y3;
    };
    force.strength = function(_) {
      return arguments.length ? (strength = +_, force) : strength;
    };
    return force;
  }

  // node_modules/d3-quadtree/src/add.js
  function add_default(d) {
    const x3 = +this._x.call(null, d), y3 = +this._y.call(null, d);
    return add(this.cover(x3, y3), x3, y3, d);
  }
  function add(tree, x3, y3, d) {
    if (isNaN(x3) || isNaN(y3))
      return tree;
    var parent, node = tree._root, leaf = { data: d }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i, j;
    if (!node)
      return tree._root = leaf, tree;
    while (node.length) {
      if (right = x3 >= (xm = (x0 + x1) / 2))
        x0 = xm;
      else
        x1 = xm;
      if (bottom = y3 >= (ym = (y0 + y1) / 2))
        y0 = ym;
      else
        y1 = ym;
      if (parent = node, !(node = node[i = bottom << 1 | right]))
        return parent[i] = leaf, tree;
    }
    xp = +tree._x.call(null, node.data);
    yp = +tree._y.call(null, node.data);
    if (x3 === xp && y3 === yp)
      return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
    do {
      parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
      if (right = x3 >= (xm = (x0 + x1) / 2))
        x0 = xm;
      else
        x1 = xm;
      if (bottom = y3 >= (ym = (y0 + y1) / 2))
        y0 = ym;
      else
        y1 = ym;
    } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
    return parent[j] = node, parent[i] = leaf, tree;
  }
  function addAll(data2) {
    var d, i, n2 = data2.length, x3, y3, xz = new Array(n2), yz = new Array(n2), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
    for (i = 0; i < n2; ++i) {
      if (isNaN(x3 = +this._x.call(null, d = data2[i])) || isNaN(y3 = +this._y.call(null, d)))
        continue;
      xz[i] = x3;
      yz[i] = y3;
      if (x3 < x0)
        x0 = x3;
      if (x3 > x1)
        x1 = x3;
      if (y3 < y0)
        y0 = y3;
      if (y3 > y1)
        y1 = y3;
    }
    if (x0 > x1 || y0 > y1)
      return this;
    this.cover(x0, y0).cover(x1, y1);
    for (i = 0; i < n2; ++i) {
      add(this, xz[i], yz[i], data2[i]);
    }
    return this;
  }

  // node_modules/d3-quadtree/src/cover.js
  function cover_default(x3, y3) {
    if (isNaN(x3 = +x3) || isNaN(y3 = +y3))
      return this;
    var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
    if (isNaN(x0)) {
      x1 = (x0 = Math.floor(x3)) + 1;
      y1 = (y0 = Math.floor(y3)) + 1;
    } else {
      var z = x1 - x0 || 1, node = this._root, parent, i;
      while (x0 > x3 || x3 >= x1 || y0 > y3 || y3 >= y1) {
        i = (y3 < y0) << 1 | x3 < x0;
        parent = new Array(4), parent[i] = node, node = parent, z *= 2;
        switch (i) {
          case 0:
            x1 = x0 + z, y1 = y0 + z;
            break;
          case 1:
            x0 = x1 - z, y1 = y0 + z;
            break;
          case 2:
            x1 = x0 + z, y0 = y1 - z;
            break;
          case 3:
            x0 = x1 - z, y0 = y1 - z;
            break;
        }
      }
      if (this._root && this._root.length)
        this._root = node;
    }
    this._x0 = x0;
    this._y0 = y0;
    this._x1 = x1;
    this._y1 = y1;
    return this;
  }

  // node_modules/d3-quadtree/src/data.js
  function data_default() {
    var data2 = [];
    this.visit(function(node) {
      if (!node.length)
        do
          data2.push(node.data);
        while (node = node.next);
    });
    return data2;
  }

  // node_modules/d3-quadtree/src/extent.js
  function extent_default(_) {
    return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
  }

  // node_modules/d3-quadtree/src/quad.js
  function quad_default(node, x0, y0, x1, y1) {
    this.node = node;
    this.x0 = x0;
    this.y0 = y0;
    this.x1 = x1;
    this.y1 = y1;
  }

  // node_modules/d3-quadtree/src/find.js
  function find_default(x3, y3, radius2) {
    var data2, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;
    if (node)
      quads.push(new quad_default(node, x0, y0, x32, y32));
    if (radius2 == null)
      radius2 = Infinity;
    else {
      x0 = x3 - radius2, y0 = y3 - radius2;
      x32 = x3 + radius2, y32 = y3 + radius2;
      radius2 *= radius2;
    }
    while (q = quads.pop()) {
      if (!(node = q.node) || (x1 = q.x0) > x32 || (y1 = q.y0) > y32 || (x22 = q.x1) < x0 || (y22 = q.y1) < y0)
        continue;
      if (node.length) {
        var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;
        quads.push(
          new quad_default(node[3], xm, ym, x22, y22),
          new quad_default(node[2], x1, ym, xm, y22),
          new quad_default(node[1], xm, y1, x22, ym),
          new quad_default(node[0], x1, y1, xm, ym)
        );
        if (i = (y3 >= ym) << 1 | x3 >= xm) {
          q = quads[quads.length - 1];
          quads[quads.length - 1] = quads[quads.length - 1 - i];
          quads[quads.length - 1 - i] = q;
        }
      } else {
        var dx = x3 - +this._x.call(null, node.data), dy = y3 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
        if (d2 < radius2) {
          var d = Math.sqrt(radius2 = d2);
          x0 = x3 - d, y0 = y3 - d;
          x32 = x3 + d, y32 = y3 + d;
          data2 = node.data;
        }
      }
    }
    return data2;
  }

  // node_modules/d3-quadtree/src/remove.js
  function remove_default(d) {
    if (isNaN(x3 = +this._x.call(null, d)) || isNaN(y3 = +this._y.call(null, d)))
      return this;
    var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x3, y3, xm, ym, right, bottom, i, j;
    if (!node)
      return this;
    if (node.length)
      while (true) {
        if (right = x3 >= (xm = (x0 + x1) / 2))
          x0 = xm;
        else
          x1 = xm;
        if (bottom = y3 >= (ym = (y0 + y1) / 2))
          y0 = ym;
        else
          y1 = ym;
        if (!(parent = node, node = node[i = bottom << 1 | right]))
          return this;
        if (!node.length)
          break;
        if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])
          retainer = parent, j = i;
      }
    while (node.data !== d)
      if (!(previous = node, node = node.next))
        return this;
    if (next = node.next)
      delete node.next;
    if (previous)
      return next ? previous.next = next : delete previous.next, this;
    if (!parent)
      return this._root = next, this;
    next ? parent[i] = next : delete parent[i];
    if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
      if (retainer)
        retainer[j] = node;
      else
        this._root = node;
    }
    return this;
  }
  function removeAll(data2) {
    for (var i = 0, n2 = data2.length; i < n2; ++i)
      this.remove(data2[i]);
    return this;
  }

  // node_modules/d3-quadtree/src/root.js
  function root_default() {
    return this._root;
  }

  // node_modules/d3-quadtree/src/size.js
  function size_default() {
    var size = 0;
    this.visit(function(node) {
      if (!node.length)
        do
          ++size;
        while (node = node.next);
    });
    return size;
  }

  // node_modules/d3-quadtree/src/visit.js
  function visit_default(callback) {
    var quads = [], q, node = this._root, child, x0, y0, x1, y1;
    if (node)
      quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
    while (q = quads.pop()) {
      if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
        var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
        if (child = node[3])
          quads.push(new quad_default(child, xm, ym, x1, y1));
        if (child = node[2])
          quads.push(new quad_default(child, x0, ym, xm, y1));
        if (child = node[1])
          quads.push(new quad_default(child, xm, y0, x1, ym));
        if (child = node[0])
          quads.push(new quad_default(child, x0, y0, xm, ym));
      }
    }
    return this;
  }

  // node_modules/d3-quadtree/src/visitAfter.js
  function visitAfter_default(callback) {
    var quads = [], next = [], q;
    if (this._root)
      quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
    while (q = quads.pop()) {
      var node = q.node;
      if (node.length) {
        var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
        if (child = node[0])
          quads.push(new quad_default(child, x0, y0, xm, ym));
        if (child = node[1])
          quads.push(new quad_default(child, xm, y0, x1, ym));
        if (child = node[2])
          quads.push(new quad_default(child, x0, ym, xm, y1));
        if (child = node[3])
          quads.push(new quad_default(child, xm, ym, x1, y1));
      }
      next.push(q);
    }
    while (q = next.pop()) {
      callback(q.node, q.x0, q.y0, q.x1, q.y1);
    }
    return this;
  }

  // node_modules/d3-quadtree/src/x.js
  function defaultX(d) {
    return d[0];
  }
  function x_default(_) {
    return arguments.length ? (this._x = _, this) : this._x;
  }

  // node_modules/d3-quadtree/src/y.js
  function defaultY(d) {
    return d[1];
  }
  function y_default(_) {
    return arguments.length ? (this._y = _, this) : this._y;
  }

  // node_modules/d3-quadtree/src/quadtree.js
  function quadtree(nodes, x3, y3) {
    var tree = new Quadtree(x3 == null ? defaultX : x3, y3 == null ? defaultY : y3, NaN, NaN, NaN, NaN);
    return nodes == null ? tree : tree.addAll(nodes);
  }
  function Quadtree(x3, y3, x0, y0, x1, y1) {
    this._x = x3;
    this._y = y3;
    this._x0 = x0;
    this._y0 = y0;
    this._x1 = x1;
    this._y1 = y1;
    this._root = void 0;
  }
  function leaf_copy(leaf) {
    var copy2 = { data: leaf.data }, next = copy2;
    while (leaf = leaf.next)
      next = next.next = { data: leaf.data };
    return copy2;
  }
  var treeProto = quadtree.prototype = Quadtree.prototype;
  treeProto.copy = function() {
    var copy2 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
    if (!node)
      return copy2;
    if (!node.length)
      return copy2._root = leaf_copy(node), copy2;
    nodes = [{ source: node, target: copy2._root = new Array(4) }];
    while (node = nodes.pop()) {
      for (var i = 0; i < 4; ++i) {
        if (child = node.source[i]) {
          if (child.length)
            nodes.push({ source: child, target: node.target[i] = new Array(4) });
          else
            node.target[i] = leaf_copy(child);
        }
      }
    }
    return copy2;
  };
  treeProto.add = add_default;
  treeProto.addAll = addAll;
  treeProto.cover = cover_default;
  treeProto.data = data_default;
  treeProto.extent = extent_default;
  treeProto.find = find_default;
  treeProto.remove = remove_default;
  treeProto.removeAll = removeAll;
  treeProto.root = root_default;
  treeProto.size = size_default;
  treeProto.visit = visit_default;
  treeProto.visitAfter = visitAfter_default;
  treeProto.x = x_default;
  treeProto.y = y_default;

  // node_modules/d3-force/src/constant.js
  function constant_default(x3) {
    return function() {
      return x3;
    };
  }

  // node_modules/d3-force/src/jiggle.js
  function jiggle_default(random) {
    return (random() - 0.5) * 1e-6;
  }

  // node_modules/d3-force/src/collide.js
  function x(d) {
    return d.x + d.vx;
  }
  function y(d) {
    return d.y + d.vy;
  }
  function collide_default(radius2) {
    var nodes, radii, random, strength = 1, iterations = 1;
    if (typeof radius2 !== "function")
      radius2 = constant_default(radius2 == null ? 1 : +radius2);
    function force() {
      var i, n2 = nodes.length, tree, node, xi, yi, ri, ri2;
      for (var k = 0; k < iterations; ++k) {
        tree = quadtree(nodes, x, y).visitAfter(prepare);
        for (i = 0; i < n2; ++i) {
          node = nodes[i];
          ri = radii[node.index], ri2 = ri * ri;
          xi = node.x + node.vx;
          yi = node.y + node.vy;
          tree.visit(apply);
        }
      }
      function apply(quad, x0, y0, x1, y1) {
        var data2 = quad.data, rj = quad.r, r = ri + rj;
        if (data2) {
          if (data2.index > node.index) {
            var x3 = xi - data2.x - data2.vx, y3 = yi - data2.y - data2.vy, l = x3 * x3 + y3 * y3;
            if (l < r * r) {
              if (x3 === 0)
                x3 = jiggle_default(random), l += x3 * x3;
              if (y3 === 0)
                y3 = jiggle_default(random), l += y3 * y3;
              l = (r - (l = Math.sqrt(l))) / l * strength;
              node.vx += (x3 *= l) * (r = (rj *= rj) / (ri2 + rj));
              node.vy += (y3 *= l) * r;
              data2.vx -= x3 * (r = 1 - r);
              data2.vy -= y3 * r;
            }
          }
          return;
        }
        return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
      }
    }
    function prepare(quad) {
      if (quad.data)
        return quad.r = radii[quad.data.index];
      for (var i = quad.r = 0; i < 4; ++i) {
        if (quad[i] && quad[i].r > quad.r) {
          quad.r = quad[i].r;
        }
      }
    }
    function initialize() {
      if (!nodes)
        return;
      var i, n2 = nodes.length, node;
      radii = new Array(n2);
      for (i = 0; i < n2; ++i)
        node = nodes[i], radii[node.index] = +radius2(node, i, nodes);
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random = _random;
      initialize();
    };
    force.iterations = function(_) {
      return arguments.length ? (iterations = +_, force) : iterations;
    };
    force.strength = function(_) {
      return arguments.length ? (strength = +_, force) : strength;
    };
    force.radius = function(_) {
      return arguments.length ? (radius2 = typeof _ === "function" ? _ : constant_default(+_), initialize(), force) : radius2;
    };
    return force;
  }

  // node_modules/d3-force/src/link.js
  function index(d) {
    return d.index;
  }
  function find(nodeById, nodeId) {
    var node = nodeById.get(nodeId);
    if (!node)
      throw new Error("node not found: " + nodeId);
    return node;
  }
  function link_default(links) {
    var id3 = index, strength = defaultStrength, strengths, distance = constant_default(30), distances, nodes, count2, bias, random, iterations = 1;
    if (links == null)
      links = [];
    function defaultStrength(link) {
      return 1 / Math.min(count2[link.source.index], count2[link.target.index]);
    }
    function force(alpha) {
      for (var k = 0, n2 = links.length; k < iterations; ++k) {
        for (var i = 0, link, source, target, x3, y3, l, b; i < n2; ++i) {
          link = links[i], source = link.source, target = link.target;
          x3 = target.x + target.vx - source.x - source.vx || jiggle_default(random);
          y3 = target.y + target.vy - source.y - source.vy || jiggle_default(random);
          l = Math.sqrt(x3 * x3 + y3 * y3);
          l = (l - distances[i]) / l * alpha * strengths[i];
          x3 *= l, y3 *= l;
          target.vx -= x3 * (b = bias[i]);
          target.vy -= y3 * b;
          source.vx += x3 * (b = 1 - b);
          source.vy += y3 * b;
        }
      }
    }
    function initialize() {
      if (!nodes)
        return;
      var i, n2 = nodes.length, m2 = links.length, nodeById = new Map(nodes.map((d, i2) => [id3(d, i2, nodes), d])), link;
      for (i = 0, count2 = new Array(n2); i < m2; ++i) {
        link = links[i], link.index = i;
        if (typeof link.source !== "object")
          link.source = find(nodeById, link.source);
        if (typeof link.target !== "object")
          link.target = find(nodeById, link.target);
        count2[link.source.index] = (count2[link.source.index] || 0) + 1;
        count2[link.target.index] = (count2[link.target.index] || 0) + 1;
      }
      for (i = 0, bias = new Array(m2); i < m2; ++i) {
        link = links[i], bias[i] = count2[link.source.index] / (count2[link.source.index] + count2[link.target.index]);
      }
      strengths = new Array(m2), initializeStrength();
      distances = new Array(m2), initializeDistance();
    }
    function initializeStrength() {
      if (!nodes)
        return;
      for (var i = 0, n2 = links.length; i < n2; ++i) {
        strengths[i] = +strength(links[i], i, links);
      }
    }
    function initializeDistance() {
      if (!nodes)
        return;
      for (var i = 0, n2 = links.length; i < n2; ++i) {
        distances[i] = +distance(links[i], i, links);
      }
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random = _random;
      initialize();
    };
    force.links = function(_) {
      return arguments.length ? (links = _, initialize(), force) : links;
    };
    force.id = function(_) {
      return arguments.length ? (id3 = _, force) : id3;
    };
    force.iterations = function(_) {
      return arguments.length ? (iterations = +_, force) : iterations;
    };
    force.strength = function(_) {
      return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default(+_), initializeStrength(), force) : strength;
    };
    force.distance = function(_) {
      return arguments.length ? (distance = typeof _ === "function" ? _ : constant_default(+_), initializeDistance(), force) : distance;
    };
    return force;
  }

  // node_modules/d3-dispatch/src/dispatch.js
  var noop = { value: () => {
  } };
  function dispatch() {
    for (var i = 0, n2 = arguments.length, _ = {}, t2; i < n2; ++i) {
      if (!(t2 = arguments[i] + "") || t2 in _ || /[\s.]/.test(t2))
        throw new Error("illegal type: " + t2);
      _[t2] = [];
    }
    return new Dispatch(_);
  }
  function Dispatch(_) {
    this._ = _;
  }
  function parseTypenames(typenames, types2) {
    return typenames.trim().split(/^|\s+/).map(function(t2) {
      var name2 = "", i = t2.indexOf(".");
      if (i >= 0)
        name2 = t2.slice(i + 1), t2 = t2.slice(0, i);
      if (t2 && !types2.hasOwnProperty(t2))
        throw new Error("unknown type: " + t2);
      return { type: t2, name: name2 };
    });
  }
  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _ = this._, T = parseTypenames(typename + "", _), t2, i = -1, n2 = T.length;
      if (arguments.length < 2) {
        while (++i < n2)
          if ((t2 = (typename = T[i]).type) && (t2 = get2(_[t2], typename.name)))
            return t2;
        return;
      }
      if (callback != null && typeof callback !== "function")
        throw new Error("invalid callback: " + callback);
      while (++i < n2) {
        if (t2 = (typename = T[i]).type)
          _[t2] = set(_[t2], typename.name, callback);
        else if (callback == null)
          for (t2 in _)
            _[t2] = set(_[t2], typename.name, null);
      }
      return this;
    },
    copy: function() {
      var copy2 = {}, _ = this._;
      for (var t2 in _)
        copy2[t2] = _[t2].slice();
      return new Dispatch(copy2);
    },
    call: function(type, that) {
      if ((n2 = arguments.length - 2) > 0)
        for (var args2 = new Array(n2), i = 0, n2, t2; i < n2; ++i)
          args2[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type))
        throw new Error("unknown type: " + type);
      for (t2 = this._[type], i = 0, n2 = t2.length; i < n2; ++i)
        t2[i].value.apply(that, args2);
    },
    apply: function(type, that, args2) {
      if (!this._.hasOwnProperty(type))
        throw new Error("unknown type: " + type);
      for (var t2 = this._[type], i = 0, n2 = t2.length; i < n2; ++i)
        t2[i].value.apply(that, args2);
    }
  };
  function get2(type, name2) {
    for (var i = 0, n2 = type.length, c2; i < n2; ++i) {
      if ((c2 = type[i]).name === name2) {
        return c2.value;
      }
    }
  }
  function set(type, name2, callback) {
    for (var i = 0, n2 = type.length; i < n2; ++i) {
      if (type[i].name === name2) {
        type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
        break;
      }
    }
    if (callback != null)
      type.push({ name: name2, value: callback });
    return type;
  }
  var dispatch_default = dispatch;

  // node_modules/d3-timer/src/timer.js
  var frame = 0;
  var timeout = 0;
  var interval = 0;
  var pokeDelay = 1e3;
  var taskHead;
  var taskTail;
  var clockLast = 0;
  var clockNow = 0;
  var clockSkew = 0;
  var clock = typeof performance === "object" && performance.now ? performance : Date;
  var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
    setTimeout(f, 17);
  };
  function now2() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time) {
      if (typeof callback !== "function")
        throw new TypeError("callback is not a function");
      time = (time == null ? now2() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail)
          taskTail._next = this;
        else
          taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time) {
    var t2 = new Timer();
    t2.restart(callback, delay, time);
    return t2;
  }
  function timerFlush() {
    now2();
    ++frame;
    var t2 = taskHead, e;
    while (t2) {
      if ((e = clockNow - t2._time) >= 0)
        t2._call.call(void 0, e);
      t2 = t2._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    var now3 = clock.now(), delay = now3 - clockLast;
    if (delay > pokeDelay)
      clockSkew -= delay, clockLast = now3;
  }
  function nap() {
    var t0, t1 = taskHead, t2, time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time)
          time = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }
  function sleep(time) {
    if (frame)
      return;
    if (timeout)
      timeout = clearTimeout(timeout);
    var delay = time - clockNow;
    if (delay > 24) {
      if (time < Infinity)
        timeout = setTimeout(wake, time - clock.now() - clockSkew);
      if (interval)
        interval = clearInterval(interval);
    } else {
      if (!interval)
        clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }

  // node_modules/d3-force/src/lcg.js
  var a = 1664525;
  var c = 1013904223;
  var m = 4294967296;
  function lcg_default() {
    let s = 1;
    return () => (s = (a * s + c) % m) / m;
  }

  // node_modules/d3-force/src/simulation.js
  function x2(d) {
    return d.x;
  }
  function y2(d) {
    return d.y;
  }
  var initialRadius = 10;
  var initialAngle = Math.PI * (3 - Math.sqrt(5));
  function simulation_default(nodes) {
    var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch_default("tick", "end"), random = lcg_default();
    if (nodes == null)
      nodes = [];
    function step() {
      tick();
      event.call("tick", simulation);
      if (alpha < alphaMin) {
        stepper.stop();
        event.call("end", simulation);
      }
    }
    function tick(iterations) {
      var i, n2 = nodes.length, node;
      if (iterations === void 0)
        iterations = 1;
      for (var k = 0; k < iterations; ++k) {
        alpha += (alphaTarget - alpha) * alphaDecay;
        forces.forEach(function(force) {
          force(alpha);
        });
        for (i = 0; i < n2; ++i) {
          node = nodes[i];
          if (node.fx == null)
            node.x += node.vx *= velocityDecay;
          else
            node.x = node.fx, node.vx = 0;
          if (node.fy == null)
            node.y += node.vy *= velocityDecay;
          else
            node.y = node.fy, node.vy = 0;
        }
      }
      return simulation;
    }
    function initializeNodes() {
      for (var i = 0, n2 = nodes.length, node; i < n2; ++i) {
        node = nodes[i], node.index = i;
        if (node.fx != null)
          node.x = node.fx;
        if (node.fy != null)
          node.y = node.fy;
        if (isNaN(node.x) || isNaN(node.y)) {
          var radius2 = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
          node.x = radius2 * Math.cos(angle);
          node.y = radius2 * Math.sin(angle);
        }
        if (isNaN(node.vx) || isNaN(node.vy)) {
          node.vx = node.vy = 0;
        }
      }
    }
    function initializeForce(force) {
      if (force.initialize)
        force.initialize(nodes, random);
      return force;
    }
    initializeNodes();
    return simulation = {
      tick,
      restart: function() {
        return stepper.restart(step), simulation;
      },
      stop: function() {
        return stepper.stop(), simulation;
      },
      nodes: function(_) {
        return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
      },
      alpha: function(_) {
        return arguments.length ? (alpha = +_, simulation) : alpha;
      },
      alphaMin: function(_) {
        return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
      },
      alphaDecay: function(_) {
        return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
      },
      alphaTarget: function(_) {
        return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
      },
      velocityDecay: function(_) {
        return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
      },
      randomSource: function(_) {
        return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
      },
      force: function(name2, _) {
        return arguments.length > 1 ? (_ == null ? forces.delete(name2) : forces.set(name2, initializeForce(_)), simulation) : forces.get(name2);
      },
      find: function(x3, y3, radius2) {
        var i = 0, n2 = nodes.length, dx, dy, d2, node, closest;
        if (radius2 == null)
          radius2 = Infinity;
        else
          radius2 *= radius2;
        for (i = 0; i < n2; ++i) {
          node = nodes[i];
          dx = x3 - node.x;
          dy = y3 - node.y;
          d2 = dx * dx + dy * dy;
          if (d2 < radius2)
            closest = node, radius2 = d2;
        }
        return closest;
      },
      on: function(name2, _) {
        return arguments.length > 1 ? (event.on(name2, _), simulation) : event.on(name2);
      }
    };
  }

  // node_modules/d3-force/src/manyBody.js
  function manyBody_default() {
    var nodes, node, random, alpha, strength = constant_default(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
    function force(_) {
      var i, n2 = nodes.length, tree = quadtree(nodes, x2, y2).visitAfter(accumulate);
      for (alpha = _, i = 0; i < n2; ++i)
        node = nodes[i], tree.visit(apply);
    }
    function initialize() {
      if (!nodes)
        return;
      var i, n2 = nodes.length, node2;
      strengths = new Array(n2);
      for (i = 0; i < n2; ++i)
        node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
    }
    function accumulate(quad) {
      var strength2 = 0, q, c2, weight = 0, x3, y3, i;
      if (quad.length) {
        for (x3 = y3 = i = 0; i < 4; ++i) {
          if ((q = quad[i]) && (c2 = Math.abs(q.value))) {
            strength2 += q.value, weight += c2, x3 += c2 * q.x, y3 += c2 * q.y;
          }
        }
        quad.x = x3 / weight;
        quad.y = y3 / weight;
      } else {
        q = quad;
        q.x = q.data.x;
        q.y = q.data.y;
        do
          strength2 += strengths[q.data.index];
        while (q = q.next);
      }
      quad.value = strength2;
    }
    function apply(quad, x1, _, x22) {
      if (!quad.value)
        return true;
      var x3 = quad.x - node.x, y3 = quad.y - node.y, w = x22 - x1, l = x3 * x3 + y3 * y3;
      if (w * w / theta2 < l) {
        if (l < distanceMax2) {
          if (x3 === 0)
            x3 = jiggle_default(random), l += x3 * x3;
          if (y3 === 0)
            y3 = jiggle_default(random), l += y3 * y3;
          if (l < distanceMin2)
            l = Math.sqrt(distanceMin2 * l);
          node.vx += x3 * quad.value * alpha / l;
          node.vy += y3 * quad.value * alpha / l;
        }
        return true;
      } else if (quad.length || l >= distanceMax2)
        return;
      if (quad.data !== node || quad.next) {
        if (x3 === 0)
          x3 = jiggle_default(random), l += x3 * x3;
        if (y3 === 0)
          y3 = jiggle_default(random), l += y3 * y3;
        if (l < distanceMin2)
          l = Math.sqrt(distanceMin2 * l);
      }
      do
        if (quad.data !== node) {
          w = strengths[quad.data.index] * alpha / l;
          node.vx += x3 * w;
          node.vy += y3 * w;
        }
      while (quad = quad.next);
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random = _random;
      initialize();
    };
    force.strength = function(_) {
      return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default(+_), initialize(), force) : strength;
    };
    force.distanceMin = function(_) {
      return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
    };
    force.distanceMax = function(_) {
      return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
    };
    force.theta = function(_) {
      return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
    };
    return force;
  }

  // node_modules/d3-force/src/radial.js
  function radial_default(radius2, x3, y3) {
    var nodes, strength = constant_default(0.1), strengths, radiuses;
    if (typeof radius2 !== "function")
      radius2 = constant_default(+radius2);
    if (x3 == null)
      x3 = 0;
    if (y3 == null)
      y3 = 0;
    function force(alpha) {
      for (var i = 0, n2 = nodes.length; i < n2; ++i) {
        var node = nodes[i], dx = node.x - x3 || 1e-6, dy = node.y - y3 || 1e-6, r = Math.sqrt(dx * dx + dy * dy), k = (radiuses[i] - r) * strengths[i] * alpha / r;
        node.vx += dx * k;
        node.vy += dy * k;
      }
    }
    function initialize() {
      if (!nodes)
        return;
      var i, n2 = nodes.length;
      strengths = new Array(n2);
      radiuses = new Array(n2);
      for (i = 0; i < n2; ++i) {
        radiuses[i] = +radius2(nodes[i], i, nodes);
        strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_) {
      nodes = _, initialize();
    };
    force.strength = function(_) {
      return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default(+_), initialize(), force) : strength;
    };
    force.radius = function(_) {
      return arguments.length ? (radius2 = typeof _ === "function" ? _ : constant_default(+_), initialize(), force) : radius2;
    };
    force.x = function(_) {
      return arguments.length ? (x3 = +_, force) : x3;
    };
    force.y = function(_) {
      return arguments.length ? (y3 = +_, force) : y3;
    };
    return force;
  }

  // node_modules/d3-force/src/x.js
  function x_default2(x3) {
    var strength = constant_default(0.1), nodes, strengths, xz;
    if (typeof x3 !== "function")
      x3 = constant_default(x3 == null ? 0 : +x3);
    function force(alpha) {
      for (var i = 0, n2 = nodes.length, node; i < n2; ++i) {
        node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
      }
    }
    function initialize() {
      if (!nodes)
        return;
      var i, n2 = nodes.length;
      strengths = new Array(n2);
      xz = new Array(n2);
      for (i = 0; i < n2; ++i) {
        strengths[i] = isNaN(xz[i] = +x3(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_) {
      nodes = _;
      initialize();
    };
    force.strength = function(_) {
      return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default(+_), initialize(), force) : strength;
    };
    force.x = function(_) {
      return arguments.length ? (x3 = typeof _ === "function" ? _ : constant_default(+_), initialize(), force) : x3;
    };
    return force;
  }

  // node_modules/d3-force/src/y.js
  function y_default2(y3) {
    var strength = constant_default(0.1), nodes, strengths, yz;
    if (typeof y3 !== "function")
      y3 = constant_default(y3 == null ? 0 : +y3);
    function force(alpha) {
      for (var i = 0, n2 = nodes.length, node; i < n2; ++i) {
        node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
      }
    }
    function initialize() {
      if (!nodes)
        return;
      var i, n2 = nodes.length;
      strengths = new Array(n2);
      yz = new Array(n2);
      for (i = 0; i < n2; ++i) {
        strengths[i] = isNaN(yz[i] = +y3(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_) {
      nodes = _;
      initialize();
    };
    force.strength = function(_) {
      return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default(+_), initialize(), force) : strength;
    };
    force.y = function(_) {
      return arguments.length ? (y3 = typeof _ === "function" ? _ : constant_default(+_), initialize(), force) : y3;
    };
    return force;
  }

  // src/editor/components/graphDisplay.ts
  var UpdateSimulation = (dispatch2, payload) => payload ? !(payload.simulation || payload.static) ? void 0 : updateSimulationNodes(dispatch2, payload) : dispatch2((state) => [state, [() => !state.simulation ? void 0 : updateSimulationNodes(dispatch2, state), void 0]]);
  var UpdateGraphDisplay = (dispatch2, payload) => {
    requestAnimationFrame(() => dispatch2((s) => [{
      ...s,
      levels: calculateLevels(payload.nodes, payload.links, payload.editingGraph, payload.selected)
    }]));
  };
  var updateSimulationNodes = (dispatch2, data2) => {
    const simulation_node_data = /* @__PURE__ */ new Map();
    if (!data2.clear_simulation_cache) {
      data2.simulation.nodes().forEach((n2) => {
        simulation_node_data.set(n2.node_id, n2);
      });
    }
    const start_sim_node_size = simulation_node_data.size;
    const simulation_link_data = /* @__PURE__ */ new Map();
    if (!data2.clear_simulation_cache) {
      data2.simulation.force("links").links().forEach((l) => {
        if (typeof l.source === "object" && typeof l.target === "object") {
          simulation_link_data.set(`${idFromNode(l.source)}__${idFromNode(l.target)}`, l);
        }
      });
    }
    const start_sim_link_size = simulation_link_data.size;
    const main_node_map = /* @__PURE__ */ new Map();
    const node_map = new Map(Object.entries(data2.editingGraph.nodes));
    const children_map = new Map(Object.values(data2.editingGraph.nodes).map((n2) => [
      n2.id,
      [nolib.no.runtime.get_edge_out(data2.editingGraph, n2.id)?.to].filter((e) => e)
    ]));
    const order = [];
    const queue = [data2.editingGraph.out ?? "out"];
    const parents_map = wrapPromise(Promise.all(Object.values(data2.editingGraph.nodes).map(
      (n2) => wrapPromise(nolib.no.runtime.get_edges_in(data2.editingGraph, n2.id)).then((edges) => [n2.id, edges.map((e) => e.from)]).value
    ))).then((kvs) => new Map(kvs)).then((parents_map2) => {
      while (queue.length > 0) {
        const node = queue.shift();
        order.push(node);
        main_node_map.set(node, node);
        parents_map2.get(node)?.forEach((p) => {
          queue.push(p);
        });
      }
      const ancestor_count = /* @__PURE__ */ new Map();
      const reverse_order = [...order];
      reverse_order.reverse();
      reverse_order.forEach((n2) => ancestor_count.set(n2, parents_map2.has(n2) ? parents_map2.get(n2).reduce((acc, c2) => acc + (ancestor_count.get(c2) || 0) + 1, 0) : 0));
      for (let ps of parents_map2.values()) {
        let i = 0;
        ps.sort((a2, b) => parents_map2.get(a2).length === parents_map2.get(b).length ? (simulation_node_data.get(main_node_map.get(a2))?.hash ?? hashcode(a2)) - (simulation_node_data.get(main_node_map.get(b))?.hash ?? hashcode(b)) : (i++ % 2 * 2 - 1) * (parents_map2.get(b).length - parents_map2.get(a2).length));
      }
      const ccw = ([ax, ay], [bx, by], [cx, cy]) => (cy - ay) * (bx - ax) > (by - ay) * (cx - ax);
      const nodes = order.flatMap((nid) => {
        let n2 = node_map.get(nid);
        const children = children_map.get(n2.id);
        const node_id = main_node_map.get(n2.id);
        const stored_siblings = parents_map2.get(children[0]);
        stored_siblings?.sort((a2, b) => ancestor_count.get(a2) - ancestor_count.get(b));
        const siblings = [];
        stored_siblings?.forEach((s, i) => {
          if (i % 2 == 0) {
            siblings.push(s);
          } else {
            siblings.unshift(s);
          }
        });
        const node_hash = simulation_node_data.get(node_id)?.hash ?? hashcode(nid);
        const randpos = { x: node_hash * 0.254 % 256 / 256, y: node_hash * 0.874 % 256 / 256 };
        const sibling_idx = siblings?.findIndex((v) => v === n2.id);
        const sibling_mult = sibling_idx - (siblings?.length - 1) * 0.5;
        const addorundefined = (a2, b) => {
          return a2 === void 0 || b === void 0 ? void 0 : a2 + b;
        };
        const calculated_nodes = children.length === 0 ? [{
          id: n2.id,
          node_id: n2.id,
          hash: simulation_node_data.get(node_id)?.hash ?? hashcode(n2.id),
          nested_node_count: isNodeGraph(n2) ? Object.keys(n2.nodes).length : void 0,
          nested_edge_count: isNodeGraph(n2) ? Object.keys(n2.edges).length : void 0,
          x: Math.floor(simulation_node_data.get(node_id)?.x ?? simulation_node_data.get(main_node_map.get(parents_map2.get(n2.id)?.[0]))?.x ?? Math.floor(window.innerWidth * (randpos.x * 0.5 + 0.25))),
          y: Math.floor(simulation_node_data.get(node_id)?.y ?? addorundefined(simulation_node_data.get(main_node_map.get(parents_map2.get(n2.id)?.[0]))?.y, 128) ?? Math.floor(window.innerHeight * (randpos.y * 0.5 + 0.25)))
        }] : children.map((c2, i) => ({
          id: n2.id,
          node_id: n2.id,
          hash: simulation_node_data.get(node_id)?.hash ?? hashcode(n2.id),
          sibling_index_normalized: parents_map2.get(c2).findIndex((p) => p === n2.id) / parents_map2.get(c2).length,
          nested_node_count: isNodeGraph(n2) ? Object.keys(n2.nodes).length : void 0,
          nested_edge_count: isNodeGraph(n2) ? Object.keys(n2.edges).length : void 0,
          x: Math.floor(simulation_node_data.get(node_id)?.x ?? simulation_node_data.get(main_node_map.get(parents_map2.get(n2.id)?.[0]))?.x ?? addorundefined(
            simulation_node_data.get(children[0])?.x,
            sibling_mult * (256 + 32 * Math.log(Math.max(1, ancestor_count.get(n2.id)) / Math.log(1.01)))
          ) ?? Math.floor(window.innerWidth * (randpos.x * 0.5 + 0.25))),
          y: Math.floor(simulation_node_data.get(node_id)?.y ?? addorundefined(256, simulation_node_data.get(main_node_map.get(parents_map2.get(n2.id)?.[0]))?.y) ?? addorundefined(
            -(16 + 32 * Math.log(Math.max(1, ancestor_count.get(n2.id) * 0.5 + parents_map2.get(children_map.get(n2.id)?.[0])?.length)) / Math.log(1.25)),
            simulation_node_data.get(main_node_map.get(children_map.get(n2.id)?.[0]))?.y
          ) ?? Math.floor(window.innerHeight * (randpos.y * 0.5 + 0.25)))
        }));
        const simnode = calculated_nodes[0];
        const A = [simnode.x, simnode.y];
        children.forEach((child) => {
          const cnode = simulation_node_data.get(child);
          const B = [cnode.x, cnode.y];
          for (let compnode of simulation_node_data.values()) {
            if (compnode && compnode.id !== nid && compnode.id !== child && parents_map2.has(compnode.id)) {
              const C2 = [compnode.x, compnode.y];
              for (let compp of parents_map2.get(compnode.id)) {
                const comppnode = simulation_node_data.get(compp);
                if (comppnode) {
                  const D = [comppnode.x, comppnode.y];
                  if (ccw(A, C2, D) !== ccw(B, C2, D) && ccw(A, B, C2) !== ccw(A, B, D)) {
                    const newsimnodex = comppnode.x;
                    comppnode.x = simnode.x;
                    simnode.x = newsimnodex;
                  }
                }
              }
            }
          }
        });
        calculated_nodes.map((n3) => simulation_node_data.set(n3.node_id, n3));
        return calculated_nodes;
      });
      const links = Object.values(data2.editingGraph.edges).filter((e) => main_node_map.has(e.from) && main_node_map.has(e.to)).map((e) => {
        const l = simulation_link_data.get(`${e.from}__${e.to}`);
        const proximal = ((parents_map2.get(main_node_map.get(e.to))?.length ?? 0) + (parents_map2.get(children_map.get(main_node_map.get(e.to))[0])?.length ?? 0)) * 0.5;
        return {
          ...e,
          edge: e,
          source: e.from,
          target: main_node_map.get(e.to),
          sibling_index_normalized: simulation_node_data.get(e.from).sibling_index_normalized,
          strength: 2 * (1.5 - Math.abs(simulation_node_data.get(e.from).sibling_index_normalized - 0.5)) / (1 + 2 * Math.min(4, proximal)),
          distance: 32 + 4 * Math.min(8, proximal)
        };
      }).filter((l) => !!l);
      if (typeof links?.[0]?.source === "string") {
        if (simulation_node_data.size !== start_sim_node_size || simulation_link_data.size !== start_sim_link_size || data2.simulation.nodes()?.length !== nodes.length || data2.simulation.force("links")?.links().length !== links.length) {
          data2.simulation.alpha(0.8);
        }
        data2.simulation.nodes(nodes);
        data2.simulation.force("links").links(links);
      }
      const parentlengths = [...parents_map2.values()].map((c2) => c2.length).filter((l) => l > 0);
      const maxparents = Math.max(...parentlengths);
      const avgparents = parentlengths.reduce((acc, v) => acc + v, 0) / nodes.length;
      const logmaxparents = maxparents === 1 ? nodes.length : Math.log(nodes.length) / Math.log(1 + avgparents);
      data2.simulation.force("link_direction").y((n2) => (((parents_map2.get(n2.node_id)?.length > 0 ? 1 : 0) + (children_map.get(n2.node_id)?.length > 0 ? -1 : 0) + (children_map.get(n2.node_id)?.length > 0 ? -1 : 0)) * (logmaxparents + 3) + 0.5) * window.innerHeight).strength((n2) => !!parents_map2.get(n2.node_id)?.length === !children_map.get(n2.node_id)?.length || children_map.get(n2.node_id)?.length > 0 ? 0.01 : 0);
      data2.simulation.force("collide").radius(96);
    });
  };
  var idFromNode = (node) => typeof node === "object" ? node.node_id : typeof node === "number" ? node.toFixed() : node;
  var d3subscription = (dispatch2, props) => {
    console.log("d3 called again");
    const simulation = hlib.d3.forceSimulation().force("charge", hlib.d3.forceManyBody().strength(-1024).distanceMax(1024).distanceMin(64)).force("collide", hlib.d3.forceCollide(64)).force("links", hlib.d3.forceLink([]).distance((l) => l.distance ?? 128).strength((l) => l.strength).id((n2) => n2.node_id)).force("link_direction", hlib.d3.forceY().strength(0.01)).velocityDecay(0.7).alphaMin(0.25);
    const abort_signal = { stop: false };
    simulation.stop();
    let htmlid;
    let stopped = false;
    let selected;
    let show_all = false;
    let selectedOffset = false;
    const node_el_width = 256;
    const centerObjectFn = (center) => (obj) => ({ ...obj, x: Math.floor(obj.x - center.x), y: Math.floor(obj.y - center.y) });
    const calcBoundingRect = (nodes) => {
      const rect = nodes.reduce(
        (rect2, node) => {
          rect2.x0 = Math.min(rect2.x0, node.x);
          rect2.y0 = Math.min(rect2.y0, node.y);
          rect2.x1 = Math.max(rect2.x1, node.x);
          rect2.y1 = Math.max(rect2.y1, node.y);
          return rect2;
        },
        { x0: Number.MAX_VALUE, y0: Number.MAX_VALUE, x1: Number.MIN_VALUE, y1: Number.MIN_VALUE }
      );
      const center = { x: (rect.x1 + rect.x0) * 0.5, y: (rect.y1 + rect.y0) * 0.5 };
      return { rect, center };
    };
    let initBounding = false;
    let lastAlpha;
    let currentSelectedOffset;
    const tick = () => {
      if (simulation.nodes().length === 0) {
        requestAnimationFrame(() => dispatch2((s) => [(htmlid = s.html_id, { ...s, simulation }), [props.update, s]]));
      }
      let isReset = simulation.alpha() > lastAlpha;
      lastAlpha = simulation.alpha();
      currentSelectedOffset = isReset || selected !== pzobj.centered ? false : currentSelectedOffset ?? selectedOffset;
      if (simulation.alpha() > simulation.alphaMin()) {
        currentSelectedOffset = selectedOffset;
        if (simulation.nodes().length > 0 && selected === pzobj.centered && (initBounding === false || isReset)) {
          initBounding = calcBoundingRect(simulation.nodes()).center;
          simulation.nodes().forEach((n2) => {
            if (n2.node_id === selected && initBounding) {
              selectedOffset = { x: n2.x - initBounding.x, y: n2.y - initBounding.y };
            }
          });
        }
        const boundingRect = calcBoundingRect(simulation.nodes());
        if (selected === pzobj.centered && initBounding) {
          simulation.nodes().forEach((n2) => {
            if (n2.node_id === selected && initBounding) {
              currentSelectedOffset = { x: n2.x - boundingRect.center.x, y: n2.y - boundingRect.center.y };
            }
          });
        }
        const centerObject = (obj) => ({
          ...obj,
          x: obj.x - (initBounding ? boundingRect.center.x - initBounding.x : 0) - (currentSelectedOffset && selectedOffset ? currentSelectedOffset.x - selectedOffset.x : 0),
          y: obj.y - (initBounding ? boundingRect.center.y - initBounding.y : 0) - (currentSelectedOffset && selectedOffset ? currentSelectedOffset.y - selectedOffset.y : 0)
        });
        const data2 = {
          nodes: simulation.nodes().map(centerObject),
          links: simulation.force("links").links().map((l) => ({
            ...l,
            as: l.edge.as,
            source: centerObject({
              node_id: idFromNode(l.source),
              x: l.source.x,
              y: l.source.y
            }),
            target: centerObject({
              node_id: idFromNode(l.target),
              x: l.target.x,
              y: l.target.y
            })
          }))
        };
        const ids = simulation.nodes().map((n2) => n2.node_id).join(",");
        stopped = false;
        simulation.tick();
        dispatch2([(s) => (selected = s.selected[0], show_all = s.show_all, s.nodes.map((n2) => n2.node_id).join(",") !== ids ? [props.action, data2] : s.stopped ? [
          { ...s, stopped },
          !s.noautozoom && [
            hlib.panzoom.effect,
            {
              ...s,
              nodes: data2.nodes.map((n2) => ({ ...n2, x: n2.x - 8, y: n2.y })),
              links: data2.links,
              prevent_dispatch: true,
              node_id: s.selected[0]
            }
          ]
        ] : s)]);
        const visible_nodes = [];
        const visible_node_set = /* @__PURE__ */ new Set();
        simulation.nodes().map(centerObject).map((n2) => {
          const el = document.getElementById(`${htmlid}-${n2.node_id.replaceAll("/", "_")}`);
          if (el) {
            const x3 = n2.x - node_el_width * 0.5;
            const y3 = n2.y;
            el.style.setProperty("--tx", `${(x3 - 20).toFixed()}px`);
            el.style.setProperty("--ty", `${(y3 - 20).toFixed()}px`);
            if (n2.node_id === selected) {
              visible_nodes.push({ x: x3, y: y3 });
            }
          }
        });
        simulation.force("links").links().map((l) => {
          const el = document.getElementById(`link-${idFromNode(idFromNode(l.source))}`);
          const edge_label_el = document.getElementById(`edge-info-${idFromNode(l.source)}`);
          const insert_el = document.getElementById(`insert-${idFromNode(l.source)}`);
          if (el && edge_label_el) {
            const source = centerObject({ x: l.source.x - node_el_width * 0.5, y: l.source.y });
            const target = centerObject({ x: l.target.x - node_el_width * 0.5, y: l.target.y });
            const length_x = Math.abs(source.x - target.x);
            const length_y = Math.abs(source.y - target.y);
            const length3 = Math.sqrt(length_x * length_x + length_y * length_y);
            const lerp_length = 24;
            el.setAttribute("x1", Math.floor(source.x + (target.x - source.x) * lerp_length / length3).toFixed());
            el.setAttribute("y1", Math.floor(source.y + (target.y - source.y) * lerp_length / length3).toFixed());
            el.setAttribute("x2", Math.floor(source.x + (target.x - source.x) * (1 - lerp_length / length3)).toFixed());
            el.setAttribute("y2", Math.floor(source.y + (target.y - source.y) * (1 - lerp_length / length3)).toFixed());
            const min_edge_label_dist = 32 / Math.abs(target.y - source.y);
            const max_edge_label_dist = Math.min(64 / Math.abs(target.y - source.y), 0.5);
            const edge_label_dist = Math.min(max_edge_label_dist, Math.max(min_edge_label_dist, 0.125));
            edge_label_el.setAttribute("x", ((target.x - source.x) * edge_label_dist + source.x + 16).toFixed());
            edge_label_el.setAttribute("y", ((target.y - source.y) * edge_label_dist + source.y).toFixed());
            if (insert_el) {
              insert_el.setAttribute("x", Math.floor((source.x + target.x) * 0.5 - 16).toFixed());
              insert_el.setAttribute("y", Math.floor((source.y + target.y) * 0.5 - 16).toFixed());
            }
            if (idFromNode(l.source) === selected) {
              visible_nodes.push({ x: target.x, y: target.y });
              visible_node_set.add(idFromNode(l.target));
            } else if (idFromNode(l.target) === selected) {
              visible_nodes.push({ x: source.x, y: source.y });
              visible_node_set.add(idFromNode(l.source));
            }
          }
        });
        simulation.force("links").links().map((l) => {
          if (visible_node_set.has(idFromNode(l.target)) && !visible_node_set.has(idFromNode(l.source))) {
            const source = { x: l.source.x - node_el_width * 0.5, y: l.source.y };
            visible_nodes.push({ x: source.x, y: source.y });
          }
        });
      } else if (!stopped) {
        const boundingRect = calcBoundingRect(simulation.nodes());
        if (selected === pzobj.centered && initBounding) {
          simulation.nodes().forEach((n2) => {
            if (n2.node_id === selected && initBounding) {
              currentSelectedOffset = { x: n2.x - boundingRect.center.x, y: n2.y - boundingRect.center.y };
            }
          });
        }
        const centerObject = centerObjectFn({
          x: (initBounding ? boundingRect.center.x - initBounding.x : 0) + (currentSelectedOffset && selectedOffset ? currentSelectedOffset.x - selectedOffset.x : 0),
          y: (initBounding ? boundingRect.center.y - initBounding.y : 0) + (currentSelectedOffset && selectedOffset ? currentSelectedOffset.y - selectedOffset.y : 0)
        });
        const data2 = {
          nodes: simulation.nodes().map((n2) => {
            return centerObject({ ...n2, x: Math.floor(n2.x), y: Math.floor(n2.y) });
          }),
          links: simulation.force("links").links().map((l) => ({
            ...l,
            as: l.edge.as,
            source: centerObject({
              node_id: idFromNode(l.source),
              x: Math.floor(l.source.x),
              y: Math.floor(l.source.y)
            }),
            target: centerObject({
              node_id: idFromNode(l.target),
              x: Math.floor(l.target.x),
              y: Math.floor(l.target.y)
            })
          }))
        };
        stopped = true;
        requestAnimationFrame(() => {
          initBounding = false;
          dispatch2([props.action, data2]);
          dispatch2((s) => [{ ...s, noautozoom: false, stopped }]);
        });
      }
      if (!abort_signal.stop) {
        requestAnimationFrame(tick);
      }
    };
    requestAnimationFrame(tick);
    return () => {
      abort_signal.stop = true;
    };
  };
  var fill_rect_el = () => h("rect", { class: "fill", width: "48", "height": "48" }, []);
  var node_text_el = ({ node_id, primary, focus_primary, secondary }) => h("text", { x: 48, y: 12 }, [
    h("tspan", { class: "primary", dy: ".6em", x: "48", onpointerdown: [SelectNode, { node_id, focus_property: focus_primary }] }, text(primary.substring(0, 24))),
    h("tspan", { class: "secondary", dy: "1.2em", x: "48", onpointerdown: [SelectNode, { node_id, focus_property: "ref" }] }, text(secondary.substring(0, 24)))
  ]);
  var radius = 24;
  var node_el = ({ html_id, selected, error, selected_distance, node_id, node_ref, node_name, node_value: node_value2, has_nodes, nested_edge_count, nested_node_count }) => h("g", {
    onpointerdown: [SelectNode, { node_id }],
    width: "256",
    height: "64",
    key: html_id + "-" + node_id,
    id: html_id + "-" + node_id.replaceAll("/", "_"),
    class: {
      node: true,
      selected,
      [`distance-${selected_distance < 4 ? selected_distance : "far"}`]: true
    }
  }, [
    h(
      node_value2 !== void 0 && !(node_ref && node_ref !== "arg") || node_value2 === void 0 && node_ref === void 0 ? "polygon" : node_ref === "return" ? "rect" : "circle",
      node_value2 !== void 0 && !(node_ref && node_ref !== "arg") || node_value2 === void 0 && node_ref === void 0 ? { class: { shape: true, value: true, error }, points: `4,${4 + radius} ${4 + radius},${4 + radius} ${4 + radius * 0.5},4` } : node_ref === "return" ? { class: { shape: true, ref: true, error }, width: radius, height: radius, x: 10, y: 10 } : { class: { shape: true, none: true, error }, r: radius * 0.5, cx: radius * 0.5 + 8, cy: radius * 0.5 + 8 }
    ),
    memo(node_text_el, {
      node_id,
      primary: node_name ? node_name : node_value2 ? node_value2 : "",
      focus_primary: node_name ? "name" : "value",
      secondary: node_ref ? node_ref : has_nodes ? `graph (${nested_node_count}, ${nested_edge_count})` : node_value2 !== void 0 ? "value" : 0 > 0 ? "object" : "undefined"
    }),
    memo(fill_rect_el, {})
  ]);
  var link_el = ({ link, selected_distance }) => h("g", {}, [
    h("line", { id: `link-${link.source.node_id}`, class: { "link": true, [`distance-${selected_distance}`]: true }, "marker-end": "url(#arrow)" }),
    h("svg", {
      id: `edge-info-${link.source.node_id}`,
      class: { "edge-info": true, [`distance-${selected_distance}`]: true },
      onclick: [SelectNode, { node_id: link.source.node_id, focus_property: "edge" }],
      ontouchstart: [SelectNode, { node_id: link.source.node_id, focus_property: "edge" }]
    }, [
      h("rect", {}),
      h("text", { fontSize: 14, y: 16 }, [text(link.as)])
    ])
  ]);
  var insert_node_el = ({ link, randid, node_el_width }) => h("svg", {
    viewBox: "0 0 512 512",
    id: `insert-${link.source.node_id}`,
    key: `insert-${link.source.node_id}`,
    height: "32px",
    width: "32px",
    x: Math.floor((link.source.x + link.target.x - node_el_width) * 0.5) - 16,
    y: Math.floor((link.source.y + link.target.y) * 0.5) - 16,
    class: "insert-node",
    onclick: (s, p) => [CreateNode, { node: { id: randid }, child: link.target.node_id, parent: { from: link.source.node_id, to: link.target.node_id, as: link.as } }],
    ontouchstart: (s, p) => [CreateNode, { node: { id: randid }, child: link.target.node_id, parent: { from: link.source.node_id, to: link.target.node_id, as: link.as } }]
  }, [
    h("path", { d: "M448 256c0-106-86-192-192-192S64 150 64 256s86 192 192 192 192-86 192-192z", class: "circle" }, []),
    h("path", { d: "M256 176v160M336 256H176", class: "add" }, [])
  ]);

  // src/editor/autocomplete.ts
  var AutocompleteList = class extends HTMLElement {
    listEl;
    inputEl;
    options;
    fuseOptions;
    shownOptions;
    optionEls;
    fuse;
    selectedIndex;
    initialOption;
    focused;
    constructor() {
      super();
      this.attachShadow({ mode: "open", delegatesFocus: true });
      const wrapper = document.createElement("div");
      wrapper.classList.add("autocomplete-list");
      const style = document.createElement("style");
      style.textContent = `
      .hidden {
        display: none;
      }

      input {
        color: white;
        font-family: consolas;
        margin: 0;
        border: none;
        background-color: #000;
      }

      .autocomplete-list ul {
        position: absolute;
        margin: 0;
        padding: 0;
        z-index: 999;
        list-style-type: none;
        overflow-y: auto;
        overflow-x: hidden;
        background: #000;
        max-height: 16em;
        width: 100%;
      }

      .autocomplete-item {
        line-height: 1.2em;
        padding: .2em;
        padding-left: 0.4em;
        width: 100%;
      }

      .autocomplete-item.selected, .autocomplete-item:hover {
        background: #333;
      }

      .autocomplete-group {
        line-height: 1.4em;
        padding: .2em;
        font-weight: bold;
        padding-top: .4em;
        border-top: 1px solid #111;
      }
    `;
      this.inputEl = document.createElement("input");
      this.inputEl.onkeydown = (evt) => {
        if (evt.key === "Tab") {
          evt.stopPropagation();
          this.selectOption(this.inputEl.value);
        } else if (evt.key === "ArrowDown") {
          evt.stopPropagation();
          this.selectedIndex = this.selectedIndex === void 0 ? 0 : this.selectedIndex + 1;
        } else if (evt.key === "ArrowUp") {
          evt.stopPropagation();
          this.selectedIndex = this.selectedIndex === void 0 ? -1 : this.selectedIndex - 1;
        } else if (evt.key === "Enter") {
          evt.stopPropagation();
          if (this.selectedIndex !== void 0 && this.fuseOptions.length > 0) {
            const count2 = this.fuseOptions.length;
            this.inputEl.value = this.fuseOptions[(this.selectedIndex % count2 + count2) % count2].value;
          }
          this.selectOption(this.inputEl.value);
        }
      };
      this.inputEl.onkeyup = (evt) => {
        this.populateOptions();
      };
      wrapper.addEventListener("focusin", (evt) => {
        if (!this.focused) {
          this.initialOption = this.inputEl.value;
        }
        this.focused = true;
        if (this.listEl.classList.contains("hidden")) {
          this.listEl.classList.remove("hidden");
          this.populateOptions();
        }
      });
      wrapper.addEventListener("focusout", (evt) => {
        if (!wrapper.contains(evt.relatedTarget)) {
          this.listEl.classList.add("hidden");
          this.selectOption(this.inputEl.value);
          this.focused = false;
        } else {
          this.focused = true;
        }
      });
      this.listEl = document.createElement("ul");
      this.listEl.classList.add("hidden");
      this.shadowRoot.append(style, wrapper);
      wrapper.appendChild(this.inputEl);
      wrapper.appendChild(this.listEl);
    }
    static get observedAttributes() {
      return ["value"];
    }
    attributeChangedCallback(name2, oldValue, newValue) {
      if (name2 === "value" && !this.focused) {
        this.inputEl.value = newValue;
        this.optionEls = {};
        this.populateOptions();
      }
    }
    connectedCallback() {
      this.inputEl.value = this.getAttribute("value");
      this.optionEls = {};
      this.populateOptions();
    }
    selectOption(value) {
      this.selectedIndex = void 0;
      if (this.initialOption !== value) {
        this.inputEl.value = value;
        this.dispatchEvent(new CustomEvent("select", { detail: value }));
      }
    }
    focus() {
      this.focused = true;
      console.log("settinginitial");
      this.initialOption = this.inputEl.value;
      this.inputEl.focus();
    }
    select() {
      this.inputEl.select();
      this.populateOptions();
    }
    populateOptions() {
      this.options = Object.fromEntries([...this.querySelectorAll("option")].map((el) => [el.textContent, { value: el.textContent, category: el.dataset.category }]));
      this.fuse = new Fuse(Object.values(this.options), { keys: ["value"], distance: 40, threshold: 0.4 });
      const optionsByCategory = (options) => [...options.reduce((acc, option) => acc.set(
        option.category ?? "custom",
        (acc.get(option.category ?? "custom") ?? []).concat([option.category && !acc.has(option.category) ? { kind: "category", value: option.category } : void 0, { kind: "value", value: option.value }])
      ), /* @__PURE__ */ new Map()).values()].flat().filter((o) => o);
      if (this.inputEl.value && this.inputEl.selectionEnd - this.inputEl.selectionStart < this.inputEl.value.length) {
        this.fuseOptions = this.fuse.search(this.inputEl.value).map((searchResult) => searchResult.item);
        this.shownOptions = optionsByCategory(this.fuseOptions);
      } else {
        this.shownOptions = optionsByCategory(Object.values(this.options));
      }
      while (this.listEl.firstChild) {
        this.listEl.removeChild(this.listEl.firstChild);
      }
      let itemIdx = -1;
      const count2 = this.shownOptions.filter((o) => o.kind === "value").length;
      const countSelectedIndex = (this.selectedIndex % count2 + count2) % count2;
      this.shownOptions?.forEach((option) => {
        const itemEl = document.createElement("li");
        itemEl.classList.add(option.kind === "value" ? "autocomplete-item" : "autocomplete-group");
        itemEl.textContent = option.value;
        itemEl.setAttribute("value", option.value);
        itemEl.setAttribute("tabIndex", "-1");
        this.listEl.appendChild(itemEl);
        if (option.kind === "value") {
          itemEl.onclick = (evt) => this.selectOption(evt.target.getAttribute("value"));
          itemIdx++;
          if (itemIdx === countSelectedIndex) {
            itemEl.classList.add("selected");
          }
        }
        this.optionEls[option.value] = itemEl;
      });
    }
  };

  // src/editor/util.ts
  var EXAMPLES = ["threejs_example", "threejs_update_geo", "hydra_example"];
  var middleware = (dispatch2) => (ha_action, ha_payload) => {
    const is_action_array_payload = Array.isArray(ha_action) && ha_action.length === 2 && (typeof ha_action[0] === "function" || isRunnable(ha_action[0]));
    const is_action_obj_payload = isRunnable(ha_action);
    const action = is_action_array_payload ? ha_action[0] : ha_action;
    const payload = is_action_array_payload ? ha_action[1] : is_action_obj_payload ? { event: ha_payload } : ha_payload;
    return typeof action === "object" && isRunnable(ha_action) ? dispatch2((state, payload2) => {
      try {
        const result = action.stateonly ? hlib.run_runnable(action, state) : hlib.run_runnable(action, { state, ...payload2 });
        if (!result) {
          return state;
        }
        const effects = (result.effects ?? []).filter((e) => e).map((e) => {
          if (isRunnable(e)) {
            const effect_fn = hlib.run_runnable(e);
            return effect_fn;
          }
          return e;
        });
        if (ispromise(result)) {
          return state;
        }
        return result.hasOwnProperty("state") ? effects.length > 0 ? [result.state, ...effects] : result.state : result.hasOwnProperty("action") && result.hasOwnProperty("payload") ? [result.action, result.payload] : state;
      } catch (e) {
        return { ...state, error: e };
      }
    }, payload) : dispatch2(action, payload);
  };
  var pzobj = {
    centered: false,
    instance: false,
    lastpanzoom: false,
    animationframe: false,
    effect: function(dispatch2, payload) {
      if (!hlib.panzoom.instance || !payload.node_id) {
        pzobj.centered = false;
        return;
      }
      pzobj.centered = payload.node_id;
      pzobj.lastpanzoom = performance.now();
      const viewbox = findViewBox2(
        payload.nodes,
        payload.links,
        payload.node_id,
        payload.node_el_width,
        payload.html_id,
        payload.dimensions
      );
      const x3 = payload.dimensions.x * 0.5 - viewbox.center.x;
      const y3 = payload.dimensions.y * 0.5 - viewbox.center.y;
      const scale = hlib.panzoom.instance.getTransform().scale;
      hlib.panzoom.instance.moveTo(x3, y3);
      hlib.panzoom.instance.zoomTo(x3, y3, 1 / scale);
      if (!payload.prevent_dispatch) {
        if (pzobj.animationframe) {
          cancelAnimationFrame(pzobj.animationframe);
        }
        pzobj.animationframe = requestAnimationFrame(() => {
          pzobj.animationframe = false;
          dispatch2((s, p) => [
            { ...s, show_all: false },
            [() => requestAnimationFrame(() => nolib.no.runtime.publish("show_all", { data: false }))]
          ]);
        });
      }
    },
    getTransform: function() {
      const ret = hlib?.panzoom?.instance?.getTransform?.();
      return ret;
    },
    init: function(dispatch2, sub_payload) {
      hlib.panzoom.lastpanzoom = 0;
      let init2 = requestAnimationFrame(() => {
        hlib.panzoom.instance = (0, pz.default)(document.getElementById(sub_payload.id), {
          filterKey: () => true,
          smoothScroll: false,
          onTouch: (e) => {
            if (e.target.id.endsWith("-editor") && hlib.panzoom.lastpanzoom && performance.now() - hlib.panzoom.lastpanzoom > 100) {
              dispatch2(sub_payload.action, { event: "panstart", transform: hlib.panzoom.instance.getTransform(), noautozoom: true });
            }
            return true;
          },
          beforeWheel: (e) => {
            if (e.target.id.endsWith("-editor") && hlib.panzoom.lastpanzoom && performance.now() - hlib.panzoom.lastpanzoom > 100) {
              dispatch2(sub_payload.action, { event: "panstart", transform: hlib.panzoom.instance.getTransform(), noautozoom: true });
            }
            return false;
          },
          beforeMouseDown: (e) => {
            const should_zoom = e.buttons == 4 || e.altKey;
            if (!should_zoom && e.target.id.endsWith("-editor")) {
              dispatch2(sub_payload.action, { event: "panstart", transform: hlib.panzoom.instance.getTransform(), noautozoom: true });
            }
            return should_zoom;
          }
        });
        let currentEvent = false;
        document.getElementById(sub_payload.id).ownerSVGElement.addEventListener("pointermove", (e) => {
          if (e.buttons == 4 || e.altKey) {
            if (!currentEvent) {
              currentEvent = {
                offset: {
                  x: e.offsetX,
                  y: e.offsetY
                }
              };
            }
            const movementSign = Math.abs(e.movementX) > Math.abs(e.movementY) ? e.movementX : -e.movementY;
            const scaleMultiplier = 1 + movementSign * 0.01;
            hlib.panzoom.instance.zoomTo(currentEvent.offset.x, currentEvent.offset.y, scaleMultiplier);
          } else {
            currentEvent = false;
          }
        });
        document.getElementById(sub_payload.id).ownerSVGElement.addEventListener("pointerup", (e) => {
          currentEvent = false;
        });
        hlib.panzoom.instance.moveTo(window.innerWidth * 0, window.innerHeight * 0.5);
        hlib.panzoom.instance.on("transform", (e) => {
        });
      });
      return () => {
        cancelAnimationFrame(init2);
        hlib.panzoom.instance?.dispose();
      };
    }
  };
  var isNodysseusError = (e) => e && (e instanceof nolib.no.NodysseusError || e.node_id);
  var update_info_display = ({ fn, graph, args: args2, lib }, info_display_dispatch2, code_editor, code_editor_nodeid2, graphChanged = true) => {
    const node = nolib.no.runtime.get_node(graph, fn);
    if (!node) {
      return;
    }
    const node_ref = node && (node.ref && nolib.no.runtime.get_ref(node.ref)) || node;
    const out_ref = node && (node.nodes && nolib.no.runtime.get_node(node, node.out)) || node_ref?.nodes && nolib.no.runtime.get_node(node_ref, node_ref.out);
    const node_display_el = hlib.run(graph, fn, { ...args2, _output: "display" }, lib, { profile: false });
    const update_info_display_fn = (display) => info_display_dispatch2 && requestAnimationFrame(() => {
      info_display_dispatch2(UpdateResultDisplay, { el: display?.dom_type ? display : h("div", {}) });
      requestAnimationFrame(() => {
        if (graphChanged) {
          code_editor.dispatch({
            changes: { from: 0, to: code_editor.state.doc.length, insert: node.script ?? node.value },
            effects: [code_editor_nodeid2.of(node.id)]
          });
        }
      });
    });
    wrapPromise(node_display_el).then(update_info_display_fn);
  };
  var update_graph_list = (graph_id) => {
    const graph_list = JSON.parse(localStorage.getItem("graph_list"))?.filter((l) => l !== graph_id) ?? [];
    graph_list.unshift(graph_id);
    localStorage.setItem("graph_list", JSON.stringify(graph_list));
  };
  var SetSelectedPositionStyleEffect = (_, { node, svg_offset, dimensions }) => {
    const rt = document.querySelector(":root");
    rt.style.setProperty("--nodex", `${Math.min(node.x * (svg_offset?.scale ?? 1) + (svg_offset?.x ?? 0) - 64, dimensions.x - 256)}px`);
    rt.style.setProperty("--nodey", `${node.y * (svg_offset?.scale ?? 1) + (svg_offset?.y ?? 0) + 32}px`);
  };
  var ChangeEditingGraphId = (dispatch2, { id: id3, select_out, editingGraphId }) => {
    requestAnimationFrame(() => {
      const graphPromise = wrapPromise(
        EXAMPLES.includes(id3) && !nolib.no.runtime.refs().includes(id3) ? fetch((console.log(`fetching ${id3}`), `json/${id3}.json`)).then((res) => res.json()).then((g) => {
          return nolib.no.runtime.add_ref(g[0]);
        }).then((g) => {
          nolib.no.runtime.change_graph(g, hlib);
          return g;
        }) : nolib.no.runtime.get_ref(id3, editingGraphId && nolib.no.runtime.get_ref(editingGraphId))
      );
      window.location.hash = "#" + id3;
      graphPromise.then((graph) => dispatch2((state) => [
        { ...state, editingGraphId: id3 },
        [(dispatch3) => {
          requestAnimationFrame(() => {
            update_graph_list(id3);
            const new_graph = graph ?? Object.assign({}, base_graph(state.editingGraph), { id: id3 });
            if (!new_graph.edges_in) {
              new_graph.edges_in = Object.values(new_graph.edges).reduce((acc, edge) => ({ ...acc, [edge.to]: { ...acc[edge.to] ?? {}, [edge.from]: edge } }), {});
            }
            nolib.no.runtime.change_graph(new_graph, hlib);
            nolib.no.runtime.remove_graph_listeners(state.editingGraphId);
            dispatch3((s) => {
              const news = { ...s, editingGraph: new_graph, selected: [new_graph.out], editingGraphId: new_graph.id };
              return [news, [UpdateSimulation, { ...news, clear_simulation_cache: true }], select_out && [() => {
                setTimeout(() => {
                  dispatch3(SelectNode, { node_id: new_graph.out ?? "out" });
                }, 100);
              }, {}]];
            });
            if (!graph) {
              wrapPromise(nolib.no.runtime.get_node(new_graph, new_graph.out)).then((node) => {
                dispatch3(UpdateNode, {
                  node,
                  property: "name",
                  value: id3,
                  editingGraph: new_graph
                });
              });
            }
          });
        }, {}]
      ]));
    });
  };
  var CreateNode = (state, { node, child, child_as, parent }) => [
    state,
    (dispatch2) => {
      console.log(node);
      nolib.no.runtime.add_node(state.editingGraph, node, hlib);
      nolib.no.runtime.update_edges(
        state.editingGraph,
        parent ? [{ from: node.id, to: child, as: parent.as }, { from: parent.from, to: node.id, as: "arg0" }] : [{ from: node.id, to: child, as: child_as }],
        parent ? [{ from: parent.from, to: child }] : [],
        hlib
      );
      setTimeout(() => requestAnimationFrame(() => dispatch2(SelectNode, { node_id: node.id })), 50);
    }
  ];
  var DeleteNode = (state, { node_id }) => [
    state,
    [(dispatch2, { node_id: node_id2 }) => dispatch2(SelectNode, { node_id: node_id2 }), { node_id: nolib.no.runtime.get_edge_out(state.editingGraph, node_id).to }],
    [() => requestAnimationFrame(() => nolib.no.runtime.delete_node(state.editingGraph, node_id, hlib))]
  ];
  var ExpandContract = (state, { node_id }) => {
    const node = state.editingGraph.nodes[node_id];
    const update = node.nodes ? expand_node({ nolib, node_id, editingGraph: state.editingGraph }) : contract_node({ nolib, node_id, editingGraph: state.editingGraph });
    return [
      state,
      [(dispatch2) => {
        requestAnimationFrame(() => {
          dispatch2(SelectNode, { node_id: update.selected[0] });
        });
      }]
    ];
  };
  var CreateRef = (state, { node }) => [
    state,
    [(dispatch2) => {
      const graph = { ...base_graph(node), id: node.name, value: void 0 };
      nolib.no.runtime.change_graph(base_graph(graph), hlib);
      save_graph(graph);
      nolib.no.runtime.add_node(state.editingGraph, {
        id: node.id,
        value: node.value,
        ref: node.name,
        name: void 0
      }, hlib);
    }]
  ];
  var Copy = (state, { cut, as }) => {
    return { ...state, copied: { graph: ancestor_graph(state.selected[0], state.editingGraph, nolib), root: state.selected[0], as } };
  };
  var Paste = (state) => [
    { ...state },
    [(dispatch2) => {
      const node_id_map = {};
      Object.values(state.copied.graph.nodes).forEach((n2) => {
        const new_id = create_randid();
        node_id_map[n2.id] = new_id;
        nolib.no.runtime.add_node(state.editingGraph, { ...n2, id: new_id }, hlib);
      });
      nolib.no.runtime.update_edges(
        state.editingGraph,
        Object.values(state.copied.graph.edges).map((e) => ({ ...e, from: node_id_map[e.from], to: node_id_map[e.to] })).concat([{ from: node_id_map[state.copied.root], to: state.selected[0], as: state.copied.as }]),
        [],
        hlib
      );
      requestAnimationFrame(() => dispatch2(SelectNode, { node_id: node_id_map[state.copied.root], focus_property: "edge" }));
    }]
  ];
  var SelectNode = (state, { node_id, focus_property }) => state.editingGraph.nodes[node_id] ? [
    state.selected[0] === node_id ? state : {
      ...state,
      selected: [node_id],
      inputs: {},
      selected_edges_in: nolib.no.runtime.get_edges_in(state.editingGraph, node_id),
      noautozoom: false
    },
    !state.show_all && [pzobj.effect, { ...state, node_id }],
    [UpdateGraphDisplay, { ...state, selected: [node_id] }],
    (state.show_all || state.selected[0] !== node_id) && [pzobj.effect, { ...state, node_id }],
    focus_property && [FocusEffect, { selector: `.node-info .${focus_property}` }],
    state.nodes.find((n2) => n2.node_id === node_id) && [SetSelectedPositionStyleEffect, { node: state.nodes.find((n2) => n2.node_id === node_id), svg_offset: pzobj.getTransform(), dimensions: state.dimensions }],
    node_id === state.editingGraph.out ? [(dispatch2) => state.info_display_dispatch({ el: { dom_type: "div", props: {}, children: [
      { dom_type: "text_value", text: "Most recent graphs" },
      {
        dom_type: "ul",
        props: {},
        children: localStorage.getItem("graph_list") ? JSON.parse(localStorage.getItem("graph_list")).slice(0, 10).map((gid) => ({ dom_type: "li", props: {}, children: [
          {
            dom_type: "a",
            props: { href: "#", onclick: (s) => [s, [() => dispatch2((ms) => [ms, [ChangeEditingGraphId, { id: gid, editingGraphId: state.editingGraphId }]])]] },
            children: [{ dom_type: "text_value", text: gid }]
          }
        ] })) : []
      }
    ] } }), {}] : [() => update_info_display({
      fn: node_id,
      graph: state.editingGraph,
      args: {},
      lib: { ...hlib, ...nolib, ...hlib.run(state.editingGraph, state.editingGraph.out ?? "out", { _output: "lib" }) }
    }, state.info_display_dispatch, state.code_editor, state.code_editor_nodeid, state.selected[0] !== node_id), {}],
    state.selected[0] !== node_id && [() => nolib.no.runtime.publish("nodeselect", { data: { nodeId: node_id, graphId: state.editingGraphId } }), {}]
  ] : state;
  var CustomDOMEvent = (_, payload) => document.getElementById(`${payload.html_id}`)?.dispatchEvent(new CustomEvent(payload.event, { detail: payload.detail }));
  var FocusEffect = (_, { selector }) => {
    setTimeout(() => {
      const el = document.querySelector(selector);
      if (!el) {
        console.log(`couldn't find ${selector}`);
        return;
      }
      el.focus();
      if (el instanceof HTMLInputElement && el.type === "text" || el instanceof AutocompleteList) {
        el.select();
      }
    }, 100);
  };
  var SaveGraph = (dispatch2, payload) => save_graph(payload.editingGraph);
  var UpdateResultDisplay = (state, resel) => {
    const el = resel.el ?? resel;
    return compareObjects(el, state.el) ? state : {
      ...state,
      el
    };
  };
  var UpdateNodeEffect = (_, { editingGraph, node }) => {
    nolib.no.runtime.add_node(editingGraph, node, hlib);
    const edges_in = nolib.no.runtime.get_edges_in(editingGraph, node.id);
    const nodeargs = node_args(nolib, editingGraph, node.id);
    if (edges_in.length === 1) {
      if (nodeargs.length === 2) {
        nolib.no.runtime.update_edges(editingGraph, [{ ...edges_in[0], as: nodeargs.find((a2) => !a2.additionalArg).name }], [], hlib);
      } else if (nodeargs.find((a2) => a2.name.split(": ")[1] === "default")) {
        nolib.no.runtime.update_edges(editingGraph, [{ ...edges_in[0], as: nodeargs.map((a2) => a2.name.split(": ")).find((e) => e[1] === "default")[0] }], [], hlib);
      }
    }
  };
  var UpdateNode = (state, { node, property, value, editingGraph }) => [
    state,
    [UpdateNodeEffect, {
      editingGraph: editingGraph ?? state.editingGraph,
      node: Object.fromEntries(Object.entries(Object.assign(
        {},
        base_node(typeof node === "string" ? (editingGraph ?? state.editingGraph).nodes[node] : node ? node : state.editingGraph.nodes[state.selected[0]]),
        { [property]: value === "" ? void 0 : value }
      )).filter((kv) => kv[1] !== void 0))
    }]
  ];
  var UpdateEdge = (state, { edge, as }) => [
    state,
    [() => nolib.no.runtime.update_edges(state.editingGraph, { ...edge, as }, edge, hlib), {}]
  ];
  var keydownSubscription = (dispatch2, options) => {
    const handler = (ev) => {
      if ((ev.key === "s" || ev.key === "o") && ev.ctrlKey) {
        ev.preventDefault();
      } else if (!ev.key) {
        return;
      }
      requestAnimationFrame(() => dispatch2(options.action, ev));
    };
    requestAnimationFrame(() => addEventListener("keydown", handler));
    return () => removeEventListener("keydown", handler);
  };
  var refresh_graph = (dispatch2, { graph, graphChanged, norun, result_display_dispatch: result_display_dispatch2, info_display_dispatch: info_display_dispatch2, code_editor, code_editor_nodeid: code_editor_nodeid2 }) => {
    if (norun ?? false) {
      return;
    }
    const result = hlib.run(graph, graph.out ?? "out", { _output: "value" }, void 0, { profile: false });
    const reslib = hlib.run(graph, graph.out ?? "out", { _output: "lib" });
    const display_fn = (result2) => hlib.run(graph, graph.out ?? "out", { _output: "display" }, { profile: false });
    const update_result_display_fn = (display) => result_display_dispatch2(UpdateResultDisplay, { el: display && display.dom_type ? display : { dom_type: "div", props: {}, children: [] } });
    const update_info_display_fn = () => dispatch2((s) => [s, s.selected[0] !== s.editingGraph.out && !s.show_all && [() => update_info_display({ fn: s.selected[0], graph: s.editingGraph, args: {}, lib: { ...hlib, ...nolib, ...reslib } }, info_display_dispatch2, code_editor, code_editor_nodeid2, graphChanged)]]);
    wrapPromise(result).then(display_fn).then(update_result_display_fn);
    wrapPromise(result).then(update_info_display_fn);
    return result;
  };
  var result_subscription = (dispatch2, { editingGraphId, displayGraphId, norun }) => {
    let animrun = false;
    const error_listener = (error) => requestAnimationFrame(() => {
      dispatch2((s) => Object.assign({}, s, { error: s.error ? s.error.concat([error]) : [error] }));
    });
    nolib.no.runtime.add_listener("grapherror", "update_hyperapp_error", error_listener);
    let info_display_dispatch2, code_editor, code_editor_nodeid2, result_display_dispatch2;
    const change_listener = (graph) => {
      if (animrun) {
        cancelAnimationFrame(animrun);
      }
      if (info_display_dispatch2 && code_editor && code_editor_nodeid2 && result_display_dispatch2) {
        animrun = requestAnimationFrame(() => {
          if (graph.id === (displayGraphId || editingGraphId)) {
            const result = refresh_graph(dispatch2, { graph: nolib.no.runtime.get_ref(displayGraphId || editingGraphId), graphChanged: false, norun, info_display_dispatch: info_display_dispatch2, code_editor, code_editor_nodeid: code_editor_nodeid2, result_display_dispatch: result_display_dispatch2 });
            const reset_animrun = () => animrun = false;
            wrapPromise(result, reset_animrun).then(reset_animrun);
          }
        });
      } else {
        dispatch2((s) => [s, () => {
          info_display_dispatch2 = s.info_display_dispatch;
          code_editor = s.code_editor;
          code_editor_nodeid2 = s.code_editor_nodeid;
          result_display_dispatch2 = s.result_display_dispatch;
        }]);
      }
    };
    nolib.no.runtime.add_listener("graphupdate", "clear_hyperapp_error", change_listener);
    const timeouts = {};
    const animframes = {};
    const noderun_listener = (data2) => {
      if (data2.graph.id === editingGraphId) {
        const node_id = data2.node_id;
        const timeout2 = timeouts[node_id];
        const nodeanimframe = animframes[node_id];
        if (!timeout2) {
          const el = document.querySelector(`#node-editor-${data2.node_id.replaceAll("/", "_")} .shape`);
          el?.classList.add("flash");
        }
        if (!timeout2 || performance.now() - timeout2.timestamp > 950) {
          if (timeout2) {
            clearTimeout(timeout2.id);
          }
          timeouts[node_id] = {
            id: setTimeout(() => {
              const el = document.querySelector(`#node-editor-${data2.node_id.replaceAll("/", "_")} .shape`);
              timeouts[node_id] = false;
              el?.classList.remove("flash");
            }, 1e3),
            timestamp: performance.now()
          };
        }
      }
    };
    nolib.no.runtime.add_listener("noderun", "update_hyperapp_error", noderun_listener);
    return () => (nolib.no.runtime.remove_listener("graphupdate", "clear_hyperapp_error", change_listener), nolib.no.runtime.remove_listener("grapherror", "update_hyperapp_error", error_listener));
  };
  var graph_subscription = (dispatch2, props) => {
    let animframe = false;
    const listener = (graph) => {
      if (props.editingGraphId === graph.id) {
        dispatch2((s) => s.error ? Object.assign({}, s, { error: false }) : s);
        if (animframe) {
          cancelAnimationFrame(animframe);
        }
        animframe = requestAnimationFrame(() => {
          animframe = false;
          dispatch2((s) => [{ ...s, editingGraph: graph }, [UpdateSimulation], [refresh_graph, {
            graph: s.displayGraph || graph,
            norun: props.norun,
            graphChanged: true,
            result_display_dispatch: s.result_display_dispatch,
            info_display_dispatch: s.info_display_dispatch,
            code_editor: s.code_editor,
            code_editor_nodeid: s.code_editor_nodeid
          }]]);
        });
      }
    };
    nolib.no.runtime.add_listener("graphchange", "update_hyperapp", listener);
    return () => nolib.no.runtime.remove_listener("graphchange", "update_hyperapp");
  };
  var select_node_subscription = (dispatch2, props) => {
    const listener = (data2) => {
      dispatch2(SelectNode, { node_id: data2.data.substring(data2.data.indexOf("/") + 1) });
    };
    nolib.no.runtime.add_listener("selectnode", "hyperapp", listener);
    return () => nolib.no.runtime.remove_listener("selectnode", "hyperapp");
  };
  var listen = (type, action) => [listenToEvent, { type, action }];
  var listenToEvent = (dispatch2, props) => {
    const listener = (event) => requestAnimationFrame(() => dispatch2(props.action, event));
    requestAnimationFrame(() => addEventListener(props.type, listener));
    return () => removeEventListener(props.type, listener);
  };
  var run_h = ({ dom_type, props, children, text: text3 }, exclude_tags = []) => {
    return dom_type === "text_value" ? text(text3) : h(dom_type, props, children?.map((c2) => c2.el ?? c2).filter((c2) => !!c2 && !exclude_tags.includes(c2.dom_type)).map((c2) => run_h(c2, exclude_tags)) ?? []);
  };
  var runh = (el) => el.d && el.p && el.c && h(el.d, el.p, el.c);
  var findViewBox2 = (nodes, links, selected, node_el_width, htmlid, dimensions) => {
    const visible_nodes = [];
    const visible_node_set = /* @__PURE__ */ new Set();
    let selected_pos;
    links.forEach((l) => {
      const el = document.getElementById(`link-${l.source.node_id}`);
      const info_el = document.getElementById(`edge-info-${l.source.node_id}`);
      if (el && info_el && l.source && l.target) {
        const source = { x: l.source.x - node_el_width * 0.5, y: l.source.y };
        const target = { x: l.target.x - node_el_width * 0.5, y: l.target.y };
        if (l.source.node_id === selected) {
          visible_nodes.push({ x: target.x, y: target.y });
          visible_node_set.add(l.target.node_id);
        } else if (l.target.node_id === selected) {
          visible_nodes.push({ x: source.x, y: source.y });
          visible_node_set.add(l.source.node_id);
        }
      }
    });
    links.forEach((l) => {
      if (visible_node_set.has(l.target.node_id) && !visible_node_set.has(l.source.node_id)) {
        const source = { x: l.source.x - node_el_width * 0.5, y: l.source.y };
        visible_nodes.push({ x: source.x, y: source.y });
      }
    });
    nodes.forEach((n2) => {
      const el = document.getElementById(`${htmlid}-${n2.node_id}`);
      if (el) {
        const x3 = n2.x - node_el_width * 0.5;
        const y3 = n2.y;
        if (n2.node_id === selected) {
          visible_nodes.push({ x: x3, y: y3 });
          selected_pos = { x: x3, y: y3 };
        }
      }
    });
    const nodes_box = visible_nodes.reduce(
      (acc, n2) => ({ min: { x: Math.min(acc.min.x, n2.x - 24), y: Math.min(acc.min.y, n2.y - 24) }, max: { x: Math.max(acc.max.x, n2.x + node_el_width * 0.5 - 24), y: Math.max(acc.max.y, n2.y + 24) } }),
      { min: { x: selected_pos ? selected_pos.x - 96 : dimensions.x, y: selected_pos ? selected_pos.y - 256 : dimensions.y }, max: { x: selected_pos ? selected_pos.x + 96 : -dimensions.x, y: selected_pos ? selected_pos.y + 128 : -dimensions.y } }
    );
    const nodes_box_center = { x: (nodes_box.max.x + nodes_box.min.x) * 0.5, y: (nodes_box.max.y + nodes_box.min.y) * 0.5 };
    const nodes_box_dimensions = { x: Math.max(dimensions.x * 0.5, Math.min(dimensions.x, nodes_box.max.x - nodes_box.min.x)), y: Math.max(dimensions.y * 0.5, Math.min(dimensions.y, nodes_box.max.y - nodes_box.min.y)) };
    const center = !selected_pos ? nodes_box_center : { x: (selected_pos.x + nodes_box_center.x * 3) * 0.25, y: (selected_pos.y + nodes_box_center.y * 3) * 0.25 };
    return { nodes_box_dimensions, center };
  };
  var bfs = (graph, fn) => {
    const visited = /* @__PURE__ */ new Set();
    const iter = (id3, level) => {
      if (visited.has(id3)) {
        return;
      }
      fn(id3, level);
      visited.add(id3);
      for (const e of Object.values(graph.edges)) {
        if (e.to === id3) {
          iter(e.from, level + 1);
        }
      }
    };
    return iter;
  };
  var calculateLevels = (nodes, links, graph, selected) => {
    const find_childest = (n2) => {
      const e = hlib.no.runtime.get_edge_out(graph, n2);
      if (e) {
        return find_childest(e.to);
      } else {
        return n2;
      }
    };
    selected = selected[0];
    const top2 = find_childest(selected);
    const levels = /* @__PURE__ */ new Map();
    bfs(graph, (id3, level) => levels.set(id3, Math.min(levels.get(id3) || Number.MAX_SAFE_INTEGER, level)))(top2, 0);
    const parents = new Map(
      nodes.map((n2) => [
        n2.node_id,
        links.filter((l) => typeof l.target == "object" ? l.target.node_id : l.target === n2.node_id).map((l) => typeof l.source === "object" ? l.source.node_id : String(l.source))
      ])
    );
    [...parents.values()].forEach((nps) => {
      nps.sort((a2, b) => parents.get(b).length - parents.get(a2).length);
      for (let i = 0; i < nps.length * 0.5; i++) {
        if (i % 2 === 1) {
          const tmp = nps[i];
          const endidx = nps.length - 1 - Math.floor(i / 2);
          nps[i] = nps[endidx];
          nps[endidx] = tmp;
        }
      }
    });
    const children = new Map(nodes.map((n2) => [
      n2.node_id,
      links.filter((l) => (typeof l.source === "object" ? l.source.node_id : l.source) === n2.node_id).map((l) => typeof l.target === "object" ? l.target.node_id : String(l.target))
    ]));
    const siblings = new Map(nodes.map((n2) => [n2.node_id, [...new Set(children.has(n2.node_id) ? children.get(n2.node_id).flatMap((c2) => parents.get(c2) || []) : []).values()]]));
    const distance_from_selected = /* @__PURE__ */ new Map();
    const calculate_selected_graph = (s, i) => {
      const id3 = s;
      if (distance_from_selected.get(id3) <= i) {
        return;
      }
      distance_from_selected.set(id3, i);
      if (parents.has(s)) {
        parents.get(s).forEach((p) => {
          calculate_selected_graph(p, i + 1);
        });
      }
      if (children.has(s)) {
        children.get(s).forEach((c2) => {
          calculate_selected_graph(c2, i + 1);
        });
      }
    };
    calculate_selected_graph(selected, 0);
    return {
      level_by_node: levels,
      parents,
      children,
      siblings,
      distance_from_selected,
      min: Math.min(...levels.values()),
      max: Math.max(...levels.values()),
      nodes_by_level: [...levels.entries()].reduce((acc, [n2, l]) => (acc[l] ? acc[l].push(n2) : acc[l] = [n2], acc), {})
    };
  };
  var save_graph = (graph) => {
    graph = base_graph(graph);
    const graphstr = JSON.stringify(base_graph(graph));
    nolib.no.runtime.add_ref(graph);
  };
  var hlib = {
    ...nolib,
    ha: {
      middleware,
      h: {
        args: ["dom_type", "props", "children", "memo"],
        fn: (dom_type, props, children, usememo) => usememo ? memo(runh, { d: dom_type, p: props, c: children }) : runh({ d: dom_type, p: props, c: children })
      },
      app,
      text: { args: ["text"], fn: text }
    },
    scripts: { d3subscription, updateSimulationNodes, keydownSubscription, calculateLevels, listen, graph_subscription, save_graph },
    effects: {
      position_by_selected: (id3, selected, dimensions, nodes) => {
        selected = Array.isArray(selected) ? selected[0] : selected;
        const el = document.getElementById(id3.replaceAll("/", "_"));
        const node = nodes.find((n2) => n2.id === selected);
        const x3 = node.x;
        const y3 = node.y;
        const svg_offset = hlib.panzoom.getTransform();
        el.setAttribute("left", `${Math.min(x3 * (svg_offset?.scale ?? 1) + (svg_offset?.x ?? 0) - 64, dimensions.x - 256)}px`);
        el.setAttribute("top", `${y3 * (svg_offset?.scale ?? 1) + (svg_offset?.y ?? 0) + 32}px`);
      }
    },
    panzoom: pzobj,
    run: (graph, fn, args2, lib, options) => run({ graph, fn, lib: lib ? { ...hlib, ...lib } : hlib }, isArgs(args2) ? args2 : args2 ? new Map(Object.entries(args2)) : /* @__PURE__ */ new Map(), options),
    run_runnable: (runnable, args2, options) => run(runnable, args2, options),
    initStore: (nodysseusStore) => initStore(nodysseusStore),
    d3: { forceSimulation: simulation_default, forceManyBody: manyBody_default, forceCenter: center_default, forceLink: link_default, forceRadial: radial_default, forceY: y_default2, forceCollide: collide_default, forceX: x_default2 },
    worker: void 0
  };

  // src/editor/components/infoWindow.ts
  var info_display = (html_id) => app({
    init: { el: { dom_type: "div", props: {}, children: [] } },
    node: document.getElementById(html_id + "-info-display"),
    dispatch: middleware,
    view: (s) => {
      return run_h(s.el, ["script"]);
    }
  });
  var infoInput = ({ label, property, value, onchange, oninput, onkeydown, options, inputs, disabled }) => h(
    "div",
    {
      class: "value-input"
    },
    [
      h("label", { for: `edit-text-${property}` }, [text(label)]),
      h(
        "autocomplete-list",
        {
          class: property,
          id: `edit-text-${property}`,
          key: `edit-text-${property}`,
          name: `edit-text-${property}`,
          value: inputs[`edit-text-${property}`] ?? value ?? "",
          onselect: (state, payload) => [{ ...state, inputs: Object.assign(state.inputs, { [`edit-text-${property}`]: void 0 }) }, (dispatch2) => dispatch2(onchange, { value: payload.detail })],
          oninput: (s, e) => [{ ...s, inputs: Object.assign(s.inputs, { [`edit-text-${property}`]: e.target.value }) }],
          onblur: (state, event) => [{ ...state, focused: false }]
        },
        options && options.length > 0 && options.map((o) => h("option", { class: `autocomplete-item`, value: typeof o === "string" ? o : o.value, "data-category": typeof o === "string" ? void 0 : o.category }, text(typeof o === "string" ? o : o.value)))
      )
    ]
  );
  var infoWindow = ({ node, hidden, edges_in, link_out, editingGraphId, randid, ref_graphs, html_id, copied_graph, inputs, graph_out, editing }) => {
    const node_ref = node && node.ref ? nolib.no.runtime.get_ref(node.ref) : node;
    const description = node_ref?.description;
    const node_arg_labels = [];
    return h("div", { id: "node-info-wrapper" }, [h("div", { class: "spacer before" }, []), h(
      "div",
      {
        class: { "node-info": true, hidden, editing, [node.ref]: !!node.ref },
        onfocusin: (state) => [{ ...state, editing: true }],
        onblurout: (state) => [{ ...state, editing: false }]
      },
      [
        h(
          "div",
          { class: "args" },
          node_arg_labels.map((n2) => h("span", {
            class: "clickable",
            onclick: n2.exists ? edges_in.filter((l) => l.as === n2.name).map((l) => [SelectNode, { node_id: l.from }])[0] : [CreateNode, { node: { id: randid, ref: n2.type && n2.type !== "any" ? n2.type : void 0 }, child: node.id, child_as: n2.name }]
          }, [text(n2.exists ? n2.name : `+${n2.name}`)]))
        ),
        h("div", { class: "inputs" }, [
          memo((node2) => infoInput({
            label: "name",
            value: node2.name,
            property: "name",
            inputs,
            onchange: (state, { value }) => node2.id !== graph_out && node2.id !== "out" ? [UpdateNode, { node: node2, property: "name", value }] : [state, [ChangeEditingGraphId, { id: value, select_out: true, editingGraphId }]],
            options: (graph_out ? node2.id === graph_out : node2.id === "out") ? ref_graphs : []
          }), node),
          memo(
            (node2) => infoInput({
              label: "value",
              value: node2.value,
              property: "value",
              inputs,
              onchange: (state, { value }) => [UpdateNode, { node: node2, property: "value", value }]
            }),
            node
          ),
          memo((node2) => infoInput({
            label: "ref",
            value: node2.ref,
            property: "ref",
            inputs,
            options: nolib.no.runtime.refs().map((r) => generic_default.nodes[r] ? { value: r, category: generic_default.nodes[r].category } : { value: r, category: "custom" }),
            onchange: (state, { value }) => [UpdateNode, { node: node2, property: "ref", value }],
            disabled: node2.id === graph_out
          }), node),
          link_out && link_out.source && memo((link_out2) => infoInput({
            label: "edge",
            value: link_out2.as,
            property: "edge",
            inputs,
            options: node_args(nolib, editingGraphId, link_out2.to).map((na) => na.name.split(": ")[0]),
            onchange: (state, { value }) => [UpdateEdge, { edge: { from: link_out2.from, to: link_out2.to, as: link_out2.as }, as: value }]
          }), link_out)
        ]),
        description && h("div", { class: "description" }, text(description)),
        h("div", {
          id: `${html_id}-code-editor`
        }, []),
        h("canvas", {
          id: `${html_id}-info-canvas`,
          class: "display-none",
          key: "node-editor-info-canvas"
        }, []),
        h("div", { id: `${html_id}-info-display` }),
        h("div", { class: "buttons" }, [
          node.node_id !== graph_out && h("div", {
            class: "action",
            onclick: [ExpandContract, { node_id: node.node_id }]
          }, [h("span", { class: "material-icons-outlined" }, text(Object.keys(node.nodes ?? {}).length > 0 ? "unfold_more" : "unfold_less")), h("span", {}, text(Object.keys(node.nodes ?? {}).length > 0 ? "expand" : "collapse"))]),
          Object.keys(node.nodes ?? {}).length > 0 && node.name !== "" && h("div", { class: "action", onclick: [CreateRef, { node }] }, text("make ref")),
          node.ref && h("div", {
            class: "action",
            onclick: (state) => [state, [ChangeEditingGraphId, { id: node.ref, editingGraphId }]],
            key: "open-ref-action"
          }, [h("span", { class: "material-icons-outlined" }, text("code")), h("span", {}, text("open"))]),
          h("div", {
            class: "action",
            onclick: [Copy, { cut: false, as: link_out.as }],
            key: "copy-action"
          }, [h("span", { class: "material-icons-outlined" }, text("copy")), h("span", {}, text("copy"))]),
          copied_graph && h("div", {
            class: "action",
            onclick: [Paste, {}],
            key: "paste-action"
          }, [h("span", { class: "material-icons-outlined" }, text("paste")), h("span", {}, text("paste"))]),
          node.node_id == graph_out && h("div", {
            class: "action",
            onclick: (state, payload) => [state, [SaveGraph, state]]
          }, [h("span", { class: "material-icons-outlined" }, text("save")), h("span", {}, text("save"))]),
          node.node_id !== graph_out && h("div", {
            class: "action",
            onclick: [DeleteNode, {
              node_id: node.node_id
            }]
          }, [h("span", { class: "material-icons-outlined" }, text("delete")), h("span", {}, text("delete"))])
        ])
      ]
    ), h("div", { class: "spacer after" }, [])]);
  };

  // node_modules/@codemirror/state/dist/index.js
  var Text = class {
    constructor() {
    }
    lineAt(pos) {
      if (pos < 0 || pos > this.length)
        throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
      return this.lineInner(pos, false, 1, 0);
    }
    line(n2) {
      if (n2 < 1 || n2 > this.lines)
        throw new RangeError(`Invalid line number ${n2} in ${this.lines}-line document`);
      return this.lineInner(n2, true, 1, 0);
    }
    replace(from3, to, text3) {
      let parts = [];
      this.decompose(0, from3, parts, 2);
      if (text3.length)
        text3.decompose(0, text3.length, parts, 1 | 2);
      this.decompose(to, this.length, parts, 1);
      return TextNode.from(parts, this.length - (to - from3) + text3.length);
    }
    append(other) {
      return this.replace(this.length, this.length, other);
    }
    slice(from3, to = this.length) {
      let parts = [];
      this.decompose(from3, to, parts, 0);
      return TextNode.from(parts, to - from3);
    }
    eq(other) {
      if (other == this)
        return true;
      if (other.length != this.length || other.lines != this.lines)
        return false;
      let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
      let a2 = new RawTextCursor(this), b = new RawTextCursor(other);
      for (let skip = start, pos = start; ; ) {
        a2.next(skip);
        b.next(skip);
        skip = 0;
        if (a2.lineBreak != b.lineBreak || a2.done != b.done || a2.value != b.value)
          return false;
        pos += a2.value.length;
        if (a2.done || pos >= end)
          return true;
      }
    }
    iter(dir = 1) {
      return new RawTextCursor(this, dir);
    }
    iterRange(from3, to = this.length) {
      return new PartialTextCursor(this, from3, to);
    }
    iterLines(from3, to) {
      let inner;
      if (from3 == null) {
        inner = this.iter();
      } else {
        if (to == null)
          to = this.lines + 1;
        let start = this.line(from3).from;
        inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
      }
      return new LineCursor(inner);
    }
    toString() {
      return this.sliceString(0);
    }
    toJSON() {
      let lines = [];
      this.flatten(lines);
      return lines;
    }
    static of(text3) {
      if (text3.length == 0)
        throw new RangeError("A document must have at least one line");
      if (text3.length == 1 && !text3[0])
        return Text.empty;
      return text3.length <= 32 ? new TextLeaf(text3) : TextNode.from(TextLeaf.split(text3, []));
    }
  };
  var TextLeaf = class extends Text {
    constructor(text3, length3 = textLength(text3)) {
      super();
      this.text = text3;
      this.length = length3;
    }
    get lines() {
      return this.text.length;
    }
    get children() {
      return null;
    }
    lineInner(target, isLine, line, offset) {
      for (let i = 0; ; i++) {
        let string3 = this.text[i], end = offset + string3.length;
        if ((isLine ? line : end) >= target)
          return new Line(offset, end, line, string3);
        offset = end + 1;
        line++;
      }
    }
    decompose(from3, to, target, open) {
      let text3 = from3 <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from3, to), Math.min(to, this.length) - Math.max(0, from3));
      if (open & 1) {
        let prev = target.pop();
        let joined = appendText(text3.text, prev.text.slice(), 0, text3.length);
        if (joined.length <= 32) {
          target.push(new TextLeaf(joined, prev.length + text3.length));
        } else {
          let mid = joined.length >> 1;
          target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
        }
      } else {
        target.push(text3);
      }
    }
    replace(from3, to, text3) {
      if (!(text3 instanceof TextLeaf))
        return super.replace(from3, to, text3);
      let lines = appendText(this.text, appendText(text3.text, sliceText(this.text, 0, from3)), to);
      let newLen = this.length + text3.length - (to - from3);
      if (lines.length <= 32)
        return new TextLeaf(lines, newLen);
      return TextNode.from(TextLeaf.split(lines, []), newLen);
    }
    sliceString(from3, to = this.length, lineSep = "\n") {
      let result = "";
      for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
        let line = this.text[i], end = pos + line.length;
        if (pos > from3 && i)
          result += lineSep;
        if (from3 < end && to > pos)
          result += line.slice(Math.max(0, from3 - pos), to - pos);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let line of this.text)
        target.push(line);
    }
    scanIdentical() {
      return 0;
    }
    static split(text3, target) {
      let part = [], len = -1;
      for (let line of text3) {
        part.push(line);
        len += line.length + 1;
        if (part.length == 32) {
          target.push(new TextLeaf(part, len));
          part = [];
          len = -1;
        }
      }
      if (len > -1)
        target.push(new TextLeaf(part, len));
      return target;
    }
  };
  var TextNode = class extends Text {
    constructor(children, length3) {
      super();
      this.children = children;
      this.length = length3;
      this.lines = 0;
      for (let child of children)
        this.lines += child.lines;
    }
    lineInner(target, isLine, line, offset) {
      for (let i = 0; ; i++) {
        let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
        if ((isLine ? endLine : end) >= target)
          return child.lineInner(target, isLine, line, offset);
        offset = end + 1;
        line = endLine + 1;
      }
    }
    decompose(from3, to, target, open) {
      for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (from3 <= end && to >= pos) {
          let childOpen = open & ((pos <= from3 ? 1 : 0) | (end >= to ? 2 : 0));
          if (pos >= from3 && end <= to && !childOpen)
            target.push(child);
          else
            child.decompose(from3 - pos, to - pos, target, childOpen);
        }
        pos = end + 1;
      }
    }
    replace(from3, to, text3) {
      if (text3.lines < this.lines)
        for (let i = 0, pos = 0; i < this.children.length; i++) {
          let child = this.children[i], end = pos + child.length;
          if (from3 >= pos && to <= end) {
            let updated = child.replace(from3 - pos, to - pos, text3);
            let totalLines = this.lines - child.lines + updated.lines;
            if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
              let copy2 = this.children.slice();
              copy2[i] = updated;
              return new TextNode(copy2, this.length - (to - from3) + text3.length);
            }
            return super.replace(pos, end, updated);
          }
          pos = end + 1;
        }
      return super.replace(from3, to, text3);
    }
    sliceString(from3, to = this.length, lineSep = "\n") {
      let result = "";
      for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
        let child = this.children[i], end = pos + child.length;
        if (pos > from3 && i)
          result += lineSep;
        if (from3 < end && to > pos)
          result += child.sliceString(from3 - pos, to - pos, lineSep);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let child of this.children)
        child.flatten(target);
    }
    scanIdentical(other, dir) {
      if (!(other instanceof TextNode))
        return 0;
      let length3 = 0;
      let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
      for (; ; iA += dir, iB += dir) {
        if (iA == eA || iB == eB)
          return length3;
        let chA = this.children[iA], chB = other.children[iB];
        if (chA != chB)
          return length3 + chA.scanIdentical(chB, dir);
        length3 += chA.length + 1;
      }
    }
    static from(children, length3 = children.reduce((l, ch) => l + ch.length + 1, -1)) {
      let lines = 0;
      for (let ch of children)
        lines += ch.lines;
      if (lines < 32) {
        let flat = [];
        for (let ch of children)
          ch.flatten(flat);
        return new TextLeaf(flat, length3);
      }
      let chunk = Math.max(32, lines >> 5), maxChunk = chunk << 1, minChunk = chunk >> 1;
      let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
      function add3(child) {
        let last2;
        if (child.lines > maxChunk && child instanceof TextNode) {
          for (let node of child.children)
            add3(node);
        } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
          flush();
          chunked.push(child);
        } else if (child instanceof TextLeaf && currentLines && (last2 = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last2.lines <= 32) {
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk[currentChunk.length - 1] = new TextLeaf(last2.text.concat(child.text), last2.length + 1 + child.length);
        } else {
          if (currentLines + child.lines > chunk)
            flush();
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk.push(child);
        }
      }
      function flush() {
        if (currentLines == 0)
          return;
        chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
        currentLen = -1;
        currentLines = currentChunk.length = 0;
      }
      for (let child of children)
        add3(child);
      flush();
      return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length3);
    }
  };
  Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
  function textLength(text3) {
    let length3 = -1;
    for (let line of text3)
      length3 += line.length + 1;
    return length3;
  }
  function appendText(text3, target, from3 = 0, to = 1e9) {
    for (let pos = 0, i = 0, first = true; i < text3.length && pos <= to; i++) {
      let line = text3[i], end = pos + line.length;
      if (end >= from3) {
        if (end > to)
          line = line.slice(0, to - pos);
        if (pos < from3)
          line = line.slice(from3 - pos);
        if (first) {
          target[target.length - 1] += line;
          first = false;
        } else
          target.push(line);
      }
      pos = end + 1;
    }
    return target;
  }
  function sliceText(text3, from3, to) {
    return appendText(text3, [""], from3, to);
  }
  var RawTextCursor = class {
    constructor(text3, dir = 1) {
      this.dir = dir;
      this.done = false;
      this.lineBreak = false;
      this.value = "";
      this.nodes = [text3];
      this.offsets = [dir > 0 ? 1 : (text3 instanceof TextLeaf ? text3.text.length : text3.children.length) << 1];
    }
    nextInner(skip, dir) {
      this.done = this.lineBreak = false;
      for (; ; ) {
        let last2 = this.nodes.length - 1;
        let top2 = this.nodes[last2], offsetValue = this.offsets[last2], offset = offsetValue >> 1;
        let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
        if (offset == (dir > 0 ? size : 0)) {
          if (last2 == 0) {
            this.done = true;
            this.value = "";
            return this;
          }
          if (dir > 0)
            this.offsets[last2 - 1]++;
          this.nodes.pop();
          this.offsets.pop();
        } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
          this.offsets[last2] += dir;
          if (skip == 0) {
            this.lineBreak = true;
            this.value = "\n";
            return this;
          }
          skip--;
        } else if (top2 instanceof TextLeaf) {
          let next = top2.text[offset + (dir < 0 ? -1 : 0)];
          this.offsets[last2] += dir;
          if (next.length > Math.max(0, skip)) {
            this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
            return this;
          }
          skip -= next.length;
        } else {
          let next = top2.children[offset + (dir < 0 ? -1 : 0)];
          if (skip > next.length) {
            skip -= next.length;
            this.offsets[last2] += dir;
          } else {
            if (dir < 0)
              this.offsets[last2]--;
            this.nodes.push(next);
            this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
          }
        }
      }
    }
    next(skip = 0) {
      if (skip < 0) {
        this.nextInner(-skip, -this.dir);
        skip = this.value.length;
      }
      return this.nextInner(skip, this.dir);
    }
  };
  var PartialTextCursor = class {
    constructor(text3, start, end) {
      this.value = "";
      this.done = false;
      this.cursor = new RawTextCursor(text3, start > end ? -1 : 1);
      this.pos = start > end ? text3.length : 0;
      this.from = Math.min(start, end);
      this.to = Math.max(start, end);
    }
    nextInner(skip, dir) {
      if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
        this.value = "";
        this.done = true;
        return this;
      }
      skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
      let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
      if (skip > limit)
        skip = limit;
      limit -= skip;
      let { value } = this.cursor.next(skip);
      this.pos += (value.length + skip) * dir;
      this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
      this.done = !this.value;
      return this;
    }
    next(skip = 0) {
      if (skip < 0)
        skip = Math.max(skip, this.from - this.pos);
      else if (skip > 0)
        skip = Math.min(skip, this.to - this.pos);
      return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() {
      return this.cursor.lineBreak && this.value != "";
    }
  };
  var LineCursor = class {
    constructor(inner) {
      this.inner = inner;
      this.afterBreak = true;
      this.value = "";
      this.done = false;
    }
    next(skip = 0) {
      let { done, lineBreak, value } = this.inner.next(skip);
      if (done) {
        this.done = true;
        this.value = "";
      } else if (lineBreak) {
        if (this.afterBreak) {
          this.value = "";
        } else {
          this.afterBreak = true;
          this.next();
        }
      } else {
        this.value = value;
        this.afterBreak = false;
      }
      return this;
    }
    get lineBreak() {
      return false;
    }
  };
  if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function() {
      return this.iter();
    };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  var Line = class {
    constructor(from3, to, number2, text3) {
      this.from = from3;
      this.to = to;
      this.number = number2;
      this.text = text3;
    }
    get length() {
      return this.to - this.from;
    }
  };
  var extend = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
  for (let i = 1; i < extend.length; i++)
    extend[i] += extend[i - 1];
  function isExtendingChar(code) {
    for (let i = 1; i < extend.length; i += 2)
      if (extend[i] > code)
        return extend[i - 1] <= code;
    return false;
  }
  function isRegionalIndicator(code) {
    return code >= 127462 && code <= 127487;
  }
  var ZWJ = 8205;
  function findClusterBreak(str, pos, forward = true, includeExtending = true) {
    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
  }
  function nextClusterBreak(str, pos, includeExtending) {
    if (pos == str.length)
      return pos;
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
      pos--;
    let prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
      let next = codePointAt(str, pos);
      if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
        pos += codePointSize(next);
        prev = next;
      } else if (isRegionalIndicator(next)) {
        let countBefore = 0, i = pos - 2;
        while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
          countBefore++;
          i -= 2;
        }
        if (countBefore % 2 == 0)
          break;
        else
          pos += 2;
      } else {
        break;
      }
    }
    return pos;
  }
  function prevClusterBreak(str, pos, includeExtending) {
    while (pos > 0) {
      let found = nextClusterBreak(str, pos - 2, includeExtending);
      if (found < pos)
        return found;
      pos--;
    }
    return 0;
  }
  function surrogateLow(ch) {
    return ch >= 56320 && ch < 57344;
  }
  function surrogateHigh(ch) {
    return ch >= 55296 && ch < 56320;
  }
  function codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length)
      return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1))
      return code0;
    return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
  }
  function fromCodePoint(code) {
    if (code <= 65535)
      return String.fromCharCode(code);
    code -= 65536;
    return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
  }
  function codePointSize(code) {
    return code < 65536 ? 1 : 2;
  }
  var DefaultSplit = /\r\n?|\n/;
  var MapMode = /* @__PURE__ */ function(MapMode2) {
    MapMode2[MapMode2["Simple"] = 0] = "Simple";
    MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
    MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
    MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
    return MapMode2;
  }(MapMode || (MapMode = {}));
  var ChangeDesc = class {
    constructor(sections) {
      this.sections = sections;
    }
    get length() {
      let result = 0;
      for (let i = 0; i < this.sections.length; i += 2)
        result += this.sections[i];
      return result;
    }
    get newLength() {
      let result = 0;
      for (let i = 0; i < this.sections.length; i += 2) {
        let ins = this.sections[i + 1];
        result += ins < 0 ? this.sections[i] : ins;
      }
      return result;
    }
    get empty() {
      return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
    }
    iterGaps(f) {
      for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++];
        if (ins < 0) {
          f(posA, posB, len);
          posB += len;
        } else {
          posB += ins;
        }
        posA += len;
      }
    }
    iterChangedRanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get invertedDesc() {
      let sections = [];
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++];
        if (ins < 0)
          sections.push(len, ins);
        else
          sections.push(ins, len);
      }
      return new ChangeDesc(sections);
    }
    composeDesc(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other);
    }
    mapDesc(other, before = false) {
      return other.empty ? this : mapSet(this, other, before);
    }
    mapPos(pos, assoc = -1, mode = MapMode.Simple) {
      let posA = 0, posB = 0;
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
        if (ins < 0) {
          if (endA > pos)
            return posB + (pos - posA);
          posB += len;
        } else {
          if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
            return null;
          if (endA > pos || endA == pos && assoc < 0 && !len)
            return pos == posA || assoc < 0 ? posB : posB + ins;
          posB += ins;
        }
        posA = endA;
      }
      if (pos > posA)
        throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
      return posB;
    }
    touchesRange(from3, to = from3) {
      for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
        let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
        if (ins >= 0 && pos <= to && end >= from3)
          return pos < from3 && end > to ? "cover" : true;
        pos = end;
      }
      return false;
    }
    toString() {
      let result = "";
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++];
        result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
      }
      return result;
    }
    toJSON() {
      return this.sections;
    }
    static fromJSON(json) {
      if (!Array.isArray(json) || json.length % 2 || json.some((a2) => typeof a2 != "number"))
        throw new RangeError("Invalid JSON representation of ChangeDesc");
      return new ChangeDesc(json);
    }
    static create(sections) {
      return new ChangeDesc(sections);
    }
  };
  var ChangeSet = class extends ChangeDesc {
    constructor(sections, inserted) {
      super(sections);
      this.inserted = inserted;
    }
    apply(doc3) {
      if (this.length != doc3.length)
        throw new RangeError("Applying change set to a document with the wrong length");
      iterChanges(this, (fromA, toA, fromB, _toB, text3) => doc3 = doc3.replace(fromB, fromB + (toA - fromA), text3), false);
      return doc3;
    }
    mapDesc(other, before = false) {
      return mapSet(this, other, before, true);
    }
    invert(doc3) {
      let sections = this.sections.slice(), inserted = [];
      for (let i = 0, pos = 0; i < sections.length; i += 2) {
        let len = sections[i], ins = sections[i + 1];
        if (ins >= 0) {
          sections[i] = ins;
          sections[i + 1] = len;
          let index2 = i >> 1;
          while (inserted.length < index2)
            inserted.push(Text.empty);
          inserted.push(len ? doc3.slice(pos, pos + len) : Text.empty);
        }
        pos += len;
      }
      return new ChangeSet(sections, inserted);
    }
    compose(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other, true);
    }
    map(other, before = false) {
      return other.empty ? this : mapSet(this, other, before, true);
    }
    iterChanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get desc() {
      return ChangeDesc.create(this.sections);
    }
    filter(ranges) {
      let resultSections = [], resultInserted = [], filteredSections = [];
      let iter = new SectionIter(this);
      done:
        for (let i = 0, pos = 0; ; ) {
          let next = i == ranges.length ? 1e9 : ranges[i++];
          while (pos < next || pos == next && iter.len == 0) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, next - pos);
            addSection(filteredSections, len, -1);
            let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
            addSection(resultSections, len, ins);
            if (ins > 0)
              addInsert(resultInserted, resultSections, iter.text);
            iter.forward(len);
            pos += len;
          }
          let end = ranges[i++];
          while (pos < end) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, end - pos);
            addSection(resultSections, len, -1);
            addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
            iter.forward(len);
            pos += len;
          }
        }
      return {
        changes: new ChangeSet(resultSections, resultInserted),
        filtered: ChangeDesc.create(filteredSections)
      };
    }
    toJSON() {
      let parts = [];
      for (let i = 0; i < this.sections.length; i += 2) {
        let len = this.sections[i], ins = this.sections[i + 1];
        if (ins < 0)
          parts.push(len);
        else if (ins == 0)
          parts.push([len]);
        else
          parts.push([len].concat(this.inserted[i >> 1].toJSON()));
      }
      return parts;
    }
    static of(changes, length3, lineSep) {
      let sections = [], inserted = [], pos = 0;
      let total = null;
      function flush(force = false) {
        if (!force && !sections.length)
          return;
        if (pos < length3)
          addSection(sections, length3 - pos, -1);
        let set3 = new ChangeSet(sections, inserted);
        total = total ? total.compose(set3.map(total)) : set3;
        sections = [];
        inserted = [];
        pos = 0;
      }
      function process2(spec) {
        if (Array.isArray(spec)) {
          for (let sub of spec)
            process2(sub);
        } else if (spec instanceof ChangeSet) {
          if (spec.length != length3)
            throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length3})`);
          flush();
          total = total ? total.compose(spec.map(total)) : spec;
        } else {
          let { from: from3, to = from3, insert: insert2 } = spec;
          if (from3 > to || from3 < 0 || to > length3)
            throw new RangeError(`Invalid change range ${from3} to ${to} (in doc of length ${length3})`);
          let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
          let insLen = insText.length;
          if (from3 == to && insLen == 0)
            return;
          if (from3 < pos)
            flush();
          if (from3 > pos)
            addSection(sections, from3 - pos, -1);
          addSection(sections, to - from3, insLen);
          addInsert(inserted, sections, insText);
          pos = to;
        }
      }
      process2(changes);
      flush(!total);
      return total;
    }
    static empty(length3) {
      return new ChangeSet(length3 ? [length3, -1] : [], []);
    }
    static fromJSON(json) {
      if (!Array.isArray(json))
        throw new RangeError("Invalid JSON representation of ChangeSet");
      let sections = [], inserted = [];
      for (let i = 0; i < json.length; i++) {
        let part = json[i];
        if (typeof part == "number") {
          sections.push(part, -1);
        } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
          throw new RangeError("Invalid JSON representation of ChangeSet");
        } else if (part.length == 1) {
          sections.push(part[0], 0);
        } else {
          while (inserted.length < i)
            inserted.push(Text.empty);
          inserted[i] = Text.of(part.slice(1));
          sections.push(part[0], inserted[i].length);
        }
      }
      return new ChangeSet(sections, inserted);
    }
    static createSet(sections, inserted) {
      return new ChangeSet(sections, inserted);
    }
  };
  function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0)
      return;
    let last2 = sections.length - 2;
    if (last2 >= 0 && ins <= 0 && ins == sections[last2 + 1])
      sections[last2] += len;
    else if (len == 0 && sections[last2] == 0)
      sections[last2 + 1] += ins;
    else if (forceJoin) {
      sections[last2] += len;
      sections[last2 + 1] += ins;
    } else
      sections.push(len, ins);
  }
  function addInsert(values2, sections, value) {
    if (value.length == 0)
      return;
    let index2 = sections.length - 2 >> 1;
    if (index2 < values2.length) {
      values2[values2.length - 1] = values2[values2.length - 1].append(value);
    } else {
      while (values2.length < index2)
        values2.push(Text.empty);
      values2.push(value);
    }
  }
  function iterChanges(desc, f, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
      let len = desc.sections[i++], ins = desc.sections[i++];
      if (ins < 0) {
        posA += len;
        posB += len;
      } else {
        let endA = posA, endB = posB, text3 = Text.empty;
        for (; ; ) {
          endA += len;
          endB += ins;
          if (ins && inserted)
            text3 = text3.append(inserted[i - 2 >> 1]);
          if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
            break;
          len = desc.sections[i++];
          ins = desc.sections[i++];
        }
        f(posA, endA, posB, endB, text3);
        posA = endA;
        posB = endB;
      }
    }
  }
  function mapSet(setA, setB, before, mkSet = false) {
    let sections = [], insert2 = mkSet ? [] : null;
    let a2 = new SectionIter(setA), b = new SectionIter(setB);
    for (let inserted = -1; ; ) {
      if (a2.ins == -1 && b.ins == -1) {
        let len = Math.min(a2.len, b.len);
        addSection(sections, len, -1);
        a2.forward(len);
        b.forward(len);
      } else if (b.ins >= 0 && (a2.ins < 0 || inserted == a2.i || a2.off == 0 && (b.len < a2.len || b.len == a2.len && !before))) {
        let len = b.len;
        addSection(sections, b.ins, -1);
        while (len) {
          let piece = Math.min(a2.len, len);
          if (a2.ins >= 0 && inserted < a2.i && a2.len <= piece) {
            addSection(sections, 0, a2.ins);
            if (insert2)
              addInsert(insert2, sections, a2.text);
            inserted = a2.i;
          }
          a2.forward(piece);
          len -= piece;
        }
        b.next();
      } else if (a2.ins >= 0) {
        let len = 0, left = a2.len;
        while (left) {
          if (b.ins == -1) {
            let piece = Math.min(left, b.len);
            len += piece;
            left -= piece;
            b.forward(piece);
          } else if (b.ins == 0 && b.len < left) {
            left -= b.len;
            b.next();
          } else {
            break;
          }
        }
        addSection(sections, len, inserted < a2.i ? a2.ins : 0);
        if (insert2 && inserted < a2.i)
          addInsert(insert2, sections, a2.text);
        inserted = a2.i;
        a2.forward(a2.len - left);
      } else if (a2.done && b.done) {
        return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
      } else {
        throw new Error("Mismatched change set lengths");
      }
    }
  }
  function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert2 = mkSet ? [] : null;
    let a2 = new SectionIter(setA), b = new SectionIter(setB);
    for (let open = false; ; ) {
      if (a2.done && b.done) {
        return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
      } else if (a2.ins == 0) {
        addSection(sections, a2.len, 0, open);
        a2.next();
      } else if (b.len == 0 && !b.done) {
        addSection(sections, 0, b.ins, open);
        if (insert2)
          addInsert(insert2, sections, b.text);
        b.next();
      } else if (a2.done || b.done) {
        throw new Error("Mismatched change set lengths");
      } else {
        let len = Math.min(a2.len2, b.len), sectionLen = sections.length;
        if (a2.ins == -1) {
          let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
          addSection(sections, len, insB, open);
          if (insert2 && insB)
            addInsert(insert2, sections, b.text);
        } else if (b.ins == -1) {
          addSection(sections, a2.off ? 0 : a2.len, len, open);
          if (insert2)
            addInsert(insert2, sections, a2.textBit(len));
        } else {
          addSection(sections, a2.off ? 0 : a2.len, b.off ? 0 : b.ins, open);
          if (insert2 && !b.off)
            addInsert(insert2, sections, b.text);
        }
        open = (a2.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
        a2.forward2(len);
        b.forward(len);
      }
    }
  }
  var SectionIter = class {
    constructor(set3) {
      this.set = set3;
      this.i = 0;
      this.next();
    }
    next() {
      let { sections } = this.set;
      if (this.i < sections.length) {
        this.len = sections[this.i++];
        this.ins = sections[this.i++];
      } else {
        this.len = 0;
        this.ins = -2;
      }
      this.off = 0;
    }
    get done() {
      return this.ins == -2;
    }
    get len2() {
      return this.ins < 0 ? this.len : this.ins;
    }
    get text() {
      let { inserted } = this.set, index2 = this.i - 2 >> 1;
      return index2 >= inserted.length ? Text.empty : inserted[index2];
    }
    textBit(len) {
      let { inserted } = this.set, index2 = this.i - 2 >> 1;
      return index2 >= inserted.length && !len ? Text.empty : inserted[index2].slice(this.off, len == null ? void 0 : this.off + len);
    }
    forward(len) {
      if (len == this.len)
        this.next();
      else {
        this.len -= len;
        this.off += len;
      }
    }
    forward2(len) {
      if (this.ins == -1)
        this.forward(len);
      else if (len == this.ins)
        this.next();
      else {
        this.ins -= len;
        this.off += len;
      }
    }
  };
  var SelectionRange = class {
    constructor(from3, to, flags) {
      this.from = from3;
      this.to = to;
      this.flags = flags;
    }
    get anchor() {
      return this.flags & 16 ? this.to : this.from;
    }
    get head() {
      return this.flags & 16 ? this.from : this.to;
    }
    get empty() {
      return this.from == this.to;
    }
    get assoc() {
      return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
    }
    get bidiLevel() {
      let level = this.flags & 3;
      return level == 3 ? null : level;
    }
    get goalColumn() {
      let value = this.flags >> 5;
      return value == 33554431 ? void 0 : value;
    }
    map(change2, assoc = -1) {
      let from3, to;
      if (this.empty) {
        from3 = to = change2.mapPos(this.from, assoc);
      } else {
        from3 = change2.mapPos(this.from, 1);
        to = change2.mapPos(this.to, -1);
      }
      return from3 == this.from && to == this.to ? this : new SelectionRange(from3, to, this.flags);
    }
    extend(from3, to = from3) {
      if (from3 <= this.anchor && to >= this.anchor)
        return EditorSelection.range(from3, to);
      let head = Math.abs(from3 - this.anchor) > Math.abs(to - this.anchor) ? from3 : to;
      return EditorSelection.range(this.anchor, head);
    }
    eq(other) {
      return this.anchor == other.anchor && this.head == other.head;
    }
    toJSON() {
      return { anchor: this.anchor, head: this.head };
    }
    static fromJSON(json) {
      if (!json || typeof json.anchor != "number" || typeof json.head != "number")
        throw new RangeError("Invalid JSON representation for SelectionRange");
      return EditorSelection.range(json.anchor, json.head);
    }
    static create(from3, to, flags) {
      return new SelectionRange(from3, to, flags);
    }
  };
  var EditorSelection = class {
    constructor(ranges, mainIndex) {
      this.ranges = ranges;
      this.mainIndex = mainIndex;
    }
    map(change2, assoc = -1) {
      if (change2.empty)
        return this;
      return EditorSelection.create(this.ranges.map((r) => r.map(change2, assoc)), this.mainIndex);
    }
    eq(other) {
      if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
        return false;
      for (let i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].eq(other.ranges[i]))
          return false;
      return true;
    }
    get main() {
      return this.ranges[this.mainIndex];
    }
    asSingle() {
      return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
    }
    addRange(range, main = true) {
      return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
    }
    replaceRange(range, which = this.mainIndex) {
      let ranges = this.ranges.slice();
      ranges[which] = range;
      return EditorSelection.create(ranges, this.mainIndex);
    }
    toJSON() {
      return { ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex };
    }
    static fromJSON(json) {
      if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
        throw new RangeError("Invalid JSON representation for EditorSelection");
      return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
    }
    static single(anchor, head = anchor) {
      return new EditorSelection([EditorSelection.range(anchor, head)], 0);
    }
    static create(ranges, mainIndex = 0) {
      if (ranges.length == 0)
        throw new RangeError("A selection needs at least one range");
      for (let pos = 0, i = 0; i < ranges.length; i++) {
        let range = ranges[i];
        if (range.empty ? range.from <= pos : range.from < pos)
          return EditorSelection.normalized(ranges.slice(), mainIndex);
        pos = range.to;
      }
      return new EditorSelection(ranges, mainIndex);
    }
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
      return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 : 8) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5);
    }
    static range(anchor, head, goalColumn) {
      let goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5;
      return head < anchor ? SelectionRange.create(head, anchor, 16 | goal | 8) : SelectionRange.create(anchor, head, goal | (head > anchor ? 4 : 0));
    }
    static normalized(ranges, mainIndex = 0) {
      let main = ranges[mainIndex];
      ranges.sort((a2, b) => a2.from - b.from);
      mainIndex = ranges.indexOf(main);
      for (let i = 1; i < ranges.length; i++) {
        let range = ranges[i], prev = ranges[i - 1];
        if (range.empty ? range.from <= prev.to : range.from < prev.to) {
          let from3 = prev.from, to = Math.max(range.to, prev.to);
          if (i <= mainIndex)
            mainIndex--;
          ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from3) : EditorSelection.range(from3, to));
        }
      }
      return new EditorSelection(ranges, mainIndex);
    }
  };
  function checkSelection(selection, docLength) {
    for (let range of selection.ranges)
      if (range.to > docLength)
        throw new RangeError("Selection points outside of document");
  }
  var nextID = 0;
  var Facet = class {
    constructor(combine, compareInput, compare3, isStatic, enables) {
      this.combine = combine;
      this.compareInput = compareInput;
      this.compare = compare3;
      this.isStatic = isStatic;
      this.id = nextID++;
      this.default = combine([]);
      this.extensions = typeof enables == "function" ? enables(this) : enables;
    }
    static define(config2 = {}) {
      return new Facet(config2.combine || ((a2) => a2), config2.compareInput || ((a2, b) => a2 === b), config2.compare || (!config2.combine ? sameArray : (a2, b) => a2 === b), !!config2.static, config2.enables);
    }
    of(value) {
      return new FacetProvider([], this, 0, value);
    }
    compute(deps, get4) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 1, get4);
    }
    computeN(deps, get4) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 2, get4);
    }
    from(field, get4) {
      if (!get4)
        get4 = (x3) => x3;
      return this.compute([field], (state) => get4(state.field(field)));
    }
  };
  function sameArray(a2, b) {
    return a2 == b || a2.length == b.length && a2.every((e, i) => e === b[i]);
  }
  var FacetProvider = class {
    constructor(dependencies, facet, type, value) {
      this.dependencies = dependencies;
      this.facet = facet;
      this.type = type;
      this.value = value;
      this.id = nextID++;
    }
    dynamicSlot(addresses) {
      var _a2;
      let getter = this.value;
      let compare3 = this.facet.compareInput;
      let id3 = this.id, idx = addresses[id3] >> 1, multi = this.type == 2;
      let depDoc = false, depSel = false, depAddrs = [];
      for (let dep of this.dependencies) {
        if (dep == "doc")
          depDoc = true;
        else if (dep == "selection")
          depSel = true;
        else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
          depAddrs.push(addresses[dep.id]);
      }
      return {
        create(state) {
          state.values[idx] = getter(state);
          return 1;
        },
        update(state, tr) {
          if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
            let newVal = getter(state);
            if (multi ? !compareArray(newVal, state.values[idx], compare3) : !compare3(newVal, state.values[idx])) {
              state.values[idx] = newVal;
              return 1;
            }
          }
          return 0;
        },
        reconfigure: (state, oldState) => {
          let newVal, oldAddr = oldState.config.address[id3];
          if (oldAddr != null) {
            let oldVal = getAddr(oldState, oldAddr);
            if (this.dependencies.every((dep) => {
              return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
            }) || (multi ? compareArray(newVal = getter(state), oldVal, compare3) : compare3(newVal = getter(state), oldVal))) {
              state.values[idx] = oldVal;
              return 0;
            }
          } else {
            newVal = getter(state);
          }
          state.values[idx] = newVal;
          return 1;
        }
      };
    }
  };
  function compareArray(a2, b, compare3) {
    if (a2.length != b.length)
      return false;
    for (let i = 0; i < a2.length; i++)
      if (!compare3(a2[i], b[i]))
        return false;
    return true;
  }
  function ensureAll(state, addrs) {
    let changed = false;
    for (let addr of addrs)
      if (ensureAddr(state, addr) & 1)
        changed = true;
    return changed;
  }
  function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map((p) => addresses[p.id]);
    let providerTypes = providers.map((p) => p.type);
    let dynamic = providerAddrs.filter((p) => !(p & 1));
    let idx = addresses[facet.id] >> 1;
    function get4(state) {
      let values2 = [];
      for (let i = 0; i < providerAddrs.length; i++) {
        let value = getAddr(state, providerAddrs[i]);
        if (providerTypes[i] == 2)
          for (let val of value)
            values2.push(val);
        else
          values2.push(value);
      }
      return facet.combine(values2);
    }
    return {
      create(state) {
        for (let addr of providerAddrs)
          ensureAddr(state, addr);
        state.values[idx] = get4(state);
        return 1;
      },
      update(state, tr) {
        if (!ensureAll(state, dynamic))
          return 0;
        let value = get4(state);
        if (facet.compare(value, state.values[idx]))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure(state, oldState) {
        let depChanged = ensureAll(state, providerAddrs);
        let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
        if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
          state.values[idx] = oldValue;
          return 0;
        }
        let value = get4(state);
        if (facet.compare(value, oldValue)) {
          state.values[idx] = oldValue;
          return 0;
        }
        state.values[idx] = value;
        return 1;
      }
    };
  }
  var initField = /* @__PURE__ */ Facet.define({ static: true });
  var StateField = class {
    constructor(id3, createF, updateF, compareF, spec) {
      this.id = id3;
      this.createF = createF;
      this.updateF = updateF;
      this.compareF = compareF;
      this.spec = spec;
      this.provides = void 0;
    }
    static define(config2) {
      let field = new StateField(nextID++, config2.create, config2.update, config2.compare || ((a2, b) => a2 === b), config2);
      if (config2.provide)
        field.provides = config2.provide(field);
      return field;
    }
    create(state) {
      let init2 = state.facet(initField).find((i) => i.field == this);
      return ((init2 === null || init2 === void 0 ? void 0 : init2.create) || this.createF)(state);
    }
    slot(addresses) {
      let idx = addresses[this.id] >> 1;
      return {
        create: (state) => {
          state.values[idx] = this.create(state);
          return 1;
        },
        update: (state, tr) => {
          let oldVal = state.values[idx];
          let value = this.updateF(oldVal, tr);
          if (this.compareF(oldVal, value))
            return 0;
          state.values[idx] = value;
          return 1;
        },
        reconfigure: (state, oldState) => {
          if (oldState.config.address[this.id] != null) {
            state.values[idx] = oldState.field(this);
            return 0;
          }
          state.values[idx] = this.create(state);
          return 1;
        }
      };
    }
    init(create8) {
      return [this, initField.of({ field: this, create: create8 })];
    }
    get extension() {
      return this;
    }
  };
  var Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
  function prec(value) {
    return (ext) => new PrecExtension(ext, value);
  }
  var Prec = {
    highest: /* @__PURE__ */ prec(Prec_.highest),
    high: /* @__PURE__ */ prec(Prec_.high),
    default: /* @__PURE__ */ prec(Prec_.default),
    low: /* @__PURE__ */ prec(Prec_.low),
    lowest: /* @__PURE__ */ prec(Prec_.lowest)
  };
  var PrecExtension = class {
    constructor(inner, prec2) {
      this.inner = inner;
      this.prec = prec2;
    }
  };
  var Compartment = class {
    of(ext) {
      return new CompartmentInstance(this, ext);
    }
    reconfigure(content2) {
      return Compartment.reconfigure.of({ compartment: this, extension: content2 });
    }
    get(state) {
      return state.config.compartments.get(this);
    }
  };
  var CompartmentInstance = class {
    constructor(compartment, inner) {
      this.compartment = compartment;
      this.inner = inner;
    }
  };
  var Configuration = class {
    constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
      this.base = base2;
      this.compartments = compartments;
      this.dynamicSlots = dynamicSlots;
      this.address = address;
      this.staticValues = staticValues;
      this.facets = facets;
      this.statusTemplate = [];
      while (this.statusTemplate.length < dynamicSlots.length)
        this.statusTemplate.push(0);
    }
    staticFacet(facet) {
      let addr = this.address[facet.id];
      return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base2, compartments, oldState) {
      let fields = [];
      let facets = /* @__PURE__ */ Object.create(null);
      let newCompartments = /* @__PURE__ */ new Map();
      for (let ext of flatten(base2, compartments, newCompartments)) {
        if (ext instanceof StateField)
          fields.push(ext);
        else
          (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
      }
      let address = /* @__PURE__ */ Object.create(null);
      let staticValues = [];
      let dynamicSlots = [];
      for (let field of fields) {
        address[field.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a2) => field.slot(a2));
      }
      let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
      for (let id3 in facets) {
        let providers = facets[id3], facet = providers[0].facet;
        let oldProviders = oldFacets && oldFacets[id3] || [];
        if (providers.every((p) => p.type == 0)) {
          address[facet.id] = staticValues.length << 1 | 1;
          if (sameArray(oldProviders, providers)) {
            staticValues.push(oldState.facet(facet));
          } else {
            let value = facet.combine(providers.map((p) => p.value));
            staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
          }
        } else {
          for (let p of providers) {
            if (p.type == 0) {
              address[p.id] = staticValues.length << 1 | 1;
              staticValues.push(p.value);
            } else {
              address[p.id] = dynamicSlots.length << 1;
              dynamicSlots.push((a2) => p.dynamicSlot(a2));
            }
          }
          address[facet.id] = dynamicSlots.length << 1;
          dynamicSlots.push((a2) => dynamicFacetSlot(a2, facet, providers));
        }
      }
      let dynamic = dynamicSlots.map((f) => f(address));
      return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
    }
  };
  function flatten(extension, compartments, newCompartments) {
    let result = [[], [], [], [], []];
    let seen = /* @__PURE__ */ new Map();
    function inner(ext, prec2) {
      let known = seen.get(ext);
      if (known != null) {
        if (known <= prec2)
          return;
        let found = result[known].indexOf(ext);
        if (found > -1)
          result[known].splice(found, 1);
        if (ext instanceof CompartmentInstance)
          newCompartments.delete(ext.compartment);
      }
      seen.set(ext, prec2);
      if (Array.isArray(ext)) {
        for (let e of ext)
          inner(e, prec2);
      } else if (ext instanceof CompartmentInstance) {
        if (newCompartments.has(ext.compartment))
          throw new RangeError(`Duplicate use of compartment in extensions`);
        let content2 = compartments.get(ext.compartment) || ext.inner;
        newCompartments.set(ext.compartment, content2);
        inner(content2, prec2);
      } else if (ext instanceof PrecExtension) {
        inner(ext.inner, ext.prec);
      } else if (ext instanceof StateField) {
        result[prec2].push(ext);
        if (ext.provides)
          inner(ext.provides, prec2);
      } else if (ext instanceof FacetProvider) {
        result[prec2].push(ext);
        if (ext.facet.extensions)
          inner(ext.facet.extensions, Prec_.default);
      } else {
        let content2 = ext.extension;
        if (!content2)
          throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
        inner(content2, prec2);
      }
    }
    inner(extension, Prec_.default);
    return result.reduce((a2, b) => a2.concat(b));
  }
  function ensureAddr(state, addr) {
    if (addr & 1)
      return 2;
    let idx = addr >> 1;
    let status = state.status[idx];
    if (status == 4)
      throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2)
      return status;
    state.status[idx] = 4;
    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
    return state.status[idx] = 2 | changed;
  }
  function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
  }
  var languageData = /* @__PURE__ */ Facet.define();
  var allowMultipleSelections = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.some((v) => v),
    static: true
  });
  var lineSeparator = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.length ? values2[0] : void 0,
    static: true
  });
  var changeFilter = /* @__PURE__ */ Facet.define();
  var transactionFilter = /* @__PURE__ */ Facet.define();
  var transactionExtender = /* @__PURE__ */ Facet.define();
  var readOnly = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.length ? values2[0] : false
  });
  var Annotation = class {
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
    static define() {
      return new AnnotationType();
    }
  };
  var AnnotationType = class {
    of(value) {
      return new Annotation(this, value);
    }
  };
  var StateEffectType = class {
    constructor(map3) {
      this.map = map3;
    }
    of(value) {
      return new StateEffect(this, value);
    }
  };
  var StateEffect = class {
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
    map(mapping) {
      let mapped = this.type.map(this.value, mapping);
      return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
    }
    is(type) {
      return this.type == type;
    }
    static define(spec = {}) {
      return new StateEffectType(spec.map || ((v) => v));
    }
    static mapEffects(effects, mapping) {
      if (!effects.length)
        return effects;
      let result = [];
      for (let effect of effects) {
        let mapped = effect.map(mapping);
        if (mapped)
          result.push(mapped);
      }
      return result;
    }
  };
  StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
  StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
  var Transaction = class {
    constructor(startState, changes, selection, effects, annotations, scrollIntoView3) {
      this.startState = startState;
      this.changes = changes;
      this.selection = selection;
      this.effects = effects;
      this.annotations = annotations;
      this.scrollIntoView = scrollIntoView3;
      this._doc = null;
      this._state = null;
      if (selection)
        checkSelection(selection, changes.newLength);
      if (!annotations.some((a2) => a2.type == Transaction.time))
        this.annotations = annotations.concat(Transaction.time.of(Date.now()));
    }
    static create(startState, changes, selection, effects, annotations, scrollIntoView3) {
      return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView3);
    }
    get newDoc() {
      return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    get newSelection() {
      return this.selection || this.startState.selection.map(this.changes);
    }
    get state() {
      if (!this._state)
        this.startState.applyTransaction(this);
      return this._state;
    }
    annotation(type) {
      for (let ann of this.annotations)
        if (ann.type == type)
          return ann.value;
      return void 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get reconfigured() {
      return this.startState.config != this.state.config;
    }
    isUserEvent(event) {
      let e = this.annotation(Transaction.userEvent);
      return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
    }
  };
  Transaction.time = /* @__PURE__ */ Annotation.define();
  Transaction.userEvent = /* @__PURE__ */ Annotation.define();
  Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
  Transaction.remote = /* @__PURE__ */ Annotation.define();
  function joinRanges(a2, b) {
    let result = [];
    for (let iA = 0, iB = 0; ; ) {
      let from3, to;
      if (iA < a2.length && (iB == b.length || b[iB] >= a2[iA])) {
        from3 = a2[iA++];
        to = a2[iA++];
      } else if (iB < b.length) {
        from3 = b[iB++];
        to = b[iB++];
      } else
        return result;
      if (!result.length || result[result.length - 1] < from3)
        result.push(from3, to);
      else if (result[result.length - 1] < to)
        result[result.length - 1] = to;
    }
  }
  function mergeTransaction(a2, b, sequential) {
    var _a2;
    let mapForA, mapForB, changes;
    if (sequential) {
      mapForA = b.changes;
      mapForB = ChangeSet.empty(b.changes.length);
      changes = a2.changes.compose(b.changes);
    } else {
      mapForA = b.changes.map(a2.changes);
      mapForB = a2.changes.mapDesc(b.changes, true);
      changes = a2.changes.compose(mapForA);
    }
    return {
      changes,
      selection: b.selection ? b.selection.map(mapForB) : (_a2 = a2.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
      effects: StateEffect.mapEffects(a2.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
      annotations: a2.annotations.length ? a2.annotations.concat(b.annotations) : b.annotations,
      scrollIntoView: a2.scrollIntoView || b.scrollIntoView
    };
  }
  function resolveTransactionInner(state, spec, docSize) {
    let sel = spec.selection, annotations = asArray(spec.annotations);
    if (spec.userEvent)
      annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
      changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
      selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
      effects: asArray(spec.effects),
      annotations,
      scrollIntoView: !!spec.scrollIntoView
    };
  }
  function resolveTransaction(state, specs, filter) {
    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
    if (specs.length && specs[0].filter === false)
      filter = false;
    for (let i = 1; i < specs.length; i++) {
      if (specs[i].filter === false)
        filter = false;
      let seq = !!specs[i].sequential;
      s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
    }
    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr) : tr);
  }
  function filterTransaction(tr) {
    let state = tr.startState;
    let result = true;
    for (let filter of state.facet(changeFilter)) {
      let value = filter(tr);
      if (value === false) {
        result = false;
        break;
      }
      if (Array.isArray(value))
        result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
      let changes, back;
      if (result === false) {
        back = tr.changes.invertedDesc;
        changes = ChangeSet.empty(state.doc.length);
      } else {
        let filtered = tr.changes.filter(result);
        changes = filtered.changes;
        back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
      }
      tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    let filters = state.facet(transactionFilter);
    for (let i = filters.length - 1; i >= 0; i--) {
      let filtered = filters[i](tr);
      if (filtered instanceof Transaction)
        tr = filtered;
      else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
        tr = filtered[0];
      else
        tr = resolveTransaction(state, asArray(filtered), false);
    }
    return tr;
  }
  function extendTransaction(tr) {
    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
    for (let i = extenders.length - 1; i >= 0; i--) {
      let extension = extenders[i](tr);
      if (extension && Object.keys(extension).length)
        spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
  }
  var none = [];
  function asArray(value) {
    return value == null ? none : Array.isArray(value) ? value : [value];
  }
  var CharCategory = /* @__PURE__ */ function(CharCategory2) {
    CharCategory2[CharCategory2["Word"] = 0] = "Word";
    CharCategory2[CharCategory2["Space"] = 1] = "Space";
    CharCategory2[CharCategory2["Other"] = 2] = "Other";
    return CharCategory2;
  }(CharCategory || (CharCategory = {}));
  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var wordChar;
  try {
    wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
  } catch (_) {
  }
  function hasWordChar(str) {
    if (wordChar)
      return wordChar.test(str);
    for (let i = 0; i < str.length; i++) {
      let ch = str[i];
      if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
        return true;
    }
    return false;
  }
  function makeCategorizer(wordChars) {
    return (char) => {
      if (!/\S/.test(char))
        return CharCategory.Space;
      if (hasWordChar(char))
        return CharCategory.Word;
      for (let i = 0; i < wordChars.length; i++)
        if (char.indexOf(wordChars[i]) > -1)
          return CharCategory.Word;
      return CharCategory.Other;
    };
  }
  var EditorState = class {
    constructor(config2, doc3, selection, values2, computeSlot, tr) {
      this.config = config2;
      this.doc = doc3;
      this.selection = selection;
      this.values = values2;
      this.status = config2.statusTemplate.slice();
      this.computeSlot = computeSlot;
      if (tr)
        tr._state = this;
      for (let i = 0; i < this.config.dynamicSlots.length; i++)
        ensureAddr(this, i << 1);
      this.computeSlot = null;
    }
    field(field, require2 = true) {
      let addr = this.config.address[field.id];
      if (addr == null) {
        if (require2)
          throw new RangeError("Field is not present in this state");
        return void 0;
      }
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    update(...specs) {
      return resolveTransaction(this, specs, true);
    }
    applyTransaction(tr) {
      let conf = this.config, { base: base2, compartments } = conf;
      for (let effect of tr.effects) {
        if (effect.is(Compartment.reconfigure)) {
          if (conf) {
            compartments = /* @__PURE__ */ new Map();
            conf.compartments.forEach((val, key) => compartments.set(key, val));
            conf = null;
          }
          compartments.set(effect.value.compartment, effect.value.extension);
        } else if (effect.is(StateEffect.reconfigure)) {
          conf = null;
          base2 = effect.value;
        } else if (effect.is(StateEffect.appendConfig)) {
          conf = null;
          base2 = asArray(base2).concat(effect.value);
        }
      }
      let startValues;
      if (!conf) {
        conf = Configuration.resolve(base2, compartments, this);
        let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
        startValues = intermediateState.values;
      } else {
        startValues = tr.startState.values.slice();
      }
      new EditorState(conf, tr.newDoc, tr.newSelection, startValues, (state, slot) => slot.update(state, tr), tr);
    }
    replaceSelection(text3) {
      if (typeof text3 == "string")
        text3 = this.toText(text3);
      return this.changeByRange((range) => ({
        changes: { from: range.from, to: range.to, insert: text3 },
        range: EditorSelection.cursor(range.from + text3.length)
      }));
    }
    changeByRange(f) {
      let sel = this.selection;
      let result1 = f(sel.ranges[0]);
      let changes = this.changes(result1.changes), ranges = [result1.range];
      let effects = asArray(result1.effects);
      for (let i = 1; i < sel.ranges.length; i++) {
        let result = f(sel.ranges[i]);
        let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
        for (let j = 0; j < i; j++)
          ranges[j] = ranges[j].map(newMapped);
        let mapBy = changes.mapDesc(newChanges, true);
        ranges.push(result.range.map(mapBy));
        changes = changes.compose(newMapped);
        effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
      }
      return {
        changes,
        selection: EditorSelection.create(ranges, sel.mainIndex),
        effects
      };
    }
    changes(spec = []) {
      if (spec instanceof ChangeSet)
        return spec;
      return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
    }
    toText(string3) {
      return Text.of(string3.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
    }
    sliceDoc(from3 = 0, to = this.doc.length) {
      return this.doc.sliceString(from3, to, this.lineBreak);
    }
    facet(facet) {
      let addr = this.config.address[facet.id];
      if (addr == null)
        return facet.default;
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    toJSON(fields) {
      let result = {
        doc: this.sliceDoc(),
        selection: this.selection.toJSON()
      };
      if (fields)
        for (let prop in fields) {
          let value = fields[prop];
          if (value instanceof StateField && this.config.address[value.id] != null)
            result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
        }
      return result;
    }
    static fromJSON(json, config2 = {}, fields) {
      if (!json || typeof json.doc != "string")
        throw new RangeError("Invalid JSON representation for EditorState");
      let fieldInit = [];
      if (fields)
        for (let prop in fields) {
          if (Object.prototype.hasOwnProperty.call(json, prop)) {
            let field = fields[prop], value = json[prop];
            fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
          }
        }
      return EditorState.create({
        doc: json.doc,
        selection: EditorSelection.fromJSON(json.selection),
        extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
      });
    }
    static create(config2 = {}) {
      let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map());
      let doc3 = config2.doc instanceof Text ? config2.doc : Text.of((config2.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
      let selection = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
      checkSelection(selection, doc3.length);
      if (!configuration.staticFacet(allowMultipleSelections))
        selection = selection.asSingle();
      return new EditorState(configuration, doc3, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
    }
    get tabSize() {
      return this.facet(EditorState.tabSize);
    }
    get lineBreak() {
      return this.facet(EditorState.lineSeparator) || "\n";
    }
    get readOnly() {
      return this.facet(readOnly);
    }
    phrase(phrase2, ...insert2) {
      for (let map3 of this.facet(EditorState.phrases))
        if (Object.prototype.hasOwnProperty.call(map3, phrase2)) {
          phrase2 = map3[phrase2];
          break;
        }
      if (insert2.length)
        phrase2 = phrase2.replace(/\$(\$|\d*)/g, (m2, i) => {
          if (i == "$")
            return "$";
          let n2 = +(i || 1);
          return !n2 || n2 > insert2.length ? m2 : insert2[n2 - 1];
        });
      return phrase2;
    }
    languageDataAt(name2, pos, side = -1) {
      let values2 = [];
      for (let provider of this.facet(languageData)) {
        for (let result of provider(this, pos, side)) {
          if (Object.prototype.hasOwnProperty.call(result, name2))
            values2.push(result[name2]);
        }
      }
      return values2;
    }
    charCategorizer(at) {
      return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    wordAt(pos) {
      let { text: text3, from: from3, length: length3 } = this.doc.lineAt(pos);
      let cat = this.charCategorizer(pos);
      let start = pos - from3, end = pos - from3;
      while (start > 0) {
        let prev = findClusterBreak(text3, start, false);
        if (cat(text3.slice(prev, start)) != CharCategory.Word)
          break;
        start = prev;
      }
      while (end < length3) {
        let next = findClusterBreak(text3, end);
        if (cat(text3.slice(end, next)) != CharCategory.Word)
          break;
        end = next;
      }
      return start == end ? null : EditorSelection.range(start + from3, end + from3);
    }
  };
  EditorState.allowMultipleSelections = allowMultipleSelections;
  EditorState.tabSize = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.length ? values2[0] : 4
  });
  EditorState.lineSeparator = lineSeparator;
  EditorState.readOnly = readOnly;
  EditorState.phrases = /* @__PURE__ */ Facet.define({
    compare(a2, b) {
      let kA = Object.keys(a2), kB = Object.keys(b);
      return kA.length == kB.length && kA.every((k) => a2[k] == b[k]);
    }
  });
  EditorState.languageData = languageData;
  EditorState.changeFilter = changeFilter;
  EditorState.transactionFilter = transactionFilter;
  EditorState.transactionExtender = transactionExtender;
  Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
  function combineConfig(configs, defaults3, combine = {}) {
    let result = {};
    for (let config2 of configs)
      for (let key of Object.keys(config2)) {
        let value = config2[key], current = result[key];
        if (current === void 0)
          result[key] = value;
        else if (current === value || value === void 0)
          ;
        else if (Object.hasOwnProperty.call(combine, key))
          result[key] = combine[key](current, value);
        else
          throw new Error("Config merge conflict for field " + key);
      }
    for (let key in defaults3)
      if (result[key] === void 0)
        result[key] = defaults3[key];
    return result;
  }
  var RangeValue = class {
    eq(other) {
      return this == other;
    }
    range(from3, to = from3) {
      return Range.create(from3, to, this);
    }
  };
  RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
  RangeValue.prototype.point = false;
  RangeValue.prototype.mapMode = MapMode.TrackDel;
  var Range = class {
    constructor(from3, to, value) {
      this.from = from3;
      this.to = to;
      this.value = value;
    }
    static create(from3, to, value) {
      return new Range(from3, to, value);
    }
  };
  function cmpRange(a2, b) {
    return a2.from - b.from || a2.value.startSide - b.value.startSide;
  }
  var Chunk = class {
    constructor(from3, to, value, maxPoint) {
      this.from = from3;
      this.to = to;
      this.value = value;
      this.maxPoint = maxPoint;
    }
    get length() {
      return this.to[this.to.length - 1];
    }
    findIndex(pos, side, end, startAt = 0) {
      let arr = end ? this.to : this.from;
      for (let lo = startAt, hi = arr.length; ; ) {
        if (lo == hi)
          return lo;
        let mid = lo + hi >> 1;
        let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
        if (mid == lo)
          return diff >= 0 ? lo : hi;
        if (diff >= 0)
          hi = mid;
        else
          lo = mid + 1;
      }
    }
    between(offset, from3, to, f) {
      for (let i = this.findIndex(from3, -1e9, true), e = this.findIndex(to, 1e9, false, i); i < e; i++)
        if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
          return false;
    }
    map(offset, changes) {
      let value = [], from3 = [], to = [], newPos = -1, maxPoint = -1;
      for (let i = 0; i < this.value.length; i++) {
        let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
        if (curFrom == curTo) {
          let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
          if (mapped == null)
            continue;
          newFrom = newTo = mapped;
          if (val.startSide != val.endSide) {
            newTo = changes.mapPos(curFrom, val.endSide);
            if (newTo < newFrom)
              continue;
          }
        } else {
          newFrom = changes.mapPos(curFrom, val.startSide);
          newTo = changes.mapPos(curTo, val.endSide);
          if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
            continue;
        }
        if ((newTo - newFrom || val.endSide - val.startSide) < 0)
          continue;
        if (newPos < 0)
          newPos = newFrom;
        if (val.point)
          maxPoint = Math.max(maxPoint, newTo - newFrom);
        value.push(val);
        from3.push(newFrom - newPos);
        to.push(newTo - newPos);
      }
      return { mapped: value.length ? new Chunk(from3, to, value, maxPoint) : null, pos: newPos };
    }
  };
  var RangeSet = class {
    constructor(chunkPos, chunk, nextLayer, maxPoint) {
      this.chunkPos = chunkPos;
      this.chunk = chunk;
      this.nextLayer = nextLayer;
      this.maxPoint = maxPoint;
    }
    static create(chunkPos, chunk, nextLayer, maxPoint) {
      return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
    }
    get length() {
      let last2 = this.chunk.length - 1;
      return last2 < 0 ? 0 : Math.max(this.chunkEnd(last2), this.nextLayer.length);
    }
    get size() {
      if (this.isEmpty)
        return 0;
      let size = this.nextLayer.size;
      for (let chunk of this.chunk)
        size += chunk.value.length;
      return size;
    }
    chunkEnd(index2) {
      return this.chunkPos[index2] + this.chunk[index2].length;
    }
    update(updateSpec) {
      let { add: add3 = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
      let filter = updateSpec.filter;
      if (add3.length == 0 && !filter)
        return this;
      if (sort)
        add3 = add3.slice().sort(cmpRange);
      if (this.isEmpty)
        return add3.length ? RangeSet.of(add3) : this;
      let cur2 = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
      let builder = new RangeSetBuilder();
      while (cur2.value || i < add3.length) {
        if (i < add3.length && (cur2.from - add3[i].from || cur2.startSide - add3[i].value.startSide) >= 0) {
          let range = add3[i++];
          if (!builder.addInner(range.from, range.to, range.value))
            spill.push(range);
        } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i == add3.length || this.chunkEnd(cur2.chunkIndex) < add3[i].from) && (!filter || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
          cur2.nextChunk();
        } else {
          if (!filter || filterFrom > cur2.to || filterTo < cur2.from || filter(cur2.from, cur2.to, cur2.value)) {
            if (!builder.addInner(cur2.from, cur2.to, cur2.value))
              spill.push(Range.create(cur2.from, cur2.to, cur2.value));
          }
          cur2.next();
        }
      }
      return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
    }
    map(changes) {
      if (changes.empty || this.isEmpty)
        return this;
      let chunks = [], chunkPos = [], maxPoint = -1;
      for (let i = 0; i < this.chunk.length; i++) {
        let start = this.chunkPos[i], chunk = this.chunk[i];
        let touch = changes.touchesRange(start, start + chunk.length);
        if (touch === false) {
          maxPoint = Math.max(maxPoint, chunk.maxPoint);
          chunks.push(chunk);
          chunkPos.push(changes.mapPos(start));
        } else if (touch === true) {
          let { mapped, pos } = chunk.map(start, changes);
          if (mapped) {
            maxPoint = Math.max(maxPoint, mapped.maxPoint);
            chunks.push(mapped);
            chunkPos.push(pos);
          }
        }
      }
      let next = this.nextLayer.map(changes);
      return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
    }
    between(from3, to, f) {
      if (this.isEmpty)
        return;
      for (let i = 0; i < this.chunk.length; i++) {
        let start = this.chunkPos[i], chunk = this.chunk[i];
        if (to >= start && from3 <= start + chunk.length && chunk.between(start, from3 - start, to - start, f) === false)
          return;
      }
      this.nextLayer.between(from3, to, f);
    }
    iter(from3 = 0) {
      return HeapCursor.from([this]).goto(from3);
    }
    get isEmpty() {
      return this.nextLayer == this;
    }
    static iter(sets, from3 = 0) {
      return HeapCursor.from(sets).goto(from3);
    }
    static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
      let a2 = oldSets.filter((set3) => set3.maxPoint > 0 || !set3.isEmpty && set3.maxPoint >= minPointSize);
      let b = newSets.filter((set3) => set3.maxPoint > 0 || !set3.isEmpty && set3.maxPoint >= minPointSize);
      let sharedChunks = findSharedChunks(a2, b, textDiff);
      let sideA = new SpanCursor(a2, sharedChunks, minPointSize);
      let sideB = new SpanCursor(b, sharedChunks, minPointSize);
      textDiff.iterGaps((fromA, fromB, length3) => compare2(sideA, fromA, sideB, fromB, length3, comparator));
      if (textDiff.empty && textDiff.length == 0)
        compare2(sideA, 0, sideB, 0, 0, comparator);
    }
    static eq(oldSets, newSets, from3 = 0, to) {
      if (to == null)
        to = 1e9 - 1;
      let a2 = oldSets.filter((set3) => !set3.isEmpty && newSets.indexOf(set3) < 0);
      let b = newSets.filter((set3) => !set3.isEmpty && oldSets.indexOf(set3) < 0);
      if (a2.length != b.length)
        return false;
      if (!a2.length)
        return true;
      let sharedChunks = findSharedChunks(a2, b);
      let sideA = new SpanCursor(a2, sharedChunks, 0).goto(from3), sideB = new SpanCursor(b, sharedChunks, 0).goto(from3);
      for (; ; ) {
        if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
          return false;
        if (sideA.to > to)
          return true;
        sideA.next();
        sideB.next();
      }
    }
    static spans(sets, from3, to, iterator, minPointSize = -1) {
      let cursor = new SpanCursor(sets, null, minPointSize).goto(from3), pos = from3;
      let openRanges = cursor.openStart;
      for (; ; ) {
        let curTo = Math.min(cursor.to, to);
        if (cursor.point) {
          let active = cursor.activeForPoint(cursor.to);
          let openCount = cursor.pointFrom < from3 ? active.length + 1 : Math.min(active.length, openRanges);
          iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
          openRanges = Math.min(cursor.openEnd(curTo), active.length);
        } else if (curTo > pos) {
          iterator.span(pos, curTo, cursor.active, openRanges);
          openRanges = cursor.openEnd(curTo);
        }
        if (cursor.to > to)
          return openRanges + (cursor.point && cursor.to > to ? 1 : 0);
        pos = cursor.to;
        cursor.next();
      }
    }
    static of(ranges, sort = false) {
      let build = new RangeSetBuilder();
      for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
        build.add(range.from, range.to, range.value);
      return build.finish();
    }
  };
  RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
  function lazySort(ranges) {
    if (ranges.length > 1)
      for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
        let cur2 = ranges[i];
        if (cmpRange(prev, cur2) > 0)
          return ranges.slice().sort(cmpRange);
        prev = cur2;
      }
    return ranges;
  }
  RangeSet.empty.nextLayer = RangeSet.empty;
  var RangeSetBuilder = class {
    constructor() {
      this.chunks = [];
      this.chunkPos = [];
      this.chunkStart = -1;
      this.last = null;
      this.lastFrom = -1e9;
      this.lastTo = -1e9;
      this.from = [];
      this.to = [];
      this.value = [];
      this.maxPoint = -1;
      this.setMaxPoint = -1;
      this.nextLayer = null;
    }
    finishChunk(newArrays) {
      this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
      this.chunkPos.push(this.chunkStart);
      this.chunkStart = -1;
      this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
      this.maxPoint = -1;
      if (newArrays) {
        this.from = [];
        this.to = [];
        this.value = [];
      }
    }
    add(from3, to, value) {
      if (!this.addInner(from3, to, value))
        (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from3, to, value);
    }
    addInner(from3, to, value) {
      let diff = from3 - this.lastTo || value.startSide - this.last.endSide;
      if (diff <= 0 && (from3 - this.lastFrom || value.startSide - this.last.startSide) < 0)
        throw new Error("Ranges must be added sorted by `from` position and `startSide`");
      if (diff < 0)
        return false;
      if (this.from.length == 250)
        this.finishChunk(true);
      if (this.chunkStart < 0)
        this.chunkStart = from3;
      this.from.push(from3 - this.chunkStart);
      this.to.push(to - this.chunkStart);
      this.last = value;
      this.lastFrom = from3;
      this.lastTo = to;
      this.value.push(value);
      if (value.point)
        this.maxPoint = Math.max(this.maxPoint, to - from3);
      return true;
    }
    addChunk(from3, chunk) {
      if ((from3 - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
        return false;
      if (this.from.length)
        this.finishChunk(true);
      this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
      this.chunks.push(chunk);
      this.chunkPos.push(from3);
      let last2 = chunk.value.length - 1;
      this.last = chunk.value[last2];
      this.lastFrom = chunk.from[last2] + from3;
      this.lastTo = chunk.to[last2] + from3;
      return true;
    }
    finish() {
      return this.finishInner(RangeSet.empty);
    }
    finishInner(next) {
      if (this.from.length)
        this.finishChunk(false);
      if (this.chunks.length == 0)
        return next;
      let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
      this.from = null;
      return result;
    }
  };
  function findSharedChunks(a2, b, textDiff) {
    let inA = /* @__PURE__ */ new Map();
    for (let set3 of a2)
      for (let i = 0; i < set3.chunk.length; i++)
        if (set3.chunk[i].maxPoint <= 0)
          inA.set(set3.chunk[i], set3.chunkPos[i]);
    let shared = /* @__PURE__ */ new Set();
    for (let set3 of b)
      for (let i = 0; i < set3.chunk.length; i++) {
        let known = inA.get(set3.chunk[i]);
        if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set3.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set3.chunk[i].length)))
          shared.add(set3.chunk[i]);
      }
    return shared;
  }
  var LayerCursor = class {
    constructor(layer2, skip, minPoint, rank = 0) {
      this.layer = layer2;
      this.skip = skip;
      this.minPoint = minPoint;
      this.rank = rank;
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    get endSide() {
      return this.value ? this.value.endSide : 0;
    }
    goto(pos, side = -1e9) {
      this.chunkIndex = this.rangeIndex = 0;
      this.gotoInner(pos, side, false);
      return this;
    }
    gotoInner(pos, side, forward) {
      while (this.chunkIndex < this.layer.chunk.length) {
        let next = this.layer.chunk[this.chunkIndex];
        if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
          break;
        this.chunkIndex++;
        forward = false;
      }
      if (this.chunkIndex < this.layer.chunk.length) {
        let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
        if (!forward || this.rangeIndex < rangeIndex)
          this.setRangeIndex(rangeIndex);
      }
      this.next();
    }
    forward(pos, side) {
      if ((this.to - pos || this.endSide - side) < 0)
        this.gotoInner(pos, side, true);
    }
    next() {
      for (; ; ) {
        if (this.chunkIndex == this.layer.chunk.length) {
          this.from = this.to = 1e9;
          this.value = null;
          break;
        } else {
          let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
          let from3 = chunkPos + chunk.from[this.rangeIndex];
          this.from = from3;
          this.to = chunkPos + chunk.to[this.rangeIndex];
          this.value = chunk.value[this.rangeIndex];
          this.setRangeIndex(this.rangeIndex + 1);
          if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
            break;
        }
      }
    }
    setRangeIndex(index2) {
      if (index2 == this.layer.chunk[this.chunkIndex].value.length) {
        this.chunkIndex++;
        if (this.skip) {
          while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
            this.chunkIndex++;
        }
        this.rangeIndex = 0;
      } else {
        this.rangeIndex = index2;
      }
    }
    nextChunk() {
      this.chunkIndex++;
      this.rangeIndex = 0;
      this.next();
    }
    compare(other) {
      return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
    }
  };
  var HeapCursor = class {
    constructor(heap2) {
      this.heap = heap2;
    }
    static from(sets, skip = null, minPoint = -1) {
      let heap2 = [];
      for (let i = 0; i < sets.length; i++) {
        for (let cur2 = sets[i]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
          if (cur2.maxPoint >= minPoint)
            heap2.push(new LayerCursor(cur2, skip, minPoint, i));
        }
      }
      return heap2.length == 1 ? heap2[0] : new HeapCursor(heap2);
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    goto(pos, side = -1e9) {
      for (let cur2 of this.heap)
        cur2.goto(pos, side);
      for (let i = this.heap.length >> 1; i >= 0; i--)
        heapBubble(this.heap, i);
      this.next();
      return this;
    }
    forward(pos, side) {
      for (let cur2 of this.heap)
        cur2.forward(pos, side);
      for (let i = this.heap.length >> 1; i >= 0; i--)
        heapBubble(this.heap, i);
      if ((this.to - pos || this.value.endSide - side) < 0)
        this.next();
    }
    next() {
      if (this.heap.length == 0) {
        this.from = this.to = 1e9;
        this.value = null;
        this.rank = -1;
      } else {
        let top2 = this.heap[0];
        this.from = top2.from;
        this.to = top2.to;
        this.value = top2.value;
        this.rank = top2.rank;
        if (top2.value)
          top2.next();
        heapBubble(this.heap, 0);
      }
    }
  };
  function heapBubble(heap2, index2) {
    for (let cur2 = heap2[index2]; ; ) {
      let childIndex = (index2 << 1) + 1;
      if (childIndex >= heap2.length)
        break;
      let child = heap2[childIndex];
      if (childIndex + 1 < heap2.length && child.compare(heap2[childIndex + 1]) >= 0) {
        child = heap2[childIndex + 1];
        childIndex++;
      }
      if (cur2.compare(child) < 0)
        break;
      heap2[childIndex] = cur2;
      heap2[index2] = child;
      index2 = childIndex;
    }
  }
  var SpanCursor = class {
    constructor(sets, skip, minPoint) {
      this.minPoint = minPoint;
      this.active = [];
      this.activeTo = [];
      this.activeRank = [];
      this.minActive = -1;
      this.point = null;
      this.pointFrom = 0;
      this.pointRank = 0;
      this.to = -1e9;
      this.endSide = 0;
      this.openStart = -1;
      this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -1e9) {
      this.cursor.goto(pos, side);
      this.active.length = this.activeTo.length = this.activeRank.length = 0;
      this.minActive = -1;
      this.to = pos;
      this.endSide = side;
      this.openStart = -1;
      this.next();
      return this;
    }
    forward(pos, side) {
      while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
        this.removeActive(this.minActive);
      this.cursor.forward(pos, side);
    }
    removeActive(index2) {
      remove(this.active, index2);
      remove(this.activeTo, index2);
      remove(this.activeRank, index2);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
      let i = 0, { value, to, rank } = this.cursor;
      while (i < this.activeRank.length && this.activeRank[i] <= rank)
        i++;
      insert(this.active, i, value);
      insert(this.activeTo, i, to);
      insert(this.activeRank, i, rank);
      if (trackOpen)
        insert(trackOpen, i, this.cursor.from);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    next() {
      let from3 = this.to, wasPoint = this.point;
      this.point = null;
      let trackOpen = this.openStart < 0 ? [] : null;
      for (; ; ) {
        let a2 = this.minActive;
        if (a2 > -1 && (this.activeTo[a2] - this.cursor.from || this.active[a2].endSide - this.cursor.startSide) < 0) {
          if (this.activeTo[a2] > from3) {
            this.to = this.activeTo[a2];
            this.endSide = this.active[a2].endSide;
            break;
          }
          this.removeActive(a2);
          if (trackOpen)
            remove(trackOpen, a2);
        } else if (!this.cursor.value) {
          this.to = this.endSide = 1e9;
          break;
        } else if (this.cursor.from > from3) {
          this.to = this.cursor.from;
          this.endSide = this.cursor.startSide;
          break;
        } else {
          let nextVal = this.cursor.value;
          if (!nextVal.point) {
            this.addActive(trackOpen);
            this.cursor.next();
          } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
            this.cursor.next();
          } else {
            this.point = nextVal;
            this.pointFrom = this.cursor.from;
            this.pointRank = this.cursor.rank;
            this.to = this.cursor.to;
            this.endSide = nextVal.endSide;
            this.cursor.next();
            this.forward(this.to, this.endSide);
            break;
          }
        }
      }
      if (trackOpen) {
        this.openStart = 0;
        for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from3; i--)
          this.openStart++;
      }
    }
    activeForPoint(to) {
      if (!this.active.length)
        return this.active;
      let active = [];
      for (let i = this.active.length - 1; i >= 0; i--) {
        if (this.activeRank[i] < this.pointRank)
          break;
        if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
          active.push(this.active[i]);
      }
      return active.reverse();
    }
    openEnd(to) {
      let open = 0;
      for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
        open++;
      return open;
    }
  };
  function compare2(a2, startA, b, startB, length3, comparator) {
    a2.goto(startA);
    b.goto(startB);
    let endB = startB + length3;
    let pos = startB, dPos = startB - startA;
    for (; ; ) {
      let diff = a2.to + dPos - b.to || a2.endSide - b.endSide;
      let end = diff < 0 ? a2.to + dPos : b.to, clipEnd = Math.min(end, endB);
      if (a2.point || b.point) {
        if (!(a2.point && b.point && (a2.point == b.point || a2.point.eq(b.point)) && sameValues(a2.activeForPoint(a2.to + dPos), b.activeForPoint(b.to))))
          comparator.comparePoint(pos, clipEnd, a2.point, b.point);
      } else {
        if (clipEnd > pos && !sameValues(a2.active, b.active))
          comparator.compareRange(pos, clipEnd, a2.active, b.active);
      }
      if (end > endB)
        break;
      pos = end;
      if (diff <= 0)
        a2.next();
      if (diff >= 0)
        b.next();
    }
  }
  function sameValues(a2, b) {
    if (a2.length != b.length)
      return false;
    for (let i = 0; i < a2.length; i++)
      if (a2[i] != b[i] && !a2[i].eq(b[i]))
        return false;
    return true;
  }
  function remove(array2, index2) {
    for (let i = index2, e = array2.length - 1; i < e; i++)
      array2[i] = array2[i + 1];
    array2.pop();
  }
  function insert(array2, index2, value) {
    for (let i = array2.length - 1; i >= index2; i--)
      array2[i + 1] = array2[i];
    array2[index2] = value;
  }
  function findMinIndex(value, array2) {
    let found = -1, foundPos = 1e9;
    for (let i = 0; i < array2.length; i++)
      if ((array2[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
        found = i;
        foundPos = array2[i];
      }
    return found;
  }
  function countColumn(string3, tabSize, to = string3.length) {
    let n2 = 0;
    for (let i = 0; i < to; ) {
      if (string3.charCodeAt(i) == 9) {
        n2 += tabSize - n2 % tabSize;
        i++;
      } else {
        n2++;
        i = findClusterBreak(string3, i);
      }
    }
    return n2;
  }
  function findColumn(string3, col, tabSize, strict) {
    for (let i = 0, n2 = 0; ; ) {
      if (n2 >= col)
        return i;
      if (i == string3.length)
        break;
      n2 += string3.charCodeAt(i) == 9 ? tabSize - n2 % tabSize : 1;
      i = findClusterBreak(string3, i);
    }
    return strict === true ? -1 : string3.length;
  }

  // node_modules/style-mod/src/style-mod.js
  var C = "\u037C";
  var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
  var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
  var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
  var StyleModule = class {
    constructor(spec, options) {
      this.rules = [];
      let { finish } = options || {};
      function splitSelector(selector) {
        return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
      }
      function render(selectors, spec2, target, isKeyframes) {
        let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
        if (isAt && spec2 == null)
          return target.push(selectors[0] + ";");
        for (let prop in spec2) {
          let value = spec2[prop];
          if (/&/.test(prop)) {
            render(
              prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a2, b) => a2.concat(b)),
              value,
              target
            );
          } else if (value && typeof value == "object") {
            if (!isAt)
              throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
            render(splitSelector(prop), value, local, keyframes);
          } else if (value != null) {
            local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
          }
        }
        if (local.length || keyframes) {
          target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
        }
      }
      for (let prop in spec)
        render(splitSelector(prop), spec[prop], this.rules);
    }
    getRules() {
      return this.rules.join("\n");
    }
    static newName() {
      let id3 = top[COUNT] || 1;
      top[COUNT] = id3 + 1;
      return C + id3.toString(36);
    }
    static mount(root, modules) {
      (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules]);
    }
  };
  var adoptedSet = null;
  var StyleSet = class {
    constructor(root) {
      if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
        if (adoptedSet) {
          root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets);
          return root[SET] = adoptedSet;
        }
        this.sheet = new CSSStyleSheet();
        root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets);
        adoptedSet = this;
      } else {
        this.styleTag = (root.ownerDocument || root).createElement("style");
        let target = root.head || root;
        target.insertBefore(this.styleTag, target.firstChild);
      }
      this.modules = [];
      root[SET] = this;
    }
    mount(modules) {
      let sheet = this.sheet;
      let pos = 0, j = 0;
      for (let i = 0; i < modules.length; i++) {
        let mod = modules[i], index2 = this.modules.indexOf(mod);
        if (index2 < j && index2 > -1) {
          this.modules.splice(index2, 1);
          j--;
          index2 = -1;
        }
        if (index2 == -1) {
          this.modules.splice(j++, 0, mod);
          if (sheet)
            for (let k = 0; k < mod.rules.length; k++)
              sheet.insertRule(mod.rules[k], pos++);
        } else {
          while (j < index2)
            pos += this.modules[j++].rules.length;
          pos += mod.rules.length;
          j++;
        }
      }
      if (!sheet) {
        let text3 = "";
        for (let i = 0; i < this.modules.length; i++)
          text3 += this.modules[i].getRules() + "\n";
        this.styleTag.textContent = text3;
      }
    }
  };

  // node_modules/w3c-keyname/index.es.js
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  };
  var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
  var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
  var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  var brokenModifierNames = mac || chrome && +chrome[1] < 57;
  for (i = 0; i < 10; i++)
    base[48 + i] = base[96 + i] = String(i);
  var i;
  for (i = 1; i <= 24; i++)
    base[i + 111] = "F" + i;
  var i;
  for (i = 65; i <= 90; i++) {
    base[i] = String.fromCharCode(i + 32);
    shift[i] = String.fromCharCode(i);
  }
  var i;
  for (code in base)
    if (!shift.hasOwnProperty(code))
      shift[code] = base[code];
  var code;
  function keyName(event) {
    var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
    var name2 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
    if (name2 == "Esc")
      name2 = "Escape";
    if (name2 == "Del")
      name2 = "Delete";
    if (name2 == "Left")
      name2 = "ArrowLeft";
    if (name2 == "Up")
      name2 = "ArrowUp";
    if (name2 == "Right")
      name2 = "ArrowRight";
    if (name2 == "Down")
      name2 = "ArrowDown";
    return name2;
  }

  // node_modules/@codemirror/view/dist/index.js
  function getSelection(root) {
    let target;
    if (root.nodeType == 11) {
      target = root.getSelection ? root : root.ownerDocument;
    } else {
      target = root;
    }
    return target.getSelection();
  }
  function contains(dom, node) {
    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
  }
  function deepActiveElement(doc3) {
    let elt2 = doc3.activeElement;
    while (elt2 && elt2.shadowRoot)
      elt2 = elt2.shadowRoot.activeElement;
    return elt2;
  }
  function hasSelection(dom, selection) {
    if (!selection.anchorNode)
      return false;
    try {
      return contains(dom, selection.anchorNode);
    } catch (_) {
      return false;
    }
  }
  function clientRectsFor(dom) {
    if (dom.nodeType == 3)
      return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1)
      return dom.getClientRects();
    else
      return [];
  }
  function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
  }
  function domIndex(node) {
    for (var index2 = 0; ; index2++) {
      node = node.previousSibling;
      if (!node)
        return index2;
    }
  }
  function scanFor(node, off, targetNode, targetOff, dir) {
    for (; ; ) {
      if (node == targetNode && off == targetOff)
        return true;
      if (off == (dir < 0 ? 0 : maxOffset(node))) {
        if (node.nodeName == "DIV")
          return false;
        let parent = node.parentNode;
        if (!parent || parent.nodeType != 1)
          return false;
        off = domIndex(node) + (dir < 0 ? 0 : 1);
        node = parent;
      } else if (node.nodeType == 1) {
        node = node.childNodes[off + (dir < 0 ? -1 : 0)];
        if (node.nodeType == 1 && node.contentEditable == "false")
          return false;
        off = dir < 0 ? maxOffset(node) : 0;
      } else {
        return false;
      }
    }
  }
  function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  var Rect0 = { left: 0, right: 0, top: 0, bottom: 0 };
  function flattenRect(rect, left) {
    let x3 = left ? rect.left : rect.right;
    return { left: x3, right: x3, top: rect.top, bottom: rect.bottom };
  }
  function windowRect(win) {
    return {
      left: 0,
      right: win.innerWidth,
      top: 0,
      bottom: win.innerHeight
    };
  }
  function scrollRectIntoView(dom, rect, side, x3, y3, xMargin, yMargin, ltr) {
    let doc3 = dom.ownerDocument, win = doc3.defaultView || window;
    for (let cur2 = dom; cur2; ) {
      if (cur2.nodeType == 1) {
        let bounding, top2 = cur2 == doc3.body;
        if (top2) {
          bounding = windowRect(win);
        } else {
          if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
            cur2 = cur2.assignedSlot || cur2.parentNode;
            continue;
          }
          let rect2 = cur2.getBoundingClientRect();
          bounding = {
            left: rect2.left,
            right: rect2.left + cur2.clientWidth,
            top: rect2.top,
            bottom: rect2.top + cur2.clientHeight
          };
        }
        let moveX = 0, moveY = 0;
        if (y3 == "nearest") {
          if (rect.top < bounding.top) {
            moveY = -(bounding.top - rect.top + yMargin);
            if (side > 0 && rect.bottom > bounding.bottom + moveY)
              moveY = rect.bottom - bounding.bottom + moveY + yMargin;
          } else if (rect.bottom > bounding.bottom) {
            moveY = rect.bottom - bounding.bottom + yMargin;
            if (side < 0 && rect.top - moveY < bounding.top)
              moveY = -(bounding.top + moveY - rect.top + yMargin);
          }
        } else {
          let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
          let targetTop = y3 == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y3 == "start" || y3 == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
          moveY = targetTop - bounding.top;
        }
        if (x3 == "nearest") {
          if (rect.left < bounding.left) {
            moveX = -(bounding.left - rect.left + xMargin);
            if (side > 0 && rect.right > bounding.right + moveX)
              moveX = rect.right - bounding.right + moveX + xMargin;
          } else if (rect.right > bounding.right) {
            moveX = rect.right - bounding.right + xMargin;
            if (side < 0 && rect.left < bounding.left + moveX)
              moveX = -(bounding.left + moveX - rect.left + xMargin);
          }
        } else {
          let targetLeft = x3 == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x3 == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
          moveX = targetLeft - bounding.left;
        }
        if (moveX || moveY) {
          if (top2) {
            win.scrollBy(moveX, moveY);
          } else {
            let movedX = 0, movedY = 0;
            if (moveY) {
              let start = cur2.scrollTop;
              cur2.scrollTop += moveY;
              movedY = cur2.scrollTop - start;
            }
            if (moveX) {
              let start = cur2.scrollLeft;
              cur2.scrollLeft += moveX;
              movedX = cur2.scrollLeft - start;
            }
            rect = {
              left: rect.left - movedX,
              top: rect.top - movedY,
              right: rect.right - movedX,
              bottom: rect.bottom - movedY
            };
            if (movedX && Math.abs(movedX - moveX) < 1)
              x3 = "nearest";
            if (movedY && Math.abs(movedY - moveY) < 1)
              y3 = "nearest";
          }
        }
        if (top2)
          break;
        cur2 = cur2.assignedSlot || cur2.parentNode;
      } else if (cur2.nodeType == 11) {
        cur2 = cur2.host;
      } else {
        break;
      }
    }
  }
  var DOMSelectionState = class {
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    eq(domSel) {
      return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range) {
      this.set(range.anchorNode, range.anchorOffset, range.focusNode, range.focusOffset);
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
      this.anchorNode = anchorNode;
      this.anchorOffset = anchorOffset;
      this.focusNode = focusNode;
      this.focusOffset = focusOffset;
    }
  };
  var preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive)
      return dom.setActive();
    if (preventScrollSupported)
      return dom.focus(preventScrollSupported);
    let stack = [];
    for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
      stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
      if (cur2 == cur2.ownerDocument)
        break;
    }
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = { preventScroll: true };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      for (let i = 0; i < stack.length; ) {
        let elt2 = stack[i++], top2 = stack[i++], left = stack[i++];
        if (elt2.scrollTop != top2)
          elt2.scrollTop = top2;
        if (elt2.scrollLeft != left)
          elt2.scrollLeft = left;
      }
    }
  }
  var scratchRange;
  function textRange(node, from3, to = from3) {
    let range = scratchRange || (scratchRange = document.createRange());
    range.setEnd(node, to);
    range.setStart(node, from3);
    return range;
  }
  function dispatchKey(elt2, name2, code) {
    let options = { key: name2, code: name2, keyCode: code, which: code, cancelable: true };
    let down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    elt2.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options);
    up.synthetic = true;
    elt2.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
  }
  function getRoot(node) {
    while (node) {
      if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
        return node;
      node = node.assignedSlot || node.parentNode;
    }
    return null;
  }
  function clearAttributes(node) {
    while (node.attributes.length)
      node.removeAttributeNode(node.attributes[0]);
  }
  function atElementStart(doc3, selection) {
    let node = selection.focusNode, offset = selection.focusOffset;
    if (!node || selection.anchorNode != node || selection.anchorOffset != offset)
      return false;
    for (; ; ) {
      if (offset) {
        if (node.nodeType != 1)
          return false;
        let prev = node.childNodes[offset - 1];
        if (prev.contentEditable == "false")
          offset--;
        else {
          node = prev;
          offset = maxOffset(node);
        }
      } else if (node == doc3) {
        return true;
      } else {
        offset = domIndex(node);
        node = node.parentNode;
      }
    }
  }
  var DOMPos = class {
    constructor(node, offset, precise = true) {
      this.node = node;
      this.offset = offset;
      this.precise = precise;
    }
    static before(dom, precise) {
      return new DOMPos(dom.parentNode, domIndex(dom), precise);
    }
    static after(dom, precise) {
      return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
    }
  };
  var noChildren = [];
  var ContentView = class {
    constructor() {
      this.parent = null;
      this.dom = null;
      this.dirty = 2;
    }
    get editorView() {
      if (!this.parent)
        throw new Error("Accessing view in orphan content view");
      return this.parent.editorView;
    }
    get overrideDOMText() {
      return null;
    }
    get posAtStart() {
      return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
      return this.posAtStart + this.length;
    }
    posBefore(view2) {
      let pos = this.posAtStart;
      for (let child of this.children) {
        if (child == view2)
          return pos;
        pos += child.length + child.breakAfter;
      }
      throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view2) {
      return this.posBefore(view2) + view2.length;
    }
    coordsAt(_pos, _side) {
      return null;
    }
    sync(track) {
      if (this.dirty & 2) {
        let parent = this.dom;
        let prev = null, next;
        for (let child of this.children) {
          if (child.dirty) {
            if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
              let contentView = ContentView.get(next);
              if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                child.reuseDOM(next);
            }
            child.sync(track);
            child.dirty = 0;
          }
          next = prev ? prev.nextSibling : parent.firstChild;
          if (track && !track.written && track.node == parent && next != child.dom)
            track.written = true;
          if (child.dom.parentNode == parent) {
            while (next && next != child.dom)
              next = rm$1(next);
          } else {
            parent.insertBefore(child.dom, next);
          }
          prev = child.dom;
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (next && track && track.node == parent)
          track.written = true;
        while (next)
          next = rm$1(next);
      } else if (this.dirty & 1) {
        for (let child of this.children)
          if (child.dirty) {
            child.sync(track);
            child.dirty = 0;
          }
      }
    }
    reuseDOM(_dom) {
    }
    localPosFromDOM(node, offset) {
      let after;
      if (node == this.dom) {
        after = this.dom.childNodes[offset];
      } else {
        let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
        for (; ; ) {
          let parent = node.parentNode;
          if (parent == this.dom)
            break;
          if (bias == 0 && parent.firstChild != parent.lastChild) {
            if (node == parent.firstChild)
              bias = -1;
            else
              bias = 1;
          }
          node = parent;
        }
        if (bias < 0)
          after = node;
        else
          after = node.nextSibling;
      }
      if (after == this.dom.firstChild)
        return 0;
      while (after && !ContentView.get(after))
        after = after.nextSibling;
      if (!after)
        return this.length;
      for (let i = 0, pos = 0; ; i++) {
        let child = this.children[i];
        if (child.dom == after)
          return pos;
        pos += child.length + child.breakAfter;
      }
    }
    domBoundsAround(from3, to, offset = 0) {
      let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
      for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (pos < from3 && end > to)
          return child.domBoundsAround(from3, to, pos);
        if (end >= from3 && fromI == -1) {
          fromI = i;
          fromStart = pos;
        }
        if (pos > to && child.dom.parentNode == this.dom) {
          toI = i;
          toEnd = prevEnd;
          break;
        }
        prevEnd = end;
        pos = end + child.breakAfter;
      }
      return {
        from: fromStart,
        to: toEnd < 0 ? offset + this.length : toEnd,
        startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
        endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
      };
    }
    markDirty(andParent = false) {
      this.dirty |= 2;
      this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
      for (let parent = this.parent; parent; parent = parent.parent) {
        if (childList)
          parent.dirty |= 2;
        if (parent.dirty & 1)
          return;
        parent.dirty |= 1;
        childList = false;
      }
    }
    setParent(parent) {
      if (this.parent != parent) {
        this.parent = parent;
        if (this.dirty)
          this.markParentsDirty(true);
      }
    }
    setDOM(dom) {
      if (this.dom)
        this.dom.cmView = null;
      this.dom = dom;
      dom.cmView = this;
    }
    get rootView() {
      for (let v = this; ; ) {
        let parent = v.parent;
        if (!parent)
          return v;
        v = parent;
      }
    }
    replaceChildren(from3, to, children = noChildren) {
      this.markDirty();
      for (let i = from3; i < to; i++) {
        let child = this.children[i];
        if (child.parent == this)
          child.destroy();
      }
      this.children.splice(from3, to - from3, ...children);
      for (let i = 0; i < children.length; i++)
        children[i].setParent(this);
    }
    ignoreMutation(_rec) {
      return false;
    }
    ignoreEvent(_event) {
      return false;
    }
    childCursor(pos = this.length) {
      return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
      return this.childCursor().findPos(pos, bias);
    }
    toString() {
      let name2 = this.constructor.name.replace("View", "");
      return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
    }
    static get(node) {
      return node.cmView;
    }
    get isEditable() {
      return true;
    }
    merge(from3, to, source, hasStart, openStart, openEnd) {
      return false;
    }
    become(other) {
      return false;
    }
    canReuseDOM(other) {
      return other.constructor == this.constructor;
    }
    getSide() {
      return 0;
    }
    destroy() {
      this.parent = null;
    }
  };
  ContentView.prototype.breakAfter = 0;
  function rm$1(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  var ChildCursor = class {
    constructor(children, pos, i) {
      this.children = children;
      this.pos = pos;
      this.i = i;
      this.off = 0;
    }
    findPos(pos, bias = 1) {
      for (; ; ) {
        if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
          this.off = pos - this.pos;
          return this;
        }
        let next = this.children[--this.i];
        this.pos -= next.length + next.breakAfter;
      }
    }
  };
  function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
    let { children } = parent;
    let before = children.length ? children[fromI] : null;
    let last2 = insert2.length ? insert2[insert2.length - 1] : null;
    let breakAtEnd = last2 ? last2.breakAfter : breakAtStart;
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert2.length < 2 && before.merge(fromOff, toOff, insert2.length ? last2 : null, fromOff == 0, openStart, openEnd))
      return;
    if (toI < children.length) {
      let after = children[toI];
      if (after && toOff < after.length) {
        if (fromI == toI) {
          after = after.split(toOff);
          toOff = 0;
        }
        if (!breakAtEnd && last2 && after.merge(0, toOff, last2, true, 0, openEnd)) {
          insert2[insert2.length - 1] = after;
        } else {
          if (toOff)
            after.merge(0, toOff, null, false, 0, openEnd);
          insert2.push(after);
        }
      } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
        if (last2)
          last2.breakAfter = 1;
        else
          breakAtStart = 1;
      }
      toI++;
    }
    if (before) {
      before.breakAfter = breakAtStart;
      if (fromOff > 0) {
        if (!breakAtStart && insert2.length && before.merge(fromOff, before.length, insert2[0], false, openStart, 0)) {
          before.breakAfter = insert2.shift().breakAfter;
        } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
          before.merge(fromOff, before.length, null, false, openStart, 0);
        }
        fromI++;
      }
    }
    while (fromI < toI && insert2.length) {
      if (children[toI - 1].become(insert2[insert2.length - 1])) {
        toI--;
        insert2.pop();
        openEnd = insert2.length ? 0 : openStart;
      } else if (children[fromI].become(insert2[0])) {
        fromI++;
        insert2.shift();
        openStart = insert2.length ? 0 : openEnd;
      } else {
        break;
      }
    }
    if (!insert2.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
      fromI--;
    if (fromI < toI || insert2.length)
      parent.replaceChildren(fromI, toI, insert2);
  }
  function mergeChildrenInto(parent, from3, to, insert2, openStart, openEnd) {
    let cur2 = parent.childCursor();
    let { i: toI, off: toOff } = cur2.findPos(to, 1);
    let { i: fromI, off: fromOff } = cur2.findPos(from3, -1);
    let dLen = from3 - to;
    for (let view2 of insert2)
      dLen += view2.length;
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
  }
  var nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
  var doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
  var ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
  var ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
  var ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
  var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
  var gecko2 = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
  var chrome2 = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
  var webkit = "webkitFontSmoothing" in doc.documentElement.style;
  var safari = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
  var ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
  var browser = {
    mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
    windows: /* @__PURE__ */ /Win/.test(nav.platform),
    linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
    ie: ie2,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko: gecko2,
    gecko_version: gecko2 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome2,
    chrome_version: chrome2 ? +chrome2[1] : 0,
    ios,
    android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
  };
  var MaxJoinLen = 256;
  var TextView = class extends ContentView {
    constructor(text3) {
      super();
      this.text = text3;
    }
    get length() {
      return this.text.length;
    }
    createDOM(textDOM) {
      this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(track) {
      if (!this.dom)
        this.createDOM();
      if (this.dom.nodeValue != this.text) {
        if (track && track.node == this.dom)
          track.written = true;
        this.dom.nodeValue = this.text;
      }
    }
    reuseDOM(dom) {
      if (dom.nodeType == 3)
        this.createDOM(dom);
    }
    merge(from3, to, source) {
      if (source && (!(source instanceof TextView) || this.length - (to - from3) + source.length > MaxJoinLen))
        return false;
      this.text = this.text.slice(0, from3) + (source ? source.text : "") + this.text.slice(to);
      this.markDirty();
      return true;
    }
    split(from3) {
      let result = new TextView(this.text.slice(from3));
      this.text = this.text.slice(0, from3);
      this.markDirty();
      return result;
    }
    localPosFromDOM(node, offset) {
      return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) {
      return new DOMPos(this.dom, pos);
    }
    domBoundsAround(_from, _to, offset) {
      return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
    }
    coordsAt(pos, side) {
      return textCoords(this.dom, pos, side);
    }
  };
  var MarkView = class extends ContentView {
    constructor(mark, children = [], length3 = 0) {
      super();
      this.mark = mark;
      this.children = children;
      this.length = length3;
      for (let ch of children)
        ch.setParent(this);
    }
    setAttrs(dom) {
      clearAttributes(dom);
      if (this.mark.class)
        dom.className = this.mark.class;
      if (this.mark.attrs)
        for (let name2 in this.mark.attrs)
          dom.setAttribute(name2, this.mark.attrs[name2]);
      return dom;
    }
    reuseDOM(node) {
      if (node.nodeName == this.mark.tagName.toUpperCase()) {
        this.setDOM(node);
        this.dirty |= 4 | 2;
      }
    }
    sync(track) {
      if (!this.dom)
        this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
      else if (this.dirty & 4)
        this.setAttrs(this.dom);
      super.sync(track);
    }
    merge(from3, to, source, _hasStart, openStart, openEnd) {
      if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from3 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      mergeChildrenInto(this, from3, to, source ? source.children : [], openStart - 1, openEnd - 1);
      this.markDirty();
      return true;
    }
    split(from3) {
      let result = [], off = 0, detachFrom = -1, i = 0;
      for (let elt2 of this.children) {
        let end = off + elt2.length;
        if (end > from3)
          result.push(off < from3 ? elt2.split(from3 - off) : elt2);
        if (detachFrom < 0 && off >= from3)
          detachFrom = i;
        off = end;
        i++;
      }
      let length3 = this.length - from3;
      this.length = from3;
      if (detachFrom > -1) {
        this.children.length = detachFrom;
        this.markDirty();
      }
      return new MarkView(this.mark, result, length3);
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
  };
  function textCoords(text3, pos, side) {
    let length3 = text3.nodeValue.length;
    if (pos > length3)
      pos = length3;
    let from3 = pos, to = pos, flatten2 = 0;
    if (pos == 0 && side < 0 || pos == length3 && side >= 0) {
      if (!(browser.chrome || browser.gecko)) {
        if (pos) {
          from3--;
          flatten2 = 1;
        } else if (to < length3) {
          to++;
          flatten2 = -1;
        }
      }
    } else {
      if (side < 0)
        from3--;
      else if (to < length3)
        to++;
    }
    let rects = textRange(text3, from3, to).getClientRects();
    if (!rects.length)
      return Rect0;
    let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten2 && rect.width == 0)
      rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
    return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
  }
  var WidgetView = class extends ContentView {
    constructor(widget, length3, side) {
      super();
      this.widget = widget;
      this.length = length3;
      this.side = side;
      this.prevWidget = null;
    }
    static create(widget, length3, side) {
      return new (widget.customView || WidgetView)(widget, length3, side);
    }
    split(from3) {
      let result = WidgetView.create(this.widget, this.length - from3, this.side);
      this.length -= from3;
      return result;
    }
    sync() {
      if (!this.dom || !this.widget.updateDOM(this.dom)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(this.editorView));
        this.dom.contentEditable = "false";
      }
    }
    getSide() {
      return this.side;
    }
    merge(from3, to, source, hasStart, openStart, openEnd) {
      if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from3 > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      this.length = from3 + (source ? source.length : 0) + (this.length - to);
      return true;
    }
    become(other) {
      if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {
        if (this.widget.constructor == other.widget.constructor) {
          if (!this.widget.eq(other.widget))
            this.markDirty(true);
          if (this.dom && !this.prevWidget)
            this.prevWidget = this.widget;
          this.widget = other.widget;
          return true;
        }
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    get overrideDOMText() {
      if (this.length == 0)
        return Text.empty;
      let top2 = this;
      while (top2.parent)
        top2 = top2.parent;
      let view2 = top2.editorView, text3 = view2 && view2.state.doc, start = this.posAtStart;
      return text3 ? text3.slice(start, start + this.length) : Text.empty;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos, side) {
      let rects = this.dom.getClientRects(), rect = null;
      if (!rects.length)
        return Rect0;
      for (let i = pos > 0 ? rects.length - 1 : 0; ; i += pos > 0 ? -1 : 1) {
        rect = rects[i];
        if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
          break;
      }
      return this.length ? rect : flattenRect(rect, this.side > 0);
    }
    get isEditable() {
      return false;
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
  };
  var CompositionView = class extends WidgetView {
    domAtPos(pos) {
      let { topView, text: text3 } = this.widget;
      if (!topView)
        return new DOMPos(text3, Math.min(pos, text3.nodeValue.length));
      return scanCompositionTree(pos, 0, topView, text3, (v, p) => v.domAtPos(p), (p) => new DOMPos(text3, Math.min(p, text3.nodeValue.length)));
    }
    sync() {
      this.setDOM(this.widget.toDOM());
    }
    localPosFromDOM(node, offset) {
      let { topView, text: text3 } = this.widget;
      if (!topView)
        return Math.min(offset, this.length);
      return posFromDOMInCompositionTree(node, offset, topView, text3);
    }
    ignoreMutation() {
      return false;
    }
    get overrideDOMText() {
      return null;
    }
    coordsAt(pos, side) {
      let { topView, text: text3 } = this.widget;
      if (!topView)
        return textCoords(text3, pos, side);
      return scanCompositionTree(pos, side, topView, text3, (v, pos2, side2) => v.coordsAt(pos2, side2), (pos2, side2) => textCoords(text3, pos2, side2));
    }
    destroy() {
      var _a2;
      super.destroy();
      (_a2 = this.widget.topView) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    }
    get isEditable() {
      return true;
    }
    canReuseDOM() {
      return true;
    }
  };
  function scanCompositionTree(pos, side, view2, text3, enterView, fromText) {
    if (view2 instanceof MarkView) {
      for (let child = view2.dom.firstChild; child; child = child.nextSibling) {
        let desc = ContentView.get(child);
        if (!desc)
          return fromText(pos, side);
        let hasComp = contains(child, text3);
        let len = desc.length + (hasComp ? text3.nodeValue.length : 0);
        if (pos < len || pos == len && desc.getSide() <= 0)
          return hasComp ? scanCompositionTree(pos, side, desc, text3, enterView, fromText) : enterView(desc, pos, side);
        pos -= len;
      }
      return enterView(view2, view2.length, -1);
    } else if (view2.dom == text3) {
      return fromText(pos, side);
    } else {
      return enterView(view2, pos, side);
    }
  }
  function posFromDOMInCompositionTree(node, offset, view2, text3) {
    if (view2 instanceof MarkView) {
      for (let child of view2.children) {
        let pos = 0, hasComp = contains(child.dom, text3);
        if (contains(child.dom, node))
          return pos + (hasComp ? posFromDOMInCompositionTree(node, offset, child, text3) : child.localPosFromDOM(node, offset));
        pos += hasComp ? text3.nodeValue.length : child.length;
      }
    } else if (view2.dom == text3) {
      return Math.min(offset, text3.nodeValue.length);
    }
    return view2.localPosFromDOM(node, offset);
  }
  var WidgetBufferView = class extends ContentView {
    constructor(side) {
      super();
      this.side = side;
    }
    get length() {
      return 0;
    }
    merge() {
      return false;
    }
    become(other) {
      return other instanceof WidgetBufferView && other.side == this.side;
    }
    split() {
      return new WidgetBufferView(this.side);
    }
    sync() {
      if (!this.dom) {
        let dom = document.createElement("img");
        dom.className = "cm-widgetBuffer";
        dom.setAttribute("aria-hidden", "true");
        this.setDOM(dom);
      }
    }
    getSide() {
      return this.side;
    }
    domAtPos(pos) {
      return DOMPos.before(this.dom);
    }
    localPosFromDOM() {
      return 0;
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos) {
      let imgRect = this.dom.getBoundingClientRect();
      let siblingRect = inlineSiblingRect(this, this.side > 0 ? -1 : 1);
      return siblingRect && siblingRect.top < imgRect.bottom && siblingRect.bottom > imgRect.top ? { left: imgRect.left, right: imgRect.right, top: siblingRect.top, bottom: siblingRect.bottom } : imgRect;
    }
    get overrideDOMText() {
      return Text.empty;
    }
  };
  TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
  function inlineSiblingRect(view2, side) {
    let parent = view2.parent, index2 = parent ? parent.children.indexOf(view2) : -1;
    while (parent && index2 >= 0) {
      if (side < 0 ? index2 > 0 : index2 < parent.children.length) {
        let next = parent.children[index2 + side];
        if (next instanceof TextView) {
          let nextRect = next.coordsAt(side < 0 ? next.length : 0, side);
          if (nextRect)
            return nextRect;
        }
        index2 += side;
      } else if (parent instanceof MarkView && parent.parent) {
        index2 = parent.parent.children.indexOf(parent) + (side < 0 ? 0 : 1);
        parent = parent.parent;
      } else {
        let last2 = parent.dom.lastChild;
        if (last2 && last2.nodeName == "BR")
          return last2.getClientRects()[0];
        break;
      }
    }
    return void 0;
  }
  function inlineDOMAtPos(parent, pos) {
    let dom = parent.dom, { children } = parent, i = 0;
    for (let off = 0; i < children.length; i++) {
      let child = children[i], end = off + child.length;
      if (end == off && child.getSide() <= 0)
        continue;
      if (pos > off && pos < end && child.dom.parentNode == dom)
        return child.domAtPos(pos - off);
      if (pos <= off)
        break;
      off = end;
    }
    for (let j = i; j > 0; j--) {
      let prev = children[j - 1];
      if (prev.dom.parentNode == dom)
        return prev.domAtPos(prev.length);
    }
    for (let j = i; j < children.length; j++) {
      let next = children[j];
      if (next.dom.parentNode == dom)
        return next.domAtPos(0);
    }
    return new DOMPos(dom, 0);
  }
  function joinInlineInto(parent, view2, open) {
    let last2, { children } = parent;
    if (open > 0 && view2 instanceof MarkView && children.length && (last2 = children[children.length - 1]) instanceof MarkView && last2.mark.eq(view2.mark)) {
      joinInlineInto(last2, view2.children[0], open - 1);
    } else {
      children.push(view2);
      view2.setParent(parent);
    }
    parent.length += view2.length;
  }
  function coordsInChildren(view2, pos, side) {
    let before = null, beforePos = -1, after = null, afterPos = -1;
    function scan(view3, pos2) {
      for (let i = 0, off = 0; i < view3.children.length && off <= pos2; i++) {
        let child = view3.children[i], end = off + child.length;
        if (end >= pos2) {
          if (child.children.length) {
            scan(child, pos2 - off);
          } else if (!after && (end > pos2 || off == end && child.getSide() > 0)) {
            after = child;
            afterPos = pos2 - off;
          } else if (off < pos2 || off == end && child.getSide() < 0) {
            before = child;
            beforePos = pos2 - off;
          }
        }
        off = end;
      }
    }
    scan(view2, pos);
    let target = (side < 0 ? before : after) || before || after;
    if (target)
      return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
    return fallbackRect(view2);
  }
  function fallbackRect(view2) {
    let last2 = view2.dom.lastChild;
    if (!last2)
      return view2.dom.getBoundingClientRect();
    let rects = clientRectsFor(last2);
    return rects[rects.length - 1] || null;
  }
  function combineAttrs(source, target) {
    for (let name2 in source) {
      if (name2 == "class" && target.class)
        target.class += " " + source.class;
      else if (name2 == "style" && target.style)
        target.style += ";" + source.style;
      else
        target[name2] = source[name2];
    }
    return target;
  }
  function attrsEq(a2, b) {
    if (a2 == b)
      return true;
    if (!a2 || !b)
      return false;
    let keysA = Object.keys(a2), keysB = Object.keys(b);
    if (keysA.length != keysB.length)
      return false;
    for (let key of keysA) {
      if (keysB.indexOf(key) == -1 || a2[key] !== b[key])
        return false;
    }
    return true;
  }
  function updateAttrs(dom, prev, attrs) {
    let changed = null;
    if (prev) {
      for (let name2 in prev)
        if (!(attrs && name2 in attrs))
          dom.removeAttribute(changed = name2);
    }
    if (attrs) {
      for (let name2 in attrs)
        if (!(prev && prev[name2] == attrs[name2]))
          dom.setAttribute(changed = name2, attrs[name2]);
    }
    return !!changed;
  }
  var WidgetType = class {
    eq(widget) {
      return false;
    }
    updateDOM(dom) {
      return false;
    }
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    get estimatedHeight() {
      return -1;
    }
    ignoreEvent(event) {
      return true;
    }
    get customView() {
      return null;
    }
    destroy(dom) {
    }
  };
  var BlockType = /* @__PURE__ */ function(BlockType2) {
    BlockType2[BlockType2["Text"] = 0] = "Text";
    BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
    BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
    BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
    return BlockType2;
  }(BlockType || (BlockType = {}));
  var Decoration = class extends RangeValue {
    constructor(startSide, endSide, widget, spec) {
      super();
      this.startSide = startSide;
      this.endSide = endSide;
      this.widget = widget;
      this.spec = spec;
    }
    get heightRelevant() {
      return false;
    }
    static mark(spec) {
      return new MarkDecoration(spec);
    }
    static widget(spec) {
      let side = spec.side || 0, block = !!spec.block;
      side += block ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
      return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    static replace(spec) {
      let block = !!spec.block, startSide, endSide;
      if (spec.isBlockGap) {
        startSide = -5e8;
        endSide = 4e8;
      } else {
        let { start, end } = getInclusive(spec, block);
        startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
        endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
      }
      return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    static line(spec) {
      return new LineDecoration(spec);
    }
    static set(of, sort = false) {
      return RangeSet.of(of, sort);
    }
    hasHeight() {
      return this.widget ? this.widget.estimatedHeight > -1 : false;
    }
  };
  Decoration.none = RangeSet.empty;
  var MarkDecoration = class extends Decoration {
    constructor(spec) {
      let { start, end } = getInclusive(spec);
      super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
      this.tagName = spec.tagName || "span";
      this.class = spec.class || "";
      this.attrs = spec.attributes || null;
    }
    eq(other) {
      return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs);
    }
    range(from3, to = from3) {
      if (from3 >= to)
        throw new RangeError("Mark decorations may not be empty");
      return super.range(from3, to);
    }
  };
  MarkDecoration.prototype.point = false;
  var LineDecoration = class extends Decoration {
    constructor(spec) {
      super(-2e8, -2e8, null, spec);
    }
    eq(other) {
      return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from3, to = from3) {
      if (to != from3)
        throw new RangeError("Line decoration ranges must be zero-length");
      return super.range(from3, to);
    }
  };
  LineDecoration.prototype.mapMode = MapMode.TrackBefore;
  LineDecoration.prototype.point = true;
  var PointDecoration = class extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
      super(startSide, endSide, widget, spec);
      this.block = block;
      this.isReplace = isReplace;
      this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
    }
    get type() {
      return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
      return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
    }
    eq(other) {
      return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from3, to = from3) {
      if (this.isReplace && (from3 > to || from3 == to && this.startSide > 0 && this.endSide <= 0))
        throw new RangeError("Invalid range for replacement decoration");
      if (!this.isReplace && to != from3)
        throw new RangeError("Widget decorations can only have zero-length ranges");
      return super.range(from3, to);
    }
  };
  PointDecoration.prototype.point = true;
  function getInclusive(spec, block = false) {
    let { inclusiveStart: start, inclusiveEnd: end } = spec;
    if (start == null)
      start = spec.inclusive;
    if (end == null)
      end = spec.inclusive;
    return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
  }
  function widgetsEq(a2, b) {
    return a2 == b || !!(a2 && b && a2.compare(b));
  }
  function addRange(from3, to, ranges, margin = 0) {
    let last2 = ranges.length - 1;
    if (last2 >= 0 && ranges[last2] + margin >= from3)
      ranges[last2] = Math.max(ranges[last2], to);
    else
      ranges.push(from3, to);
  }
  var LineView = class extends ContentView {
    constructor() {
      super(...arguments);
      this.children = [];
      this.length = 0;
      this.prevAttrs = void 0;
      this.attrs = null;
      this.breakAfter = 0;
    }
    merge(from3, to, source, hasStart, openStart, openEnd) {
      if (source) {
        if (!(source instanceof LineView))
          return false;
        if (!this.dom)
          source.transferDOM(this);
      }
      if (hasStart)
        this.setDeco(source ? source.attrs : null);
      mergeChildrenInto(this, from3, to, source ? source.children : [], openStart, openEnd);
      return true;
    }
    split(at) {
      let end = new LineView();
      end.breakAfter = this.breakAfter;
      if (this.length == 0)
        return end;
      let { i, off } = this.childPos(at);
      if (off) {
        end.append(this.children[i].split(off), 0);
        this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
        i++;
      }
      for (let j = i; j < this.children.length; j++)
        end.append(this.children[j], 0);
      while (i > 0 && this.children[i - 1].length == 0)
        this.children[--i].destroy();
      this.children.length = i;
      this.markDirty();
      this.length = at;
      return end;
    }
    transferDOM(other) {
      if (!this.dom)
        return;
      this.markDirty();
      other.setDOM(this.dom);
      other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
      this.prevAttrs = void 0;
      this.dom = null;
    }
    setDeco(attrs) {
      if (!attrsEq(this.attrs, attrs)) {
        if (this.dom) {
          this.prevAttrs = this.attrs;
          this.markDirty();
        }
        this.attrs = attrs;
      }
    }
    append(child, openStart) {
      joinInlineInto(this, child, openStart);
    }
    addLineDeco(deco) {
      let attrs = deco.spec.attributes, cls = deco.spec.class;
      if (attrs)
        this.attrs = combineAttrs(attrs, this.attrs || {});
      if (cls)
        this.attrs = combineAttrs({ class: cls }, this.attrs || {});
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    reuseDOM(node) {
      if (node.nodeName == "DIV") {
        this.setDOM(node);
        this.dirty |= 4 | 2;
      }
    }
    sync(track) {
      var _a2;
      if (!this.dom) {
        this.setDOM(document.createElement("div"));
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      } else if (this.dirty & 4) {
        clearAttributes(this.dom);
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      }
      if (this.prevAttrs !== void 0) {
        updateAttrs(this.dom, this.prevAttrs, this.attrs);
        this.dom.classList.add("cm-line");
        this.prevAttrs = void 0;
      }
      super.sync(track);
      let last2 = this.dom.lastChild;
      while (last2 && ContentView.get(last2) instanceof MarkView)
        last2 = last2.lastChild;
      if (!last2 || !this.length || last2.nodeName != "BR" && ((_a2 = ContentView.get(last2)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
        let hack = document.createElement("BR");
        hack.cmIgnore = true;
        this.dom.appendChild(hack);
      }
    }
    measureTextSize() {
      if (this.children.length == 0 || this.length > 20)
        return null;
      let totalWidth = 0;
      for (let child of this.children) {
        if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
          return null;
        let rects = clientRectsFor(child.dom);
        if (rects.length != 1)
          return null;
        totalWidth += rects[0].width;
      }
      return !totalWidth ? null : {
        lineHeight: this.dom.getBoundingClientRect().height,
        charWidth: totalWidth / this.length
      };
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
    become(_other) {
      return false;
    }
    get type() {
      return BlockType.Text;
    }
    static find(docView, pos) {
      for (let i = 0, off = 0; i < docView.children.length; i++) {
        let block = docView.children[i], end = off + block.length;
        if (end >= pos) {
          if (block instanceof LineView)
            return block;
          if (end > pos)
            break;
        }
        off = end + block.breakAfter;
      }
      return null;
    }
  };
  var BlockWidgetView = class extends ContentView {
    constructor(widget, length3, type) {
      super();
      this.widget = widget;
      this.length = length3;
      this.type = type;
      this.breakAfter = 0;
      this.prevWidget = null;
    }
    merge(from3, to, source, _takeDeco, openStart, openEnd) {
      if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from3 > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      this.length = from3 + (source ? source.length : 0) + (this.length - to);
      return true;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
      let len = this.length - at;
      this.length = at;
      let end = new BlockWidgetView(this.widget, len, this.type);
      end.breakAfter = this.breakAfter;
      return end;
    }
    get children() {
      return noChildren;
    }
    sync() {
      if (!this.dom || !this.widget.updateDOM(this.dom)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(this.editorView));
        this.dom.contentEditable = "false";
      }
    }
    get overrideDOMText() {
      return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
    }
    domBoundsAround() {
      return null;
    }
    become(other) {
      if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {
        if (!other.widget.eq(this.widget))
          this.markDirty(true);
        if (this.dom && !this.prevWidget)
          this.prevWidget = this.widget;
        this.widget = other.widget;
        this.length = other.length;
        this.breakAfter = other.breakAfter;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
  };
  var ContentBuilder = class {
    constructor(doc3, pos, end, disallowBlockEffectsFor) {
      this.doc = doc3;
      this.pos = pos;
      this.end = end;
      this.disallowBlockEffectsFor = disallowBlockEffectsFor;
      this.content = [];
      this.curLine = null;
      this.breakAtStart = 0;
      this.pendingBuffer = 0;
      this.atCursorPos = true;
      this.openStart = -1;
      this.openEnd = -1;
      this.text = "";
      this.textOff = 0;
      this.cursor = doc3.iter();
      this.skip = pos;
    }
    posCovered() {
      if (this.content.length == 0)
        return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
      let last2 = this.content[this.content.length - 1];
      return !last2.breakAfter && !(last2 instanceof BlockWidgetView && last2.type == BlockType.WidgetBefore);
    }
    getLine() {
      if (!this.curLine) {
        this.content.push(this.curLine = new LineView());
        this.atCursorPos = true;
      }
      return this.curLine;
    }
    flushBuffer(active) {
      if (this.pendingBuffer) {
        this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
        this.pendingBuffer = 0;
      }
    }
    addBlockWidget(view2) {
      this.flushBuffer([]);
      this.curLine = null;
      this.content.push(view2);
    }
    finish(openEnd) {
      if (!openEnd)
        this.flushBuffer([]);
      else
        this.pendingBuffer = 0;
      if (!this.posCovered())
        this.getLine();
    }
    buildText(length3, active, openStart) {
      while (length3 > 0) {
        if (this.textOff == this.text.length) {
          let { value, lineBreak, done } = this.cursor.next(this.skip);
          this.skip = 0;
          if (done)
            throw new Error("Ran out of text content when drawing inline views");
          if (lineBreak) {
            if (!this.posCovered())
              this.getLine();
            if (this.content.length)
              this.content[this.content.length - 1].breakAfter = 1;
            else
              this.breakAtStart = 1;
            this.flushBuffer([]);
            this.curLine = null;
            length3--;
            continue;
          } else {
            this.text = value;
            this.textOff = 0;
          }
        }
        let take = Math.min(this.text.length - this.textOff, length3, 512);
        this.flushBuffer(active.slice(active.length - openStart));
        this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
        this.atCursorPos = true;
        this.textOff += take;
        length3 -= take;
        openStart = 0;
      }
    }
    span(from3, to, active, openStart) {
      this.buildText(to - from3, active, openStart);
      this.pos = to;
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    point(from3, to, deco, active, openStart, index2) {
      if (this.disallowBlockEffectsFor[index2] && deco instanceof PointDecoration) {
        if (deco.block)
          throw new RangeError("Block decorations may not be specified via plugins");
        if (to > this.doc.lineAt(this.pos).to)
          throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
      }
      let len = to - from3;
      if (deco instanceof PointDecoration) {
        if (deco.block) {
          let { type } = deco;
          if (type == BlockType.WidgetAfter && !this.posCovered())
            this.getLine();
          this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type));
        } else {
          let view2 = WidgetView.create(deco.widget || new NullWidget("span"), len, len ? 0 : deco.startSide);
          let cursorBefore = this.atCursorPos && !view2.isEditable && openStart <= active.length && (from3 < to || deco.startSide > 0);
          let cursorAfter = !view2.isEditable && (from3 < to || deco.startSide <= 0);
          let line = this.getLine();
          if (this.pendingBuffer == 2 && !cursorBefore)
            this.pendingBuffer = 0;
          this.flushBuffer(active);
          if (cursorBefore) {
            line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
            openStart = active.length + Math.max(0, openStart - active.length);
          }
          line.append(wrapMarks(view2, active), openStart);
          this.atCursorPos = cursorAfter;
          this.pendingBuffer = !cursorAfter ? 0 : from3 < to ? 1 : 2;
        }
      } else if (this.doc.lineAt(this.pos).from == this.pos) {
        this.getLine().addLineDeco(deco);
      }
      if (len) {
        if (this.textOff + len <= this.text.length) {
          this.textOff += len;
        } else {
          this.skip += len - (this.text.length - this.textOff);
          this.text = "";
          this.textOff = 0;
        }
        this.pos = to;
      }
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    static build(text3, from3, to, decorations2, dynamicDecorationMap) {
      let builder = new ContentBuilder(text3, from3, to, dynamicDecorationMap);
      builder.openEnd = RangeSet.spans(decorations2, from3, to, builder);
      if (builder.openStart < 0)
        builder.openStart = builder.openEnd;
      builder.finish(builder.openEnd);
      return builder;
    }
  };
  function wrapMarks(view2, active) {
    for (let mark of active)
      view2 = new MarkView(mark, [view2], view2.length);
    return view2;
  }
  var NullWidget = class extends WidgetType {
    constructor(tag) {
      super();
      this.tag = tag;
    }
    eq(other) {
      return other.tag == this.tag;
    }
    toDOM() {
      return document.createElement(this.tag);
    }
    updateDOM(elt2) {
      return elt2.nodeName.toLowerCase() == this.tag;
    }
  };
  var clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
  var dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
  var mouseSelectionStyle = /* @__PURE__ */ Facet.define();
  var exceptionSink = /* @__PURE__ */ Facet.define();
  var updateListener = /* @__PURE__ */ Facet.define();
  var inputHandler = /* @__PURE__ */ Facet.define();
  var perLineTextDirection = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.some((x3) => x3)
  });
  var nativeSelectionHidden = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.some((x3) => x3)
  });
  var ScrollTarget = class {
    constructor(range, y3 = "nearest", x3 = "nearest", yMargin = 5, xMargin = 5) {
      this.range = range;
      this.y = y3;
      this.x = x3;
      this.yMargin = yMargin;
      this.xMargin = xMargin;
    }
    map(changes) {
      return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);
    }
  };
  var scrollIntoView = /* @__PURE__ */ StateEffect.define({ map: (t2, ch) => t2.map(ch) });
  function logException(state, exception, context) {
    let handler = state.facet(exceptionSink);
    if (handler.length)
      handler[0](exception);
    else if (window.onerror)
      window.onerror(String(exception), context, void 0, void 0, exception);
    else if (context)
      console.error(context + ":", exception);
    else
      console.error(exception);
  }
  var editable = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.length ? values2[0] : true });
  var nextPluginID = 0;
  var viewPlugin = /* @__PURE__ */ Facet.define();
  var ViewPlugin = class {
    constructor(id3, create8, domEventHandlers, buildExtensions) {
      this.id = id3;
      this.create = create8;
      this.domEventHandlers = domEventHandlers;
      this.extension = buildExtensions(this);
    }
    static define(create8, spec) {
      const { eventHandlers, provide, decorations: deco } = spec || {};
      return new ViewPlugin(nextPluginID++, create8, eventHandlers, (plugin) => {
        let ext = [viewPlugin.of(plugin)];
        if (deco)
          ext.push(decorations.of((view2) => {
            let pluginInst = view2.plugin(plugin);
            return pluginInst ? deco(pluginInst) : Decoration.none;
          }));
        if (provide)
          ext.push(provide(plugin));
        return ext;
      });
    }
    static fromClass(cls, spec) {
      return ViewPlugin.define((view2) => new cls(view2), spec);
    }
  };
  var PluginInstance = class {
    constructor(spec) {
      this.spec = spec;
      this.mustUpdate = null;
      this.value = null;
    }
    update(view2) {
      if (!this.value) {
        if (this.spec) {
          try {
            this.value = this.spec.create(view2);
          } catch (e) {
            logException(view2.state, e, "CodeMirror plugin crashed");
            this.deactivate();
          }
        }
      } else if (this.mustUpdate) {
        let update = this.mustUpdate;
        this.mustUpdate = null;
        if (this.value.update) {
          try {
            this.value.update(update);
          } catch (e) {
            logException(update.state, e, "CodeMirror plugin crashed");
            if (this.value.destroy)
              try {
                this.value.destroy();
              } catch (_) {
              }
            this.deactivate();
          }
        }
      }
      return this;
    }
    destroy(view2) {
      var _a2;
      if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
        try {
          this.value.destroy();
        } catch (e) {
          logException(view2.state, e, "CodeMirror plugin crashed");
        }
      }
    }
    deactivate() {
      this.spec = this.value = null;
    }
  };
  var editorAttributes = /* @__PURE__ */ Facet.define();
  var contentAttributes = /* @__PURE__ */ Facet.define();
  var decorations = /* @__PURE__ */ Facet.define();
  var atomicRanges = /* @__PURE__ */ Facet.define();
  var scrollMargins = /* @__PURE__ */ Facet.define();
  var styleModule = /* @__PURE__ */ Facet.define();
  var ChangedRange = class {
    constructor(fromA, toA, fromB, toB) {
      this.fromA = fromA;
      this.toA = toA;
      this.fromB = fromB;
      this.toB = toB;
    }
    join(other) {
      return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set3) {
      let i = set3.length, me = this;
      for (; i > 0; i--) {
        let range = set3[i - 1];
        if (range.fromA > me.toA)
          continue;
        if (range.toA < me.fromA)
          break;
        me = me.join(range);
        set3.splice(i - 1, 1);
      }
      set3.splice(i, 0, me);
      return set3;
    }
    static extendWithRanges(diff, ranges) {
      if (ranges.length == 0)
        return diff;
      let result = [];
      for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
        let next = dI == diff.length ? null : diff[dI], off = posA - posB;
        let end = next ? next.fromB : 1e9;
        while (rI < ranges.length && ranges[rI] < end) {
          let from3 = ranges[rI], to = ranges[rI + 1];
          let fromB = Math.max(posB, from3), toB = Math.min(end, to);
          if (fromB <= toB)
            new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
          if (to > end)
            break;
          else
            rI += 2;
        }
        if (!next)
          return result;
        new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
        posA = next.toA;
        posB = next.toB;
      }
    }
  };
  var ViewUpdate = class {
    constructor(view2, state, transactions) {
      this.view = view2;
      this.state = state;
      this.transactions = transactions;
      this.flags = 0;
      this.startState = view2.state;
      this.changes = ChangeSet.empty(this.startState.doc.length);
      for (let tr of transactions)
        this.changes = this.changes.compose(tr.changes);
      let changedRanges = [];
      this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
      this.changedRanges = changedRanges;
      let focus = view2.hasFocus;
      if (focus != view2.inputState.notifiedFocused) {
        view2.inputState.notifiedFocused = focus;
        this.flags |= 1;
      }
    }
    static create(view2, state, transactions) {
      return new ViewUpdate(view2, state, transactions);
    }
    get viewportChanged() {
      return (this.flags & 4) > 0;
    }
    get heightChanged() {
      return (this.flags & 2) > 0;
    }
    get geometryChanged() {
      return this.docChanged || (this.flags & (8 | 2)) > 0;
    }
    get focusChanged() {
      return (this.flags & 1) > 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get selectionSet() {
      return this.transactions.some((tr) => tr.selection);
    }
    get empty() {
      return this.flags == 0 && this.transactions.length == 0;
    }
  };
  var Direction = /* @__PURE__ */ function(Direction2) {
    Direction2[Direction2["LTR"] = 0] = "LTR";
    Direction2[Direction2["RTL"] = 1] = "RTL";
    return Direction2;
  }(Direction || (Direction = {}));
  var LTR = Direction.LTR;
  var RTL = Direction.RTL;
  function dec(str) {
    let result = [];
    for (let i = 0; i < str.length; i++)
      result.push(1 << +str[i]);
    return result;
  }
  var LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
  var ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
  var Brackets = /* @__PURE__ */ Object.create(null);
  var BracketStack = [];
  for (let p of ["()", "[]", "{}"]) {
    let l = /* @__PURE__ */ p.charCodeAt(0), r = /* @__PURE__ */ p.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
  }
  function charType(ch) {
    return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8203 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : ch == 8204 ? 256 : 1;
  }
  var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
  var BidiSpan = class {
    constructor(from3, to, level) {
      this.from = from3;
      this.to = to;
      this.level = level;
    }
    get dir() {
      return this.level % 2 ? RTL : LTR;
    }
    side(end, dir) {
      return this.dir == dir == end ? this.to : this.from;
    }
    static find(order, index2, level, assoc) {
      let maybe = -1;
      for (let i = 0; i < order.length; i++) {
        let span = order[i];
        if (span.from <= index2 && span.to >= index2) {
          if (span.level == level)
            return i;
          if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index2 : span.to > index2 : order[maybe].level > span.level))
            maybe = i;
        }
      }
      if (maybe < 0)
        throw new RangeError("Index out of range");
      return maybe;
    }
  };
  var types = [];
  function computeOrder(line, direction) {
    let len = line.length, outerType = direction == LTR ? 1 : 2, oppositeType = direction == LTR ? 2 : 1;
    if (!line || outerType == 1 && !BidiRE.test(line))
      return trivialOrder(len);
    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
      let type = charType(line.charCodeAt(i));
      if (type == 512)
        type = prev;
      else if (type == 8 && prevStrong == 4)
        type = 16;
      types[i] = type == 4 ? 2 : type;
      if (type & 7)
        prevStrong = type;
      prev = type;
    }
    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
      let type = types[i];
      if (type == 128) {
        if (i < len - 1 && prev == types[i + 1] && prev & 24)
          type = types[i] = prev;
        else
          types[i] = 256;
      } else if (type == 64) {
        let end = i + 1;
        while (end < len && types[end] == 64)
          end++;
        let replace = i && prev == 8 || end < len && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j = i; j < end; j++)
          types[j] = replace;
        i = end - 1;
      } else if (type == 8 && prevStrong == 1) {
        types[i] = 1;
      }
      prev = type;
      if (type & 7)
        prevStrong = type;
    }
    for (let i = 0, sI = 0, context = 0, ch, br, type; i < len; i++) {
      if (br = Brackets[ch = line.charCodeAt(i)]) {
        if (br < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br) {
              let flags = BracketStack[sJ + 2];
              let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type2)
                types[i] = types[BracketStack[sJ]] = type2;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i;
          BracketStack[sI++] = ch;
          BracketStack[sI++] = context;
        }
      } else if ((type = types[i]) == 2 || type == 1) {
        let embed = type == outerType;
        context = embed ? 0 : 1;
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur2 = BracketStack[sJ + 2];
          if (cur2 & 2)
            break;
          if (embed) {
            BracketStack[sJ + 2] |= 2;
          } else {
            if (cur2 & 4)
              break;
            BracketStack[sJ + 2] |= 4;
          }
        }
      }
    }
    for (let i = 0; i < len; i++) {
      if (types[i] == 256) {
        let end = i + 1;
        while (end < len && types[end] == 256)
          end++;
        let beforeL = (i ? types[i - 1] : outerType) == 1;
        let afterL = (end < len ? types[end] : outerType) == 1;
        let replace = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j = i; j < end; j++)
          types[j] = replace;
        i = end - 1;
      }
    }
    let order = [];
    if (outerType == 1) {
      for (let i = 0; i < len; ) {
        let start = i, rtl = types[i++] != 1;
        while (i < len && rtl == (types[i] != 1))
          i++;
        if (rtl) {
          for (let j = i; j > start; ) {
            let end = j, l = types[--j] != 2;
            while (j > start && l == (types[j - 1] != 2))
              j--;
            order.push(new BidiSpan(j, end, l ? 2 : 1));
          }
        } else {
          order.push(new BidiSpan(start, i, 0));
        }
      }
    } else {
      for (let i = 0; i < len; ) {
        let start = i, rtl = types[i++] == 2;
        while (i < len && rtl == (types[i] == 2))
          i++;
        order.push(new BidiSpan(start, i, rtl ? 1 : 2));
      }
    }
    return order;
  }
  function trivialOrder(length3) {
    return [new BidiSpan(0, length3, 0)];
  }
  var movedOver = "";
  function moveVisually(line, order, dir, start, forward) {
    var _a2;
    let startIndex = start.head - line.from, spanI = -1;
    if (startIndex == 0) {
      if (!forward || !line.length)
        return null;
      if (order[0].level != dir) {
        startIndex = order[0].side(false, dir);
        spanI = 0;
      }
    } else if (startIndex == line.length) {
      if (forward)
        return null;
      let last2 = order[order.length - 1];
      if (last2.level != dir) {
        startIndex = last2.side(true, dir);
        spanI = order.length - 1;
      }
    }
    if (spanI < 0)
      spanI = BidiSpan.find(order, startIndex, (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start.assoc);
    let span = order[spanI];
    if (startIndex == span.side(forward, dir)) {
      span = order[spanI += forward ? 1 : -1];
      startIndex = span.side(!forward, dir);
    }
    let indexForward = forward == (span.dir == dir);
    let nextIndex = findClusterBreak(line.text, startIndex, indexForward);
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    if (nextIndex != span.side(forward, dir))
      return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (!nextSpan && span.level != dir)
      return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
    if (nextSpan && nextSpan.level < span.level)
      return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
    return EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
  }
  var LineBreakPlaceholder = "\uFFFF";
  var DOMReader = class {
    constructor(points, state) {
      this.points = points;
      this.text = "";
      this.lineSeparator = state.facet(EditorState.lineSeparator);
    }
    append(text3) {
      this.text += text3;
    }
    lineBreak() {
      this.text += LineBreakPlaceholder;
    }
    readRange(start, end) {
      if (!start)
        return this;
      let parent = start.parentNode;
      for (let cur2 = start; ; ) {
        this.findPointBefore(parent, cur2);
        this.readNode(cur2);
        let next = cur2.nextSibling;
        if (next == end)
          break;
        let view2 = ContentView.get(cur2), nextView = ContentView.get(next);
        if (view2 && nextView ? view2.breakAfter : (view2 ? view2.breakAfter : isBlockElement(cur2)) || isBlockElement(next) && (cur2.nodeName != "BR" || cur2.cmIgnore))
          this.lineBreak();
        cur2 = next;
      }
      this.findPointBefore(parent, end);
      return this;
    }
    readTextNode(node) {
      let text3 = node.nodeValue;
      for (let point of this.points)
        if (point.node == node)
          point.pos = this.text.length + Math.min(point.offset, text3.length);
      for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
        let nextBreak = -1, breakSize = 1, m2;
        if (this.lineSeparator) {
          nextBreak = text3.indexOf(this.lineSeparator, off);
          breakSize = this.lineSeparator.length;
        } else if (m2 = re.exec(text3)) {
          nextBreak = m2.index;
          breakSize = m2[0].length;
        }
        this.append(text3.slice(off, nextBreak < 0 ? text3.length : nextBreak));
        if (nextBreak < 0)
          break;
        this.lineBreak();
        if (breakSize > 1) {
          for (let point of this.points)
            if (point.node == node && point.pos > this.text.length)
              point.pos -= breakSize - 1;
        }
        off = nextBreak + breakSize;
      }
    }
    readNode(node) {
      if (node.cmIgnore)
        return;
      let view2 = ContentView.get(node);
      let fromView = view2 && view2.overrideDOMText;
      if (fromView != null) {
        this.findPointInside(node, fromView.length);
        for (let i = fromView.iter(); !i.next().done; ) {
          if (i.lineBreak)
            this.lineBreak();
          else
            this.append(i.value);
        }
      } else if (node.nodeType == 3) {
        this.readTextNode(node);
      } else if (node.nodeName == "BR") {
        if (node.nextSibling)
          this.lineBreak();
      } else if (node.nodeType == 1) {
        this.readRange(node.firstChild, null);
      }
    }
    findPointBefore(node, next) {
      for (let point of this.points)
        if (point.node == node && node.childNodes[point.offset] == next)
          point.pos = this.text.length;
    }
    findPointInside(node, maxLen) {
      for (let point of this.points)
        if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
          point.pos = this.text.length + Math.min(maxLen, point.offset);
    }
  };
  function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
  }
  var DOMPoint = class {
    constructor(node, offset) {
      this.node = node;
      this.offset = offset;
      this.pos = -1;
    }
  };
  var DocView = class extends ContentView {
    constructor(view2) {
      super();
      this.view = view2;
      this.compositionDeco = Decoration.none;
      this.decorations = [];
      this.dynamicDecorationMap = [];
      this.minWidth = 0;
      this.minWidthFrom = 0;
      this.minWidthTo = 0;
      this.impreciseAnchor = null;
      this.impreciseHead = null;
      this.forceSelection = false;
      this.lastUpdate = Date.now();
      this.setDOM(view2.contentDOM);
      this.children = [new LineView()];
      this.children[0].setParent(this);
      this.updateDeco();
      this.updateInner([new ChangedRange(0, 0, 0, view2.state.doc.length)], 0);
    }
    get editorView() {
      return this.view;
    }
    get length() {
      return this.view.state.doc.length;
    }
    update(update) {
      let changedRanges = update.changedRanges;
      if (this.minWidth > 0 && changedRanges.length) {
        if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
          this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
        } else {
          this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
          this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
        }
      }
      if (this.view.inputState.composing < 0)
        this.compositionDeco = Decoration.none;
      else if (update.transactions.length || this.dirty)
        this.compositionDeco = computeCompositionDeco(this.view, update.changes);
      if ((browser.ie || browser.chrome) && !this.compositionDeco.size && update && update.state.doc.lines != update.startState.doc.lines)
        this.forceSelection = true;
      let prevDeco = this.decorations, deco = this.updateDeco();
      let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
      changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
      if (this.dirty == 0 && changedRanges.length == 0) {
        return false;
      } else {
        this.updateInner(changedRanges, update.startState.doc.length);
        if (update.transactions.length)
          this.lastUpdate = Date.now();
        return true;
      }
    }
    updateInner(changes, oldLength) {
      this.view.viewState.mustMeasureContent = true;
      this.updateChildren(changes, oldLength);
      let { observer } = this.view;
      observer.ignore(() => {
        this.dom.style.height = this.view.viewState.contentHeight + "px";
        this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
        let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
        this.sync(track);
        this.dirty = 0;
        if (track && (track.written || observer.selectionRange.focusNode != track.node))
          this.forceSelection = true;
        this.dom.style.height = "";
      });
      let gaps = [];
      if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
        for (let child of this.children)
          if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
            gaps.push(child.dom);
      }
      observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength) {
      let cursor = this.childCursor(oldLength);
      for (let i = changes.length - 1; ; i--) {
        let next = i >= 0 ? changes[i] : null;
        if (!next)
          break;
        let { fromA, toA, fromB, toB } = next;
        let { content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap);
        let { i: toI, off: toOff } = cursor.findPos(toA, 1);
        let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
        replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
      }
    }
    updateSelection(mustRead = false, fromPointer = false) {
      if (mustRead || !this.view.observer.selectionRange.focusNode)
        this.view.observer.readSelectionRange();
      if (!(fromPointer || this.mayControlSelection()))
        return;
      let force = this.forceSelection;
      this.forceSelection = false;
      let main = this.view.state.selection.main;
      let anchor = this.domAtPos(main.anchor);
      let head = main.empty ? anchor : this.domAtPos(main.head);
      if (browser.gecko && main.empty && betweenUneditable(anchor)) {
        let dummy = document.createTextNode("");
        this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
        anchor = head = new DOMPos(dummy, 0);
        force = true;
      }
      let domSel = this.view.observer.selectionRange;
      if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
        this.view.observer.ignore(() => {
          if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
            this.dom.blur();
            this.dom.focus({ preventScroll: true });
          }
          let rawSel = getSelection(this.view.root);
          if (!rawSel)
            ;
          else if (main.empty) {
            if (browser.gecko) {
              let nextTo = nextToUneditable(anchor.node, anchor.offset);
              if (nextTo && nextTo != (1 | 2)) {
                let text3 = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
                if (text3)
                  anchor = new DOMPos(text3, nextTo == 1 ? 0 : text3.nodeValue.length);
              }
            }
            rawSel.collapse(anchor.node, anchor.offset);
            if (main.bidiLevel != null && domSel.cursorBidiLevel != null)
              domSel.cursorBidiLevel = main.bidiLevel;
          } else if (rawSel.extend) {
            rawSel.collapse(anchor.node, anchor.offset);
            try {
              rawSel.extend(head.node, head.offset);
            } catch (_) {
            }
          } else {
            let range = document.createRange();
            if (main.anchor > main.head)
              [anchor, head] = [head, anchor];
            range.setEnd(head.node, head.offset);
            range.setStart(anchor.node, anchor.offset);
            rawSel.removeAllRanges();
            rawSel.addRange(range);
          }
        });
        this.view.observer.setSelectionRange(anchor, head);
      }
      this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
      this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    enforceCursorAssoc() {
      if (this.compositionDeco.size)
        return;
      let { view: view2 } = this, cursor = view2.state.selection.main;
      let sel = getSelection(view2.root);
      let { anchorNode, anchorOffset } = view2.observer.selectionRange;
      if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
        return;
      let line = LineView.find(this, cursor.head);
      if (!line)
        return;
      let lineStart = line.posAtStart;
      if (cursor.head == lineStart || cursor.head == lineStart + line.length)
        return;
      let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
      if (!before || !after || before.bottom > after.top)
        return;
      let dom = this.domAtPos(cursor.head + cursor.assoc);
      sel.collapse(dom.node, dom.offset);
      sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
      view2.observer.readSelectionRange();
      let newRange = view2.observer.selectionRange;
      if (view2.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
        sel.collapse(anchorNode, anchorOffset);
    }
    mayControlSelection() {
      let active = this.view.root.activeElement;
      return active == this.dom || hasSelection(this.dom, this.view.observer.selectionRange) && !(active && this.dom.contains(active));
    }
    nearest(dom) {
      for (let cur2 = dom; cur2; ) {
        let domView = ContentView.get(cur2);
        if (domView && domView.rootView == this)
          return domView;
        cur2 = cur2.parentNode;
      }
      return null;
    }
    posFromDOM(node, offset) {
      let view2 = this.nearest(node);
      if (!view2)
        throw new RangeError("Trying to find position for a DOM position outside of the document");
      return view2.localPosFromDOM(node, offset) + view2.posAtStart;
    }
    domAtPos(pos) {
      let { i, off } = this.childCursor().findPos(pos, -1);
      for (; i < this.children.length - 1; ) {
        let child = this.children[i];
        if (off < child.length || child instanceof LineView)
          break;
        i++;
        off = 0;
      }
      return this.children[i].domAtPos(off);
    }
    coordsAt(pos, side) {
      for (let off = this.length, i = this.children.length - 1; ; i--) {
        let child = this.children[i], start = off - child.breakAfter - child.length;
        if (pos > start || pos == start && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter && (!i || side == 2 || this.children[i - 1].breakAfter || this.children[i - 1].type == BlockType.WidgetBefore && side > -2))
          return child.coordsAt(pos - start, side);
        off = start;
      }
    }
    measureVisibleLineHeights(viewport) {
      let result = [], { from: from3, to } = viewport;
      let contentWidth = this.view.contentDOM.clientWidth;
      let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
      let widest = -1, ltr = this.view.textDirection == Direction.LTR;
      for (let pos = 0, i = 0; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (end > to)
          break;
        if (pos >= from3) {
          let childRect = child.dom.getBoundingClientRect();
          result.push(childRect.height);
          if (isWider) {
            let last2 = child.dom.lastChild;
            let rects = last2 ? clientRectsFor(last2) : [];
            if (rects.length) {
              let rect = rects[rects.length - 1];
              let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
              if (width > widest) {
                widest = width;
                this.minWidth = contentWidth;
                this.minWidthFrom = pos;
                this.minWidthTo = end;
              }
            }
          }
        }
        pos = end + child.breakAfter;
      }
      return result;
    }
    textDirectionAt(pos) {
      let { i } = this.childPos(pos, 1);
      return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
    }
    measureTextSize() {
      for (let child of this.children) {
        if (child instanceof LineView) {
          let measure = child.measureTextSize();
          if (measure)
            return measure;
        }
      }
      let dummy = document.createElement("div"), lineHeight, charWidth;
      dummy.className = "cm-line";
      dummy.style.width = "99999px";
      dummy.textContent = "abc def ghi jkl mno pqr stu";
      this.view.observer.ignore(() => {
        this.dom.appendChild(dummy);
        let rect = clientRectsFor(dummy.firstChild)[0];
        lineHeight = dummy.getBoundingClientRect().height;
        charWidth = rect ? rect.width / 27 : 7;
        dummy.remove();
      });
      return { lineHeight, charWidth };
    }
    childCursor(pos = this.length) {
      let i = this.children.length;
      if (i)
        pos -= this.children[--i].length;
      return new ChildCursor(this.children, pos, i);
    }
    computeBlockGapDeco() {
      let deco = [], vs = this.view.viewState;
      for (let pos = 0, i = 0; ; i++) {
        let next = i == vs.viewports.length ? null : vs.viewports[i];
        let end = next ? next.from - 1 : this.length;
        if (end > pos) {
          let height = vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top;
          deco.push(Decoration.replace({
            widget: new BlockGapWidget(height),
            block: true,
            inclusive: true,
            isBlockGap: true
          }).range(pos, end));
        }
        if (!next)
          break;
        pos = next.to + 1;
      }
      return Decoration.set(deco);
    }
    updateDeco() {
      let allDeco = this.view.state.facet(decorations).map((d, i) => {
        let dynamic = this.dynamicDecorationMap[i] = typeof d == "function";
        return dynamic ? d(this.view) : d;
      });
      for (let i = allDeco.length; i < allDeco.length + 3; i++)
        this.dynamicDecorationMap[i] = false;
      return this.decorations = [
        ...allDeco,
        this.compositionDeco,
        this.computeBlockGapDeco(),
        this.view.viewState.lineGapDeco
      ];
    }
    scrollIntoView(target) {
      let { range } = target;
      let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
      if (!rect)
        return;
      if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
        rect = {
          left: Math.min(rect.left, other.left),
          top: Math.min(rect.top, other.top),
          right: Math.max(rect.right, other.right),
          bottom: Math.max(rect.bottom, other.bottom)
        };
      let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;
      for (let margins of this.view.state.facet(scrollMargins).map((f) => f(this.view)))
        if (margins) {
          let { left, right, top: top2, bottom } = margins;
          if (left != null)
            mLeft = Math.max(mLeft, left);
          if (right != null)
            mRight = Math.max(mRight, right);
          if (top2 != null)
            mTop = Math.max(mTop, top2);
          if (bottom != null)
            mBottom = Math.max(mBottom, bottom);
        }
      let targetRect = {
        left: rect.left - mLeft,
        top: rect.top - mTop,
        right: rect.right + mRight,
        bottom: rect.bottom + mBottom
      };
      scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);
    }
  };
  function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
  }
  var BlockGapWidget = class extends WidgetType {
    constructor(height) {
      super();
      this.height = height;
    }
    toDOM() {
      let elt2 = document.createElement("div");
      this.updateDOM(elt2);
      return elt2;
    }
    eq(other) {
      return other.height == this.height;
    }
    updateDOM(elt2) {
      elt2.style.height = this.height + "px";
      return true;
    }
    get estimatedHeight() {
      return this.height;
    }
  };
  function compositionSurroundingNode(view2) {
    let sel = view2.observer.selectionRange;
    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
    if (!textNode)
      return null;
    let cView = view2.docView.nearest(textNode);
    if (!cView)
      return null;
    if (cView instanceof LineView) {
      let topNode = textNode;
      while (topNode.parentNode != cView.dom)
        topNode = topNode.parentNode;
      let prev = topNode.previousSibling;
      while (prev && !ContentView.get(prev))
        prev = prev.previousSibling;
      let pos = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;
      return { from: pos, to: pos, node: topNode, text: textNode };
    } else {
      for (; ; ) {
        let { parent } = cView;
        if (!parent)
          return null;
        if (parent instanceof LineView)
          break;
        cView = parent;
      }
      let from3 = cView.posAtStart;
      return { from: from3, to: from3 + cView.length, node: cView.dom, text: textNode };
    }
  }
  function computeCompositionDeco(view2, changes) {
    let surrounding = compositionSurroundingNode(view2);
    if (!surrounding)
      return Decoration.none;
    let { from: from3, to, node, text: textNode } = surrounding;
    let newFrom = changes.mapPos(from3, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));
    let { state } = view2, text3 = node.nodeType == 3 ? node.nodeValue : new DOMReader([], state).readRange(node.firstChild, null).text;
    if (newTo - newFrom < text3.length) {
      if (state.doc.sliceString(newFrom, Math.min(state.doc.length, newFrom + text3.length), LineBreakPlaceholder) == text3)
        newTo = newFrom + text3.length;
      else if (state.doc.sliceString(Math.max(0, newTo - text3.length), newTo, LineBreakPlaceholder) == text3)
        newFrom = newTo - text3.length;
      else
        return Decoration.none;
    } else if (state.doc.sliceString(newFrom, newTo, LineBreakPlaceholder) != text3) {
      return Decoration.none;
    }
    let topView = ContentView.get(node);
    if (topView instanceof CompositionView)
      topView = topView.widget.topView;
    else if (topView)
      topView.parent = null;
    return Decoration.set(Decoration.replace({ widget: new CompositionWidget(node, textNode, topView), inclusive: true }).range(newFrom, newTo));
  }
  var CompositionWidget = class extends WidgetType {
    constructor(top2, text3, topView) {
      super();
      this.top = top2;
      this.text = text3;
      this.topView = topView;
    }
    eq(other) {
      return this.top == other.top && this.text == other.text;
    }
    toDOM() {
      return this.top;
    }
    ignoreEvent() {
      return false;
    }
    get customView() {
      return CompositionView;
    }
  };
  function nearbyTextNode(node, offset, side) {
    for (; ; ) {
      if (node.nodeType == 3)
        return node;
      if (node.nodeType == 1 && offset > 0 && side <= 0) {
        node = node.childNodes[offset - 1];
        offset = maxOffset(node);
      } else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
        node = node.childNodes[offset];
        offset = 0;
      } else {
        return null;
      }
    }
  }
  function nextToUneditable(node, offset) {
    if (node.nodeType != 1)
      return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
  }
  var DecorationComparator$1 = class {
    constructor() {
      this.changes = [];
    }
    compareRange(from3, to) {
      addRange(from3, to, this.changes);
    }
    comparePoint(from3, to) {
      addRange(from3, to, this.changes);
    }
  };
  function findChangedDeco(a2, b, diff) {
    let comp = new DecorationComparator$1();
    RangeSet.compare(a2, b, diff, comp);
    return comp.changes;
  }
  function inUneditable(node, inside2) {
    for (let cur2 = node; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
      if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
        return true;
      }
    }
    return false;
  }
  function groupAt(state, pos, bias = 1) {
    let categorize = state.charCategorizer(pos);
    let line = state.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0)
      return EditorSelection.cursor(pos);
    if (linePos == 0)
      bias = 1;
    else if (linePos == line.length)
      bias = -1;
    let from3 = linePos, to = linePos;
    if (bias < 0)
      from3 = findClusterBreak(line.text, linePos, false);
    else
      to = findClusterBreak(line.text, linePos);
    let cat = categorize(line.text.slice(from3, to));
    while (from3 > 0) {
      let prev = findClusterBreak(line.text, from3, false);
      if (categorize(line.text.slice(prev, from3)) != cat)
        break;
      from3 = prev;
    }
    while (to < line.length) {
      let next = findClusterBreak(line.text, to);
      if (categorize(line.text.slice(to, next)) != cat)
        break;
      to = next;
    }
    return EditorSelection.range(from3 + line.from, to + line.from);
  }
  function getdx(x3, rect) {
    return rect.left > x3 ? rect.left - x3 : Math.max(0, x3 - rect.right);
  }
  function getdy(y3, rect) {
    return rect.top > y3 ? rect.top - y3 : Math.max(0, y3 - rect.bottom);
  }
  function yOverlap(a2, b) {
    return a2.top < b.bottom - 1 && a2.bottom > b.top + 1;
  }
  function upTop(rect, top2) {
    return top2 < rect.top ? { top: top2, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
  }
  function upBot(rect, bottom) {
    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
  }
  function domPosAtCoords(parent, x3, y3) {
    let closest, closestRect, closestX, closestY, closestOverlap = false;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
      let rects = clientRectsFor(child);
      for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        if (closestRect && yOverlap(closestRect, rect))
          rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
        let dx = getdx(x3, rect), dy = getdy(y3, rect);
        if (dx == 0 && dy == 0)
          return child.nodeType == 3 ? domPosInText(child, x3, y3) : domPosAtCoords(child, x3, y3);
        if (!closest || closestY > dy || closestY == dy && closestX > dx) {
          closest = child;
          closestRect = rect;
          closestX = dx;
          closestY = dy;
          closestOverlap = !dx || (dx > 0 ? i < rects.length - 1 : i > 0);
        }
        if (dx == 0) {
          if (y3 > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
            above = child;
            aboveRect = rect;
          } else if (y3 < rect.top && (!belowRect || belowRect.top > rect.top)) {
            below = child;
            belowRect = rect;
          }
        } else if (aboveRect && yOverlap(aboveRect, rect)) {
          aboveRect = upBot(aboveRect, rect.bottom);
        } else if (belowRect && yOverlap(belowRect, rect)) {
          belowRect = upTop(belowRect, rect.top);
        }
      }
    }
    if (aboveRect && aboveRect.bottom >= y3) {
      closest = above;
      closestRect = aboveRect;
    } else if (belowRect && belowRect.top <= y3) {
      closest = below;
      closestRect = belowRect;
    }
    if (!closest)
      return { node: parent, offset: 0 };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x3));
    if (closest.nodeType == 3)
      return domPosInText(closest, clipX, y3);
    if (closestOverlap && closest.contentEditable != "false")
      return domPosAtCoords(closest, clipX, y3);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x3 >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return { node: parent, offset };
  }
  function domPosInText(node, x3, y3) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i = 0; i < len; i++) {
      let rects = textRange(node, i, i + 1).getClientRects();
      for (let j = 0; j < rects.length; j++) {
        let rect = rects[j];
        if (rect.top == rect.bottom)
          continue;
        if (!generalSide)
          generalSide = x3 - rect.left;
        let dy = (rect.top > y3 ? rect.top - y3 : y3 - rect.bottom) - 1;
        if (rect.left - 1 <= x3 && rect.right + 1 >= x3 && dy < closestDY) {
          let right = x3 >= (rect.left + rect.right) / 2, after = right;
          if (browser.chrome || browser.gecko) {
            let rectBefore = textRange(node, i).getBoundingClientRect();
            if (rectBefore.left == rect.right)
              after = !right;
          }
          if (dy <= 0)
            return { node, offset: i + (after ? 1 : 0) };
          closestOffset = i + (after ? 1 : 0);
          closestDY = dy;
        }
      }
    }
    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
  }
  function posAtCoords(view2, { x: x3, y: y3 }, precise, bias = -1) {
    var _a2;
    let content2 = view2.contentDOM.getBoundingClientRect(), docTop = content2.top + view2.viewState.paddingTop;
    let block, { docHeight } = view2.viewState;
    let yOffset = y3 - docTop;
    if (yOffset < 0)
      return 0;
    if (yOffset > docHeight)
      return view2.state.doc.length;
    for (let halfLine = view2.defaultLineHeight / 2, bounced = false; ; ) {
      block = view2.elementAtHeight(yOffset);
      if (block.type == BlockType.Text)
        break;
      for (; ; ) {
        yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
        if (yOffset >= 0 && yOffset <= docHeight)
          break;
        if (bounced)
          return precise ? null : 0;
        bounced = true;
        bias = -bias;
      }
    }
    y3 = docTop + yOffset;
    let lineStart = block.from;
    if (lineStart < view2.viewport.from)
      return view2.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view2, content2, block, x3, y3);
    if (lineStart > view2.viewport.to)
      return view2.viewport.to == view2.state.doc.length ? view2.state.doc.length : precise ? null : posAtCoordsImprecise(view2, content2, block, x3, y3);
    let doc3 = view2.dom.ownerDocument;
    let root = view2.root.elementFromPoint ? view2.root : doc3;
    let element2 = root.elementFromPoint(x3, y3);
    if (element2 && !view2.contentDOM.contains(element2))
      element2 = null;
    if (!element2) {
      x3 = Math.max(content2.left + 1, Math.min(content2.right - 1, x3));
      element2 = root.elementFromPoint(x3, y3);
      if (element2 && !view2.contentDOM.contains(element2))
        element2 = null;
    }
    let node, offset = -1;
    if (element2 && ((_a2 = view2.docView.nearest(element2)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
      if (doc3.caretPositionFromPoint) {
        let pos = doc3.caretPositionFromPoint(x3, y3);
        if (pos)
          ({ offsetNode: node, offset } = pos);
      } else if (doc3.caretRangeFromPoint) {
        let range = doc3.caretRangeFromPoint(x3, y3);
        if (range) {
          ({ startContainer: node, startOffset: offset } = range);
          if (!view2.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x3) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x3))
            node = void 0;
        }
      }
    }
    if (!node || !view2.docView.dom.contains(node)) {
      let line = LineView.find(view2.docView, lineStart);
      if (!line)
        return yOffset > block.top + block.height / 2 ? block.to : block.from;
      ({ node, offset } = domPosAtCoords(line.dom, x3, y3));
    }
    return view2.docView.posFromDOM(node, offset);
  }
  function posAtCoordsImprecise(view2, contentRect, block, x3, y3) {
    let into = Math.round((x3 - contentRect.left) * view2.defaultCharacterWidth);
    if (view2.lineWrapping && block.height > view2.defaultLineHeight * 1.5) {
      let line = Math.floor((y3 - block.top) / view2.defaultLineHeight);
      into += line * view2.viewState.heightOracle.lineLength;
    }
    let content2 = view2.state.sliceDoc(block.from, block.to);
    return block.from + findColumn(content2, into, view2.state.tabSize);
  }
  function isSuspiciousSafariCaretResult(node, offset, x3) {
    let len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
      return false;
    for (let next = node.nextSibling; next; next = next.nextSibling)
      if (next.nodeType != 1 || next.nodeName != "BR")
        return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x3;
  }
  function isSuspiciousChromeCaretResult(node, offset, x3) {
    if (offset != 0)
      return false;
    for (let cur2 = node; ; ) {
      let parent = cur2.parentNode;
      if (!parent || parent.nodeType != 1 || parent.firstChild != cur2)
        return false;
      if (parent.classList.contains("cm-line"))
        break;
      cur2 = parent;
    }
    let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
    return x3 - rect.left > 5;
  }
  function moveToLineBoundary(view2, start, forward, includeWrap) {
    let line = view2.state.doc.lineAt(start.head);
    let coords = !includeWrap || !view2.lineWrapping ? null : view2.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
    if (coords) {
      let editorRect = view2.dom.getBoundingClientRect();
      let direction = view2.textDirectionAt(line.from);
      let pos = view2.posAtCoords({
        x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
        y: (coords.top + coords.bottom) / 2
      });
      if (pos != null)
        return EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    let lineView = LineView.find(view2.docView, start.head);
    let end = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line.to : line.from;
    return EditorSelection.cursor(end, forward ? -1 : 1);
  }
  function moveByChar(view2, start, forward, by) {
    let line = view2.state.doc.lineAt(start.head), spans = view2.bidiSpans(line);
    let direction = view2.textDirectionAt(line.from);
    for (let cur2 = start, check = null; ; ) {
      let next = moveVisually(line, spans, direction, cur2, forward), char = movedOver;
      if (!next) {
        if (line.number == (forward ? view2.state.doc.lines : 1))
          return cur2;
        char = "\n";
        line = view2.state.doc.line(line.number + (forward ? 1 : -1));
        spans = view2.bidiSpans(line);
        next = EditorSelection.cursor(forward ? line.from : line.to);
      }
      if (!check) {
        if (!by)
          return next;
        check = by(char);
      } else if (!check(char)) {
        return cur2;
      }
      cur2 = next;
    }
  }
  function byGroup(view2, pos, start) {
    let categorize = view2.state.charCategorizer(pos);
    let cat = categorize(start);
    return (next) => {
      let nextCat = categorize(next);
      if (cat == CharCategory.Space)
        cat = nextCat;
      return cat == nextCat;
    };
  }
  function moveVertically(view2, start, forward, distance) {
    let startPos = start.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view2.state.doc.length : 0))
      return EditorSelection.cursor(startPos, start.assoc);
    let goal = start.goalColumn, startY;
    let rect = view2.contentDOM.getBoundingClientRect();
    let startCoords = view2.coordsAtPos(startPos), docTop = view2.documentTop;
    if (startCoords) {
      if (goal == null)
        goal = startCoords.left - rect.left;
      startY = dir < 0 ? startCoords.top : startCoords.bottom;
    } else {
      let line = view2.viewState.lineBlockAt(startPos);
      if (goal == null)
        goal = Math.min(rect.right - rect.left, view2.defaultCharacterWidth * (startPos - line.from));
      startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist = distance !== null && distance !== void 0 ? distance : view2.defaultLineHeight >> 1;
    for (let extra = 0; ; extra += 10) {
      let curY = startY + (dist + extra) * dir;
      let pos = posAtCoords(view2, { x: resolvedGoal, y: curY }, false, dir);
      if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos))
        return EditorSelection.cursor(pos, start.assoc, void 0, goal);
    }
  }
  function skipAtoms(view2, oldPos, pos) {
    let atoms = view2.state.facet(atomicRanges).map((f) => f(view2));
    for (; ; ) {
      let moved = false;
      for (let set3 of atoms) {
        set3.between(pos.from - 1, pos.from + 1, (from3, to, value) => {
          if (pos.from > from3 && pos.from < to) {
            pos = oldPos.head > pos.from ? EditorSelection.cursor(from3, 1) : EditorSelection.cursor(to, -1);
            moved = true;
          }
        });
      }
      if (!moved)
        return pos;
    }
  }
  var InputState = class {
    constructor(view2) {
      this.lastKeyCode = 0;
      this.lastKeyTime = 0;
      this.lastTouchTime = 0;
      this.lastFocusTime = 0;
      this.lastScrollTop = 0;
      this.lastScrollLeft = 0;
      this.chromeScrollHack = -1;
      this.pendingIOSKey = void 0;
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastEscPress = 0;
      this.lastContextMenu = 0;
      this.scrollHandlers = [];
      this.registeredEvents = [];
      this.customHandlers = [];
      this.composing = -1;
      this.compositionFirstChange = null;
      this.compositionEndedAt = 0;
      this.mouseSelection = null;
      for (let type in handlers) {
        let handler = handlers[type];
        view2.contentDOM.addEventListener(type, (event) => {
          if (!eventBelongsToEditor(view2, event) || this.ignoreDuringComposition(event))
            return;
          if (type == "keydown" && this.keydown(view2, event))
            return;
          if (this.mustFlushObserver(event))
            view2.observer.forceFlush();
          if (this.runCustomHandlers(type, view2, event))
            event.preventDefault();
          else
            handler(view2, event);
        }, handlerOptions[type]);
        this.registeredEvents.push(type);
      }
      if (browser.chrome && browser.chrome_version == 102) {
        view2.scrollDOM.addEventListener("wheel", () => {
          if (this.chromeScrollHack < 0)
            view2.contentDOM.style.pointerEvents = "none";
          else
            window.clearTimeout(this.chromeScrollHack);
          this.chromeScrollHack = setTimeout(() => {
            this.chromeScrollHack = -1;
            view2.contentDOM.style.pointerEvents = "";
          }, 100);
        }, { passive: true });
      }
      this.notifiedFocused = view2.hasFocus;
      if (browser.safari)
        view2.contentDOM.addEventListener("input", () => null);
    }
    setSelectionOrigin(origin) {
      this.lastSelectionOrigin = origin;
      this.lastSelectionTime = Date.now();
    }
    ensureHandlers(view2, plugins) {
      var _a2;
      let handlers2;
      this.customHandlers = [];
      for (let plugin of plugins)
        if (handlers2 = (_a2 = plugin.update(view2).spec) === null || _a2 === void 0 ? void 0 : _a2.domEventHandlers) {
          this.customHandlers.push({ plugin: plugin.value, handlers: handlers2 });
          for (let type in handlers2)
            if (this.registeredEvents.indexOf(type) < 0 && type != "scroll") {
              this.registeredEvents.push(type);
              view2.contentDOM.addEventListener(type, (event) => {
                if (!eventBelongsToEditor(view2, event))
                  return;
                if (this.runCustomHandlers(type, view2, event))
                  event.preventDefault();
              });
            }
        }
    }
    runCustomHandlers(type, view2, event) {
      for (let set3 of this.customHandlers) {
        let handler = set3.handlers[type];
        if (handler) {
          try {
            if (handler.call(set3.plugin, event, view2) || event.defaultPrevented)
              return true;
          } catch (e) {
            logException(view2.state, e);
          }
        }
      }
      return false;
    }
    runScrollHandlers(view2, event) {
      this.lastScrollTop = view2.scrollDOM.scrollTop;
      this.lastScrollLeft = view2.scrollDOM.scrollLeft;
      for (let set3 of this.customHandlers) {
        let handler = set3.handlers.scroll;
        if (handler) {
          try {
            handler.call(set3.plugin, event, view2);
          } catch (e) {
            logException(view2.state, e);
          }
        }
      }
    }
    keydown(view2, event) {
      this.lastKeyCode = event.keyCode;
      this.lastKeyTime = Date.now();
      if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
        return true;
      if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
        view2.observer.delayAndroidKey(event.key, event.keyCode);
        return true;
      }
      let pending;
      if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
        this.pendingIOSKey = pending || event;
        setTimeout(() => this.flushIOSKey(view2), 250);
        return true;
      }
      return false;
    }
    flushIOSKey(view2) {
      let key = this.pendingIOSKey;
      if (!key)
        return false;
      this.pendingIOSKey = void 0;
      return dispatchKey(view2.contentDOM, key.key, key.keyCode);
    }
    ignoreDuringComposition(event) {
      if (!/^key/.test(event.type))
        return false;
      if (this.composing > 0)
        return true;
      if (browser.safari && !browser.ios && Date.now() - this.compositionEndedAt < 100) {
        this.compositionEndedAt = 0;
        return true;
      }
      return false;
    }
    mustFlushObserver(event) {
      return event.type == "keydown" && event.keyCode != 229;
    }
    startMouseSelection(mouseSelection) {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
      this.mouseSelection = mouseSelection;
    }
    update(update) {
      if (this.mouseSelection)
        this.mouseSelection.update(update);
      if (update.transactions.length)
        this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
    }
  };
  var PendingKeys = [
    { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
    { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
    { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
  ];
  var EmacsyPendingKeys = "dthko";
  var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
  var MouseSelection = class {
    constructor(view2, startEvent, style, mustSelect) {
      this.view = view2;
      this.style = style;
      this.mustSelect = mustSelect;
      this.lastEvent = startEvent;
      let doc3 = view2.contentDOM.ownerDocument;
      doc3.addEventListener("mousemove", this.move = this.move.bind(this));
      doc3.addEventListener("mouseup", this.up = this.up.bind(this));
      this.extend = startEvent.shiftKey;
      this.multiple = view2.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view2, startEvent);
      this.dragMove = dragMovesSelection(view2, startEvent);
      this.dragging = isInPrimarySelection(view2, startEvent) && getClickType(startEvent) == 1 ? null : false;
      if (this.dragging === false) {
        startEvent.preventDefault();
        this.select(startEvent);
      }
    }
    move(event) {
      if (event.buttons == 0)
        return this.destroy();
      if (this.dragging !== false)
        return;
      this.select(this.lastEvent = event);
    }
    up(event) {
      if (this.dragging == null)
        this.select(this.lastEvent);
      if (!this.dragging)
        event.preventDefault();
      this.destroy();
    }
    destroy() {
      let doc3 = this.view.contentDOM.ownerDocument;
      doc3.removeEventListener("mousemove", this.move);
      doc3.removeEventListener("mouseup", this.up);
      this.view.inputState.mouseSelection = null;
    }
    select(event) {
      let selection = this.style.get(event, this.extend, this.multiple);
      if (this.mustSelect || !selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc)
        this.view.dispatch({
          selection,
          userEvent: "select.pointer",
          scrollIntoView: true
        });
      this.mustSelect = false;
    }
    update(update) {
      if (update.docChanged && this.dragging)
        this.dragging = this.dragging.map(update.changes);
      if (this.style.update(update))
        setTimeout(() => this.select(this.lastEvent), 20);
    }
  };
  function addsSelectionRange(view2, event) {
    let facet = view2.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
  }
  function dragMovesSelection(view2, event) {
    let facet = view2.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
  }
  function isInPrimarySelection(view2, event) {
    let { main } = view2.state.selection;
    if (main.empty)
      return false;
    let sel = getSelection(view2.root);
    if (!sel || sel.rangeCount == 0)
      return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
        return true;
    }
    return false;
  }
  function eventBelongsToEditor(view2, event) {
    if (!event.bubbles)
      return true;
    if (event.defaultPrevented)
      return false;
    for (let node = event.target, cView; node != view2.contentDOM; node = node.parentNode)
      if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event))
        return false;
    return true;
  }
  var handlers = /* @__PURE__ */ Object.create(null);
  var handlerOptions = /* @__PURE__ */ Object.create(null);
  var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
  function capturePaste(view2) {
    let parent = view2.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
      view2.focus();
      target.remove();
      doPaste(view2, target.value);
    }, 50);
  }
  function doPaste(view2, input) {
    let { state } = view2, changes, i = 1, text3 = state.toText(input);
    let byLine = text3.lines == state.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text3.toString();
    if (linewise) {
      let lastLine = -1;
      changes = state.changeByRange((range) => {
        let line = state.doc.lineAt(range.from);
        if (line.from == lastLine)
          return { range };
        lastLine = line.from;
        let insert2 = state.toText((byLine ? text3.line(i++).text : input) + state.lineBreak);
        return {
          changes: { from: line.from, insert: insert2 },
          range: EditorSelection.cursor(range.from + insert2.length)
        };
      });
    } else if (byLine) {
      changes = state.changeByRange((range) => {
        let line = text3.line(i++);
        return {
          changes: { from: range.from, to: range.to, insert: line.text },
          range: EditorSelection.cursor(range.from + line.length)
        };
      });
    } else {
      changes = state.replaceSelection(text3);
    }
    view2.dispatch(changes, {
      userEvent: "input.paste",
      scrollIntoView: true
    });
  }
  handlers.keydown = (view2, event) => {
    view2.inputState.setSelectionOrigin("select");
    if (event.keyCode == 27)
      view2.inputState.lastEscPress = Date.now();
    else if (modifierCodes.indexOf(event.keyCode) < 0)
      view2.inputState.lastEscPress = 0;
  };
  handlers.touchstart = (view2, e) => {
    view2.inputState.lastTouchTime = Date.now();
    view2.inputState.setSelectionOrigin("select.pointer");
  };
  handlers.touchmove = (view2) => {
    view2.inputState.setSelectionOrigin("select.pointer");
  };
  handlerOptions.touchstart = handlerOptions.touchmove = { passive: true };
  handlers.mousedown = (view2, event) => {
    view2.observer.flush();
    if (view2.inputState.lastTouchTime > Date.now() - 2e3)
      return;
    let style = null;
    for (let makeStyle of view2.state.facet(mouseSelectionStyle)) {
      style = makeStyle(view2, event);
      if (style)
        break;
    }
    if (!style && event.button == 0)
      style = basicMouseSelection(view2, event);
    if (style) {
      let mustFocus = view2.root.activeElement != view2.contentDOM;
      if (mustFocus)
        view2.observer.ignore(() => focusPreventScroll(view2.contentDOM));
      view2.inputState.startMouseSelection(new MouseSelection(view2, event, style, mustFocus));
    }
  };
  function rangeForClick(view2, pos, bias, type) {
    if (type == 1) {
      return EditorSelection.cursor(pos, bias);
    } else if (type == 2) {
      return groupAt(view2.state, pos, bias);
    } else {
      let visual = LineView.find(view2.docView, pos), line = view2.state.doc.lineAt(visual ? visual.posAtEnd : pos);
      let from3 = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
      if (to < view2.state.doc.length && to == line.to)
        to++;
      return EditorSelection.range(from3, to);
    }
  }
  var insideY = (y3, rect) => y3 >= rect.top && y3 <= rect.bottom;
  var inside = (x3, y3, rect) => insideY(y3, rect) && x3 >= rect.left && x3 <= rect.right;
  function findPositionSide(view2, pos, x3, y3) {
    let line = LineView.find(view2.docView, pos);
    if (!line)
      return 1;
    let off = pos - line.posAtStart;
    if (off == 0)
      return 1;
    if (off == line.length)
      return -1;
    let before = line.coordsAt(off, -1);
    if (before && inside(x3, y3, before))
      return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x3, y3, after))
      return 1;
    return before && insideY(y3, before) ? -1 : 1;
  }
  function queryPos(view2, event) {
    let pos = view2.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    return { pos, bias: findPositionSide(view2, pos, event.clientX, event.clientY) };
  }
  var BadMouseDetail = browser.ie && browser.ie_version <= 11;
  var lastMouseDown = null;
  var lastMouseDownCount = 0;
  var lastMouseDownTime = 0;
  function getClickType(event) {
    if (!BadMouseDetail)
      return event.detail;
    let last2 = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last2 || lastTime > Date.now() - 400 && Math.abs(last2.clientX - event.clientX) < 2 && Math.abs(last2.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
  }
  function basicMouseSelection(view2, event) {
    let start = queryPos(view2, event), type = getClickType(event);
    let startSel = view2.state.selection;
    let last2 = start, lastEvent = event;
    return {
      update(update) {
        if (update.docChanged) {
          start.pos = update.changes.mapPos(start.pos);
          startSel = startSel.map(update.changes);
          lastEvent = null;
        }
      },
      get(event2, extend2, multiple) {
        let cur2;
        if (lastEvent && event2.clientX == lastEvent.clientX && event2.clientY == lastEvent.clientY)
          cur2 = last2;
        else {
          cur2 = last2 = queryPos(view2, event2);
          lastEvent = event2;
        }
        let range = rangeForClick(view2, cur2.pos, cur2.bias, type);
        if (start.pos != cur2.pos && !extend2) {
          let startRange = rangeForClick(view2, start.pos, start.bias, type);
          let from3 = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
          range = from3 < range.from ? EditorSelection.range(from3, to) : EditorSelection.range(to, from3);
        }
        if (extend2)
          return startSel.replaceRange(startSel.main.extend(range.from, range.to));
        else if (multiple && startSel.ranges.length > 1 && startSel.ranges.some((r) => r.eq(range)))
          return removeRange(startSel, range);
        else if (multiple)
          return startSel.addRange(range);
        else
          return EditorSelection.create([range]);
      }
    };
  }
  function removeRange(sel, range) {
    for (let i = 0; ; i++) {
      if (sel.ranges[i].eq(range))
        return EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
    }
  }
  handlers.dragstart = (view2, event) => {
    let { selection: { main } } = view2.state;
    let { mouseSelection } = view2.inputState;
    if (mouseSelection)
      mouseSelection.dragging = main;
    if (event.dataTransfer) {
      event.dataTransfer.setData("Text", view2.state.sliceDoc(main.from, main.to));
      event.dataTransfer.effectAllowed = "copyMove";
    }
  };
  function dropText(view2, event, text3, direct) {
    if (!text3)
      return;
    let dropPos = view2.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    event.preventDefault();
    let { mouseSelection } = view2.inputState;
    let del2 = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;
    let ins = { from: dropPos, insert: text3 };
    let changes = view2.state.changes(del2 ? [del2, ins] : ins);
    view2.focus();
    view2.dispatch({
      changes,
      selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
      userEvent: del2 ? "move.drop" : "input.drop"
    });
  }
  handlers.drop = (view2, event) => {
    if (!event.dataTransfer)
      return;
    if (view2.state.readOnly)
      return event.preventDefault();
    let files = event.dataTransfer.files;
    if (files && files.length) {
      event.preventDefault();
      let text3 = Array(files.length), read = 0;
      let finishFile = () => {
        if (++read == files.length)
          dropText(view2, event, text3.filter((s) => s != null).join(view2.state.lineBreak), false);
      };
      for (let i = 0; i < files.length; i++) {
        let reader = new FileReader();
        reader.onerror = finishFile;
        reader.onload = () => {
          if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
            text3[i] = reader.result;
          finishFile();
        };
        reader.readAsText(files[i]);
      }
    } else {
      dropText(view2, event, event.dataTransfer.getData("Text"), true);
    }
  };
  handlers.paste = (view2, event) => {
    if (view2.state.readOnly)
      return event.preventDefault();
    view2.observer.flush();
    let data2 = brokenClipboardAPI ? null : event.clipboardData;
    if (data2) {
      doPaste(view2, data2.getData("text/plain"));
      event.preventDefault();
    } else {
      capturePaste(view2);
    }
  };
  function captureCopy(view2, text3) {
    let parent = view2.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text3;
    target.focus();
    target.selectionEnd = text3.length;
    target.selectionStart = 0;
    setTimeout(() => {
      target.remove();
      view2.focus();
    }, 50);
  }
  function copiedRange(state) {
    let content2 = [], ranges = [], linewise = false;
    for (let range of state.selection.ranges)
      if (!range.empty) {
        content2.push(state.sliceDoc(range.from, range.to));
        ranges.push(range);
      }
    if (!content2.length) {
      let upto = -1;
      for (let { from: from3 } of state.selection.ranges) {
        let line = state.doc.lineAt(from3);
        if (line.number > upto) {
          content2.push(line.text);
          ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
        }
        upto = line.number;
      }
      linewise = true;
    }
    return { text: content2.join(state.lineBreak), ranges, linewise };
  }
  var lastLinewiseCopy = null;
  handlers.copy = handlers.cut = (view2, event) => {
    let { text: text3, ranges, linewise } = copiedRange(view2.state);
    if (!text3 && !linewise)
      return;
    lastLinewiseCopy = linewise ? text3 : null;
    let data2 = brokenClipboardAPI ? null : event.clipboardData;
    if (data2) {
      event.preventDefault();
      data2.clearData();
      data2.setData("text/plain", text3);
    } else {
      captureCopy(view2, text3);
    }
    if (event.type == "cut" && !view2.state.readOnly)
      view2.dispatch({
        changes: ranges,
        scrollIntoView: true,
        userEvent: "delete.cut"
      });
  };
  function updateForFocusChange(view2) {
    setTimeout(() => {
      if (view2.hasFocus != view2.inputState.notifiedFocused)
        view2.update([]);
    }, 10);
  }
  handlers.focus = (view2) => {
    view2.inputState.lastFocusTime = Date.now();
    if (!view2.scrollDOM.scrollTop && (view2.inputState.lastScrollTop || view2.inputState.lastScrollLeft)) {
      view2.scrollDOM.scrollTop = view2.inputState.lastScrollTop;
      view2.scrollDOM.scrollLeft = view2.inputState.lastScrollLeft;
    }
    updateForFocusChange(view2);
  };
  handlers.blur = (view2) => {
    view2.observer.clearSelectionRange();
    updateForFocusChange(view2);
  };
  handlers.compositionstart = handlers.compositionupdate = (view2) => {
    if (view2.inputState.compositionFirstChange == null)
      view2.inputState.compositionFirstChange = true;
    if (view2.inputState.composing < 0) {
      view2.inputState.composing = 0;
    }
  };
  handlers.compositionend = (view2) => {
    view2.inputState.composing = -1;
    view2.inputState.compositionEndedAt = Date.now();
    view2.inputState.compositionFirstChange = null;
    if (browser.chrome && browser.android)
      view2.observer.flushSoon();
    setTimeout(() => {
      if (view2.inputState.composing < 0 && view2.docView.compositionDeco.size)
        view2.update([]);
    }, 50);
  };
  handlers.contextmenu = (view2) => {
    view2.inputState.lastContextMenu = Date.now();
  };
  handlers.beforeinput = (view2, event) => {
    var _a2;
    let pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
      view2.observer.delayAndroidKey(pending.key, pending.keyCode);
      if (pending.key == "Backspace" || pending.key == "Delete") {
        let startViewHeight = ((_a2 = window.visualViewport) === null || _a2 === void 0 ? void 0 : _a2.height) || 0;
        setTimeout(() => {
          var _a3;
          if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view2.hasFocus) {
            view2.contentDOM.blur();
            view2.focus();
          }
        }, 100);
      }
    }
  };
  var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
  var HeightOracle = class {
    constructor(lineWrapping) {
      this.lineWrapping = lineWrapping;
      this.doc = Text.empty;
      this.heightSamples = {};
      this.lineHeight = 14;
      this.charWidth = 7;
      this.lineLength = 30;
      this.heightChanged = false;
    }
    heightForGap(from3, to) {
      let lines = this.doc.lineAt(to).number - this.doc.lineAt(from3).number + 1;
      if (this.lineWrapping)
        lines += Math.ceil((to - from3 - lines * this.lineLength * 0.5) / this.lineLength);
      return this.lineHeight * lines;
    }
    heightForLine(length3) {
      if (!this.lineWrapping)
        return this.lineHeight;
      let lines = 1 + Math.max(0, Math.ceil((length3 - this.lineLength) / (this.lineLength - 5)));
      return lines * this.lineHeight;
    }
    setDoc(doc3) {
      this.doc = doc3;
      return this;
    }
    mustRefreshForWrapping(whiteSpace) {
      return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
      let newHeight = false;
      for (let i = 0; i < lineHeights.length; i++) {
        let h2 = lineHeights[i];
        if (h2 < 0) {
          i++;
        } else if (!this.heightSamples[Math.floor(h2 * 10)]) {
          newHeight = true;
          this.heightSamples[Math.floor(h2 * 10)] = true;
        }
      }
      return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, lineLength, knownHeights) {
      let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
      let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
      this.lineWrapping = lineWrapping;
      this.lineHeight = lineHeight;
      this.charWidth = charWidth;
      this.lineLength = lineLength;
      if (changed) {
        this.heightSamples = {};
        for (let i = 0; i < knownHeights.length; i++) {
          let h2 = knownHeights[i];
          if (h2 < 0)
            i++;
          else
            this.heightSamples[Math.floor(h2 * 10)] = true;
        }
      }
      return changed;
    }
  };
  var MeasuredHeights = class {
    constructor(from3, heights) {
      this.from = from3;
      this.heights = heights;
      this.index = 0;
    }
    get more() {
      return this.index < this.heights.length;
    }
  };
  var BlockInfo = class {
    constructor(from3, length3, top2, height, type) {
      this.from = from3;
      this.length = length3;
      this.top = top2;
      this.height = height;
      this.type = type;
    }
    get to() {
      return this.from + this.length;
    }
    get bottom() {
      return this.top + this.height;
    }
    join(other) {
      let detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);
      return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
    }
  };
  var QueryType = /* @__PURE__ */ function(QueryType3) {
    QueryType3[QueryType3["ByPos"] = 0] = "ByPos";
    QueryType3[QueryType3["ByHeight"] = 1] = "ByHeight";
    QueryType3[QueryType3["ByPosNoHeight"] = 2] = "ByPosNoHeight";
    return QueryType3;
  }(QueryType || (QueryType = {}));
  var Epsilon = 1e-3;
  var HeightMap = class {
    constructor(length3, height, flags = 2) {
      this.length = length3;
      this.height = height;
      this.flags = flags;
    }
    get outdated() {
      return (this.flags & 2) > 0;
    }
    set outdated(value) {
      this.flags = (value ? 2 : 0) | this.flags & ~2;
    }
    setHeight(oracle, height) {
      if (this.height != height) {
        if (Math.abs(this.height - height) > Epsilon)
          oracle.heightChanged = true;
        this.height = height;
      }
    }
    replace(_from, _to, nodes) {
      return HeightMap.of(nodes);
    }
    decomposeLeft(_to, result) {
      result.push(this);
    }
    decomposeRight(_from, result) {
      result.push(this);
    }
    applyChanges(decorations2, oldDoc, oracle, changes) {
      let me = this;
      for (let i = changes.length - 1; i >= 0; i--) {
        let { fromA, toA, fromB, toB } = changes[i];
        let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        toB += end.to - toA;
        toA = end.to;
        while (i > 0 && start.from <= changes[i - 1].toA) {
          fromA = changes[i - 1].fromA;
          fromB = changes[i - 1].fromB;
          i--;
          if (fromA < start.from)
            start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        }
        fromB += start.from - fromA;
        fromA = start.from;
        let nodes = NodeBuilder.build(oracle, decorations2, fromB, toB);
        me = me.replace(fromA, toA, nodes);
      }
      return me.updateHeight(oracle, 0);
    }
    static empty() {
      return new HeightMapText(0, 0);
    }
    static of(nodes) {
      if (nodes.length == 1)
        return nodes[0];
      let i = 0, j = nodes.length, before = 0, after = 0;
      for (; ; ) {
        if (i == j) {
          if (before > after * 2) {
            let split = nodes[i - 1];
            if (split.break)
              nodes.splice(--i, 1, split.left, null, split.right);
            else
              nodes.splice(--i, 1, split.left, split.right);
            j += 1 + split.break;
            before -= split.size;
          } else if (after > before * 2) {
            let split = nodes[j];
            if (split.break)
              nodes.splice(j, 1, split.left, null, split.right);
            else
              nodes.splice(j, 1, split.left, split.right);
            j += 2 + split.break;
            after -= split.size;
          } else {
            break;
          }
        } else if (before < after) {
          let next = nodes[i++];
          if (next)
            before += next.size;
        } else {
          let next = nodes[--j];
          if (next)
            after += next.size;
        }
      }
      let brk = 0;
      if (nodes[i - 1] == null) {
        brk = 1;
        i--;
      } else if (nodes[i] == null) {
        brk = 1;
        j++;
      }
      return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
    }
  };
  HeightMap.prototype.size = 1;
  var HeightMapBlock = class extends HeightMap {
    constructor(length3, height, type) {
      super(length3, height);
      this.type = type;
    }
    blockAt(_height, _doc, top2, offset) {
      return new BlockInfo(offset, this.length, top2, this.height, this.type);
    }
    lineAt(_value, _type, doc3, top2, offset) {
      return this.blockAt(0, doc3, top2, offset);
    }
    forEachLine(from3, to, doc3, top2, offset, f) {
      if (from3 <= offset + this.length && to >= offset)
        f(this.blockAt(0, doc3, top2, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(oracle, measured.heights[measured.index++]);
      this.outdated = false;
      return this;
    }
    toString() {
      return `block(${this.length})`;
    }
  };
  var HeightMapText = class extends HeightMapBlock {
    constructor(length3, height) {
      super(length3, height, BlockType.Text);
      this.collapsed = 0;
      this.widgetHeight = 0;
    }
    replace(_from, _to, nodes) {
      let node = nodes[0];
      if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
        if (node instanceof HeightMapGap)
          node = new HeightMapText(node.length, this.height);
        else
          node.height = this.height;
        if (!this.outdated)
          node.outdated = false;
        return node;
      } else {
        return HeightMap.of(nodes);
      }
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(oracle, measured.heights[measured.index++]);
      else if (force || this.outdated)
        this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
      this.outdated = false;
      return this;
    }
    toString() {
      return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
  };
  var HeightMapGap = class extends HeightMap {
    constructor(length3) {
      super(length3, 0);
    }
    lines(doc3, offset) {
      let firstLine = doc3.lineAt(offset).number, lastLine = doc3.lineAt(offset + this.length).number;
      return { firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1) };
    }
    blockAt(height, doc3, top2, offset) {
      let { firstLine, lastLine, lineHeight } = this.lines(doc3, offset);
      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / lineHeight)));
      let { from: from3, length: length3 } = doc3.line(firstLine + line);
      return new BlockInfo(from3, length3, top2 + lineHeight * line, lineHeight, BlockType.Text);
    }
    lineAt(value, type, doc3, top2, offset) {
      if (type == QueryType.ByHeight)
        return this.blockAt(value, doc3, top2, offset);
      if (type == QueryType.ByPosNoHeight) {
        let { from: from4, to } = doc3.lineAt(value);
        return new BlockInfo(from4, to - from4, 0, 0, BlockType.Text);
      }
      let { firstLine, lineHeight } = this.lines(doc3, offset);
      let { from: from3, length: length3, number: number2 } = doc3.lineAt(value);
      return new BlockInfo(from3, length3, top2 + lineHeight * (number2 - firstLine), lineHeight, BlockType.Text);
    }
    forEachLine(from3, to, doc3, top2, offset, f) {
      let { firstLine, lineHeight } = this.lines(doc3, offset);
      for (let pos = Math.max(from3, offset), end = Math.min(offset + this.length, to); pos <= end; ) {
        let line = doc3.lineAt(pos);
        if (pos == from3)
          top2 += lineHeight * (line.number - firstLine);
        f(new BlockInfo(line.from, line.length, top2, lineHeight, BlockType.Text));
        top2 += lineHeight;
        pos = line.to + 1;
      }
    }
    replace(from3, to, nodes) {
      let after = this.length - to;
      if (after > 0) {
        let last2 = nodes[nodes.length - 1];
        if (last2 instanceof HeightMapGap)
          nodes[nodes.length - 1] = new HeightMapGap(last2.length + after);
        else
          nodes.push(null, new HeightMapGap(after - 1));
      }
      if (from3 > 0) {
        let first = nodes[0];
        if (first instanceof HeightMapGap)
          nodes[0] = new HeightMapGap(from3 + first.length);
        else
          nodes.unshift(new HeightMapGap(from3 - 1), null);
      }
      return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
      result.push(new HeightMapGap(to - 1), null);
    }
    decomposeRight(from3, result) {
      result.push(null, new HeightMapGap(this.length - from3 - 1));
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      let end = offset + this.length;
      if (measured && measured.from <= offset + this.length && measured.more) {
        let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
        let wasChanged = oracle.heightChanged;
        if (measured.from > offset)
          nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
        while (pos <= end && measured.more) {
          let len = oracle.doc.lineAt(pos).length;
          if (nodes.length)
            nodes.push(null);
          let height = measured.heights[measured.index++];
          if (singleHeight == -1)
            singleHeight = height;
          else if (Math.abs(height - singleHeight) >= Epsilon)
            singleHeight = -2;
          let line = new HeightMapText(len, height);
          line.outdated = false;
          nodes.push(line);
          pos += len + 1;
        }
        if (pos <= end)
          nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
        let result = HeightMap.of(nodes);
        oracle.heightChanged = wasChanged || singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.lines(oracle.doc, offset).lineHeight) >= Epsilon;
        return result;
      } else if (force || this.outdated) {
        this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
        this.outdated = false;
      }
      return this;
    }
    toString() {
      return `gap(${this.length})`;
    }
  };
  var HeightMapBranch = class extends HeightMap {
    constructor(left, brk, right) {
      super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
      this.left = left;
      this.right = right;
      this.size = left.size + right.size;
    }
    get break() {
      return this.flags & 1;
    }
    blockAt(height, doc3, top2, offset) {
      let mid = top2 + this.left.height;
      return height < mid ? this.left.blockAt(height, doc3, top2, offset) : this.right.blockAt(height, doc3, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type, doc3, top2, offset) {
      let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
      let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
      let base2 = left ? this.left.lineAt(value, type, doc3, top2, offset) : this.right.lineAt(value, type, doc3, rightTop, rightOffset);
      if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
        return base2;
      let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
      if (left)
        return base2.join(this.right.lineAt(rightOffset, subQuery, doc3, rightTop, rightOffset));
      else
        return this.left.lineAt(rightOffset, subQuery, doc3, top2, offset).join(base2);
    }
    forEachLine(from3, to, doc3, top2, offset, f) {
      let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
      if (this.break) {
        if (from3 < rightOffset)
          this.left.forEachLine(from3, to, doc3, top2, offset, f);
        if (to >= rightOffset)
          this.right.forEachLine(from3, to, doc3, rightTop, rightOffset, f);
      } else {
        let mid = this.lineAt(rightOffset, QueryType.ByPos, doc3, top2, offset);
        if (from3 < mid.from)
          this.left.forEachLine(from3, mid.from - 1, doc3, top2, offset, f);
        if (mid.to >= from3 && mid.from <= to)
          f(mid);
        if (to > mid.to)
          this.right.forEachLine(mid.to + 1, to, doc3, rightTop, rightOffset, f);
      }
    }
    replace(from3, to, nodes) {
      let rightStart = this.left.length + this.break;
      if (to < rightStart)
        return this.balanced(this.left.replace(from3, to, nodes), this.right);
      if (from3 > this.left.length)
        return this.balanced(this.left, this.right.replace(from3 - rightStart, to - rightStart, nodes));
      let result = [];
      if (from3 > 0)
        this.decomposeLeft(from3, result);
      let left = result.length;
      for (let node of nodes)
        result.push(node);
      if (from3 > 0)
        mergeGaps(result, left - 1);
      if (to < this.length) {
        let right = result.length;
        this.decomposeRight(to, result);
        mergeGaps(result, right);
      }
      return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
      let left = this.left.length;
      if (to <= left)
        return this.left.decomposeLeft(to, result);
      result.push(this.left);
      if (this.break) {
        left++;
        if (to >= left)
          result.push(null);
      }
      if (to > left)
        this.right.decomposeLeft(to - left, result);
    }
    decomposeRight(from3, result) {
      let left = this.left.length, right = left + this.break;
      if (from3 >= right)
        return this.right.decomposeRight(from3 - right, result);
      if (from3 < left)
        this.left.decomposeRight(from3, result);
      if (this.break && from3 < right)
        result.push(null);
      result.push(this.right);
    }
    balanced(left, right) {
      if (left.size > 2 * right.size || right.size > 2 * left.size)
        return HeightMap.of(this.break ? [left, null, right] : [left, right]);
      this.left = left;
      this.right = right;
      this.height = left.height + right.height;
      this.outdated = left.outdated || right.outdated;
      this.size = left.size + right.size;
      this.length = left.length + this.break + right.length;
      return this;
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
      if (measured && measured.from <= offset + left.length && measured.more)
        rebalance = left = left.updateHeight(oracle, offset, force, measured);
      else
        left.updateHeight(oracle, offset, force);
      if (measured && measured.from <= rightStart + right.length && measured.more)
        rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
      else
        right.updateHeight(oracle, rightStart, force);
      if (rebalance)
        return this.balanced(left, right);
      this.height = this.left.height + this.right.height;
      this.outdated = false;
      return this;
    }
    toString() {
      return this.left + (this.break ? " " : "-") + this.right;
    }
  };
  function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
      nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
  }
  var relevantWidgetHeight = 5;
  var NodeBuilder = class {
    constructor(pos, oracle) {
      this.pos = pos;
      this.oracle = oracle;
      this.nodes = [];
      this.lineStart = -1;
      this.lineEnd = -1;
      this.covering = null;
      this.writtenTo = pos;
    }
    get isCovered() {
      return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
      if (this.lineStart > -1) {
        let end = Math.min(to, this.lineEnd), last2 = this.nodes[this.nodes.length - 1];
        if (last2 instanceof HeightMapText)
          last2.length += end - this.pos;
        else if (end > this.pos || !this.isCovered)
          this.nodes.push(new HeightMapText(end - this.pos, -1));
        this.writtenTo = end;
        if (to > end) {
          this.nodes.push(null);
          this.writtenTo++;
          this.lineStart = -1;
        }
      }
      this.pos = to;
    }
    point(from3, to, deco) {
      if (from3 < to || deco.heightRelevant) {
        let height = deco.widget ? deco.widget.estimatedHeight : 0;
        if (height < 0)
          height = this.oracle.lineHeight;
        let len = to - from3;
        if (deco.block) {
          this.addBlock(new HeightMapBlock(len, height, deco.type));
        } else if (len || height >= relevantWidgetHeight) {
          this.addLineDeco(height, len);
        }
      } else if (to > from3) {
        this.span(from3, to);
      }
      if (this.lineEnd > -1 && this.lineEnd < this.pos)
        this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
      if (this.lineStart > -1)
        return;
      let { from: from3, to } = this.oracle.doc.lineAt(this.pos);
      this.lineStart = from3;
      this.lineEnd = to;
      if (this.writtenTo < from3) {
        if (this.writtenTo < from3 - 1 || this.nodes[this.nodes.length - 1] == null)
          this.nodes.push(this.blankContent(this.writtenTo, from3 - 1));
        this.nodes.push(null);
      }
      if (this.pos > from3)
        this.nodes.push(new HeightMapText(this.pos - from3, -1));
      this.writtenTo = this.pos;
    }
    blankContent(from3, to) {
      let gap = new HeightMapGap(to - from3);
      if (this.oracle.doc.lineAt(from3).to == to)
        gap.flags |= 4;
      return gap;
    }
    ensureLine() {
      this.enterLine();
      let last2 = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
      if (last2 instanceof HeightMapText)
        return last2;
      let line = new HeightMapText(0, -1);
      this.nodes.push(line);
      return line;
    }
    addBlock(block) {
      this.enterLine();
      if (block.type == BlockType.WidgetAfter && !this.isCovered)
        this.ensureLine();
      this.nodes.push(block);
      this.writtenTo = this.pos = this.pos + block.length;
      if (block.type != BlockType.WidgetBefore)
        this.covering = block;
    }
    addLineDeco(height, length3) {
      let line = this.ensureLine();
      line.length += length3;
      line.collapsed += length3;
      line.widgetHeight = Math.max(line.widgetHeight, height);
      this.writtenTo = this.pos = this.pos + length3;
    }
    finish(from3) {
      let last2 = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
      if (this.lineStart > -1 && !(last2 instanceof HeightMapText) && !this.isCovered)
        this.nodes.push(new HeightMapText(0, -1));
      else if (this.writtenTo < this.pos || last2 == null)
        this.nodes.push(this.blankContent(this.writtenTo, this.pos));
      let pos = from3;
      for (let node of this.nodes) {
        if (node instanceof HeightMapText)
          node.updateHeight(this.oracle, pos);
        pos += node ? node.length : 1;
      }
      return this.nodes;
    }
    static build(oracle, decorations2, from3, to) {
      let builder = new NodeBuilder(from3, oracle);
      RangeSet.spans(decorations2, from3, to, builder, 0);
      return builder.finish(from3);
    }
  };
  function heightRelevantDecoChanges(a2, b, diff) {
    let comp = new DecorationComparator();
    RangeSet.compare(a2, b, diff, comp, 0);
    return comp.changes;
  }
  var DecorationComparator = class {
    constructor() {
      this.changes = [];
    }
    compareRange() {
    }
    comparePoint(from3, to, a2, b) {
      if (from3 < to || a2 && a2.heightRelevant || b && b.heightRelevant)
        addRange(from3, to, this.changes, 5);
    }
  };
  function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let doc3 = dom.ownerDocument, win = doc3.defaultView || window;
    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
    let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
    for (let parent = dom.parentNode; parent && parent != doc3.body; ) {
      if (parent.nodeType == 1) {
        let elt2 = parent;
        let style = window.getComputedStyle(elt2);
        if ((elt2.scrollHeight > elt2.clientHeight || elt2.scrollWidth > elt2.clientWidth) && style.overflow != "visible") {
          let parentRect = elt2.getBoundingClientRect();
          left = Math.max(left, parentRect.left);
          right = Math.min(right, parentRect.right);
          top2 = Math.max(top2, parentRect.top);
          bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);
        }
        parent = style.position == "absolute" || style.position == "fixed" ? elt2.offsetParent : elt2.parentNode;
      } else if (parent.nodeType == 11) {
        parent = parent.host;
      } else {
        break;
      }
    }
    return {
      left: left - rect.left,
      right: Math.max(left, right) - rect.left,
      top: top2 - (rect.top + paddingTop),
      bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
    };
  }
  function fullPixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    return {
      left: 0,
      right: rect.right - rect.left,
      top: paddingTop,
      bottom: rect.bottom - (rect.top + paddingTop)
    };
  }
  var LineGap = class {
    constructor(from3, to, size) {
      this.from = from3;
      this.to = to;
      this.size = size;
    }
    static same(a2, b) {
      if (a2.length != b.length)
        return false;
      for (let i = 0; i < a2.length; i++) {
        let gA = a2[i], gB = b[i];
        if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
          return false;
      }
      return true;
    }
    draw(wrapping) {
      return Decoration.replace({ widget: new LineGapWidget(this.size, wrapping) }).range(this.from, this.to);
    }
  };
  var LineGapWidget = class extends WidgetType {
    constructor(size, vertical) {
      super();
      this.size = size;
      this.vertical = vertical;
    }
    eq(other) {
      return other.size == this.size && other.vertical == this.vertical;
    }
    toDOM() {
      let elt2 = document.createElement("div");
      if (this.vertical) {
        elt2.style.height = this.size + "px";
      } else {
        elt2.style.width = this.size + "px";
        elt2.style.height = "2px";
        elt2.style.display = "inline-block";
      }
      return elt2;
    }
    get estimatedHeight() {
      return this.vertical ? this.size : -1;
    }
  };
  var ViewState = class {
    constructor(state) {
      this.state = state;
      this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
      this.inView = true;
      this.paddingTop = 0;
      this.paddingBottom = 0;
      this.contentDOMWidth = 0;
      this.contentDOMHeight = 0;
      this.editorHeight = 0;
      this.editorWidth = 0;
      this.scaler = IdScaler;
      this.scrollTarget = null;
      this.printing = false;
      this.mustMeasureContent = true;
      this.defaultTextDirection = Direction.LTR;
      this.visibleRanges = [];
      this.mustEnforceCursorAssoc = false;
      let guessWrapping = state.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
      this.heightOracle = new HeightOracle(guessWrapping);
      this.stateDeco = state.facet(decorations).filter((d) => typeof d != "function");
      this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
      this.viewport = this.getViewport(0, null);
      this.updateViewportLines();
      this.updateForViewport();
      this.lineGaps = this.ensureLineGaps([]);
      this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(false)));
      this.computeVisibleRanges();
    }
    updateForViewport() {
      let viewports = [this.viewport], { main } = this.state.selection;
      for (let i = 0; i <= 1; i++) {
        let pos = i ? main.head : main.anchor;
        if (!viewports.some(({ from: from3, to }) => pos >= from3 && pos <= to)) {
          let { from: from3, to } = this.lineBlockAt(pos);
          viewports.push(new Viewport(from3, to));
        }
      }
      this.viewports = viewports.sort((a2, b) => a2.from - b.from);
      this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);
    }
    updateViewportLines() {
      this.viewportLines = [];
      this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, (block) => {
        this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
      });
    }
    update(update, scrollTarget = null) {
      this.state = update.state;
      let prevDeco = this.stateDeco;
      this.stateDeco = this.state.facet(decorations).filter((d) => typeof d != "function");
      let contentChanges = update.changedRanges;
      let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
      let prevHeight = this.heightMap.height;
      this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
      if (this.heightMap.height != prevHeight)
        update.flags |= 2;
      let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
      if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
        viewport = this.getViewport(0, scrollTarget);
      let updateLines = !update.changes.empty || update.flags & 2 || viewport.from != this.viewport.from || viewport.to != this.viewport.to;
      this.viewport = viewport;
      this.updateForViewport();
      if (updateLines)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
        this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
      update.flags |= this.computeVisibleRanges();
      if (scrollTarget)
        this.scrollTarget = scrollTarget;
      if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
        this.mustEnforceCursorAssoc = true;
    }
    measure(view2) {
      let dom = view2.contentDOM, style = window.getComputedStyle(dom);
      let oracle = this.heightOracle;
      let whiteSpace = style.whiteSpace;
      this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
      let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
      let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != dom.clientHeight;
      this.contentDOMHeight = dom.clientHeight;
      this.mustMeasureContent = false;
      let result = 0, bias = 0;
      let paddingTop = parseInt(style.paddingTop) || 0, paddingBottom = parseInt(style.paddingBottom) || 0;
      if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
        this.paddingTop = paddingTop;
        this.paddingBottom = paddingBottom;
        result |= 8 | 2;
      }
      if (this.editorWidth != view2.scrollDOM.clientWidth) {
        if (oracle.lineWrapping)
          measureContent = true;
        this.editorWidth = view2.scrollDOM.clientWidth;
        result |= 8;
      }
      let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
      let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
      this.pixelViewport = pixelViewport;
      let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
      if (inView != this.inView) {
        this.inView = inView;
        if (inView)
          measureContent = true;
      }
      if (!this.inView && !this.scrollTarget)
        return 0;
      let contentWidth = dom.clientWidth;
      if (this.contentDOMWidth != contentWidth || this.editorHeight != view2.scrollDOM.clientHeight) {
        this.contentDOMWidth = contentWidth;
        this.editorHeight = view2.scrollDOM.clientHeight;
        result |= 8;
      }
      if (measureContent) {
        let lineHeights = view2.docView.measureVisibleLineHeights(this.viewport);
        if (oracle.mustRefreshForHeights(lineHeights))
          refresh = true;
        if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
          let { lineHeight, charWidth } = view2.docView.measureTextSize();
          refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, contentWidth / charWidth, lineHeights);
          if (refresh) {
            view2.docView.minWidth = 0;
            result |= 8;
          }
        }
        if (dTop > 0 && dBottom > 0)
          bias = Math.max(dTop, dBottom);
        else if (dTop < 0 && dBottom < 0)
          bias = Math.min(dTop, dBottom);
        oracle.heightChanged = false;
        for (let vp of this.viewports) {
          let heights = vp.from == this.viewport.from ? lineHeights : view2.docView.measureVisibleLineHeights(vp);
          this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view2.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
        }
        if (oracle.heightChanged)
          result |= 2;
      }
      let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
      if (viewportChange)
        this.viewport = this.getViewport(bias, this.scrollTarget);
      this.updateForViewport();
      if (result & 2 || viewportChange)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
        this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view2));
      result |= this.computeVisibleRanges();
      if (this.mustEnforceCursorAssoc) {
        this.mustEnforceCursorAssoc = false;
        view2.docView.enforceCursorAssoc();
      }
      return result;
    }
    get visibleTop() {
      return this.scaler.fromDOM(this.pixelViewport.top);
    }
    get visibleBottom() {
      return this.scaler.fromDOM(this.pixelViewport.bottom);
    }
    getViewport(bias, scrollTarget) {
      let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
      let map3 = this.heightMap, doc3 = this.state.doc, { visibleTop, visibleBottom } = this;
      let viewport = new Viewport(map3.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, doc3, 0, 0).from, map3.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, doc3, 0, 0).to);
      if (scrollTarget) {
        let { head } = scrollTarget.range;
        if (head < viewport.from || head > viewport.to) {
          let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
          let block = map3.lineAt(head, QueryType.ByPos, doc3, 0, 0), topPos;
          if (scrollTarget.y == "center")
            topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
          else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
            topPos = block.top;
          else
            topPos = block.bottom - viewHeight;
          viewport = new Viewport(map3.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, doc3, 0, 0).from, map3.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, doc3, 0, 0).to);
        }
      }
      return viewport;
    }
    mapViewport(viewport, changes) {
      let from3 = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
      return new Viewport(this.heightMap.lineAt(from3, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);
    }
    viewportIsAppropriate({ from: from3, to }, bias = 0) {
      if (!this.inView)
        return true;
      let { top: top2 } = this.heightMap.lineAt(from3, QueryType.ByPos, this.state.doc, 0, 0);
      let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);
      let { visibleTop, visibleBottom } = this;
      return (from3 == 0 || top2 <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(bias, 250))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
    }
    mapLineGaps(gaps, changes) {
      if (!gaps.length || changes.empty)
        return gaps;
      let mapped = [];
      for (let gap of gaps)
        if (!changes.touchesRange(gap.from, gap.to))
          mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
      return mapped;
    }
    ensureLineGaps(current, mayMeasure) {
      let wrapping = this.heightOracle.lineWrapping;
      let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
      if (this.defaultTextDirection != Direction.LTR && !wrapping)
        return [];
      let gaps = [];
      let addGap = (from3, to, line, structure) => {
        if (to - from3 < halfMargin)
          return;
        let sel = this.state.selection.main, avoid = [sel.from];
        if (!sel.empty)
          avoid.push(sel.to);
        for (let pos of avoid) {
          if (pos > from3 && pos < to) {
            addGap(from3, pos - 10, line, structure);
            addGap(pos + 10, to, line, structure);
            return;
          }
        }
        let gap = find2(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from3) < halfMargin && Math.abs(gap2.to - to) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
        if (!gap) {
          if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r) => r.from <= to && r.to >= to)) {
            let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
            if (lineStart > from3)
              to = lineStart;
          }
          gap = new LineGap(from3, to, this.gapSize(line, from3, to, structure));
        }
        gaps.push(gap);
      };
      for (let line of this.viewportLines) {
        if (line.length < doubleMargin)
          continue;
        let structure = lineStructure(line.from, line.to, this.stateDeco);
        if (structure.total < doubleMargin)
          continue;
        let target = this.scrollTarget ? this.scrollTarget.range.head : null;
        let viewFrom, viewTo;
        if (wrapping) {
          let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
          let top2, bot;
          if (target != null) {
            let targetFrac = findFraction(structure, target);
            let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
            top2 = targetFrac - spaceFrac;
            bot = targetFrac + spaceFrac;
          } else {
            top2 = (this.visibleTop - line.top - marginHeight) / line.height;
            bot = (this.visibleBottom - line.top + marginHeight) / line.height;
          }
          viewFrom = findPosition(structure, top2);
          viewTo = findPosition(structure, bot);
        } else {
          let totalWidth = structure.total * this.heightOracle.charWidth;
          let marginWidth = margin * this.heightOracle.charWidth;
          let left, right;
          if (target != null) {
            let targetFrac = findFraction(structure, target);
            let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;
            left = targetFrac - spaceFrac;
            right = targetFrac + spaceFrac;
          } else {
            left = (this.pixelViewport.left - marginWidth) / totalWidth;
            right = (this.pixelViewport.right + marginWidth) / totalWidth;
          }
          viewFrom = findPosition(structure, left);
          viewTo = findPosition(structure, right);
        }
        if (viewFrom > line.from)
          addGap(line.from, viewFrom, line, structure);
        if (viewTo < line.to)
          addGap(viewTo, line.to, line, structure);
      }
      return gaps;
    }
    gapSize(line, from3, to, structure) {
      let fraction = findFraction(structure, to) - findFraction(structure, from3);
      if (this.heightOracle.lineWrapping) {
        return line.height * fraction;
      } else {
        return structure.total * this.heightOracle.charWidth * fraction;
      }
    }
    updateLineGaps(gaps) {
      if (!LineGap.same(gaps, this.lineGaps)) {
        this.lineGaps = gaps;
        this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this.heightOracle.lineWrapping)));
      }
    }
    computeVisibleRanges() {
      let deco = this.stateDeco;
      if (this.lineGaps.length)
        deco = deco.concat(this.lineGapDeco);
      let ranges = [];
      RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
        span(from3, to) {
          ranges.push({ from: from3, to });
        },
        point() {
        }
      }, 20);
      let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);
      this.visibleRanges = ranges;
      return changed ? 4 : 0;
    }
    lineBlockAt(pos) {
      return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
      return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.state.doc, 0, 0), this.scaler);
    }
    elementAtHeight(height) {
      return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.state.doc, 0, 0), this.scaler);
    }
    get docHeight() {
      return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
      return this.docHeight + this.paddingTop + this.paddingBottom;
    }
  };
  var Viewport = class {
    constructor(from3, to) {
      this.from = from3;
      this.to = to;
    }
  };
  function lineStructure(from3, to, stateDeco) {
    let ranges = [], pos = from3, total = 0;
    RangeSet.spans(stateDeco, from3, to, {
      span() {
      },
      point(from4, to2) {
        if (from4 > pos) {
          ranges.push({ from: pos, to: from4 });
          total += from4 - pos;
        }
        pos = to2;
      }
    }, 20);
    if (pos < to) {
      ranges.push({ from: pos, to });
      total += to - pos;
    }
    return { total, ranges };
  }
  function findPosition({ total, ranges }, ratio) {
    if (ratio <= 0)
      return ranges[0].from;
    if (ratio >= 1)
      return ranges[ranges.length - 1].to;
    let dist = Math.floor(total * ratio);
    for (let i = 0; ; i++) {
      let { from: from3, to } = ranges[i], size = to - from3;
      if (dist <= size)
        return from3 + dist;
      dist -= size;
    }
  }
  function findFraction(structure, pos) {
    let counted = 0;
    for (let { from: from3, to } of structure.ranges) {
      if (pos <= to) {
        counted += pos - from3;
        break;
      }
      counted += to - from3;
    }
    return counted / structure.total;
  }
  function find2(array2, f) {
    for (let val of array2)
      if (f(val))
        return val;
    return void 0;
  }
  var IdScaler = {
    toDOM(n2) {
      return n2;
    },
    fromDOM(n2) {
      return n2;
    },
    scale: 1
  };
  var BigScaler = class {
    constructor(doc3, heightMap, viewports) {
      let vpHeight = 0, base2 = 0, domBase = 0;
      this.viewports = viewports.map(({ from: from3, to }) => {
        let top2 = heightMap.lineAt(from3, QueryType.ByPos, doc3, 0, 0).top;
        let bottom = heightMap.lineAt(to, QueryType.ByPos, doc3, 0, 0).bottom;
        vpHeight += bottom - top2;
        return { from: from3, to, top: top2, bottom, domTop: 0, domBottom: 0 };
      });
      this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
      for (let obj of this.viewports) {
        obj.domTop = domBase + (obj.top - base2) * this.scale;
        domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
        base2 = obj.bottom;
      }
    }
    toDOM(n2) {
      for (let i = 0, base2 = 0, domBase = 0; ; i++) {
        let vp = i < this.viewports.length ? this.viewports[i] : null;
        if (!vp || n2 < vp.top)
          return domBase + (n2 - base2) * this.scale;
        if (n2 <= vp.bottom)
          return vp.domTop + (n2 - vp.top);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    fromDOM(n2) {
      for (let i = 0, base2 = 0, domBase = 0; ; i++) {
        let vp = i < this.viewports.length ? this.viewports[i] : null;
        if (!vp || n2 < vp.domTop)
          return base2 + (n2 - domBase) / this.scale;
        if (n2 <= vp.domBottom)
          return vp.top + (n2 - vp.domTop);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
  };
  function scaleBlock(block, scaler) {
    if (scaler.scale == 1)
      return block;
    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map((b) => scaleBlock(b, scaler)) : block.type);
  }
  var theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
  var darkTheme = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.indexOf(true) > -1 });
  var baseThemeID = /* @__PURE__ */ StyleModule.newName();
  var baseLightID = /* @__PURE__ */ StyleModule.newName();
  var baseDarkID = /* @__PURE__ */ StyleModule.newName();
  var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
  function buildTheme(main, spec, scopes) {
    return new StyleModule(spec, {
      finish(sel) {
        return /&/.test(sel) ? sel.replace(/&\w*/, (m2) => {
          if (m2 == "&")
            return main;
          if (!scopes || !scopes[m2])
            throw new RangeError(`Unsupported selector: ${m2}`);
          return scopes[m2];
        }) : main + " " + sel;
      }
    });
  }
  var baseTheme$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
    "&.cm-editor": {
      position: "relative !important",
      boxSizing: "border-box",
      "&.cm-focused": {
        outline: "1px dotted #212121"
      },
      display: "flex !important",
      flexDirection: "column"
    },
    ".cm-scroller": {
      display: "flex !important",
      alignItems: "flex-start !important",
      fontFamily: "monospace",
      lineHeight: 1.4,
      height: "100%",
      overflowX: "auto",
      position: "relative",
      zIndex: 0
    },
    ".cm-content": {
      margin: 0,
      flexGrow: 2,
      flexShrink: 0,
      minHeight: "100%",
      display: "block",
      whiteSpace: "pre",
      wordWrap: "normal",
      boxSizing: "border-box",
      padding: "4px 0",
      outline: "none",
      "&[contenteditable=true]": {
        WebkitUserModify: "read-write-plaintext-only"
      }
    },
    ".cm-lineWrapping": {
      whiteSpace_fallback: "pre-wrap",
      whiteSpace: "break-spaces",
      wordBreak: "break-word",
      overflowWrap: "anywhere",
      flexShrink: 1
    },
    "&light .cm-content": { caretColor: "black" },
    "&dark .cm-content": { caretColor: "white" },
    ".cm-line": {
      display: "block",
      padding: "0 2px 0 6px"
    },
    ".cm-layer": {
      contain: "size style",
      "& > *": {
        position: "absolute"
      }
    },
    "&light .cm-selectionBackground": {
      background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
      background: "#222"
    },
    "&light.cm-focused .cm-selectionBackground": {
      background: "#d7d4f0"
    },
    "&dark.cm-focused .cm-selectionBackground": {
      background: "#233"
    },
    ".cm-cursorLayer": {
      pointerEvents: "none"
    },
    "&.cm-focused .cm-cursorLayer": {
      animation: "steps(1) cm-blink 1.2s infinite"
    },
    "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    ".cm-cursor, .cm-dropCursor": {
      borderLeft: "1.2px solid black",
      marginLeft: "-0.6px",
      pointerEvents: "none"
    },
    ".cm-cursor": {
      display: "none"
    },
    "&dark .cm-cursor": {
      borderLeftColor: "#444"
    },
    "&.cm-focused .cm-cursor": {
      display: "block"
    },
    "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
    "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
    "&light .cm-specialChar": { color: "red" },
    "&dark .cm-specialChar": { color: "#f78" },
    ".cm-gutters": {
      flexShrink: 0,
      display: "flex",
      height: "100%",
      boxSizing: "border-box",
      left: 0,
      zIndex: 200
    },
    "&light .cm-gutters": {
      backgroundColor: "#f5f5f5",
      color: "#6c6c6c",
      borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
      backgroundColor: "#333338",
      color: "#ccc"
    },
    ".cm-gutter": {
      display: "flex !important",
      flexDirection: "column",
      flexShrink: 0,
      boxSizing: "border-box",
      minHeight: "100%",
      overflow: "hidden"
    },
    ".cm-gutterElement": {
      boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
      padding: "0 3px 0 5px",
      minWidth: "20px",
      textAlign: "right",
      whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
      backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
      backgroundColor: "#222227"
    },
    ".cm-panels": {
      boxSizing: "border-box",
      position: "sticky",
      left: 0,
      right: 0
    },
    "&light .cm-panels": {
      backgroundColor: "#f5f5f5",
      color: "black"
    },
    "&light .cm-panels-top": {
      borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
      borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tab": {
      display: "inline-block",
      overflow: "hidden",
      verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
      verticalAlign: "text-top",
      height: "1em",
      width: 0,
      display: "inline"
    },
    ".cm-placeholder": {
      color: "#888",
      display: "inline-block",
      verticalAlign: "top"
    },
    ".cm-button": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      padding: ".2em 1em",
      borderRadius: "1px"
    },
    "&light .cm-button": {
      backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
      }
    },
    "&dark .cm-button": {
      backgroundImage: "linear-gradient(#393939, #111)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#111, #333)"
      }
    },
    ".cm-textfield": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      border: "1px solid silver",
      padding: ".2em .5em"
    },
    "&light .cm-textfield": {
      backgroundColor: "white"
    },
    "&dark .cm-textfield": {
      border: "1px solid #555",
      backgroundColor: "inherit"
    }
  }, lightDarkIDs);
  var DOMChange = class {
    constructor(view2, start, end, typeOver) {
      this.typeOver = typeOver;
      this.bounds = null;
      this.text = "";
      let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view2.docView;
      if (view2.state.readOnly && start > -1) {
        this.newSel = null;
      } else if (start > -1 && (this.bounds = view2.docView.domBoundsAround(start, end, 0))) {
        let selPoints = iHead || iAnchor ? [] : selectionPoints(view2);
        let reader = new DOMReader(selPoints, view2.state);
        reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
        this.text = reader.text;
        this.newSel = selectionFromPoints(selPoints, this.bounds.from);
      } else {
        let domSel = view2.observer.selectionRange;
        let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view2.contentDOM, domSel.focusNode) ? view2.state.selection.main.head : view2.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view2.contentDOM, domSel.anchorNode) ? view2.state.selection.main.anchor : view2.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
        this.newSel = EditorSelection.single(anchor, head);
      }
    }
  };
  function applyDOMChange(view2, domChange) {
    let change2;
    let { newSel } = domChange, sel = view2.state.selection.main;
    if (domChange.bounds) {
      let { from: from3, to } = domChange.bounds;
      let preferredPos = sel.from, preferredSide = null;
      if (view2.inputState.lastKeyCode === 8 && view2.inputState.lastKeyTime > Date.now() - 100 || browser.android && domChange.text.length < to - from3) {
        preferredPos = sel.to;
        preferredSide = "end";
      }
      let diff = findDiff(view2.state.doc.sliceString(from3, to, LineBreakPlaceholder), domChange.text, preferredPos - from3, preferredSide);
      if (diff) {
        if (browser.chrome && view2.inputState.lastKeyCode == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
          diff.toB--;
        change2 = {
          from: from3 + diff.from,
          to: from3 + diff.toA,
          insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
        };
      }
    } else if (newSel && (!view2.hasFocus || !view2.state.facet(editable) || newSel.main.eq(sel))) {
      newSel = null;
    }
    if (!change2 && !newSel)
      return false;
    if (!change2 && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
      change2 = { from: sel.from, to: sel.to, insert: view2.state.doc.slice(sel.from, sel.to) };
    } else if (change2 && change2.from >= sel.from && change2.to <= sel.to && (change2.from != sel.from || change2.to != sel.to) && sel.to - sel.from - (change2.to - change2.from) <= 4) {
      change2 = {
        from: sel.from,
        to: sel.to,
        insert: view2.state.doc.slice(sel.from, change2.from).append(change2.insert).append(view2.state.doc.slice(change2.to, sel.to))
      };
    } else if ((browser.mac || browser.android) && change2 && change2.from == change2.to && change2.from == sel.head - 1 && /^\. ?$/.test(change2.insert.toString())) {
      if (newSel && change2.insert.length == 2)
        newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change2 = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
    } else if (browser.chrome && change2 && change2.from == change2.to && change2.from == sel.head && change2.insert.toString() == "\n " && view2.lineWrapping) {
      if (newSel)
        newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change2 = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
    }
    if (change2) {
      let startState = view2.state;
      if (browser.ios && view2.inputState.flushIOSKey(view2))
        return true;
      if (browser.android && (change2.from == sel.from && change2.to == sel.to && change2.insert.length == 1 && change2.insert.lines == 2 && dispatchKey(view2.contentDOM, "Enter", 13) || change2.from == sel.from - 1 && change2.to == sel.to && change2.insert.length == 0 && dispatchKey(view2.contentDOM, "Backspace", 8) || change2.from == sel.from && change2.to == sel.to + 1 && change2.insert.length == 0 && dispatchKey(view2.contentDOM, "Delete", 46)))
        return true;
      let text3 = change2.insert.toString();
      if (view2.state.facet(inputHandler).some((h2) => h2(view2, change2.from, change2.to, text3)))
        return true;
      if (view2.inputState.composing >= 0)
        view2.inputState.composing++;
      let tr;
      if (change2.from >= sel.from && change2.to <= sel.to && change2.to - change2.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change2.from + change2.insert.length) && view2.inputState.composing < 0) {
        let before = sel.from < change2.from ? startState.sliceDoc(sel.from, change2.from) : "";
        let after = sel.to > change2.to ? startState.sliceDoc(change2.to, sel.to) : "";
        tr = startState.replaceSelection(view2.state.toText(before + change2.insert.sliceString(0, void 0, view2.state.lineBreak) + after));
      } else {
        let changes = startState.changes(change2);
        let mainSel = newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? newSel.main : void 0;
        if (startState.selection.ranges.length > 1 && view2.inputState.composing >= 0 && change2.to <= sel.to && change2.to >= sel.to - 10) {
          let replaced = view2.state.sliceDoc(change2.from, change2.to);
          let compositionRange = compositionSurroundingNode(view2) || view2.state.doc.lineAt(sel.head);
          let offset = sel.to - change2.to, size = sel.to - sel.from;
          tr = startState.changeByRange((range) => {
            if (range.from == sel.from && range.to == sel.to)
              return { changes, range: mainSel || range.map(changes) };
            let to = range.to - offset, from3 = to - replaced.length;
            if (range.to - range.from != size || view2.state.sliceDoc(from3, to) != replaced || compositionRange && range.to >= compositionRange.from && range.from <= compositionRange.to)
              return { range };
            let rangeChanges = startState.changes({ from: from3, to, insert: change2.insert }), selOff = range.to - sel.to;
            return {
              changes: rangeChanges,
              range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
            };
          });
        } else {
          tr = {
            changes,
            selection: mainSel && startState.selection.replaceRange(mainSel)
          };
        }
      }
      let userEvent = "input.type";
      if (view2.composing) {
        userEvent += ".compose";
        if (view2.inputState.compositionFirstChange) {
          userEvent += ".start";
          view2.inputState.compositionFirstChange = false;
        }
      }
      view2.dispatch(tr, { scrollIntoView: true, userEvent });
      return true;
    } else if (newSel && !newSel.main.eq(sel)) {
      let scrollIntoView3 = false, userEvent = "select";
      if (view2.inputState.lastSelectionTime > Date.now() - 50) {
        if (view2.inputState.lastSelectionOrigin == "select")
          scrollIntoView3 = true;
        userEvent = view2.inputState.lastSelectionOrigin;
      }
      view2.dispatch({ selection: newSel, scrollIntoView: scrollIntoView3, userEvent });
      return true;
    } else {
      return false;
    }
  }
  function findDiff(a2, b, preferredPos, preferredSide) {
    let minLen = Math.min(a2.length, b.length);
    let from3 = 0;
    while (from3 < minLen && a2.charCodeAt(from3) == b.charCodeAt(from3))
      from3++;
    if (from3 == minLen && a2.length == b.length)
      return null;
    let toA = a2.length, toB = b.length;
    while (toA > 0 && toB > 0 && a2.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
      toA--;
      toB--;
    }
    if (preferredSide == "end") {
      let adjust = Math.max(0, from3 - Math.min(toA, toB));
      preferredPos -= toA + adjust - from3;
    }
    if (toA < from3 && a2.length < b.length) {
      let move = preferredPos <= from3 && preferredPos >= toA ? from3 - preferredPos : 0;
      from3 -= move;
      toB = from3 + (toB - toA);
      toA = from3;
    } else if (toB < from3) {
      let move = preferredPos <= from3 && preferredPos >= toB ? from3 - preferredPos : 0;
      from3 -= move;
      toA = from3 + (toA - toB);
      toB = from3;
    }
    return { from: from3, toA, toB };
  }
  function selectionPoints(view2) {
    let result = [];
    if (view2.root.activeElement != view2.contentDOM)
      return result;
    let { anchorNode, anchorOffset, focusNode, focusOffset } = view2.observer.selectionRange;
    if (anchorNode) {
      result.push(new DOMPoint(anchorNode, anchorOffset));
      if (focusNode != anchorNode || focusOffset != anchorOffset)
        result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
  }
  function selectionFromPoints(points, base2) {
    if (points.length == 0)
      return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
  }
  var observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
  };
  var useCharData = browser.ie && browser.ie_version <= 11;
  var DOMObserver = class {
    constructor(view2) {
      this.view = view2;
      this.active = false;
      this.selectionRange = new DOMSelectionState();
      this.selectionChanged = false;
      this.delayedFlush = -1;
      this.resizeTimeout = -1;
      this.queue = [];
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
      this.lastChange = 0;
      this.scrollTargets = [];
      this.intersection = null;
      this.resize = null;
      this.intersecting = false;
      this.gapIntersection = null;
      this.gaps = [];
      this.parentCheck = -1;
      this.dom = view2.contentDOM;
      this.observer = new MutationObserver((mutations) => {
        for (let mut of mutations)
          this.queue.push(mut);
        if ((browser.ie && browser.ie_version <= 11 || browser.ios && view2.composing) && mutations.some((m2) => m2.type == "childList" && m2.removedNodes.length || m2.type == "characterData" && m2.oldValue.length > m2.target.nodeValue.length))
          this.flushSoon();
        else
          this.flush();
      });
      if (useCharData)
        this.onCharData = (event) => {
          this.queue.push({
            target: event.target,
            type: "characterData",
            oldValue: event.prevValue
          });
          this.flushSoon();
        };
      this.onSelectionChange = this.onSelectionChange.bind(this);
      this.onResize = this.onResize.bind(this);
      this.onPrint = this.onPrint.bind(this);
      this.onScroll = this.onScroll.bind(this);
      if (typeof ResizeObserver == "function") {
        this.resize = new ResizeObserver(() => {
          var _a2;
          if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
            this.onResize();
        });
        this.resize.observe(view2.scrollDOM);
      }
      this.addWindowListeners(this.win = view2.win);
      this.start();
      if (typeof IntersectionObserver == "function") {
        this.intersection = new IntersectionObserver((entries) => {
          if (this.parentCheck < 0)
            this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
            this.intersecting = !this.intersecting;
            if (this.intersecting != this.view.inView)
              this.onScrollChanged(document.createEvent("Event"));
          }
        }, {});
        this.intersection.observe(this.dom);
        this.gapIntersection = new IntersectionObserver((entries) => {
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
            this.onScrollChanged(document.createEvent("Event"));
        }, {});
      }
      this.listenForScroll();
      this.readSelectionRange();
    }
    onScrollChanged(e) {
      this.view.inputState.runScrollHandlers(this.view, e);
      if (this.intersecting)
        this.view.measure();
    }
    onScroll(e) {
      if (this.intersecting)
        this.flush(false);
      this.onScrollChanged(e);
    }
    onResize() {
      if (this.resizeTimeout < 0)
        this.resizeTimeout = setTimeout(() => {
          this.resizeTimeout = -1;
          this.view.requestMeasure();
        }, 50);
    }
    onPrint() {
      this.view.viewState.printing = true;
      this.view.measure();
      setTimeout(() => {
        this.view.viewState.printing = false;
        this.view.requestMeasure();
      }, 500);
    }
    updateGaps(gaps) {
      if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
        this.gapIntersection.disconnect();
        for (let gap of gaps)
          this.gapIntersection.observe(gap);
        this.gaps = gaps;
      }
    }
    onSelectionChange(event) {
      let wasChanged = this.selectionChanged;
      if (!this.readSelectionRange() || this.delayedAndroidKey)
        return;
      let { view: view2 } = this, sel = this.selectionRange;
      if (view2.state.facet(editable) ? view2.root.activeElement != this.dom : !hasSelection(view2.dom, sel))
        return;
      let context = sel.anchorNode && view2.docView.nearest(sel.anchorNode);
      if (context && context.ignoreEvent(event)) {
        if (!wasChanged)
          this.selectionChanged = false;
        return;
      }
      if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view2.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        this.flushSoon();
      else
        this.flush(false);
    }
    readSelectionRange() {
      let { view: view2 } = this;
      let range = browser.safari && view2.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view) || getSelection(view2.root);
      if (!range || this.selectionRange.eq(range))
        return false;
      let local = hasSelection(this.dom, range);
      if (local && !this.selectionChanged && view2.inputState.lastFocusTime > Date.now() - 200 && view2.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
        this.view.inputState.lastFocusTime = 0;
        view2.docView.updateSelection();
        return false;
      }
      this.selectionRange.setRange(range);
      if (local)
        this.selectionChanged = true;
      return true;
    }
    setSelectionRange(anchor, head) {
      this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
      this.selectionChanged = false;
    }
    clearSelectionRange() {
      this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
      this.parentCheck = -1;
      let i = 0, changed = null;
      for (let dom = this.dom; dom; ) {
        if (dom.nodeType == 1) {
          if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
            i++;
          else if (!changed)
            changed = this.scrollTargets.slice(0, i);
          if (changed)
            changed.push(dom);
          dom = dom.assignedSlot || dom.parentNode;
        } else if (dom.nodeType == 11) {
          dom = dom.host;
        } else {
          break;
        }
      }
      if (i < this.scrollTargets.length && !changed)
        changed = this.scrollTargets.slice(0, i);
      if (changed) {
        for (let dom of this.scrollTargets)
          dom.removeEventListener("scroll", this.onScroll);
        for (let dom of this.scrollTargets = changed)
          dom.addEventListener("scroll", this.onScroll);
      }
    }
    ignore(f) {
      if (!this.active)
        return f();
      try {
        this.stop();
        return f();
      } finally {
        this.start();
        this.clear();
      }
    }
    start() {
      if (this.active)
        return;
      this.observer.observe(this.dom, observeOptions);
      if (useCharData)
        this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.active = true;
    }
    stop() {
      if (!this.active)
        return;
      this.active = false;
      this.observer.disconnect();
      if (useCharData)
        this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    clear() {
      this.processRecords();
      this.queue.length = 0;
      this.selectionChanged = false;
    }
    delayAndroidKey(key, keyCode) {
      var _a2;
      if (!this.delayedAndroidKey) {
        let flush = () => {
          let key2 = this.delayedAndroidKey;
          if (key2) {
            this.clearDelayedAndroidKey();
            if (!this.flush() && key2.force)
              dispatchKey(this.dom, key2.key, key2.keyCode);
          }
        };
        this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
      }
      if (!this.delayedAndroidKey || key == "Enter")
        this.delayedAndroidKey = {
          key,
          keyCode,
          force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
        };
    }
    clearDelayedAndroidKey() {
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
    }
    flushSoon() {
      if (this.delayedFlush < 0)
        this.delayedFlush = this.view.win.requestAnimationFrame(() => {
          this.delayedFlush = -1;
          this.flush();
        });
    }
    forceFlush() {
      if (this.delayedFlush >= 0) {
        this.view.win.cancelAnimationFrame(this.delayedFlush);
        this.delayedFlush = -1;
      }
      this.flush();
    }
    processRecords() {
      let records = this.queue;
      for (let mut of this.observer.takeRecords())
        records.push(mut);
      if (records.length)
        this.queue = [];
      let from3 = -1, to = -1, typeOver = false;
      for (let record of records) {
        let range = this.readMutation(record);
        if (!range)
          continue;
        if (range.typeOver)
          typeOver = true;
        if (from3 == -1) {
          ({ from: from3, to } = range);
        } else {
          from3 = Math.min(range.from, from3);
          to = Math.max(range.to, to);
        }
      }
      return { from: from3, to, typeOver };
    }
    readChange() {
      let { from: from3, to, typeOver } = this.processRecords();
      let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
      if (from3 < 0 && !newSel)
        return null;
      if (from3 > -1)
        this.lastChange = Date.now();
      this.view.inputState.lastFocusTime = 0;
      this.selectionChanged = false;
      return new DOMChange(this.view, from3, to, typeOver);
    }
    flush(readSelection = true) {
      if (this.delayedFlush >= 0 || this.delayedAndroidKey)
        return false;
      if (readSelection)
        this.readSelectionRange();
      let domChange = this.readChange();
      if (!domChange)
        return false;
      let startState = this.view.state;
      let handled = applyDOMChange(this.view, domChange);
      if (this.view.state == startState)
        this.view.update([]);
      return handled;
    }
    readMutation(rec) {
      let cView = this.view.docView.nearest(rec.target);
      if (!cView || cView.ignoreMutation(rec))
        return null;
      cView.markDirty(rec.type == "attributes");
      if (rec.type == "attributes")
        cView.dirty |= 4;
      if (rec.type == "childList") {
        let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
        let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
        return {
          from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
          to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
          typeOver: false
        };
      } else if (rec.type == "characterData") {
        return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
      } else {
        return null;
      }
    }
    setWindow(win) {
      if (win != this.win) {
        this.removeWindowListeners(this.win);
        this.win = win;
        this.addWindowListeners(this.win);
      }
    }
    addWindowListeners(win) {
      win.addEventListener("resize", this.onResize);
      win.addEventListener("beforeprint", this.onPrint);
      win.addEventListener("scroll", this.onScroll);
      win.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(win) {
      win.removeEventListener("scroll", this.onScroll);
      win.removeEventListener("resize", this.onResize);
      win.removeEventListener("beforeprint", this.onPrint);
      win.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    destroy() {
      var _a2, _b, _c;
      this.stop();
      (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
      (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
      (_c = this.resize) === null || _c === void 0 ? void 0 : _c.disconnect();
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      this.removeWindowListeners(this.win);
      clearTimeout(this.parentCheck);
      clearTimeout(this.resizeTimeout);
      this.win.cancelAnimationFrame(this.delayedFlush);
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
    }
  };
  function findChild(cView, dom, dir) {
    while (dom) {
      let curView = ContentView.get(dom);
      if (curView && curView.parent == cView)
        return curView;
      let parent = dom.parentNode;
      dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
  }
  function safariSelectionRangeHack(view2) {
    let found = null;
    function read(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found = event.getTargetRanges()[0];
    }
    view2.contentDOM.addEventListener("beforeinput", read, true);
    view2.dom.ownerDocument.execCommand("indent");
    view2.contentDOM.removeEventListener("beforeinput", read, true);
    if (!found)
      return null;
    let anchorNode = found.startContainer, anchorOffset = found.startOffset;
    let focusNode = found.endContainer, focusOffset = found.endOffset;
    let curAnchor = view2.docView.domAtPos(view2.state.selection.main.anchor);
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
  }
  var EditorView = class {
    constructor(config2 = {}) {
      this.plugins = [];
      this.pluginMap = /* @__PURE__ */ new Map();
      this.editorAttrs = {};
      this.contentAttrs = {};
      this.bidiCache = [];
      this.destroyed = false;
      this.updateState = 2;
      this.measureScheduled = -1;
      this.measureRequests = [];
      this.contentDOM = document.createElement("div");
      this.scrollDOM = document.createElement("div");
      this.scrollDOM.tabIndex = -1;
      this.scrollDOM.className = "cm-scroller";
      this.scrollDOM.appendChild(this.contentDOM);
      this.announceDOM = document.createElement("div");
      this.announceDOM.style.cssText = "position: absolute; top: -10000px";
      this.announceDOM.setAttribute("aria-live", "polite");
      this.dom = document.createElement("div");
      this.dom.appendChild(this.announceDOM);
      this.dom.appendChild(this.scrollDOM);
      this._dispatch = config2.dispatch || ((tr) => this.update([tr]));
      this.dispatch = this.dispatch.bind(this);
      this._root = config2.root || getRoot(config2.parent) || document;
      this.viewState = new ViewState(config2.state || EditorState.create(config2));
      this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      for (let plugin of this.plugins)
        plugin.update(this);
      this.observer = new DOMObserver(this);
      this.inputState = new InputState(this);
      this.inputState.ensureHandlers(this, this.plugins);
      this.docView = new DocView(this);
      this.mountStyles();
      this.updateAttrs();
      this.updateState = 0;
      this.requestMeasure();
      if (config2.parent)
        config2.parent.appendChild(this.dom);
    }
    get state() {
      return this.viewState.state;
    }
    get viewport() {
      return this.viewState.viewport;
    }
    get visibleRanges() {
      return this.viewState.visibleRanges;
    }
    get inView() {
      return this.viewState.inView;
    }
    get composing() {
      return this.inputState.composing > 0;
    }
    get compositionStarted() {
      return this.inputState.composing >= 0;
    }
    get root() {
      return this._root;
    }
    get win() {
      return this.dom.ownerDocument.defaultView || window;
    }
    dispatch(...input) {
      this._dispatch(input.length == 1 && input[0] instanceof Transaction ? input[0] : this.state.update(...input));
    }
    update(transactions) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
      let redrawn = false, attrsChanged = false, update;
      let state = this.state;
      for (let tr of transactions) {
        if (tr.startState != state)
          throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
        state = tr.state;
      }
      if (this.destroyed) {
        this.viewState.state = state;
        return;
      }
      let pendingKey = this.observer.delayedAndroidKey, domChange = null;
      if (pendingKey) {
        this.observer.clearDelayedAndroidKey();
        domChange = this.observer.readChange();
        if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
          domChange = null;
      } else {
        this.observer.clear();
      }
      if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
        return this.setState(state);
      update = ViewUpdate.create(this, state, transactions);
      let scrollTarget = this.viewState.scrollTarget;
      try {
        this.updateState = 2;
        for (let tr of transactions) {
          if (scrollTarget)
            scrollTarget = scrollTarget.map(tr.changes);
          if (tr.scrollIntoView) {
            let { main } = tr.state.selection;
            scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
          }
          for (let e of tr.effects)
            if (e.is(scrollIntoView))
              scrollTarget = e.value;
        }
        this.viewState.update(update, scrollTarget);
        this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
        }
        redrawn = this.docView.update(update);
        if (this.state.facet(styleModule) != this.styleModules)
          this.mountStyles();
        attrsChanged = this.updateAttrs();
        this.showAnnouncements(transactions);
        this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
      } finally {
        this.updateState = 0;
      }
      if (update.startState.facet(theme) != update.state.facet(theme))
        this.viewState.mustMeasureContent = true;
      if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
        this.requestMeasure();
      if (!update.empty)
        for (let listener of this.state.facet(updateListener))
          listener(update);
      if (domChange) {
        if (!applyDOMChange(this, domChange) && pendingKey.force)
          dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
      }
    }
    setState(newState) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
      if (this.destroyed) {
        this.viewState.state = newState;
        return;
      }
      this.updateState = 2;
      let hadFocus = this.hasFocus;
      try {
        for (let plugin of this.plugins)
          plugin.destroy(this);
        this.viewState = new ViewState(newState);
        this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
        this.pluginMap.clear();
        for (let plugin of this.plugins)
          plugin.update(this);
        this.docView = new DocView(this);
        this.inputState.ensureHandlers(this, this.plugins);
        this.mountStyles();
        this.updateAttrs();
        this.bidiCache = [];
      } finally {
        this.updateState = 0;
      }
      if (hadFocus)
        this.focus();
      this.requestMeasure();
    }
    updatePlugins(update) {
      let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
      if (prevSpecs != specs) {
        let newPlugins = [];
        for (let spec of specs) {
          let found = prevSpecs.indexOf(spec);
          if (found < 0) {
            newPlugins.push(new PluginInstance(spec));
          } else {
            let plugin = this.plugins[found];
            plugin.mustUpdate = update;
            newPlugins.push(plugin);
          }
        }
        for (let plugin of this.plugins)
          if (plugin.mustUpdate != update)
            plugin.destroy(this);
        this.plugins = newPlugins;
        this.pluginMap.clear();
        this.inputState.ensureHandlers(this, this.plugins);
      } else {
        for (let p of this.plugins)
          p.mustUpdate = update;
      }
      for (let i = 0; i < this.plugins.length; i++)
        this.plugins[i].update(this);
    }
    measure(flush = true) {
      if (this.destroyed)
        return;
      if (this.measureScheduled > -1)
        cancelAnimationFrame(this.measureScheduled);
      this.measureScheduled = 0;
      if (flush)
        this.observer.forceFlush();
      let updated = null;
      let { scrollHeight, scrollTop, clientHeight } = this.scrollDOM;
      let refHeight = scrollTop > scrollHeight - clientHeight - 4 ? scrollHeight : scrollTop;
      try {
        for (let i = 0; ; i++) {
          this.updateState = 1;
          let oldViewport = this.viewport;
          let refBlock = this.viewState.lineBlockAtHeight(refHeight);
          let changed = this.viewState.measure(this);
          if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
            break;
          if (i > 5) {
            console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
            break;
          }
          let measuring = [];
          if (!(changed & 4))
            [this.measureRequests, measuring] = [measuring, this.measureRequests];
          let measured = measuring.map((m2) => {
            try {
              return m2.read(this);
            } catch (e) {
              logException(this.state, e);
              return BadMeasure;
            }
          });
          let update = ViewUpdate.create(this, this.state, []), redrawn = false, scrolled = false;
          update.flags |= changed;
          if (!updated)
            updated = update;
          else
            updated.flags |= changed;
          this.updateState = 2;
          if (!update.empty) {
            this.updatePlugins(update);
            this.inputState.update(update);
            this.updateAttrs();
            redrawn = this.docView.update(update);
          }
          for (let i2 = 0; i2 < measuring.length; i2++)
            if (measured[i2] != BadMeasure) {
              try {
                let m2 = measuring[i2];
                if (m2.write)
                  m2.write(measured[i2], this);
              } catch (e) {
                logException(this.state, e);
              }
            }
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget);
              this.viewState.scrollTarget = null;
              scrolled = true;
            } else {
              let diff = this.viewState.lineBlockAt(refBlock.from).top - refBlock.top;
              if (diff > 1 || diff < -1) {
                this.scrollDOM.scrollTop += diff;
                scrolled = true;
              }
            }
          }
          if (redrawn)
            this.docView.updateSelection(true);
          if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to && !scrolled && this.measureRequests.length == 0)
            break;
        }
      } finally {
        this.updateState = 0;
        this.measureScheduled = -1;
      }
      if (updated && !updated.empty)
        for (let listener of this.state.facet(updateListener))
          listener(updated);
    }
    get themeClasses() {
      return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
    }
    updateAttrs() {
      let editorAttrs = attrsFromFacet(this, editorAttributes, {
        class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
      });
      let contentAttrs = {
        spellcheck: "false",
        autocorrect: "off",
        autocapitalize: "off",
        translate: "no",
        contenteditable: !this.state.facet(editable) ? "false" : "true",
        class: "cm-content",
        style: `${browser.tabSize}: ${this.state.tabSize}`,
        role: "textbox",
        "aria-multiline": "true"
      };
      if (this.state.readOnly)
        contentAttrs["aria-readonly"] = "true";
      attrsFromFacet(this, contentAttributes, contentAttrs);
      let changed = this.observer.ignore(() => {
        let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
        let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
        return changedContent || changedEditor;
      });
      this.editorAttrs = editorAttrs;
      this.contentAttrs = contentAttrs;
      return changed;
    }
    showAnnouncements(trs) {
      let first = true;
      for (let tr of trs)
        for (let effect of tr.effects)
          if (effect.is(EditorView.announce)) {
            if (first)
              this.announceDOM.textContent = "";
            first = false;
            let div = this.announceDOM.appendChild(document.createElement("div"));
            div.textContent = effect.value;
          }
    }
    mountStyles() {
      this.styleModules = this.state.facet(styleModule);
      StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse());
    }
    readMeasured() {
      if (this.updateState == 2)
        throw new Error("Reading the editor layout isn't allowed during an update");
      if (this.updateState == 0 && this.measureScheduled > -1)
        this.measure(false);
    }
    requestMeasure(request) {
      if (this.measureScheduled < 0)
        this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
      if (request) {
        if (request.key != null)
          for (let i = 0; i < this.measureRequests.length; i++) {
            if (this.measureRequests[i].key === request.key) {
              this.measureRequests[i] = request;
              return;
            }
          }
        this.measureRequests.push(request);
      }
    }
    plugin(plugin) {
      let known = this.pluginMap.get(plugin);
      if (known === void 0 || known && known.spec != plugin)
        this.pluginMap.set(plugin, known = this.plugins.find((p) => p.spec == plugin) || null);
      return known && known.update(this).value;
    }
    get documentTop() {
      return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    get documentPadding() {
      return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
    }
    elementAtHeight(height) {
      this.readMeasured();
      return this.viewState.elementAtHeight(height);
    }
    lineBlockAtHeight(height) {
      this.readMeasured();
      return this.viewState.lineBlockAtHeight(height);
    }
    get viewportLineBlocks() {
      return this.viewState.viewportLines;
    }
    lineBlockAt(pos) {
      return this.viewState.lineBlockAt(pos);
    }
    get contentHeight() {
      return this.viewState.contentHeight;
    }
    moveByChar(start, forward, by) {
      return skipAtoms(this, start, moveByChar(this, start, forward, by));
    }
    moveByGroup(start, forward) {
      return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
    }
    moveToLineBoundary(start, forward, includeWrap = true) {
      return moveToLineBoundary(this, start, forward, includeWrap);
    }
    moveVertically(start, forward, distance) {
      return skipAtoms(this, start, moveVertically(this, start, forward, distance));
    }
    domAtPos(pos) {
      return this.docView.domAtPos(pos);
    }
    posAtDOM(node, offset = 0) {
      return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords, precise = true) {
      this.readMeasured();
      return posAtCoords(this, coords, precise);
    }
    coordsAtPos(pos, side = 1) {
      this.readMeasured();
      let rect = this.docView.coordsAt(pos, side);
      if (!rect || rect.left == rect.right)
        return rect;
      let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
      let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
      return flattenRect(rect, span.dir == Direction.LTR == side > 0);
    }
    get defaultCharacterWidth() {
      return this.viewState.heightOracle.charWidth;
    }
    get defaultLineHeight() {
      return this.viewState.heightOracle.lineHeight;
    }
    get textDirection() {
      return this.viewState.defaultTextDirection;
    }
    textDirectionAt(pos) {
      let perLine = this.state.facet(perLineTextDirection);
      if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
        return this.textDirection;
      this.readMeasured();
      return this.docView.textDirectionAt(pos);
    }
    get lineWrapping() {
      return this.viewState.heightOracle.lineWrapping;
    }
    bidiSpans(line) {
      if (line.length > MaxBidiLine)
        return trivialOrder(line.length);
      let dir = this.textDirectionAt(line.from);
      for (let entry of this.bidiCache)
        if (entry.from == line.from && entry.dir == dir)
          return entry.order;
      let order = computeOrder(line.text, dir);
      this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));
      return order;
    }
    get hasFocus() {
      var _a2;
      return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
    }
    focus() {
      this.observer.ignore(() => {
        focusPreventScroll(this.contentDOM);
        this.docView.updateSelection();
      });
    }
    setRoot(root) {
      if (this._root != root) {
        this._root = root;
        this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
        this.mountStyles();
      }
    }
    destroy() {
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.plugins = [];
      this.inputState.destroy();
      this.dom.remove();
      this.observer.destroy();
      if (this.measureScheduled > -1)
        cancelAnimationFrame(this.measureScheduled);
      this.destroyed = true;
    }
    static scrollIntoView(pos, options = {}) {
      return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
    }
    static domEventHandlers(handlers2) {
      return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
    }
    static theme(spec, options) {
      let prefix = StyleModule.newName();
      let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
      if (options && options.dark)
        result.push(darkTheme.of(true));
      return result;
    }
    static baseTheme(spec) {
      return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
    static findFromDOM(dom) {
      var _a2;
      let content2 = dom.querySelector(".cm-content");
      let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
      return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
    }
  };
  EditorView.styleModule = styleModule;
  EditorView.inputHandler = inputHandler;
  EditorView.perLineTextDirection = perLineTextDirection;
  EditorView.exceptionSink = exceptionSink;
  EditorView.updateListener = updateListener;
  EditorView.editable = editable;
  EditorView.mouseSelectionStyle = mouseSelectionStyle;
  EditorView.dragMovesSelection = dragMovesSelection$1;
  EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
  EditorView.decorations = decorations;
  EditorView.atomicRanges = atomicRanges;
  EditorView.scrollMargins = scrollMargins;
  EditorView.darkTheme = darkTheme;
  EditorView.contentAttributes = contentAttributes;
  EditorView.editorAttributes = editorAttributes;
  EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
  EditorView.announce = /* @__PURE__ */ StateEffect.define();
  var MaxBidiLine = 4096;
  var BadMeasure = {};
  var CachedOrder = class {
    constructor(from3, to, dir, order) {
      this.from = from3;
      this.to = to;
      this.dir = dir;
      this.order = order;
    }
    static update(cache2, changes) {
      if (changes.empty)
        return cache2;
      let result = [], lastDir = cache2.length ? cache2[cache2.length - 1].dir : Direction.LTR;
      for (let i = Math.max(0, cache2.length - 10); i < cache2.length; i++) {
        let entry = cache2[i];
        if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
          result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
      }
      return result;
    }
  };
  function attrsFromFacet(view2, facet, base2) {
    for (let sources = view2.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
      let source = sources[i], value = typeof source == "function" ? source(view2) : source;
      if (value)
        combineAttrs(value, base2);
    }
    return base2;
  }
  var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
  function normalizeKeyName(name2, platform) {
    const parts = name2.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
      result = " ";
    let alt, ctrl, shift2, meta2;
    for (let i = 0; i < parts.length - 1; ++i) {
      const mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod))
        meta2 = true;
      else if (/^a(lt)?$/i.test(mod))
        alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod))
        ctrl = true;
      else if (/^s(hift)?$/i.test(mod))
        shift2 = true;
      else if (/^mod$/i.test(mod)) {
        if (platform == "mac")
          meta2 = true;
        else
          ctrl = true;
      } else
        throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
      result = "Alt-" + result;
    if (ctrl)
      result = "Ctrl-" + result;
    if (meta2)
      result = "Meta-" + result;
    if (shift2)
      result = "Shift-" + result;
    return result;
  }
  function modifiers(name2, event, shift2) {
    if (event.altKey)
      name2 = "Alt-" + name2;
    if (event.ctrlKey)
      name2 = "Ctrl-" + name2;
    if (event.metaKey)
      name2 = "Meta-" + name2;
    if (shift2 !== false && event.shiftKey)
      name2 = "Shift-" + name2;
    return name2;
  }
  var handleKeyEvents = /* @__PURE__ */ Prec.default(/* @__PURE__ */ EditorView.domEventHandlers({
    keydown(event, view2) {
      return runHandlers(getKeymap(view2.state), event, view2, "editor");
    }
  }));
  var keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
  var Keymaps = /* @__PURE__ */ new WeakMap();
  function getKeymap(state) {
    let bindings = state.facet(keymap);
    let map3 = Keymaps.get(bindings);
    if (!map3)
      Keymaps.set(bindings, map3 = buildKeymap(bindings.reduce((a2, b) => a2.concat(b), [])));
    return map3;
  }
  function runScopeHandlers(view2, event, scope) {
    return runHandlers(getKeymap(view2.state), event, view2, scope);
  }
  var storedPrefix = null;
  var PrefixTimeout = 4e3;
  function buildKeymap(bindings, platform = currentPlatform) {
    let bound = /* @__PURE__ */ Object.create(null);
    let isPrefix = /* @__PURE__ */ Object.create(null);
    let checkPrefix = (name2, is) => {
      let current = isPrefix[name2];
      if (current == null)
        isPrefix[name2] = is;
      else if (current != is)
        throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add3 = (scope, key, command2, preventDefault) => {
      var _a2, _b;
      let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
      let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
      for (let i = 1; i < parts.length; i++) {
        let prefix = parts.slice(0, i).join(" ");
        checkPrefix(prefix, true);
        if (!scopeObj[prefix])
          scopeObj[prefix] = {
            preventDefault: true,
            run: [(view2) => {
              let ourObj = storedPrefix = { view: view2, prefix, scope };
              setTimeout(() => {
                if (storedPrefix == ourObj)
                  storedPrefix = null;
              }, PrefixTimeout);
              return true;
            }]
          };
      }
      let full = parts.join(" ");
      checkPrefix(full, false);
      let binding = scopeObj[full] || (scopeObj[full] = { preventDefault: false, run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || [] });
      if (command2)
        binding.run.push(command2);
      if (preventDefault)
        binding.preventDefault = true;
    };
    for (let b of bindings) {
      let scopes = b.scope ? b.scope.split(" ") : ["editor"];
      if (b.any)
        for (let scope of scopes) {
          let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
          if (!scopeObj._any)
            scopeObj._any = { preventDefault: false, run: [] };
          for (let key in scopeObj)
            scopeObj[key].run.push(b.any);
        }
      let name2 = b[platform] || b.key;
      if (!name2)
        continue;
      for (let scope of scopes) {
        add3(scope, name2, b.run, b.preventDefault);
        if (b.shift)
          add3(scope, "Shift-" + name2, b.shift, b.preventDefault);
      }
    }
    return bound;
  }
  function runHandlers(map3, event, view2, scope) {
    let name2 = keyName(event);
    let charCode = codePointAt(name2, 0), isChar = codePointSize(charCode) == name2.length && name2 != " ";
    let prefix = "", fallthrough = false;
    if (storedPrefix && storedPrefix.view == view2 && storedPrefix.scope == scope) {
      prefix = storedPrefix.prefix + " ";
      if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0)
        storedPrefix = null;
    }
    let ran = /* @__PURE__ */ new Set();
    let runFor = (binding) => {
      if (binding) {
        for (let cmd2 of binding.run)
          if (!ran.has(cmd2)) {
            ran.add(cmd2);
            if (cmd2(view2, event))
              return true;
          }
        if (binding.preventDefault)
          fallthrough = true;
      }
      return false;
    };
    let scopeObj = map3[scope], baseName, shiftName;
    if (scopeObj) {
      if (runFor(scopeObj[prefix + modifiers(name2, event, !isChar)]))
        return true;
      if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && (baseName = base[event.keyCode]) && baseName != name2) {
        if (runFor(scopeObj[prefix + modifiers(baseName, event, true)]))
          return true;
        else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)]))
          return true;
      } else if (isChar && event.shiftKey) {
        if (runFor(scopeObj[prefix + modifiers(name2, event, true)]))
          return true;
      }
      if (runFor(scopeObj._any))
        return true;
    }
    return fallthrough;
  }
  var RectangleMarker = class {
    constructor(className, left, top2, width, height) {
      this.className = className;
      this.left = left;
      this.top = top2;
      this.width = width;
      this.height = height;
    }
    draw() {
      let elt2 = document.createElement("div");
      elt2.className = this.className;
      this.adjust(elt2);
      return elt2;
    }
    update(elt2, prev) {
      if (prev.className != this.className)
        return false;
      this.adjust(elt2);
      return true;
    }
    adjust(elt2) {
      elt2.style.left = this.left + "px";
      elt2.style.top = this.top + "px";
      if (this.width >= 0)
        elt2.style.width = this.width + "px";
      elt2.style.height = this.height + "px";
    }
    eq(p) {
      return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
    }
  };
  function sameMarker(a2, b) {
    return a2.constructor == b.constructor && a2.eq(b);
  }
  var LayerView = class {
    constructor(view2, layer2) {
      this.view = view2;
      this.layer = layer2;
      this.drawn = [];
      this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
      this.dom = view2.scrollDOM.appendChild(document.createElement("div"));
      this.dom.classList.add("cm-layer");
      if (layer2.above)
        this.dom.classList.add("cm-layer-above");
      if (layer2.class)
        this.dom.classList.add(layer2.class);
      this.dom.setAttribute("aria-hidden", "true");
      this.setOrder(view2.state);
      view2.requestMeasure(this.measureReq);
      if (layer2.mount)
        layer2.mount(this.dom, view2);
    }
    update(update) {
      if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
        this.setOrder(update.state);
      if (this.layer.update(update, this.dom) || update.geometryChanged)
        update.view.requestMeasure(this.measureReq);
    }
    setOrder(state) {
      let pos = 0, order = state.facet(layerOrder);
      while (pos < order.length && order[pos] != this.layer)
        pos++;
      this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
    }
    measure() {
      return this.layer.markers(this.view);
    }
    draw(markers) {
      if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {
        let old = this.dom.firstChild, oldI = 0;
        for (let marker of markers) {
          if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
            old = old.nextSibling;
            oldI++;
          } else {
            this.dom.insertBefore(marker.draw(), old);
          }
        }
        while (old) {
          let next = old.nextSibling;
          old.remove();
          old = next;
        }
        this.drawn = markers;
      }
    }
    destroy() {
      this.dom.remove();
    }
  };
  var layerOrder = /* @__PURE__ */ Facet.define();
  function layer(config2) {
    return [
      ViewPlugin.define((v) => new LayerView(v, config2)),
      layerOrder.of(config2)
    ];
  }
  var CanHidePrimary = !browser.ios;
  var selectionConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        cursorBlinkRate: 1200,
        drawRangeCursor: true
      }, {
        cursorBlinkRate: (a2, b) => Math.min(a2, b),
        drawRangeCursor: (a2, b) => a2 || b
      });
    }
  });
  function drawSelection(config2 = {}) {
    return [
      selectionConfig.of(config2),
      cursorLayer,
      selectionLayer,
      hideNativeSelection,
      nativeSelectionHidden.of(true)
    ];
  }
  function configChanged(update) {
    return update.startState.facet(selectionConfig) != update.startState.facet(selectionConfig);
  }
  var cursorLayer = /* @__PURE__ */ layer({
    above: true,
    markers(view2) {
      let { state } = view2, conf = state.facet(selectionConfig);
      let cursors = [];
      for (let r of state.selection.ranges) {
        let prim = r == state.selection.main;
        if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
          let piece = measureCursor(view2, r, prim);
          if (piece)
            cursors.push(piece);
        }
      }
      return cursors;
    },
    update(update, dom) {
      if (update.transactions.some((tr) => tr.scrollIntoView))
        dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
      let confChange = configChanged(update);
      if (confChange)
        setBlinkRate(update.state, dom);
      return update.docChanged || update.selectionSet || confChange;
    },
    mount(dom, view2) {
      setBlinkRate(view2.state, dom);
    },
    class: "cm-cursorLayer"
  });
  function setBlinkRate(state, dom) {
    dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
  }
  var selectionLayer = /* @__PURE__ */ layer({
    above: false,
    markers(view2) {
      return view2.state.selection.ranges.map((r) => r.empty ? [] : measureRange(view2, r)).reduce((a2, b) => a2.concat(b));
    },
    update(update, dom) {
      return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
    },
    class: "cm-selectionLayer"
  });
  var themeSpec = {
    ".cm-line": {
      "& ::selection": { backgroundColor: "transparent !important" },
      "&::selection": { backgroundColor: "transparent !important" }
    }
  };
  if (CanHidePrimary)
    themeSpec[".cm-line"].caretColor = "transparent !important";
  var hideNativeSelection = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.theme(themeSpec));
  function getBase(view2) {
    let rect = view2.scrollDOM.getBoundingClientRect();
    let left = view2.textDirection == Direction.LTR ? rect.left : rect.right - view2.scrollDOM.clientWidth;
    return { left: left - view2.scrollDOM.scrollLeft, top: rect.top - view2.scrollDOM.scrollTop };
  }
  function wrappedLine(view2, pos, inside2) {
    let range = EditorSelection.cursor(pos);
    return {
      from: Math.max(inside2.from, view2.moveToLineBoundary(range, false, true).from),
      to: Math.min(inside2.to, view2.moveToLineBoundary(range, true, true).from),
      type: BlockType.Text
    };
  }
  function blockAt(view2, pos) {
    let line = view2.lineBlockAt(pos);
    if (Array.isArray(line.type))
      for (let l of line.type) {
        if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))
          return l;
      }
    return line;
  }
  function measureRange(view2, range) {
    if (range.to <= view2.viewport.from || range.from >= view2.viewport.to)
      return [];
    let from3 = Math.max(range.from, view2.viewport.from), to = Math.min(range.to, view2.viewport.to);
    let ltr = view2.textDirection == Direction.LTR;
    let content2 = view2.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view2);
    let lineStyle = window.getComputedStyle(content2.firstChild);
    let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent));
    let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);
    let startBlock = blockAt(view2, from3), endBlock = blockAt(view2, to);
    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
    if (view2.lineWrapping) {
      if (visualStart)
        visualStart = wrappedLine(view2, from3, visualStart);
      if (visualEnd)
        visualEnd = wrappedLine(view2, to, visualEnd);
    }
    if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
      return pieces(drawForLine(range.from, range.to, visualStart));
    } else {
      let top2 = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
      let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
      let between = [];
      if ((visualStart || startBlock).to < (visualEnd || endBlock).from - 1)
        between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
      else if (top2.bottom < bottom.top && view2.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text)
        top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
      return pieces(top2).concat(between).concat(pieces(bottom));
    }
    function piece(left, top2, right, bottom) {
      return new RectangleMarker("cm-selectionBackground", left - base2.left, top2 - base2.top - 0.01, right - left, bottom - top2 + 0.01);
    }
    function pieces({ top: top2, bottom, horizontal }) {
      let pieces2 = [];
      for (let i = 0; i < horizontal.length; i += 2)
        pieces2.push(piece(horizontal[i], top2, horizontal[i + 1], bottom));
      return pieces2;
    }
    function drawForLine(from4, to2, line) {
      let top2 = 1e9, bottom = -1e9, horizontal = [];
      function addSpan(from5, fromOpen, to3, toOpen, dir) {
        let fromCoords = view2.coordsAtPos(from5, from5 == line.to ? -2 : 2);
        let toCoords = view2.coordsAtPos(to3, to3 == line.from ? 2 : -2);
        top2 = Math.min(fromCoords.top, toCoords.top, top2);
        bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
        if (dir == Direction.LTR)
          horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
        else
          horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
      }
      let start = from4 !== null && from4 !== void 0 ? from4 : line.from, end = to2 !== null && to2 !== void 0 ? to2 : line.to;
      for (let r of view2.visibleRanges)
        if (r.to > start && r.from < end) {
          for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end); ; ) {
            let docLine = view2.state.doc.lineAt(pos);
            for (let span of view2.bidiSpans(docLine)) {
              let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
              if (spanFrom >= endPos)
                break;
              if (spanTo > pos)
                addSpan(Math.max(spanFrom, pos), from4 == null && spanFrom <= start, Math.min(spanTo, endPos), to2 == null && spanTo >= end, span.dir);
            }
            pos = docLine.to + 1;
            if (pos >= endPos)
              break;
          }
        }
      if (horizontal.length == 0)
        addSpan(start, from4 == null, end, to2 == null, view2.textDirection);
      return { top: top2, bottom, horizontal };
    }
    function drawForWidget(block, top2) {
      let y3 = contentRect.top + (top2 ? block.top : block.bottom);
      return { top: y3, bottom: y3, horizontal: [] };
    }
  }
  function measureCursor(view2, cursor, primary) {
    let pos = view2.coordsAtPos(cursor.head, cursor.assoc || 1);
    if (!pos)
      return null;
    let base2 = getBase(view2);
    return new RectangleMarker(primary ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", pos.left - base2.left, pos.top - base2.top, -1, pos.bottom - pos.top);
  }
  var setDropCursorPos = /* @__PURE__ */ StateEffect.define({
    map(pos, mapping) {
      return pos == null ? null : mapping.mapPos(pos);
    }
  });
  var dropCursorPos = /* @__PURE__ */ StateField.define({
    create() {
      return null;
    },
    update(pos, tr) {
      if (pos != null)
        pos = tr.changes.mapPos(pos);
      return tr.effects.reduce((pos2, e) => e.is(setDropCursorPos) ? e.value : pos2, pos);
    }
  });
  var drawDropCursor = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view2) {
      this.view = view2;
      this.cursor = null;
      this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
    }
    update(update) {
      var _a2;
      let cursorPos = update.state.field(dropCursorPos);
      if (cursorPos == null) {
        if (this.cursor != null) {
          (_a2 = this.cursor) === null || _a2 === void 0 ? void 0 : _a2.remove();
          this.cursor = null;
        }
      } else {
        if (!this.cursor) {
          this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
          this.cursor.className = "cm-dropCursor";
        }
        if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
          this.view.requestMeasure(this.measureReq);
      }
    }
    readPos() {
      let pos = this.view.state.field(dropCursorPos);
      let rect = pos != null && this.view.coordsAtPos(pos);
      if (!rect)
        return null;
      let outer = this.view.scrollDOM.getBoundingClientRect();
      return {
        left: rect.left - outer.left + this.view.scrollDOM.scrollLeft,
        top: rect.top - outer.top + this.view.scrollDOM.scrollTop,
        height: rect.bottom - rect.top
      };
    }
    drawCursor(pos) {
      if (this.cursor) {
        if (pos) {
          this.cursor.style.left = pos.left + "px";
          this.cursor.style.top = pos.top + "px";
          this.cursor.style.height = pos.height + "px";
        } else {
          this.cursor.style.left = "-100000px";
        }
      }
    }
    destroy() {
      if (this.cursor)
        this.cursor.remove();
    }
    setDropPos(pos) {
      if (this.view.state.field(dropCursorPos) != pos)
        this.view.dispatch({ effects: setDropCursorPos.of(pos) });
    }
  }, {
    eventHandlers: {
      dragover(event) {
        this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
      },
      dragleave(event) {
        if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
          this.setDropPos(null);
      },
      dragend() {
        this.setDropPos(null);
      },
      drop() {
        this.setDropPos(null);
      }
    }
  });
  function dropCursor() {
    return [dropCursorPos, drawDropCursor];
  }
  function iterMatches(doc3, re, from3, to, f) {
    re.lastIndex = 0;
    for (let cursor = doc3.iterRange(from3, to), pos = from3, m2; !cursor.next().done; pos += cursor.value.length) {
      if (!cursor.lineBreak)
        while (m2 = re.exec(cursor.value))
          f(pos + m2.index, m2);
    }
  }
  function matchRanges(view2, maxLength) {
    let visible = view2.visibleRanges;
    if (visible.length == 1 && visible[0].from == view2.viewport.from && visible[0].to == view2.viewport.to)
      return visible;
    let result = [];
    for (let { from: from3, to } of visible) {
      from3 = Math.max(view2.state.doc.lineAt(from3).from, from3 - maxLength);
      to = Math.min(view2.state.doc.lineAt(to).to, to + maxLength);
      if (result.length && result[result.length - 1].to >= from3)
        result[result.length - 1].to = to;
      else
        result.push({ from: from3, to });
    }
    return result;
  }
  var MatchDecorator = class {
    constructor(config2) {
      const { regexp, decoration, decorate, boundary, maxLength = 1e3 } = config2;
      if (!regexp.global)
        throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
      this.regexp = regexp;
      if (decorate) {
        this.addMatch = (match, view2, from3, add3) => decorate(add3, from3, from3 + match[0].length, match, view2);
      } else if (typeof decoration == "function") {
        this.addMatch = (match, view2, from3, add3) => {
          let deco = decoration(match, view2, from3);
          if (deco)
            add3(from3, from3 + match[0].length, deco);
        };
      } else if (decoration) {
        this.addMatch = (match, _view, from3, add3) => add3(from3, from3 + match[0].length, decoration);
      } else {
        throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
      }
      this.boundary = boundary;
      this.maxLength = maxLength;
    }
    createDeco(view2) {
      let build = new RangeSetBuilder(), add3 = build.add.bind(build);
      for (let { from: from3, to } of matchRanges(view2, this.maxLength))
        iterMatches(view2.state.doc, this.regexp, from3, to, (from4, m2) => this.addMatch(m2, view2, from4, add3));
      return build.finish();
    }
    updateDeco(update, deco) {
      let changeFrom = 1e9, changeTo = -1;
      if (update.docChanged)
        update.changes.iterChanges((_f, _t, from3, to) => {
          if (to > update.view.viewport.from && from3 < update.view.viewport.to) {
            changeFrom = Math.min(from3, changeFrom);
            changeTo = Math.max(to, changeTo);
          }
        });
      if (update.viewportChanged || changeTo - changeFrom > 1e3)
        return this.createDeco(update.view);
      if (changeTo > -1)
        return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
      return deco;
    }
    updateRange(view2, deco, updateFrom, updateTo) {
      for (let r of view2.visibleRanges) {
        let from3 = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
        if (to > from3) {
          let fromLine = view2.state.doc.lineAt(from3), toLine = fromLine.to < to ? view2.state.doc.lineAt(to) : fromLine;
          let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
          if (this.boundary) {
            for (; from3 > fromLine.from; from3--)
              if (this.boundary.test(fromLine.text[from3 - 1 - fromLine.from])) {
                start = from3;
                break;
              }
            for (; to < toLine.to; to++)
              if (this.boundary.test(toLine.text[to - toLine.from])) {
                end = to;
                break;
              }
          }
          let ranges = [], m2;
          let add3 = (from4, to2, deco2) => ranges.push(deco2.range(from4, to2));
          if (fromLine == toLine) {
            this.regexp.lastIndex = start - fromLine.from;
            while ((m2 = this.regexp.exec(fromLine.text)) && m2.index < end - fromLine.from)
              this.addMatch(m2, view2, m2.index + fromLine.from, add3);
          } else {
            iterMatches(view2.state.doc, this.regexp, start, end, (from4, m3) => this.addMatch(m3, view2, from4, add3));
          }
          deco = deco.update({ filterFrom: start, filterTo: end, filter: (from4, to2) => from4 < start || to2 > end, add: ranges });
        }
      }
      return deco;
    }
  };
  var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
  var Specials = /* @__PURE__ */ new RegExp("[\0-\b\n-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]", UnicodeRegexpSupport);
  var Names = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8294: "left-to-right isolate",
    8295: "right-to-left isolate",
    8297: "pop directional isolate",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
  };
  var _supportsTabSize = null;
  function supportsTabSize() {
    var _a2;
    if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
      let styles = document.body.style;
      _supportsTabSize = ((_a2 = styles.tabSize) !== null && _a2 !== void 0 ? _a2 : styles.MozTabSize) != null;
    }
    return _supportsTabSize || false;
  }
  var specialCharConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      let config2 = combineConfig(configs, {
        render: null,
        specialChars: Specials,
        addSpecialChars: null
      });
      if (config2.replaceTabs = !supportsTabSize())
        config2.specialChars = new RegExp("	|" + config2.specialChars.source, UnicodeRegexpSupport);
      if (config2.addSpecialChars)
        config2.specialChars = new RegExp(config2.specialChars.source + "|" + config2.addSpecialChars.source, UnicodeRegexpSupport);
      return config2;
    }
  });
  function highlightSpecialChars(config2 = {}) {
    return [specialCharConfig.of(config2), specialCharPlugin()];
  }
  var _plugin = null;
  function specialCharPlugin() {
    return _plugin || (_plugin = ViewPlugin.fromClass(class {
      constructor(view2) {
        this.view = view2;
        this.decorations = Decoration.none;
        this.decorationCache = /* @__PURE__ */ Object.create(null);
        this.decorator = this.makeDecorator(view2.state.facet(specialCharConfig));
        this.decorations = this.decorator.createDeco(view2);
      }
      makeDecorator(conf) {
        return new MatchDecorator({
          regexp: conf.specialChars,
          decoration: (m2, view2, pos) => {
            let { doc: doc3 } = view2.state;
            let code = codePointAt(m2[0], 0);
            if (code == 9) {
              let line = doc3.lineAt(pos);
              let size = view2.state.tabSize, col = countColumn(line.text, size, pos - line.from);
              return Decoration.replace({ widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth) });
            }
            return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
          },
          boundary: conf.replaceTabs ? void 0 : /[^]/
        });
      }
      update(update) {
        let conf = update.state.facet(specialCharConfig);
        if (update.startState.facet(specialCharConfig) != conf) {
          this.decorator = this.makeDecorator(conf);
          this.decorations = this.decorator.createDeco(update.view);
        } else {
          this.decorations = this.decorator.updateDeco(update, this.decorations);
        }
      }
    }, {
      decorations: (v) => v.decorations
    }));
  }
  var DefaultPlaceholder = "\u2022";
  function placeholder$1(code) {
    if (code >= 32)
      return DefaultPlaceholder;
    if (code == 10)
      return "\u2424";
    return String.fromCharCode(9216 + code);
  }
  var SpecialCharWidget = class extends WidgetType {
    constructor(options, code) {
      super();
      this.options = options;
      this.code = code;
    }
    eq(other) {
      return other.code == this.code;
    }
    toDOM(view2) {
      let ph = placeholder$1(this.code);
      let desc = view2.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
      let custom = this.options.render && this.options.render(this.code, desc, ph);
      if (custom)
        return custom;
      let span = document.createElement("span");
      span.textContent = ph;
      span.title = desc;
      span.setAttribute("aria-label", desc);
      span.className = "cm-specialChar";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  };
  var TabWidget = class extends WidgetType {
    constructor(width) {
      super();
      this.width = width;
    }
    eq(other) {
      return other.width == this.width;
    }
    toDOM() {
      let span = document.createElement("span");
      span.textContent = "	";
      span.className = "cm-tab";
      span.style.width = this.width + "px";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  };
  function highlightActiveLine() {
    return activeLineHighlighter;
  }
  var lineDeco = /* @__PURE__ */ Decoration.line({ class: "cm-activeLine" });
  var activeLineHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view2) {
      this.decorations = this.getDeco(view2);
    }
    update(update) {
      if (update.docChanged || update.selectionSet)
        this.decorations = this.getDeco(update.view);
    }
    getDeco(view2) {
      let lastLineStart = -1, deco = [];
      for (let r of view2.state.selection.ranges) {
        let line = view2.lineBlockAt(r.head);
        if (line.from > lastLineStart) {
          deco.push(lineDeco.range(line.from));
          lastLineStart = line.from;
        }
      }
      return Decoration.set(deco);
    }
  }, {
    decorations: (v) => v.decorations
  });
  var MaxOff = 2e3;
  function rectangleFor(state, a2, b) {
    let startLine = Math.min(a2.line, b.line), endLine = Math.max(a2.line, b.line);
    let ranges = [];
    if (a2.off > MaxOff || b.off > MaxOff || a2.col < 0 || b.col < 0) {
      let startOff = Math.min(a2.off, b.off), endOff = Math.max(a2.off, b.off);
      for (let i = startLine; i <= endLine; i++) {
        let line = state.doc.line(i);
        if (line.length <= endOff)
          ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
      }
    } else {
      let startCol = Math.min(a2.col, b.col), endCol = Math.max(a2.col, b.col);
      for (let i = startLine; i <= endLine; i++) {
        let line = state.doc.line(i);
        let start = findColumn(line.text, startCol, state.tabSize, true);
        if (start < 0) {
          ranges.push(EditorSelection.cursor(line.to));
        } else {
          let end = findColumn(line.text, endCol, state.tabSize);
          ranges.push(EditorSelection.range(line.from + start, line.from + end));
        }
      }
    }
    return ranges;
  }
  function absoluteColumn(view2, x3) {
    let ref = view2.coordsAtPos(view2.viewport.from);
    return ref ? Math.round(Math.abs((ref.left - x3) / view2.defaultCharacterWidth)) : -1;
  }
  function getPos(view2, event) {
    let offset = view2.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    let line = view2.state.doc.lineAt(offset), off = offset - line.from;
    let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view2, event.clientX) : countColumn(line.text, view2.state.tabSize, offset - line.from);
    return { line: line.number, col, off };
  }
  function rectangleSelectionStyle(view2, event) {
    let start = getPos(view2, event), startSel = view2.state.selection;
    if (!start)
      return null;
    return {
      update(update) {
        if (update.docChanged) {
          let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
          let newLine = update.state.doc.lineAt(newStart);
          start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
          startSel = startSel.map(update.changes);
        }
      },
      get(event2, _extend, multiple) {
        let cur2 = getPos(view2, event2);
        if (!cur2)
          return startSel;
        let ranges = rectangleFor(view2.state, start, cur2);
        if (!ranges.length)
          return startSel;
        if (multiple)
          return EditorSelection.create(ranges.concat(startSel.ranges));
        else
          return EditorSelection.create(ranges);
      }
    };
  }
  function rectangularSelection(options) {
    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || ((e) => e.altKey && e.button == 0);
    return EditorView.mouseSelectionStyle.of((view2, event) => filter(event) ? rectangleSelectionStyle(view2, event) : null);
  }
  var keys = {
    Alt: [18, (e) => e.altKey],
    Control: [17, (e) => e.ctrlKey],
    Shift: [16, (e) => e.shiftKey],
    Meta: [91, (e) => e.metaKey]
  };
  var showCrosshair = { style: "cursor: crosshair" };
  function crosshairCursor(options = {}) {
    let [code, getter] = keys[options.key || "Alt"];
    let plugin = ViewPlugin.fromClass(class {
      constructor(view2) {
        this.view = view2;
        this.isDown = false;
      }
      set(isDown) {
        if (this.isDown != isDown) {
          this.isDown = isDown;
          this.view.update([]);
        }
      }
    }, {
      eventHandlers: {
        keydown(e) {
          this.set(e.keyCode == code || getter(e));
        },
        keyup(e) {
          if (e.keyCode == code || !getter(e))
            this.set(false);
        },
        mousemove(e) {
          this.set(getter(e));
        }
      }
    });
    return [
      plugin,
      EditorView.contentAttributes.of((view2) => {
        var _a2;
        return ((_a2 = view2.plugin(plugin)) === null || _a2 === void 0 ? void 0 : _a2.isDown) ? showCrosshair : null;
      })
    ];
  }
  var Outside = "-10000px";
  var TooltipViewManager = class {
    constructor(view2, facet, createTooltipView) {
      this.facet = facet;
      this.createTooltipView = createTooltipView;
      this.input = view2.state.facet(facet);
      this.tooltips = this.input.filter((t2) => t2);
      this.tooltipViews = this.tooltips.map(createTooltipView);
    }
    update(update) {
      var _a2;
      let input = update.state.facet(this.facet);
      let tooltips = input.filter((x3) => x3);
      if (input === this.input) {
        for (let t2 of this.tooltipViews)
          if (t2.update)
            t2.update(update);
        return false;
      }
      let tooltipViews = [];
      for (let i = 0; i < tooltips.length; i++) {
        let tip = tooltips[i], known = -1;
        if (!tip)
          continue;
        for (let i2 = 0; i2 < this.tooltips.length; i2++) {
          let other = this.tooltips[i2];
          if (other && other.create == tip.create)
            known = i2;
        }
        if (known < 0) {
          tooltipViews[i] = this.createTooltipView(tip);
        } else {
          let tooltipView = tooltipViews[i] = this.tooltipViews[known];
          if (tooltipView.update)
            tooltipView.update(update);
        }
      }
      for (let t2 of this.tooltipViews)
        if (tooltipViews.indexOf(t2) < 0) {
          t2.dom.remove();
          (_a2 = t2.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t2);
        }
      this.input = input;
      this.tooltips = tooltips;
      this.tooltipViews = tooltipViews;
      return true;
    }
  };
  function windowSpace(view2) {
    let { win } = view2;
    return { top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth };
  }
  var tooltipConfig = /* @__PURE__ */ Facet.define({
    combine: (values2) => {
      var _a2, _b, _c;
      return {
        position: browser.ios ? "absolute" : ((_a2 = values2.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
        parent: ((_b = values2.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
        tooltipSpace: ((_c = values2.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
      };
    }
  });
  var tooltipPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view2) {
      this.view = view2;
      this.inView = true;
      this.lastTransaction = 0;
      this.measureTimeout = -1;
      let config2 = view2.state.facet(tooltipConfig);
      this.position = config2.position;
      this.parent = config2.parent;
      this.classes = view2.themeClasses;
      this.createContainer();
      this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
      this.manager = new TooltipViewManager(view2, showTooltip, (t2) => this.createTooltip(t2));
      this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
        if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
          this.measureSoon();
      }, { threshold: [1] }) : null;
      this.observeIntersection();
      view2.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
      this.maybeMeasure();
    }
    createContainer() {
      if (this.parent) {
        this.container = document.createElement("div");
        this.container.style.position = "relative";
        this.container.className = this.view.themeClasses;
        this.parent.appendChild(this.container);
      } else {
        this.container = this.view.dom;
      }
    }
    observeIntersection() {
      if (this.intersectionObserver) {
        this.intersectionObserver.disconnect();
        for (let tooltip of this.manager.tooltipViews)
          this.intersectionObserver.observe(tooltip.dom);
      }
    }
    measureSoon() {
      if (this.measureTimeout < 0)
        this.measureTimeout = setTimeout(() => {
          this.measureTimeout = -1;
          this.maybeMeasure();
        }, 50);
    }
    update(update) {
      if (update.transactions.length)
        this.lastTransaction = Date.now();
      let updated = this.manager.update(update);
      if (updated)
        this.observeIntersection();
      let shouldMeasure = updated || update.geometryChanged;
      let newConfig = update.state.facet(tooltipConfig);
      if (newConfig.position != this.position) {
        this.position = newConfig.position;
        for (let t2 of this.manager.tooltipViews)
          t2.dom.style.position = this.position;
        shouldMeasure = true;
      }
      if (newConfig.parent != this.parent) {
        if (this.parent)
          this.container.remove();
        this.parent = newConfig.parent;
        this.createContainer();
        for (let t2 of this.manager.tooltipViews)
          this.container.appendChild(t2.dom);
        shouldMeasure = true;
      } else if (this.parent && this.view.themeClasses != this.classes) {
        this.classes = this.container.className = this.view.themeClasses;
      }
      if (shouldMeasure)
        this.maybeMeasure();
    }
    createTooltip(tooltip) {
      let tooltipView = tooltip.create(this.view);
      tooltipView.dom.classList.add("cm-tooltip");
      if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
        let arrow = document.createElement("div");
        arrow.className = "cm-tooltip-arrow";
        tooltipView.dom.appendChild(arrow);
      }
      tooltipView.dom.style.position = this.position;
      tooltipView.dom.style.top = Outside;
      this.container.appendChild(tooltipView.dom);
      if (tooltipView.mount)
        tooltipView.mount(this.view);
      return tooltipView;
    }
    destroy() {
      var _a2, _b;
      this.view.win.removeEventListener("resize", this.measureSoon);
      for (let tooltipView of this.manager.tooltipViews) {
        tooltipView.dom.remove();
        (_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView);
      }
      (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
      clearTimeout(this.measureTimeout);
    }
    readMeasure() {
      let editor2 = this.view.dom.getBoundingClientRect();
      return {
        editor: editor2,
        parent: this.parent ? this.container.getBoundingClientRect() : editor2,
        pos: this.manager.tooltips.map((t2, i) => {
          let tv = this.manager.tooltipViews[i];
          return tv.getCoords ? tv.getCoords(t2.pos) : this.view.coordsAtPos(t2.pos);
        }),
        size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
        space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view)
      };
    }
    writeMeasure(measured) {
      let { editor: editor2, space: space4 } = measured;
      let others = [];
      for (let i = 0; i < this.manager.tooltips.length; i++) {
        let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;
        let pos = measured.pos[i], size = measured.size[i];
        if (!pos || pos.bottom <= Math.max(editor2.top, space4.top) || pos.top >= Math.min(editor2.bottom, space4.bottom) || pos.right < Math.max(editor2.left, space4.left) - 0.1 || pos.left > Math.min(editor2.right, space4.right) + 0.1) {
          dom.style.top = Outside;
          continue;
        }
        let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
        let arrowHeight = arrow ? 7 : 0;
        let width = size.right - size.left, height = size.bottom - size.top;
        let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
        let left = size.width > space4.right - space4.left ? ltr ? space4.left : space4.right - size.width : ltr ? Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space4.right - width) : Math.max(space4.left, pos.left - width + (arrow ? 14 : 0) - offset.x);
        let above = !!tooltip.above;
        if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space4.top : pos.bottom + (size.bottom - size.top) + offset.y > space4.bottom) && above == space4.bottom - pos.bottom > pos.top - space4.top)
          above = !above;
        let spaceVert = (above ? pos.top - space4.top : space4.bottom - pos.bottom) - arrowHeight;
        if (spaceVert < height && tView.resize !== false) {
          if (spaceVert < this.view.defaultLineHeight) {
            dom.style.top = Outside;
            continue;
          }
          dom.style.height = (height = spaceVert) + "px";
        } else if (dom.style.height) {
          dom.style.height = "";
        }
        let top2 = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
        let right = left + width;
        if (tView.overlap !== true) {
          for (let r of others)
            if (r.left < right && r.right > left && r.top < top2 + height && r.bottom > top2)
              top2 = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
        }
        if (this.position == "absolute") {
          dom.style.top = top2 - measured.parent.top + "px";
          dom.style.left = left - measured.parent.left + "px";
        } else {
          dom.style.top = top2 + "px";
          dom.style.left = left + "px";
        }
        if (arrow)
          arrow.style.left = `${pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7)}px`;
        if (tView.overlap !== true)
          others.push({ left, top: top2, right, bottom: top2 + height });
        dom.classList.toggle("cm-tooltip-above", above);
        dom.classList.toggle("cm-tooltip-below", !above);
        if (tView.positioned)
          tView.positioned(measured.space);
      }
    }
    maybeMeasure() {
      if (this.manager.tooltips.length) {
        if (this.view.inView)
          this.view.requestMeasure(this.measureReq);
        if (this.inView != this.view.inView) {
          this.inView = this.view.inView;
          if (!this.inView)
            for (let tv of this.manager.tooltipViews)
              tv.dom.style.top = Outside;
        }
      }
    }
  }, {
    eventHandlers: {
      scroll() {
        this.maybeMeasure();
      }
    }
  });
  var baseTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip": {
      zIndex: 100,
      boxSizing: "border-box"
    },
    "&light .cm-tooltip": {
      border: "1px solid #bbb",
      backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
      borderTop: "1px solid #bbb"
    },
    "&dark .cm-tooltip": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tooltip-arrow": {
      height: `${7}px`,
      width: `${7 * 2}px`,
      position: "absolute",
      zIndex: -1,
      overflow: "hidden",
      "&:before, &:after": {
        content: "''",
        position: "absolute",
        width: 0,
        height: 0,
        borderLeft: `${7}px solid transparent`,
        borderRight: `${7}px solid transparent`
      },
      ".cm-tooltip-above &": {
        bottom: `-${7}px`,
        "&:before": {
          borderTop: `${7}px solid #bbb`
        },
        "&:after": {
          borderTop: `${7}px solid #f5f5f5`,
          bottom: "1px"
        }
      },
      ".cm-tooltip-below &": {
        top: `-${7}px`,
        "&:before": {
          borderBottom: `${7}px solid #bbb`
        },
        "&:after": {
          borderBottom: `${7}px solid #f5f5f5`,
          top: "1px"
        }
      }
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
      "&:before": {
        borderTopColor: "#333338",
        borderBottomColor: "#333338"
      },
      "&:after": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      }
    }
  });
  var noOffset = { x: 0, y: 0 };
  var showTooltip = /* @__PURE__ */ Facet.define({
    enables: [tooltipPlugin, baseTheme]
  });
  var showHoverTooltip = /* @__PURE__ */ Facet.define();
  var HoverTooltipHost = class {
    constructor(view2) {
      this.view = view2;
      this.mounted = false;
      this.dom = document.createElement("div");
      this.dom.classList.add("cm-tooltip-hover");
      this.manager = new TooltipViewManager(view2, showHoverTooltip, (t2) => this.createHostedView(t2));
    }
    static create(view2) {
      return new HoverTooltipHost(view2);
    }
    createHostedView(tooltip) {
      let hostedView = tooltip.create(this.view);
      hostedView.dom.classList.add("cm-tooltip-section");
      this.dom.appendChild(hostedView.dom);
      if (this.mounted && hostedView.mount)
        hostedView.mount(this.view);
      return hostedView;
    }
    mount(view2) {
      for (let hostedView of this.manager.tooltipViews) {
        if (hostedView.mount)
          hostedView.mount(view2);
      }
      this.mounted = true;
    }
    positioned(space4) {
      for (let hostedView of this.manager.tooltipViews) {
        if (hostedView.positioned)
          hostedView.positioned(space4);
      }
    }
    update(update) {
      this.manager.update(update);
    }
  };
  var showHoverTooltipHost = /* @__PURE__ */ showTooltip.compute([showHoverTooltip], (state) => {
    let tooltips = state.facet(showHoverTooltip).filter((t2) => t2);
    if (tooltips.length === 0)
      return null;
    return {
      pos: Math.min(...tooltips.map((t2) => t2.pos)),
      end: Math.max(...tooltips.filter((t2) => t2.end != null).map((t2) => t2.end)),
      create: HoverTooltipHost.create,
      above: tooltips[0].above,
      arrow: tooltips.some((t2) => t2.arrow)
    };
  });
  var HoverPlugin = class {
    constructor(view2, source, field, setHover, hoverTime) {
      this.view = view2;
      this.source = source;
      this.field = field;
      this.setHover = setHover;
      this.hoverTime = hoverTime;
      this.hoverTimeout = -1;
      this.restartTimeout = -1;
      this.pending = null;
      this.lastMove = { x: 0, y: 0, target: view2.dom, time: 0 };
      this.checkHover = this.checkHover.bind(this);
      view2.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
      view2.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
      if (this.pending) {
        this.pending = null;
        clearTimeout(this.restartTimeout);
        this.restartTimeout = setTimeout(() => this.startHover(), 20);
      }
    }
    get active() {
      return this.view.state.field(this.field);
    }
    checkHover() {
      this.hoverTimeout = -1;
      if (this.active)
        return;
      let hovered = Date.now() - this.lastMove.time;
      if (hovered < this.hoverTime)
        this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
      else
        this.startHover();
    }
    startHover() {
      clearTimeout(this.restartTimeout);
      let { lastMove } = this;
      let pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(lastMove) : null;
      if (pos == null)
        return;
      let posCoords = this.view.coordsAtPos(pos);
      if (posCoords == null || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - this.view.defaultCharacterWidth || lastMove.x > posCoords.right + this.view.defaultCharacterWidth)
        return;
      let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find((s) => s.from <= pos && s.to >= pos);
      let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
      let open = this.source(this.view, pos, lastMove.x < posCoords.left ? -rtl : rtl);
      if (open === null || open === void 0 ? void 0 : open.then) {
        let pending = this.pending = { pos };
        open.then((result) => {
          if (this.pending == pending) {
            this.pending = null;
            if (result)
              this.view.dispatch({ effects: this.setHover.of(result) });
          }
        }, (e) => logException(this.view.state, e, "hover tooltip"));
      } else if (open) {
        this.view.dispatch({ effects: this.setHover.of(open) });
      }
    }
    mousemove(event) {
      var _a2;
      this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
      if (this.hoverTimeout < 0)
        this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
      let tooltip = this.active;
      if (tooltip && !isInTooltip(this.lastMove.target) || this.pending) {
        let { pos } = tooltip || this.pending, end = (_a2 = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a2 !== void 0 ? _a2 : pos;
        if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY, 6)) {
          this.view.dispatch({ effects: this.setHover.of(null) });
          this.pending = null;
        }
      }
    }
    mouseleave(e) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = -1;
      if (this.active && !isInTooltip(e.relatedTarget))
        this.view.dispatch({ effects: this.setHover.of(null) });
    }
    destroy() {
      clearTimeout(this.hoverTimeout);
      this.view.dom.removeEventListener("mouseleave", this.mouseleave);
      this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
  };
  function isInTooltip(elt2) {
    for (let cur2 = elt2; cur2; cur2 = cur2.parentNode)
      if (cur2.nodeType == 1 && cur2.classList.contains("cm-tooltip"))
        return true;
    return false;
  }
  function isOverRange(view2, from3, to, x3, y3, margin) {
    let range = document.createRange();
    let fromDOM = view2.domAtPos(from3), toDOM = view2.domAtPos(to);
    range.setEnd(toDOM.node, toDOM.offset);
    range.setStart(fromDOM.node, fromDOM.offset);
    let rects = range.getClientRects();
    range.detach();
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      let dist = Math.max(rect.top - y3, y3 - rect.bottom, rect.left - x3, x3 - rect.right);
      if (dist <= margin)
        return true;
    }
    return false;
  }
  function hoverTooltip(source, options = {}) {
    let setHover = StateEffect.define();
    let hoverState = StateField.define({
      create() {
        return null;
      },
      update(value, tr) {
        if (value && (options.hideOnChange && (tr.docChanged || tr.selection) || options.hideOn && options.hideOn(tr, value)))
          return null;
        if (value && tr.docChanged) {
          let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);
          if (newPos == null)
            return null;
          let copy2 = Object.assign(/* @__PURE__ */ Object.create(null), value);
          copy2.pos = newPos;
          if (value.end != null)
            copy2.end = tr.changes.mapPos(value.end);
          value = copy2;
        }
        for (let effect of tr.effects) {
          if (effect.is(setHover))
            value = effect.value;
          if (effect.is(closeHoverTooltipEffect))
            value = null;
        }
        return value;
      },
      provide: (f) => showHoverTooltip.from(f)
    });
    return [
      hoverState,
      ViewPlugin.define((view2) => new HoverPlugin(view2, source, hoverState, setHover, options.hoverTime || 300)),
      showHoverTooltipHost
    ];
  }
  function getTooltip(view2, tooltip) {
    let plugin = view2.plugin(tooltipPlugin);
    if (!plugin)
      return null;
    let found = plugin.manager.tooltips.indexOf(tooltip);
    return found < 0 ? null : plugin.manager.tooltipViews[found];
  }
  var closeHoverTooltipEffect = /* @__PURE__ */ StateEffect.define();
  var panelConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      let topContainer, bottomContainer;
      for (let c2 of configs) {
        topContainer = topContainer || c2.topContainer;
        bottomContainer = bottomContainer || c2.bottomContainer;
      }
      return { topContainer, bottomContainer };
    }
  });
  function getPanel(view2, panel) {
    let plugin = view2.plugin(panelPlugin);
    let index2 = plugin ? plugin.specs.indexOf(panel) : -1;
    return index2 > -1 ? plugin.panels[index2] : null;
  }
  var panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view2) {
      this.input = view2.state.facet(showPanel);
      this.specs = this.input.filter((s) => s);
      this.panels = this.specs.map((spec) => spec(view2));
      let conf = view2.state.facet(panelConfig);
      this.top = new PanelGroup(view2, true, conf.topContainer);
      this.bottom = new PanelGroup(view2, false, conf.bottomContainer);
      this.top.sync(this.panels.filter((p) => p.top));
      this.bottom.sync(this.panels.filter((p) => !p.top));
      for (let p of this.panels) {
        p.dom.classList.add("cm-panel");
        if (p.mount)
          p.mount();
      }
    }
    update(update) {
      let conf = update.state.facet(panelConfig);
      if (this.top.container != conf.topContainer) {
        this.top.sync([]);
        this.top = new PanelGroup(update.view, true, conf.topContainer);
      }
      if (this.bottom.container != conf.bottomContainer) {
        this.bottom.sync([]);
        this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
      }
      this.top.syncClasses();
      this.bottom.syncClasses();
      let input = update.state.facet(showPanel);
      if (input != this.input) {
        let specs = input.filter((x3) => x3);
        let panels = [], top2 = [], bottom = [], mount = [];
        for (let spec of specs) {
          let known = this.specs.indexOf(spec), panel;
          if (known < 0) {
            panel = spec(update.view);
            mount.push(panel);
          } else {
            panel = this.panels[known];
            if (panel.update)
              panel.update(update);
          }
          panels.push(panel);
          (panel.top ? top2 : bottom).push(panel);
        }
        this.specs = specs;
        this.panels = panels;
        this.top.sync(top2);
        this.bottom.sync(bottom);
        for (let p of mount) {
          p.dom.classList.add("cm-panel");
          if (p.mount)
            p.mount();
        }
      } else {
        for (let p of this.panels)
          if (p.update)
            p.update(update);
      }
    }
    destroy() {
      this.top.sync([]);
      this.bottom.sync([]);
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view2) => {
      let value = view2.plugin(plugin);
      return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
    })
  });
  var PanelGroup = class {
    constructor(view2, top2, container) {
      this.view = view2;
      this.top = top2;
      this.container = container;
      this.dom = void 0;
      this.classes = "";
      this.panels = [];
      this.syncClasses();
    }
    sync(panels) {
      for (let p of this.panels)
        if (p.destroy && panels.indexOf(p) < 0)
          p.destroy();
      this.panels = panels;
      this.syncDOM();
    }
    syncDOM() {
      if (this.panels.length == 0) {
        if (this.dom) {
          this.dom.remove();
          this.dom = void 0;
        }
        return;
      }
      if (!this.dom) {
        this.dom = document.createElement("div");
        this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
        this.dom.style[this.top ? "top" : "bottom"] = "0";
        let parent = this.container || this.view.dom;
        parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
      }
      let curDOM = this.dom.firstChild;
      for (let panel of this.panels) {
        if (panel.dom.parentNode == this.dom) {
          while (curDOM != panel.dom)
            curDOM = rm(curDOM);
          curDOM = curDOM.nextSibling;
        } else {
          this.dom.insertBefore(panel.dom, curDOM);
        }
      }
      while (curDOM)
        curDOM = rm(curDOM);
    }
    scrollMargin() {
      return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
      if (!this.container || this.classes == this.view.themeClasses)
        return;
      for (let cls of this.classes.split(" "))
        if (cls)
          this.container.classList.remove(cls);
      for (let cls of (this.classes = this.view.themeClasses).split(" "))
        if (cls)
          this.container.classList.add(cls);
    }
  };
  function rm(node) {
    let next = node.nextSibling;
    node.remove();
    return next;
  }
  var showPanel = /* @__PURE__ */ Facet.define({
    enables: panelPlugin
  });
  var GutterMarker = class extends RangeValue {
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    eq(other) {
      return false;
    }
    destroy(dom) {
    }
  };
  GutterMarker.prototype.elementClass = "";
  GutterMarker.prototype.toDOM = void 0;
  GutterMarker.prototype.mapMode = MapMode.TrackBefore;
  GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
  GutterMarker.prototype.point = true;
  var gutterLineClass = /* @__PURE__ */ Facet.define();
  var defaults = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => RangeSet.empty,
    lineMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
  };
  var activeGutters = /* @__PURE__ */ Facet.define();
  function gutter(config2) {
    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config2))];
  }
  var unfixGutters = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.some((x3) => x3)
  });
  function gutters(config2) {
    let result = [
      gutterView
    ];
    if (config2 && config2.fixed === false)
      result.push(unfixGutters.of(true));
    return result;
  }
  var gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view2) {
      this.view = view2;
      this.prevViewport = view2.viewport;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutters";
      this.dom.setAttribute("aria-hidden", "true");
      this.dom.style.minHeight = this.view.contentHeight + "px";
      this.gutters = view2.state.facet(activeGutters).map((conf) => new SingleGutterView(view2, conf));
      for (let gutter2 of this.gutters)
        this.dom.appendChild(gutter2.dom);
      this.fixed = !view2.state.facet(unfixGutters);
      if (this.fixed) {
        this.dom.style.position = "sticky";
      }
      this.syncGutters(false);
      view2.scrollDOM.insertBefore(this.dom, view2.contentDOM);
    }
    update(update) {
      if (this.updateGutters(update)) {
        let vpA = this.prevViewport, vpB = update.view.viewport;
        let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
        this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
      }
      if (update.geometryChanged)
        this.dom.style.minHeight = this.view.contentHeight + "px";
      if (this.view.state.facet(unfixGutters) != !this.fixed) {
        this.fixed = !this.fixed;
        this.dom.style.position = this.fixed ? "sticky" : "";
      }
      this.prevViewport = update.view.viewport;
    }
    syncGutters(detach) {
      let after = this.dom.nextSibling;
      if (detach)
        this.dom.remove();
      let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
      let classSet = [];
      let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
      for (let line of this.view.viewportLineBlocks) {
        let text3;
        if (Array.isArray(line.type)) {
          for (let b of line.type)
            if (b.type == BlockType.Text) {
              text3 = b;
              break;
            }
        } else {
          text3 = line.type == BlockType.Text ? line : void 0;
        }
        if (!text3)
          continue;
        if (classSet.length)
          classSet = [];
        advanceCursor(lineClasses, classSet, line.from);
        for (let cx of contexts)
          cx.line(this.view, text3, classSet);
      }
      for (let cx of contexts)
        cx.finish();
      if (detach)
        this.view.scrollDOM.insertBefore(this.dom, after);
    }
    updateGutters(update) {
      let prev = update.startState.facet(activeGutters), cur2 = update.state.facet(activeGutters);
      let change2 = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
      if (prev == cur2) {
        for (let gutter2 of this.gutters)
          if (gutter2.update(update))
            change2 = true;
      } else {
        change2 = true;
        let gutters2 = [];
        for (let conf of cur2) {
          let known = prev.indexOf(conf);
          if (known < 0) {
            gutters2.push(new SingleGutterView(this.view, conf));
          } else {
            this.gutters[known].update(update);
            gutters2.push(this.gutters[known]);
          }
        }
        for (let g of this.gutters) {
          g.dom.remove();
          if (gutters2.indexOf(g) < 0)
            g.destroy();
        }
        for (let g of gutters2)
          this.dom.appendChild(g.dom);
        this.gutters = gutters2;
      }
      return change2;
    }
    destroy() {
      for (let view2 of this.gutters)
        view2.destroy();
      this.dom.remove();
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view2) => {
      let value = view2.plugin(plugin);
      if (!value || value.gutters.length == 0 || !value.fixed)
        return null;
      return view2.textDirection == Direction.LTR ? { left: value.dom.offsetWidth } : { right: value.dom.offsetWidth };
    })
  });
  function asArray2(val) {
    return Array.isArray(val) ? val : [val];
  }
  function advanceCursor(cursor, collect, pos) {
    while (cursor.value && cursor.from <= pos) {
      if (cursor.from == pos)
        collect.push(cursor.value);
      cursor.next();
    }
  }
  var UpdateContext = class {
    constructor(gutter2, viewport, height) {
      this.gutter = gutter2;
      this.height = height;
      this.localMarkers = [];
      this.i = 0;
      this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
    }
    line(view2, line, extraMarkers) {
      if (this.localMarkers.length)
        this.localMarkers = [];
      advanceCursor(this.cursor, this.localMarkers, line.from);
      let localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;
      let forLine = this.gutter.config.lineMarker(view2, line, localMarkers);
      if (forLine)
        localMarkers.unshift(forLine);
      let gutter2 = this.gutter;
      if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
        return;
      let above = line.top - this.height;
      if (this.i == gutter2.elements.length) {
        let newElt = new GutterElement(view2, line.height, above, localMarkers);
        gutter2.elements.push(newElt);
        gutter2.dom.appendChild(newElt.dom);
      } else {
        gutter2.elements[this.i].update(view2, line.height, above, localMarkers);
      }
      this.height = line.bottom;
      this.i++;
    }
    finish() {
      let gutter2 = this.gutter;
      while (gutter2.elements.length > this.i) {
        let last2 = gutter2.elements.pop();
        gutter2.dom.removeChild(last2.dom);
        last2.destroy();
      }
    }
  };
  var SingleGutterView = class {
    constructor(view2, config2) {
      this.view = view2;
      this.config = config2;
      this.elements = [];
      this.spacer = null;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
      for (let prop in config2.domEventHandlers) {
        this.dom.addEventListener(prop, (event) => {
          let line = view2.lineBlockAtHeight(event.clientY - view2.documentTop);
          if (config2.domEventHandlers[prop](view2, line, event))
            event.preventDefault();
        });
      }
      this.markers = asArray2(config2.markers(view2));
      if (config2.initialSpacer) {
        this.spacer = new GutterElement(view2, 0, 0, [config2.initialSpacer(view2)]);
        this.dom.appendChild(this.spacer.dom);
        this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
      }
    }
    update(update) {
      let prevMarkers = this.markers;
      this.markers = asArray2(this.config.markers(update.view));
      if (this.spacer && this.config.updateSpacer) {
        let updated = this.config.updateSpacer(this.spacer.markers[0], update);
        if (updated != this.spacer.markers[0])
          this.spacer.update(update.view, 0, 0, [updated]);
      }
      let vp = update.view.viewport;
      return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
    }
    destroy() {
      for (let elt2 of this.elements)
        elt2.destroy();
    }
  };
  var GutterElement = class {
    constructor(view2, height, above, markers) {
      this.height = -1;
      this.above = 0;
      this.markers = [];
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutterElement";
      this.update(view2, height, above, markers);
    }
    update(view2, height, above, markers) {
      if (this.height != height)
        this.dom.style.height = (this.height = height) + "px";
      if (this.above != above)
        this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
      if (!sameMarkers(this.markers, markers))
        this.setMarkers(view2, markers);
    }
    setMarkers(view2, markers) {
      let cls = "cm-gutterElement", domPos = this.dom.firstChild;
      for (let iNew = 0, iOld = 0; ; ) {
        let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
        if (marker) {
          let c2 = marker.elementClass;
          if (c2)
            cls += " " + c2;
          for (let i = iOld; i < this.markers.length; i++)
            if (this.markers[i].compare(marker)) {
              skipTo = i;
              matched = true;
              break;
            }
        } else {
          skipTo = this.markers.length;
        }
        while (iOld < skipTo) {
          let next = this.markers[iOld++];
          if (next.toDOM) {
            next.destroy(domPos);
            let after = domPos.nextSibling;
            domPos.remove();
            domPos = after;
          }
        }
        if (!marker)
          break;
        if (marker.toDOM) {
          if (matched)
            domPos = domPos.nextSibling;
          else
            this.dom.insertBefore(marker.toDOM(view2), domPos);
        }
        if (matched)
          iOld++;
      }
      this.dom.className = cls;
      this.markers = markers;
    }
    destroy() {
      this.setMarkers(null, []);
    }
  };
  function sameMarkers(a2, b) {
    if (a2.length != b.length)
      return false;
    for (let i = 0; i < a2.length; i++)
      if (!a2[i].compare(b[i]))
        return false;
    return true;
  }
  var lineNumberMarkers = /* @__PURE__ */ Facet.define();
  var lineNumberConfig = /* @__PURE__ */ Facet.define({
    combine(values2) {
      return combineConfig(values2, { formatNumber: String, domEventHandlers: {} }, {
        domEventHandlers(a2, b) {
          let result = Object.assign({}, a2);
          for (let event in b) {
            let exists = result[event], add3 = b[event];
            result[event] = exists ? (view2, line, event2) => exists(view2, line, event2) || add3(view2, line, event2) : add3;
          }
          return result;
        }
      });
    }
  });
  var NumberMarker = class extends GutterMarker {
    constructor(number2) {
      super();
      this.number = number2;
    }
    eq(other) {
      return this.number == other.number;
    }
    toDOM() {
      return document.createTextNode(this.number);
    }
  };
  function formatNumber(view2, number2) {
    return view2.state.facet(lineNumberConfig).formatNumber(number2, view2.state);
  }
  var lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state) => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(view2) {
      return view2.state.facet(lineNumberMarkers);
    },
    lineMarker(view2, line, others) {
      if (others.some((m2) => m2.toDOM))
        return null;
      return new NumberMarker(formatNumber(view2, view2.state.doc.lineAt(line.from).number));
    },
    lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
    initialSpacer(view2) {
      return new NumberMarker(formatNumber(view2, maxLineNumber(view2.state.doc.lines)));
    },
    updateSpacer(spacer, update) {
      let max2 = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
      return max2 == spacer.number ? spacer : new NumberMarker(max2);
    },
    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
  }));
  function lineNumbers(config2 = {}) {
    return [
      lineNumberConfig.of(config2),
      gutters(),
      lineNumberGutter
    ];
  }
  function maxLineNumber(lines) {
    let last2 = 9;
    while (last2 < lines)
      last2 = last2 * 10 + 9;
    return last2;
  }
  var activeLineGutterMarker = /* @__PURE__ */ new class extends GutterMarker {
    constructor() {
      super(...arguments);
      this.elementClass = "cm-activeLineGutter";
    }
  }();
  var activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state) => {
    let marks = [], last2 = -1;
    for (let range of state.selection.ranges) {
      let linePos = state.doc.lineAt(range.head).from;
      if (linePos > last2) {
        last2 = linePos;
        marks.push(activeLineGutterMarker.range(linePos));
      }
    }
    return RangeSet.of(marks);
  });
  function highlightActiveLineGutter() {
    return activeLineGutterHighlighter;
  }

  // node_modules/@lezer/common/dist/index.js
  var DefaultBufferLength = 1024;
  var nextPropID = 0;
  var Range2 = class {
    constructor(from3, to) {
      this.from = from3;
      this.to = to;
    }
  };
  var NodeProp = class {
    constructor(config2 = {}) {
      this.id = nextPropID++;
      this.perNode = !!config2.perNode;
      this.deserialize = config2.deserialize || (() => {
        throw new Error("This node type doesn't define a deserialize function");
      });
    }
    add(match) {
      if (this.perNode)
        throw new RangeError("Can't add per-node props to node types");
      if (typeof match != "function")
        match = NodeType.match(match);
      return (type) => {
        let result = match(type);
        return result === void 0 ? null : [this, result];
      };
    }
  };
  NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.contextHash = new NodeProp({ perNode: true });
  NodeProp.lookAhead = new NodeProp({ perNode: true });
  NodeProp.mounted = new NodeProp({ perNode: true });
  var MountedTree = class {
    constructor(tree, overlay, parser5) {
      this.tree = tree;
      this.overlay = overlay;
      this.parser = parser5;
    }
  };
  var noProps = /* @__PURE__ */ Object.create(null);
  var NodeType = class {
    constructor(name2, props, id3, flags = 0) {
      this.name = name2;
      this.props = props;
      this.id = id3;
      this.flags = flags;
    }
    static define(spec) {
      let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
      let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
      let type = new NodeType(spec.name || "", props, spec.id, flags);
      if (spec.props)
        for (let src of spec.props) {
          if (!Array.isArray(src))
            src = src(type);
          if (src) {
            if (src[0].perNode)
              throw new RangeError("Can't store a per-node prop on a node type");
            props[src[0].id] = src[1];
          }
        }
      return type;
    }
    prop(prop) {
      return this.props[prop.id];
    }
    get isTop() {
      return (this.flags & 1) > 0;
    }
    get isSkipped() {
      return (this.flags & 2) > 0;
    }
    get isError() {
      return (this.flags & 4) > 0;
    }
    get isAnonymous() {
      return (this.flags & 8) > 0;
    }
    is(name2) {
      if (typeof name2 == "string") {
        if (this.name == name2)
          return true;
        let group = this.prop(NodeProp.group);
        return group ? group.indexOf(name2) > -1 : false;
      }
      return this.id == name2;
    }
    static match(map3) {
      let direct = /* @__PURE__ */ Object.create(null);
      for (let prop in map3)
        for (let name2 of prop.split(" "))
          direct[name2] = map3[prop];
      return (node) => {
        for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
          let found = direct[i < 0 ? node.name : groups[i]];
          if (found)
            return found;
        }
      };
    }
  };
  NodeType.none = new NodeType("", /* @__PURE__ */ Object.create(null), 0, 8);
  var NodeSet = class {
    constructor(types2) {
      this.types = types2;
      for (let i = 0; i < types2.length; i++)
        if (types2[i].id != i)
          throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    extend(...props) {
      let newTypes = [];
      for (let type of this.types) {
        let newProps = null;
        for (let source of props) {
          let add3 = source(type);
          if (add3) {
            if (!newProps)
              newProps = Object.assign({}, type.props);
            newProps[add3[0].id] = add3[1];
          }
        }
        newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
      }
      return new NodeSet(newTypes);
    }
  };
  var CachedNode = /* @__PURE__ */ new WeakMap();
  var CachedInnerNode = /* @__PURE__ */ new WeakMap();
  var IterMode;
  (function(IterMode2) {
    IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
    IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
  })(IterMode || (IterMode = {}));
  var Tree = class {
    constructor(type, children, positions, length3, props) {
      this.type = type;
      this.children = children;
      this.positions = positions;
      this.length = length3;
      this.props = null;
      if (props && props.length) {
        this.props = /* @__PURE__ */ Object.create(null);
        for (let [prop, value] of props)
          this.props[typeof prop == "number" ? prop : prop.id] = value;
      }
    }
    toString() {
      let mounted = this.prop(NodeProp.mounted);
      if (mounted && !mounted.overlay)
        return mounted.tree.toString();
      let children = "";
      for (let ch of this.children) {
        let str = ch.toString();
        if (str) {
          if (children)
            children += ",";
          children += str;
        }
      }
      return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
    }
    cursor(mode = 0) {
      return new TreeCursor(this.topNode, mode);
    }
    cursorAt(pos, side = 0, mode = 0) {
      let scope = CachedNode.get(this) || this.topNode;
      let cursor = new TreeCursor(scope);
      cursor.moveTo(pos, side);
      CachedNode.set(this, cursor._tree);
      return cursor;
    }
    get topNode() {
      return new TreeNode(this, 0, 0, null);
    }
    resolve(pos, side = 0) {
      let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
      CachedNode.set(this, node);
      return node;
    }
    resolveInner(pos, side = 0) {
      let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
      CachedInnerNode.set(this, node);
      return node;
    }
    iterate(spec) {
      let { enter, leave, from: from3 = 0, to = this.length } = spec;
      for (let c2 = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous); ; ) {
        let entered = false;
        if (c2.from <= to && c2.to >= from3 && (c2.type.isAnonymous || enter(c2) !== false)) {
          if (c2.firstChild())
            continue;
          entered = true;
        }
        for (; ; ) {
          if (entered && leave && !c2.type.isAnonymous)
            leave(c2);
          if (c2.nextSibling())
            break;
          if (!c2.parent())
            return;
          entered = true;
        }
      }
    }
    prop(prop) {
      return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
    }
    get propValues() {
      let result = [];
      if (this.props)
        for (let id3 in this.props)
          result.push([+id3, this.props[id3]]);
      return result;
    }
    balance(config2 = {}) {
      return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length3) => new Tree(this.type, children, positions, length3, this.propValues), config2.makeTree || ((children, positions, length3) => new Tree(NodeType.none, children, positions, length3)));
    }
    static build(data2) {
      return buildTree(data2);
    }
  };
  Tree.empty = new Tree(NodeType.none, [], [], 0);
  var FlatBufferCursor = class {
    constructor(buffer, index2) {
      this.buffer = buffer;
      this.index = index2;
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    get pos() {
      return this.index;
    }
    next() {
      this.index -= 4;
    }
    fork() {
      return new FlatBufferCursor(this.buffer, this.index);
    }
  };
  var TreeBuffer = class {
    constructor(buffer, length3, set3) {
      this.buffer = buffer;
      this.length = length3;
      this.set = set3;
    }
    get type() {
      return NodeType.none;
    }
    toString() {
      let result = [];
      for (let index2 = 0; index2 < this.buffer.length; ) {
        result.push(this.childString(index2));
        index2 = this.buffer[index2 + 3];
      }
      return result.join(",");
    }
    childString(index2) {
      let id3 = this.buffer[index2], endIndex = this.buffer[index2 + 3];
      let type = this.set.types[id3], result = type.name;
      if (/\W/.test(result) && !type.isError)
        result = JSON.stringify(result);
      index2 += 4;
      if (endIndex == index2)
        return result;
      let children = [];
      while (index2 < endIndex) {
        children.push(this.childString(index2));
        index2 = this.buffer[index2 + 3];
      }
      return result + "(" + children.join(",") + ")";
    }
    findChild(startIndex, endIndex, dir, pos, side) {
      let { buffer } = this, pick = -1;
      for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
        if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
          pick = i;
          if (dir > 0)
            break;
        }
      }
      return pick;
    }
    slice(startI, endI, from3) {
      let b = this.buffer;
      let copy2 = new Uint16Array(endI - startI), len = 0;
      for (let i = startI, j = 0; i < endI; ) {
        copy2[j++] = b[i++];
        copy2[j++] = b[i++] - from3;
        let to = copy2[j++] = b[i++] - from3;
        copy2[j++] = b[i++] - startI;
        len = Math.max(len, to);
      }
      return new TreeBuffer(copy2, len, this.set);
    }
  };
  function checkSide(side, pos, from3, to) {
    switch (side) {
      case -2:
        return from3 < pos;
      case -1:
        return to >= pos && from3 < pos;
      case 0:
        return from3 < pos && to > pos;
      case 1:
        return from3 <= pos && to > pos;
      case 2:
        return to > pos;
      case 4:
        return true;
    }
  }
  function enterUnfinishedNodesBefore(node, pos) {
    let scan = node.childBefore(pos);
    while (scan) {
      let last2 = scan.lastChild;
      if (!last2 || last2.to != scan.to)
        break;
      if (last2.type.isError && last2.from == last2.to) {
        node = scan;
        scan = last2.prevSibling;
      } else {
        scan = last2;
      }
    }
    return node;
  }
  function resolveNode(node, pos, side, overlays) {
    var _a2;
    while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
      let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
      if (!parent)
        return node;
      node = parent;
    }
    let mode = overlays ? 0 : IterMode.IgnoreOverlays;
    if (overlays)
      for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
        if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
          node = parent;
      }
    for (; ; ) {
      let inner = node.enter(pos, side, mode);
      if (!inner)
        return node;
      node = inner;
    }
  }
  var TreeNode = class {
    constructor(_tree, from3, index2, _parent) {
      this._tree = _tree;
      this.from = from3;
      this.index = index2;
      this._parent = _parent;
    }
    get type() {
      return this._tree.type;
    }
    get name() {
      return this._tree.type.name;
    }
    get to() {
      return this.from + this._tree.length;
    }
    nextChild(i, dir, pos, side, mode = 0) {
      for (let parent = this; ; ) {
        for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
          let next = children[i], start = positions[i] + parent.from;
          if (!checkSide(side, pos, start, start + next.length))
            continue;
          if (next instanceof TreeBuffer) {
            if (mode & IterMode.ExcludeBuffers)
              continue;
            let index2 = next.findChild(0, next.buffer.length, dir, pos - start, side);
            if (index2 > -1)
              return new BufferNode(new BufferContext(parent, next, i, start), null, index2);
          } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
            let mounted;
            if (!(mode & IterMode.IgnoreMounts) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
              return new TreeNode(mounted.tree, start, i, parent);
            let inner = new TreeNode(next, start, i, parent);
            return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
          }
        }
        if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
          return null;
        if (parent.index >= 0)
          i = parent.index + dir;
        else
          i = dir < 0 ? -1 : parent._parent._tree.children.length;
        parent = parent._parent;
        if (!parent)
          return null;
      }
    }
    get firstChild() {
      return this.nextChild(0, 1, 0, 4);
    }
    get lastChild() {
      return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
    }
    childAfter(pos) {
      return this.nextChild(0, 1, pos, 2);
    }
    childBefore(pos) {
      return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
    }
    enter(pos, side, mode = 0) {
      let mounted;
      if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
        let rPos = pos - this.from;
        for (let { from: from3, to } of mounted.overlay) {
          if ((side > 0 ? from3 <= rPos : from3 < rPos) && (side < 0 ? to >= rPos : to > rPos))
            return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
        }
      }
      return this.nextChild(0, 1, pos, side, mode);
    }
    nextSignificantParent() {
      let val = this;
      while (val.type.isAnonymous && val._parent)
        val = val._parent;
      return val;
    }
    get parent() {
      return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
    }
    get prevSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
    }
    cursor(mode = 0) {
      return new TreeCursor(this, mode);
    }
    get tree() {
      return this._tree;
    }
    toTree() {
      return this._tree;
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore(this, pos);
    }
    getChild(type, before = null, after = null) {
      let r = getChildren(this, type, before, after);
      return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
      return getChildren(this, type, before, after);
    }
    toString() {
      return this._tree.toString();
    }
    get node() {
      return this;
    }
    matchContext(context) {
      return matchNodeContext(this, context);
    }
  };
  function getChildren(node, type, before, after) {
    let cur2 = node.cursor(), result = [];
    if (!cur2.firstChild())
      return result;
    if (before != null) {
      while (!cur2.type.is(before))
        if (!cur2.nextSibling())
          return result;
    }
    for (; ; ) {
      if (after != null && cur2.type.is(after))
        return result;
      if (cur2.type.is(type))
        result.push(cur2.node);
      if (!cur2.nextSibling())
        return after == null ? result : [];
    }
  }
  function matchNodeContext(node, context, i = context.length - 1) {
    for (let p = node.parent; i >= 0; p = p.parent) {
      if (!p)
        return false;
      if (!p.type.isAnonymous) {
        if (context[i] && context[i] != p.name)
          return false;
        i--;
      }
    }
    return true;
  }
  var BufferContext = class {
    constructor(parent, buffer, index2, start) {
      this.parent = parent;
      this.buffer = buffer;
      this.index = index2;
      this.start = start;
    }
  };
  var BufferNode = class {
    get name() {
      return this.type.name;
    }
    get from() {
      return this.context.start + this.context.buffer.buffer[this.index + 1];
    }
    get to() {
      return this.context.start + this.context.buffer.buffer[this.index + 2];
    }
    constructor(context, _parent, index2) {
      this.context = context;
      this._parent = _parent;
      this.index = index2;
      this.type = context.buffer.set.types[context.buffer.buffer[index2]];
    }
    child(dir, pos, side) {
      let { buffer } = this.context;
      let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
      return index2 < 0 ? null : new BufferNode(this.context, this, index2);
    }
    get firstChild() {
      return this.child(1, 0, 4);
    }
    get lastChild() {
      return this.child(-1, 0, 4);
    }
    childAfter(pos) {
      return this.child(1, pos, 2);
    }
    childBefore(pos) {
      return this.child(-1, pos, -2);
    }
    enter(pos, side, mode = 0) {
      if (mode & IterMode.ExcludeBuffers)
        return null;
      let { buffer } = this.context;
      let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
      return index2 < 0 ? null : new BufferNode(this.context, this, index2);
    }
    get parent() {
      return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
      return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
    }
    get nextSibling() {
      let { buffer } = this.context;
      let after = buffer.buffer[this.index + 3];
      if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
        return new BufferNode(this.context, this._parent, after);
      return this.externalSibling(1);
    }
    get prevSibling() {
      let { buffer } = this.context;
      let parentStart = this._parent ? this._parent.index + 4 : 0;
      if (this.index == parentStart)
        return this.externalSibling(-1);
      return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
    }
    cursor(mode = 0) {
      return new TreeCursor(this, mode);
    }
    get tree() {
      return null;
    }
    toTree() {
      let children = [], positions = [];
      let { buffer } = this.context;
      let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
      if (endI > startI) {
        let from3 = buffer.buffer[this.index + 1];
        children.push(buffer.slice(startI, endI, from3));
        positions.push(0);
      }
      return new Tree(this.type, children, positions, this.to - this.from);
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore(this, pos);
    }
    toString() {
      return this.context.buffer.childString(this.index);
    }
    getChild(type, before = null, after = null) {
      let r = getChildren(this, type, before, after);
      return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
      return getChildren(this, type, before, after);
    }
    get node() {
      return this;
    }
    matchContext(context) {
      return matchNodeContext(this, context);
    }
  };
  var TreeCursor = class {
    get name() {
      return this.type.name;
    }
    constructor(node, mode = 0) {
      this.mode = mode;
      this.buffer = null;
      this.stack = [];
      this.index = 0;
      this.bufferNode = null;
      if (node instanceof TreeNode) {
        this.yieldNode(node);
      } else {
        this._tree = node.context.parent;
        this.buffer = node.context;
        for (let n2 = node._parent; n2; n2 = n2._parent)
          this.stack.unshift(n2.index);
        this.bufferNode = node;
        this.yieldBuf(node.index);
      }
    }
    yieldNode(node) {
      if (!node)
        return false;
      this._tree = node;
      this.type = node.type;
      this.from = node.from;
      this.to = node.to;
      return true;
    }
    yieldBuf(index2, type) {
      this.index = index2;
      let { start, buffer } = this.buffer;
      this.type = type || buffer.set.types[buffer.buffer[index2]];
      this.from = start + buffer.buffer[index2 + 1];
      this.to = start + buffer.buffer[index2 + 2];
      return true;
    }
    yield(node) {
      if (!node)
        return false;
      if (node instanceof TreeNode) {
        this.buffer = null;
        return this.yieldNode(node);
      }
      this.buffer = node.context;
      return this.yieldBuf(node.index, node.type);
    }
    toString() {
      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    enterChild(dir, pos, side) {
      if (!this.buffer)
        return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
      let { buffer } = this.buffer;
      let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
      if (index2 < 0)
        return false;
      this.stack.push(this.index);
      return this.yieldBuf(index2);
    }
    firstChild() {
      return this.enterChild(1, 0, 4);
    }
    lastChild() {
      return this.enterChild(-1, 0, 4);
    }
    childAfter(pos) {
      return this.enterChild(1, pos, 2);
    }
    childBefore(pos) {
      return this.enterChild(-1, pos, -2);
    }
    enter(pos, side, mode = this.mode) {
      if (!this.buffer)
        return this.yield(this._tree.enter(pos, side, mode));
      return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    parent() {
      if (!this.buffer)
        return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
      if (this.stack.length)
        return this.yieldBuf(this.stack.pop());
      let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
      this.buffer = null;
      return this.yieldNode(parent);
    }
    sibling(dir) {
      if (!this.buffer)
        return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
      let { buffer } = this.buffer, d = this.stack.length - 1;
      if (dir < 0) {
        let parentStart = d < 0 ? 0 : this.stack[d] + 4;
        if (this.index != parentStart)
          return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
      } else {
        let after = buffer.buffer[this.index + 3];
        if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
          return this.yieldBuf(after);
      }
      return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
    }
    nextSibling() {
      return this.sibling(1);
    }
    prevSibling() {
      return this.sibling(-1);
    }
    atLastNode(dir) {
      let index2, parent, { buffer } = this;
      if (buffer) {
        if (dir > 0) {
          if (this.index < buffer.buffer.buffer.length)
            return false;
        } else {
          for (let i = 0; i < this.index; i++)
            if (buffer.buffer.buffer[i + 3] < this.index)
              return false;
        }
        ({ index: index2, parent } = buffer);
      } else {
        ({ index: index2, _parent: parent } = this._tree);
      }
      for (; parent; { index: index2, _parent: parent } = parent) {
        if (index2 > -1)
          for (let i = index2 + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
            let child = parent._tree.children[i];
            if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
              return false;
          }
      }
      return true;
    }
    move(dir, enter) {
      if (enter && this.enterChild(dir, 0, 4))
        return true;
      for (; ; ) {
        if (this.sibling(dir))
          return true;
        if (this.atLastNode(dir) || !this.parent())
          return false;
      }
    }
    next(enter = true) {
      return this.move(1, enter);
    }
    prev(enter = true) {
      return this.move(-1, enter);
    }
    moveTo(pos, side = 0) {
      while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
        if (!this.parent())
          break;
      while (this.enterChild(1, pos, side)) {
      }
      return this;
    }
    get node() {
      if (!this.buffer)
        return this._tree;
      let cache2 = this.bufferNode, result = null, depth = 0;
      if (cache2 && cache2.context == this.buffer) {
        scan:
          for (let index2 = this.index, d = this.stack.length; d >= 0; ) {
            for (let c2 = cache2; c2; c2 = c2._parent)
              if (c2.index == index2) {
                if (index2 == this.index)
                  return c2;
                result = c2;
                depth = d + 1;
                break scan;
              }
            index2 = this.stack[--d];
          }
      }
      for (let i = depth; i < this.stack.length; i++)
        result = new BufferNode(this.buffer, result, this.stack[i]);
      return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    get tree() {
      return this.buffer ? null : this._tree._tree;
    }
    iterate(enter, leave) {
      for (let depth = 0; ; ) {
        let mustLeave = false;
        if (this.type.isAnonymous || enter(this) !== false) {
          if (this.firstChild()) {
            depth++;
            continue;
          }
          if (!this.type.isAnonymous)
            mustLeave = true;
        }
        for (; ; ) {
          if (mustLeave && leave)
            leave(this);
          mustLeave = this.type.isAnonymous;
          if (this.nextSibling())
            break;
          if (!depth)
            return;
          this.parent();
          depth--;
          mustLeave = true;
        }
      }
    }
    matchContext(context) {
      if (!this.buffer)
        return matchNodeContext(this.node, context);
      let { buffer } = this.buffer, { types: types2 } = buffer.set;
      for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
        if (d < 0)
          return matchNodeContext(this.node, context, i);
        let type = types2[buffer.buffer[this.stack[d]]];
        if (!type.isAnonymous) {
          if (context[i] && context[i] != type.name)
            return false;
          i--;
        }
      }
      return true;
    }
  };
  function hasChild(tree) {
    return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
  }
  function buildTree(data2) {
    var _a2;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data2;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types2 = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children2, positions2, inRepeat) {
      let { id: id3, start, end, size } = cursor;
      let lookAheadAtStart = lookAhead;
      while (size < 0) {
        cursor.next();
        if (size == -1) {
          let node2 = reused[id3];
          children2.push(node2);
          positions2.push(start - parentStart);
          return;
        } else if (size == -3) {
          contextHash = id3;
          return;
        } else if (size == -4) {
          lookAhead = id3;
          return;
        } else {
          throw new RangeError(`Unrecognized record size: ${size}`);
        }
      }
      let type = types2[id3], node, buffer2;
      let startPos = start - parentStart;
      if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
        let data3 = new Uint16Array(buffer2.size - buffer2.skip);
        let endPos = cursor.pos - buffer2.size, index2 = data3.length;
        while (cursor.pos > endPos)
          index2 = copyToBuffer(buffer2.start, data3, index2);
        node = new TreeBuffer(data3, end - buffer2.start, nodeSet);
        startPos = buffer2.start - parentStart;
      } else {
        let endPos = cursor.pos - size;
        cursor.next();
        let localChildren = [], localPositions = [];
        let localInRepeat = id3 >= minRepeatType ? id3 : -1;
        let lastGroup = 0, lastEnd = end;
        while (cursor.pos > endPos) {
          if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
            if (cursor.end <= lastEnd - maxBufferLength) {
              makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
              lastGroup = localChildren.length;
              lastEnd = cursor.end;
            }
            cursor.next();
          } else {
            takeNode(start, endPos, localChildren, localPositions, localInRepeat);
          }
        }
        if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
          makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
        localChildren.reverse();
        localPositions.reverse();
        if (localInRepeat > -1 && lastGroup > 0) {
          let make = makeBalanced(type);
          node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
        } else {
          node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
        }
      }
      children2.push(node);
      positions2.push(startPos);
    }
    function makeBalanced(type) {
      return (children2, positions2, length4) => {
        let lookAhead2 = 0, lastI = children2.length - 1, last2, lookAheadProp;
        if (lastI >= 0 && (last2 = children2[lastI]) instanceof Tree) {
          if (!lastI && last2.type == type && last2.length == length4)
            return last2;
          if (lookAheadProp = last2.prop(NodeProp.lookAhead))
            lookAhead2 = positions2[lastI] + last2.length + lookAheadProp;
        }
        return makeTree(type, children2, positions2, length4, lookAhead2);
      };
    }
    function makeRepeatLeaf(children2, positions2, base2, i, from3, to, type, lookAhead2) {
      let localChildren = [], localPositions = [];
      while (children2.length > i) {
        localChildren.push(children2.pop());
        localPositions.push(positions2.pop() + base2 - from3);
      }
      children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from3, lookAhead2 - to));
      positions2.push(from3 - base2);
    }
    function makeTree(type, children2, positions2, length4, lookAhead2 = 0, props) {
      if (contextHash) {
        let pair2 = [NodeProp.contextHash, contextHash];
        props = props ? [pair2].concat(props) : [pair2];
      }
      if (lookAhead2 > 25) {
        let pair2 = [NodeProp.lookAhead, lookAhead2];
        props = props ? [pair2].concat(props) : [pair2];
      }
      return new Tree(type, children2, positions2, length4, props);
    }
    function findBufferSize(maxSize, inRepeat) {
      let fork = cursor.fork();
      let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
      let result = { size: 0, start: 0, skip: 0 };
      scan:
        for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
          let nodeSize2 = fork.size;
          if (fork.id == inRepeat && nodeSize2 >= 0) {
            result.size = size;
            result.start = start;
            result.skip = skip;
            skip += 4;
            size += 4;
            fork.next();
            continue;
          }
          let startPos = fork.pos - nodeSize2;
          if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
            break;
          let localSkipped = fork.id >= minRepeatType ? 4 : 0;
          let nodeStart2 = fork.start;
          fork.next();
          while (fork.pos > startPos) {
            if (fork.size < 0) {
              if (fork.size == -3)
                localSkipped += 4;
              else
                break scan;
            } else if (fork.id >= minRepeatType) {
              localSkipped += 4;
            }
            fork.next();
          }
          start = nodeStart2;
          size += nodeSize2;
          skip += localSkipped;
        }
      if (inRepeat < 0 || size == maxSize) {
        result.size = size;
        result.start = start;
        result.skip = skip;
      }
      return result.size > 4 ? result : void 0;
    }
    function copyToBuffer(bufferStart, buffer2, index2) {
      let { id: id3, start, end, size } = cursor;
      cursor.next();
      if (size >= 0 && id3 < minRepeatType) {
        let startIndex = index2;
        if (size > 4) {
          let endPos = cursor.pos - (size - 4);
          while (cursor.pos > endPos)
            index2 = copyToBuffer(bufferStart, buffer2, index2);
        }
        buffer2[--index2] = startIndex;
        buffer2[--index2] = end - bufferStart;
        buffer2[--index2] = start - bufferStart;
        buffer2[--index2] = id3;
      } else if (size == -3) {
        contextHash = id3;
      } else if (size == -4) {
        lookAhead = id3;
      }
      return index2;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
      takeNode(data2.start || 0, data2.bufferStart || 0, children, positions, -1);
    let length3 = (_a2 = data2.length) !== null && _a2 !== void 0 ? _a2 : children.length ? positions[0] + children[0].length : 0;
    return new Tree(types2[data2.topID], children.reverse(), positions.reverse(), length3);
  }
  var nodeSizeCache = /* @__PURE__ */ new WeakMap();
  function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
      return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
      size = 1;
      for (let child of node.children) {
        if (child.type != balanceType || !(child instanceof Tree)) {
          size = 1;
          break;
        }
        size += nodeSize(balanceType, child);
      }
      nodeSizeCache.set(node, size);
    }
    return size;
  }
  function balanceRange(balanceType, children, positions, from3, to, start, length3, mkTop, mkTree) {
    let total = 0;
    for (let i = from3; i < to; i++)
      total += nodeSize(balanceType, children[i]);
    let maxChild = Math.ceil(total * 1.5 / 8);
    let localChildren = [], localPositions = [];
    function divide(children2, positions2, from4, to2, offset) {
      for (let i = from4; i < to2; ) {
        let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children2[i]);
        i++;
        for (; i < to2; i++) {
          let nextSize = nodeSize(balanceType, children2[i]);
          if (groupSize + nextSize >= maxChild)
            break;
          groupSize += nextSize;
        }
        if (i == groupFrom + 1) {
          if (groupSize > maxChild) {
            let only = children2[groupFrom];
            divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
            continue;
          }
          localChildren.push(children2[groupFrom]);
        } else {
          let length4 = positions2[i - 1] + children2[i - 1].length - groupStart;
          localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i, groupStart, length4, null, mkTree));
        }
        localPositions.push(groupStart + offset - start);
      }
    }
    divide(children, positions, from3, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length3);
  }
  var NodeWeakMap = class {
    constructor() {
      this.map = /* @__PURE__ */ new WeakMap();
    }
    setBuffer(buffer, index2, value) {
      let inner = this.map.get(buffer);
      if (!inner)
        this.map.set(buffer, inner = /* @__PURE__ */ new Map());
      inner.set(index2, value);
    }
    getBuffer(buffer, index2) {
      let inner = this.map.get(buffer);
      return inner && inner.get(index2);
    }
    set(node, value) {
      if (node instanceof BufferNode)
        this.setBuffer(node.context.buffer, node.index, value);
      else if (node instanceof TreeNode)
        this.map.set(node.tree, value);
    }
    get(node) {
      return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : void 0;
    }
    cursorSet(cursor, value) {
      if (cursor.buffer)
        this.setBuffer(cursor.buffer.buffer, cursor.index, value);
      else
        this.map.set(cursor.tree, value);
    }
    cursorGet(cursor) {
      return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);
    }
  };
  var TreeFragment = class {
    constructor(from3, to, tree, offset, openStart = false, openEnd = false) {
      this.from = from3;
      this.to = to;
      this.tree = tree;
      this.offset = offset;
      this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
    }
    get openStart() {
      return (this.open & 1) > 0;
    }
    get openEnd() {
      return (this.open & 2) > 0;
    }
    static addTree(tree, fragments = [], partial = false) {
      let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
      for (let f of fragments)
        if (f.to > tree.length)
          result.push(f);
      return result;
    }
    static applyChanges(fragments, changes, minGap = 128) {
      if (!changes.length)
        return fragments;
      let result = [];
      let fI = 1, nextF = fragments.length ? fragments[0] : null;
      for (let cI = 0, pos = 0, off = 0; ; cI++) {
        let nextC = cI < changes.length ? changes[cI] : null;
        let nextPos = nextC ? nextC.fromA : 1e9;
        if (nextPos - pos >= minGap)
          while (nextF && nextF.from < nextPos) {
            let cut = nextF;
            if (pos >= cut.from || nextPos <= cut.to || off) {
              let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
              cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
            }
            if (cut)
              result.push(cut);
            if (nextF.to > nextPos)
              break;
            nextF = fI < fragments.length ? fragments[fI++] : null;
          }
        if (!nextC)
          break;
        pos = nextC.toA;
        off = nextC.toA - nextC.toB;
      }
      return result;
    }
  };
  var Parser = class {
    startParse(input, fragments, ranges) {
      if (typeof input == "string")
        input = new StringInput(input);
      ranges = !ranges ? [new Range2(0, input.length)] : ranges.length ? ranges.map((r) => new Range2(r.from, r.to)) : [new Range2(0, 0)];
      return this.createParse(input, fragments || [], ranges);
    }
    parse(input, fragments, ranges) {
      let parse2 = this.startParse(input, fragments, ranges);
      for (; ; ) {
        let done = parse2.advance();
        if (done)
          return done;
      }
    }
  };
  var StringInput = class {
    constructor(string3) {
      this.string = string3;
    }
    get length() {
      return this.string.length;
    }
    chunk(from3) {
      return this.string.slice(from3);
    }
    get lineChunks() {
      return false;
    }
    read(from3, to) {
      return this.string.slice(from3, to);
    }
  };
  function parseMixed(nest) {
    return (parse2, input, fragments, ranges) => new MixedParse(parse2, nest, input, fragments, ranges);
  }
  var InnerParse = class {
    constructor(parser5, parse2, overlay, target, ranges) {
      this.parser = parser5;
      this.parse = parse2;
      this.overlay = overlay;
      this.target = target;
      this.ranges = ranges;
    }
  };
  var ActiveOverlay = class {
    constructor(parser5, predicate, mounts, index2, start, target, prev) {
      this.parser = parser5;
      this.predicate = predicate;
      this.mounts = mounts;
      this.index = index2;
      this.start = start;
      this.target = target;
      this.prev = prev;
      this.depth = 0;
      this.ranges = [];
    }
  };
  var stoppedInner = new NodeProp({ perNode: true });
  var MixedParse = class {
    constructor(base2, nest, input, fragments, ranges) {
      this.nest = nest;
      this.input = input;
      this.fragments = fragments;
      this.ranges = ranges;
      this.inner = [];
      this.innerDone = 0;
      this.baseTree = null;
      this.stoppedAt = null;
      this.baseParse = base2;
    }
    advance() {
      if (this.baseParse) {
        let done2 = this.baseParse.advance();
        if (!done2)
          return null;
        this.baseParse = null;
        this.baseTree = done2;
        this.startInner();
        if (this.stoppedAt != null)
          for (let inner2 of this.inner)
            inner2.parse.stopAt(this.stoppedAt);
      }
      if (this.innerDone == this.inner.length) {
        let result = this.baseTree;
        if (this.stoppedAt != null)
          result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
        return result;
      }
      let inner = this.inner[this.innerDone], done = inner.parse.advance();
      if (done) {
        this.innerDone++;
        let props = Object.assign(/* @__PURE__ */ Object.create(null), inner.target.props);
        props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
        inner.target.props = props;
      }
      return null;
    }
    get parsedPos() {
      if (this.baseParse)
        return 0;
      let pos = this.input.length;
      for (let i = this.innerDone; i < this.inner.length; i++) {
        if (this.inner[i].ranges[0].from < pos)
          pos = Math.min(pos, this.inner[i].parse.parsedPos);
      }
      return pos;
    }
    stopAt(pos) {
      this.stoppedAt = pos;
      if (this.baseParse)
        this.baseParse.stopAt(pos);
      else
        for (let i = this.innerDone; i < this.inner.length; i++)
          this.inner[i].parse.stopAt(pos);
    }
    startInner() {
      let fragmentCursor = new FragmentCursor(this.fragments);
      let overlay = null;
      let covered = null;
      let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
      scan:
        for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt; ) {
          let enter = true, range;
          if (fragmentCursor.hasNode(cursor)) {
            if (overlay) {
              let match = overlay.mounts.find((m2) => m2.frag.from <= cursor.from && m2.frag.to >= cursor.to && m2.mount.overlay);
              if (match)
                for (let r of match.mount.overlay) {
                  let from3 = r.from + match.pos, to = r.to + match.pos;
                  if (from3 >= cursor.from && to <= cursor.to && !overlay.ranges.some((r2) => r2.from < to && r2.to > from3))
                    overlay.ranges.push({ from: from3, to });
                }
            }
            enter = false;
          } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
            enter = isCovered != 2;
          } else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {
            if (!cursor.tree)
              materialize(cursor);
            let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
            if (typeof nest.overlay == "function") {
              overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
            } else {
              let ranges = punchRanges(this.ranges, nest.overlay || [new Range2(cursor.from, cursor.to)]);
              if (ranges.length)
                this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map((r) => new Range2(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));
              if (!nest.overlay)
                enter = false;
              else if (ranges.length)
                covered = { ranges, depth: 0, prev: covered };
            }
          } else if (overlay && (range = overlay.predicate(cursor))) {
            if (range === true)
              range = new Range2(cursor.from, cursor.to);
            if (range.from < range.to)
              overlay.ranges.push(range);
          }
          if (enter && cursor.firstChild()) {
            if (overlay)
              overlay.depth++;
            if (covered)
              covered.depth++;
          } else {
            for (; ; ) {
              if (cursor.nextSibling())
                break;
              if (!cursor.parent())
                break scan;
              if (overlay && !--overlay.depth) {
                let ranges = punchRanges(this.ranges, overlay.ranges);
                if (ranges.length)
                  this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map((r) => new Range2(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));
                overlay = overlay.prev;
              }
              if (covered && !--covered.depth)
                covered = covered.prev;
            }
          }
        }
    }
  };
  function checkCover(covered, from3, to) {
    for (let range of covered) {
      if (range.from >= to)
        break;
      if (range.to > from3)
        return range.from <= from3 && range.to >= to ? 2 : 1;
    }
    return 0;
  }
  function sliceBuf(buf, startI, endI, nodes, positions, off) {
    if (startI < endI) {
      let from3 = buf.buffer[startI + 1];
      nodes.push(buf.slice(startI, endI, from3));
      positions.push(from3 - off);
    }
  }
  function materialize(cursor) {
    let { node } = cursor, depth = 0;
    do {
      cursor.parent();
      depth++;
    } while (!cursor.tree);
    let i = 0, base2 = cursor.tree, off = 0;
    for (; ; i++) {
      off = base2.positions[i] + cursor.from;
      if (off <= node.from && off + base2.children[i].length >= node.to)
        break;
    }
    let buf = base2.children[i], b = buf.buffer;
    function split(startI, endI, type, innerOffset, length3) {
      let i2 = startI;
      while (b[i2 + 2] + off <= node.from)
        i2 = b[i2 + 3];
      let children = [], positions = [];
      sliceBuf(buf, startI, i2, children, positions, innerOffset);
      let from3 = b[i2 + 1], to = b[i2 + 2];
      let isTarget = from3 + off == node.from && to + off == node.to && b[i2] == node.type.id;
      children.push(isTarget ? node.toTree() : split(i2 + 4, b[i2 + 3], buf.set.types[b[i2]], from3, to - from3));
      positions.push(from3 - innerOffset);
      sliceBuf(buf, b[i2 + 3], endI, children, positions, innerOffset);
      return new Tree(type, children, positions, length3);
    }
    base2.children[i] = split(0, b.length, NodeType.none, 0, buf.length);
    for (let d = 0; d <= depth; d++)
      cursor.childAfter(node.from);
  }
  var StructureCursor = class {
    constructor(root, offset) {
      this.offset = offset;
      this.done = false;
      this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
    }
    moveTo(pos) {
      let { cursor } = this, p = pos - this.offset;
      while (!this.done && cursor.from < p) {
        if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers))
          ;
        else if (!cursor.next(false))
          this.done = true;
      }
    }
    hasNode(cursor) {
      this.moveTo(cursor.from);
      if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
        for (let tree = this.cursor.tree; ; ) {
          if (tree == cursor.tree)
            return true;
          if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
            tree = tree.children[0];
          else
            break;
        }
      }
      return false;
    }
  };
  var FragmentCursor = class {
    constructor(fragments) {
      var _a2;
      this.fragments = fragments;
      this.curTo = 0;
      this.fragI = 0;
      if (fragments.length) {
        let first = this.curFrag = fragments[0];
        this.curTo = (_a2 = first.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : first.to;
        this.inner = new StructureCursor(first.tree, -first.offset);
      } else {
        this.curFrag = this.inner = null;
      }
    }
    hasNode(node) {
      while (this.curFrag && node.from >= this.curTo)
        this.nextFrag();
      return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
    }
    nextFrag() {
      var _a2;
      this.fragI++;
      if (this.fragI == this.fragments.length) {
        this.curFrag = this.inner = null;
      } else {
        let frag = this.curFrag = this.fragments[this.fragI];
        this.curTo = (_a2 = frag.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : frag.to;
        this.inner = new StructureCursor(frag.tree, -frag.offset);
      }
    }
    findMounts(pos, parser5) {
      var _a2;
      let result = [];
      if (this.inner) {
        this.inner.cursor.moveTo(pos, 1);
        for (let pos2 = this.inner.cursor.node; pos2; pos2 = pos2.parent) {
          let mount = (_a2 = pos2.tree) === null || _a2 === void 0 ? void 0 : _a2.prop(NodeProp.mounted);
          if (mount && mount.parser == parser5) {
            for (let i = this.fragI; i < this.fragments.length; i++) {
              let frag = this.fragments[i];
              if (frag.from >= pos2.to)
                break;
              if (frag.tree == this.curFrag.tree)
                result.push({
                  frag,
                  pos: pos2.from - frag.offset,
                  mount
                });
            }
          }
        }
      }
      return result;
    }
  };
  function punchRanges(outer, ranges) {
    let copy2 = null, current = ranges;
    for (let i = 1, j = 0; i < outer.length; i++) {
      let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
      for (; j < current.length; j++) {
        let r = current[j];
        if (r.from >= gapTo)
          break;
        if (r.to <= gapFrom)
          continue;
        if (!copy2)
          current = copy2 = ranges.slice();
        if (r.from < gapFrom) {
          copy2[j] = new Range2(r.from, gapFrom);
          if (r.to > gapTo)
            copy2.splice(j + 1, 0, new Range2(gapTo, r.to));
        } else if (r.to > gapTo) {
          copy2[j--] = new Range2(gapTo, r.to);
        } else {
          copy2.splice(j--, 1);
        }
      }
    }
    return current;
  }
  function findCoverChanges(a2, b, from3, to) {
    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
    let result = [];
    for (; ; ) {
      let nextA = iA == a2.length ? 1e9 : inA ? a2[iA].to : a2[iA].from;
      let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
      if (inA != inB) {
        let start = Math.max(pos, from3), end = Math.min(nextA, nextB, to);
        if (start < end)
          result.push(new Range2(start, end));
      }
      pos = Math.min(nextA, nextB);
      if (pos == 1e9)
        break;
      if (nextA == pos) {
        if (!inA)
          inA = true;
        else {
          inA = false;
          iA++;
        }
      }
      if (nextB == pos) {
        if (!inB)
          inB = true;
        else {
          inB = false;
          iB++;
        }
      }
    }
    return result;
  }
  function enterFragments(mounts, ranges) {
    let result = [];
    for (let { pos, mount, frag } of mounts) {
      let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
      let from3 = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
      if (mount.overlay) {
        let overlay = mount.overlay.map((r) => new Range2(r.from + pos, r.to + pos));
        let changes = findCoverChanges(ranges, overlay, from3, to);
        for (let i = 0, pos2 = from3; ; i++) {
          let last2 = i == changes.length, end = last2 ? to : changes[i].from;
          if (end > pos2)
            result.push(new TreeFragment(pos2, end, mount.tree, -startPos, frag.from >= pos2 || frag.openStart, frag.to <= end || frag.openEnd));
          if (last2)
            break;
          pos2 = changes[i].to;
        }
      } else {
        result.push(new TreeFragment(from3, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));
      }
    }
    return result;
  }

  // node_modules/@lezer/highlight/dist/index.js
  var nextTagID = 0;
  var Tag = class {
    constructor(set3, base2, modified) {
      this.set = set3;
      this.base = base2;
      this.modified = modified;
      this.id = nextTagID++;
    }
    static define(parent) {
      if (parent === null || parent === void 0 ? void 0 : parent.base)
        throw new Error("Can not derive from a modified tag");
      let tag = new Tag([], null, []);
      tag.set.push(tag);
      if (parent)
        for (let t2 of parent.set)
          tag.set.push(t2);
      return tag;
    }
    static defineModifier() {
      let mod = new Modifier();
      return (tag) => {
        if (tag.modified.indexOf(mod) > -1)
          return tag;
        return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a2, b) => a2.id - b.id));
      };
    }
  };
  var nextModifierID = 0;
  var Modifier = class {
    constructor() {
      this.instances = [];
      this.id = nextModifierID++;
    }
    static get(base2, mods) {
      if (!mods.length)
        return base2;
      let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray2(mods, t2.modified));
      if (exists)
        return exists;
      let set3 = [], tag = new Tag(set3, base2, mods);
      for (let m2 of mods)
        m2.instances.push(tag);
      let configs = powerSet(mods);
      for (let parent of base2.set)
        if (!parent.modified.length)
          for (let config2 of configs)
            set3.push(Modifier.get(parent, config2));
      return tag;
    }
  };
  function sameArray2(a2, b) {
    return a2.length == b.length && a2.every((x3, i) => x3 == b[i]);
  }
  function powerSet(array2) {
    let sets = [[]];
    for (let i = 0; i < array2.length; i++) {
      for (let j = 0, e = sets.length; j < e; j++) {
        sets.push(sets[j].concat(array2[i]));
      }
    }
    return sets.sort((a2, b) => b.length - a2.length);
  }
  function styleTags(spec) {
    let byName = /* @__PURE__ */ Object.create(null);
    for (let prop in spec) {
      let tags3 = spec[prop];
      if (!Array.isArray(tags3))
        tags3 = [tags3];
      for (let part of prop.split(" "))
        if (part) {
          let pieces = [], mode = 2, rest = part;
          for (let pos = 0; ; ) {
            if (rest == "..." && pos > 0 && pos + 3 == part.length) {
              mode = 1;
              break;
            }
            let m2 = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
            if (!m2)
              throw new RangeError("Invalid path: " + part);
            pieces.push(m2[0] == "*" ? "" : m2[0][0] == '"' ? JSON.parse(m2[0]) : m2[0]);
            pos += m2[0].length;
            if (pos == part.length)
              break;
            let next = part[pos++];
            if (pos == part.length && next == "!") {
              mode = 0;
              break;
            }
            if (next != "/")
              throw new RangeError("Invalid path: " + part);
            rest = part.slice(pos);
          }
          let last2 = pieces.length - 1, inner = pieces[last2];
          if (!inner)
            throw new RangeError("Invalid path: " + part);
          let rule = new Rule(tags3, mode, last2 > 0 ? pieces.slice(0, last2) : null);
          byName[inner] = rule.sort(byName[inner]);
        }
    }
    return ruleNodeProp.add(byName);
  }
  var ruleNodeProp = new NodeProp();
  var Rule = class {
    constructor(tags3, mode, context, next) {
      this.tags = tags3;
      this.mode = mode;
      this.context = context;
      this.next = next;
    }
    get opaque() {
      return this.mode == 0;
    }
    get inherit() {
      return this.mode == 1;
    }
    sort(other) {
      if (!other || other.depth < this.depth) {
        this.next = other;
        return this;
      }
      other.next = this.sort(other.next);
      return other;
    }
    get depth() {
      return this.context ? this.context.length : 0;
    }
  };
  Rule.empty = new Rule([], 2, null);
  function tagHighlighter(tags3, options) {
    let map3 = /* @__PURE__ */ Object.create(null);
    for (let style of tags3) {
      if (!Array.isArray(style.tag))
        map3[style.tag.id] = style.class;
      else
        for (let tag of style.tag)
          map3[tag.id] = style.class;
    }
    let { scope, all: all2 = null } = options || {};
    return {
      style: (tags4) => {
        let cls = all2;
        for (let tag of tags4) {
          for (let sub of tag.set) {
            let tagClass = map3[sub.id];
            if (tagClass) {
              cls = cls ? cls + " " + tagClass : tagClass;
              break;
            }
          }
        }
        return cls;
      },
      scope
    };
  }
  function highlightTags(highlighters, tags3) {
    let result = null;
    for (let highlighter of highlighters) {
      let value = highlighter.style(tags3);
      if (value)
        result = result ? result + " " + value : value;
    }
    return result;
  }
  function highlightTree(tree, highlighter, putStyle, from3 = 0, to = tree.length) {
    let builder = new HighlightBuilder(from3, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
    builder.highlightRange(tree.cursor(), from3, to, "", builder.highlighters);
    builder.flush(to);
  }
  var HighlightBuilder = class {
    constructor(at, highlighters, span) {
      this.at = at;
      this.highlighters = highlighters;
      this.span = span;
      this.class = "";
    }
    startSpan(at, cls) {
      if (cls != this.class) {
        this.flush(at);
        if (at > this.at)
          this.at = at;
        this.class = cls;
      }
    }
    flush(to) {
      if (to > this.at && this.class)
        this.span(this.at, to, this.class);
    }
    highlightRange(cursor, from3, to, inheritedClass, highlighters) {
      let { type, from: start, to: end } = cursor;
      if (start >= to || end <= from3)
        return;
      if (type.isTop)
        highlighters = this.highlighters.filter((h2) => !h2.scope || h2.scope(type));
      let cls = inheritedClass;
      let rule = getStyleTags(cursor) || Rule.empty;
      let tagCls = highlightTags(highlighters, rule.tags);
      if (tagCls) {
        if (cls)
          cls += " ";
        cls += tagCls;
        if (rule.mode == 1)
          inheritedClass += (inheritedClass ? " " : "") + tagCls;
      }
      this.startSpan(cursor.from, cls);
      if (rule.opaque)
        return;
      let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
      if (mounted && mounted.overlay) {
        let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
        let innerHighlighters = this.highlighters.filter((h2) => !h2.scope || h2.scope(mounted.tree.type));
        let hasChild2 = cursor.firstChild();
        for (let i = 0, pos = start; ; i++) {
          let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
          let nextPos = next ? next.from + start : end;
          let rangeFrom = Math.max(from3, pos), rangeTo = Math.min(to, nextPos);
          if (rangeFrom < rangeTo && hasChild2) {
            while (cursor.from < rangeTo) {
              this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
              this.startSpan(Math.min(rangeTo, cursor.to), cls);
              if (cursor.to >= nextPos || !cursor.nextSibling())
                break;
            }
          }
          if (!next || nextPos > to)
            break;
          pos = next.to + start;
          if (pos > from3) {
            this.highlightRange(inner.cursor(), Math.max(from3, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);
            this.startSpan(pos, cls);
          }
        }
        if (hasChild2)
          cursor.parent();
      } else if (cursor.firstChild()) {
        do {
          if (cursor.to <= from3)
            continue;
          if (cursor.from >= to)
            break;
          this.highlightRange(cursor, from3, to, inheritedClass, highlighters);
          this.startSpan(Math.min(to, cursor.to), cls);
        } while (cursor.nextSibling());
        cursor.parent();
      }
    }
  };
  function getStyleTags(node) {
    let rule = node.type.prop(ruleNodeProp);
    while (rule && rule.context && !node.matchContext(rule.context))
      rule = rule.next;
    return rule || null;
  }
  var t = Tag.define;
  var comment = t();
  var name = t();
  var typeName = t(name);
  var propertyName = t(name);
  var literal = t();
  var string = t(literal);
  var number = t(literal);
  var content = t();
  var heading = t(content);
  var keyword = t();
  var operator = t();
  var punctuation = t();
  var bracket = t(punctuation);
  var meta = t();
  var tags = {
    comment,
    lineComment: t(comment),
    blockComment: t(comment),
    docComment: t(comment),
    name,
    variableName: t(name),
    typeName,
    tagName: t(typeName),
    propertyName,
    attributeName: t(propertyName),
    className: t(name),
    labelName: t(name),
    namespace: t(name),
    macroName: t(name),
    literal,
    string,
    docString: t(string),
    character: t(string),
    attributeValue: t(string),
    number,
    integer: t(number),
    float: t(number),
    bool: t(literal),
    regexp: t(literal),
    escape: t(literal),
    color: t(literal),
    url: t(literal),
    keyword,
    self: t(keyword),
    null: t(keyword),
    atom: t(keyword),
    unit: t(keyword),
    modifier: t(keyword),
    operatorKeyword: t(keyword),
    controlKeyword: t(keyword),
    definitionKeyword: t(keyword),
    moduleKeyword: t(keyword),
    operator,
    derefOperator: t(operator),
    arithmeticOperator: t(operator),
    logicOperator: t(operator),
    bitwiseOperator: t(operator),
    compareOperator: t(operator),
    updateOperator: t(operator),
    definitionOperator: t(operator),
    typeOperator: t(operator),
    controlOperator: t(operator),
    punctuation,
    separator: t(punctuation),
    bracket,
    angleBracket: t(bracket),
    squareBracket: t(bracket),
    paren: t(bracket),
    brace: t(bracket),
    content,
    heading,
    heading1: t(heading),
    heading2: t(heading),
    heading3: t(heading),
    heading4: t(heading),
    heading5: t(heading),
    heading6: t(heading),
    contentSeparator: t(content),
    list: t(content),
    quote: t(content),
    emphasis: t(content),
    strong: t(content),
    link: t(content),
    monospace: t(content),
    strikethrough: t(content),
    inserted: t(),
    deleted: t(),
    changed: t(),
    invalid: t(),
    meta,
    documentMeta: t(meta),
    annotation: t(meta),
    processingInstruction: t(meta),
    definition: Tag.defineModifier(),
    constant: Tag.defineModifier(),
    function: Tag.defineModifier(),
    standard: Tag.defineModifier(),
    local: Tag.defineModifier(),
    special: Tag.defineModifier()
  };
  var classHighlighter = tagHighlighter([
    { tag: tags.link, class: "tok-link" },
    { tag: tags.heading, class: "tok-heading" },
    { tag: tags.emphasis, class: "tok-emphasis" },
    { tag: tags.strong, class: "tok-strong" },
    { tag: tags.keyword, class: "tok-keyword" },
    { tag: tags.atom, class: "tok-atom" },
    { tag: tags.bool, class: "tok-bool" },
    { tag: tags.url, class: "tok-url" },
    { tag: tags.labelName, class: "tok-labelName" },
    { tag: tags.inserted, class: "tok-inserted" },
    { tag: tags.deleted, class: "tok-deleted" },
    { tag: tags.literal, class: "tok-literal" },
    { tag: tags.string, class: "tok-string" },
    { tag: tags.number, class: "tok-number" },
    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
    { tag: tags.variableName, class: "tok-variableName" },
    { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
    { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
    { tag: tags.special(tags.variableName), class: "tok-variableName2" },
    { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
    { tag: tags.typeName, class: "tok-typeName" },
    { tag: tags.namespace, class: "tok-namespace" },
    { tag: tags.className, class: "tok-className" },
    { tag: tags.macroName, class: "tok-macroName" },
    { tag: tags.propertyName, class: "tok-propertyName" },
    { tag: tags.operator, class: "tok-operator" },
    { tag: tags.comment, class: "tok-comment" },
    { tag: tags.meta, class: "tok-meta" },
    { tag: tags.invalid, class: "tok-invalid" },
    { tag: tags.punctuation, class: "tok-punctuation" }
  ]);

  // node_modules/@codemirror/language/dist/index.js
  var _a;
  var languageDataProp = /* @__PURE__ */ new NodeProp();
  function defineLanguageFacet(baseData) {
    return Facet.define({
      combine: baseData ? (values2) => values2.concat(baseData) : void 0
    });
  }
  var Language = class {
    constructor(data2, parser5, extraExtensions = [], name2 = "") {
      this.data = data2;
      this.name = name2;
      if (!EditorState.prototype.hasOwnProperty("tree"))
        Object.defineProperty(EditorState.prototype, "tree", { get() {
          return syntaxTree(this);
        } });
      this.parser = parser5;
      this.extension = [
        language.of(this),
        EditorState.languageData.of((state, pos, side) => state.facet(languageDataFacetAt(state, pos, side)))
      ].concat(extraExtensions);
    }
    isActiveAt(state, pos, side = -1) {
      return languageDataFacetAt(state, pos, side) == this.data;
    }
    findRegions(state) {
      let lang = state.facet(language);
      if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
        return [{ from: 0, to: state.doc.length }];
      if (!lang || !lang.allowsNesting)
        return [];
      let result = [];
      let explore = (tree, from3) => {
        if (tree.prop(languageDataProp) == this.data) {
          result.push({ from: from3, to: from3 + tree.length });
          return;
        }
        let mount = tree.prop(NodeProp.mounted);
        if (mount) {
          if (mount.tree.prop(languageDataProp) == this.data) {
            if (mount.overlay)
              for (let r of mount.overlay)
                result.push({ from: r.from + from3, to: r.to + from3 });
            else
              result.push({ from: from3, to: from3 + tree.length });
            return;
          } else if (mount.overlay) {
            let size = result.length;
            explore(mount.tree, mount.overlay[0].from + from3);
            if (result.length > size)
              return;
          }
        }
        for (let i = 0; i < tree.children.length; i++) {
          let ch = tree.children[i];
          if (ch instanceof Tree)
            explore(ch, tree.positions[i] + from3);
        }
      };
      explore(syntaxTree(state), 0);
      return result;
    }
    get allowsNesting() {
      return true;
    }
  };
  Language.setState = /* @__PURE__ */ StateEffect.define();
  function languageDataFacetAt(state, pos, side) {
    let topLang = state.facet(language);
    if (!topLang)
      return null;
    let facet = topLang.data;
    if (topLang.allowsNesting) {
      for (let node = syntaxTree(state).topNode; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
        facet = node.type.prop(languageDataProp) || facet;
    }
    return facet;
  }
  var LRLanguage = class extends Language {
    constructor(data2, parser5, name2) {
      super(data2, parser5, [], name2);
      this.parser = parser5;
    }
    static define(spec) {
      let data2 = defineLanguageFacet(spec.languageData);
      return new LRLanguage(data2, spec.parser.configure({
        props: [languageDataProp.add((type) => type.isTop ? data2 : void 0)]
      }), spec.name);
    }
    configure(options, name2) {
      return new LRLanguage(this.data, this.parser.configure(options), name2 || this.name);
    }
    get allowsNesting() {
      return this.parser.hasWrappers();
    }
  };
  function syntaxTree(state) {
    let field = state.field(Language.state, false);
    return field ? field.tree : Tree.empty;
  }
  var DocInput = class {
    constructor(doc3, length3 = doc3.length) {
      this.doc = doc3;
      this.length = length3;
      this.cursorPos = 0;
      this.string = "";
      this.cursor = doc3.iter();
    }
    syncTo(pos) {
      this.string = this.cursor.next(pos - this.cursorPos).value;
      this.cursorPos = pos + this.string.length;
      return this.cursorPos - this.string.length;
    }
    chunk(pos) {
      this.syncTo(pos);
      return this.string;
    }
    get lineChunks() {
      return true;
    }
    read(from3, to) {
      let stringStart = this.cursorPos - this.string.length;
      if (from3 < stringStart || to >= this.cursorPos)
        return this.doc.sliceString(from3, to);
      else
        return this.string.slice(from3 - stringStart, to - stringStart);
    }
  };
  var currentContext = null;
  var ParseContext = class {
    constructor(parser5, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
      this.parser = parser5;
      this.state = state;
      this.fragments = fragments;
      this.tree = tree;
      this.treeLen = treeLen;
      this.viewport = viewport;
      this.skipped = skipped;
      this.scheduleOn = scheduleOn;
      this.parse = null;
      this.tempSkipped = [];
    }
    static create(parser5, state, viewport) {
      return new ParseContext(parser5, state, [], Tree.empty, 0, viewport, [], null);
    }
    startParse() {
      return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    work(until, upto) {
      if (upto != null && upto >= this.state.doc.length)
        upto = void 0;
      if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
        this.takeTree();
        return true;
      }
      return this.withContext(() => {
        var _a2;
        if (typeof until == "number") {
          let endTime = Date.now() + until;
          until = () => Date.now() > endTime;
        }
        if (!this.parse)
          this.parse = this.startParse();
        if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
          this.parse.stopAt(upto);
        for (; ; ) {
          let done = this.parse.advance();
          if (done) {
            this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
            this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
            this.tree = done;
            this.parse = null;
            if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
              this.parse = this.startParse();
            else
              return true;
          }
          if (until())
            return false;
        }
      });
    }
    takeTree() {
      let pos, tree;
      if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
        if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
          this.parse.stopAt(pos);
        this.withContext(() => {
          while (!(tree = this.parse.advance())) {
          }
        });
        this.treeLen = pos;
        this.tree = tree;
        this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
        this.parse = null;
      }
    }
    withContext(f) {
      let prev = currentContext;
      currentContext = this;
      try {
        return f();
      } finally {
        currentContext = prev;
      }
    }
    withoutTempSkipped(fragments) {
      for (let r; r = this.tempSkipped.pop(); )
        fragments = cutFragments(fragments, r.from, r.to);
      return fragments;
    }
    changes(changes, newState) {
      let { fragments, tree, treeLen, viewport, skipped } = this;
      this.takeTree();
      if (!changes.empty) {
        let ranges = [];
        changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
        fragments = TreeFragment.applyChanges(fragments, ranges);
        tree = Tree.empty;
        treeLen = 0;
        viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
        if (this.skipped.length) {
          skipped = [];
          for (let r of this.skipped) {
            let from3 = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
            if (from3 < to)
              skipped.push({ from: from3, to });
          }
        }
      }
      return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    updateViewport(viewport) {
      if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
        return false;
      this.viewport = viewport;
      let startLen = this.skipped.length;
      for (let i = 0; i < this.skipped.length; i++) {
        let { from: from3, to } = this.skipped[i];
        if (from3 < viewport.to && to > viewport.from) {
          this.fragments = cutFragments(this.fragments, from3, to);
          this.skipped.splice(i--, 1);
        }
      }
      if (this.skipped.length >= startLen)
        return false;
      this.reset();
      return true;
    }
    reset() {
      if (this.parse) {
        this.takeTree();
        this.parse = null;
      }
    }
    skipUntilInView(from3, to) {
      this.skipped.push({ from: from3, to });
    }
    static getSkippingParser(until) {
      return new class extends Parser {
        createParse(input, fragments, ranges) {
          let from3 = ranges[0].from, to = ranges[ranges.length - 1].to;
          let parser5 = {
            parsedPos: from3,
            advance() {
              let cx = currentContext;
              if (cx) {
                for (let r of ranges)
                  cx.tempSkipped.push(r);
                if (until)
                  cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
              }
              this.parsedPos = to;
              return new Tree(NodeType.none, [], [], to - from3);
            },
            stoppedAt: null,
            stopAt() {
            }
          };
          return parser5;
        }
      }();
    }
    isDone(upto) {
      upto = Math.min(upto, this.state.doc.length);
      let frags = this.fragments;
      return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    static get() {
      return currentContext;
    }
  };
  function cutFragments(fragments, from3, to) {
    return TreeFragment.applyChanges(fragments, [{ fromA: from3, toA: to, fromB: from3, toB: to }]);
  }
  var LanguageState = class {
    constructor(context) {
      this.context = context;
      this.tree = context.tree;
    }
    apply(tr) {
      if (!tr.docChanged && this.tree == this.context.tree)
        return this;
      let newCx = this.context.changes(tr.changes, tr.state);
      let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
      if (!newCx.work(20, upto))
        newCx.takeTree();
      return new LanguageState(newCx);
    }
    static init(state) {
      let vpTo = Math.min(3e3, state.doc.length);
      let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
      if (!parseState.work(20, vpTo))
        parseState.takeTree();
      return new LanguageState(parseState);
    }
  };
  Language.state = /* @__PURE__ */ StateField.define({
    create: LanguageState.init,
    update(value, tr) {
      for (let e of tr.effects)
        if (e.is(Language.setState))
          return e.value;
      if (tr.startState.facet(language) != tr.state.facet(language))
        return LanguageState.init(tr.state);
      return value.apply(tr);
    }
  });
  var requestIdle = (callback) => {
    let timeout2 = setTimeout(() => callback(), 500);
    return () => clearTimeout(timeout2);
  };
  if (typeof requestIdleCallback != "undefined")
    requestIdle = (callback) => {
      let idle = -1, timeout2 = setTimeout(() => {
        idle = requestIdleCallback(callback, { timeout: 500 - 100 });
      }, 100);
      return () => idle < 0 ? clearTimeout(timeout2) : cancelIdleCallback(idle);
    };
  var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
  var parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
    constructor(view2) {
      this.view = view2;
      this.working = null;
      this.workScheduled = 0;
      this.chunkEnd = -1;
      this.chunkBudget = -1;
      this.work = this.work.bind(this);
      this.scheduleWork();
    }
    update(update) {
      let cx = this.view.state.field(Language.state).context;
      if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
        this.scheduleWork();
      if (update.docChanged) {
        if (this.view.hasFocus)
          this.chunkBudget += 50;
        this.scheduleWork();
      }
      this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
      if (this.working)
        return;
      let { state } = this.view, field = state.field(Language.state);
      if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
        this.working = requestIdle(this.work);
    }
    work(deadline) {
      this.working = null;
      let now3 = Date.now();
      if (this.chunkEnd < now3 && (this.chunkEnd < 0 || this.view.hasFocus)) {
        this.chunkEnd = now3 + 3e4;
        this.chunkBudget = 3e3;
      }
      if (this.chunkBudget <= 0)
        return;
      let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
      if (field.tree == field.context.tree && field.context.isDone(vpTo + 1e5))
        return;
      let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
      let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
      let done = field.context.work(() => {
        return isInputPending && isInputPending() || Date.now() > endTime;
      }, vpTo + (viewportFirst ? 0 : 1e5));
      this.chunkBudget -= Date.now() - now3;
      if (done || this.chunkBudget <= 0) {
        field.context.takeTree();
        this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
      }
      if (this.chunkBudget > 0 && !(done && !viewportFirst))
        this.scheduleWork();
      this.checkAsyncSchedule(field.context);
    }
    checkAsyncSchedule(cx) {
      if (cx.scheduleOn) {
        this.workScheduled++;
        cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
        cx.scheduleOn = null;
      }
    }
    destroy() {
      if (this.working)
        this.working();
    }
    isWorking() {
      return !!(this.working || this.workScheduled > 0);
    }
  }, {
    eventHandlers: { focus() {
      this.scheduleWork();
    } }
  });
  var language = /* @__PURE__ */ Facet.define({
    combine(languages) {
      return languages.length ? languages[0] : null;
    },
    enables: (language2) => [
      Language.state,
      parseWorker,
      EditorView.contentAttributes.compute([language2], (state) => {
        let lang = state.facet(language2);
        return lang && lang.name ? { "data-language": lang.name } : {};
      })
    ]
  });
  var LanguageSupport = class {
    constructor(language2, support = []) {
      this.language = language2;
      this.support = support;
      this.extension = [language2, support];
    }
  };
  var LanguageDescription = class {
    constructor(name2, alias, extensions, filename, loadFunc, support = void 0) {
      this.name = name2;
      this.alias = alias;
      this.extensions = extensions;
      this.filename = filename;
      this.loadFunc = loadFunc;
      this.support = support;
      this.loading = null;
    }
    load() {
      return this.loading || (this.loading = this.loadFunc().then((support) => this.support = support, (err) => {
        this.loading = null;
        throw err;
      }));
    }
    static of(spec) {
      let { load: load3, support } = spec;
      if (!load3) {
        if (!support)
          throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
        load3 = () => Promise.resolve(support);
      }
      return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map((s) => s.toLowerCase()), spec.extensions || [], spec.filename, load3, support);
    }
    static matchFilename(descs, filename) {
      for (let d of descs)
        if (d.filename && d.filename.test(filename))
          return d;
      let ext = /\.([^.]+)$/.exec(filename);
      if (ext) {
        for (let d of descs)
          if (d.extensions.indexOf(ext[1]) > -1)
            return d;
      }
      return null;
    }
    static matchLanguageName(descs, name2, fuzzy = true) {
      name2 = name2.toLowerCase();
      for (let d of descs)
        if (d.alias.some((a2) => a2 == name2))
          return d;
      if (fuzzy)
        for (let d of descs)
          for (let a2 of d.alias) {
            let found = name2.indexOf(a2);
            if (found > -1 && (a2.length > 2 || !/\w/.test(name2[found - 1]) && !/\w/.test(name2[found + a2.length])))
              return d;
          }
      return null;
    }
  };
  var indentService = /* @__PURE__ */ Facet.define();
  var indentUnit = /* @__PURE__ */ Facet.define({
    combine: (values2) => {
      if (!values2.length)
        return "  ";
      if (!/^(?: +|\t+)$/.test(values2[0]))
        throw new Error("Invalid indent unit: " + JSON.stringify(values2[0]));
      return values2[0];
    }
  });
  function getIndentUnit(state) {
    let unit = state.facet(indentUnit);
    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
  }
  function indentString(state, cols) {
    let result = "", ts = state.tabSize;
    if (state.facet(indentUnit).charCodeAt(0) == 9)
      while (cols >= ts) {
        result += "	";
        cols -= ts;
      }
    for (let i = 0; i < cols; i++)
      result += " ";
    return result;
  }
  function getIndentation(context, pos) {
    if (context instanceof EditorState)
      context = new IndentContext(context);
    for (let service of context.state.facet(indentService)) {
      let result = service(context, pos);
      if (result !== void 0)
        return result;
    }
    let tree = syntaxTree(context.state);
    return tree ? syntaxIndentation(context, tree, pos) : null;
  }
  var IndentContext = class {
    constructor(state, options = {}) {
      this.state = state;
      this.options = options;
      this.unit = getIndentUnit(state);
    }
    lineAt(pos, bias = 1) {
      let line = this.state.doc.lineAt(pos);
      let { simulateBreak, simulateDoubleBreak } = this.options;
      if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
        if (simulateDoubleBreak && simulateBreak == pos)
          return { text: "", from: pos };
        else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
          return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
        else
          return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
      }
      return line;
    }
    textAfterPos(pos, bias = 1) {
      if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
        return "";
      let { text: text3, from: from3 } = this.lineAt(pos, bias);
      return text3.slice(pos - from3, Math.min(text3.length, pos + 100 - from3));
    }
    column(pos, bias = 1) {
      let { text: text3, from: from3 } = this.lineAt(pos, bias);
      let result = this.countColumn(text3, pos - from3);
      let override = this.options.overrideIndentation ? this.options.overrideIndentation(from3) : -1;
      if (override > -1)
        result += override - this.countColumn(text3, text3.search(/\S|$/));
      return result;
    }
    countColumn(line, pos = line.length) {
      return countColumn(line, this.state.tabSize, pos);
    }
    lineIndent(pos, bias = 1) {
      let { text: text3, from: from3 } = this.lineAt(pos, bias);
      let override = this.options.overrideIndentation;
      if (override) {
        let overriden = override(from3);
        if (overriden > -1)
          return overriden;
      }
      return this.countColumn(text3, text3.search(/\S|$/));
    }
    get simulatedBreak() {
      return this.options.simulateBreak || null;
    }
  };
  var indentNodeProp = /* @__PURE__ */ new NodeProp();
  function syntaxIndentation(cx, ast, pos) {
    return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);
  }
  function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
  }
  function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy)
      return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(NodeProp.closedBy))) {
      let last2 = tree.lastChild, closed = last2 && close.indexOf(last2.name) > -1;
      return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last2.from : void 0);
    }
    return tree.parent == null ? topIndent : null;
  }
  function indentFrom(node, pos, base2) {
    for (; node; node = node.parent) {
      let strategy = indentStrategy(node);
      if (strategy)
        return strategy(TreeIndentContext.create(base2, pos, node));
    }
    return null;
  }
  function topIndent() {
    return 0;
  }
  var TreeIndentContext = class extends IndentContext {
    constructor(base2, pos, node) {
      super(base2.state, base2.options);
      this.base = base2;
      this.pos = pos;
      this.node = node;
    }
    static create(base2, pos, node) {
      return new TreeIndentContext(base2, pos, node);
    }
    get textAfter() {
      return this.textAfterPos(this.pos);
    }
    get baseIndent() {
      let line = this.state.doc.lineAt(this.node.from);
      for (; ; ) {
        let atBreak = this.node.resolve(line.from);
        while (atBreak.parent && atBreak.parent.from == atBreak.from)
          atBreak = atBreak.parent;
        if (isParent(atBreak, this.node))
          break;
        line = this.state.doc.lineAt(atBreak.from);
      }
      return this.lineIndent(line.from);
    }
    continue() {
      let parent = this.node.parent;
      return parent ? indentFrom(parent, this.pos, this.base) : 0;
    }
  };
  function isParent(parent, of) {
    for (let cur2 = of; cur2; cur2 = cur2.parent)
      if (parent == cur2)
        return true;
    return false;
  }
  function bracketedAligned(context) {
    let tree = context.node;
    let openToken = tree.childAfter(tree.from), last2 = tree.lastChild;
    if (!openToken)
      return null;
    let sim = context.options.simulateBreak;
    let openLine = context.state.doc.lineAt(openToken.from);
    let lineEnd2 = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (let pos = openToken.to; ; ) {
      let next = tree.childAfter(pos);
      if (!next || next == last2)
        return null;
      if (!next.type.isSkipped)
        return next.from < lineEnd2 ? openToken : null;
      pos = next.to;
    }
  }
  function delimitedIndent({ closing: closing2, align = true, units = 1 }) {
    return (context) => delimitedStrategy(context, align, units, closing2);
  }
  function delimitedStrategy(context, align, units, closing2, closedAt) {
    let after = context.textAfter, space4 = after.match(/^\s*/)[0].length;
    let closed = closing2 && after.slice(space4, space4 + closing2.length) == closing2 || closedAt == context.pos + space4;
    let aligned = align ? bracketedAligned(context) : null;
    if (aligned)
      return closed ? context.column(aligned.from) : context.column(aligned.to);
    return context.baseIndent + (closed ? 0 : context.unit * units);
  }
  var flatIndent = (context) => context.baseIndent;
  function continuedIndent({ except, units = 1 } = {}) {
    return (context) => {
      let matchExcept = except && except.test(context.textAfter);
      return context.baseIndent + (matchExcept ? 0 : units * context.unit);
    };
  }
  var DontIndentBeyond = 200;
  function indentOnInput() {
    return EditorState.transactionFilter.of((tr) => {
      if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
        return tr;
      let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
      if (!rules.length)
        return tr;
      let doc3 = tr.newDoc, { head } = tr.newSelection.main, line = doc3.lineAt(head);
      if (head > line.from + DontIndentBeyond)
        return tr;
      let lineStart = doc3.sliceString(line.from, head);
      if (!rules.some((r) => r.test(lineStart)))
        return tr;
      let { state } = tr, last2 = -1, changes = [];
      for (let { head: head2 } of state.selection.ranges) {
        let line2 = state.doc.lineAt(head2);
        if (line2.from == last2)
          continue;
        last2 = line2.from;
        let indent = getIndentation(state, line2.from);
        if (indent == null)
          continue;
        let cur2 = /^\s*/.exec(line2.text)[0];
        let norm2 = indentString(state, indent);
        if (cur2 != norm2)
          changes.push({ from: line2.from, to: line2.from + cur2.length, insert: norm2 });
      }
      return changes.length ? [tr, { changes, sequential: true }] : tr;
    });
  }
  var foldService = /* @__PURE__ */ Facet.define();
  var foldNodeProp = /* @__PURE__ */ new NodeProp();
  function foldInside(node) {
    let first = node.firstChild, last2 = node.lastChild;
    return first && first.to < last2.from ? { from: first.to, to: last2.type.isError ? node.to : last2.from } : null;
  }
  function syntaxFolding(state, start, end) {
    let tree = syntaxTree(state);
    if (tree.length < end)
      return null;
    let inner = tree.resolveInner(end, 1);
    let found = null;
    for (let cur2 = inner; cur2; cur2 = cur2.parent) {
      if (cur2.to <= end || cur2.from > end)
        continue;
      if (found && cur2.from < start)
        break;
      let prop = cur2.type.prop(foldNodeProp);
      if (prop && (cur2.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur2))) {
        let value = prop(cur2, state);
        if (value && value.from <= end && value.from >= start && value.to > end)
          found = value;
      }
    }
    return found;
  }
  function isUnfinished(node) {
    let ch = node.lastChild;
    return ch && ch.to == node.to && ch.type.isError;
  }
  function foldable(state, lineStart, lineEnd2) {
    for (let service of state.facet(foldService)) {
      let result = service(state, lineStart, lineEnd2);
      if (result)
        return result;
    }
    return syntaxFolding(state, lineStart, lineEnd2);
  }
  function mapRange(range, mapping) {
    let from3 = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
    return from3 >= to ? void 0 : { from: from3, to };
  }
  var foldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
  var unfoldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
  function selectedLines(view2) {
    let lines = [];
    for (let { head } of view2.state.selection.ranges) {
      if (lines.some((l) => l.from <= head && l.to >= head))
        continue;
      lines.push(view2.lineBlockAt(head));
    }
    return lines;
  }
  var foldState = /* @__PURE__ */ StateField.define({
    create() {
      return Decoration.none;
    },
    update(folded, tr) {
      folded = folded.map(tr.changes);
      for (let e of tr.effects) {
        if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to))
          folded = folded.update({ add: [foldWidget.range(e.value.from, e.value.to)] });
        else if (e.is(unfoldEffect))
          folded = folded.update({
            filter: (from3, to) => e.value.from != from3 || e.value.to != to,
            filterFrom: e.value.from,
            filterTo: e.value.to
          });
      }
      if (tr.selection) {
        let onSelection = false, { head } = tr.selection.main;
        folded.between(head, head, (a2, b) => {
          if (a2 < head && b > head)
            onSelection = true;
        });
        if (onSelection)
          folded = folded.update({
            filterFrom: head,
            filterTo: head,
            filter: (a2, b) => b <= head || a2 >= head
          });
      }
      return folded;
    },
    provide: (f) => EditorView.decorations.from(f),
    toJSON(folded, state) {
      let ranges = [];
      folded.between(0, state.doc.length, (from3, to) => {
        ranges.push(from3, to);
      });
      return ranges;
    },
    fromJSON(value) {
      if (!Array.isArray(value) || value.length % 2)
        throw new RangeError("Invalid JSON for fold state");
      let ranges = [];
      for (let i = 0; i < value.length; ) {
        let from3 = value[i++], to = value[i++];
        if (typeof from3 != "number" || typeof to != "number")
          throw new RangeError("Invalid JSON for fold state");
        ranges.push(foldWidget.range(from3, to));
      }
      return Decoration.set(ranges, true);
    }
  });
  function findFold(state, from3, to) {
    var _a2;
    let found = null;
    (_a2 = state.field(foldState, false)) === null || _a2 === void 0 ? void 0 : _a2.between(from3, to, (from4, to2) => {
      if (!found || found.from > from4)
        found = { from: from4, to: to2 };
    });
    return found;
  }
  function foldExists(folded, from3, to) {
    let found = false;
    folded.between(from3, from3, (a2, b) => {
      if (a2 == from3 && b == to)
        found = true;
    });
    return found;
  }
  function maybeEnable(state, other) {
    return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
  }
  var foldCode = (view2) => {
    for (let line of selectedLines(view2)) {
      let range = foldable(view2.state, line.from, line.to);
      if (range) {
        view2.dispatch({ effects: maybeEnable(view2.state, [foldEffect.of(range), announceFold(view2, range)]) });
        return true;
      }
    }
    return false;
  };
  var unfoldCode = (view2) => {
    if (!view2.state.field(foldState, false))
      return false;
    let effects = [];
    for (let line of selectedLines(view2)) {
      let folded = findFold(view2.state, line.from, line.to);
      if (folded)
        effects.push(unfoldEffect.of(folded), announceFold(view2, folded, false));
    }
    if (effects.length)
      view2.dispatch({ effects });
    return effects.length > 0;
  };
  function announceFold(view2, range, fold = true) {
    let lineFrom = view2.state.doc.lineAt(range.from).number, lineTo = view2.state.doc.lineAt(range.to).number;
    return EditorView.announce.of(`${view2.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view2.state.phrase("to")} ${lineTo}.`);
  }
  var foldAll = (view2) => {
    let { state } = view2, effects = [];
    for (let pos = 0; pos < state.doc.length; ) {
      let line = view2.lineBlockAt(pos), range = foldable(state, line.from, line.to);
      if (range)
        effects.push(foldEffect.of(range));
      pos = (range ? view2.lineBlockAt(range.to) : line).to + 1;
    }
    if (effects.length)
      view2.dispatch({ effects: maybeEnable(view2.state, effects) });
    return !!effects.length;
  };
  var unfoldAll = (view2) => {
    let field = view2.state.field(foldState, false);
    if (!field || !field.size)
      return false;
    let effects = [];
    field.between(0, view2.state.doc.length, (from3, to) => {
      effects.push(unfoldEffect.of({ from: from3, to }));
    });
    view2.dispatch({ effects });
    return true;
  };
  var foldKeymap = [
    { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
    { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
    { key: "Ctrl-Alt-[", run: foldAll },
    { key: "Ctrl-Alt-]", run: unfoldAll }
  ];
  var defaultConfig = {
    placeholderDOM: null,
    placeholderText: "\u2026"
  };
  var foldConfig = /* @__PURE__ */ Facet.define({
    combine(values2) {
      return combineConfig(values2, defaultConfig);
    }
  });
  function codeFolding(config2) {
    let result = [foldState, baseTheme$12];
    if (config2)
      result.push(foldConfig.of(config2));
    return result;
  }
  var foldWidget = /* @__PURE__ */ Decoration.replace({ widget: /* @__PURE__ */ new class extends WidgetType {
    toDOM(view2) {
      let { state } = view2, conf = state.facet(foldConfig);
      let onclick = (event) => {
        let line = view2.lineBlockAt(view2.posAtDOM(event.target));
        let folded = findFold(view2.state, line.from, line.to);
        if (folded)
          view2.dispatch({ effects: unfoldEffect.of(folded) });
        event.preventDefault();
      };
      if (conf.placeholderDOM)
        return conf.placeholderDOM(view2, onclick);
      let element2 = document.createElement("span");
      element2.textContent = conf.placeholderText;
      element2.setAttribute("aria-label", state.phrase("folded code"));
      element2.title = state.phrase("unfold");
      element2.className = "cm-foldPlaceholder";
      element2.onclick = onclick;
      return element2;
    }
  }() });
  var foldGutterDefaults = {
    openText: "\u2304",
    closedText: "\u203A",
    markerDOM: null,
    domEventHandlers: {},
    foldingChanged: () => false
  };
  var FoldMarker = class extends GutterMarker {
    constructor(config2, open) {
      super();
      this.config = config2;
      this.open = open;
    }
    eq(other) {
      return this.config == other.config && this.open == other.open;
    }
    toDOM(view2) {
      if (this.config.markerDOM)
        return this.config.markerDOM(this.open);
      let span = document.createElement("span");
      span.textContent = this.open ? this.config.openText : this.config.closedText;
      span.title = view2.state.phrase(this.open ? "Fold line" : "Unfold line");
      return span;
    }
  };
  function foldGutter(config2 = {}) {
    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config2);
    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
    let markers = ViewPlugin.fromClass(class {
      constructor(view2) {
        this.from = view2.viewport.from;
        this.markers = this.buildMarkers(view2);
      }
      update(update) {
        if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update))
          this.markers = this.buildMarkers(update.view);
      }
      buildMarkers(view2) {
        let builder = new RangeSetBuilder();
        for (let line of view2.viewportLineBlocks) {
          let mark = findFold(view2.state, line.from, line.to) ? canUnfold : foldable(view2.state, line.from, line.to) ? canFold : null;
          if (mark)
            builder.add(line.from, line.from, mark);
        }
        return builder.finish();
      }
    });
    let { domEventHandlers } = fullConfig;
    return [
      markers,
      gutter({
        class: "cm-foldGutter",
        markers(view2) {
          var _a2;
          return ((_a2 = view2.plugin(markers)) === null || _a2 === void 0 ? void 0 : _a2.markers) || RangeSet.empty;
        },
        initialSpacer() {
          return new FoldMarker(fullConfig, false);
        },
        domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), { click: (view2, line, event) => {
          if (domEventHandlers.click && domEventHandlers.click(view2, line, event))
            return true;
          let folded = findFold(view2.state, line.from, line.to);
          if (folded) {
            view2.dispatch({ effects: unfoldEffect.of(folded) });
            return true;
          }
          let range = foldable(view2.state, line.from, line.to);
          if (range) {
            view2.dispatch({ effects: foldEffect.of(range) });
            return true;
          }
          return false;
        } })
      }),
      codeFolding()
    ];
  }
  var baseTheme$12 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-foldPlaceholder": {
      backgroundColor: "#eee",
      border: "1px solid #ddd",
      color: "#888",
      borderRadius: ".2em",
      margin: "0 1px",
      padding: "0 1px",
      cursor: "pointer"
    },
    ".cm-foldGutter span": {
      padding: "0 1px",
      cursor: "pointer"
    }
  });
  var HighlightStyle = class {
    constructor(specs, options) {
      this.specs = specs;
      let modSpec;
      function def(spec) {
        let cls = StyleModule.newName();
        (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
        return cls;
      }
      const all2 = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
      const scopeOpt = options.scope;
      this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
      this.style = tagHighlighter(specs.map((style) => ({
        tag: style.tag,
        class: style.class || def(Object.assign({}, style, { tag: null }))
      })), {
        all: all2
      }).style;
      this.module = modSpec ? new StyleModule(modSpec) : null;
      this.themeType = options.themeType;
    }
    static define(specs, options) {
      return new HighlightStyle(specs, options || {});
    }
  };
  var highlighterFacet = /* @__PURE__ */ Facet.define();
  var fallbackHighlighter = /* @__PURE__ */ Facet.define({
    combine(values2) {
      return values2.length ? [values2[0]] : null;
    }
  });
  function getHighlighters(state) {
    let main = state.facet(highlighterFacet);
    return main.length ? main : state.facet(fallbackHighlighter);
  }
  function syntaxHighlighting(highlighter, options) {
    let ext = [treeHighlighter], themeType;
    if (highlighter instanceof HighlightStyle) {
      if (highlighter.module)
        ext.push(EditorView.styleModule.of(highlighter.module));
      themeType = highlighter.themeType;
    }
    if (options === null || options === void 0 ? void 0 : options.fallback)
      ext.push(fallbackHighlighter.of(highlighter));
    else if (themeType)
      ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
        return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
      }));
    else
      ext.push(highlighterFacet.of(highlighter));
    return ext;
  }
  var TreeHighlighter = class {
    constructor(view2) {
      this.markCache = /* @__PURE__ */ Object.create(null);
      this.tree = syntaxTree(view2.state);
      this.decorations = this.buildDeco(view2, getHighlighters(view2.state));
    }
    update(update) {
      let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
      let styleChange = highlighters != getHighlighters(update.startState);
      if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {
        this.decorations = this.decorations.map(update.changes);
      } else if (tree != this.tree || update.viewportChanged || styleChange) {
        this.tree = tree;
        this.decorations = this.buildDeco(update.view, highlighters);
      }
    }
    buildDeco(view2, highlighters) {
      if (!highlighters || !this.tree.length)
        return Decoration.none;
      let builder = new RangeSetBuilder();
      for (let { from: from3, to } of view2.visibleRanges) {
        highlightTree(this.tree, highlighters, (from4, to2, style) => {
          builder.add(from4, to2, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
        }, from3, to);
      }
      return builder.finish();
    }
  };
  var treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
    decorations: (v) => v.decorations
  }));
  var defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
    {
      tag: tags.meta,
      color: "#7a757a"
    },
    {
      tag: tags.link,
      textDecoration: "underline"
    },
    {
      tag: tags.heading,
      textDecoration: "underline",
      fontWeight: "bold"
    },
    {
      tag: tags.emphasis,
      fontStyle: "italic"
    },
    {
      tag: tags.strong,
      fontWeight: "bold"
    },
    {
      tag: tags.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: tags.keyword,
      color: "#708"
    },
    {
      tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
      color: "#219"
    },
    {
      tag: [tags.literal, tags.inserted],
      color: "#164"
    },
    {
      tag: [tags.string, tags.deleted],
      color: "#a11"
    },
    {
      tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
      color: "#e40"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.variableName),
      color: "#00f"
    },
    {
      tag: /* @__PURE__ */ tags.local(tags.variableName),
      color: "#30a"
    },
    {
      tag: [tags.typeName, tags.namespace],
      color: "#085"
    },
    {
      tag: tags.className,
      color: "#167"
    },
    {
      tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
      color: "#256"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.propertyName),
      color: "#00c"
    },
    {
      tag: tags.comment,
      color: "#940"
    },
    {
      tag: tags.invalid,
      color: "#f00"
    }
  ]);
  var baseTheme2 = /* @__PURE__ */ EditorView.baseTheme({
    "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
    "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
  });
  var DefaultScanDist = 1e4;
  var DefaultBrackets = "()[]{}";
  var bracketMatchingConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        afterCursor: true,
        brackets: DefaultBrackets,
        maxScanDistance: DefaultScanDist,
        renderMatch: defaultRenderMatch
      });
    }
  });
  var matchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-matchingBracket" });
  var nonmatchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-nonmatchingBracket" });
  function defaultRenderMatch(match) {
    let decorations2 = [];
    let mark = match.matched ? matchingMark : nonmatchingMark;
    decorations2.push(mark.range(match.start.from, match.start.to));
    if (match.end)
      decorations2.push(mark.range(match.end.from, match.end.to));
    return decorations2;
  }
  var bracketMatchingState = /* @__PURE__ */ StateField.define({
    create() {
      return Decoration.none;
    },
    update(deco, tr) {
      if (!tr.docChanged && !tr.selection)
        return deco;
      let decorations2 = [];
      let config2 = tr.state.facet(bracketMatchingConfig);
      for (let range of tr.state.selection.ranges) {
        if (!range.empty)
          continue;
        let match = matchBrackets(tr.state, range.head, -1, config2) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config2) || config2.afterCursor && (matchBrackets(tr.state, range.head, 1, config2) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config2));
        if (match)
          decorations2 = decorations2.concat(config2.renderMatch(match, tr.state));
      }
      return Decoration.set(decorations2, true);
    },
    provide: (f) => EditorView.decorations.from(f)
  });
  var bracketMatchingUnique = [
    bracketMatchingState,
    baseTheme2
  ];
  function bracketMatching(config2 = {}) {
    return [bracketMatchingConfig.of(config2), bracketMatchingUnique];
  }
  function matchingNodes(node, dir, brackets) {
    let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
    if (byProp)
      return byProp;
    if (node.name.length == 1) {
      let index2 = brackets.indexOf(node.name);
      if (index2 > -1 && index2 % 2 == (dir < 0 ? 1 : 0))
        return [brackets[index2 + dir]];
    }
    return null;
  }
  function matchBrackets(state, pos, dir, config2 = {}) {
    let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
    for (let cur2 = node; cur2; cur2 = cur2.parent) {
      let matches = matchingNodes(cur2.type, dir, brackets);
      if (matches && cur2.from < cur2.to)
        return matchMarkedBrackets(state, pos, dir, cur2, matches, brackets);
    }
    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
  }
  function matchMarkedBrackets(_state2, _pos, dir, token, matching, brackets) {
    let parent = token.parent, firstToken = { from: token.from, to: token.to };
    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
      do {
        if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
          if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
            return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: true };
          } else if (matchingNodes(cursor.type, dir, brackets)) {
            depth++;
          } else if (matchingNodes(cursor.type, -dir, brackets)) {
            if (depth == 0)
              return {
                start: firstToken,
                end: cursor.from == cursor.to ? void 0 : { from: cursor.from, to: cursor.to },
                matched: false
              };
            depth--;
          }
        }
      } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
    return { start: firstToken, matched: false };
  }
  function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
    let bracket2 = brackets.indexOf(startCh);
    if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
      return null;
    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
    for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
      let text3 = iter.value;
      if (dir < 0)
        distance += text3.length;
      let basePos = pos + distance * dir;
      for (let pos2 = dir > 0 ? 0 : text3.length - 1, end = dir > 0 ? text3.length : -1; pos2 != end; pos2 += dir) {
        let found = brackets.indexOf(text3[pos2]);
        if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
          continue;
        if (found % 2 == 0 == dir > 0) {
          depth++;
        } else if (depth == 1) {
          return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
        } else {
          depth--;
        }
      }
      if (dir > 0)
        distance += text3.length;
    }
    return iter.done ? { start: startToken, matched: false } : null;
  }
  var noTokens = /* @__PURE__ */ Object.create(null);
  var typeArray = [NodeType.none];
  var warned = [];
  var defaultTable = /* @__PURE__ */ Object.create(null);
  for (let [legacyName, name2] of [
    ["variable", "variableName"],
    ["variable-2", "variableName.special"],
    ["string-2", "string.special"],
    ["def", "variableName.definition"],
    ["tag", "tagName"],
    ["attribute", "attributeName"],
    ["type", "typeName"],
    ["builtin", "variableName.standard"],
    ["qualifier", "modifier"],
    ["error", "invalid"],
    ["header", "heading"],
    ["property", "propertyName"]
  ])
    defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name2);
  function warnForPart(part, msg) {
    if (warned.indexOf(part) > -1)
      return;
    warned.push(part);
    console.warn(msg);
  }
  function createTokenType(extra, tagStr) {
    let tag = null;
    for (let part of tagStr.split(".")) {
      let value = extra[part] || tags[part];
      if (!value) {
        warnForPart(part, `Unknown highlighting tag ${part}`);
      } else if (typeof value == "function") {
        if (!tag)
          warnForPart(part, `Modifier ${part} used at start of tag`);
        else
          tag = value(tag);
      } else {
        if (tag)
          warnForPart(part, `Tag ${part} used as modifier`);
        else
          tag = value;
      }
    }
    if (!tag)
      return 0;
    let name2 = tagStr.replace(/ /g, "_"), type = NodeType.define({
      id: typeArray.length,
      name: name2,
      props: [styleTags({ [name2]: tag })]
    });
    typeArray.push(type);
    return type.id;
  }

  // node_modules/@codemirror/commands/dist/index.js
  var toggleComment = (target) => {
    let config2 = getConfig(target.state);
    return config2.line ? toggleLineComment(target) : config2.block ? toggleBlockCommentByLine(target) : false;
  };
  function command(f, option) {
    return ({ state, dispatch: dispatch2 }) => {
      if (state.readOnly)
        return false;
      let tr = f(option, state);
      if (!tr)
        return false;
      dispatch2(state.update(tr));
      return true;
    };
  }
  var toggleLineComment = /* @__PURE__ */ command(changeLineComment, 0);
  var toggleBlockComment = /* @__PURE__ */ command(changeBlockComment, 0);
  var toggleBlockCommentByLine = /* @__PURE__ */ command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0);
  function getConfig(state, pos = state.selection.main.head) {
    let data2 = state.languageDataAt("commentTokens", pos);
    return data2.length ? data2[0] : {};
  }
  var SearchMargin = 50;
  function findBlockComment(state, { open, close }, from3, to) {
    let textBefore = state.sliceDoc(from3 - SearchMargin, from3);
    let textAfter = state.sliceDoc(to, to + SearchMargin);
    let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
    let beforeOff = textBefore.length - spaceBefore;
    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
      return {
        open: { pos: from3 - spaceBefore, margin: spaceBefore && 1 },
        close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
      };
    }
    let startText, endText;
    if (to - from3 <= 2 * SearchMargin) {
      startText = endText = state.sliceDoc(from3, to);
    } else {
      startText = state.sliceDoc(from3, from3 + SearchMargin);
      endText = state.sliceDoc(to - SearchMargin, to);
    }
    let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
    let endOff = endText.length - endSpace - close.length;
    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
      return {
        open: {
          pos: from3 + startSpace + open.length,
          margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
        },
        close: {
          pos: to - endSpace - close.length,
          margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
        }
      };
    }
    return null;
  }
  function selectedLineRanges(state) {
    let ranges = [];
    for (let r of state.selection.ranges) {
      let fromLine = state.doc.lineAt(r.from);
      let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
      let last2 = ranges.length - 1;
      if (last2 >= 0 && ranges[last2].to > fromLine.from)
        ranges[last2].to = toLine.to;
      else
        ranges.push({ from: fromLine.from, to: toLine.to });
    }
    return ranges;
  }
  function changeBlockComment(option, state, ranges = state.selection.ranges) {
    let tokens = ranges.map((r) => getConfig(state, r.from).block);
    if (!tokens.every((c2) => c2))
      return null;
    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
    if (option != 2 && !comments.every((c2) => c2)) {
      return { changes: state.changes(ranges.map((range, i) => {
        if (comments[i])
          return [];
        return [{ from: range.from, insert: tokens[i].open + " " }, { from: range.to, insert: " " + tokens[i].close }];
      })) };
    } else if (option != 1 && comments.some((c2) => c2)) {
      let changes = [];
      for (let i = 0, comment2; i < comments.length; i++)
        if (comment2 = comments[i]) {
          let token = tokens[i], { open, close } = comment2;
          changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
        }
      return { changes };
    }
    return null;
  }
  function changeLineComment(option, state, ranges = state.selection.ranges) {
    let lines = [];
    let prevLine = -1;
    for (let { from: from3, to } of ranges) {
      let startI = lines.length, minIndent = 1e9;
      for (let pos = from3; pos <= to; ) {
        let line = state.doc.lineAt(pos);
        if (line.from > prevLine && (from3 == to || to > line.from)) {
          prevLine = line.from;
          let token = getConfig(state, pos).line;
          if (!token)
            continue;
          let indent = /^\s*/.exec(line.text)[0].length;
          let empty2 = indent == line.length;
          let comment2 = line.text.slice(indent, indent + token.length) == token ? indent : -1;
          if (indent < line.text.length && indent < minIndent)
            minIndent = indent;
          lines.push({ line, comment: comment2, token, indent, empty: empty2, single: false });
        }
        pos = line.to + 1;
      }
      if (minIndent < 1e9) {
        for (let i = startI; i < lines.length; i++)
          if (lines[i].indent < lines[i].line.text.length)
            lines[i].indent = minIndent;
      }
      if (lines.length == startI + 1)
        lines[startI].single = true;
    }
    if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
      let changes = [];
      for (let { line, token, indent, empty: empty2, single } of lines)
        if (single || !empty2)
          changes.push({ from: line.from + indent, insert: token + " " });
      let changeSet = state.changes(changes);
      return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
    } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
      let changes = [];
      for (let { line, comment: comment2, token } of lines)
        if (comment2 >= 0) {
          let from3 = line.from + comment2, to = from3 + token.length;
          if (line.text[to - line.from] == " ")
            to++;
          changes.push({ from: from3, to });
        }
      return { changes };
    }
    return null;
  }
  var fromHistory = /* @__PURE__ */ Annotation.define();
  var isolateHistory = /* @__PURE__ */ Annotation.define();
  var invertedEffects = /* @__PURE__ */ Facet.define();
  var historyConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        minDepth: 100,
        newGroupDelay: 500
      }, { minDepth: Math.max, newGroupDelay: Math.min });
    }
  });
  function changeEnd(changes) {
    let end = 0;
    changes.iterChangedRanges((_, to) => end = to);
    return end;
  }
  var historyField_ = /* @__PURE__ */ StateField.define({
    create() {
      return HistoryState.empty;
    },
    update(state, tr) {
      let config2 = tr.state.facet(historyConfig);
      let fromHist = tr.annotation(fromHistory);
      if (fromHist) {
        let selection = tr.docChanged ? EditorSelection.single(changeEnd(tr.changes)) : void 0;
        let item = HistEvent.fromTransaction(tr, selection), from3 = fromHist.side;
        let other = from3 == 0 ? state.undone : state.done;
        if (item)
          other = updateBranch(other, other.length, config2.minDepth, item);
        else
          other = addSelection(other, tr.startState.selection);
        return new HistoryState(from3 == 0 ? fromHist.rest : other, from3 == 0 ? other : fromHist.rest);
      }
      let isolate = tr.annotation(isolateHistory);
      if (isolate == "full" || isolate == "before")
        state = state.isolate();
      if (tr.annotation(Transaction.addToHistory) === false)
        return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
      let event = HistEvent.fromTransaction(tr);
      let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
      if (event)
        state = state.addChanges(event, time, userEvent, config2.newGroupDelay, config2.minDepth);
      else if (tr.selection)
        state = state.addSelection(tr.startState.selection, time, userEvent, config2.newGroupDelay);
      if (isolate == "full" || isolate == "after")
        state = state.isolate();
      return state;
    },
    toJSON(value) {
      return { done: value.done.map((e) => e.toJSON()), undone: value.undone.map((e) => e.toJSON()) };
    },
    fromJSON(json) {
      return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
    }
  });
  function history(config2 = {}) {
    return [
      historyField_,
      historyConfig.of(config2),
      EditorView.domEventHandlers({
        beforeinput(e, view2) {
          let command2 = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e.preventDefault();
          return command2(view2);
        }
      })
    ];
  }
  function cmd(side, selection) {
    return function({ state, dispatch: dispatch2 }) {
      if (!selection && state.readOnly)
        return false;
      let historyState = state.field(historyField_, false);
      if (!historyState)
        return false;
      let tr = historyState.pop(side, state, selection);
      if (!tr)
        return false;
      dispatch2(tr);
      return true;
    };
  }
  var undo = /* @__PURE__ */ cmd(0, false);
  var redo = /* @__PURE__ */ cmd(1, false);
  var undoSelection = /* @__PURE__ */ cmd(0, true);
  var redoSelection = /* @__PURE__ */ cmd(1, true);
  var HistEvent = class {
    constructor(changes, effects, mapped, startSelection, selectionsAfter) {
      this.changes = changes;
      this.effects = effects;
      this.mapped = mapped;
      this.startSelection = startSelection;
      this.selectionsAfter = selectionsAfter;
    }
    setSelAfter(after) {
      return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
      var _a2, _b, _c;
      return {
        changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
        mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
        startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
        selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
      };
    }
    static fromJSON(json) {
      return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
    }
    static fromTransaction(tr, selection) {
      let effects = none2;
      for (let invert of tr.startState.facet(invertedEffects)) {
        let result = invert(tr);
        if (result.length)
          effects = effects.concat(result);
      }
      if (!effects.length && tr.changes.empty)
        return null;
      return new HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection || tr.startState.selection, none2);
    }
    static selection(selections) {
      return new HistEvent(void 0, none2, void 0, void 0, selections);
    }
  };
  function updateBranch(branch, to, maxLen, newEvent) {
    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
    let newBranch = branch.slice(start, to);
    newBranch.push(newEvent);
    return newBranch;
  }
  function isAdjacent(a2, b) {
    let ranges = [], isAdjacent2 = false;
    a2.iterChangedRanges((f, t2) => ranges.push(f, t2));
    b.iterChangedRanges((_f, _t, f, t2) => {
      for (let i = 0; i < ranges.length; ) {
        let from3 = ranges[i++], to = ranges[i++];
        if (t2 >= from3 && f <= to)
          isAdjacent2 = true;
      }
    });
    return isAdjacent2;
  }
  function eqSelectionShape(a2, b) {
    return a2.ranges.length == b.ranges.length && a2.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
  }
  function conc(a2, b) {
    return !a2.length ? b : !b.length ? a2 : a2.concat(b);
  }
  var none2 = [];
  var MaxSelectionsPerEvent = 200;
  function addSelection(branch, selection) {
    if (!branch.length) {
      return [HistEvent.selection([selection])];
    } else {
      let lastEvent = branch[branch.length - 1];
      let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
      if (sels.length && sels[sels.length - 1].eq(selection))
        return branch;
      sels.push(selection);
      return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
    }
  }
  function popSelection(branch) {
    let last2 = branch[branch.length - 1];
    let newBranch = branch.slice();
    newBranch[branch.length - 1] = last2.setSelAfter(last2.selectionsAfter.slice(0, last2.selectionsAfter.length - 1));
    return newBranch;
  }
  function addMappingToBranch(branch, mapping) {
    if (!branch.length)
      return branch;
    let length3 = branch.length, selections = none2;
    while (length3) {
      let event = mapEvent(branch[length3 - 1], mapping, selections);
      if (event.changes && !event.changes.empty || event.effects.length) {
        let result = branch.slice(0, length3);
        result[length3 - 1] = event;
        return result;
      } else {
        mapping = event.mapped;
        length3--;
        selections = event.selectionsAfter;
      }
    }
    return selections.length ? [HistEvent.selection(selections)] : none2;
  }
  function mapEvent(event, mapping, extraSelections) {
    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s) => s.map(mapping)) : none2, extraSelections);
    if (!event.changes)
      return HistEvent.selection(selections);
    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
    return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
  }
  var joinableUserEvent = /^(input\.type|delete)($|\.)/;
  var HistoryState = class {
    constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
      this.done = done;
      this.undone = undone;
      this.prevTime = prevTime;
      this.prevUserEvent = prevUserEvent;
    }
    isolate() {
      return this.prevTime ? new HistoryState(this.done, this.undone) : this;
    }
    addChanges(event, time, userEvent, newGroupDelay, maxLen) {
      let done = this.done, lastEvent = done[done.length - 1];
      if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < newGroupDelay && isAdjacent(lastEvent.changes, event.changes) || userEvent == "input.type.compose")) {
        done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none2));
      } else {
        done = updateBranch(done, done.length, maxLen, event);
      }
      return new HistoryState(done, none2, time, userEvent);
    }
    addSelection(selection, time, userEvent, newGroupDelay) {
      let last2 = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none2;
      if (last2.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last2[last2.length - 1], selection))
        return this;
      return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
    }
    addMapping(mapping) {
      return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state, selection) {
      let branch = side == 0 ? this.done : this.undone;
      if (branch.length == 0)
        return null;
      let event = branch[branch.length - 1];
      if (selection && event.selectionsAfter.length) {
        return state.update({
          selection: event.selectionsAfter[event.selectionsAfter.length - 1],
          annotations: fromHistory.of({ side, rest: popSelection(branch) }),
          userEvent: side == 0 ? "select.undo" : "select.redo",
          scrollIntoView: true
        });
      } else if (!event.changes) {
        return null;
      } else {
        let rest = branch.length == 1 ? none2 : branch.slice(0, branch.length - 1);
        if (event.mapped)
          rest = addMappingToBranch(rest, event.mapped);
        return state.update({
          changes: event.changes,
          selection: event.startSelection,
          effects: event.effects,
          annotations: fromHistory.of({ side, rest }),
          filter: false,
          userEvent: side == 0 ? "undo" : "redo",
          scrollIntoView: true
        });
      }
    }
  };
  HistoryState.empty = /* @__PURE__ */ new HistoryState(none2, none2);
  var historyKeymap = [
    { key: "Mod-z", run: undo, preventDefault: true },
    { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
    { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
    { key: "Mod-u", run: undoSelection, preventDefault: true },
    { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
  ];
  function updateSel(sel, by) {
    return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
  }
  function setSel(state, selection) {
    return state.update({ selection, scrollIntoView: true, userEvent: "select" });
  }
  function moveSel({ state, dispatch: dispatch2 }, how) {
    let selection = updateSel(state.selection, how);
    if (selection.eq(state.selection))
      return false;
    dispatch2(setSel(state, selection));
    return true;
  }
  function rangeEnd(range, forward) {
    return EditorSelection.cursor(forward ? range.to : range.from);
  }
  function cursorByChar(view2, forward) {
    return moveSel(view2, (range) => range.empty ? view2.moveByChar(range, forward) : rangeEnd(range, forward));
  }
  function ltrAtCursor(view2) {
    return view2.textDirectionAt(view2.state.selection.main.head) == Direction.LTR;
  }
  var cursorCharLeft = (view2) => cursorByChar(view2, !ltrAtCursor(view2));
  var cursorCharRight = (view2) => cursorByChar(view2, ltrAtCursor(view2));
  function cursorByGroup(view2, forward) {
    return moveSel(view2, (range) => range.empty ? view2.moveByGroup(range, forward) : rangeEnd(range, forward));
  }
  var cursorGroupLeft = (view2) => cursorByGroup(view2, !ltrAtCursor(view2));
  var cursorGroupRight = (view2) => cursorByGroup(view2, ltrAtCursor(view2));
  function interestingNode(state, node, bracketProp) {
    if (node.type.prop(bracketProp))
      return true;
    let len = node.to - node.from;
    return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
  }
  function moveBySyntax(state, start, forward) {
    let pos = syntaxTree(state).resolveInner(start.head);
    let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
    for (let at = start.head; ; ) {
      let next = forward ? pos.childAfter(at) : pos.childBefore(at);
      if (!next)
        break;
      if (interestingNode(state, next, bracketProp))
        pos = next;
      else
        at = forward ? next.to : next.from;
    }
    let bracket2 = pos.type.prop(bracketProp), match, newPos;
    if (bracket2 && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
      newPos = forward ? match.end.to : match.end.from;
    else
      newPos = forward ? pos.to : pos.from;
    return EditorSelection.cursor(newPos, forward ? -1 : 1);
  }
  var cursorSyntaxLeft = (view2) => moveSel(view2, (range) => moveBySyntax(view2.state, range, !ltrAtCursor(view2)));
  var cursorSyntaxRight = (view2) => moveSel(view2, (range) => moveBySyntax(view2.state, range, ltrAtCursor(view2)));
  function cursorByLine(view2, forward) {
    return moveSel(view2, (range) => {
      if (!range.empty)
        return rangeEnd(range, forward);
      let moved = view2.moveVertically(range, forward);
      return moved.head != range.head ? moved : view2.moveToLineBoundary(range, forward);
    });
  }
  var cursorLineUp = (view2) => cursorByLine(view2, false);
  var cursorLineDown = (view2) => cursorByLine(view2, true);
  function pageHeight(view2) {
    return Math.max(view2.defaultLineHeight, Math.min(view2.dom.clientHeight, innerHeight) - 5);
  }
  function cursorByPage(view2, forward) {
    let { state } = view2, selection = updateSel(state.selection, (range) => {
      return range.empty ? view2.moveVertically(range, forward, pageHeight(view2)) : rangeEnd(range, forward);
    });
    if (selection.eq(state.selection))
      return false;
    let startPos = view2.coordsAtPos(state.selection.main.head);
    let scrollRect = view2.scrollDOM.getBoundingClientRect();
    let effect;
    if (startPos && startPos.top > scrollRect.top && startPos.bottom < scrollRect.bottom && startPos.top - scrollRect.top <= view2.scrollDOM.scrollHeight - view2.scrollDOM.scrollTop - view2.scrollDOM.clientHeight)
      effect = EditorView.scrollIntoView(selection.main.head, { y: "start", yMargin: startPos.top - scrollRect.top });
    view2.dispatch(setSel(state, selection), { effects: effect });
    return true;
  }
  var cursorPageUp = (view2) => cursorByPage(view2, false);
  var cursorPageDown = (view2) => cursorByPage(view2, true);
  function moveByLineBoundary(view2, start, forward) {
    let line = view2.lineBlockAt(start.head), moved = view2.moveToLineBoundary(start, forward);
    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
      moved = view2.moveToLineBoundary(start, forward, false);
    if (!forward && moved.head == line.from && line.length) {
      let space4 = /^\s*/.exec(view2.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
      if (space4 && start.head != line.from + space4)
        moved = EditorSelection.cursor(line.from + space4);
    }
    return moved;
  }
  var cursorLineBoundaryForward = (view2) => moveSel(view2, (range) => moveByLineBoundary(view2, range, true));
  var cursorLineBoundaryBackward = (view2) => moveSel(view2, (range) => moveByLineBoundary(view2, range, false));
  var cursorLineBoundaryLeft = (view2) => moveSel(view2, (range) => moveByLineBoundary(view2, range, !ltrAtCursor(view2)));
  var cursorLineBoundaryRight = (view2) => moveSel(view2, (range) => moveByLineBoundary(view2, range, ltrAtCursor(view2)));
  var cursorLineStart = (view2) => moveSel(view2, (range) => EditorSelection.cursor(view2.lineBlockAt(range.head).from, 1));
  var cursorLineEnd = (view2) => moveSel(view2, (range) => EditorSelection.cursor(view2.lineBlockAt(range.head).to, -1));
  function toMatchingBracket(state, dispatch2, extend2) {
    let found = false, selection = updateSel(state.selection, (range) => {
      let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
      if (!matching || !matching.end)
        return range;
      found = true;
      let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
      return extend2 ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
    });
    if (!found)
      return false;
    dispatch2(setSel(state, selection));
    return true;
  }
  var cursorMatchingBracket = ({ state, dispatch: dispatch2 }) => toMatchingBracket(state, dispatch2, false);
  function extendSel(view2, how) {
    let selection = updateSel(view2.state.selection, (range) => {
      let head = how(range);
      return EditorSelection.range(range.anchor, head.head, head.goalColumn);
    });
    if (selection.eq(view2.state.selection))
      return false;
    view2.dispatch(setSel(view2.state, selection));
    return true;
  }
  function selectByChar(view2, forward) {
    return extendSel(view2, (range) => view2.moveByChar(range, forward));
  }
  var selectCharLeft = (view2) => selectByChar(view2, !ltrAtCursor(view2));
  var selectCharRight = (view2) => selectByChar(view2, ltrAtCursor(view2));
  function selectByGroup(view2, forward) {
    return extendSel(view2, (range) => view2.moveByGroup(range, forward));
  }
  var selectGroupLeft = (view2) => selectByGroup(view2, !ltrAtCursor(view2));
  var selectGroupRight = (view2) => selectByGroup(view2, ltrAtCursor(view2));
  var selectSyntaxLeft = (view2) => extendSel(view2, (range) => moveBySyntax(view2.state, range, !ltrAtCursor(view2)));
  var selectSyntaxRight = (view2) => extendSel(view2, (range) => moveBySyntax(view2.state, range, ltrAtCursor(view2)));
  function selectByLine(view2, forward) {
    return extendSel(view2, (range) => view2.moveVertically(range, forward));
  }
  var selectLineUp = (view2) => selectByLine(view2, false);
  var selectLineDown = (view2) => selectByLine(view2, true);
  function selectByPage(view2, forward) {
    return extendSel(view2, (range) => view2.moveVertically(range, forward, pageHeight(view2)));
  }
  var selectPageUp = (view2) => selectByPage(view2, false);
  var selectPageDown = (view2) => selectByPage(view2, true);
  var selectLineBoundaryForward = (view2) => extendSel(view2, (range) => moveByLineBoundary(view2, range, true));
  var selectLineBoundaryBackward = (view2) => extendSel(view2, (range) => moveByLineBoundary(view2, range, false));
  var selectLineBoundaryLeft = (view2) => extendSel(view2, (range) => moveByLineBoundary(view2, range, !ltrAtCursor(view2)));
  var selectLineBoundaryRight = (view2) => extendSel(view2, (range) => moveByLineBoundary(view2, range, ltrAtCursor(view2)));
  var selectLineStart = (view2) => extendSel(view2, (range) => EditorSelection.cursor(view2.lineBlockAt(range.head).from));
  var selectLineEnd = (view2) => extendSel(view2, (range) => EditorSelection.cursor(view2.lineBlockAt(range.head).to));
  var cursorDocStart = ({ state, dispatch: dispatch2 }) => {
    dispatch2(setSel(state, { anchor: 0 }));
    return true;
  };
  var cursorDocEnd = ({ state, dispatch: dispatch2 }) => {
    dispatch2(setSel(state, { anchor: state.doc.length }));
    return true;
  };
  var selectDocStart = ({ state, dispatch: dispatch2 }) => {
    dispatch2(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
    return true;
  };
  var selectDocEnd = ({ state, dispatch: dispatch2 }) => {
    dispatch2(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
    return true;
  };
  var selectAll = ({ state, dispatch: dispatch2 }) => {
    dispatch2(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
    return true;
  };
  var selectLine = ({ state, dispatch: dispatch2 }) => {
    let ranges = selectedLineBlocks(state).map(({ from: from3, to }) => EditorSelection.range(from3, Math.min(to + 1, state.doc.length)));
    dispatch2(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
    return true;
  };
  var selectParentSyntax = ({ state, dispatch: dispatch2 }) => {
    let selection = updateSel(state.selection, (range) => {
      var _a2;
      let context = syntaxTree(state).resolveInner(range.head, 1);
      while (!(context.from < range.from && context.to >= range.to || context.to > range.to && context.from <= range.from || !((_a2 = context.parent) === null || _a2 === void 0 ? void 0 : _a2.parent)))
        context = context.parent;
      return EditorSelection.range(context.to, context.from);
    });
    dispatch2(setSel(state, selection));
    return true;
  };
  var simplifySelection = ({ state, dispatch: dispatch2 }) => {
    let cur2 = state.selection, selection = null;
    if (cur2.ranges.length > 1)
      selection = EditorSelection.create([cur2.main]);
    else if (!cur2.main.empty)
      selection = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
    if (!selection)
      return false;
    dispatch2(setSel(state, selection));
    return true;
  };
  function deleteBy(target, by) {
    if (target.state.readOnly)
      return false;
    let event = "delete.selection", { state } = target;
    let changes = state.changeByRange((range) => {
      let { from: from3, to } = range;
      if (from3 == to) {
        let towards = by(from3);
        if (towards < from3) {
          event = "delete.backward";
          towards = skipAtomic(target, towards, false);
        } else if (towards > from3) {
          event = "delete.forward";
          towards = skipAtomic(target, towards, true);
        }
        from3 = Math.min(from3, towards);
        to = Math.max(to, towards);
      } else {
        from3 = skipAtomic(target, from3, false);
        to = skipAtomic(target, to, true);
      }
      return from3 == to ? { range } : { changes: { from: from3, to }, range: EditorSelection.cursor(from3) };
    });
    if (changes.changes.empty)
      return false;
    target.dispatch(state.update(changes, {
      scrollIntoView: true,
      userEvent: event,
      effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
    }));
    return true;
  }
  function skipAtomic(target, pos, forward) {
    if (target instanceof EditorView)
      for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
        ranges.between(pos, pos, (from3, to) => {
          if (from3 < pos && to > pos)
            pos = forward ? to : from3;
        });
    return pos;
  }
  var deleteByChar = (target, forward) => deleteBy(target, (pos) => {
    let { state } = target, line = state.doc.lineAt(pos), before, targetPos;
    if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
      if (before[before.length - 1] == "	")
        return pos - 1;
      let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
      for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
        pos--;
      targetPos = pos;
    } else {
      targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
      if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
        targetPos += forward ? 1 : -1;
    }
    return targetPos;
  });
  var deleteCharBackward = (view2) => deleteByChar(view2, false);
  var deleteCharForward = (view2) => deleteByChar(view2, true);
  var deleteByGroup = (target, forward) => deleteBy(target, (start) => {
    let pos = start, { state } = target, line = state.doc.lineAt(pos);
    let categorize = state.charCategorizer(pos);
    for (let cat = null; ; ) {
      if (pos == (forward ? line.to : line.from)) {
        if (pos == start && line.number != (forward ? state.doc.lines : 1))
          pos += forward ? 1 : -1;
        break;
      }
      let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
      let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
      let nextCat = categorize(nextChar2);
      if (cat != null && nextCat != cat)
        break;
      if (nextChar2 != " " || pos != start)
        cat = nextCat;
      pos = next;
    }
    return pos;
  });
  var deleteGroupBackward = (target) => deleteByGroup(target, false);
  var deleteGroupForward = (target) => deleteByGroup(target, true);
  var deleteToLineEnd = (view2) => deleteBy(view2, (pos) => {
    let lineEnd2 = view2.lineBlockAt(pos).to;
    return pos < lineEnd2 ? lineEnd2 : Math.min(view2.state.doc.length, pos + 1);
  });
  var deleteToLineStart = (view2) => deleteBy(view2, (pos) => {
    let lineStart = view2.lineBlockAt(pos).from;
    return pos > lineStart ? lineStart : Math.max(0, pos - 1);
  });
  var splitLine = ({ state, dispatch: dispatch2 }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      return {
        changes: { from: range.from, to: range.to, insert: Text.of(["", ""]) },
        range: EditorSelection.cursor(range.from)
      };
    });
    dispatch2(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
  var transposeChars = ({ state, dispatch: dispatch2 }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      if (!range.empty || range.from == 0 || range.from == state.doc.length)
        return { range };
      let pos = range.from, line = state.doc.lineAt(pos);
      let from3 = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
      let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
      return {
        changes: { from: from3, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from3, pos)) },
        range: EditorSelection.cursor(to)
      };
    });
    if (changes.changes.empty)
      return false;
    dispatch2(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
    return true;
  };
  function selectedLineBlocks(state) {
    let blocks = [], upto = -1;
    for (let range of state.selection.ranges) {
      let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
      if (!range.empty && range.to == endLine.from)
        endLine = state.doc.lineAt(range.to - 1);
      if (upto >= startLine.number) {
        let prev = blocks[blocks.length - 1];
        prev.to = endLine.to;
        prev.ranges.push(range);
      } else {
        blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
      }
      upto = endLine.number + 1;
    }
    return blocks;
  }
  function moveLine(state, dispatch2, forward) {
    if (state.readOnly)
      return false;
    let changes = [], ranges = [];
    for (let block of selectedLineBlocks(state)) {
      if (forward ? block.to == state.doc.length : block.from == 0)
        continue;
      let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
      let size = nextLine.length + 1;
      if (forward) {
        changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
        for (let r of block.ranges)
          ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
      } else {
        changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
        for (let r of block.ranges)
          ranges.push(EditorSelection.range(r.anchor - size, r.head - size));
      }
    }
    if (!changes.length)
      return false;
    dispatch2(state.update({
      changes,
      scrollIntoView: true,
      selection: EditorSelection.create(ranges, state.selection.mainIndex),
      userEvent: "move.line"
    }));
    return true;
  }
  var moveLineUp = ({ state, dispatch: dispatch2 }) => moveLine(state, dispatch2, false);
  var moveLineDown = ({ state, dispatch: dispatch2 }) => moveLine(state, dispatch2, true);
  function copyLine(state, dispatch2, forward) {
    if (state.readOnly)
      return false;
    let changes = [];
    for (let block of selectedLineBlocks(state)) {
      if (forward)
        changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
      else
        changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
    }
    dispatch2(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
    return true;
  }
  var copyLineUp = ({ state, dispatch: dispatch2 }) => copyLine(state, dispatch2, false);
  var copyLineDown = ({ state, dispatch: dispatch2 }) => copyLine(state, dispatch2, true);
  var deleteLine = (view2) => {
    if (view2.state.readOnly)
      return false;
    let { state } = view2, changes = state.changes(selectedLineBlocks(state).map(({ from: from3, to }) => {
      if (from3 > 0)
        from3--;
      else if (to < state.doc.length)
        to++;
      return { from: from3, to };
    }));
    let selection = updateSel(state.selection, (range) => view2.moveVertically(range, true)).map(changes);
    view2.dispatch({ changes, selection, scrollIntoView: true, userEvent: "delete.line" });
    return true;
  };
  function isBetweenBrackets(state, pos) {
    if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
      return { from: pos, to: pos };
    let context = syntaxTree(state).resolveInner(pos);
    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from)
      return { from: before.to, to: after.from };
    return null;
  }
  var insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
  var insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
  function newlineAndIndent(atEof) {
    return ({ state, dispatch: dispatch2 }) => {
      if (state.readOnly)
        return false;
      let changes = state.changeByRange((range) => {
        let { from: from3, to } = range, line = state.doc.lineAt(from3);
        let explode = !atEof && from3 == to && isBetweenBrackets(state, from3);
        if (atEof)
          from3 = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
        let cx = new IndentContext(state, { simulateBreak: from3, simulateDoubleBreak: !!explode });
        let indent = getIndentation(cx, from3);
        if (indent == null)
          indent = /^\s*/.exec(state.doc.lineAt(from3).text)[0].length;
        while (to < line.to && /\s/.test(line.text[to - line.from]))
          to++;
        if (explode)
          ({ from: from3, to } = explode);
        else if (from3 > line.from && from3 < line.from + 100 && !/\S/.test(line.text.slice(0, from3)))
          from3 = line.from;
        let insert2 = ["", indentString(state, indent)];
        if (explode)
          insert2.push(indentString(state, cx.lineIndent(line.from, -1)));
        return {
          changes: { from: from3, to, insert: Text.of(insert2) },
          range: EditorSelection.cursor(from3 + 1 + insert2[1].length)
        };
      });
      dispatch2(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
      return true;
    };
  }
  function changeBySelectedLine(state, f) {
    let atLine = -1;
    return state.changeByRange((range) => {
      let changes = [];
      for (let pos = range.from; pos <= range.to; ) {
        let line = state.doc.lineAt(pos);
        if (line.number > atLine && (range.empty || range.to > line.from)) {
          f(line, changes, range);
          atLine = line.number;
        }
        pos = line.to + 1;
      }
      let changeSet = state.changes(changes);
      return {
        changes,
        range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
      };
    });
  }
  var indentSelection = ({ state, dispatch: dispatch2 }) => {
    if (state.readOnly)
      return false;
    let updated = /* @__PURE__ */ Object.create(null);
    let context = new IndentContext(state, { overrideIndentation: (start) => {
      let found = updated[start];
      return found == null ? -1 : found;
    } });
    let changes = changeBySelectedLine(state, (line, changes2, range) => {
      let indent = getIndentation(context, line.from);
      if (indent == null)
        return;
      if (!/\S/.test(line.text))
        indent = 0;
      let cur2 = /^\s*/.exec(line.text)[0];
      let norm2 = indentString(state, indent);
      if (cur2 != norm2 || range.from < line.from + cur2.length) {
        updated[line.from] = indent;
        changes2.push({ from: line.from, to: line.from + cur2.length, insert: norm2 });
      }
    });
    if (!changes.changes.empty)
      dispatch2(state.update(changes, { userEvent: "indent" }));
    return true;
  };
  var indentMore = ({ state, dispatch: dispatch2 }) => {
    if (state.readOnly)
      return false;
    dispatch2(state.update(changeBySelectedLine(state, (line, changes) => {
      changes.push({ from: line.from, insert: state.facet(indentUnit) });
    }), { userEvent: "input.indent" }));
    return true;
  };
  var indentLess = ({ state, dispatch: dispatch2 }) => {
    if (state.readOnly)
      return false;
    dispatch2(state.update(changeBySelectedLine(state, (line, changes) => {
      let space4 = /^\s*/.exec(line.text)[0];
      if (!space4)
        return;
      let col = countColumn(space4, state.tabSize), keep = 0;
      let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
      while (keep < space4.length && keep < insert2.length && space4.charCodeAt(keep) == insert2.charCodeAt(keep))
        keep++;
      changes.push({ from: line.from + keep, to: line.from + space4.length, insert: insert2.slice(keep) });
    }), { userEvent: "delete.dedent" }));
    return true;
  };
  var emacsStyleKeymap = [
    { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
    { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
    { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
    { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
    { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
    { key: "Ctrl-d", run: deleteCharForward },
    { key: "Ctrl-h", run: deleteCharBackward },
    { key: "Ctrl-k", run: deleteToLineEnd },
    { key: "Ctrl-Alt-h", run: deleteGroupBackward },
    { key: "Ctrl-o", run: splitLine },
    { key: "Ctrl-t", run: transposeChars },
    { key: "Ctrl-v", run: cursorPageDown }
  ];
  var standardKeymap = /* @__PURE__ */ [
    { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
    { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
    { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
    { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
    { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
    { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
    { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
    { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
    { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
    { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
    { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
    { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
    { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
    { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
    { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
    { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
    { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
    { key: "Enter", run: insertNewlineAndIndent },
    { key: "Mod-a", run: selectAll },
    { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
    { key: "Delete", run: deleteCharForward },
    { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
    { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
    { mac: "Mod-Backspace", run: deleteToLineStart },
    { mac: "Mod-Delete", run: deleteToLineEnd }
  ].concat(/* @__PURE__ */ emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })));
  var defaultKeymap = /* @__PURE__ */ [
    { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
    { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
    { key: "Alt-ArrowUp", run: moveLineUp },
    { key: "Shift-Alt-ArrowUp", run: copyLineUp },
    { key: "Alt-ArrowDown", run: moveLineDown },
    { key: "Shift-Alt-ArrowDown", run: copyLineDown },
    { key: "Escape", run: simplifySelection },
    { key: "Mod-Enter", run: insertBlankLine },
    { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
    { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
    { key: "Mod-[", run: indentLess },
    { key: "Mod-]", run: indentMore },
    { key: "Mod-Alt-\\", run: indentSelection },
    { key: "Shift-Mod-k", run: deleteLine },
    { key: "Shift-Mod-\\", run: cursorMatchingBracket },
    { key: "Mod-/", run: toggleComment },
    { key: "Alt-A", run: toggleBlockComment }
  ].concat(standardKeymap);

  // node_modules/crelt/index.es.js
  function crelt() {
    var elt2 = arguments[0];
    if (typeof elt2 == "string")
      elt2 = document.createElement(elt2);
    var i = 1, next = arguments[1];
    if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
      for (var name2 in next)
        if (Object.prototype.hasOwnProperty.call(next, name2)) {
          var value = next[name2];
          if (typeof value == "string")
            elt2.setAttribute(name2, value);
          else if (value != null)
            elt2[name2] = value;
        }
      i++;
    }
    for (; i < arguments.length; i++)
      add2(elt2, arguments[i]);
    return elt2;
  }
  function add2(elt2, child) {
    if (typeof child == "string") {
      elt2.appendChild(document.createTextNode(child));
    } else if (child == null) {
    } else if (child.nodeType != null) {
      elt2.appendChild(child);
    } else if (Array.isArray(child)) {
      for (var i = 0; i < child.length; i++)
        add2(elt2, child[i]);
    } else {
      throw new RangeError("Unsupported child node: " + child);
    }
  }

  // node_modules/@codemirror/search/dist/index.js
  var basicNormalize = typeof String.prototype.normalize == "function" ? (x3) => x3.normalize("NFKD") : (x3) => x3;
  var SearchCursor = class {
    constructor(text3, query, from3 = 0, to = text3.length, normalize, test) {
      this.test = test;
      this.value = { from: 0, to: 0 };
      this.done = false;
      this.matches = [];
      this.buffer = "";
      this.bufferPos = 0;
      this.iter = text3.iterRange(from3, to);
      this.bufferStart = from3;
      this.normalize = normalize ? (x3) => normalize(basicNormalize(x3)) : basicNormalize;
      this.query = this.normalize(query);
    }
    peek() {
      if (this.bufferPos == this.buffer.length) {
        this.bufferStart += this.buffer.length;
        this.iter.next();
        if (this.iter.done)
          return -1;
        this.bufferPos = 0;
        this.buffer = this.iter.value;
      }
      return codePointAt(this.buffer, this.bufferPos);
    }
    next() {
      while (this.matches.length)
        this.matches.pop();
      return this.nextOverlapping();
    }
    nextOverlapping() {
      for (; ; ) {
        let next = this.peek();
        if (next < 0) {
          this.done = true;
          return this;
        }
        let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
        this.bufferPos += codePointSize(next);
        let norm2 = this.normalize(str);
        for (let i = 0, pos = start; ; i++) {
          let code = norm2.charCodeAt(i);
          let match = this.match(code, pos);
          if (match) {
            this.value = match;
            return this;
          }
          if (i == norm2.length - 1)
            break;
          if (pos == start && i < str.length && str.charCodeAt(i) == code)
            pos++;
        }
      }
    }
    match(code, pos) {
      let match = null;
      for (let i = 0; i < this.matches.length; i += 2) {
        let index2 = this.matches[i], keep = false;
        if (this.query.charCodeAt(index2) == code) {
          if (index2 == this.query.length - 1) {
            match = { from: this.matches[i + 1], to: pos + 1 };
          } else {
            this.matches[i]++;
            keep = true;
          }
        }
        if (!keep) {
          this.matches.splice(i, 2);
          i -= 2;
        }
      }
      if (this.query.charCodeAt(0) == code) {
        if (this.query.length == 1)
          match = { from: pos, to: pos + 1 };
        else
          this.matches.push(1, pos);
      }
      if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferPos))
        match = null;
      return match;
    }
  };
  if (typeof Symbol != "undefined")
    SearchCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  var empty = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") };
  var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
  var RegExpCursor = class {
    constructor(text3, query, options, from3 = 0, to = text3.length) {
      this.text = text3;
      this.to = to;
      this.curLine = "";
      this.done = false;
      this.value = empty;
      if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
        return new MultilineRegExpCursor(text3, query, options, from3, to);
      this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
      this.test = options === null || options === void 0 ? void 0 : options.test;
      this.iter = text3.iter();
      let startLine = text3.lineAt(from3);
      this.curLineStart = startLine.from;
      this.matchPos = toCharEnd(text3, from3);
      this.getLine(this.curLineStart);
    }
    getLine(skip) {
      this.iter.next(skip);
      if (this.iter.lineBreak) {
        this.curLine = "";
      } else {
        this.curLine = this.iter.value;
        if (this.curLineStart + this.curLine.length > this.to)
          this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
        this.iter.next();
      }
    }
    nextLine() {
      this.curLineStart = this.curLineStart + this.curLine.length + 1;
      if (this.curLineStart > this.to)
        this.curLine = "";
      else
        this.getLine(0);
    }
    next() {
      for (let off = this.matchPos - this.curLineStart; ; ) {
        this.re.lastIndex = off;
        let match = this.matchPos <= this.to && this.re.exec(this.curLine);
        if (match) {
          let from3 = this.curLineStart + match.index, to = from3 + match[0].length;
          this.matchPos = toCharEnd(this.text, to + (from3 == to ? 1 : 0));
          if (from3 == this.curLineStart + this.curLine.length)
            this.nextLine();
          if ((from3 < to || from3 > this.value.to) && (!this.test || this.test(from3, to, match))) {
            this.value = { from: from3, to, match };
            return this;
          }
          off = this.matchPos - this.curLineStart;
        } else if (this.curLineStart + this.curLine.length < this.to) {
          this.nextLine();
          off = 0;
        } else {
          this.done = true;
          return this;
        }
      }
    }
  };
  var flattened = /* @__PURE__ */ new WeakMap();
  var FlattenedDoc = class {
    constructor(from3, text3) {
      this.from = from3;
      this.text = text3;
    }
    get to() {
      return this.from + this.text.length;
    }
    static get(doc3, from3, to) {
      let cached = flattened.get(doc3);
      if (!cached || cached.from >= to || cached.to <= from3) {
        let flat = new FlattenedDoc(from3, doc3.sliceString(from3, to));
        flattened.set(doc3, flat);
        return flat;
      }
      if (cached.from == from3 && cached.to == to)
        return cached;
      let { text: text3, from: cachedFrom } = cached;
      if (cachedFrom > from3) {
        text3 = doc3.sliceString(from3, cachedFrom) + text3;
        cachedFrom = from3;
      }
      if (cached.to < to)
        text3 += doc3.sliceString(cached.to, to);
      flattened.set(doc3, new FlattenedDoc(cachedFrom, text3));
      return new FlattenedDoc(from3, text3.slice(from3 - cachedFrom, to - cachedFrom));
    }
  };
  var MultilineRegExpCursor = class {
    constructor(text3, query, options, from3, to) {
      this.text = text3;
      this.to = to;
      this.done = false;
      this.value = empty;
      this.matchPos = toCharEnd(text3, from3);
      this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
      this.test = options === null || options === void 0 ? void 0 : options.test;
      this.flat = FlattenedDoc.get(text3, from3, this.chunkEnd(from3 + 5e3));
    }
    chunkEnd(pos) {
      return pos >= this.to ? this.to : this.text.lineAt(pos).to;
    }
    next() {
      for (; ; ) {
        let off = this.re.lastIndex = this.matchPos - this.flat.from;
        let match = this.re.exec(this.flat.text);
        if (match && !match[0] && match.index == off) {
          this.re.lastIndex = off + 1;
          match = this.re.exec(this.flat.text);
        }
        if (match) {
          let from3 = this.flat.from + match.index, to = from3 + match[0].length;
          if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from3, to, match))) {
            this.value = { from: from3, to, match };
            this.matchPos = toCharEnd(this.text, to + (from3 == to ? 1 : 0));
            return this;
          }
        }
        if (this.flat.to == this.to) {
          this.done = true;
          return this;
        }
        this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
      }
    }
  };
  if (typeof Symbol != "undefined") {
    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  function validRegExp(source) {
    try {
      new RegExp(source, baseFlags);
      return true;
    } catch (_a2) {
      return false;
    }
  }
  function toCharEnd(text3, pos) {
    if (pos >= text3.length)
      return pos;
    let line = text3.lineAt(pos), next;
    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344)
      pos++;
    return pos;
  }
  function createLineDialog(view2) {
    let input = crelt("input", { class: "cm-textfield", name: "line" });
    let dom = crelt("form", {
      class: "cm-gotoLine",
      onkeydown: (event) => {
        if (event.keyCode == 27) {
          event.preventDefault();
          view2.dispatch({ effects: dialogEffect.of(false) });
          view2.focus();
        } else if (event.keyCode == 13) {
          event.preventDefault();
          go();
        }
      },
      onsubmit: (event) => {
        event.preventDefault();
        go();
      }
    }, crelt("label", view2.state.phrase("Go to line"), ": ", input), " ", crelt("button", { class: "cm-button", type: "submit" }, view2.state.phrase("go")));
    function go() {
      let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
      if (!match)
        return;
      let { state } = view2, startLine = state.doc.lineAt(state.selection.main.head);
      let [, sign, ln, cl, percent2] = match;
      let col = cl ? +cl.slice(1) : 0;
      let line = ln ? +ln : startLine.number;
      if (ln && percent2) {
        let pc = line / 100;
        if (sign)
          pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
        line = Math.round(state.doc.lines * pc);
      } else if (ln && sign) {
        line = line * (sign == "-" ? -1 : 1) + startLine.number;
      }
      let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));
      view2.dispatch({
        effects: dialogEffect.of(false),
        selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),
        scrollIntoView: true
      });
      view2.focus();
    }
    return { dom };
  }
  var dialogEffect = /* @__PURE__ */ StateEffect.define();
  var dialogField = /* @__PURE__ */ StateField.define({
    create() {
      return true;
    },
    update(value, tr) {
      for (let e of tr.effects)
        if (e.is(dialogEffect))
          value = e.value;
      return value;
    },
    provide: (f) => showPanel.from(f, (val) => val ? createLineDialog : null)
  });
  var gotoLine = (view2) => {
    let panel = getPanel(view2, createLineDialog);
    if (!panel) {
      let effects = [dialogEffect.of(true)];
      if (view2.state.field(dialogField, false) == null)
        effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$13]));
      view2.dispatch({ effects });
      panel = getPanel(view2, createLineDialog);
    }
    if (panel)
      panel.dom.querySelector("input").focus();
    return true;
  };
  var baseTheme$13 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-panel.cm-gotoLine": {
      padding: "2px 6px 4px",
      "& label": { fontSize: "80%" }
    }
  });
  var defaultHighlightOptions = {
    highlightWordAroundCursor: false,
    minSelectionLength: 1,
    maxMatches: 100,
    wholeWords: false
  };
  var highlightConfig = /* @__PURE__ */ Facet.define({
    combine(options) {
      return combineConfig(options, defaultHighlightOptions, {
        highlightWordAroundCursor: (a2, b) => a2 || b,
        minSelectionLength: Math.min,
        maxMatches: Math.min
      });
    }
  });
  function highlightSelectionMatches(options) {
    let ext = [defaultTheme, matchHighlighter];
    if (options)
      ext.push(highlightConfig.of(options));
    return ext;
  }
  var matchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch" });
  var mainMatchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
  function insideWordBoundaries(check, state, from3, to) {
    return (from3 == 0 || check(state.sliceDoc(from3 - 1, from3)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);
  }
  function insideWord(check, state, from3, to) {
    return check(state.sliceDoc(from3, from3 + 1)) == CharCategory.Word && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;
  }
  var matchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view2) {
      this.decorations = this.getDeco(view2);
    }
    update(update) {
      if (update.selectionSet || update.docChanged || update.viewportChanged)
        this.decorations = this.getDeco(update.view);
    }
    getDeco(view2) {
      let conf = view2.state.facet(highlightConfig);
      let { state } = view2, sel = state.selection;
      if (sel.ranges.length > 1)
        return Decoration.none;
      let range = sel.main, query, check = null;
      if (range.empty) {
        if (!conf.highlightWordAroundCursor)
          return Decoration.none;
        let word = state.wordAt(range.head);
        if (!word)
          return Decoration.none;
        check = state.charCategorizer(range.head);
        query = state.sliceDoc(word.from, word.to);
      } else {
        let len = range.to - range.from;
        if (len < conf.minSelectionLength || len > 200)
          return Decoration.none;
        if (conf.wholeWords) {
          query = state.sliceDoc(range.from, range.to);
          check = state.charCategorizer(range.head);
          if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to)))
            return Decoration.none;
        } else {
          query = state.sliceDoc(range.from, range.to).trim();
          if (!query)
            return Decoration.none;
        }
      }
      let deco = [];
      for (let part of view2.visibleRanges) {
        let cursor = new SearchCursor(state.doc, query, part.from, part.to);
        while (!cursor.next().done) {
          let { from: from3, to } = cursor.value;
          if (!check || insideWordBoundaries(check, state, from3, to)) {
            if (range.empty && from3 <= range.from && to >= range.to)
              deco.push(mainMatchDeco.range(from3, to));
            else if (from3 >= range.to || to <= range.from)
              deco.push(matchDeco.range(from3, to));
            if (deco.length > conf.maxMatches)
              return Decoration.none;
          }
        }
      }
      return Decoration.set(deco);
    }
  }, {
    decorations: (v) => v.decorations
  });
  var defaultTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
    ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
  });
  var selectWord = ({ state, dispatch: dispatch2 }) => {
    let { selection } = state;
    let newSel = EditorSelection.create(selection.ranges.map((range) => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);
    if (newSel.eq(selection))
      return false;
    dispatch2(state.update({ selection: newSel }));
    return true;
  };
  function findNextOccurrence(state, query) {
    let { main, ranges } = state.selection;
    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ; ) {
      cursor.next();
      if (cursor.done) {
        if (cycled)
          return null;
        cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
        cycled = true;
      } else {
        if (cycled && ranges.some((r) => r.from == cursor.value.from))
          continue;
        if (fullWord) {
          let word2 = state.wordAt(cursor.value.from);
          if (!word2 || word2.from != cursor.value.from || word2.to != cursor.value.to)
            continue;
        }
        return cursor.value;
      }
    }
  }
  var selectNextOccurrence = ({ state, dispatch: dispatch2 }) => {
    let { ranges } = state.selection;
    if (ranges.some((sel) => sel.from === sel.to))
      return selectWord({ state, dispatch: dispatch2 });
    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
    if (state.selection.ranges.some((r) => state.sliceDoc(r.from, r.to) != searchedText))
      return false;
    let range = findNextOccurrence(state, searchedText);
    if (!range)
      return false;
    dispatch2(state.update({
      selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
      effects: EditorView.scrollIntoView(range.to)
    }));
    return true;
  };
  var searchConfigFacet = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        top: false,
        caseSensitive: false,
        literal: false,
        wholeWord: false,
        createPanel: (view2) => new SearchPanel(view2)
      });
    }
  });
  var SearchQuery = class {
    constructor(config2) {
      this.search = config2.search;
      this.caseSensitive = !!config2.caseSensitive;
      this.literal = !!config2.literal;
      this.regexp = !!config2.regexp;
      this.replace = config2.replace || "";
      this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
      this.unquoted = this.unquote(this.search);
      this.wholeWord = !!config2.wholeWord;
    }
    unquote(text3) {
      return this.literal ? text3 : text3.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
    }
    eq(other) {
      return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
    }
    create() {
      return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
    }
    getCursor(state, from3 = 0, to) {
      let st = state.doc ? state : EditorState.create({ doc: state });
      if (to == null)
        to = st.doc.length;
      return this.regexp ? regexpCursor(this, st, from3, to) : stringCursor(this, st, from3, to);
    }
  };
  var QueryType2 = class {
    constructor(spec) {
      this.spec = spec;
    }
  };
  function stringCursor(spec, state, from3, to) {
    return new SearchCursor(state.doc, spec.unquoted, from3, to, spec.caseSensitive ? void 0 : (x3) => x3.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
  }
  function stringWordTest(doc3, categorizer) {
    return (from3, to, buf, bufPos) => {
      if (bufPos > from3 || bufPos + buf.length < to) {
        bufPos = Math.max(0, from3 - 2);
        buf = doc3.sliceString(bufPos, Math.min(doc3.length, to + 2));
      }
      return (categorizer(charBefore(buf, from3 - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from3 - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);
    };
  }
  var StringQuery = class extends QueryType2 {
    constructor(spec) {
      super(spec);
    }
    nextMatch(state, curFrom, curTo) {
      let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
      if (cursor.done)
        cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();
      return cursor.done ? null : cursor.value;
    }
    prevMatchInRange(state, from3, to) {
      for (let pos = to; ; ) {
        let start = Math.max(from3, pos - 1e4 - this.spec.unquoted.length);
        let cursor = stringCursor(this.spec, state, start, pos), range = null;
        while (!cursor.nextOverlapping().done)
          range = cursor.value;
        if (range)
          return range;
        if (start == from3)
          return null;
        pos -= 1e4;
      }
    }
    prevMatch(state, curFrom, curTo) {
      return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
    }
    getReplacement(_result) {
      return this.spec.unquote(this.spec.replace);
    }
    matchAll(state, limit) {
      let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
      while (!cursor.next().done) {
        if (ranges.length >= limit)
          return null;
        ranges.push(cursor.value);
      }
      return ranges;
    }
    highlight(state, from3, to, add3) {
      let cursor = stringCursor(this.spec, state, Math.max(0, from3 - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
      while (!cursor.next().done)
        add3(cursor.value.from, cursor.value.to);
    }
  };
  function regexpCursor(spec, state, from3, to) {
    return new RegExpCursor(state.doc, spec.search, {
      ignoreCase: !spec.caseSensitive,
      test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
    }, from3, to);
  }
  function charBefore(str, index2) {
    return str.slice(findClusterBreak(str, index2, false), index2);
  }
  function charAfter(str, index2) {
    return str.slice(index2, findClusterBreak(str, index2));
  }
  function regexpWordTest(categorizer) {
    return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != CharCategory.Word || categorizer(charAfter(match.input, match.index)) != CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);
  }
  var RegExpQuery = class extends QueryType2 {
    nextMatch(state, curFrom, curTo) {
      let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();
      if (cursor.done)
        cursor = regexpCursor(this.spec, state, 0, curFrom).next();
      return cursor.done ? null : cursor.value;
    }
    prevMatchInRange(state, from3, to) {
      for (let size = 1; ; size++) {
        let start = Math.max(from3, to - size * 1e4);
        let cursor = regexpCursor(this.spec, state, start, to), range = null;
        while (!cursor.next().done)
          range = cursor.value;
        if (range && (start == from3 || range.from > start + 10))
          return range;
        if (start == from3)
          return null;
      }
    }
    prevMatch(state, curFrom, curTo) {
      return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
    }
    getReplacement(result) {
      return this.spec.unquote(this.spec.replace.replace(/\$([$&\d+])/g, (m2, i) => i == "$" ? "$" : i == "&" ? result.match[0] : i != "0" && +i < result.match.length ? result.match[i] : m2));
    }
    matchAll(state, limit) {
      let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
      while (!cursor.next().done) {
        if (ranges.length >= limit)
          return null;
        ranges.push(cursor.value);
      }
      return ranges;
    }
    highlight(state, from3, to, add3) {
      let cursor = regexpCursor(this.spec, state, Math.max(0, from3 - 250), Math.min(to + 250, state.doc.length));
      while (!cursor.next().done)
        add3(cursor.value.from, cursor.value.to);
    }
  };
  var setSearchQuery = /* @__PURE__ */ StateEffect.define();
  var togglePanel = /* @__PURE__ */ StateEffect.define();
  var searchState = /* @__PURE__ */ StateField.define({
    create(state) {
      return new SearchState(defaultQuery(state).create(), null);
    },
    update(value, tr) {
      for (let effect of tr.effects) {
        if (effect.is(setSearchQuery))
          value = new SearchState(effect.value.create(), value.panel);
        else if (effect.is(togglePanel))
          value = new SearchState(value.query, effect.value ? createSearchPanel : null);
      }
      return value;
    },
    provide: (f) => showPanel.from(f, (val) => val.panel)
  });
  var SearchState = class {
    constructor(query, panel) {
      this.query = query;
      this.panel = panel;
    }
  };
  var matchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch" });
  var selectedMatchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
  var searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view2) {
      this.view = view2;
      this.decorations = this.highlight(view2.state.field(searchState));
    }
    update(update) {
      let state = update.state.field(searchState);
      if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
        this.decorations = this.highlight(state);
    }
    highlight({ query, panel }) {
      if (!panel || !query.spec.valid)
        return Decoration.none;
      let { view: view2 } = this;
      let builder = new RangeSetBuilder();
      for (let i = 0, ranges = view2.visibleRanges, l = ranges.length; i < l; i++) {
        let { from: from3, to } = ranges[i];
        while (i < l - 1 && to > ranges[i + 1].from - 2 * 250)
          to = ranges[++i].to;
        query.highlight(view2.state, from3, to, (from4, to2) => {
          let selected = view2.state.selection.ranges.some((r) => r.from == from4 && r.to == to2);
          builder.add(from4, to2, selected ? selectedMatchMark : matchMark);
        });
      }
      return builder.finish();
    }
  }, {
    decorations: (v) => v.decorations
  });
  function searchCommand(f) {
    return (view2) => {
      let state = view2.state.field(searchState, false);
      return state && state.query.spec.valid ? f(view2, state) : openSearchPanel(view2);
    };
  }
  var findNext = /* @__PURE__ */ searchCommand((view2, { query }) => {
    let { to } = view2.state.selection.main;
    let next = query.nextMatch(view2.state, to, to);
    if (!next)
      return false;
    view2.dispatch({
      selection: { anchor: next.from, head: next.to },
      scrollIntoView: true,
      effects: announceMatch(view2, next),
      userEvent: "select.search"
    });
    return true;
  });
  var findPrevious = /* @__PURE__ */ searchCommand((view2, { query }) => {
    let { state } = view2, { from: from3 } = state.selection.main;
    let range = query.prevMatch(state, from3, from3);
    if (!range)
      return false;
    view2.dispatch({
      selection: { anchor: range.from, head: range.to },
      scrollIntoView: true,
      effects: announceMatch(view2, range),
      userEvent: "select.search"
    });
    return true;
  });
  var selectMatches = /* @__PURE__ */ searchCommand((view2, { query }) => {
    let ranges = query.matchAll(view2.state, 1e3);
    if (!ranges || !ranges.length)
      return false;
    view2.dispatch({
      selection: EditorSelection.create(ranges.map((r) => EditorSelection.range(r.from, r.to))),
      userEvent: "select.search.matches"
    });
    return true;
  });
  var selectSelectionMatches = ({ state, dispatch: dispatch2 }) => {
    let sel = state.selection;
    if (sel.ranges.length > 1 || sel.main.empty)
      return false;
    let { from: from3, to } = sel.main;
    let ranges = [], main = 0;
    for (let cur2 = new SearchCursor(state.doc, state.sliceDoc(from3, to)); !cur2.next().done; ) {
      if (ranges.length > 1e3)
        return false;
      if (cur2.value.from == from3)
        main = ranges.length;
      ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to));
    }
    dispatch2(state.update({
      selection: EditorSelection.create(ranges, main),
      userEvent: "select.search.matches"
    }));
    return true;
  };
  var replaceNext = /* @__PURE__ */ searchCommand((view2, { query }) => {
    let { state } = view2, { from: from3, to } = state.selection.main;
    if (state.readOnly)
      return false;
    let next = query.nextMatch(state, from3, from3);
    if (!next)
      return false;
    let changes = [], selection, replacement;
    let announce = [];
    if (next.from == from3 && next.to == to) {
      replacement = state.toText(query.getReplacement(next));
      changes.push({ from: next.from, to: next.to, insert: replacement });
      next = query.nextMatch(state, next.from, next.to);
      announce.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from3).number) + "."));
    }
    if (next) {
      let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
      selection = { anchor: next.from - off, head: next.to - off };
      announce.push(announceMatch(view2, next));
    }
    view2.dispatch({
      changes,
      selection,
      scrollIntoView: !!selection,
      effects: announce,
      userEvent: "input.replace"
    });
    return true;
  });
  var replaceAll = /* @__PURE__ */ searchCommand((view2, { query }) => {
    if (view2.state.readOnly)
      return false;
    let changes = query.matchAll(view2.state, 1e9).map((match) => {
      let { from: from3, to } = match;
      return { from: from3, to, insert: query.getReplacement(match) };
    });
    if (!changes.length)
      return false;
    let announceText = view2.state.phrase("replaced $ matches", changes.length) + ".";
    view2.dispatch({
      changes,
      effects: EditorView.announce.of(announceText),
      userEvent: "input.replace.all"
    });
    return true;
  });
  function createSearchPanel(view2) {
    return view2.state.facet(searchConfigFacet).createPanel(view2);
  }
  function defaultQuery(state, fallback) {
    var _a2, _b, _c, _d;
    let sel = state.selection.main;
    let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
    if (fallback && !selText)
      return fallback;
    let config2 = state.facet(searchConfigFacet);
    return new SearchQuery({
      search: ((_a2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a2 !== void 0 ? _a2 : config2.literal) ? selText : selText.replace(/\n/g, "\\n"),
      caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config2.caseSensitive,
      literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config2.literal,
      wholeWord: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _d !== void 0 ? _d : config2.wholeWord
    });
  }
  var openSearchPanel = (view2) => {
    let state = view2.state.field(searchState, false);
    if (state && state.panel) {
      let panel = getPanel(view2, createSearchPanel);
      if (!panel)
        return false;
      let searchInput = panel.dom.querySelector("[main-field]");
      if (searchInput && searchInput != view2.root.activeElement) {
        let query = defaultQuery(view2.state, state.query.spec);
        if (query.valid)
          view2.dispatch({ effects: setSearchQuery.of(query) });
        searchInput.focus();
        searchInput.select();
      }
    } else {
      view2.dispatch({ effects: [
        togglePanel.of(true),
        state ? setSearchQuery.of(defaultQuery(view2.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
      ] });
    }
    return true;
  };
  var closeSearchPanel = (view2) => {
    let state = view2.state.field(searchState, false);
    if (!state || !state.panel)
      return false;
    let panel = getPanel(view2, createSearchPanel);
    if (panel && panel.dom.contains(view2.root.activeElement))
      view2.focus();
    view2.dispatch({ effects: togglePanel.of(false) });
    return true;
  };
  var searchKeymap = [
    { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
    { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
    { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
    { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
    { key: "Mod-Shift-l", run: selectSelectionMatches },
    { key: "Alt-g", run: gotoLine },
    { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
  ];
  var SearchPanel = class {
    constructor(view2) {
      this.view = view2;
      let query = this.query = view2.state.field(searchState).query.spec;
      this.commit = this.commit.bind(this);
      this.searchField = crelt("input", {
        value: query.search,
        placeholder: phrase(view2, "Find"),
        "aria-label": phrase(view2, "Find"),
        class: "cm-textfield",
        name: "search",
        form: "",
        "main-field": "true",
        onchange: this.commit,
        onkeyup: this.commit
      });
      this.replaceField = crelt("input", {
        value: query.replace,
        placeholder: phrase(view2, "Replace"),
        "aria-label": phrase(view2, "Replace"),
        class: "cm-textfield",
        name: "replace",
        form: "",
        onchange: this.commit,
        onkeyup: this.commit
      });
      this.caseField = crelt("input", {
        type: "checkbox",
        name: "case",
        form: "",
        checked: query.caseSensitive,
        onchange: this.commit
      });
      this.reField = crelt("input", {
        type: "checkbox",
        name: "re",
        form: "",
        checked: query.regexp,
        onchange: this.commit
      });
      this.wordField = crelt("input", {
        type: "checkbox",
        name: "word",
        form: "",
        checked: query.wholeWord,
        onchange: this.commit
      });
      function button(name2, onclick, content2) {
        return crelt("button", { class: "cm-button", name: name2, onclick, type: "button" }, content2);
      }
      this.dom = crelt("div", { onkeydown: (e) => this.keydown(e), class: "cm-search" }, [
        this.searchField,
        button("next", () => findNext(view2), [phrase(view2, "next")]),
        button("prev", () => findPrevious(view2), [phrase(view2, "previous")]),
        button("select", () => selectMatches(view2), [phrase(view2, "all")]),
        crelt("label", null, [this.caseField, phrase(view2, "match case")]),
        crelt("label", null, [this.reField, phrase(view2, "regexp")]),
        crelt("label", null, [this.wordField, phrase(view2, "by word")]),
        ...view2.state.readOnly ? [] : [
          crelt("br"),
          this.replaceField,
          button("replace", () => replaceNext(view2), [phrase(view2, "replace")]),
          button("replaceAll", () => replaceAll(view2), [phrase(view2, "replace all")])
        ],
        crelt("button", {
          name: "close",
          onclick: () => closeSearchPanel(view2),
          "aria-label": phrase(view2, "close"),
          type: "button"
        }, ["\xD7"])
      ]);
    }
    commit() {
      let query = new SearchQuery({
        search: this.searchField.value,
        caseSensitive: this.caseField.checked,
        regexp: this.reField.checked,
        wholeWord: this.wordField.checked,
        replace: this.replaceField.value
      });
      if (!query.eq(this.query)) {
        this.query = query;
        this.view.dispatch({ effects: setSearchQuery.of(query) });
      }
    }
    keydown(e) {
      if (runScopeHandlers(this.view, e, "search-panel")) {
        e.preventDefault();
      } else if (e.keyCode == 13 && e.target == this.searchField) {
        e.preventDefault();
        (e.shiftKey ? findPrevious : findNext)(this.view);
      } else if (e.keyCode == 13 && e.target == this.replaceField) {
        e.preventDefault();
        replaceNext(this.view);
      }
    }
    update(update) {
      for (let tr of update.transactions)
        for (let effect of tr.effects) {
          if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
            this.setQuery(effect.value);
        }
    }
    setQuery(query) {
      this.query = query;
      this.searchField.value = query.search;
      this.replaceField.value = query.replace;
      this.caseField.checked = query.caseSensitive;
      this.reField.checked = query.regexp;
      this.wordField.checked = query.wholeWord;
    }
    mount() {
      this.searchField.select();
    }
    get pos() {
      return 80;
    }
    get top() {
      return this.view.state.facet(searchConfigFacet).top;
    }
  };
  function phrase(view2, phrase2) {
    return view2.state.phrase(phrase2);
  }
  var AnnounceMargin = 30;
  var Break = /[\s\.,:;?!]/;
  function announceMatch(view2, { from: from3, to }) {
    let line = view2.state.doc.lineAt(from3), lineEnd2 = view2.state.doc.lineAt(to).to;
    let start = Math.max(line.from, from3 - AnnounceMargin), end = Math.min(lineEnd2, to + AnnounceMargin);
    let text3 = view2.state.sliceDoc(start, end);
    if (start != line.from) {
      for (let i = 0; i < AnnounceMargin; i++)
        if (!Break.test(text3[i + 1]) && Break.test(text3[i])) {
          text3 = text3.slice(i);
          break;
        }
    }
    if (end != lineEnd2) {
      for (let i = text3.length - 1; i > text3.length - AnnounceMargin; i--)
        if (!Break.test(text3[i - 1]) && Break.test(text3[i])) {
          text3 = text3.slice(0, i);
          break;
        }
    }
    return EditorView.announce.of(`${view2.state.phrase("current match")}. ${text3} ${view2.state.phrase("on line")} ${line.number}.`);
  }
  var baseTheme3 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-panel.cm-search": {
      padding: "2px 6px 4px",
      position: "relative",
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "4px",
        backgroundColor: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      },
      "& input, & button, & label": {
        margin: ".2em .6em .2em 0"
      },
      "& input[type=checkbox]": {
        marginRight: ".2em"
      },
      "& label": {
        fontSize: "80%",
        whiteSpace: "pre"
      }
    },
    "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
    "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
    "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
    "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
  });
  var searchExtensions = [
    searchState,
    /* @__PURE__ */ Prec.lowest(searchHighlighter),
    baseTheme3
  ];

  // node_modules/@codemirror/autocomplete/dist/index.js
  var CompletionContext = class {
    constructor(state, pos, explicit) {
      this.state = state;
      this.pos = pos;
      this.explicit = explicit;
      this.abortListeners = [];
    }
    tokenBefore(types2) {
      let token = syntaxTree(this.state).resolveInner(this.pos, -1);
      while (token && types2.indexOf(token.name) < 0)
        token = token.parent;
      return token ? {
        from: token.from,
        to: this.pos,
        text: this.state.sliceDoc(token.from, this.pos),
        type: token.type
      } : null;
    }
    matchBefore(expr) {
      let line = this.state.doc.lineAt(this.pos);
      let start = Math.max(line.from, this.pos - 250);
      let str = line.text.slice(start - line.from, this.pos - line.from);
      let found = str.search(ensureAnchor(expr, false));
      return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
    }
    get aborted() {
      return this.abortListeners == null;
    }
    addEventListener(type, listener) {
      if (type == "abort" && this.abortListeners)
        this.abortListeners.push(listener);
    }
  };
  function toSet(chars) {
    let flat = Object.keys(chars).join("");
    let words = /\w/.test(flat);
    if (words)
      flat = flat.replace(/\w/g, "");
    return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
  }
  function prefixMatch(options) {
    let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
    for (let { label } of options) {
      first[label[0]] = true;
      for (let i = 1; i < label.length; i++)
        rest[label[i]] = true;
    }
    let source = toSet(first) + toSet(rest) + "*$";
    return [new RegExp("^" + source), new RegExp(source)];
  }
  function completeFromList(list) {
    let options = list.map((o) => typeof o == "string" ? { label: o } : o);
    let [validFor, match] = options.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
    return (context) => {
      let token = context.matchBefore(match);
      return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;
    };
  }
  function ifNotIn(nodes, source) {
    return (context) => {
      for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent)
        if (nodes.indexOf(pos.name) > -1)
          return null;
      return source(context);
    };
  }
  var Option = class {
    constructor(completion, source, match) {
      this.completion = completion;
      this.source = source;
      this.match = match;
    }
  };
  function cur(state) {
    return state.selection.main.head;
  }
  function ensureAnchor(expr, start) {
    var _a2;
    let { source } = expr;
    let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
    if (!addStart && !addEnd)
      return expr;
    return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a2 = expr.flags) !== null && _a2 !== void 0 ? _a2 : expr.ignoreCase ? "i" : "");
  }
  var pickedCompletion = /* @__PURE__ */ Annotation.define();
  function insertCompletionText(state, text3, from3, to) {
    return Object.assign(Object.assign({}, state.changeByRange((range) => {
      if (range == state.selection.main)
        return {
          changes: { from: from3, to, insert: text3 },
          range: EditorSelection.cursor(from3 + text3.length)
        };
      let len = to - from3;
      if (!range.empty || len && state.sliceDoc(range.from - len, range.from) != state.sliceDoc(from3, to))
        return { range };
      return {
        changes: { from: range.from - len, to: range.from, insert: text3 },
        range: EditorSelection.cursor(range.from - len + text3.length)
      };
    })), { userEvent: "input.complete" });
  }
  function applyCompletion(view2, option) {
    const apply = option.completion.apply || option.completion.label;
    let result = option.source;
    if (typeof apply == "string")
      view2.dispatch(Object.assign(Object.assign({}, insertCompletionText(view2.state, apply, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));
    else
      apply(view2, option.completion, result.from, result.to);
  }
  var SourceCache = /* @__PURE__ */ new WeakMap();
  function asSource(source) {
    if (!Array.isArray(source))
      return source;
    let known = SourceCache.get(source);
    if (!known)
      SourceCache.set(source, known = completeFromList(source));
    return known;
  }
  var FuzzyMatcher = class {
    constructor(pattern) {
      this.pattern = pattern;
      this.chars = [];
      this.folded = [];
      this.any = [];
      this.precise = [];
      this.byWord = [];
      for (let p = 0; p < pattern.length; ) {
        let char = codePointAt(pattern, p), size = codePointSize(char);
        this.chars.push(char);
        let part = pattern.slice(p, p + size), upper = part.toUpperCase();
        this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));
        p += size;
      }
      this.astral = pattern.length != this.chars.length;
    }
    match(word) {
      if (this.pattern.length == 0)
        return [0];
      if (word.length < this.pattern.length)
        return null;
      let { chars, folded, any: any2, precise, byWord } = this;
      if (chars.length == 1) {
        let first = codePointAt(word, 0);
        return first == chars[0] ? [0, 0, codePointSize(first)] : first == folded[0] ? [-200, 0, codePointSize(first)] : null;
      }
      let direct = word.indexOf(this.pattern);
      if (direct == 0)
        return [0, 0, this.pattern.length];
      let len = chars.length, anyTo = 0;
      if (direct < 0) {
        for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len; ) {
          let next = codePointAt(word, i);
          if (next == chars[anyTo] || next == folded[anyTo])
            any2[anyTo++] = i;
          i += codePointSize(next);
        }
        if (anyTo < len)
          return null;
      }
      let preciseTo = 0;
      let byWordTo = 0, byWordFolded = false;
      let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
      let hasLower = /[a-z]/.test(word), wordAdjacent = true;
      for (let i = 0, e = Math.min(word.length, 200), prevType = 0; i < e && byWordTo < len; ) {
        let next = codePointAt(word, i);
        if (direct < 0) {
          if (preciseTo < len && next == chars[preciseTo])
            precise[preciseTo++] = i;
          if (adjacentTo < len) {
            if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
              if (adjacentTo == 0)
                adjacentStart = i;
              adjacentEnd = i + 1;
              adjacentTo++;
            } else {
              adjacentTo = 0;
            }
          }
        }
        let ch, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
        if (!i || type == 1 && hasLower || prevType == 0 && type != 0) {
          if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
            byWord[byWordTo++] = i;
          else if (byWord.length)
            wordAdjacent = false;
        }
        prevType = type;
        i += codePointSize(next);
      }
      if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
        return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
      if (adjacentTo == len && adjacentStart == 0)
        return [-200 - word.length, 0, adjacentEnd];
      if (direct > -1)
        return [-700 - word.length, direct, direct + this.pattern.length];
      if (adjacentTo == len)
        return [-200 + -700 - word.length, adjacentStart, adjacentEnd];
      if (byWordTo == len)
        return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
      return chars.length == 2 ? null : this.result((any2[0] ? -700 : 0) + -200 + -1100, any2, word);
    }
    result(score2, positions, word) {
      let result = [score2 - word.length], i = 1;
      for (let pos of positions) {
        let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
        if (i > 1 && result[i - 1] == pos)
          result[i - 1] = to;
        else {
          result[i++] = pos;
          result[i++] = to;
        }
      }
      return result;
    }
  };
  var completionConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        activateOnTyping: true,
        selectOnOpen: true,
        override: null,
        closeOnBlur: true,
        maxRenderedOptions: 100,
        defaultKeymap: true,
        optionClass: () => "",
        aboveCursor: false,
        icons: true,
        addToOptions: [],
        compareCompletions: (a2, b) => a2.label.localeCompare(b.label),
        interactionDelay: 75
      }, {
        defaultKeymap: (a2, b) => a2 && b,
        closeOnBlur: (a2, b) => a2 && b,
        icons: (a2, b) => a2 && b,
        optionClass: (a2, b) => (c2) => joinClass(a2(c2), b(c2)),
        addToOptions: (a2, b) => a2.concat(b)
      });
    }
  });
  function joinClass(a2, b) {
    return a2 ? b ? a2 + " " + b : a2 : b;
  }
  function optionContent(config2) {
    let content2 = config2.addToOptions.slice();
    if (config2.icons)
      content2.push({
        render(completion) {
          let icon = document.createElement("div");
          icon.classList.add("cm-completionIcon");
          if (completion.type)
            icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
          icon.setAttribute("aria-hidden", "true");
          return icon;
        },
        position: 20
      });
    content2.push({
      render(completion, _s, match) {
        let labelElt = document.createElement("span");
        labelElt.className = "cm-completionLabel";
        let { label } = completion, off = 0;
        for (let j = 1; j < match.length; ) {
          let from3 = match[j++], to = match[j++];
          if (from3 > off)
            labelElt.appendChild(document.createTextNode(label.slice(off, from3)));
          let span = labelElt.appendChild(document.createElement("span"));
          span.appendChild(document.createTextNode(label.slice(from3, to)));
          span.className = "cm-completionMatchedText";
          off = to;
        }
        if (off < label.length)
          labelElt.appendChild(document.createTextNode(label.slice(off)));
        return labelElt;
      },
      position: 50
    }, {
      render(completion) {
        if (!completion.detail)
          return null;
        let detailElt = document.createElement("span");
        detailElt.className = "cm-completionDetail";
        detailElt.textContent = completion.detail;
        return detailElt;
      },
      position: 80
    });
    return content2.sort((a2, b) => a2.position - b.position).map((a2) => a2.render);
  }
  function rangeAroundSelected(total, selected, max2) {
    if (total <= max2)
      return { from: 0, to: total };
    if (selected < 0)
      selected = 0;
    if (selected <= total >> 1) {
      let off2 = Math.floor(selected / max2);
      return { from: off2 * max2, to: (off2 + 1) * max2 };
    }
    let off = Math.floor((total - selected) / max2);
    return { from: total - (off + 1) * max2, to: total - off * max2 };
  }
  var CompletionTooltip = class {
    constructor(view2, stateField) {
      this.view = view2;
      this.stateField = stateField;
      this.info = null;
      this.placeInfo = {
        read: () => this.measureInfo(),
        write: (pos) => this.positionInfo(pos),
        key: this
      };
      this.space = null;
      let cState = view2.state.field(stateField);
      let { options, selected } = cState.open;
      let config2 = view2.state.facet(completionConfig);
      this.optionContent = optionContent(config2);
      this.optionClass = config2.optionClass;
      this.range = rangeAroundSelected(options.length, selected, config2.maxRenderedOptions);
      this.dom = document.createElement("div");
      this.dom.className = "cm-tooltip-autocomplete";
      this.dom.addEventListener("mousedown", (e) => {
        for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {
          if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options.length) {
            applyCompletion(view2, options[+match[1]]);
            e.preventDefault();
            return;
          }
        }
      });
      this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));
      this.list.addEventListener("scroll", () => {
        if (this.info)
          this.view.requestMeasure(this.placeInfo);
      });
    }
    mount() {
      this.updateSel();
    }
    update(update) {
      var _a2, _b, _c;
      let cState = update.state.field(this.stateField);
      let prevState = update.startState.field(this.stateField);
      if (cState != prevState) {
        this.updateSel();
        if (((_a2 = cState.open) === null || _a2 === void 0 ? void 0 : _a2.disabled) != ((_b = prevState.open) === null || _b === void 0 ? void 0 : _b.disabled))
          this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!((_c = cState.open) === null || _c === void 0 ? void 0 : _c.disabled));
      }
    }
    positioned(space4) {
      this.space = space4;
      if (this.info)
        this.view.requestMeasure(this.placeInfo);
    }
    updateSel() {
      let cState = this.view.state.field(this.stateField), open = cState.open;
      if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
        this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
        this.list.remove();
        this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));
        this.list.addEventListener("scroll", () => {
          if (this.info)
            this.view.requestMeasure(this.placeInfo);
        });
      }
      if (this.updateSelectedOption(open.selected)) {
        if (this.info) {
          this.info.remove();
          this.info = null;
        }
        let { completion } = open.options[open.selected];
        let { info } = completion;
        if (!info)
          return;
        let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
        if (!infoResult)
          return;
        if ("then" in infoResult) {
          infoResult.then((node) => {
            if (node && this.view.state.field(this.stateField, false) == cState)
              this.addInfoPane(node);
          }).catch((e) => logException(this.view.state, e, "completion info"));
        } else {
          this.addInfoPane(infoResult);
        }
      }
    }
    addInfoPane(content2) {
      let dom = this.info = document.createElement("div");
      dom.className = "cm-tooltip cm-completionInfo";
      dom.appendChild(content2);
      this.dom.appendChild(dom);
      this.view.requestMeasure(this.placeInfo);
    }
    updateSelectedOption(selected) {
      let set3 = null;
      for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
        if (i == selected) {
          if (!opt.hasAttribute("aria-selected")) {
            opt.setAttribute("aria-selected", "true");
            set3 = opt;
          }
        } else {
          if (opt.hasAttribute("aria-selected"))
            opt.removeAttribute("aria-selected");
        }
      }
      if (set3)
        scrollIntoView2(this.list, set3);
      return set3;
    }
    measureInfo() {
      let sel = this.dom.querySelector("[aria-selected]");
      if (!sel || !this.info)
        return null;
      let listRect = this.dom.getBoundingClientRect();
      let infoRect = this.info.getBoundingClientRect();
      let selRect = sel.getBoundingClientRect();
      let space4 = this.space;
      if (!space4) {
        let win = this.dom.ownerDocument.defaultView || window;
        space4 = { left: 0, top: 0, right: win.innerWidth, bottom: win.innerHeight };
      }
      if (selRect.top > Math.min(space4.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space4.top, listRect.top) + 10)
        return null;
      let rtl = this.view.textDirection == Direction.RTL, left = rtl, narrow = false, maxWidth;
      let top2 = "", bottom = "";
      let spaceLeft = listRect.left - space4.left, spaceRight = space4.right - listRect.right;
      if (left && spaceLeft < Math.min(infoRect.width, spaceRight))
        left = false;
      else if (!left && spaceRight < Math.min(infoRect.width, spaceLeft))
        left = true;
      if (infoRect.width <= (left ? spaceLeft : spaceRight)) {
        top2 = Math.max(space4.top, Math.min(selRect.top, space4.bottom - infoRect.height)) - listRect.top + "px";
        maxWidth = Math.min(400, left ? spaceLeft : spaceRight) + "px";
      } else {
        narrow = true;
        maxWidth = Math.min(400, (rtl ? listRect.right : space4.right - listRect.left) - 30) + "px";
        let spaceBelow = space4.bottom - listRect.bottom;
        if (spaceBelow >= infoRect.height || spaceBelow > listRect.top)
          top2 = selRect.bottom - listRect.top + "px";
        else
          bottom = listRect.bottom - selRect.top + "px";
      }
      return {
        top: top2,
        bottom,
        maxWidth,
        class: narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right"
      };
    }
    positionInfo(pos) {
      if (this.info) {
        if (pos) {
          this.info.style.top = pos.top;
          this.info.style.bottom = pos.bottom;
          this.info.style.maxWidth = pos.maxWidth;
          this.info.className = "cm-tooltip cm-completionInfo cm-completionInfo-" + pos.class;
        } else {
          this.info.style.top = "-1e6px";
        }
      }
    }
    createListBox(options, id3, range) {
      const ul = document.createElement("ul");
      ul.id = id3;
      ul.setAttribute("role", "listbox");
      ul.setAttribute("aria-expanded", "true");
      ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
      for (let i = range.from; i < range.to; i++) {
        let { completion, match } = options[i];
        const li = ul.appendChild(document.createElement("li"));
        li.id = id3 + "-" + i;
        li.setAttribute("role", "option");
        let cls = this.optionClass(completion);
        if (cls)
          li.className = cls;
        for (let source of this.optionContent) {
          let node = source(completion, this.view.state, match);
          if (node)
            li.appendChild(node);
        }
      }
      if (range.from)
        ul.classList.add("cm-completionListIncompleteTop");
      if (range.to < options.length)
        ul.classList.add("cm-completionListIncompleteBottom");
      return ul;
    }
  };
  function completionTooltip(stateField) {
    return (view2) => new CompletionTooltip(view2, stateField);
  }
  function scrollIntoView2(container, element2) {
    let parent = container.getBoundingClientRect();
    let self2 = element2.getBoundingClientRect();
    if (self2.top < parent.top)
      container.scrollTop -= parent.top - self2.top;
    else if (self2.bottom > parent.bottom)
      container.scrollTop += self2.bottom - parent.bottom;
  }
  function score(option) {
    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
  }
  function sortOptions(active, state) {
    let options = [], i = 0;
    for (let a2 of active)
      if (a2.hasResult()) {
        if (a2.result.filter === false) {
          let getMatch2 = a2.result.getMatch;
          for (let option of a2.result.options) {
            let match = [1e9 - i++];
            if (getMatch2)
              for (let n2 of getMatch2(option))
                match.push(n2);
            options.push(new Option(option, a2, match));
          }
        } else {
          let matcher = new FuzzyMatcher(state.sliceDoc(a2.from, a2.to)), match;
          for (let option of a2.result.options)
            if (match = matcher.match(option.label)) {
              if (option.boost != null)
                match[0] += option.boost;
              options.push(new Option(option, a2, match));
            }
        }
      }
    let result = [], prev = null;
    let compare3 = state.facet(completionConfig).compareCompletions;
    for (let opt of options.sort((a2, b) => b.match[0] - a2.match[0] || compare3(a2.completion, b.completion))) {
      if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail || prev.type != null && opt.completion.type != null && prev.type != opt.completion.type || prev.apply != opt.completion.apply)
        result.push(opt);
      else if (score(opt.completion) > score(prev))
        result[result.length - 1] = opt;
      prev = opt.completion;
    }
    return result;
  }
  var CompletionDialog = class {
    constructor(options, attrs, tooltip, timestamp, selected, disabled) {
      this.options = options;
      this.attrs = attrs;
      this.tooltip = tooltip;
      this.timestamp = timestamp;
      this.selected = selected;
      this.disabled = disabled;
    }
    setSelected(selected, id3) {
      return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id3, selected), this.tooltip, this.timestamp, selected, this.disabled);
    }
    static build(active, state, id3, prev, conf) {
      let options = sortOptions(active, state);
      if (!options.length) {
        return prev && active.some((a2) => a2.state == 1) ? new CompletionDialog(prev.options, prev.attrs, prev.tooltip, prev.timestamp, prev.selected, true) : null;
      }
      let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
      if (prev && prev.selected != selected && prev.selected != -1) {
        let selectedValue = prev.options[prev.selected].completion;
        for (let i = 0; i < options.length; i++)
          if (options[i].completion == selectedValue) {
            selected = i;
            break;
          }
      }
      return new CompletionDialog(options, makeAttrs(id3, selected), {
        pos: active.reduce((a2, b) => b.hasResult() ? Math.min(a2, b.from) : a2, 1e8),
        create: completionTooltip(completionState),
        above: conf.aboveCursor
      }, prev ? prev.timestamp : Date.now(), selected, false);
    }
    map(changes) {
      return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
    }
  };
  var CompletionState = class {
    constructor(active, id3, open) {
      this.active = active;
      this.id = id3;
      this.open = open;
    }
    static start() {
      return new CompletionState(none3, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
    }
    update(tr) {
      let { state } = tr, conf = state.facet(completionConfig);
      let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
      let active = sources.map((source) => {
        let value = this.active.find((s) => s.source == source) || new ActiveSource(source, this.active.some((a2) => a2.state != 0) ? 1 : 0);
        return value.update(tr, conf);
      });
      if (active.length == this.active.length && active.every((a2, i) => a2 == this.active[i]))
        active = this.active;
      let open = this.open;
      if (tr.selection || active.some((a2) => a2.hasResult() && tr.changes.touchesRange(a2.from, a2.to)) || !sameResults(active, this.active))
        open = CompletionDialog.build(active, state, this.id, this.open, conf);
      else if (open && open.disabled && !active.some((a2) => a2.state == 1))
        open = null;
      else if (open && tr.docChanged)
        open = open.map(tr.changes);
      if (!open && active.every((a2) => a2.state != 1) && active.some((a2) => a2.hasResult()))
        active = active.map((a2) => a2.hasResult() ? new ActiveSource(a2.source, 0) : a2);
      for (let effect of tr.effects)
        if (effect.is(setSelectedEffect))
          open = open && open.setSelected(effect.value, this.id);
      return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
    }
    get tooltip() {
      return this.open ? this.open.tooltip : null;
    }
    get attrs() {
      return this.open ? this.open.attrs : baseAttrs;
    }
  };
  function sameResults(a2, b) {
    if (a2 == b)
      return true;
    for (let iA = 0, iB = 0; ; ) {
      while (iA < a2.length && !a2[iA].hasResult)
        iA++;
      while (iB < b.length && !b[iB].hasResult)
        iB++;
      let endA = iA == a2.length, endB = iB == b.length;
      if (endA || endB)
        return endA == endB;
      if (a2[iA++].result != b[iB++].result)
        return false;
    }
  }
  var baseAttrs = {
    "aria-autocomplete": "list"
  };
  function makeAttrs(id3, selected) {
    let result = {
      "aria-autocomplete": "list",
      "aria-haspopup": "listbox",
      "aria-controls": id3
    };
    if (selected > -1)
      result["aria-activedescendant"] = id3 + "-" + selected;
    return result;
  }
  var none3 = [];
  function getUserEvent(tr) {
    return tr.isUserEvent("input.type") ? "input" : tr.isUserEvent("delete.backward") ? "delete" : null;
  }
  var ActiveSource = class {
    constructor(source, state, explicitPos = -1) {
      this.source = source;
      this.state = state;
      this.explicitPos = explicitPos;
    }
    hasResult() {
      return false;
    }
    update(tr, conf) {
      let event = getUserEvent(tr), value = this;
      if (event)
        value = value.handleUserEvent(tr, event, conf);
      else if (tr.docChanged)
        value = value.handleChange(tr);
      else if (tr.selection && value.state != 0)
        value = new ActiveSource(value.source, 0);
      for (let effect of tr.effects) {
        if (effect.is(startCompletionEffect))
          value = new ActiveSource(value.source, 1, effect.value ? cur(tr.state) : -1);
        else if (effect.is(closeCompletionEffect))
          value = new ActiveSource(value.source, 0);
        else if (effect.is(setActiveEffect)) {
          for (let active of effect.value)
            if (active.source == value.source)
              value = active;
        }
      }
      return value;
    }
    handleUserEvent(tr, type, conf) {
      return type == "delete" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1);
    }
    handleChange(tr) {
      return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0) : this.map(tr.changes);
    }
    map(changes) {
      return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
    }
  };
  var ActiveResult = class extends ActiveSource {
    constructor(source, explicitPos, result, from3, to) {
      super(source, 2, explicitPos);
      this.result = result;
      this.from = from3;
      this.to = to;
    }
    hasResult() {
      return true;
    }
    handleUserEvent(tr, type, conf) {
      var _a2;
      let from3 = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
      let pos = cur(tr.state);
      if ((this.explicitPos < 0 ? pos <= from3 : pos < this.from) || pos > to || type == "delete" && cur(tr.startState) == this.from)
        return new ActiveSource(this.source, type == "input" && conf.activateOnTyping ? 1 : 0);
      let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos), updated;
      if (checkValid(this.result.validFor, tr.state, from3, to))
        return new ActiveResult(this.source, explicitPos, this.result, from3, to);
      if (this.result.update && (updated = this.result.update(this.result, from3, to, new CompletionContext(tr.state, pos, explicitPos >= 0))))
        return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a2 = updated.to) !== null && _a2 !== void 0 ? _a2 : cur(tr.state));
      return new ActiveSource(this.source, 1, explicitPos);
    }
    handleChange(tr) {
      return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0) : this.map(tr.changes);
    }
    map(mapping) {
      return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
    }
  };
  function checkValid(validFor, state, from3, to) {
    if (!validFor)
      return false;
    let text3 = state.sliceDoc(from3, to);
    return typeof validFor == "function" ? validFor(text3, from3, to, state) : ensureAnchor(validFor, true).test(text3);
  }
  var startCompletionEffect = /* @__PURE__ */ StateEffect.define();
  var closeCompletionEffect = /* @__PURE__ */ StateEffect.define();
  var setActiveEffect = /* @__PURE__ */ StateEffect.define({
    map(sources, mapping) {
      return sources.map((s) => s.map(mapping));
    }
  });
  var setSelectedEffect = /* @__PURE__ */ StateEffect.define();
  var completionState = /* @__PURE__ */ StateField.define({
    create() {
      return CompletionState.start();
    },
    update(value, tr) {
      return value.update(tr);
    },
    provide: (f) => [
      showTooltip.from(f, (val) => val.tooltip),
      EditorView.contentAttributes.from(f, (state) => state.attrs)
    ]
  });
  function moveCompletionSelection(forward, by = "option") {
    return (view2) => {
      let cState = view2.state.field(completionState, false);
      if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view2.state.facet(completionConfig).interactionDelay)
        return false;
      let step = 1, tooltip;
      if (by == "page" && (tooltip = getTooltip(view2, cState.open.tooltip)))
        step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
      let { length: length3 } = cState.open.options;
      let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length3 - 1;
      if (selected < 0)
        selected = by == "page" ? 0 : length3 - 1;
      else if (selected >= length3)
        selected = by == "page" ? length3 - 1 : 0;
      view2.dispatch({ effects: setSelectedEffect.of(selected) });
      return true;
    };
  }
  var acceptCompletion = (view2) => {
    let cState = view2.state.field(completionState, false);
    if (view2.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || Date.now() - cState.open.timestamp < view2.state.facet(completionConfig).interactionDelay)
      return false;
    if (!cState.open.disabled)
      applyCompletion(view2, cState.open.options[cState.open.selected]);
    return true;
  };
  var startCompletion = (view2) => {
    let cState = view2.state.field(completionState, false);
    if (!cState)
      return false;
    view2.dispatch({ effects: startCompletionEffect.of(true) });
    return true;
  };
  var closeCompletion = (view2) => {
    let cState = view2.state.field(completionState, false);
    if (!cState || !cState.active.some((a2) => a2.state != 0))
      return false;
    view2.dispatch({ effects: closeCompletionEffect.of(null) });
    return true;
  };
  var RunningQuery = class {
    constructor(active, context) {
      this.active = active;
      this.context = context;
      this.time = Date.now();
      this.updates = [];
      this.done = void 0;
    }
  };
  var DebounceTime = 50;
  var MaxUpdateCount = 50;
  var MinAbortTime = 1e3;
  var completionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view2) {
      this.view = view2;
      this.debounceUpdate = -1;
      this.running = [];
      this.debounceAccept = -1;
      this.composing = 0;
      for (let active of view2.state.field(completionState).active)
        if (active.state == 1)
          this.startQuery(active);
    }
    update(update) {
      let cState = update.state.field(completionState);
      if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
        return;
      let doesReset = update.transactions.some((tr) => {
        return (tr.selection || tr.docChanged) && !getUserEvent(tr);
      });
      for (let i = 0; i < this.running.length; i++) {
        let query = this.running[i];
        if (doesReset || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
          for (let handler of query.context.abortListeners) {
            try {
              handler();
            } catch (e) {
              logException(this.view.state, e);
            }
          }
          query.context.abortListeners = null;
          this.running.splice(i--, 1);
        } else {
          query.updates.push(...update.transactions);
        }
      }
      if (this.debounceUpdate > -1)
        clearTimeout(this.debounceUpdate);
      this.debounceUpdate = cState.active.some((a2) => a2.state == 1 && !this.running.some((q) => q.active.source == a2.source)) ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;
      if (this.composing != 0)
        for (let tr of update.transactions) {
          if (getUserEvent(tr) == "input")
            this.composing = 2;
          else if (this.composing == 2 && tr.selection)
            this.composing = 3;
        }
    }
    startUpdate() {
      this.debounceUpdate = -1;
      let { state } = this.view, cState = state.field(completionState);
      for (let active of cState.active) {
        if (active.state == 1 && !this.running.some((r) => r.active.source == active.source))
          this.startQuery(active);
      }
    }
    startQuery(active) {
      let { state } = this.view, pos = cur(state);
      let context = new CompletionContext(state, pos, active.explicitPos == pos);
      let pending = new RunningQuery(active, context);
      this.running.push(pending);
      Promise.resolve(active.source(context)).then((result) => {
        if (!pending.context.aborted) {
          pending.done = result || null;
          this.scheduleAccept();
        }
      }, (err) => {
        this.view.dispatch({ effects: closeCompletionEffect.of(null) });
        logException(this.view.state, err);
      });
    }
    scheduleAccept() {
      if (this.running.every((q) => q.done !== void 0))
        this.accept();
      else if (this.debounceAccept < 0)
        this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);
    }
    accept() {
      var _a2;
      if (this.debounceAccept > -1)
        clearTimeout(this.debounceAccept);
      this.debounceAccept = -1;
      let updated = [];
      let conf = this.view.state.facet(completionConfig);
      for (let i = 0; i < this.running.length; i++) {
        let query = this.running[i];
        if (query.done === void 0)
          continue;
        this.running.splice(i--, 1);
        if (query.done) {
          let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a2 = query.done.to) !== null && _a2 !== void 0 ? _a2 : cur(query.updates.length ? query.updates[0].startState : this.view.state));
          for (let tr of query.updates)
            active = active.update(tr, conf);
          if (active.hasResult()) {
            updated.push(active);
            continue;
          }
        }
        let current = this.view.state.field(completionState).active.find((a2) => a2.source == query.active.source);
        if (current && current.state == 1) {
          if (query.done == null) {
            let active = new ActiveSource(query.active.source, 0);
            for (let tr of query.updates)
              active = active.update(tr, conf);
            if (active.state != 1)
              updated.push(active);
          } else {
            this.startQuery(current);
          }
        }
      }
      if (updated.length)
        this.view.dispatch({ effects: setActiveEffect.of(updated) });
    }
  }, {
    eventHandlers: {
      blur() {
        let state = this.view.state.field(completionState, false);
        if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur)
          this.view.dispatch({ effects: closeCompletionEffect.of(null) });
      },
      compositionstart() {
        this.composing = 1;
      },
      compositionend() {
        if (this.composing == 3) {
          setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
        }
        this.composing = 0;
      }
    }
  });
  var baseTheme4 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
      "& > ul": {
        fontFamily: "monospace",
        whiteSpace: "nowrap",
        overflow: "hidden auto",
        maxWidth_fallback: "700px",
        maxWidth: "min(700px, 95vw)",
        minWidth: "250px",
        maxHeight: "10em",
        height: "100%",
        listStyle: "none",
        margin: 0,
        padding: 0,
        "& > li": {
          overflowX: "hidden",
          textOverflow: "ellipsis",
          cursor: "pointer",
          padding: "1px 3px",
          lineHeight: 1.2
        }
      }
    },
    "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#17c",
      color: "white"
    },
    "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
      background: "#777"
    },
    "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#347",
      color: "white"
    },
    "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
      background: "#444"
    },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
      content: '"\xB7\xB7\xB7"',
      opacity: 0.5,
      display: "block",
      textAlign: "center"
    },
    ".cm-tooltip.cm-completionInfo": {
      position: "absolute",
      padding: "3px 9px",
      width: "max-content",
      maxWidth: `${400}px`,
      boxSizing: "border-box"
    },
    ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
    ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
    ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
    ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
    "&light .cm-snippetField": { backgroundColor: "#00000022" },
    "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
    ".cm-snippetFieldPosition": {
      verticalAlign: "text-top",
      width: 0,
      height: "1.15em",
      display: "inline-block",
      margin: "0 -0.7px -.7em",
      borderLeft: "1.4px dotted #888"
    },
    ".cm-completionMatchedText": {
      textDecoration: "underline"
    },
    ".cm-completionDetail": {
      marginLeft: "0.5em",
      fontStyle: "italic"
    },
    ".cm-completionIcon": {
      fontSize: "90%",
      width: ".8em",
      display: "inline-block",
      textAlign: "center",
      paddingRight: ".6em",
      opacity: "0.6",
      boxSizing: "content-box"
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": {
      "&:after": { content: "'\u0192'" }
    },
    ".cm-completionIcon-class": {
      "&:after": { content: "'\u25CB'" }
    },
    ".cm-completionIcon-interface": {
      "&:after": { content: "'\u25CC'" }
    },
    ".cm-completionIcon-variable": {
      "&:after": { content: "'\u{1D465}'" }
    },
    ".cm-completionIcon-constant": {
      "&:after": { content: "'\u{1D436}'" }
    },
    ".cm-completionIcon-type": {
      "&:after": { content: "'\u{1D461}'" }
    },
    ".cm-completionIcon-enum": {
      "&:after": { content: "'\u222A'" }
    },
    ".cm-completionIcon-property": {
      "&:after": { content: "'\u25A1'" }
    },
    ".cm-completionIcon-keyword": {
      "&:after": { content: "'\u{1F511}\uFE0E'" }
    },
    ".cm-completionIcon-namespace": {
      "&:after": { content: "'\u25A2'" }
    },
    ".cm-completionIcon-text": {
      "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
    }
  });
  var FieldPos = class {
    constructor(field, line, from3, to) {
      this.field = field;
      this.line = line;
      this.from = from3;
      this.to = to;
    }
  };
  var FieldRange = class {
    constructor(field, from3, to) {
      this.field = field;
      this.from = from3;
      this.to = to;
    }
    map(changes) {
      let from3 = changes.mapPos(this.from, -1, MapMode.TrackDel);
      let to = changes.mapPos(this.to, 1, MapMode.TrackDel);
      return from3 == null || to == null ? null : new FieldRange(this.field, from3, to);
    }
  };
  var Snippet = class {
    constructor(lines, fieldPositions) {
      this.lines = lines;
      this.fieldPositions = fieldPositions;
    }
    instantiate(state, pos) {
      let text3 = [], lineStart = [pos];
      let lineObj = state.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.text)[0];
      for (let line of this.lines) {
        if (text3.length) {
          let indent = baseIndent, tabs = /^\t*/.exec(line)[0].length;
          for (let i = 0; i < tabs; i++)
            indent += state.facet(indentUnit);
          lineStart.push(pos + indent.length - tabs);
          line = indent + line.slice(tabs);
        }
        text3.push(line);
        pos += line.length + 1;
      }
      let ranges = this.fieldPositions.map((pos2) => new FieldRange(pos2.field, lineStart[pos2.line] + pos2.from, lineStart[pos2.line] + pos2.to));
      return { text: text3, ranges };
    }
    static parse(template2) {
      let fields = [];
      let lines = [], positions = [], m2;
      for (let line of template2.split(/\r\n?|\n/)) {
        while (m2 = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(line)) {
          let seq = m2[1] ? +m2[1] : null, name2 = m2[2] || m2[3] || "", found = -1;
          for (let i = 0; i < fields.length; i++) {
            if (seq != null ? fields[i].seq == seq : name2 ? fields[i].name == name2 : false)
              found = i;
          }
          if (found < 0) {
            let i = 0;
            while (i < fields.length && (seq == null || fields[i].seq != null && fields[i].seq < seq))
              i++;
            fields.splice(i, 0, { seq, name: name2 });
            found = i;
            for (let pos of positions)
              if (pos.field >= found)
                pos.field++;
          }
          positions.push(new FieldPos(found, lines.length, m2.index, m2.index + name2.length));
          line = line.slice(0, m2.index) + name2 + line.slice(m2.index + m2[0].length);
        }
        for (let esc; esc = /\\([{}])/.exec(line); ) {
          line = line.slice(0, esc.index) + esc[1] + line.slice(esc.index + esc[0].length);
          for (let pos of positions)
            if (pos.line == lines.length && pos.from > esc.index) {
              pos.from--;
              pos.to--;
            }
        }
        lines.push(line);
      }
      return new Snippet(lines, positions);
    }
  };
  var fieldMarker = /* @__PURE__ */ Decoration.widget({ widget: /* @__PURE__ */ new class extends WidgetType {
    toDOM() {
      let span = document.createElement("span");
      span.className = "cm-snippetFieldPosition";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  }() });
  var fieldRange = /* @__PURE__ */ Decoration.mark({ class: "cm-snippetField" });
  var ActiveSnippet = class {
    constructor(ranges, active) {
      this.ranges = ranges;
      this.active = active;
      this.deco = Decoration.set(ranges.map((r) => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));
    }
    map(changes) {
      let ranges = [];
      for (let r of this.ranges) {
        let mapped = r.map(changes);
        if (!mapped)
          return null;
        ranges.push(mapped);
      }
      return new ActiveSnippet(ranges, this.active);
    }
    selectionInsideField(sel) {
      return sel.ranges.every((range) => this.ranges.some((r) => r.field == this.active && r.from <= range.from && r.to >= range.to));
    }
  };
  var setActive = /* @__PURE__ */ StateEffect.define({
    map(value, changes) {
      return value && value.map(changes);
    }
  });
  var moveToField = /* @__PURE__ */ StateEffect.define();
  var snippetState = /* @__PURE__ */ StateField.define({
    create() {
      return null;
    },
    update(value, tr) {
      for (let effect of tr.effects) {
        if (effect.is(setActive))
          return effect.value;
        if (effect.is(moveToField) && value)
          return new ActiveSnippet(value.ranges, effect.value);
      }
      if (value && tr.docChanged)
        value = value.map(tr.changes);
      if (value && tr.selection && !value.selectionInsideField(tr.selection))
        value = null;
      return value;
    },
    provide: (f) => EditorView.decorations.from(f, (val) => val ? val.deco : Decoration.none)
  });
  function fieldSelection(ranges, field) {
    return EditorSelection.create(ranges.filter((r) => r.field == field).map((r) => EditorSelection.range(r.from, r.to)));
  }
  function snippet(template2) {
    let snippet2 = Snippet.parse(template2);
    return (editor2, _completion, from3, to) => {
      let { text: text3, ranges } = snippet2.instantiate(editor2.state, from3);
      let spec = {
        changes: { from: from3, to, insert: Text.of(text3) },
        scrollIntoView: true
      };
      if (ranges.length)
        spec.selection = fieldSelection(ranges, 0);
      if (ranges.length > 1) {
        let active = new ActiveSnippet(ranges, 0);
        let effects = spec.effects = [setActive.of(active)];
        if (editor2.state.field(snippetState, false) === void 0)
          effects.push(StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme4]));
      }
      editor2.dispatch(editor2.state.update(spec));
    };
  }
  function moveField(dir) {
    return ({ state, dispatch: dispatch2 }) => {
      let active = state.field(snippetState, false);
      if (!active || dir < 0 && active.active == 0)
        return false;
      let next = active.active + dir, last2 = dir > 0 && !active.ranges.some((r) => r.field == next + dir);
      dispatch2(state.update({
        selection: fieldSelection(active.ranges, next),
        effects: setActive.of(last2 ? null : new ActiveSnippet(active.ranges, next))
      }));
      return true;
    };
  }
  var clearSnippet = ({ state, dispatch: dispatch2 }) => {
    let active = state.field(snippetState, false);
    if (!active)
      return false;
    dispatch2(state.update({ effects: setActive.of(null) }));
    return true;
  };
  var nextSnippetField = /* @__PURE__ */ moveField(1);
  var prevSnippetField = /* @__PURE__ */ moveField(-1);
  var defaultSnippetKeymap = [
    { key: "Tab", run: nextSnippetField, shift: prevSnippetField },
    { key: "Escape", run: clearSnippet }
  ];
  var snippetKeymap = /* @__PURE__ */ Facet.define({
    combine(maps) {
      return maps.length ? maps[0] : defaultSnippetKeymap;
    }
  });
  var addSnippetKeymap = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.compute([snippetKeymap], (state) => state.facet(snippetKeymap)));
  function snippetCompletion(template2, completion) {
    return Object.assign(Object.assign({}, completion), { apply: snippet(template2) });
  }
  var snippetPointerHandler = /* @__PURE__ */ EditorView.domEventHandlers({
    mousedown(event, view2) {
      let active = view2.state.field(snippetState, false), pos;
      if (!active || (pos = view2.posAtCoords({ x: event.clientX, y: event.clientY })) == null)
        return false;
      let match = active.ranges.find((r) => r.from <= pos && r.to >= pos);
      if (!match || match.field == active.active)
        return false;
      view2.dispatch({
        selection: fieldSelection(active.ranges, match.field),
        effects: setActive.of(active.ranges.some((r) => r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null)
      });
      return true;
    }
  });
  var defaults2 = {
    brackets: ["(", "[", "{", "'", '"'],
    before: ")]}:;>",
    stringPrefixes: []
  };
  var closeBracketEffect = /* @__PURE__ */ StateEffect.define({
    map(value, mapping) {
      let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
      return mapped == null ? void 0 : mapped;
    }
  });
  var skipBracketEffect = /* @__PURE__ */ StateEffect.define({
    map(value, mapping) {
      return mapping.mapPos(value);
    }
  });
  var closedBracket = /* @__PURE__ */ new class extends RangeValue {
  }();
  closedBracket.startSide = 1;
  closedBracket.endSide = -1;
  var bracketState = /* @__PURE__ */ StateField.define({
    create() {
      return RangeSet.empty;
    },
    update(value, tr) {
      if (tr.selection) {
        let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;
        let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;
        if (lineStart != tr.changes.mapPos(prevLineStart, -1))
          value = RangeSet.empty;
      }
      value = value.map(tr.changes);
      for (let effect of tr.effects) {
        if (effect.is(closeBracketEffect))
          value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
        else if (effect.is(skipBracketEffect))
          value = value.update({ filter: (from3) => from3 != effect.value });
      }
      return value;
    }
  });
  function closeBrackets() {
    return [inputHandler2, bracketState];
  }
  var definedClosing = "()[]{}<>";
  function closing(ch) {
    for (let i = 0; i < definedClosing.length; i += 2)
      if (definedClosing.charCodeAt(i) == ch)
        return definedClosing.charAt(i + 1);
    return fromCodePoint(ch < 128 ? ch : ch + 1);
  }
  function config(state, pos) {
    return state.languageDataAt("closeBrackets", pos)[0] || defaults2;
  }
  var android = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
  var inputHandler2 = /* @__PURE__ */ EditorView.inputHandler.of((view2, from3, to, insert2) => {
    if ((android ? view2.composing : view2.compositionStarted) || view2.state.readOnly)
      return false;
    let sel = view2.state.selection.main;
    if (insert2.length > 2 || insert2.length == 2 && codePointSize(codePointAt(insert2, 0)) == 1 || from3 != sel.from || to != sel.to)
      return false;
    let tr = insertBracket(view2.state, insert2);
    if (!tr)
      return false;
    view2.dispatch(tr);
    return true;
  });
  var deleteBracketPair = ({ state, dispatch: dispatch2 }) => {
    if (state.readOnly)
      return false;
    let conf = config(state, state.selection.main.head);
    let tokens = conf.brackets || defaults2.brackets;
    let dont = null, changes = state.changeByRange((range) => {
      if (range.empty) {
        let before = prevChar(state.doc, range.head);
        for (let token of tokens) {
          if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0)))
            return {
              changes: { from: range.head - token.length, to: range.head + token.length },
              range: EditorSelection.cursor(range.head - token.length)
            };
        }
      }
      return { range: dont = range };
    });
    if (!dont)
      dispatch2(state.update(changes, { scrollIntoView: true, userEvent: "delete.backward" }));
    return !dont;
  };
  var closeBracketsKeymap = [
    { key: "Backspace", run: deleteBracketPair }
  ];
  function insertBracket(state, bracket2) {
    let conf = config(state, state.selection.main.head);
    let tokens = conf.brackets || defaults2.brackets;
    for (let tok of tokens) {
      let closed = closing(codePointAt(tok, 0));
      if (bracket2 == tok)
        return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults2.before);
      if (bracket2 == closed && closedBracketAt(state, state.selection.main.from))
        return handleClose(state, tok, closed);
    }
    return null;
  }
  function closedBracketAt(state, pos) {
    let found = false;
    state.field(bracketState).between(0, state.doc.length, (from3) => {
      if (from3 == pos)
        found = true;
    });
    return found;
  }
  function nextChar(doc3, pos) {
    let next = doc3.sliceString(pos, pos + 2);
    return next.slice(0, codePointSize(codePointAt(next, 0)));
  }
  function prevChar(doc3, pos) {
    let prev = doc3.sliceString(pos - 2, pos);
    return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
  }
  function handleOpen(state, open, close, closeBefore) {
    let dont = null, changes = state.changeByRange((range) => {
      if (!range.empty)
        return {
          changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
          effects: closeBracketEffect.of(range.to + open.length),
          range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
        };
      let next = nextChar(state.doc, range.head);
      if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
        return {
          changes: { insert: open + close, from: range.head },
          effects: closeBracketEffect.of(range.head + open.length),
          range: EditorSelection.cursor(range.head + open.length)
        };
      return { range: dont = range };
    });
    return dont ? null : state.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function handleClose(state, _open, close) {
    let dont = null, moved = state.selection.ranges.map((range) => {
      if (range.empty && nextChar(state.doc, range.head) == close)
        return EditorSelection.cursor(range.head + close.length);
      return dont = range;
    });
    return dont ? null : state.update({
      selection: EditorSelection.create(moved, state.selection.mainIndex),
      scrollIntoView: true,
      effects: state.selection.ranges.map(({ from: from3 }) => skipBracketEffect.of(from3))
    });
  }
  function handleSame(state, token, allowTriple, config2) {
    let stringPrefixes = config2.stringPrefixes || defaults2.stringPrefixes;
    let dont = null, changes = state.changeByRange((range) => {
      if (!range.empty)
        return {
          changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],
          effects: closeBracketEffect.of(range.to + token.length),
          range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
        };
      let pos = range.head, next = nextChar(state.doc, pos), start;
      if (next == token) {
        if (nodeStart(state, pos)) {
          return {
            changes: { insert: token + token, from: pos },
            effects: closeBracketEffect.of(pos + token.length),
            range: EditorSelection.cursor(pos + token.length)
          };
        } else if (closedBracketAt(state, pos)) {
          let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
          return {
            range: EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),
            effects: skipBracketEffect.of(pos)
          };
        }
      } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {
        return {
          changes: { insert: token + token + token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
        if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))
          return {
            changes: { insert: token + token, from: pos },
            effects: closeBracketEffect.of(pos + token.length),
            range: EditorSelection.cursor(pos + token.length)
          };
      }
      return { range: dont = range };
    });
    return dont ? null : state.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function nodeStart(state, pos) {
    let tree = syntaxTree(state).resolveInner(pos + 1);
    return tree.parent && tree.from == pos;
  }
  function probablyInString(state, pos, quoteToken, prefixes) {
    let node = syntaxTree(state).resolveInner(pos, -1);
    let maxPrefix = prefixes.reduce((m2, p) => Math.max(m2, p.length), 0);
    for (let i = 0; i < 5; i++) {
      let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
      let quotePos = start.indexOf(quoteToken);
      if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
        let first = node.firstChild;
        while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
          if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
            return false;
          first = first.firstChild;
        }
        return true;
      }
      let parent = node.to == pos && node.parent;
      if (!parent)
        break;
      node = parent;
    }
    return false;
  }
  function canStartStringAt(state, pos, prefixes) {
    let charCat = state.charCategorizer(pos);
    if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)
      return pos;
    for (let prefix of prefixes) {
      let start = pos - prefix.length;
      if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word)
        return start;
    }
    return -1;
  }
  function autocompletion(config2 = {}) {
    return [
      completionState,
      completionConfig.of(config2),
      completionPlugin,
      completionKeymapExt,
      baseTheme4
    ];
  }
  var completionKeymap = [
    { key: "Ctrl-Space", run: startCompletion },
    { key: "Escape", run: closeCompletion },
    { key: "ArrowDown", run: /* @__PURE__ */ moveCompletionSelection(true) },
    { key: "ArrowUp", run: /* @__PURE__ */ moveCompletionSelection(false) },
    { key: "PageDown", run: /* @__PURE__ */ moveCompletionSelection(true, "page") },
    { key: "PageUp", run: /* @__PURE__ */ moveCompletionSelection(false, "page") },
    { key: "Enter", run: acceptCompletion }
  ];
  var completionKeymapExt = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.computeN([completionConfig], (state) => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));

  // node_modules/@codemirror/lint/dist/index.js
  var SelectedDiagnostic = class {
    constructor(from3, to, diagnostic) {
      this.from = from3;
      this.to = to;
      this.diagnostic = diagnostic;
    }
  };
  var LintState = class {
    constructor(diagnostics, panel, selected) {
      this.diagnostics = diagnostics;
      this.panel = panel;
      this.selected = selected;
    }
    static init(diagnostics, panel, state) {
      let markedDiagnostics = diagnostics;
      let diagnosticFilter = state.facet(lintConfig).markerFilter;
      if (diagnosticFilter)
        markedDiagnostics = diagnosticFilter(markedDiagnostics);
      let ranges = Decoration.set(markedDiagnostics.map((d) => {
        return d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from ? Decoration.widget({
          widget: new DiagnosticWidget(d),
          diagnostic: d
        }).range(d.from) : Decoration.mark({
          attributes: { class: "cm-lintRange cm-lintRange-" + d.severity },
          diagnostic: d
        }).range(d.from, d.to);
      }), true);
      return new LintState(ranges, panel, findDiagnostic(ranges));
    }
  };
  function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
    let found = null;
    diagnostics.between(after, 1e9, (from3, to, { spec }) => {
      if (diagnostic && spec.diagnostic != diagnostic)
        return;
      found = new SelectedDiagnostic(from3, to, spec.diagnostic);
      return false;
    });
    return found;
  }
  function hideTooltip(tr, tooltip) {
    return !!(tr.effects.some((e) => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(tooltip.pos));
  }
  function maybeEnableLint(state, effects) {
    return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of([
      lintState,
      EditorView.decorations.compute([lintState], (state2) => {
        let { selected, panel } = state2.field(lintState);
        return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
          activeMark.range(selected.from, selected.to)
        ]);
      }),
      hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
      baseTheme5
    ]));
  }
  function setDiagnostics(state, diagnostics) {
    return {
      effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
    };
  }
  var setDiagnosticsEffect = /* @__PURE__ */ StateEffect.define();
  var togglePanel2 = /* @__PURE__ */ StateEffect.define();
  var movePanelSelection = /* @__PURE__ */ StateEffect.define();
  var lintState = /* @__PURE__ */ StateField.define({
    create() {
      return new LintState(Decoration.none, null, null);
    },
    update(value, tr) {
      if (tr.docChanged) {
        let mapped = value.diagnostics.map(tr.changes), selected = null;
        if (value.selected) {
          let selPos = tr.changes.mapPos(value.selected.from, 1);
          selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
        }
        value = new LintState(mapped, value.panel, selected);
      }
      for (let effect of tr.effects) {
        if (effect.is(setDiagnosticsEffect)) {
          value = LintState.init(effect.value, value.panel, tr.state);
        } else if (effect.is(togglePanel2)) {
          value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
        } else if (effect.is(movePanelSelection)) {
          value = new LintState(value.diagnostics, value.panel, effect.value);
        }
      }
      return value;
    },
    provide: (f) => [
      showPanel.from(f, (val) => val.panel),
      EditorView.decorations.from(f, (s) => s.diagnostics)
    ]
  });
  var activeMark = /* @__PURE__ */ Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
  function lintTooltip(view2, pos, side) {
    let { diagnostics } = view2.state.field(lintState);
    let found = [], stackStart = 2e8, stackEnd = 0;
    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from3, to, { spec }) => {
      if (pos >= from3 && pos <= to && (from3 == to || (pos > from3 || side > 0) && (pos < to || side < 0))) {
        found.push(spec.diagnostic);
        stackStart = Math.min(from3, stackStart);
        stackEnd = Math.max(to, stackEnd);
      }
    });
    let diagnosticFilter = view2.state.facet(lintConfig).tooltipFilter;
    if (diagnosticFilter)
      found = diagnosticFilter(found);
    if (!found.length)
      return null;
    return {
      pos: stackStart,
      end: stackEnd,
      above: view2.state.doc.lineAt(stackStart).to < stackEnd,
      create() {
        return { dom: diagnosticsTooltip(view2, found) };
      }
    };
  }
  function diagnosticsTooltip(view2, diagnostics) {
    return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d) => renderDiagnostic(view2, d, false)));
  }
  var openLintPanel = (view2) => {
    let field = view2.state.field(lintState, false);
    if (!field || !field.panel)
      view2.dispatch({ effects: maybeEnableLint(view2.state, [togglePanel2.of(true)]) });
    let panel = getPanel(view2, LintPanel.open);
    if (panel)
      panel.dom.querySelector(".cm-panel-lint ul").focus();
    return true;
  };
  var closeLintPanel = (view2) => {
    let field = view2.state.field(lintState, false);
    if (!field || !field.panel)
      return false;
    view2.dispatch({ effects: togglePanel2.of(false) });
    return true;
  };
  var nextDiagnostic = (view2) => {
    let field = view2.state.field(lintState, false);
    if (!field)
      return false;
    let sel = view2.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
    if (!next.value) {
      next = field.diagnostics.iter(0);
      if (!next.value || next.from == sel.from && next.to == sel.to)
        return false;
    }
    view2.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
    return true;
  };
  var lintKeymap = [
    { key: "Mod-Shift-m", run: openLintPanel, preventDefault: true },
    { key: "F8", run: nextDiagnostic }
  ];
  var lintPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view2) {
      this.view = view2;
      this.timeout = -1;
      this.set = true;
      let { delay } = view2.state.facet(lintConfig);
      this.lintTime = Date.now() + delay;
      this.run = this.run.bind(this);
      this.timeout = setTimeout(this.run, delay);
    }
    run() {
      let now3 = Date.now();
      if (now3 < this.lintTime - 10) {
        setTimeout(this.run, this.lintTime - now3);
      } else {
        this.set = false;
        let { state } = this.view, { sources } = state.facet(lintConfig);
        Promise.all(sources.map((source) => Promise.resolve(source(this.view)))).then((annotations) => {
          let all2 = annotations.reduce((a2, b) => a2.concat(b));
          if (this.view.state.doc == state.doc)
            this.view.dispatch(setDiagnostics(this.view.state, all2));
        }, (error) => {
          logException(this.view.state, error);
        });
      }
    }
    update(update) {
      let config2 = update.state.facet(lintConfig);
      if (update.docChanged || config2 != update.startState.facet(lintConfig)) {
        this.lintTime = Date.now() + config2.delay;
        if (!this.set) {
          this.set = true;
          this.timeout = setTimeout(this.run, config2.delay);
        }
      }
    }
    force() {
      if (this.set) {
        this.lintTime = Date.now();
        this.run();
      }
    }
    destroy() {
      clearTimeout(this.timeout);
    }
  });
  var lintConfig = /* @__PURE__ */ Facet.define({
    combine(input) {
      return Object.assign({ sources: input.map((i) => i.source) }, combineConfig(input.map((i) => i.config), {
        delay: 750,
        markerFilter: null,
        tooltipFilter: null
      }));
    },
    enables: lintPlugin
  });
  function assignKeys(actions) {
    let assigned = [];
    if (actions)
      actions:
        for (let { name: name2 } of actions) {
          for (let i = 0; i < name2.length; i++) {
            let ch = name2[i];
            if (/[a-zA-Z]/.test(ch) && !assigned.some((c2) => c2.toLowerCase() == ch.toLowerCase())) {
              assigned.push(ch);
              continue actions;
            }
          }
          assigned.push("");
        }
    return assigned;
  }
  function renderDiagnostic(view2, diagnostic, inPanel) {
    var _a2;
    let keys3 = inPanel ? assignKeys(diagnostic.actions) : [];
    return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a2 = diagnostic.actions) === null || _a2 === void 0 ? void 0 : _a2.map((action, i) => {
      let click = (e) => {
        e.preventDefault();
        let found = findDiagnostic(view2.state.field(lintState).diagnostics, diagnostic);
        if (found)
          action.apply(view2, found.from, found.to);
      };
      let { name: name2 } = action, keyIndex = keys3[i] ? name2.indexOf(keys3[i]) : -1;
      let nameElt = keyIndex < 0 ? name2 : [
        name2.slice(0, keyIndex),
        crelt("u", name2.slice(keyIndex, keyIndex + 1)),
        name2.slice(keyIndex + 1)
      ];
      return crelt("button", {
        type: "button",
        class: "cm-diagnosticAction",
        onclick: click,
        onmousedown: click,
        "aria-label": ` Action: ${name2}${keyIndex < 0 ? "" : ` (access key "${keys3[i]})"`}.`
      }, nameElt);
    }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
  }
  var DiagnosticWidget = class extends WidgetType {
    constructor(diagnostic) {
      super();
      this.diagnostic = diagnostic;
    }
    eq(other) {
      return other.diagnostic == this.diagnostic;
    }
    toDOM() {
      return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
    }
  };
  var PanelItem = class {
    constructor(view2, diagnostic) {
      this.diagnostic = diagnostic;
      this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
      this.dom = renderDiagnostic(view2, diagnostic, true);
      this.dom.id = this.id;
      this.dom.setAttribute("role", "option");
    }
  };
  var LintPanel = class {
    constructor(view2) {
      this.view = view2;
      this.items = [];
      let onkeydown = (event) => {
        if (event.keyCode == 27) {
          closeLintPanel(this.view);
          this.view.focus();
        } else if (event.keyCode == 38 || event.keyCode == 33) {
          this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
        } else if (event.keyCode == 40 || event.keyCode == 34) {
          this.moveSelection((this.selectedIndex + 1) % this.items.length);
        } else if (event.keyCode == 36) {
          this.moveSelection(0);
        } else if (event.keyCode == 35) {
          this.moveSelection(this.items.length - 1);
        } else if (event.keyCode == 13) {
          this.view.focus();
        } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
          let { diagnostic } = this.items[this.selectedIndex], keys3 = assignKeys(diagnostic.actions);
          for (let i = 0; i < keys3.length; i++)
            if (keys3[i].toUpperCase().charCodeAt(0) == event.keyCode) {
              let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
              if (found)
                diagnostic.actions[i].apply(view2, found.from, found.to);
            }
        } else {
          return;
        }
        event.preventDefault();
      };
      let onclick = (event) => {
        for (let i = 0; i < this.items.length; i++) {
          if (this.items[i].dom.contains(event.target))
            this.moveSelection(i);
        }
      };
      this.list = crelt("ul", {
        tabIndex: 0,
        role: "listbox",
        "aria-label": this.view.state.phrase("Diagnostics"),
        onkeydown,
        onclick
      });
      this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
        type: "button",
        name: "close",
        "aria-label": this.view.state.phrase("close"),
        onclick: () => closeLintPanel(this.view)
      }, "\xD7"));
      this.update();
    }
    get selectedIndex() {
      let selected = this.view.state.field(lintState).selected;
      if (!selected)
        return -1;
      for (let i = 0; i < this.items.length; i++)
        if (this.items[i].diagnostic == selected.diagnostic)
          return i;
      return -1;
    }
    update() {
      let { diagnostics, selected } = this.view.state.field(lintState);
      let i = 0, needsSync = false, newSelectedItem = null;
      diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
        let found = -1, item;
        for (let j = i; j < this.items.length; j++)
          if (this.items[j].diagnostic == spec.diagnostic) {
            found = j;
            break;
          }
        if (found < 0) {
          item = new PanelItem(this.view, spec.diagnostic);
          this.items.splice(i, 0, item);
          needsSync = true;
        } else {
          item = this.items[found];
          if (found > i) {
            this.items.splice(i, found - i);
            needsSync = true;
          }
        }
        if (selected && item.diagnostic == selected.diagnostic) {
          if (!item.dom.hasAttribute("aria-selected")) {
            item.dom.setAttribute("aria-selected", "true");
            newSelectedItem = item;
          }
        } else if (item.dom.hasAttribute("aria-selected")) {
          item.dom.removeAttribute("aria-selected");
        }
        i++;
      });
      while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
        needsSync = true;
        this.items.pop();
      }
      if (this.items.length == 0) {
        this.items.push(new PanelItem(this.view, {
          from: -1,
          to: -1,
          severity: "info",
          message: this.view.state.phrase("No diagnostics")
        }));
        needsSync = true;
      }
      if (newSelectedItem) {
        this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
        this.view.requestMeasure({
          key: this,
          read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
          write: ({ sel, panel }) => {
            if (sel.top < panel.top)
              this.list.scrollTop -= panel.top - sel.top;
            else if (sel.bottom > panel.bottom)
              this.list.scrollTop += sel.bottom - panel.bottom;
          }
        });
      } else if (this.selectedIndex < 0) {
        this.list.removeAttribute("aria-activedescendant");
      }
      if (needsSync)
        this.sync();
    }
    sync() {
      let domPos = this.list.firstChild;
      function rm2() {
        let prev = domPos;
        domPos = prev.nextSibling;
        prev.remove();
      }
      for (let item of this.items) {
        if (item.dom.parentNode == this.list) {
          while (domPos != item.dom)
            rm2();
          domPos = item.dom.nextSibling;
        } else {
          this.list.insertBefore(item.dom, domPos);
        }
      }
      while (domPos)
        rm2();
    }
    moveSelection(selectedIndex) {
      if (this.selectedIndex < 0)
        return;
      let field = this.view.state.field(lintState);
      let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
      if (!selection)
        return;
      this.view.dispatch({
        selection: { anchor: selection.from, head: selection.to },
        scrollIntoView: true,
        effects: movePanelSelection.of(selection)
      });
    }
    static open(view2) {
      return new LintPanel(view2);
    }
  };
  function svg(content2, attrs = `viewBox="0 0 40 40"`) {
    return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content2)}</svg>')`;
  }
  function underline(color) {
    return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
  }
  var baseTheme5 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-diagnostic": {
      padding: "3px 6px 3px 8px",
      marginLeft: "-1px",
      display: "block",
      whiteSpace: "pre-wrap"
    },
    ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
    ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
    ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
    ".cm-diagnosticAction": {
      font: "inherit",
      border: "none",
      padding: "2px 4px",
      backgroundColor: "#444",
      color: "white",
      borderRadius: "3px",
      marginLeft: "8px"
    },
    ".cm-diagnosticSource": {
      fontSize: "70%",
      opacity: 0.7
    },
    ".cm-lintRange": {
      backgroundPosition: "left bottom",
      backgroundRepeat: "repeat-x",
      paddingBottom: "0.7px"
    },
    ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ underline("#d11") },
    ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ underline("orange") },
    ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ underline("#999") },
    ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
    ".cm-tooltip-lint": {
      padding: 0,
      margin: 0
    },
    ".cm-lintPoint": {
      position: "relative",
      "&:after": {
        content: '""',
        position: "absolute",
        bottom: 0,
        left: "-2px",
        borderLeft: "3px solid transparent",
        borderRight: "3px solid transparent",
        borderBottom: "4px solid #d11"
      }
    },
    ".cm-lintPoint-warning": {
      "&:after": { borderBottomColor: "orange" }
    },
    ".cm-lintPoint-info": {
      "&:after": { borderBottomColor: "#999" }
    },
    ".cm-panel.cm-panel-lint": {
      position: "relative",
      "& ul": {
        maxHeight: "100px",
        overflowY: "auto",
        "& [aria-selected]": {
          backgroundColor: "#ddd",
          "& u": { textDecoration: "underline" }
        },
        "&:focus [aria-selected]": {
          background_fallback: "#bdf",
          backgroundColor: "Highlight",
          color_fallback: "white",
          color: "HighlightText"
        },
        "& u": { textDecoration: "none" },
        padding: 0,
        margin: 0
      },
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "2px",
        background: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      }
    }
  });

  // node_modules/codemirror/dist/index.js
  var basicSetup = /* @__PURE__ */ (() => [
    lineNumbers(),
    highlightActiveLineGutter(),
    highlightSpecialChars(),
    history(),
    foldGutter(),
    drawSelection(),
    dropCursor(),
    EditorState.allowMultipleSelections.of(true),
    indentOnInput(),
    syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
    bracketMatching(),
    closeBrackets(),
    autocompletion(),
    rectangularSelection(),
    crosshairCursor(),
    highlightActiveLine(),
    highlightSelectionMatches(),
    keymap.of([
      ...closeBracketsKeymap,
      ...defaultKeymap,
      ...searchKeymap,
      ...historyKeymap,
      ...foldKeymap,
      ...completionKeymap,
      ...lintKeymap
    ])
  ])();

  // node_modules/@lezer/lr/dist/index.js
  var Stack = class {
    constructor(p, stack, state, reducePos, pos, score2, buffer, bufferBase, curContext, lookAhead = 0, parent) {
      this.p = p;
      this.stack = stack;
      this.state = state;
      this.reducePos = reducePos;
      this.pos = pos;
      this.score = score2;
      this.buffer = buffer;
      this.bufferBase = bufferBase;
      this.curContext = curContext;
      this.lookAhead = lookAhead;
      this.parent = parent;
    }
    toString() {
      return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    static start(p, state, pos = 0) {
      let cx = p.parser.context;
      return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    get context() {
      return this.curContext ? this.curContext.context : null;
    }
    pushState(state, start) {
      this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
      this.state = state;
    }
    reduce(action) {
      let depth = action >> 19, type = action & 65535;
      let { parser: parser5 } = this.p;
      let dPrec = parser5.dynamicPrecedence(type);
      if (dPrec)
        this.score += dPrec;
      if (depth == 0) {
        this.pushState(parser5.getGoto(this.state, type, true), this.reducePos);
        if (type < parser5.minRepeatTerm)
          this.storeNode(type, this.reducePos, this.reducePos, 4, true);
        this.reduceContext(type, this.reducePos);
        return;
      }
      let base2 = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
      let start = this.stack[base2 - 2];
      let bufferBase = this.stack[base2 - 1], count2 = this.bufferBase + this.buffer.length - bufferBase;
      if (type < parser5.minRepeatTerm || action & 131072) {
        let pos = parser5.stateFlag(this.state, 1) ? this.pos : this.reducePos;
        this.storeNode(type, start, pos, count2 + 4, true);
      }
      if (action & 262144) {
        this.state = this.stack[base2];
      } else {
        let baseStateID = this.stack[base2 - 3];
        this.state = parser5.getGoto(baseStateID, type, true);
      }
      while (this.stack.length > base2)
        this.stack.pop();
      this.reduceContext(type, start);
    }
    storeNode(term, start, end, size = 4, isReduce = false) {
      if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
        let cur2 = this, top2 = this.buffer.length;
        if (top2 == 0 && cur2.parent) {
          top2 = cur2.bufferBase - cur2.parent.bufferBase;
          cur2 = cur2.parent;
        }
        if (top2 > 0 && cur2.buffer[top2 - 4] == 0 && cur2.buffer[top2 - 1] > -1) {
          if (start == end)
            return;
          if (cur2.buffer[top2 - 2] >= start) {
            cur2.buffer[top2 - 2] = end;
            return;
          }
        }
      }
      if (!isReduce || this.pos == end) {
        this.buffer.push(term, start, end, size);
      } else {
        let index2 = this.buffer.length;
        if (index2 > 0 && this.buffer[index2 - 4] != 0)
          while (index2 > 0 && this.buffer[index2 - 2] > end) {
            this.buffer[index2] = this.buffer[index2 - 4];
            this.buffer[index2 + 1] = this.buffer[index2 - 3];
            this.buffer[index2 + 2] = this.buffer[index2 - 2];
            this.buffer[index2 + 3] = this.buffer[index2 - 1];
            index2 -= 4;
            if (size > 4)
              size -= 4;
          }
        this.buffer[index2] = term;
        this.buffer[index2 + 1] = start;
        this.buffer[index2 + 2] = end;
        this.buffer[index2 + 3] = size;
      }
    }
    shift(action, next, nextEnd) {
      let start = this.pos;
      if (action & 131072) {
        this.pushState(action & 65535, this.pos);
      } else if ((action & 262144) == 0) {
        let nextState = action, { parser: parser5 } = this.p;
        if (nextEnd > this.pos || next <= parser5.maxNode) {
          this.pos = nextEnd;
          if (!parser5.stateFlag(nextState, 1))
            this.reducePos = nextEnd;
        }
        this.pushState(nextState, start);
        this.shiftContext(next, start);
        if (next <= parser5.maxNode)
          this.buffer.push(next, start, nextEnd, 4);
      } else {
        this.pos = nextEnd;
        this.shiftContext(next, start);
        if (next <= this.p.parser.maxNode)
          this.buffer.push(next, start, nextEnd, 4);
      }
    }
    apply(action, next, nextEnd) {
      if (action & 65536)
        this.reduce(action);
      else
        this.shift(action, next, nextEnd);
    }
    useNode(value, next) {
      let index2 = this.p.reused.length - 1;
      if (index2 < 0 || this.p.reused[index2] != value) {
        this.p.reused.push(value);
        index2++;
      }
      let start = this.pos;
      this.reducePos = this.pos = start + value.length;
      this.pushState(next, start);
      this.buffer.push(index2, start, this.reducePos, -1);
      if (this.curContext)
        this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
    }
    split() {
      let parent = this;
      let off = parent.buffer.length;
      while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
        off -= 4;
      let buffer = parent.buffer.slice(off), base2 = parent.bufferBase + off;
      while (parent && base2 == parent.bufferBase)
        parent = parent.parent;
      return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent);
    }
    recoverByDelete(next, nextEnd) {
      let isNode2 = next <= this.p.parser.maxNode;
      if (isNode2)
        this.storeNode(next, this.pos, nextEnd, 4);
      this.storeNode(0, this.pos, nextEnd, isNode2 ? 8 : 4);
      this.pos = this.reducePos = nextEnd;
      this.score -= 190;
    }
    canShift(term) {
      for (let sim = new SimulatedStack(this); ; ) {
        let action = this.p.parser.stateSlot(sim.state, 4) || this.p.parser.hasAction(sim.state, term);
        if (action == 0)
          return false;
        if ((action & 65536) == 0)
          return true;
        sim.reduce(action);
      }
    }
    recoverByInsert(next) {
      if (this.stack.length >= 300)
        return [];
      let nextStates = this.p.parser.nextStates(this.state);
      if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
        let best = [];
        for (let i = 0, s; i < nextStates.length; i += 2) {
          if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
            best.push(nextStates[i], s);
        }
        if (this.stack.length < 120)
          for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
            let s = nextStates[i + 1];
            if (!best.some((v, i2) => i2 & 1 && v == s))
              best.push(nextStates[i], s);
          }
        nextStates = best;
      }
      let result = [];
      for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
        let s = nextStates[i + 1];
        if (s == this.state)
          continue;
        let stack = this.split();
        stack.pushState(s, this.pos);
        stack.storeNode(0, stack.pos, stack.pos, 4, true);
        stack.shiftContext(nextStates[i], this.pos);
        stack.score -= 200;
        result.push(stack);
      }
      return result;
    }
    forceReduce() {
      let reduce = this.p.parser.stateSlot(this.state, 5);
      if ((reduce & 65536) == 0)
        return false;
      let { parser: parser5 } = this.p;
      if (!parser5.validAction(this.state, reduce)) {
        let depth = reduce >> 19, term = reduce & 65535;
        let target = this.stack.length - depth * 3;
        if (target < 0 || parser5.getGoto(this.stack[target], term, false) < 0)
          return false;
        this.storeNode(0, this.reducePos, this.reducePos, 4, true);
        this.score -= 100;
      }
      this.reducePos = this.pos;
      this.reduce(reduce);
      return true;
    }
    forceAll() {
      while (!this.p.parser.stateFlag(this.state, 2)) {
        if (!this.forceReduce()) {
          this.storeNode(0, this.pos, this.pos, 4, true);
          break;
        }
      }
      return this;
    }
    get deadEnd() {
      if (this.stack.length != 3)
        return false;
      let { parser: parser5 } = this.p;
      return parser5.data[parser5.stateSlot(this.state, 1)] == 65535 && !parser5.stateSlot(this.state, 4);
    }
    restart() {
      this.state = this.stack[0];
      this.stack.length = 0;
    }
    sameState(other) {
      if (this.state != other.state || this.stack.length != other.stack.length)
        return false;
      for (let i = 0; i < this.stack.length; i += 3)
        if (this.stack[i] != other.stack[i])
          return false;
      return true;
    }
    get parser() {
      return this.p.parser;
    }
    dialectEnabled(dialectID) {
      return this.p.parser.dialect.flags[dialectID];
    }
    shiftContext(term, start) {
      if (this.curContext)
        this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    reduceContext(term, start) {
      if (this.curContext)
        this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    emitContext() {
      let last2 = this.buffer.length - 1;
      if (last2 < 0 || this.buffer[last2] != -3)
        this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
    }
    emitLookAhead() {
      let last2 = this.buffer.length - 1;
      if (last2 < 0 || this.buffer[last2] != -4)
        this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
    }
    updateContext(context) {
      if (context != this.curContext.context) {
        let newCx = new StackContext(this.curContext.tracker, context);
        if (newCx.hash != this.curContext.hash)
          this.emitContext();
        this.curContext = newCx;
      }
    }
    setLookAhead(lookAhead) {
      if (lookAhead > this.lookAhead) {
        this.emitLookAhead();
        this.lookAhead = lookAhead;
      }
    }
    close() {
      if (this.curContext && this.curContext.tracker.strict)
        this.emitContext();
      if (this.lookAhead > 0)
        this.emitLookAhead();
    }
  };
  var StackContext = class {
    constructor(tracker, context) {
      this.tracker = tracker;
      this.context = context;
      this.hash = tracker.strict ? tracker.hash(context) : 0;
    }
  };
  var Recover;
  (function(Recover2) {
    Recover2[Recover2["Insert"] = 200] = "Insert";
    Recover2[Recover2["Delete"] = 190] = "Delete";
    Recover2[Recover2["Reduce"] = 100] = "Reduce";
    Recover2[Recover2["MaxNext"] = 4] = "MaxNext";
    Recover2[Recover2["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
    Recover2[Recover2["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
  })(Recover || (Recover = {}));
  var SimulatedStack = class {
    constructor(start) {
      this.start = start;
      this.state = start.state;
      this.stack = start.stack;
      this.base = this.stack.length;
    }
    reduce(action) {
      let term = action & 65535, depth = action >> 19;
      if (depth == 0) {
        if (this.stack == this.start.stack)
          this.stack = this.stack.slice();
        this.stack.push(this.state, 0, 0);
        this.base += 3;
      } else {
        this.base -= (depth - 1) * 3;
      }
      let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
      this.state = goto;
    }
  };
  var StackBufferCursor = class {
    constructor(stack, pos, index2) {
      this.stack = stack;
      this.pos = pos;
      this.index = index2;
      this.buffer = stack.buffer;
      if (this.index == 0)
        this.maybeNext();
    }
    static create(stack, pos = stack.bufferBase + stack.buffer.length) {
      return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
      let next = this.stack.parent;
      if (next != null) {
        this.index = this.stack.bufferBase - next.bufferBase;
        this.stack = next;
        this.buffer = next.buffer;
      }
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    next() {
      this.index -= 4;
      this.pos -= 4;
      if (this.index == 0)
        this.maybeNext();
    }
    fork() {
      return new StackBufferCursor(this.stack, this.pos, this.index);
    }
  };
  var CachedToken = class {
    constructor() {
      this.start = -1;
      this.value = -1;
      this.end = -1;
      this.extended = -1;
      this.lookAhead = 0;
      this.mask = 0;
      this.context = 0;
    }
  };
  var nullToken = new CachedToken();
  var InputStream = class {
    constructor(input, ranges) {
      this.input = input;
      this.ranges = ranges;
      this.chunk = "";
      this.chunkOff = 0;
      this.chunk2 = "";
      this.chunk2Pos = 0;
      this.next = -1;
      this.token = nullToken;
      this.rangeIndex = 0;
      this.pos = this.chunkPos = ranges[0].from;
      this.range = ranges[0];
      this.end = ranges[ranges.length - 1].to;
      this.readNext();
    }
    resolveOffset(offset, assoc) {
      let range = this.range, index2 = this.rangeIndex;
      let pos = this.pos + offset;
      while (pos < range.from) {
        if (!index2)
          return null;
        let next = this.ranges[--index2];
        pos -= range.from - next.to;
        range = next;
      }
      while (assoc < 0 ? pos > range.to : pos >= range.to) {
        if (index2 == this.ranges.length - 1)
          return null;
        let next = this.ranges[++index2];
        pos += next.from - range.to;
        range = next;
      }
      return pos;
    }
    clipPos(pos) {
      if (pos >= this.range.from && pos < this.range.to)
        return pos;
      for (let range of this.ranges)
        if (range.to > pos)
          return Math.max(pos, range.from);
      return this.end;
    }
    peek(offset) {
      let idx = this.chunkOff + offset, pos, result;
      if (idx >= 0 && idx < this.chunk.length) {
        pos = this.pos + offset;
        result = this.chunk.charCodeAt(idx);
      } else {
        let resolved = this.resolveOffset(offset, 1);
        if (resolved == null)
          return -1;
        pos = resolved;
        if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
          result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
        } else {
          let i = this.rangeIndex, range = this.range;
          while (range.to <= pos)
            range = this.ranges[++i];
          this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
          if (pos + this.chunk2.length > range.to)
            this.chunk2 = this.chunk2.slice(0, range.to - pos);
          result = this.chunk2.charCodeAt(0);
        }
      }
      if (pos >= this.token.lookAhead)
        this.token.lookAhead = pos + 1;
      return result;
    }
    acceptToken(token, endOffset = 0) {
      let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
      if (end == null || end < this.token.start)
        throw new RangeError("Token end out of bounds");
      this.token.value = token;
      this.token.end = end;
    }
    getChunk() {
      if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
        let { chunk, chunkPos } = this;
        this.chunk = this.chunk2;
        this.chunkPos = this.chunk2Pos;
        this.chunk2 = chunk;
        this.chunk2Pos = chunkPos;
        this.chunkOff = this.pos - this.chunkPos;
      } else {
        this.chunk2 = this.chunk;
        this.chunk2Pos = this.chunkPos;
        let nextChunk = this.input.chunk(this.pos);
        let end = this.pos + nextChunk.length;
        this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
        this.chunkPos = this.pos;
        this.chunkOff = 0;
      }
    }
    readNext() {
      if (this.chunkOff >= this.chunk.length) {
        this.getChunk();
        if (this.chunkOff == this.chunk.length)
          return this.next = -1;
      }
      return this.next = this.chunk.charCodeAt(this.chunkOff);
    }
    advance(n2 = 1) {
      this.chunkOff += n2;
      while (this.pos + n2 >= this.range.to) {
        if (this.rangeIndex == this.ranges.length - 1)
          return this.setDone();
        n2 -= this.range.to - this.pos;
        this.range = this.ranges[++this.rangeIndex];
        this.pos = this.range.from;
      }
      this.pos += n2;
      if (this.pos >= this.token.lookAhead)
        this.token.lookAhead = this.pos + 1;
      return this.readNext();
    }
    setDone() {
      this.pos = this.chunkPos = this.end;
      this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
      this.chunk = "";
      return this.next = -1;
    }
    reset(pos, token) {
      if (token) {
        this.token = token;
        token.start = pos;
        token.lookAhead = pos + 1;
        token.value = token.extended = -1;
      } else {
        this.token = nullToken;
      }
      if (this.pos != pos) {
        this.pos = pos;
        if (pos == this.end) {
          this.setDone();
          return this;
        }
        while (pos < this.range.from)
          this.range = this.ranges[--this.rangeIndex];
        while (pos >= this.range.to)
          this.range = this.ranges[++this.rangeIndex];
        if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
          this.chunkOff = pos - this.chunkPos;
        } else {
          this.chunk = "";
          this.chunkOff = 0;
        }
        this.readNext();
      }
      return this;
    }
    read(from3, to) {
      if (from3 >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
        return this.chunk.slice(from3 - this.chunkPos, to - this.chunkPos);
      if (from3 >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
        return this.chunk2.slice(from3 - this.chunk2Pos, to - this.chunk2Pos);
      if (from3 >= this.range.from && to <= this.range.to)
        return this.input.read(from3, to);
      let result = "";
      for (let r of this.ranges) {
        if (r.from >= to)
          break;
        if (r.to > from3)
          result += this.input.read(Math.max(r.from, from3), Math.min(r.to, to));
      }
      return result;
    }
  };
  var TokenGroup = class {
    constructor(data2, id3) {
      this.data = data2;
      this.id = id3;
    }
    token(input, stack) {
      readToken(this.data, input, stack, this.id);
    }
  };
  TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
  var ExternalTokenizer = class {
    constructor(token, options = {}) {
      this.token = token;
      this.contextual = !!options.contextual;
      this.fallback = !!options.fallback;
      this.extend = !!options.extend;
    }
  };
  function readToken(data2, input, stack, group) {
    let state = 0, groupMask = 1 << group, { parser: parser5 } = stack.p, { dialect } = parser5;
    scan:
      for (; ; ) {
        if ((groupMask & data2[state]) == 0)
          break;
        let accEnd = data2[state + 1];
        for (let i = state + 3; i < accEnd; i += 2)
          if ((data2[i + 1] & groupMask) > 0) {
            let term = data2[i];
            if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || parser5.overrides(term, input.token.value))) {
              input.acceptToken(term);
              break;
            }
          }
        let next = input.next, low = 0, high = data2[state + 2];
        if (input.next < 0 && high > low && data2[accEnd + high * 3 - 3] == 65535 && data2[accEnd + high * 3 - 3] == 65535) {
          state = data2[accEnd + high * 3 - 1];
          continue scan;
        }
        for (; low < high; ) {
          let mid = low + high >> 1;
          let index2 = accEnd + mid + (mid << 1);
          let from3 = data2[index2], to = data2[index2 + 1] || 65536;
          if (next < from3)
            high = mid;
          else if (next >= to)
            low = mid + 1;
          else {
            state = data2[index2 + 2];
            input.advance();
            continue scan;
          }
        }
        break;
      }
  }
  function decodeArray(input, Type2 = Uint16Array) {
    if (typeof input != "string")
      return input;
    let array2 = null;
    for (let pos = 0, out = 0; pos < input.length; ) {
      let value = 0;
      for (; ; ) {
        let next = input.charCodeAt(pos++), stop = false;
        if (next == 126) {
          value = 65535;
          break;
        }
        if (next >= 92)
          next--;
        if (next >= 34)
          next--;
        let digit = next - 32;
        if (digit >= 46) {
          digit -= 46;
          stop = true;
        }
        value += digit;
        if (stop)
          break;
        value *= 46;
      }
      if (array2)
        array2[out++] = value;
      else
        array2 = new Type2(value);
    }
    return array2;
  }
  var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
  var stackIDs = null;
  var Safety;
  (function(Safety2) {
    Safety2[Safety2["Margin"] = 25] = "Margin";
  })(Safety || (Safety = {}));
  function cutAt(tree, pos, side) {
    let cursor = tree.cursor(IterMode.IncludeAnonymous);
    cursor.moveTo(pos);
    for (; ; ) {
      if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
        for (; ; ) {
          if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
            return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25));
          if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
            break;
          if (!cursor.parent())
            return side < 0 ? 0 : tree.length;
        }
    }
  }
  var FragmentCursor2 = class {
    constructor(fragments, nodeSet) {
      this.fragments = fragments;
      this.nodeSet = nodeSet;
      this.i = 0;
      this.fragment = null;
      this.safeFrom = -1;
      this.safeTo = -1;
      this.trees = [];
      this.start = [];
      this.index = [];
      this.nextFragment();
    }
    nextFragment() {
      let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
      if (fr) {
        this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
        this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
        while (this.trees.length) {
          this.trees.pop();
          this.start.pop();
          this.index.pop();
        }
        this.trees.push(fr.tree);
        this.start.push(-fr.offset);
        this.index.push(0);
        this.nextStart = this.safeFrom;
      } else {
        this.nextStart = 1e9;
      }
    }
    nodeAt(pos) {
      if (pos < this.nextStart)
        return null;
      while (this.fragment && this.safeTo <= pos)
        this.nextFragment();
      if (!this.fragment)
        return null;
      for (; ; ) {
        let last2 = this.trees.length - 1;
        if (last2 < 0) {
          this.nextFragment();
          return null;
        }
        let top2 = this.trees[last2], index2 = this.index[last2];
        if (index2 == top2.children.length) {
          this.trees.pop();
          this.start.pop();
          this.index.pop();
          continue;
        }
        let next = top2.children[index2];
        let start = this.start[last2] + top2.positions[index2];
        if (start > pos) {
          this.nextStart = start;
          return null;
        }
        if (next instanceof Tree) {
          if (start == pos) {
            if (start < this.safeFrom)
              return null;
            let end = start + next.length;
            if (end <= this.safeTo) {
              let lookAhead = next.prop(NodeProp.lookAhead);
              if (!lookAhead || end + lookAhead < this.fragment.to)
                return next;
            }
          }
          this.index[last2]++;
          if (start + next.length >= Math.max(this.safeFrom, pos)) {
            this.trees.push(next);
            this.start.push(start);
            this.index.push(0);
          }
        } else {
          this.index[last2]++;
          this.nextStart = start + next.length;
        }
      }
    }
  };
  var TokenCache = class {
    constructor(parser5, stream) {
      this.stream = stream;
      this.tokens = [];
      this.mainToken = null;
      this.actions = [];
      this.tokens = parser5.tokenizers.map((_) => new CachedToken());
    }
    getActions(stack) {
      let actionIndex = 0;
      let main = null;
      let { parser: parser5 } = stack.p, { tokenizers } = parser5;
      let mask = parser5.stateSlot(stack.state, 3);
      let context = stack.curContext ? stack.curContext.hash : 0;
      let lookAhead = 0;
      for (let i = 0; i < tokenizers.length; i++) {
        if ((1 << i & mask) == 0)
          continue;
        let tokenizer = tokenizers[i], token = this.tokens[i];
        if (main && !tokenizer.fallback)
          continue;
        if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
          this.updateCachedToken(token, tokenizer, stack);
          token.mask = mask;
          token.context = context;
        }
        if (token.lookAhead > token.end + 25)
          lookAhead = Math.max(token.lookAhead, lookAhead);
        if (token.value != 0) {
          let startIndex = actionIndex;
          if (token.extended > -1)
            actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
          actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
          if (!tokenizer.extend) {
            main = token;
            if (actionIndex > startIndex)
              break;
          }
        }
      }
      while (this.actions.length > actionIndex)
        this.actions.pop();
      if (lookAhead)
        stack.setLookAhead(lookAhead);
      if (!main && stack.pos == this.stream.end) {
        main = new CachedToken();
        main.value = stack.p.parser.eofTerm;
        main.start = main.end = stack.pos;
        actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
      }
      this.mainToken = main;
      return this.actions;
    }
    getMainToken(stack) {
      if (this.mainToken)
        return this.mainToken;
      let main = new CachedToken(), { pos, p } = stack;
      main.start = pos;
      main.end = Math.min(pos + 1, p.stream.end);
      main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
      return main;
    }
    updateCachedToken(token, tokenizer, stack) {
      let start = this.stream.clipPos(stack.pos);
      tokenizer.token(this.stream.reset(start, token), stack);
      if (token.value > -1) {
        let { parser: parser5 } = stack.p;
        for (let i = 0; i < parser5.specialized.length; i++)
          if (parser5.specialized[i] == token.value) {
            let result = parser5.specializers[i](this.stream.read(token.start, token.end), stack);
            if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
              if ((result & 1) == 0)
                token.value = result >> 1;
              else
                token.extended = result >> 1;
              break;
            }
          }
      } else {
        token.value = 0;
        token.end = this.stream.clipPos(start + 1);
      }
    }
    putAction(action, token, end, index2) {
      for (let i = 0; i < index2; i += 3)
        if (this.actions[i] == action)
          return index2;
      this.actions[index2++] = action;
      this.actions[index2++] = token;
      this.actions[index2++] = end;
      return index2;
    }
    addActions(stack, token, end, index2) {
      let { state } = stack, { parser: parser5 } = stack.p, { data: data2 } = parser5;
      for (let set3 = 0; set3 < 2; set3++) {
        for (let i = parser5.stateSlot(state, set3 ? 2 : 1); ; i += 3) {
          if (data2[i] == 65535) {
            if (data2[i + 1] == 1) {
              i = pair(data2, i + 2);
            } else {
              if (index2 == 0 && data2[i + 1] == 2)
                index2 = this.putAction(pair(data2, i + 2), token, end, index2);
              break;
            }
          }
          if (data2[i] == token)
            index2 = this.putAction(pair(data2, i + 1), token, end, index2);
        }
      }
      return index2;
    }
  };
  var Rec;
  (function(Rec2) {
    Rec2[Rec2["Distance"] = 5] = "Distance";
    Rec2[Rec2["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
    Rec2[Rec2["MinBufferLengthPrune"] = 500] = "MinBufferLengthPrune";
    Rec2[Rec2["ForceReduceLimit"] = 10] = "ForceReduceLimit";
    Rec2[Rec2["CutDepth"] = 15e3] = "CutDepth";
    Rec2[Rec2["CutTo"] = 9e3] = "CutTo";
  })(Rec || (Rec = {}));
  var Parse = class {
    constructor(parser5, input, fragments, ranges) {
      this.parser = parser5;
      this.input = input;
      this.ranges = ranges;
      this.recovering = 0;
      this.nextStackID = 9812;
      this.minStackPos = 0;
      this.reused = [];
      this.stoppedAt = null;
      this.stream = new InputStream(input, ranges);
      this.tokens = new TokenCache(parser5, this.stream);
      this.topTerm = parser5.top[1];
      let { from: from3 } = ranges[0];
      this.stacks = [Stack.start(this, parser5.top[0], from3)];
      this.fragments = fragments.length && this.stream.end - from3 > parser5.bufferLength * 4 ? new FragmentCursor2(fragments, parser5.nodeSet) : null;
    }
    get parsedPos() {
      return this.minStackPos;
    }
    advance() {
      let stacks = this.stacks, pos = this.minStackPos;
      let newStacks = this.stacks = [];
      let stopped, stoppedTokens;
      for (let i = 0; i < stacks.length; i++) {
        let stack = stacks[i];
        for (; ; ) {
          this.tokens.mainToken = null;
          if (stack.pos > pos) {
            newStacks.push(stack);
          } else if (this.advanceStack(stack, newStacks, stacks)) {
            continue;
          } else {
            if (!stopped) {
              stopped = [];
              stoppedTokens = [];
            }
            stopped.push(stack);
            let tok = this.tokens.getMainToken(stack);
            stoppedTokens.push(tok.value, tok.end);
          }
          break;
        }
      }
      if (!newStacks.length) {
        let finished = stopped && findFinished(stopped);
        if (finished)
          return this.stackToTree(finished);
        if (this.parser.strict) {
          if (verbose && stopped)
            console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
          throw new SyntaxError("No parse at " + pos);
        }
        if (!this.recovering)
          this.recovering = 5;
      }
      if (this.recovering && stopped) {
        let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
        if (finished)
          return this.stackToTree(finished.forceAll());
      }
      if (this.recovering) {
        let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
        if (newStacks.length > maxRemaining) {
          newStacks.sort((a2, b) => b.score - a2.score);
          while (newStacks.length > maxRemaining)
            newStacks.pop();
        }
        if (newStacks.some((s) => s.reducePos > pos))
          this.recovering--;
      } else if (newStacks.length > 1) {
        outer:
          for (let i = 0; i < newStacks.length - 1; i++) {
            let stack = newStacks[i];
            for (let j = i + 1; j < newStacks.length; j++) {
              let other = newStacks[j];
              if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
                if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                  newStacks.splice(j--, 1);
                } else {
                  newStacks.splice(i--, 1);
                  continue outer;
                }
              }
            }
          }
      }
      this.minStackPos = newStacks[0].pos;
      for (let i = 1; i < newStacks.length; i++)
        if (newStacks[i].pos < this.minStackPos)
          this.minStackPos = newStacks[i].pos;
      return null;
    }
    stopAt(pos) {
      if (this.stoppedAt != null && this.stoppedAt < pos)
        throw new RangeError("Can't move stoppedAt forward");
      this.stoppedAt = pos;
    }
    advanceStack(stack, stacks, split) {
      let start = stack.pos, { parser: parser5 } = this;
      let base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (this.stoppedAt != null && start > this.stoppedAt)
        return stack.forceReduce() ? stack : null;
      if (this.fragments) {
        let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
        for (let cached = this.fragments.nodeAt(start); cached; ) {
          let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser5.getGoto(stack.state, cached.type.id) : -1;
          if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
            stack.useNode(cached, match);
            if (verbose)
              console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser5.getName(cached.type.id)})`);
            return true;
          }
          if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
            break;
          let inner = cached.children[0];
          if (inner instanceof Tree && cached.positions[0] == 0)
            cached = inner;
          else
            break;
        }
      }
      let defaultReduce = parser5.stateSlot(stack.state, 4);
      if (defaultReduce > 0) {
        stack.reduce(defaultReduce);
        if (verbose)
          console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser5.getName(defaultReduce & 65535)})`);
        return true;
      }
      if (stack.stack.length >= 15e3) {
        while (stack.stack.length > 9e3 && stack.forceReduce()) {
        }
      }
      let actions = this.tokens.getActions(stack);
      for (let i = 0; i < actions.length; ) {
        let action = actions[i++], term = actions[i++], end = actions[i++];
        let last2 = i == actions.length || !split;
        let localStack = last2 ? stack : stack.split();
        localStack.apply(action, term, end);
        if (verbose)
          console.log(base2 + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser5.getName(action & 65535)}`} for ${parser5.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
        if (last2)
          return true;
        else if (localStack.pos > start)
          stacks.push(localStack);
        else
          split.push(localStack);
      }
      return false;
    }
    advanceFully(stack, newStacks) {
      let pos = stack.pos;
      for (; ; ) {
        if (!this.advanceStack(stack, null, null))
          return false;
        if (stack.pos > pos) {
          pushStackDedup(stack, newStacks);
          return true;
        }
      }
    }
    runRecovery(stacks, tokens, newStacks) {
      let finished = null, restarted = false;
      for (let i = 0; i < stacks.length; i++) {
        let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
        let base2 = verbose ? this.stackID(stack) + " -> " : "";
        if (stack.deadEnd) {
          if (restarted)
            continue;
          restarted = true;
          stack.restart();
          if (verbose)
            console.log(base2 + this.stackID(stack) + " (restarted)");
          let done = this.advanceFully(stack, newStacks);
          if (done)
            continue;
        }
        let force = stack.split(), forceBase = base2;
        for (let j = 0; force.forceReduce() && j < 10; j++) {
          if (verbose)
            console.log(forceBase + this.stackID(force) + " (via force-reduce)");
          let done = this.advanceFully(force, newStacks);
          if (done)
            break;
          if (verbose)
            forceBase = this.stackID(force) + " -> ";
        }
        for (let insert2 of stack.recoverByInsert(token)) {
          if (verbose)
            console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
          this.advanceFully(insert2, newStacks);
        }
        if (this.stream.end > stack.pos) {
          if (tokenEnd == stack.pos) {
            tokenEnd++;
            token = 0;
          }
          stack.recoverByDelete(token, tokenEnd);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
          pushStackDedup(stack, newStacks);
        } else if (!finished || finished.score < stack.score) {
          finished = stack;
        }
      }
      return finished;
    }
    stackToTree(stack) {
      stack.close();
      return Tree.build({
        buffer: StackBufferCursor.create(stack),
        nodeSet: this.parser.nodeSet,
        topID: this.topTerm,
        maxBufferLength: this.parser.bufferLength,
        reused: this.reused,
        start: this.ranges[0].from,
        length: stack.pos - this.ranges[0].from,
        minRepeatType: this.parser.minRepeatTerm
      });
    }
    stackID(stack) {
      let id3 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
      if (!id3)
        stackIDs.set(stack, id3 = String.fromCodePoint(this.nextStackID++));
      return id3 + stack;
    }
  };
  function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
      let other = newStacks[i];
      if (other.pos == stack.pos && other.sameState(stack)) {
        if (newStacks[i].score < stack.score)
          newStacks[i] = stack;
        return;
      }
    }
    newStacks.push(stack);
  }
  var Dialect = class {
    constructor(source, flags, disabled) {
      this.source = source;
      this.flags = flags;
      this.disabled = disabled;
    }
    allows(term) {
      return !this.disabled || this.disabled[term] == 0;
    }
  };
  var id2 = (x3) => x3;
  var ContextTracker = class {
    constructor(spec) {
      this.start = spec.start;
      this.shift = spec.shift || id2;
      this.reduce = spec.reduce || id2;
      this.reuse = spec.reuse || id2;
      this.hash = spec.hash || (() => 0);
      this.strict = spec.strict !== false;
    }
  };
  var LRParser = class extends Parser {
    constructor(spec) {
      super();
      this.wrappers = [];
      if (spec.version != 14)
        throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
      let nodeNames = spec.nodeNames.split(" ");
      this.minRepeatTerm = nodeNames.length;
      for (let i = 0; i < spec.repeatNodeCount; i++)
        nodeNames.push("");
      let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
      let nodeProps = [];
      for (let i = 0; i < nodeNames.length; i++)
        nodeProps.push([]);
      function setProp(nodeID, prop, value) {
        nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
      }
      if (spec.nodeProps)
        for (let propSpec of spec.nodeProps) {
          let prop = propSpec[0];
          if (typeof prop == "string")
            prop = NodeProp[prop];
          for (let i = 1; i < propSpec.length; ) {
            let next = propSpec[i++];
            if (next >= 0) {
              setProp(next, prop, propSpec[i++]);
            } else {
              let value = propSpec[i + -next];
              for (let j = -next; j > 0; j--)
                setProp(propSpec[i++], prop, value);
              i++;
            }
          }
        }
      this.nodeSet = new NodeSet(nodeNames.map((name2, i) => NodeType.define({
        name: i >= this.minRepeatTerm ? void 0 : name2,
        id: i,
        props: nodeProps[i],
        top: topTerms.indexOf(i) > -1,
        error: i == 0,
        skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
      })));
      if (spec.propSources)
        this.nodeSet = this.nodeSet.extend(...spec.propSources);
      this.strict = false;
      this.bufferLength = DefaultBufferLength;
      let tokenArray = decodeArray(spec.tokenData);
      this.context = spec.context;
      this.specializerSpecs = spec.specialized || [];
      this.specialized = new Uint16Array(this.specializerSpecs.length);
      for (let i = 0; i < this.specializerSpecs.length; i++)
        this.specialized[i] = this.specializerSpecs[i].term;
      this.specializers = this.specializerSpecs.map(getSpecializer);
      this.states = decodeArray(spec.states, Uint32Array);
      this.data = decodeArray(spec.stateData);
      this.goto = decodeArray(spec.goto);
      this.maxTerm = spec.maxTerm;
      this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
      this.topRules = spec.topRules;
      this.dialects = spec.dialects || {};
      this.dynamicPrecedences = spec.dynamicPrecedences || null;
      this.tokenPrecTable = spec.tokenPrec;
      this.termNames = spec.termNames || null;
      this.maxNode = this.nodeSet.types.length - 1;
      this.dialect = this.parseDialect();
      this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    createParse(input, fragments, ranges) {
      let parse2 = new Parse(this, input, fragments, ranges);
      for (let w of this.wrappers)
        parse2 = w(parse2, input, fragments, ranges);
      return parse2;
    }
    getGoto(state, term, loose = false) {
      let table = this.goto;
      if (term >= table[0])
        return -1;
      for (let pos = table[term + 1]; ; ) {
        let groupTag = table[pos++], last2 = groupTag & 1;
        let target = table[pos++];
        if (last2 && loose)
          return target;
        for (let end = pos + (groupTag >> 1); pos < end; pos++)
          if (table[pos] == state)
            return target;
        if (last2)
          return -1;
      }
    }
    hasAction(state, terminal) {
      let data2 = this.data;
      for (let set3 = 0; set3 < 2; set3++) {
        for (let i = this.stateSlot(state, set3 ? 2 : 1), next; ; i += 3) {
          if ((next = data2[i]) == 65535) {
            if (data2[i + 1] == 1)
              next = data2[i = pair(data2, i + 2)];
            else if (data2[i + 1] == 2)
              return pair(data2, i + 2);
            else
              break;
          }
          if (next == terminal || next == 0)
            return pair(data2, i + 1);
        }
      }
      return 0;
    }
    stateSlot(state, slot) {
      return this.states[state * 6 + slot];
    }
    stateFlag(state, flag) {
      return (this.stateSlot(state, 0) & flag) > 0;
    }
    validAction(state, action) {
      if (action == this.stateSlot(state, 4))
        return true;
      for (let i = this.stateSlot(state, 1); ; i += 3) {
        if (this.data[i] == 65535) {
          if (this.data[i + 1] == 1)
            i = pair(this.data, i + 2);
          else
            return false;
        }
        if (action == pair(this.data, i + 1))
          return true;
      }
    }
    nextStates(state) {
      let result = [];
      for (let i = this.stateSlot(state, 1); ; i += 3) {
        if (this.data[i] == 65535) {
          if (this.data[i + 1] == 1)
            i = pair(this.data, i + 2);
          else
            break;
        }
        if ((this.data[i + 2] & 65536 >> 16) == 0) {
          let value = this.data[i + 1];
          if (!result.some((v, i2) => i2 & 1 && v == value))
            result.push(this.data[i], value);
        }
      }
      return result;
    }
    overrides(token, prev) {
      let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
      return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
    }
    configure(config2) {
      let copy2 = Object.assign(Object.create(LRParser.prototype), this);
      if (config2.props)
        copy2.nodeSet = this.nodeSet.extend(...config2.props);
      if (config2.top) {
        let info = this.topRules[config2.top];
        if (!info)
          throw new RangeError(`Invalid top rule name ${config2.top}`);
        copy2.top = info;
      }
      if (config2.tokenizers)
        copy2.tokenizers = this.tokenizers.map((t2) => {
          let found = config2.tokenizers.find((r) => r.from == t2);
          return found ? found.to : t2;
        });
      if (config2.specializers) {
        copy2.specializers = this.specializers.slice();
        copy2.specializerSpecs = this.specializerSpecs.map((s, i) => {
          let found = config2.specializers.find((r) => r.from == s.external);
          if (!found)
            return s;
          let spec = Object.assign(Object.assign({}, s), { external: found.to });
          copy2.specializers[i] = getSpecializer(spec);
          return spec;
        });
      }
      if (config2.contextTracker)
        copy2.context = config2.contextTracker;
      if (config2.dialect)
        copy2.dialect = this.parseDialect(config2.dialect);
      if (config2.strict != null)
        copy2.strict = config2.strict;
      if (config2.wrap)
        copy2.wrappers = copy2.wrappers.concat(config2.wrap);
      if (config2.bufferLength != null)
        copy2.bufferLength = config2.bufferLength;
      return copy2;
    }
    hasWrappers() {
      return this.wrappers.length > 0;
    }
    getName(term) {
      return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    get eofTerm() {
      return this.maxNode + 1;
    }
    get topNode() {
      return this.nodeSet.types[this.top[1]];
    }
    dynamicPrecedence(term) {
      let prec2 = this.dynamicPrecedences;
      return prec2 == null ? 0 : prec2[term] || 0;
    }
    parseDialect(dialect) {
      let values2 = Object.keys(this.dialects), flags = values2.map(() => false);
      if (dialect)
        for (let part of dialect.split(" ")) {
          let id3 = values2.indexOf(part);
          if (id3 >= 0)
            flags[id3] = true;
        }
      let disabled = null;
      for (let i = 0; i < values2.length; i++)
        if (!flags[i]) {
          for (let j = this.dialects[values2[i]], id3; (id3 = this.data[j++]) != 65535; )
            (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id3] = 1;
        }
      return new Dialect(dialect, flags, disabled);
    }
    static deserialize(spec) {
      return new LRParser(spec);
    }
  };
  function pair(data2, off) {
    return data2[off] | data2[off + 1] << 16;
  }
  function findOffset(data2, start, term) {
    for (let i = start, next; (next = data2[i]) != 65535; i++)
      if (next == term)
        return i - start;
    return -1;
  }
  function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
      let stopped = stack.p.stoppedAt;
      if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2) && (!best || best.score < stack.score))
        best = stack;
    }
    return best;
  }
  function getSpecializer(spec) {
    if (spec.external) {
      let mask = spec.extend ? 1 : 0;
      return (value, stack) => spec.external(value, stack) << 1 | mask;
    }
    return spec.get;
  }

  // node_modules/@lezer/javascript/dist/index.es.js
  var TSExtends = 1;
  var noSemi = 289;
  var incdec = 2;
  var incdecPrefix = 3;
  var templateContent = 290;
  var InterpolationStart = 4;
  var templateEnd = 291;
  var insertSemi = 292;
  var spaces = 294;
  var newline = 295;
  var LineComment = 5;
  var BlockComment = 6;
  var Dialect_ts = 1;
  var space = [
    9,
    10,
    11,
    12,
    13,
    32,
    133,
    160,
    5760,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8232,
    8233,
    8239,
    8287,
    12288
  ];
  var braceR = 125;
  var braceL = 123;
  var semicolon = 59;
  var slash = 47;
  var star = 42;
  var plus = 43;
  var minus = 45;
  var dollar = 36;
  var backtick = 96;
  var backslash = 92;
  var trackNewline = new ContextTracker({
    start: false,
    shift(context, term) {
      return term == LineComment || term == BlockComment || term == spaces ? context : term == newline;
    },
    strict: false
  });
  var insertSemicolon = new ExternalTokenizer((input, stack) => {
    let { next } = input;
    if ((next == braceR || next == -1 || stack.context) && stack.canShift(insertSemi))
      input.acceptToken(insertSemi);
  }, { contextual: true, fallback: true });
  var noSemicolon = new ExternalTokenizer((input, stack) => {
    let { next } = input, after;
    if (space.indexOf(next) > -1)
      return;
    if (next == slash && ((after = input.peek(1)) == slash || after == star))
      return;
    if (next != braceR && next != semicolon && next != -1 && !stack.context && stack.canShift(noSemi))
      input.acceptToken(noSemi);
  }, { contextual: true });
  var incdecToken = new ExternalTokenizer((input, stack) => {
    let { next } = input;
    if (next == plus || next == minus) {
      input.advance();
      if (next == input.next) {
        input.advance();
        let mayPostfix = !stack.context && stack.canShift(incdec);
        input.acceptToken(mayPostfix ? incdec : incdecPrefix);
      }
    }
  }, { contextual: true });
  var template = new ExternalTokenizer((input) => {
    for (let afterDollar = false, i = 0; ; i++) {
      let { next } = input;
      if (next < 0) {
        if (i)
          input.acceptToken(templateContent);
        break;
      } else if (next == backtick) {
        if (i)
          input.acceptToken(templateContent);
        else
          input.acceptToken(templateEnd, 1);
        break;
      } else if (next == braceL && afterDollar) {
        if (i == 1)
          input.acceptToken(InterpolationStart, 1);
        else
          input.acceptToken(templateContent, -1);
        break;
      } else if (next == 10 && i) {
        input.advance();
        input.acceptToken(templateContent);
        break;
      } else if (next == backslash) {
        input.advance();
      }
      afterDollar = next == dollar;
      input.advance();
    }
  });
  var tsExtends = new ExternalTokenizer((input, stack) => {
    if (input.next != 101 || !stack.dialectEnabled(Dialect_ts))
      return;
    input.advance();
    for (let i = 0; i < 6; i++) {
      if (input.next != "xtends".charCodeAt(i))
        return;
      input.advance();
    }
    if (input.next >= 57 && input.next <= 65 || input.next >= 48 && input.next <= 90 || input.next == 95 || input.next >= 97 && input.next <= 122 || input.next > 160)
      return;
    input.acceptToken(TSExtends);
  });
  var jsHighlight = styleTags({
    "get set async static": tags.modifier,
    "for while do if else switch try catch finally return throw break continue default case": tags.controlKeyword,
    "in of await yield void typeof delete instanceof": tags.operatorKeyword,
    "let var const function class extends": tags.definitionKeyword,
    "import export from": tags.moduleKeyword,
    "with debugger as new": tags.keyword,
    TemplateString: tags.special(tags.string),
    super: tags.atom,
    BooleanLiteral: tags.bool,
    this: tags.self,
    null: tags.null,
    Star: tags.modifier,
    VariableName: tags.variableName,
    "CallExpression/VariableName TaggedTemplateExpression/VariableName": tags.function(tags.variableName),
    VariableDefinition: tags.definition(tags.variableName),
    Label: tags.labelName,
    PropertyName: tags.propertyName,
    PrivatePropertyName: tags.special(tags.propertyName),
    "CallExpression/MemberExpression/PropertyName": tags.function(tags.propertyName),
    "FunctionDeclaration/VariableDefinition": tags.function(tags.definition(tags.variableName)),
    "ClassDeclaration/VariableDefinition": tags.definition(tags.className),
    PropertyDefinition: tags.definition(tags.propertyName),
    PrivatePropertyDefinition: tags.definition(tags.special(tags.propertyName)),
    UpdateOp: tags.updateOperator,
    LineComment: tags.lineComment,
    BlockComment: tags.blockComment,
    Number: tags.number,
    String: tags.string,
    ArithOp: tags.arithmeticOperator,
    LogicOp: tags.logicOperator,
    BitOp: tags.bitwiseOperator,
    CompareOp: tags.compareOperator,
    RegExp: tags.regexp,
    Equals: tags.definitionOperator,
    Arrow: tags.function(tags.punctuation),
    ": Spread": tags.punctuation,
    "( )": tags.paren,
    "[ ]": tags.squareBracket,
    "{ }": tags.brace,
    "InterpolationStart InterpolationEnd": tags.special(tags.brace),
    ".": tags.derefOperator,
    ", ;": tags.separator,
    TypeName: tags.typeName,
    TypeDefinition: tags.definition(tags.typeName),
    "type enum interface implements namespace module declare": tags.definitionKeyword,
    "abstract global Privacy readonly override": tags.modifier,
    "is keyof unique infer": tags.operatorKeyword,
    JSXAttributeValue: tags.attributeValue,
    JSXText: tags.content,
    "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": tags.angleBracket,
    "JSXIdentifier JSXNameSpacedName": tags.tagName,
    "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": tags.attributeName,
    "JSXBuiltin/JSXIdentifier": tags.standard(tags.tagName)
  });
  var spec_identifier = { __proto__: null, export: 18, as: 23, from: 29, default: 32, async: 37, function: 38, this: 50, true: 58, false: 58, null: 68, void: 72, typeof: 76, super: 92, new: 126, await: 143, yield: 145, delete: 146, class: 156, extends: 158, public: 203, private: 203, protected: 203, readonly: 205, instanceof: 226, satisfies: 229, in: 230, const: 232, import: 264, keyof: 319, unique: 323, infer: 329, is: 365, abstract: 385, implements: 387, type: 389, let: 392, var: 394, interface: 401, enum: 405, namespace: 411, module: 413, declare: 417, global: 421, for: 442, of: 451, while: 454, with: 458, do: 462, if: 466, else: 468, switch: 472, case: 478, try: 484, catch: 488, finally: 492, return: 496, throw: 500, break: 504, continue: 508, debugger: 512 };
  var spec_word = { __proto__: null, async: 113, get: 115, set: 117, public: 165, private: 165, protected: 165, static: 167, abstract: 169, override: 171, readonly: 177, accessor: 179, new: 369 };
  var spec_LessThan = { __proto__: null, "<": 133 };
  var parser = LRParser.deserialize({
    version: 14,
    states: "$;rO`QdOOO$zQdOOO)TQ(C|O'#ChO)[OWO'#DYO+gQdO'#D_O+wQdO'#DjO$zQdO'#DtO-{QdO'#DzOOQO'#E`'#E`O.`Q`O'#E_O.eQ`O'#E_OOQ(C['#Ei'#EiO0gQ(C|O'#I{O3TQ(C|O'#I|O3tQ`O'#FOO3yQ!bO'#FgOOQ(C['#FW'#FWO4UO#tO'#FWO4dQ&jO'#FnO5wQ`O'#FmOOQ(C['#I|'#I|OOQ(CW'#I{'#I{OOQS'#Je'#JeO5|Q`O'#HwO6RQ(ChO'#HxOOQS'#Ip'#IpOOQS'#Hz'#HzQ`QdOOO$zQdO'#DlO6ZQ`O'#GcO6`Q&jO'#CmO6nQ`O'#E^O6yQ`O'#EjO7OQ&jO'#FVO7jQ`O'#GcO7oQ`O'#GgO7zQ`O'#GgO8YQ`O'#GjO8YQ`O'#GkO8YQ`O'#GmO6ZQ`O'#GpO8yQ`O'#GsO:XQ`O'#CdO:iQ`O'#HQO:qQ`O'#HWO:qQ`O'#HYO`QdO'#H[O:qQ`O'#H^O:qQ`O'#HaO:vQ`O'#HgO:{Q(CjO'#HmO$zQdO'#HoO;WQ(CjO'#HqO;cQ(CjO'#HsO6RQ(ChO'#HuO;nQ(C|O'#ChO<[Q,UO'#DdQOQ`OOO=PQaO'#D{O6`Q&jO'#E^O=_Q`O'#E^O=jQpO'#FVO$zQdO'#DZOOOW'#H|'#H|O=rOWO,59tOOQ(C[,59t,59tO=}QdO'#H}O>bQ`O'#I}O@dQtO'#I}O)gQdO'#I}O@kQ`O,59yOARQ`O'#E`OA`Q`O'#JYOAkQ`O'#JXOAkQ`O'#JXOAsQ`O,5:|OAxQ`O'#JWOOQ(C[,5:U,5:UOBPQdO,5:UODQQ(C|O,5:`ODqQ`O,5:fOE[Q(ChO'#JVO7oQ`O'#JUOEcQ`O'#JUOEkQ`O,5:{OEpQ`O'#JUOFOQdO,5:yOHOQ&jO'#EZOI`Q`O,5:yOJuQ&jO'#DnOJ|QdO'#DsOKWQ,UO,5;SOK`Q,UO,5;SO$zQdO,5;SOOQS'#Ev'#EvOOQS'#Ex'#ExO$zQdO,5;UO$zQdO,5;UO$zQdO,5;UO$zQdO,5;UO$zQdO,5;UO$zQdO,5;UO$zQdO,5;UO$zQdO,5;UO$zQdO,5;UO$zQdO,5;UO$zQdO,5;UOOQS'#E|'#E|OKnQdO,5;gOOQ(C[,5;l,5;lOOQ(C[,5;m,5;mOMnQ`O,5;mOOQ(C[,5;n,5;nO$zQdO'#IXOMvQ(ChO,5<ZOHOQ&jO,5;UONeQ&jO,5;UO$zQdO,5;jONlQ!bO'#F]O! iQ!bO'#J^O! TQ!bO'#J^O! pQ!bO'#J^OOQO'#J^'#J^O!!UQ!bO,5;uOOOO,5<R,5<RO!!gQdO'#FiOOOO'#IW'#IWO4UO#tO,5;rO!!nQ!bO'#FkOOQ(C[,5;r,5;rO!#_Q7]O'#CsOOQ(C]'#Cv'#CvO!#rQ`O'#CvO!#wOWO'#CzO!$eQ&kO,5<WO!$lQ`O,5<YO!&OQMhO'#FxO!&]Q`O'#FyO!&bQ`O'#FyO!&gQMhO'#F}O!'fQ,UO'#GRO!([Q7]O'#IxOOQ(C]'#Ix'#IxO!)_QaO'#IwO!)mQ`O'#IvO!)uQ`O'#CrOOQ(C]'#Ct'#CtOOQ(C]'#C}'#C}OOQ(C]'#DP'#DPO!)}Q`O'#DROIeQ&jO'#FpOIeQ&jO'#FrO!*SQ`O'#FtO!*XQ`O'#FuO!&bQ`O'#F{OIeQ&jO'#GQO!*^Q`O'#EaO!*uQ`O,5<XO`QdO,5>cOOQS'#Is'#IsOOQS,5>d,5>dOOQS-E;x-E;xO!,tQ(C|O,5:WOOQ(CX'#Cp'#CpO!-hQ&kO,5<}OOQO'#Cf'#CfO!-yQ(ChO'#ItO5wQ`O'#ItO:vQ`O,59XO!.[Q!bO,59XO!.dQ&jO,59XO6`Q&jO,59XO!.oQ`O,5:yO!.wQ`O'#HPO!/VQ`O'#JiO$zQdO,5;oO!/_Q,UO,5;qO!/dQ`O,5=jO!/iQ`O,5=jO!/nQ`O,5=jO6RQ(ChO,5=jO6ZQ`O,5<}O!/|Q`O'#EbO!0sQ,UO'#EcOOQ(CW'#JW'#JWO!0zQ(ChO'#JfO6RQ(ChO,5=RO8YQ`O,5=XOOQP'#Cs'#CsO!1VQ!bO,5=UO!1_Q!cO,5=VO!1jQ`O,5=XO!1oQpO,5=[O:vQ`O'#GuO6ZQ`O'#GwO!1wQ`O'#GwO6`Q&jO'#GzO!1|Q`O'#GzOOQS,5=_,5=_O!2RQ`O'#G{O!2ZQ`O'#CmO!2`Q`O,59OO!2jQ`O,59OO!4lQdO,59OOOQS,59O,59OO!4yQ(ChO,59OO$zQdO,59OO!5UQdO'#HSOOQS'#HT'#HTOOQS'#HU'#HUO`QdO,5=lO!5fQ`O,5=lO$zQdO'#DzO`QdO,5=rO`QdO,5=tO!5kQ`O,5=vO`QdO,5=xO!5pQ`O,5={O!5uQdO,5>ROOQS,5>X,5>XO$zQdO,5>XO6RQ(ChO,5>ZOOQS,5>],5>]O!9vQ`O,5>]OOQS,5>_,5>_O!9vQ`O,5>_OOQS,5>a,5>aO!9{Q!bO'#DWOOQ(CW'#JP'#JPO$zQdO'#JPO!:jQ!bO'#JPO!;XQ!bO'#DeO!;jQ,UO'#DeO!=uQdO'#DeO!=|Q`O'#JOO!>UQ`O,5:OO!>ZQ`O'#EdO!>iQ`O'#JZO!>qQ`O,5:}O!?XQ,UO'#DeO!?cQ,UO'#EOOOQ(C[,5:g,5:gO$zQdO,5:gOHOQ&jO,5:gO!@]QaO,5:gO:vQ`O,5:xO!.[Q!bO,5:xO!.dQ&jO,5:xO6`Q&jO,5:xO!@hQpO,59uOOOW-E;z-E;zOOQ(C[1G/`1G/`O!@mQtO,5>iO)gQdO,5>iOOQO,5>n,5>nO!@wQdO'#H}OOQO-E;{-E;{O!AUQ`O,5?iO!A^QtO,5?iO!AeQ`O,5?sOOQ(C[1G/e1G/eO$zQdO,5?tO!AmQ`O'#ISOOQO-E<Q-E<QO!AeQ`O,5?sOOQ(CW1G0h1G0hOOQ(C[1G/p1G/pOOQ(C[1G0Q1G0QOOQ(CW'#EY'#EYO$zQdO,5?qO!BRQ(ChO,5?qO!BdQ(ChO,5?qO!BkQ`O,5?pO!BsQ`O'#IUO!BkQ`O,5?pOOQ(CW1G0g1G0gO7oQ`O,5?pOOQ(C[1G0e1G0eO!C_Q(C|O1G0eO!DdQ(CyO,5:uOOQ(C]'#Fw'#FwO!F}Q(C}O'#IxOFOQdO1G0eO!GtQ&kO'#JQO!HOQ`O,5:YO!HTQtO'#JRO$zQdO'#JRO!H_Q`O,5:_OOQ(C]'#DW'#DWOOQ(C[1G0n1G0nO$zQdO1G0nOOQ(C[1G1X1G1XO!HdQ`O1G0nO!J{Q(C|O1G0pO!KSQ(C|O1G0pO!MmQ(C|O1G0pO!MtQ(C|O1G0pO#!OQ(C|O1G0pO#!fQ(C|O1G0pO#%`Q(C|O1G0pO#%gQ(C|O1G0pO#(QQ(C|O1G0pO#(XQ(C|O1G0pO#*PQ(C|O1G0pO#-PQ!LUO'#ChO#.}Q!LUO1G1RO#0{Q!LUO'#I|OMqQ`O1G1XO#1`Q(C|O,5>sOOQ(CW-E<V-E<VO#2SQ(C}O1G0pOOQ(C[1G0p1G0pO#4_Q(C|O1G1UO#5RQ!bO,5;yO#5ZQ!bO,5;zO#5cQ!bO'#FbO#5zQ`O'#FaOOQO'#J_'#J_OOQO'#IV'#IVO#6PQ!bO1G1aOOQ(C[1G1a1G1aOOOO1G1l1G1lO#6bQ!LUO'#I{O#6lQ`O,5<TOKnQdO,5<TOOOO-E<U-E<UOOQ(C[1G1^1G1^OOQ(C[,5<V,5<VO#6qQ!bO,5<VOOQ(C],59b,59bOHOQ&jO'#C|OOOW'#H{'#H{O#6vOWO,59fOOQ(C],59f,59fO$zQdO1G1rO!*XQ`O'#IZO#7RQ`O,5<kOOQ(C],5<h,5<hOOQO'#G^'#G^OIeQ&jO,5<wOOQO'#G`'#G`OIeQ&jO,5<yOHOQ&jO,5<{OOQO1G1t1G1tO#7^QqO'#CpO#7qQqO,5<dO#7xQ`O'#JbO6ZQ`O'#JbO#8WQ`O,5<fOIeQ&jO,5<eO#8]Q`O'#FzO#8hQ`O,5<eO#8mQqO'#FwO#8zQqO'#JcO#9UQ`O'#JcOHOQ&jO'#JcO#9ZQ`O,5<iOOQ(CW'#Di'#DiO#9`Q!bO'#GSO!'aQ,UO'#GSO#9qQ`O'#GUO#9vQ`O'#GWO!&bQ`O'#GZO#9{Q(ChO'#I]O#:WQ,UO,5<mOOQ(C],5<m,5<mO#:_Q,UO'#GSO#:mQ,UO'#GTO#:uQ,UO'#GTOOQ(C],5<|,5<|OIeQ&jO,5?cOIeQ&jO,5?cO#:zQ`O'#I^O#;VQ`O,5?bO#;_Q`O,59^OOQ(C]'#Ch'#ChO#<OQ&kO,59mOOQ(C],59m,59mO#<qQ&kO,5<[O#=dQ&kO,5<^O#=nQ`O,5<`OOQ(C],5<a,5<aO#=sQ`O,5<gO#=xQ&kO,5<lOFOQdO1G1sO#>YQ`O1G1sOOQS1G3}1G3}OOQ(C[1G/r1G/rOMnQ`O1G/rOOQS1G2i1G2iOHOQ&jO1G2iO$zQdO1G2iOHOQ&jO1G2iO#>_QaO1G2iO#?wQ&jO'#EZOOQ(CW,5?`,5?`O#@RQ(ChO,5?`OOQS1G.s1G.sO:vQ`O1G.sO!.[Q!bO1G.sO!.dQ&jO1G.sO#@dQ`O1G0eO#@iQ`O'#ChO#@tQ`O'#JjO#@|Q`O,5=kO#ARQ`O'#JjO#AWQ`O'#JjO#A`Q`O'#IfO#AnQ`O,5@TO#AvQtO1G1ZOOQ(C[1G1]1G1]O6ZQ`O1G3UO#A}Q`O1G3UO#BSQ`O1G3UO#BXQ`O1G3UOOQS1G3U1G3UO#B^Q&kO1G2iO7oQ`O'#JXO7oQ`O'#EdO$zQdO'#EdO7oQ`O'#I`O#BoQ(ChO,5@QOOQS1G2m1G2mO!1jQ`O1G2sOHOQ&jO1G2pO#BzQ`O1G2pOOQS1G2q1G2qOHOQ&jO1G2qO#CPQaO1G2qO#CXQ,UO'#GoOOQS1G2s1G2sO!'aQ,UO'#IbO!1oQpO1G2vOOQS1G2v1G2vOOQS,5=a,5=aO#CaQ&kO,5=cO6ZQ`O,5=cO#9vQ`O,5=fO5wQ`O,5=fO!.[Q!bO,5=fO!.dQ&jO,5=fO6`Q&jO,5=fO#CrQ`O'#JhO#C}Q`O,5=gOOQS1G.j1G.jO#DSQ(ChO1G.jO#D_Q`O1G.jO#DdQ`O1G.jO6RQ(ChO1G.jO#DlQtO,5@VO#DvQ`O,5@VO#ERQdO,5=nO#EYQ`O,5=nO7oQ`O,5@VOOQS1G3W1G3WO`QdO1G3WOOQS1G3^1G3^OOQS1G3`1G3`O:qQ`O1G3bO#E_QdO1G3dO#IYQdO'#HcOOQS1G3g1G3gO#IgQ`O'#HiO:vQ`O'#HkOOQS1G3m1G3mO#IoQdO1G3mO6RQ(ChO1G3sOOQS1G3u1G3uOOQ(CW'#GO'#GOO6RQ(ChO1G3wO6RQ(ChO1G3yO#MmQ`O,5?kOKnQdO,5;OO7oQ`O,5;OO:vQ`O,5:POKnQdO,5:PO$zQdO'#JPO!.[Q!bO,5:PO#MrQ!LUO,5:POOQO,5;O,5;OO#M|Q,UO'#IOO#NdQ`O,5?jOOQ(C[1G/j1G/jO#NlQ,UO'#ITO#NvQ`O,5?uOOQ(CW1G0i1G0iO!;jQ,UO,5:POOQ(CW'#EU'#EUO$ OQ(DjO'#EVO$ jQ,UO'#EPOOQO'#IR'#IRO$ {Q,UO,5:jOOQ(C[,5:j,5:jO$!uQ,UO'#EPO$#SQ,UO'#EPO$#dQ,UO'#E]O$#gQ,UO'#EVO$$QQ,UO'#EVO$ jQ,UO'#EVO$$qQ`O1G0RO$$vQqO1G0ROOQ(C[1G0R1G0RO$zQdO1G0ROHOQ&jO1G0ROOQ(C[1G0d1G0dO:vQ`O1G0dO!.[Q!bO1G0dO!.dQ&jO1G0dOOOW1G/a1G/aO$$}QpO,5<ZO$%VQtO1G4TOOQO1G4Y1G4YO$zQdO,5>iO$%aQ`O1G5TO$%iQ`O1G5_O$%qQtO1G5`O7oQ`O,5>nO$%{Q(C|O1G5]O$zQdO1G5]O$&]Q(ChO1G5]O$&nQ`O1G5[O7oQ`O,5>pOOQO,5>p,5>pO$&vQ`O,5>pOOQO-E<S-E<SO$&nQ`O1G5[O$'UQ(C}O,59mO$)^Q(C}O,5<[O$+iQ(C}O,5<^O$-tQ(C}O,5<lOOQ(C[7+&P7+&PO$0VQ(C|O7+&PO$0yQ&jO'#IPO$1TQ`O,5?lOOQ(C]1G/t1G/tO$1]QdO'#IQO$1jQ`O,5?mO$1rQtO,5?mOOQ(C[1G/y1G/yO$1|Q`O7+&YOOQ(C[7+&Y7+&YO$2RQ!LUO,5:`O$zQdO7+&mO$2]Q!LUO,5:WOOQ(C[7+&s7+&sOOQO1G1e1G1eOOQO1G1f1G1fO$2jQ$ISO,5;|OKnQdO,5;{OOQO-E<T-E<TOOQ(C[7+&{7+&{OOOO7+'W7+'WOOOO1G1o1G1oO$2uQ`O1G1oOOQ(C[1G1q1G1qO$2zQqO,59hOOOW-E;y-E;yOOQ(C]1G/Q1G/QO$3RQ(C|O7+'^OOQ(C],5>u,5>uO$3uQ`O,5>uOOQ(C]1G2V1G2VP$3zQ`O'#IZPOQ(C]-E<X-E<XO$4kQ&kO1G2cO$5^Q&kO1G2eO$5hQqO1G2gOOQ(C]1G2O1G2OO$5oQ`O'#IYO$5}Q`O,5?|O$5}Q`O,5?|O$6VQ`O,5?|O$6bQ`O,5?|OOQO1G2Q1G2QO$6pQ&kO1G2POIeQ&jO1G2PO$7QQMhO'#I[O$7bQ`O,5?}OHOQ&jO,5?}O$7jQqO,5?}OOQ(C]1G2T1G2TOOQ(CW,5<n,5<nOOQ(CW,5<o,5<oO$7tQ`O,5<oO#9lQ`O,5<oO!.[Q!bO,5<nOOQO'#GV'#GVO$7yQ`O,5<pOOQ(CW,5<r,5<rO$7tQ`O,5<uOOQO,5>w,5>wOOQO-E<Z-E<ZOOQ(C]1G2X1G2XO!'aQ,UO,5<nO$8RQ`O,5<oO#9qQ`O,5<pO!'aQ,UO,5<oO$8^Q&kO1G4}O$8hQ&kO1G4}OOQO,5>x,5>xOOQO-E<[-E<[OOQP1G.x1G.xO!/_Q,UO,59oO$zQdO,59oO$8uQ`O1G1zOIeQ&jO1G2RO$8zQ(C|O7+'_OOQ(C[7+'_7+'_OFOQdO7+'_OOQ(C[7+%^7+%^O$9nQqO'#JdO$$qQ`O7+(TO$9xQ`O7+(TO$:QQqO7+(TOOQS7+(T7+(TOHOQ&jO7+(TO$zQdO7+(TOHOQ&jO7+(TO$:[Q(CyO'#ChO$:oQ(CyO,5<sO$;aQ`O,5<sOOQ(CW1G4z1G4zOOQS7+$_7+$_O:vQ`O7+$_O!.[Q!bO7+$_OFOQdO7+&PO$;fQ`O'#IeO$;wQ`O,5@UOOQO1G3V1G3VO6ZQ`O,5@UO$;wQ`O,5@UO$<PQ`O,5@UOOQO,5?Q,5?QOOQO-E<d-E<dOOQ(C[7+&u7+&uO$<UQ`O7+(pO6RQ(ChO7+(pO6ZQ`O7+(pO$<ZQ`O7+(pO$<`QaO7+(TO$<nQ`O,5;OOOQ(CW,5>z,5>zOOQ(CW-E<^-E<^OOQS7+(_7+(_O$<sQ(CyO7+([OHOQ&jO7+([O$<}QqO7+(]OOQS7+(]7+(]OHOQ&jO7+(]O$=UQ`O'#JgO$=aQ`O,5=ZOOQO,5>|,5>|OOQO-E<`-E<`OOQS7+(b7+(bO$>dQ,UO'#GxOOQS1G2}1G2}OHOQ&jO1G2}O$zQdO1G2}OHOQ&jO1G2}O$>kQaO1G2}O$>yQ&kO1G2}O6RQ(ChO1G3QO#9vQ`O1G3QO5wQ`O1G3QO!.[Q!bO1G3QO!.dQ&jO1G3QO$?[Q`O'#IdO$?gQ`O,5@SO$?oQ,UO,5@SOOQ(CW1G3R1G3ROOQS7+$U7+$UO$?wQ`O7+$UO6RQ(ChO7+$UO$?|Q`O7+$UO$zQdO1G5qO$zQdO1G5rO$@RQdO1G3YO$@YQ`O1G3YO$@_QdO1G3YO$@fQ(ChO1G5qOOQS7+(r7+(rO6RQ(ChO7+(|O`QdO7+)OOOQS'#Jm'#JmOOQS'#Ig'#IgO$@pQdO,5=}OOQS,5=},5=}O$zQdO'#HdO$@}Q`O'#HfOOQS,5>T,5>TO7oQ`O,5>TOOQS,5>V,5>VOOQS7+)X7+)XOOQS7+)_7+)_OOQS7+)c7+)cOOQS7+)e7+)eO$ASQ!bO1G5VO$AhQ!LUO1G0jO$ArQ`O1G0jOOQO1G/k1G/kO$A}Q!LUO1G/kO$BXQ`O,5?kO:vQ`O1G/kOKnQdO'#DeOOQO,5>j,5>jOOQO-E;|-E;|OOQO,5>o,5>oOOQO-E<R-E<RO!.[Q!bO1G/kO:vQ`O,5:kOOQO,5:q,5:qO$zQdO,5:qO$B^Q(ChO,5:qO$BiQ(ChO,5:qO!.[Q!bO,5:kOOQO-E<P-E<POOQ(C[1G0U1G0UO$ jQ,UO,5:kO$BwQ,UO,5:kO$CUQ(DjO,5:qO$CpQ,UO,5:kO$ jQ,UO,5:qOOQO,5:w,5:wO$DQQ,UO,5:qO$DkQ(ChO,5:qOOQ(C[7+%m7+%mO$$qQ`O7+%mO$$vQqO7+%mOOQ(C[7+&O7+&OO:vQ`O7+&OO!.[Q!bO7+&OO$EPQ(C|O7+*wO$zQdO7+*wOOQO1G4[1G4[O7oQ`O1G4[O$EaQ`O7+*vO$EiQ(C}O1G2cO$GtQ(C}O1G2eO$JPQ(C}O1G2PO$LbQ&kO,5>kOOQO-E;}-E;}O$LlQtO,5>lO$zQdO,5>lOOQO-E<O-E<OO$LvQ`O1G5XOOQ(C[<<It<<ItO$MOQ!LUO1G0eO% YQ!LUO1G0pO% aQ!LUO1G0pO%#eQ!LUO1G0pO%#lQ!LUO1G0pO%%aQ!LUO1G0pO%%wQ!LUO1G0pO%([Q!LUO1G0pO%(cQ!LUO1G0pO%*gQ!LUO1G0pO%*nQ!LUO1G0pO%,fQ!LUO1G0pO%,yQ(C|O<<JXO%.OQ!LVO1G0pO%/tQ!LVO'#IxO%0OQ!LUO1G1UOKnQdO'#FdOOQO'#J`'#J`OOQO1G1h1G1hO%0]Q`O1G1gO%0bQ!LUO,5>sOOOO7+'Z7+'ZOOOW1G/S1G/SOOQ(C]1G4a1G4aOIeQ&jO7+(RO%0lQ`O,5>tO6ZQ`O,5>tOOQO-E<W-E<WO%0zQ`O1G5hO%0zQ`O1G5hO%1SQ`O1G5hO%1_Q&kO7+'kO%1oQqO,5>vO%1yQ`O,5>vOHOQ&jO,5>vOOQO-E<Y-E<YO%2OQqO1G5iO%2YQ`O1G5iOOQ(CW1G2Z1G2ZO$7tQ`O1G2ZOOQ(CW1G2Y1G2YO%2bQ`O1G2[OHOQ&jO1G2[OOQ(CW1G2a1G2aO!.[Q!bO1G2YO#9lQ`O1G2ZO%2gQ`O1G2[O%2oQ`O1G2ZOIeQ&jO7+*iOOQ(C]1G/Z1G/ZO%2zQ`O1G/ZOOQ(C]7+'f7+'fO%3PQ&kO7+'mO%3aQ(C|O<<JyOOQ(C[<<Jy<<JyOHOQ&jO'#I_O%4TQ`O,5@OOOQS<<Ko<<KoOHOQ&jO<<KoO$$qQ`O<<KoO%4]Q`O<<KoO%4eQqO<<KoOHOQ&jO1G2_OOQS<<Gy<<GyO:vQ`O<<GyO%4oQ(C|O<<IkOOQ(C[<<Ik<<IkOOQO,5?P,5?PO%5cQ`O,5?PO%5hQ`O,5?POOQO-E<c-E<cO%5pQ`O1G5pO%5pQ`O1G5pO6ZQ`O1G5pO%5xQ`O<<L[OOQS<<L[<<L[O%5}Q`O<<L[O6RQ(ChO<<L[O$zQdO<<KoOHOQ&jO<<KoO%6SQ`O1G0jOOQS<<Kv<<KvO$<sQ(CyO<<KvOOQS<<Kw<<KwO$<}QqO<<KwO%6XQ,UO'#IaO%6dQ`O,5@ROKnQdO,5@ROOQS1G2u1G2uO%6lQ(DjO'#JPO%7WQdO'#JPO%7_Q(ChO'#EVO$ OQ(DjO'#EVO$ sQ,UO'#GyOOQO'#Ic'#IcO%7sQ,UO,5=dOOQS,5=d,5=dO%7zQ,UO'#EVO%8]Q,UO'#EVO%8sQ,UO'#EVO%9aQ,UO'#GyO%9rQ`O7+(iO%9wQ`O7+(iO%:PQqO7+(iOOQS7+(i7+(iOHOQ&jO7+(iO$zQdO7+(iOHOQ&jO7+(iO%:ZQaO7+(iOOQS7+(l7+(lO6RQ(ChO7+(lO#9vQ`O7+(lO5wQ`O7+(lO!.[Q!bO7+(lO%:iQ`O,5?OOOQO-E<b-E<bOOQO'#G|'#G|O%:tQ`O1G5nO6RQ(ChO<<GpOOQS<<Gp<<GpO%:|Q`O<<GpO%;RQ`O7++]O%;WQ`O7++^OOQS7+(t7+(tO%;]Q`O7+(tO%;bQdO7+(tO%;iQ`O7+(tO$zQdO7++]O$zQdO7++^OOQS<<Lh<<LhOOQS<<Lj<<LjOOQS-E<e-E<eOOQS1G3i1G3iO%;nQ`O,5>OOOQS,5>Q,5>QO%;sQ`O1G3oO7oQ`O7+&UOKnQdO7+&UOOQ(CW1G5V1G5VOOQO7+%V7+%VO%;xQ!LUO1G5`O:vQ`O7+%VOOQO1G0V1G0VO%<SQ(C|O1G0]OOQO1G0]1G0]O$zQdO1G0]O%<^Q(ChO1G0]O:vQ`O1G0VO!.[Q!bO1G0VO$ jQ,UO1G0VO%<iQ(ChO1G0]O%<wQ,UO1G0VO%=UQ(ChO1G0]O%=jQ(DjO1G0]O%=tQ,UO1G0VO$ jQ,UO1G0]OOQ(C[<<IX<<IXOOQ(C[<<Ij<<IjO:vQ`O<<IjO%>UQ(C|O<<NcOOQO7+)v7+)vO%>fQ(C}O7+'kO%@wQ(C}O7+'mO%CYQtO1G4WO%CdQ!LUO7+&PO%DYQ!LVO,59mO%F^Q!LVO,5<[O%HeQ!LVO,5<^O%JWQ!LVO,5<lO%K|Q!LUO7+'^O%LZQ!LUO7+'_O%LhQ`O,5<OOOQO7+'R7+'RO%LmQ&kO<<KmOOQO1G4`1G4`O%LtQ`O1G4`O%MPQ`O1G4`O%M_Q`O7++SO%M_Q`O7++SOHOQ&jO1G4bO%MgQqO1G4bO%MqQ`O7++TOOQ(CW7+'u7+'uO$7tQ`O7+'vO%MyQqO7+'vOOQ(CW7+'t7+'tO$7tQ`O7+'uO%NQQ`O7+'vOHOQ&jO7+'vO#9lQ`O7+'uO%NVQ&kO<<NTOOQ(C]7+$u7+$uO%NaQqO,5>yOOQO-E<]-E<]O$$qQ`OANAZOOQSANAZANAZOHOQ&jOANAZO%NkQ(CyO7+'yOOQSAN=eAN=eO6ZQ`O1G4kOOQO1G4k1G4kO%N{Q`O1G4kO& QQ`O7++[O& QQ`O7++[O6RQ(ChOANAvO& YQ`OANAvOOQSANAvANAvO& _Q`OANAZO& gQqOANAZOOQSANAbANAbOOQSANAcANAcO& qQ`O,5>{OOQO-E<_-E<_O& |Q!LUO1G5mO#9vQ`O,5=eO5wQ`O,5=eO&$^QtO'#ChO!.[Q!bO,5=eOOQO-E<a-E<aOOQS1G3O1G3OO%7WQdO,5<pO%6lQ(DjO,5=eO$CUQ(DjO,5:qO$ sQ,UO,5=eO&$hQ,UO,5=eO&$yQ,UO,5:qOOQS<<LT<<LTOHOQ&jO<<LTO%9rQ`O<<LTO&%aQ`O<<LTO&%iQqO<<LTO$zQdO<<LTOHOQ&jO<<LTOOQS<<LW<<LWO6RQ(ChO<<LWO#9vQ`O<<LWO5wQ`O<<LWO&%sQ,UO1G4jO&%{Q`O7++YOOQSAN=[AN=[O6RQ(ChOAN=[OOQS<<Nw<<NwOOQS<<Nx<<NxOOQS<<L`<<L`O&&TQ`O<<L`O&&YQdO<<L`O&&aQ`O<<NwO&&fQ`O<<NxOOQS1G3j1G3jO:vQ`O7+)ZO&&kQ`O<<IpO&&vQ!LUO<<IpOOQO<<Hq<<HqOOQO7+%w7+%wO%<SQ(C|O7+%wO$zQdO7+%wOOQO7+%q7+%qO:vQ`O7+%qO!.[Q!bO7+%qO&'QQ(ChO7+%wO$ jQ,UO7+%qO&']Q(ChO7+%wO&'kQ,UO7+%qO&'xQ(ChO7+%wOOQ(C[AN?UAN?UO&(^Q!LUO<<JXO&(kQ!LVO1G2PO&*uQ!LVO1G2cO&,|Q!LVO1G2eO&.oQ!LUO<<JyO&.|Q!LUO<<IkOOQO1G1j1G1jOIeQ&jOANAXOOQO7+)z7+)zO&/ZQ`O7+)zO&/fQ`O<<NnO&/nQqO7+)|OOQ(CW<<Kb<<KbO$7tQ`O<<KbOOQ(CW<<Ka<<KaO&/xQqO<<KbO$7tQ`O<<KaOOQSG26uG26uO$$qQ`OG26uOOQO7+*V7+*VO6ZQ`O7+*VO&0PQ`O<<NvOOQSG27bG27bO6RQ(ChOG27bOHOQ&jOG26uOKnQdO1G4gO&0XQ`O7++XO6RQ(ChO1G3PO#9vQ`O1G3PO5wQ`O1G3PO!.[Q!bO1G3PO$ sQ,UO1G3PO%6lQ(DjO1G3PO%=jQ(DjO1G0]O&0aQ,UO1G3PO%9rQ`OANAoOOQSANAoANAoOHOQ&jOANAoO&0rQ`OANAoO&0zQqOANAoOOQSANArANArO6RQ(ChOANArO#9vQ`OANArOOQO'#G}'#G}OOQO7+*U7+*UOOQSG22vG22vOOQSANAzANAzO&1UQ`OANAzOOQSANDcANDcOOQSANDdANDdOOQS<<Lu<<LuOKnQdOAN?[OOQO<<Ic<<IcO%<SQ(C|O<<IcOOQO<<I]<<I]O:vQ`O<<I]O$zQdO<<IcO!.[Q!bO<<I]O&1ZQ(ChO<<IcO$ jQ,UO<<I]O&1fQ(ChO<<IcO&1tQ!LVO7+'kO&3jQ!LVO7+'mO&5`Q&kOG26sOOQO<<Mf<<MfOOQ(CWAN@|AN@|O$7tQ`OAN@|OOQ(CWAN@{AN@{OOQSLD,aLD,aOOQO<<Mq<<MqOOQSLD,|LD,|O$$qQ`OLD,aO&5pQ!LUO7+*ROOQO7+(k7+(kO6RQ(ChO7+(kO#9vQ`O7+(kO5wQ`O7+(kO!.[Q!bO7+(kO$ sQ,UO7+(kOOQSG27ZG27ZO%9rQ`OG27ZOHOQ&jOG27ZOOQSG27^G27^O6RQ(ChOG27^OOQSG27fG27fO&5zQ!LUOG24vOOQOAN>}AN>}OOQOAN>wAN>wO%<SQ(C|OAN>}O:vQ`OAN>wO$zQdOAN>}O!.[Q!bOAN>wO&6UQ(ChOAN>}O&6aQ(C}OG26sOOQ(CWG26hG26hOOQS!$( {!$( {OOQO<<LV<<LVO6RQ(ChO<<LVO#9vQ`O<<LVO5wQ`O<<LVO!.[Q!bO<<LVOOQSLD,uLD,uO%9rQ`OLD,uOOQSLD,xLD,xOOQOG24iG24iOOQOG24cG24cO%<SQ(C|OG24iO:vQ`OG24cO$zQdOG24iO&9TQ7]O,5:uOOQOANAqANAqO6RQ(ChOANAqO#9vQ`OANAqO5wQ`OANAqOOQS!$(!a!$(!aOOQOLD*TLD*TOOQOLD)}LD)}O%<SQ(C|OLD*TO&:TQ!LVOG26sO&;yQ7]O,59mO&<vQ7]O,5<[O&=sQ7]O,5<^O&>pQ7]O,5<lOOQOG27]G27]O6RQ(ChOG27]O#9vQ`OG27]OOQO!$'Mo!$'MoO&?pQ7]O1G2cO&@mQ7]O1G2eO&AjQ7]O1G2POOQOLD,wLD,wO6RQ(ChOLD,wO&BjQ7]O7+'kO&CjQ7]O7+'mOOQO!$(!c!$(!cO&DjQ7]OG26sOKnQdO'#DtO&EjQtO'#I{OKnQdO'#DlO&EqQtO'#ChO&HXQtO'#ChO&HiQdO,5:yO&JiQ&jO'#EZOKnQdO,5;UOKnQdO,5;UOKnQdO,5;UOKnQdO,5;UOKnQdO,5;UOKnQdO,5;UOKnQdO,5;UOKnQdO,5;UOKnQdO,5;UOKnQdO,5;UOKnQdO,5;UOKnQdO'#IXO&KyQ`O,5<ZO&LRQ&jO,5;UO&McQ&jO,5;UOKnQdO,5;jO!)}Q`O'#DRO!)}Q`O'#DRO!)}Q`O'#DROHOQ&jO'#FpO&JiQ&jO'#FpO&LRQ&jO'#FpOHOQ&jO'#FrO&JiQ&jO'#FrO&LRQ&jO'#FrOHOQ&jO'#GQO&JiQ&jO'#GQO&LRQ&jO'#GQOKnQdO,5?tO&HiQdO1G0eO&MjQ!LUO'#ChOKnQdO1G1rOHOQ&jO,5<wO&JiQ&jO,5<wO&LRQ&jO,5<wOHOQ&jO,5<yO&JiQ&jO,5<yO&LRQ&jO,5<yOHOQ&jO,5<eO&JiQ&jO,5<eO&LRQ&jO,5<eO&HiQdO1G1sOKnQdO7+&mOHOQ&jO1G2PO&JiQ&jO1G2PO&LRQ&jO1G2POHOQ&jO1G2RO&JiQ&jO1G2RO&LRQ&jO1G2RO&HiQdO7+'_O&HiQdO7+&PO&MtQ`O7+'vOHOQ&jOANAXO&JiQ&jOANAXO&LRQ&jOANAXO&MtQ`O<<KbO&MtQ`OAN@|O&MyQ`O'#E_O&NOQ`O'#E_O&NWQ`O'#FOO&N]Q`O'#EjO&NbQ`O'#JYO&NmQ`O'#JWO&NxQ`O,5:yO&N}Q&kO,5<WO' UQ`O'#FyO' ZQ`O'#FyO' `Q`O'#FyO' eQ`O,5<XO' mQ`O,5:yO' uQ!LUO1G1RO' |Q`O,5<eO'!RQ`O,5<eO'!WQ`O,5<eO'!]Q`O,5<gO'!bQ`O,5<gO'!gQ`O,5<gO'!lQ`O1G1sO'!qQ`O1G0eO'!vQ`O1G2[O'!{Q&kO<<KmO'#SQ&kO<<KmO'#ZQ&kO<<KmO'#bQqO7+'vO'#iQ`O7+'vO'#nQqO<<KbO4dQ&jO'#FnO5wQ`O'#FmO=_Q`O'#E^OKnQdO,5;gO!&bQ`O'#FyO!&bQ`O'#FyO!&bQ`O'#FyO!&bQ`O'#F{O!&bQ`O'#F{O!&bQ`O'#F{O'#uQ`O,5<pOIeQ&jO7+(ROIeQ&jO7+(ROIeQ&jO7+(ROHOQ&jO1G2[O'#}Q`O1G2[OHOQ&jO7+'vO$5hQqO1G2gO$5hQqO1G2gO$5hQqO1G2gOHOQ&jO,5<{OHOQ&jO,5<{OHOQ&jO,5<{",
    stateData: "'%Q~O'bOS'cOSTOSUOS~OQUORUOXzO]dO_iOboOcnOidOkUOldOmdOrdOtUOvUO{SO!OdO!PdO!VTO!alO!fVO!iUO!jUO!kUO!lUO!mUO!pmO#htO#xqO#|_O%WrO%YuO%[sO%]sO%`vO%bwO%exO%fxO%hyO%u{O%{|O%}}O&P!OO&R!PO&U!QO&[!RO&b!SO&d!TO&f!UO&h!VO&j!WO'eQO'mRO'vZO(TbO~OQUORUO]dOb!^Oc!]OidOkUOldOmdOrdOtUOvUO{SO!OdO!PdO!V!YO!alO!fVO!iUO!jUO!kUO!lUO!mUO!p![O#x!_O#|_O'e!XO'mRO'vZO(TbO~OQ[XZ[X_[Xk[Xx[Xy[X{[X!T[X!c[X!d[X!f[X!l[X#O[X#ZdX#_[X#`[X#a[X#b[X#c[X#d[X#e[X#f[X#g[X#i[X#k[X#m[X#n[X#s[X'`[X'm[X'w[X(O[X(P[X~O!_$rX~P&zOS!`O'^!aO'_!cO~OQUORUO]dOb!^Oc!]OidOkUOldOmdOrdOtUOvUO{SO!OdO!PdO!V!YO!alO!fVO!iUO!jUO!kUO!lUO!mUO!p![O#x!_O#|_O'e:OO'mRO'vZO(TbO~O!S!gO!T!dO!Q'qP!Q'{P~P)gO!U!oO~P`OQUORUO]dOb!^Oc!]OidOkUOldOmdOrdOtUOvUO{SO!OdO!PdO!V!YO!alO!fVO!iUO!jUO!kUO!lUO!mUO!p![O#x!_O#|_O'mRO'vZO(TbO~O!S!tO#X!wO#Y!tO'e:PO!e'xP~P,OO#Z!xO~O!_!yO#Z!xO~OQ#aOZ#hOk#UOx!}Oy#OO{#PO!T#eO!c#WO!d!{O!f!|O!l#aO#_#SO#`#TO#a#TO#b#TO#c#VO#d#WO#e#WO#f#gO#g#WO#i#XO#k#ZO#m#]O#n#^O'mRO'w#_O(O#QO(P#RO~O_'oX'`'oX'['oX!e'oX!Q'oX!V'oX%X'oX!_'oX~P.mO#O#iO#s#iOQ'pXZ'pX_'pXk'pXx'pXy'pX{'pX!T'pX!c'pX!d'pX!f'pX!l'pX#_'pX#`'pX#a'pX#b'pX#c'pX#d'pX#e'pX#f'pX#i'pX#k'pX#m'pX#n'pX'm'pX'w'pX(O'pX(P'pX~O#g'pX'`'pX'['pX!Q'pX!e'pXo'pX!V'pX%X'pX!_'pX~P1TO#O#iO~O$O#kO$Q#jO$X#pO~O!V#qO#|_O$[#rO$^#tO~O]#wOi$WOk#xOl#wOm#wOr$XOt$YOv$ZO{$PO!V$QO!a$`O!f#|O#Y$aO#x$^O$e$[O$g$]O$j$_O'e#vO'i$VO'm#yOe'jP~O!f$bO~O!_$dO~O_$eO'`$eO~O'e$iO~O!f$bO'e$iO'f$kO'i$VO~Oc$qO!f$bO'e$iO~O#g#WO~O]$zOx$vO!V$sO!f$uO%Y$yO'e$iO'f$kO^(]P~O!p${O~O{$|O!V$}O'e$iO~O{$|O!V$}O%b%RO'e$iO~O'e%SO~O#htO%YuO%[sO%]sO%`vO%bwO%exO%fxO~Ob%]Oc%[O!p%YO%W%ZO%j%XO~P8_Ob%`OcnO!V%_O!pmO#htO%WrO%[sO%]sO%`vO%bwO%exO%fxO%hyO~O`%cO#O%fO%Y%aO'f$kO~P9^O!f%gO!i%kO~O!f%lO~O!VTO~O_$eO']%tO'`$eO~O_$eO']%wO'`$eO~O_$eO']%yO'`$eO~O'[[Xo[X!Q[X!e[X%y[X!V[X%X[X!_[X~P&zO]&OOl&OO{%}O!S&RO!Y&XO!Z&QO![&QO'f$kO'n%{O!U'rP!U'}P~OP&]O!V&YO!q&[O'e$iO~Oc&bO!f$bO'e$iO~Ox$vO!f$uO~OS!`O'^!aO'_&eO~O!S&gO!Q&qX!Q&vX!T&qX!T&vX~P)gO!T&iO!Q'qX~OQ#aOZ#hOk#UOx!}Oy#OO{#PO!T&iO!c#WO!d!{O!f!|O!l#aO#_#SO#`#TO#a#TO#b#TO#c#VO#d#WO#e#WO#f#gO#g#WO#i#XO#k#ZO#m#]O#n#^O'mRO'w#_O(O#QO(P#RO~O!Q'qX~P>jO!Q&nO~O!Q'zX!T'zX!_'zX!e'zX'w'zX~O#O'zX#Z#SX!U'zX~P@pO#O&oO!Q'|X!T'|X~O!T&pO!Q'{X~O!Q&sO~O#O#iO~P@pO!U&tO~P`Ox!}Oy#OO{#PO!d!{O!f!|O'mROQ!haZ!hak!ha!T!ha!c!ha!l!ha#_!ha#`!ha#a!ha#b!ha#c!ha#d!ha#e!ha#f!ha#g!ha#i!ha#k!ha#m!ha#n!ha'w!ha(O!ha(P!ha~O_!ha'`!ha'[!ha!Q!ha!e!hao!ha!V!ha%X!ha!_!ha~PBWO!e&uO~O!_!yO#O&wO'w&vO!T'yX_'yX'`'yX~O!e'yX~PDvO!T&{O!e'xX~O!e&}O~O{$|O!V$}O#Y'OO'e$iO~OQUORUO]dOb!^Oc!]OidOkUOldOmdOrdOtUOvUO{SO!OdO!PdO!VTO!alO!fVO!iUO!jUO!kUO!lUO!mUO!p![O#x!_O#|_O'e!XO'mRO'vZO(TbO~O]#wOi$WOk#xOl#wOm#wOr$XOt$YOv:dO{$PO!V$QO!a<TO!f#|O#Y:mO#x$^O$e:gO$g:jO$j$_O'e'SO'i$VO'm#yO~O#Z'UO~O]#wOi$WOk#xOl#wOm#wOr$XOt$YOv$ZO{$PO!V$QO!a$`O!f#|O#Y$aO#x$^O$e$[O$g$]O$j$_O'e'SO'i$VO'm#yO~Oe'tP~PIeO!S'YO!e'uP~P$zO'n'[O'vZO~O{'^O!f!|O'n'[O'vZO~OQ9{OR9{O]dOb<OOc!]OidOk9{OldOmdOrdOt9{Ov9{O{SO!OdO!PdO!V!YO!a9}O!fVO!i9{O!j9{O!k9{O!l9{O!m9{O!p![O#x!_O#|_O'e'lO'mRO'vZO(T;|O~Oy'oO!f!|O~O!T#eO_$ca'`$ca'[$ca!e$ca!Q$ca!V$ca%X$ca!_$ca~O#h'sO~PHOOx'vO!_'uO!V$PX#{$PX$O$PX$Q$PX$X$PX~O!_'uO!V(QX#{(QX$O(QX$Q(QX$X(QX~Ox'vO~P! TOx'vO!V(QX#{(QX$O(QX$Q(QX$X(QX~O!V'xO#{'|O$O'wO$Q'wO$X'}O~O!S(QO~PKnO$O#kO$Q#jO$X(TO~OP$kXx$kX{$kX!d$kX(O$kX(P$kX~OPgXegXe$kX!TgX#OgX~P!!yOl(VO~OS(WO'^(XO'_(ZO~OP(dOx(]O{(^O(O(`O(P(bO~Oe([O~P!$SOe(eO~O]#wOi$WOk#xOl#wOm#wOr$XOt$YOv:dO{$PO!V$QO!a<TO!f#|O#Y:mO#x$^O$e:gO$g:jO$j$_O'i$VO'm#yO~O!S(iO'e(fO!e(UP~P!$qO#Z(kO~O!f(lO~O!S(qO'e(nO!Q(VP~P!$qOk)OO{(vO!Y(|O!Z(uO![(uO!f(lO!z(}O%O(xO'f$kO'n(sO~O!U({O~P!&tO!d!{OP'lXx'lX{'lX(O'lX(P'lX!T'lX#q'lX!U'lX~Oe'lX#O'lX]'lXl'lX!Y'lX!Z'lX!['lX!t'lX!u'lX!v'lX!z'lX!{'lX'f'lX'n'lX'v'lX~P!'mOP)RO#O)QOe'kX!T'kX~O!T)SOe'jX~O'e%SOe'jP~O'e)VO~O!f)[O~O'e'SO~O{$|O!S!tO!V$}O#X!wO#Y!tO'e$iO!e'xP~O!_!yO#Z)`O~OQ#aOZ#hOk#UOx!}Oy#OO{#PO!c#WO!d!{O!f!|O!l#aO#_#SO#`#TO#a#TO#b#TO#c#VO#d#WO#e#WO#f#gO#g#WO#i#XO#k#ZO#m#]O#n#^O'mRO'w#_O(O#QO(P#RO~O_!`a!T!`a'`!`a'[!`a!Q!`a!e!`ao!`a!V!`a%X!`a!_!`a~P!*}OP)hO!V&YO!q)gO%X)fO'i$VO~O!_)jO!V'hX_'hX!T'hX'`'hX~O!f$bO'i$VO~O!f$bO'e$iO'i$VO~O!_!yO#Z'UO~O])uO%Y)vO'e)rO!U(^P~O!T)wO^(]X~O'n'[O~OZ){O~O^)|O~O!V$sO'e$iO'f$kO^(]P~O{$|O!S*RO!T&pO!V$}O'e$iO!Q'{P~O]&UOl&UO{*TO!S*SO'n'[O~O!U'}P~P!0bO!T*UO_(YX'`(YX~O#O*YO'i$VO~OP*]O!V$QO'i$VO~O!V*_O~Ox*aO!VTO~O!p*fO~Oc*kO~O'e)VO!U([P~Oc$qO~O%YuO'e%SO~P9^OZ*qO^*pO~OQUORUO]dOboOcnOidOkUOldOmdOrdOtUOvUO{SO!OdO!PdO!alO!fVO!iUO!jUO!kUO!lUO!mUO!pmO#|_O%WrO'mRO'vZO(TbO~O!V!YO#x!_O'e!XO~P!2rO^*pO_$eO'`$eO~O_*uO#h*wO%[*wO%]*wO~P$zO!f%gO~O%{*|O~O!V+OO~O&^+QO&`+ROQ&ZaR&ZaX&Za]&Za_&Zab&Zac&Zai&Zak&Zal&Zam&Zar&Zat&Zav&Za{&Za!O&Za!P&Za!V&Za!a&Za!f&Za!i&Za!j&Za!k&Za!l&Za!m&Za!p&Za#h&Za#x&Za#|&Za%W&Za%Y&Za%[&Za%]&Za%`&Za%b&Za%e&Za%f&Za%h&Za%u&Za%{&Za%}&Za&P&Za&R&Za&U&Za&[&Za&b&Za&d&Za&f&Za&h&Za&j&Za'[&Za'e&Za'm&Za'v&Za(T&Za!U&Za&S&Za`&Za&X&Za~O'e+WO~O!TzX!T!]X!UzX!U!]X!_zX!_!]X!f!]X#OzX'i!]X~O!_+]O#O+[O!T#WX!T'sX!U#WX!U'sX!_'sX!f'sX'i'sX~O!_+_O!f$bO'i$VO!T!XX!U!XX~O]%|Ol%|O{+`O'n(sO~OQ9{OR9{O]dOb<OOc!]OidOk9{OldOmdOrdOt9{Ov9{O{SO!OdO!PdO!V!YO!a9}O!fVO!i9{O!j9{O!k9{O!l9{O!m9{O!p![O#x!_O#|_O'mRO'vZO(T;|O~O'e:rO~P!;xO!T+dO!U'rX~O!U+fO~O!_+]O#O+[O!T#WX!U#WX~O!T+gO!U'}X~O!U+iO~O]%|Ol%|O{+`O'f$kO'n(sO~O!Z+jO![+jO~P!>vO_+nO!U+pO!Y+qO!Z+mO![+mO!t+uO!u+sO!v+tO!w+rO!z+vO!{+vO'v+kO~P!>vOP+{O!V&YO!q+zO~Oo,QO~O!Q&qa!T&qa~P!*}O!S,UO!Q&qX!T&qX~P$zO!T&iO!Q'qa~O!Q'qa~P>jO!T&pO!Q'{a~O{$|O!S,YO!V$}O'e$iO!Q&vX!T&vX~O#O,[O!T'ya!e'ya_'ya'`'ya~O!_!yO~P!BRO!T&{O!e'xa~O{$|O!S,_O!V$}O#X,aO#Y,_O'e$iO!T&xX!e&xX~O_#Ri!T#Ri'`#Ri'[#Ri!Q#Ri!e#Rio#Ri!V#Ri%X#Ri!_#Ri~P!*}OP<bOx(]O{(^O(O(`O(P(bO~O#Z!}a!T!}a!e!}a#O!}a!V!}a_!}a'`!}a!Q!}a~P!DRO!d!{OP'lXx'lX{'lX(O'lX(P'lXQ'lXZ'lXk'lXy'lX!T'lX!c'lX!f'lX!l'lX#_'lX#`'lX#a'lX#b'lX#c'lX#d'lX#e'lX#f'lX#g'lX#i'lX#k'lX#m'lX#n'lX'm'lX'w'lX~O#Z'lX_'lX'`'lX!e'lX!Q'lX'['lX!V'lX#O'lXo'lX%X'lX!_'lX~P!EQO!T,jOe'tX~P!$SOe,lO~O!T,mO!e'uX~P!*}O!e,pO~O!Q,rO~OQ#aOx!}Oy#OO{#PO!d!{O!f!|O!l#aO'mROZ#^i_#^ik#^i!T#^i!c#^i#`#^i#a#^i#b#^i#c#^i#d#^i#e#^i#f#^i#g#^i#i#^i#k#^i#m#^i#n#^i'`#^i'w#^i(O#^i(P#^i'[#^i!Q#^i!e#^io#^i!V#^i%X#^i!_#^i~O#_#^i~P!HiO#_#SO~P!HiOQ#aOx!}Oy#OO{#PO!d!{O!f!|O!l#aO#_#SO#`#TO#a#TO#b#TO'mROZ#^i_#^i!T#^i!c#^i#c#^i#d#^i#e#^i#f#^i#g#^i#i#^i#k#^i#m#^i#n#^i'`#^i'w#^i(O#^i(P#^i'[#^i!Q#^i!e#^io#^i!V#^i%X#^i!_#^i~Ok#^i~P!KZOk#UO~P!KZOQ#aOk#UOx!}Oy#OO{#PO!d!{O!f!|O!l#aO#_#SO#`#TO#a#TO#b#TO#c#VO'mRO_#^i!T#^i#i#^i#k#^i#m#^i#n#^i'`#^i'w#^i(O#^i(P#^i'[#^i!Q#^i!e#^io#^i!V#^i%X#^i!_#^i~OZ#^i!c#^i#d#^i#e#^i#f#^i#g#^i~P!M{OZ#hO!c#WO#d#WO#e#WO#f#gO#g#WO~P!M{OQ#aOZ#hOk#UOx!}Oy#OO{#PO!c#WO!d!{O!f!|O!l#aO#_#SO#`#TO#a#TO#b#TO#c#VO#d#WO#e#WO#f#gO#g#WO#i#XO'mRO_#^i!T#^i#k#^i#m#^i#n#^i'`#^i'w#^i(P#^i'[#^i!Q#^i!e#^io#^i!V#^i%X#^i!_#^i~O(O#^i~P#!|O(O#QO~P#!|OQ#aOZ#hOk#UOx!}Oy#OO{#PO!c#WO!d!{O!f!|O!l#aO#_#SO#`#TO#a#TO#b#TO#c#VO#d#WO#e#WO#f#gO#g#WO#i#XO#k#ZO'mRO(O#QO_#^i!T#^i#m#^i#n#^i'`#^i'w#^i'[#^i!Q#^i!e#^io#^i!V#^i%X#^i!_#^i~O(P#^i~P#%nO(P#RO~P#%nOQ#aOZ#hOk#UOx!}Oy#OO{#PO!c#WO!d!{O!f!|O!l#aO#_#SO#`#TO#a#TO#b#TO#c#VO#d#WO#e#WO#f#gO#g#WO#i#XO#k#ZO#m#]O'mRO(O#QO(P#RO~O_#^i!T#^i#n#^i'`#^i'w#^i'[#^i!Q#^i!e#^io#^i!V#^i%X#^i!_#^i~P#(`OQ[XZ[Xk[Xx[Xy[X{[X!c[X!d[X!f[X!l[X#O[X#ZdX#_[X#`[X#a[X#b[X#c[X#d[X#e[X#f[X#g[X#i[X#k[X#m[X#n[X#s[X'm[X'w[X(O[X(P[X!T[X!U[X~O#q[X~P#*yOQ#aOZ:bOk:UOx!}Oy#OO{#PO!c:WO!d!{O!f!|O!l#aO#_:SO#`:TO#a:TO#b:TO#c:VO#d:WO#e:WO#f:aO#g:WO#i:XO#k:ZO#m:]O#n:^O'mRO'w#_O(O#QO(P#RO~O#q,tO~P#-WOQ'pXZ'pXk'pXx'pXy'pX{'pX!c'pX!d'pX!f'pX!l'pX#_'pX#`'pX#a'pX#b'pX#c'pX#d'pX#e'pX#f'pX#i'pX#k'pX#m'pX#n'pX'm'pX'w'pX(O'pX(P'pX!T'pX~O#O:cO#s:cO#g'pX#q'pX!U'pX~P#/UO_&{a!T&{a'`&{a'[&{a!e&{ao&{a!Q&{a!V&{a%X&{a!_&{a~P!*}OQ#^iZ#^i_#^ik#^iy#^i!T#^i!c#^i!d#^i!f#^i!l#^i#_#^i#`#^i#a#^i#b#^i#c#^i#d#^i#e#^i#f#^i#g#^i#i#^i#k#^i#m#^i#n#^i'`#^i'm#^i'w#^i'[#^i!Q#^i!e#^io#^i!V#^i%X#^i!_#^i~P!DRO_#ri!T#ri'`#ri'[#ri!Q#ri!e#rio#ri!V#ri%X#ri!_#ri~P!*}O$O,wO$Q,wO~O$O,xO$Q,xO~O!_'uO#O,yO!V$UX#{$UX$O$UX$Q$UX$X$UX~O!S,zO~O!V'xO#{,|O$O'wO$Q'wO$X,}O~O!T:_O!U'oX~P#-WO!U-OO~O$X-QO~OS(WO'^(XO'_-TO~O]-WOl-WO!Q-XO~O!TdX!_dX!edX!e$kX'wdX~P!!yO!e-_O~P!DRO!T-`O!_!yO'w&vO!e(UX~O!e-eO~O!S(iO'e$iO!e(UP~O#Z-gO~O!Q$kX!T$kX!_$rX~P!!yO!T-hO!Q(VX~P!DRO!_-jO~O!Q-lO~Ok-pO!_!yO!f$bO'i$VO'w&vO~O'e-rO~O!_)jO~O_$eO!T-vO'`$eO~O!U-xO~P!&tO!Z-yO![-yO'f$kO'n(sO~O{-{O'n(sO~O!z-|O~O'e%SOe'QX!T'QX~O!T)SOe'ja~Oe.RO~Ox.SOy.SO{.TOPua(Oua(Pua!Tua#Oua~Oeua#qua~P#;dOx(]O{(^OP$da(O$da(P$da!T$da#O$da~Oe$da#q$da~P#<YOx(]O{(^OP$fa(O$fa(P$fa!T$fa#O$fa~Oe$fa#q$fa~P#<{O].UO~O#Z.VO~Oe$ta!T$ta#O$ta#q$ta~P!$SO#Z.YO~OP.cO!V&YO!q.bO%X.aO~O]#wOk#xOl#wOm#wOr$XOt$YOv:dO{$PO!V$QO!a<TO!f#|O#Y:mO#x$^O$e:gO$g:jO$j$_O'i$VO'm#yO~Oi.eO'e.dO~P#>mO!_)jO!V'ha_'ha!T'ha'`'ha~O#Z.kO~OZ[X!TdX!UdX~O!T.lO!U(^X~O!U.nO~OZ.oO~O].qO'e)rO~O!V$sO'e$iO^'YX!T'YX~O!T)wO^(]a~O!e.tO~P!*}O].vO~OZ.wO~O^.xO~OP.cO!V&YO!q.bO%X.aO'i$VO~O!T*UO_(Ya'`(Ya~O#O/PO~OP/SO!V$QO~O'n'[O!U(ZP~OP/^O!V/YO!q/]O%X/[O'i$VO~OZ/hO!T/fO!U([X~O!U/iO~O^/kO_$eO'`$eO~O]/lO~O]/mO'e)VO~O#g/nO%y/oO~P1TO#O#iO#g/nO%y/oO~O_/pO~P$zO_/rO~O&S/vOQ&QiR&QiX&Qi]&Qi_&Qib&Qic&Qii&Qik&Qil&Qim&Qir&Qit&Qiv&Qi{&Qi!O&Qi!P&Qi!V&Qi!a&Qi!f&Qi!i&Qi!j&Qi!k&Qi!l&Qi!m&Qi!p&Qi#h&Qi#x&Qi#|&Qi%W&Qi%Y&Qi%[&Qi%]&Qi%`&Qi%b&Qi%e&Qi%f&Qi%h&Qi%u&Qi%{&Qi%}&Qi&P&Qi&R&Qi&U&Qi&[&Qi&b&Qi&d&Qi&f&Qi&h&Qi&j&Qi'[&Qi'e&Qi'm&Qi'v&Qi(T&Qi!U&Qi`&Qi&X&Qi~O`/|O!U/zO&X/{O~P`O!VTO!f0OO~O&`+ROQ&ZiR&ZiX&Zi]&Zi_&Zib&Zic&Zii&Zik&Zil&Zim&Zir&Zit&Ziv&Zi{&Zi!O&Zi!P&Zi!V&Zi!a&Zi!f&Zi!i&Zi!j&Zi!k&Zi!l&Zi!m&Zi!p&Zi#h&Zi#x&Zi#|&Zi%W&Zi%Y&Zi%[&Zi%]&Zi%`&Zi%b&Zi%e&Zi%f&Zi%h&Zi%u&Zi%{&Zi%}&Zi&P&Zi&R&Zi&U&Zi&[&Zi&b&Zi&d&Zi&f&Zi&h&Zi&j&Zi'[&Zi'e&Zi'm&Zi'v&Zi(T&Zi!U&Zi&S&Zi`&Zi&X&Zi~O!Q0UO~O!T!Xa!U!Xa~P#-WO!S0]O!Y&XO!Z&QO![&QO!T&rX!U&rX~P!>vO!T+dO!U'ra~O!T&wX!U&wX~P!0bO!T+gO!U'}a~O_$eO!_!yO!f$bO!l0gO#O0eO'`$eO'i$VO'w&vO~O]%|Ol%|O{+`O'n(sO'v+kO~O_+nO!U0jO!Y+qO!Z+mO![+mO!t+uO!u+sO!v+tO!w+rO!z+vO!{+vO'v+kO~P!>vO!Z0kO![0kO'v+kO~P!>vO!Y0lO!Z0kO![0kO'v+kO~P!>vO!VTO!Y0lO!Z0kO![0kO!w0nO!z0oO!{0oO'v+kO~P!>vO!Y0lO!Z0kO![0kO!u0qO!v0qO!w0nO!z0oO!{0oO'v+kO~P!>vO!V&YO~O!V&YO~P!DRO!T#eOo$ca~O!Q&qi!T&qi~P!*}O!T&iO!Q'qi~O!T&pO!Q'{i~O!Q'|i!T'|i~P!*}O!T'yi!e'yi_'yi'`'yi~P!*}O#O0zO!T'yi!e'yi_'yi'`'yi~O!T&{O!e'xi~O{$|O!V$}O#Y0|O'e$iO~O#ZuaQuaZua_uakua!cua!dua!fua!lua#_ua#`ua#aua#bua#cua#dua#eua#fua#gua#iua#kua#mua#nua'`ua'mua'wua!eua!Qua'[ua!Vuaoua%Xua!_ua~P#;dO#Z$daQ$daZ$da_$dak$day$da!c$da!d$da!f$da!l$da#_$da#`$da#a$da#b$da#c$da#d$da#e$da#f$da#g$da#i$da#k$da#m$da#n$da'`$da'm$da'w$da!e$da!Q$da'[$da!V$dao$da%X$da!_$da~P#<YO#Z$faQ$faZ$fa_$fak$fay$fa!c$fa!d$fa!f$fa!l$fa#_$fa#`$fa#a$fa#b$fa#c$fa#d$fa#e$fa#f$fa#g$fa#i$fa#k$fa#m$fa#n$fa'`$fa'm$fa'w$fa!e$fa!Q$fa'[$fa!V$fao$fa%X$fa!_$fa~P#<{O#Z$taQ$taZ$ta_$tak$tay$ta!T$ta!c$ta!d$ta!f$ta!l$ta#_$ta#`$ta#a$ta#b$ta#c$ta#d$ta#e$ta#f$ta#g$ta#i$ta#k$ta#m$ta#n$ta'`$ta'm$ta'w$ta!e$ta!Q$ta'[$ta!V$ta#O$tao$ta%X$ta!_$ta~P!DRO_#Rq!T#Rq'`#Rq'[#Rq!Q#Rq!e#Rqo#Rq!V#Rq%X#Rq!_#Rq~P!*}Oe&sX!T&sX~PIeO!T,jOe'ta~O!S1UO!T&tX!e&tX~P$zO!T,mO!e'ua~O!T,mO!e'ua~P!*}O!Q1XO~O#q!ha!U!ha~PBWO#q!`a!T!`a!U!`a~P#-WO!V1jO#|_O$V1kO~O!U1oO~Oo1pO~P!DRO_$`q!T$`q'`$`q'[$`q!Q$`q!e$`qo$`q!V$`q%X$`q!_$`q~P!*}O!Q1qO~O]-WOl-WO~Ox(]O{(^O(P(bOP%Pi(O%Pi!T%Pi#O%Pi~Oe%Pi#q%Pi~P$4SOx(]O{(^OP%Ri(O%Ri(P%Ri!T%Ri#O%Ri~Oe%Ri#q%Ri~P$4uO'w#_O~P!DRO!S1tO'e$iO!T&|X!e&|X~O!T-`O!e(Ua~O!T-`O!_!yO!e(Ua~O!T-`O!_!yO'w&vO!e(Ua~Oe$mi!T$mi#O$mi#q$mi~P!$SO!S1|O'e(nO!Q'OX!T'OX~P!$qO!T-hO!Q(Va~O!T-hO!Q(Va~P!DRO!_!yO~O!_!yO#g2UO~Ok2XO!_!yO'w&vO~Oe'ki!T'ki~P!$SO#O2[Oe'ki!T'ki~P!$SO!e2_O~O_$aq!T$aq'`$aq'[$aq!Q$aq!e$aqo$aq!V$aq%X$aq!_$aq~P!*}O!T2cO!V(WX~P!DRO!V&YO%X2fO~O!V&YO%X2fO~P!DRO!V$kX$|[X_$kX!T$kX'`$kX~P!!yO$|2jOPhXxhX{hX!VhX(OhX(PhX_hX!ThX'`hX~O$|2jO~O]2pO%Y2qO'e)rO!T'XX!U'XX~O!T.lO!U(^a~OZ2uO~O^2vO~O]2yO~OP2{O!V&YO!q2zO%X2fO~O!Q2|O~O_$eO'`$eO~P!DRO!V$QO~P!DRO!T3RO#O3TO!U(ZX~O!U3UO~O]%|Ol%|O{3WO!Y3bO!Z3ZO![3ZO!t3aO!u3`O!v3`O!z3_O!{+vO'f$kO'n(sO'v+kO~O!U3^O~P$=fOP3iO!V/YO!q3hO%X3gO~OP3iO!V/YO!q3hO%X3gO'i$VO~O'e)VO!T'WX!U'WX~O!T/fO!U([a~O]3sO'n3rO~O]3tO~O^3vO~O!e3yO~P$zO_3{O~O_3{O~P$zO#g3}O%y4OO~PDvO`/|O!U4SO&X/{O~P`O!_4UO~O!_4WO!T'si!U'si!_'si!f'si'i'si~O!T#Wi!U#Wi~P#-WO#O4XO!T#Wi!U#Wi~O!T!Xi!U!Xi~P#-WO!Q4YO~O_$eO#O4aO'`$eO~O_$eO!_!yO#O4aO'`$eO~O!Z4eO![4eO'v+kO~P!>vO_$eO!_!yO!f$bO!l4fO#O4aO'`$eO'i$VO'w&vO~O!Y4gO!Z4eO![4eO'v+kO~P!>vO!Y4gO!Z4eO![4eO!w4jO!z4kO!{4kO'v+kO~P!>vO_$eO!_!yO!l4fO#O4aO'`$eO'w&vO~O!T'yq!e'yq_'yq'`'yq~P!*}O!T&{O!e'xq~O#Z%PiQ%PiZ%Pi_%Pik%Piy%Pi!c%Pi!d%Pi!f%Pi!l%Pi#_%Pi#`%Pi#a%Pi#b%Pi#c%Pi#d%Pi#e%Pi#f%Pi#g%Pi#i%Pi#k%Pi#m%Pi#n%Pi'`%Pi'm%Pi'w%Pi!e%Pi!Q%Pi'[%Pi!V%Pio%Pi%X%Pi!_%Pi~P$4SO#Z%RiQ%RiZ%Ri_%Rik%Riy%Ri!c%Ri!d%Ri!f%Ri!l%Ri#_%Ri#`%Ri#a%Ri#b%Ri#c%Ri#d%Ri#e%Ri#f%Ri#g%Ri#i%Ri#k%Ri#m%Ri#n%Ri'`%Ri'm%Ri'w%Ri!e%Ri!Q%Ri'[%Ri!V%Rio%Ri%X%Ri!_%Ri~P$4uO#Z$miQ$miZ$mi_$mik$miy$mi!T$mi!c$mi!d$mi!f$mi!l$mi#_$mi#`$mi#a$mi#b$mi#c$mi#d$mi#e$mi#f$mi#g$mi#i$mi#k$mi#m$mi#n$mi'`$mi'm$mi'w$mi!e$mi!Q$mi'[$mi!V$mi#O$mio$mi%X$mi!_$mi~P!DROe&sa!T&sa~P!$SO!T&ta!e&ta~P!*}O!T,mO!e'ui~O#q#Ri!T#Ri!U#Ri~P#-WOQ#aOx!}Oy#OO{#PO!d!{O!f!|O!l#aO'mROZ#^ik#^i!c#^i#`#^i#a#^i#b#^i#c#^i#d#^i#e#^i#f#^i#g#^i#i#^i#k#^i#m#^i#n#^i#q#^i'w#^i(O#^i(P#^i!T#^i!U#^i~O#_#^i~P$M]O#_:SO~P$M]OQ#aOx!}Oy#OO{#PO!d!{O!f!|O!l#aO#_:SO#`:TO#a:TO#b:TO'mROZ#^i!c#^i#c#^i#d#^i#e#^i#f#^i#g#^i#i#^i#k#^i#m#^i#n#^i#q#^i'w#^i(O#^i(P#^i!T#^i!U#^i~Ok#^i~P% hOk:UO~P% hOQ#aOk:UOx!}Oy#OO{#PO!d!{O!f!|O!l#aO#_:SO#`:TO#a:TO#b:TO#c:VO'mRO#i#^i#k#^i#m#^i#n#^i#q#^i'w#^i(O#^i(P#^i!T#^i!U#^i~OZ#^i!c#^i#d#^i#e#^i#f#^i#g#^i~P%#sOZ:bO!c:WO#d:WO#e:WO#f:aO#g:WO~P%#sOQ#aOZ:bOk:UOx!}Oy#OO{#PO!c:WO!d!{O!f!|O!l#aO#_:SO#`:TO#a:TO#b:TO#c:VO#d:WO#e:WO#f:aO#g:WO#i:XO'mRO#k#^i#m#^i#n#^i#q#^i'w#^i(P#^i!T#^i!U#^i~O(O#^i~P%&_O(O#QO~P%&_OQ#aOZ:bOk:UOx!}Oy#OO{#PO!c:WO!d!{O!f!|O!l#aO#_:SO#`:TO#a:TO#b:TO#c:VO#d:WO#e:WO#f:aO#g:WO#i:XO#k:ZO'mRO(O#QO#m#^i#n#^i#q#^i'w#^i!T#^i!U#^i~O(P#^i~P%(jO(P#RO~P%(jOQ#aOZ:bOk:UOx!}Oy#OO{#PO!c:WO!d!{O!f!|O!l#aO#_:SO#`:TO#a:TO#b:TO#c:VO#d:WO#e:WO#f:aO#g:WO#i:XO#k:ZO#m:]O'mRO(O#QO(P#RO~O#n#^i#q#^i'w#^i!T#^i!U#^i~P%*uO_#oy!T#oy'`#oy'[#oy!Q#oy!e#oyo#oy!V#oy%X#oy!_#oy~P!*}OP<dOx(]O{(^O(O(`O(P(bO~OQ#^iZ#^ik#^iy#^i!c#^i!d#^i!f#^i!l#^i#_#^i#`#^i#a#^i#b#^i#c#^i#d#^i#e#^i#f#^i#g#^i#i#^i#k#^i#m#^i#n#^i#q#^i'm#^i'w#^i!T#^i!U#^i~P%-mO#q'lX!U'lX~P!EQO#q#ri!T#ri!U#ri~P#-WO!U4|O~O!T&{a!U&{a~P#-WO!_!yO'w&vO!T&|a!e&|a~O!T-`O!e(Ui~O!T-`O!_!yO!e(Ui~Oe$mq!T$mq#O$mq#q$mq~P!$SO!Q'Oa!T'Oa~P!DRO!_5TO~O!T-hO!Q(Vi~P!DRO!T-hO!Q(Vi~O!Q5XO~O!_!yO#g5^O~Ok5_O!_!yO'w&vO~O!Q5aO~Oe$oq!T$oq#O$oq#q$oq~P!$SO_$ay!T$ay'`$ay'[$ay!Q$ay!e$ayo$ay!V$ay%X$ay!_$ay~P!*}O!T2cO!V(Wa~O!V&YO%X5fO~O!V&YO%X5fO~P!DRO_#Ry!T#Ry'`#Ry'[#Ry!Q#Ry!e#Ryo#Ry!V#Ry%X#Ry!_#Ry~P!*}OZ5iO~O]5kO'e)rO~O!T.lO!U(^i~O]5nO~O^5oO~O!_4WO~O'n'[O!T'TX!U'TX~O!T3RO!U(Za~O!f$bO'i$VO_'sX!_'sX!l'sX#O'sX'`'sX'w'sX~O'e5zO~P,OO_$eO!_!yO!l0gO#O0eO'`$eO'w&vO~O!U5}O~P$=fO]%|Ol%|O{6OO'n(sO'v+kO~O!Y6SO!Z6RO![6RO!z0oO!{0oO'v+kO~P!>vO!Y6SO!Z6RO![6RO!u6TO!v6TO!z0oO!{0oO'v+kO~P!>vO!Z6RO![6RO'f$kO'n(sO'v+kO~O!V/YO~O!V/YO%X6VO~O!V/YO%X6VO~P!DROP6[O!V/YO!q6ZO%X6VO~OZ6aO!T'Wa!U'Wa~O!T/fO!U([i~O]6dO~O!e6eO~O!e6fO~O!e6gO~O!e6gO~P$zO_6iO~O!_6lO~O!e6mO~O!T'|i!U'|i~P#-WO_$eO'`$eO~P!*}O_$eO#O6sO'`$eO~O_$eO!_!yO#O6sO'`$eO~O!Z6xO![6xO'v+kO~P!>vO_$eO!_!yO!l6yO#O6sO'`$eO'w&vO~O!f$bO'i$VO~P%=UO!Y6zO!Z6xO![6xO'v+kO~P!>vO!T'yy!e'yy_'yy'`'yy~P!*}O#Z$mqQ$mqZ$mq_$mqk$mqy$mq!T$mq!c$mq!d$mq!f$mq!l$mq#_$mq#`$mq#a$mq#b$mq#c$mq#d$mq#e$mq#f$mq#g$mq#i$mq#k$mq#m$mq#n$mq'`$mq'm$mq'w$mq!e$mq!Q$mq'[$mq!V$mq#O$mqo$mq%X$mq!_$mq~P!DRO#Z$oqQ$oqZ$oq_$oqk$oqy$oq!T$oq!c$oq!d$oq!f$oq!l$oq#_$oq#`$oq#a$oq#b$oq#c$oq#d$oq#e$oq#f$oq#g$oq#i$oq#k$oq#m$oq#n$oq'`$oq'm$oq'w$oq!e$oq!Q$oq'[$oq!V$oq#O$oqo$oq%X$oq!_$oq~P!DRO!T&ti!e&ti~P!*}O#q#Rq!T#Rq!U#Rq~P#-WOx.SOy.SO{.TOPua(Oua(Pua!Uua~OQuaZuakua!cua!dua!fua!lua#_ua#`ua#aua#bua#cua#dua#eua#fua#gua#iua#kua#mua#nua#qua'mua'wua!Tua~P%CqOx(]O{(^OP$da(O$da(P$da!U$da~OQ$daZ$dak$day$da!c$da!d$da!f$da!l$da#_$da#`$da#a$da#b$da#c$da#d$da#e$da#f$da#g$da#i$da#k$da#m$da#n$da#q$da'm$da'w$da!T$da~P%ExOx(]O{(^OP$fa(O$fa(P$fa!U$fa~OQ$faZ$fak$fay$fa!c$fa!d$fa!f$fa!l$fa#_$fa#`$fa#a$fa#b$fa#c$fa#d$fa#e$fa#f$fa#g$fa#i$fa#k$fa#m$fa#n$fa#q$fa'm$fa'w$fa!T$fa~P%HPOQ$taZ$tak$tay$ta!c$ta!d$ta!f$ta!l$ta#_$ta#`$ta#a$ta#b$ta#c$ta#d$ta#e$ta#f$ta#g$ta#i$ta#k$ta#m$ta#n$ta#q$ta'm$ta'w$ta!T$ta!U$ta~P%-mO#q$`q!T$`q!U$`q~P#-WO#q$aq!T$aq!U$aq~P#-WO!U7TO~O#q7UO~P!$SO!_!yO!T&|i!e&|i~O!_!yO'w&vO!T&|i!e&|i~O!T-`O!e(Uq~O!Q'Oi!T'Oi~P!DRO!T-hO!Q(Vq~O!Q7[O~P!DRO!Q7[O~Oe'ky!T'ky~P!$SO!T'Ra!V'Ra~P!DRO!V${q_${q!T${q'`${q~P!DROZ7cO~O!T.lO!U(^q~O]7fO~O!V&YO%X7gO~O!V&YO%X7gO~P!DRO#O7hO!T'Ta!U'Ta~O!T3RO!U(Zi~P#-WOQ[XZ[Xk[Xx[Xy[X{[X!Q[X!T[X!c[X!d[X!f[X!l[X#O[X#ZdX#_[X#`[X#a[X#b[X#c[X#d[X#e[X#f[X#g[X#i[X#k[X#m[X#n[X#s[X'm[X'w[X(O[X(P[X~O!_$yX#g$yX~P&!WO!Z7nO![7nO'f$kO'n(sO'v+kO~O!Y7qO!Z7nO![7nO!z4kO!{4kO'v+kO~P!>vO!V/YO%X7tO~O!V/YO%X7tO~P!DRO]7{O'n7zO~O!T/fO!U([q~O!e7}O~O!e7}O~P$zO!e8PO~O!e8QO~O#O8SO!T#Wy!U#Wy~O!T#Wy!U#Wy~P#-WO_$eO#O8XO'`$eO~O_$eO!_!yO#O8XO'`$eO~O!Z8[O![8[O'v+kO~P!>vO_$eO!_!yO!l8]O#O8XO'`$eO'w&vO~O#q#oy!T#oy!U#oy~P#-WOQ$miZ$mik$miy$mi!c$mi!d$mi!f$mi!l$mi#_$mi#`$mi#a$mi#b$mi#c$mi#d$mi#e$mi#f$mi#g$mi#i$mi#k$mi#m$mi#n$mi#q$mi'm$mi'w$mi!T$mi!U$mi~P%-mOx(]O{(^O(P(bOP%Pi(O%Pi!U%Pi~OQ%PiZ%Pik%Piy%Pi!c%Pi!d%Pi!f%Pi!l%Pi#_%Pi#`%Pi#a%Pi#b%Pi#c%Pi#d%Pi#e%Pi#f%Pi#g%Pi#i%Pi#k%Pi#m%Pi#n%Pi#q%Pi'm%Pi'w%Pi!T%Pi~P&*aOx(]O{(^OP%Ri(O%Ri(P%Ri!U%Ri~OQ%RiZ%Rik%Riy%Ri!c%Ri!d%Ri!f%Ri!l%Ri#_%Ri#`%Ri#a%Ri#b%Ri#c%Ri#d%Ri#e%Ri#f%Ri#g%Ri#i%Ri#k%Ri#m%Ri#n%Ri#q%Ri'm%Ri'w%Ri!T%Ri~P&,hO#q$ay!T$ay!U$ay~P#-WO#q#Ry!T#Ry!U#Ry~P#-WO!_!yO!T&|q!e&|q~O!T-`O!e(Uy~O!Q'Oq!T'Oq~P!DRO!Q8cO~P!DRO!T.lO!U(^y~O!T3RO!U(Zq~O!Z8oO![8oO'f$kO'n(sO'v+kO~O!V/YO%X8rO~O!V/YO%X8rO~P!DRO!e8uO~O_$eO#O8{O'`$eO~O_$eO!_!yO#O8{O'`$eO~OQ$mqZ$mqk$mqy$mq!c$mq!d$mq!f$mq!l$mq#_$mq#`$mq#a$mq#b$mq#c$mq#d$mq#e$mq#f$mq#g$mq#i$mq#k$mq#m$mq#n$mq#q$mq'm$mq'w$mq!T$mq!U$mq~P%-mOQ$oqZ$oqk$oqy$oq!c$oq!d$oq!f$oq!l$oq#_$oq#`$oq#a$oq#b$oq#c$oq#d$oq#e$oq#f$oq#g$oq#i$oq#k$oq#m$oq#n$oq#q$oq'm$oq'w$oq!T$oq!U$oq~P%-mOe%T!Z!T%T!Z#O%T!Z#q%T!Z~P!$SO!T'Tq!U'Tq~P#-WO!T#W!Z!U#W!Z~P#-WO_$eO#O9_O'`$eO~O#Z%T!ZQ%T!ZZ%T!Z_%T!Zk%T!Zy%T!Z!T%T!Z!c%T!Z!d%T!Z!f%T!Z!l%T!Z#_%T!Z#`%T!Z#a%T!Z#b%T!Z#c%T!Z#d%T!Z#e%T!Z#f%T!Z#g%T!Z#i%T!Z#k%T!Z#m%T!Z#n%T!Z'`%T!Z'm%T!Z'w%T!Z!e%T!Z!Q%T!Z'[%T!Z!V%T!Z#O%T!Zo%T!Z%X%T!Z!_%T!Z~P!DROP<cOx(]O{(^O(O(`O(P(bO~O]!}al!}a!U!}a!Y!}a!Z!}a![!}a!t!}a!u!}a!v!}a!z!}a!{!}a'f!}a'n!}a'v!}a~P&8rOQ%T!ZZ%T!Zk%T!Zy%T!Z!c%T!Z!d%T!Z!f%T!Z!l%T!Z#_%T!Z#`%T!Z#a%T!Z#b%T!Z#c%T!Z#d%T!Z#e%T!Z#f%T!Z#g%T!Z#i%T!Z#k%T!Z#m%T!Z#n%T!Z#q%T!Z'm%T!Z'w%T!Z!T%T!Z!U%T!Z~P%-mO]ualua!Yua!Zua![ua!tua!uua!vua!zua!{ua'fua'nua'vua~P%CqO]$dal$da!Y$da!Z$da![$da!t$da!u$da!v$da!z$da!{$da'f$da'n$da'v$da~P%ExO]$fal$fa!Y$fa!Z$fa![$fa!t$fa!u$fa!v$fa!z$fa!{$fa'f$fa'n$fa'v$fa~P%HPO]$tal$ta!U$ta!Y$ta!Z$ta![$ta!t$ta!u$ta!v$ta!z$ta!{$ta'f$ta'n$ta'v$ta~P&8rO]%Pil%Pi!Y%Pi!Z%Pi![%Pi!t%Pi!u%Pi!v%Pi!z%Pi!{%Pi'f%Pi'n%Pi'v%Pi~P&*aO]%Ril%Ri!Y%Ri!Z%Ri![%Ri!t%Ri!u%Ri!v%Ri!z%Ri!{%Ri'f%Ri'n%Ri'v%Ri~P&,hO]$mil$mi!U$mi!Y$mi!Z$mi![$mi!t$mi!u$mi!v$mi!z$mi!{$mi'f$mi'n$mi'v$mi~P&8rO]$mql$mq!U$mq!Y$mq!Z$mq![$mq!t$mq!u$mq!v$mq!z$mq!{$mq'f$mq'n$mq'v$mq~P&8rO]$oql$oq!U$oq!Y$oq!Z$oq![$oq!t$oq!u$oq!v$oq!z$oq!{$oq'f$oq'n$oq'v$oq~P&8rO]%T!Zl%T!Z!U%T!Z!Y%T!Z!Z%T!Z![%T!Z!t%T!Z!u%T!Z!v%T!Z!z%T!Z!{%T!Z'f%T!Z'n%T!Z'v%T!Z~P&8rOo'oX~P.mO!QdX!TdX#OdX~P&!WOQ[XZ[Xk[Xx[Xy[X{[X!T[X!TdX!c[X!d[X!f[X!l[X#O[X#OdX#ZdX#_[X#`[X#a[X#b[X#c[X#d[X#e[X#f[X#g[X#i[X#k[X#m[X#n[X#s[X'm[X'w[X(O[X(P[X~O!_dX!e[X!edX'wdX~P&FOOQ9{OR9{O]dOb<OOc!]OidOk9{OldOmdOrdOt9{Ov9{O{SO!OdO!PdO!VTO!a9}O!fVO!i9{O!j9{O!k9{O!l9{O!m9{O!p![O#x!_O#|_O'e'lO'mRO'vZO(T;|O~O]#wOi$WOk#xOl#wOm#wOr$XOt$YOv:eO{$PO!V$QO!a<UO!f#|O#Y:nO#x$^O$e:hO$g:kO$j$_O'e'SO'i$VO'm#yO~O!T:_O!U$ca~O]#wOi$WOk#xOl#wOm#wOr$XOt$YOv:fO{$PO!V$QO!a<VO!f#|O#Y:oO#x$^O$e:iO$g:lO$j$_O'e'SO'i$VO'm#yO~O#h'sO~P&LRO!U[X!UdX~P&FOO!_:RO~O#Z:QO~O!_!yO#Z:QO~O#O:cO~O#g:WO~O#O:pO!T'|X!U'|X~O#O:cO!T'zX!U'zX~O#Z:qO~Oe:sO~P!$SO#Z:zO~O#Z:{O~O#Z:|O~O!_!yO#Z:}O~O!_!yO#Z:qO~O#q;OO~P#-WO#Z;PO~O#Z;QO~O#Z;RO~O#Z;SO~O#Z;TO~O#Z;UO~O#Z;VO~O#Z;WO~O!Q;XO~O#q;YO~P!$SO#q;ZO~P!$SO#q;[O~P!$SO!Q;]O~P!DRO!Q;]O~O!Q;^O~P!DRO!_!yO#g<[O~O!_!yO#g<^O~O#|~!d!t!v!w!z#X#Y#f(T$e$g$j$|%W%X%Y%`%b%e%f%h%j~UT#|(Tlx#`!P'b'c'n'c'e$O$Q~",
    goto: "$ }(bPPPPPPPP(cP(sP*gPPPP.YPP.oP4Z8[8oP8oPPP8oP:s8oP8oP8oP:wPP:}P;d?}PPP@RPPPP@RBzPPPCQDoP@RPGSPPPPH{@RPPPPPJy@RPPNR! OPPPP! S!!lPP!!t!#vP! O@R@R!'X!*Z!/W!/W!2oPPP!2v!5s@RPPPPPPPPPPP!8rP!:UPP@R!;dP@RP@R@R@R@RP@R!<zPP!?zP!BvP!Bz!CS!CW!CWP!?wP!C[!C[P!FWP!F[@R@R!Fb!I]8oP8oP8o8oP!Jf8o8o!Lt8o# o8o##w8o8o#$e#&u#&u#&y#'R#&u#'_P#&uP8o#(Z8o#)w8o8o.YPPP#+iPP#,R#,RP#,RP#,h#,RPP#,nP#,eP#,e#-Q!!p#,e#-o#-u#-x(c#-{(cP#.S#.S#.SP(cP(cP(cP(cPP(cP#.Y#.]P#.](cP#.aP#.dP(cP(cP(cP(cP(cP(c(cP#.j#.t#.z#/Q#/`#/f#/l#/v#/|#0]#0c#0q#0w#0}#1]#1r#3j#3x#4O#4U#4[#4b#4l#4r#4x#5S#5f#5lPPPPPPPP#5rPP#6f#9oP#;V#;^#;fPP#AS#Cu#Iz#I}#JQ#Kb#KePP#Kh#Kl#LZ#MT#MX#MmPP#Mq#Mw#M{P#NO#NS#NV#Nu$ ]$ b$ e$ h$ n$ q$ u$ ymiOTk!O!p$d%j%m%n%p*y+O/v/yQ$pnQ$wqQ%bzS&Q!Y+dQ&a!]S(u$Q(zQ)p$qQ)}$yQ*j%[Q+j&XS+m&Y+oQ,P&bQ-y(|Q/e*kY0k+q+r+s+t+uS3Z/Y3]U4e0l0n0qU6R3`3a3bS6x4g4jS7n6S6TQ8[6zR8o7q$|]OPSTUVkl!O!T!`!d!g!p!x!|#P#S#T#U#V#W#X#Y#Z#[#]#^#e#i$d$u%c%f%j%l%m%n%p%t%}&[&g&i&o&w'U'Y'^([)`)g*T*u*y+O+`+z,U,[,m,t.T.Y.b.k/]/n/o/p/r/v/y/{0e0z1U2z3W3h3{3}4O4a6O6Z6i6s8X8{9_!l'n#`#q&R(Q+[+_,z0]1j3T4X7h8S9{9}:Q:S:T:U:V:W:X:Y:Z:[:]:^:_:c:p:q:s:};O;V;W<PQ)W$ZQ)u$sQ*l%_Q*s%gQ,d:dQ.f)jQ.q)vQ/m*qQ2p.lQ3p/fQ4u:fQ5k2qR9j:epfOTkz!O!p$d%a%j%m%n%p*y+O/v/yR*n%c&fWOPTUklo!O!T!^!`!p!x!|#P#S#T#U#V#W#X#Y#Z#[#]#^#`#e#i#q$d$u%c%f%g%j%l%m%n%p%t%}&[&i&o&w'U'Y'^(Q([)`)g*T*u*y+O+[+_+`+z,U,[,m,t,z.T.Y.b.k/]/n/o/p/r/v/y/{0]0e0z1U1j2z3T3W3h3{3}4O4X4a6O6Z6i6s7h8S8X8{9_9{9}:Q:S:T:U:V:W:X:Y:Z:[:]:^:_:c:p:q:s:};O;V;W<O<P[!iSV!d!g&R&gQ$jmQ$onS$tq$yx%Ost!t!w$b$|&p&{'O*R*S*U*w+],Y,_,a0O0|4WQ%WxQ&^![Q&`!]S(h#|(lS)o$p$qQ)s$sQ*Q${Q*e%YQ*i%[S,O&a&bQ-d(iQ.j)pQ.p)vQ.r)wQ.u){Q/`*fS/d*j*kQ0x,PQ1s-`Q2o.lQ2s.oQ2x.wQ3o/eQ5Q1tQ5j2qQ5m2uQ7b5iR8f7cx$Ob!{$[$]$a(a(c(k)Q)R,j-g.V1r2[7U;|<X<Y<Z!Y$mn!]$o$p$q&P&`&a&b(t)o)p+a+l,O,P-q.j0b0h0m0x2W4d4i6v8Y8|Q)i$jQ*Z%TQ*^%UQ*h%[Q.y*QQ/_*eU/c*i*j*kQ3j/`S3n/d/eS5y3V3YQ6`3oU7l5{6P6QU8m7m7o7pQ9U8nQ9d9V#^<Q!y#g#h#|$P&](W(d(q)f)h)j*Y*]+{-h-j.a.c/P/S/[/^1|2U2c2f2j2{3g3i5T5^5f6V6[7g7t8r:g:j:m:t:w:z;P;S;Y<[<^<b<c<dd<R:R:h:k:n:u:x:{;Q;T;Zg<S:a:b:i:l:o:v:y:|;R;U;[W$Tb$V)S;|S%Tu%aQ%UvQ%VwR*X%R%T$Sb!y!{#g#h#|$P$[$]$a&](W(a(c(d(k(q)Q)R)f)h)j*Y*]+{,j-g-h-j.V.a.c/P/S/[/^1r1|2U2[2c2f2j2{3g3i5T5^5f6V6[7U7g7t8r:R:a:b:g:h:i:j:k:l:m:n:o:t:u:v:w:x:y:z:{:|;P;Q;R;S;T;U;Y;Z;[;|<X<Y<Z<[<^<b<c<dT(X#y(YX)X$Z:d:e:fU&U!Y$}+gS']!}#OQ)z$vQ/T*_Q2].SR5u3R&ldOPSTUVkl!O!T!`!d!g!p!x!|#P#S#T#U#V#W#X#Y#Z#[#]#^#`#e#i#q$d$u%c%f%g%j%l%m%n%p%t%}&R&[&g&i&o&w'U'Y'^(Q([)`)g*T*u*y+O+[+_+`+z,U,[,m,t,z.T.Y.b.k/]/n/o/p/r/v/y/{0]0e0z1U1j2z3T3W3h3{3}4O4X4a6O6Z6i6s7h8S8X8{9_9{9}:Q:S:T:U:V:W:X:Y:Z:[:]:^:_:c:p:q:s:};O;V;W<P$_#d[!f!q$h&f&l'Q'X'a'b'c'd'e'f'g'h'i'j'k'm'p't(O)y+b,S,X,Z,i,o,s,u-U.W0V0Y0y1T1Y1Z1[1]1^1_1`1a1b1c1d1e1f1i1n2a2m4[4_4o4s4t4y4z5w6o6r6}7R7S8U8i8v8y9]9h9|;lT!aR!b&mdOPSTUVkl!O!T!`!d!g!p!x!|#P#S#T#U#V#W#X#Y#Z#[#]#^#`#e#i#q$d$u%c%f%g%j%l%m%n%p%t%}&R&[&g&i&o&w'U'Y'^(Q([)`)g*T*u*y+O+[+_+`+z,U,[,m,t,z.T.Y.b.k/]/n/o/p/r/v/y/{0]0e0z1U1j2z3T3W3h3{3}4O4X4a6O6Z6i6s7h8S8X8{9_9{9}:Q:S:T:U:V:W:X:Y:Z:[:]:^:_:c:p:q:s:};O;V;W<PQ&S!YR0^+d!W%|!Y&Q&X&Y+d+j+m+o+q+r+s+t+u+v0k0l0n0o0q3_4e4g4j4k6x6z8[S(t$Q(zS-q(u(|Q-z(}Q/V*aQ2W-yQ2Z-|S3V/Y3]S5{3Z3bS6P3`3aS7m6R6SQ7o6TS8n7n7qR9V8oliOTk!O!p$d%j%m%n%p*y+O/v/yQ%r!RS'P!x:QQ)m$nQ*c%WQ*d%XQ+|&_S,h'U:qS.X)`:}Q.h)nQ/X*bQ/}+QQ0P+RQ0X+^Q0p+sQ0v+}S2b.Y;VQ2k.iS2n.k;WQ4Z0[Q4^0cQ4m0wQ5h2lQ6p4]Q6t4cQ6|4nQ8R6mQ8V6uQ8x8WQ9[8zR9g9^$Y#c[!f!q&f&l'Q'X'a'b'c'd'e'f'g'h'i'j'k'm'p't(O)y+b,S,X,Z,i,o,s-U.W0V0Y0y1T1Y1Z1[1]1^1_1`1a1b1c1d1e1f1i1n2a2m4[4_4o4s4t4y4z5w6o6r6}7R7S8U8i8v8y9]9h9|;lU)P$R'T1hT)d$h,u$Y#b[!f!q&f&l'Q'X'a'b'c'd'e'f'g'h'i'j'k'm'p't(O)y+b,S,X,Z,i,o,s-U.W0V0Y0y1T1Y1Z1[1]1^1_1`1a1b1c1d1e1f1i1n2a2m4[4_4o4s4t4y4z5w6o6r6}7R7S8U8i8v8y9]9h9|;lS'_#O#cS)c$h,uQ,v'oR.Z)d&ldOPSTUVkl!O!T!`!d!g!p!x!|#P#S#T#U#V#W#X#Y#Z#[#]#^#`#e#i#q$d$u%c%f%g%j%l%m%n%p%t%}&R&[&g&i&o&w'U'Y'^(Q([)`)g*T*u*y+O+[+_+`+z,U,[,m,t,z.T.Y.b.k/]/n/o/p/r/v/y/{0]0e0z1U1j2z3T3W3h3{3}4O4X4a6O6Z6i6s7h8S8X8{9_9{9}:Q:S:T:U:V:W:X:Y:Z:[:]:^:_:c:p:q:s:};O;V;W<PQ%m|Q%n}Q%p!PQ%q!QR/u*|Q&Z![Q)e$jQ+y&^S.`)i*QS0s+w+xW2e.].^._.yS4l0t0uU5e2g2h2iU7`5d5q5rQ8e7aR9Q8hT+n&Y+oS+l&Y+oU0h+m+q+rU0m+s+t+uS0r+v3_S3Y/Y3]U4d0k0l0nQ4h0oQ4i0qS5{3Z3bS6Q3`3aU6v4e4g4jQ6{4kS7m6R6SQ7p6TS8Y6x6zS8n7n7qQ8|8[R9V8oS+n&Y+oT3[/Y3]S&y!s/sQ-c(hQ-o(tU0g+l3X3YQ1x-dS2R-p-zU4f0m0r6QQ5P1sS5[2X2ZU6y4h4i7pQ7W5QQ7_5_R8]6{Q!zYS&x!s/sQ)a$cQ)k$lQ)q$rQ,]&yQ-b(hQ-n(tQ-t(wQ.g)lQ/a*gU0f+l3X3YS1w-c-dS2Q-o-zQ2T-sQ2V-uQ3l/bW4b0g0m0r6QQ5O1sQ5S1xS5W2R2ZQ5]2YQ6^3mW6w4f4h4i7pS7V5P5QS7Z5X;XQ7]5[Q7j5xQ7x6_S8Z6y6{Q8a7WS8b7[;]Q8d7_Q8k7kQ8t7yQ8}8]S9P8c;^Q9S8lQ9b9TQ9o9cQ9v9pQ;e;`Q;s;jQ;t;kQ;u<WR;z<]%OXOPSTUVkl!O!T!`!d!g!p!x!|#P#S#T#U#V#W#X#Y#Z#[#]#^#e#i$d$u%c%f%g%j%l%m%n%p%t%}&[&g&i&o&w'U'Y'^([)`)g*T*u*y+O+`+z,U,[,m,t.T.Y.b.k/]/n/o/p/r/v/y/{0e0z1U2z3W3h3{3}4O4a6O6Z6i6s8X8{9_S!zo!^!l;_#`#q&R(Q+[+_,z0]1j3T4X7h8S9{9}:Q:S:T:U:V:W:X:Y:Z:[:]:^:_:c:p:q:s:};O;V;W<PR;e<O%OYOPSTUVkl!O!T!`!d!g!p!x!|#P#S#T#U#V#W#X#Y#Z#[#]#^#e#i$d$u%c%f%g%j%l%m%n%p%t%}&[&g&i&o&w'U'Y'^([)`)g*T*u*y+O+`+z,U,[,m,t.T.Y.b.k/]/n/o/p/r/v/y/{0e0z1U2z3W3h3{3}4O4a6O6Z6i6s8X8{9_Q$cc!Y$ln!]$o$p$q&P&`&a&b(t)o)p+a+l,O,P-q.j0b0h0m0x2W4d4i6v8Y8|S$ro!^Q)l$mQ*g%[W/b*h*i*j*kU3m/c/d/eS5x3V3YS6_3n3oW7k5y5{6P6QQ7y6`W8l7l7m7o7pS9T8m8nS9c9U9VQ9p9d!l;`#`#q&R(Q+[+_,z0]1j3T4X7h8S9{9}:Q:S:T:U:V:W:X:Y:Z:[:]:^:_:c:p:q:s:};O;V;W<PQ;j;}R;k<O$r^OPTUkl!O!T!`!p!x!|#P#S#T#U#V#W#X#Y#Z#[#]#^#e#i$d$u%c%f%j%l%m%n%p%t%}&[&i&o&w'U'Y'^([)`)g*T*u*y+O+`+z,U,[,m,t.T.Y.b.k/]/n/o/p/r/v/y/{0e0z1U2z3W3h3{3}4O4a6O6Z6i6s8X8{9_Y!nSV!d!g&gx%Ost!t!w$b$|&p&{'O*R*S*U*w+],Y,_,a0O0|4WQ*t%g!j;a#`#q(Q+[+_,z0]1j3T4X7h8S9{9}:Q:S:T:U:V:W:X:Y:Z:[:]:^:_:c:p:q:s:};O;V;W<PR;d&RS&V!Y$}R0`+g$|]OPSTUVkl!O!T!`!d!g!p!x!|#P#S#T#U#V#W#X#Y#Z#[#]#^#e#i$d$u%c%f%j%l%m%n%p%t%}&[&g&i&o&w'U'Y'^([)`)g*T*u*y+O+`+z,U,[,m,t.T.Y.b.k/]/n/o/p/r/v/y/{0e0z1U2z3W3h3{3}4O4a6O6Z6i6s8X8{9_!l'n#`#q&R(Q+[+_,z0]1j3T4X7h8S9{9}:Q:S:T:U:V:W:X:Y:Z:[:]:^:_:c:p:q:s:};O;V;W<PR*s%g%OpOPSTUVkl!O!T!`!d!g!p!x!|#P#S#T#U#V#W#X#Y#Z#[#]#^#e#i$d$u%c%f%g%j%l%m%n%p%t%}&[&g&i&o&w'U'Y'^([)`)g*T*u*y+O+`+z,U,[,m,t.T.Y.b.k/]/n/o/p/r/v/y/{0e0z1U2z3W3h3{3}4O4a6O6Z6i6s8X8{9_S']!}#O!m;b#`#q&R(Q+[+_,z0]1j3T4X7h8S9{9}:Q:S:T:U:V:W:X:Y:Z:[:]:^:_:c:p:q:s:};O;V;W<P!h#Y[!f$h&f&l'Q'X'h'i'j'k'p't)y,S,X,Z,i,o-U.W0y1T1f2a2m4_4o4s6r8U8y9]9h9|!T:Y'm(O+b,u0V0Y1Y1b1c1d1e1i1n4[4t4y4z5w6o6}7R7S8i8v;l!d#[[!f$h&f&l'Q'X'j'k'p't)y,S,X,Z,i,o-U.W0y1T1f2a2m4_4o4s6r8U8y9]9h9|!P:['m(O+b,u0V0Y1Y1d1e1i1n4[4t4y4z5w6o6}7R7S8i8v;l!`#`[!f$h&f&l'Q'X'p't)y,S,X,Z,i,o-U.W0y1T1f2a2m4_4o4s6r8U8y9]9h9|Q1r-^z<P'm(O+b,u0V0Y1Y1i1n4[4t4y4z5w6o6}7R7S8i8v;lQ<X<_Q<Y<`R<Z<a&ldOPSTUVkl!O!T!`!d!g!p!x!|#P#S#T#U#V#W#X#Y#Z#[#]#^#`#e#i#q$d$u%c%f%g%j%l%m%n%p%t%}&R&[&g&i&o&w'U'Y'^(Q([)`)g*T*u*y+O+[+_+`+z,U,[,m,t,z.T.Y.b.k/]/n/o/p/r/v/y/{0]0e0z1U1j2z3T3W3h3{3}4O4X4a6O6Z6i6s7h8S8X8{9_9{9}:Q:S:T:U:V:W:X:Y:Z:[:]:^:_:c:p:q:s:};O;V;W<PS#ra#sR1k,y&s`OPSTUVakl!O!T!`!d!g!p!x!|#P#S#T#U#V#W#X#Y#Z#[#]#^#`#e#i#q#s$d$u%c%f%g%j%l%m%n%p%t%}&R&[&g&i&o&w'U'Y'^(Q([)`)g*T*u*y+O+[+_+`+z,U,[,m,t,y,z.T.Y.b.k/]/n/o/p/r/v/y/{0]0e0z1U1j2z3T3W3h3{3}4O4X4a6O6Z6i6s7h8S8X8{9_9{9}:Q:S:T:U:V:W:X:Y:Z:[:]:^:_:c:p:q:s:};O;V;W<PT#n_#tS#l_#tT'w#o'{T#m_#tT'y#o'{&saOPSTUVakl!O!T!`!d!g!p!x!|#P#S#T#U#V#W#X#Y#Z#[#]#^#`#e#i#q#s$d$u%c%f%g%j%l%m%n%p%t%}&R&[&g&i&o&w'U'Y'^(Q([)`)g*T*u*y+O+[+_+`+z,U,[,m,t,y,z.T.Y.b.k/]/n/o/p/r/v/y/{0]0e0z1U1j2z3T3W3h3{3}4O4X4a6O6Z6i6s7h8S8X8{9_9{9}:Q:S:T:U:V:W:X:Y:Z:[:]:^:_:c:p:q:s:};O;V;W<PT#ra#sQ#uaR(S#s%OcOPSTUVkl!O!T!`!d!g!p!x!|#P#S#T#U#V#W#X#Y#Z#[#]#^#e#i$d$u%c%f%g%j%l%m%n%p%t%}&[&g&i&o&w'U'Y'^([)`)g*T*u*y+O+`+z,U,[,m,t.T.Y.b.k/]/n/o/p/r/v/y/{0e0z1U2z3W3h3{3}4O4a6O6Z6i6s8X8{9_!m;}#`#q&R(Q+[+_,z0]1j3T4X7h8S9{9}:Q:S:T:U:V:W:X:Y:Z:[:]:^:_:c:p:q:s:};O;V;W<P#_eOPTVk!O!T!`!p#P#q$d%c%f%g%j%l%m%n%p%t%}&['^(Q)g*T*u*y+O+`+z,z.T.b/]/n/o/p/r/v/y/{1j2z3W3h3{3}4O6O6Z6i!^$Rb!{$[$]$a(a(c(k)Q)R,j-g.V1r2[7U:R:h:k:n:u:x:{;Q;T;Z;|<X<Y<Z#^'T!y#g#h#|$P&](W(d(q)f)h)j*Y*]+{-h-j.a.c/P/S/[/^1|2U2c2f2j2{3g3i5T5^5f6V6[7g7t8r:g:j:m:t:w:z;P;S;Y<[<^<b<c<dQ)]$_Q-V(]g1h:a:b:i:l:o:v:y:|;R;U;[x#}b!{$[$]$a(a(c(k)Q)R,j-g.V1r2[7U;|<X<Y<ZQ(m$OS(w$Q(zQ)^$`Q-u(x#^;g!y#g#h#|$P&](W(d(q)f)h)j*Y*]+{-h-j.a.c/P/S/[/^1|2U2c2f2j2{3g3i5T5^5f6V6[7g7t8r:g:j:m:t:w:z;P;S;Y<[<^<b<c<dd;h:R:h:k:n:u:x:{;Q;T;Zf;i:a:b:i:l:o:v:y:|;R;U;[Q;m<QQ;n<RQ;o<SQ;p<TQ;q<UR;r<V!^$Rb!{$[$]$a(a(c(k)Q)R,j-g.V1r2[7U:R:h:k:n:u:x:{;Q;T;Z;|<X<Y<Z#^'T!y#g#h#|$P&](W(d(q)f)h)j*Y*]+{-h-j.a.c/P/S/[/^1|2U2c2f2j2{3g3i5T5^5f6V6[7g7t8r:g:j:m:t:w:z;P;S;Y<[<^<b<c<dg1h:a:b:i:l:o:v:y:|;R;U;[lgOTk!O!p$d%j%m%n%p*y+O/v/yQ(p$PQ+X%wQ+Y%yR1{-h%S$Sb!y!{#g#h#|$P$[$]$a&](W(a(c(d(k(q)Q)R)f)h)j*Y*]+{,j-g-h-j.V.a.c/P/S/[/^1r1|2U2[2c2f2j2{3g3i5T5^5f6V6[7U7g7t8r:R:a:b:g:h:i:j:k:l:m:n:o:t:u:v:w:x:y:z:{:|;P;Q;R;S;T;U;Y;Z;[;|<X<Y<Z<[<^<b<c<dQ*[%UQ/R*^Q3P/QR5t3QT(y$Q(zS(y$Q(zT3[/Y3]Q-s(vQ2Y-{Q<W3WR<]6OQ)k$lQ-t(wQ.g)lQ/a*gQ3l/bQ6^3mQ7j5xQ7x6_Q8k7kQ8t7yQ9S8lQ9b9TQ9o9cR9v9pp(a#z'V)_-f-}.O1R1y2`4}5`8`;f;v;w;x!n:t'R'r(g(o+x,g-R-^-k.[._/O/Q0u1Q1z2O2i3O3Q3e4q4r5U5Y5b5g5r6Y7Y7^7v9O;y;{<_<`<a[:u9`9m9t9w9x9z]:v1g4x7O8^8_9ir(c#z'V)_-[-f-}.O1R1y2`4}5`8`;f;v;w;x!p:w'R'r(g(o+x,g-R-^-k.[._/O/Q0u1O1Q1z2O2i3O3Q3e4q4r5U5Y5b5g5r6Y7Y7^7v9O;y;{<_<`<a^:x9`9m9r9t9w9x9z_:y1g4x7O7P8^8_9ipfOTkz!O!p$d%a%j%m%n%p*y+O/v/yQ%^yR*u%gpfOTkz!O!p$d%a%j%m%n%p*y+O/v/yR%^yQ*`%VR.}*XqfOTkz!O!p$d%a%j%m%n%p*y+O/v/yQ/Z*eS3f/_/`W6U3c3d3e3jU7s6W6X6YU8p7r7u7vQ9W8qR9e9XQ%ezR*o%aR3s/hR7{6aS$tq$yR.r)wQ%j{R*y%kR+P%qT/w+O/yR+T%rQ+S%rR0Q+TQkOQ!pTT$gk!pQ(Y#yR-S(YQ!bRR&d!bQ!eSU&j!e&k,VQ&k!fR,V&lQ+e&SR0_+eQ,k'VR1S,kQ,n'XS1V,n1WR1W,oQ+o&YR0i+oS!kS$|U&q!k&r,WQ&r!lR,W&mQ+h&VR0a+hQ&|!uQ,^&zU,b&|,^0}R0},cQ'{#oR,{'{Q#saR(R#sQ#f[U'q#f,R:`Q,R9|R:`(OQ-a(hW1u-a1v5R7XU1v-b-c-dS5R1w1xR7X5S$k(_#z'R'V'r(g(o)Y)Z)_+x,e,f,g-R-[-]-^-f-k-}.O.[._/O/Q0u1O1P1Q1R1g1y1z2O2`2i3O3Q3e4q4r4v4w4x4}5U5Y5`5b5g5r6Y7O7P7Q7Y7^7v8^8_8`9O9`9i9k9l9m9r9s9t9w9x9z;f;v;w;x;y;{<_<`<aQ-i(oU1}-i2P5VQ2P-kR5V2OQ(z$QR-w(zQ)T$UR.Q)TQ2d.[R5c2dQ*V%PR.|*VQ3S/TS5v3S7iR7i5wQ*b%WR/W*bQ3]/YR5|3]Q/g*lS3q/g6bR6b3sQ.m)sW2r.m2t5l7dQ2t.pQ5l2sR7d5mQ)x$tR.s)xQ/y+OR4R/yWjOTk!pQ%o!OQ)b$dQ*x%jQ*z%mQ*{%nQ*}%pQ/t*yS/w+O/yR4Q/vQ$fhQ%s!SQ%v!UQ%x!VQ%z!WQ*P$zQ*W%QQ*n%eQ+V%uQ-v(yS/j*o*rQ0R+UQ0S+XQ0T+YU0d+l3X3YQ2w.vQ2}/OQ3k/aQ3u/lQ4P/uY4`0f0g0m0r6QQ5p2yQ5s3OQ6]3lQ6c3t[6q4_4b4f4h4i7pQ7e5nQ7w6^Q7|6dW8T6r6w6y6{Q8g7fQ8j7jQ8s7xU8w8U8Z8]Q9R8kQ9Y8tS9Z8y8}Q9a9SQ9f9]Q9n9bQ9q9hQ9u9oR9y9vQ$nnQ&_!]U)n$o$p$qQ+^&PU+}&`&a&bQ-m(tS.i)o)pQ0[+aQ0c+lS0w,O,PQ2S-qQ2l.jQ4]0bS4c0h0mQ4n0xQ5Z2WS6u4d4iQ8W6vQ8z8YR9^8|S#{b;|R)U$VU$Ub$V;|R.P)SQ#zbS'R!y)jQ'V!{S'r#g#hQ(g#|Q(o$PQ)Y$[Q)Z$]Q)_$aQ+x&]Q,e:gQ,f:jQ,g:mQ-R(WQ-[(aQ-](cQ-^(dQ-f(kQ-k(qQ-})QQ.O)Rd.[)f.a/[2f3g5f6V7g7t8rQ._)hQ/O*YQ/Q*]Q0u+{Q1O:tQ1P:wQ1Q:zQ1R,jS1g:a:bQ1y-gQ1z-hQ2O-jQ2`.VQ2i.cQ3O/PQ3Q/SQ3e/^Q4q;PQ4r;SQ4v:iQ4w:lQ4x:oQ4}1rQ5U1|Q5Y2UQ5`2[Q5b2cQ5g2jQ5r2{Q6Y3iQ7O:|Q7P:vQ7Q:yQ7Y5TQ7^5^Q7v6[Q8^;RQ8_;UQ8`7UQ9O;YQ9`:RQ9i;[Q9k:hQ9l:kQ9m:nQ9r:uQ9s:xQ9t:{Q9w;QQ9x;TQ9z;ZQ;f;|Q;v<XQ;w<YQ;x<ZQ;y<[Q;{<^Q<_<bQ<`<cR<a<dlhOTk!O!p$d%j%m%n%p*y+O/v/yQ!ZPS!rV%lQ%u!TQ&c!`Q'`#PQ(P#qS*r%c%fQ*v%gQ+U%tQ+Z%}Q+w&[Q,q'^Q-P(QQ.^)gQ.z*TQ/q*uU0Z+`3W6OQ0t+zQ1m,zQ2^.TQ2h.bQ3d/]Q3w/nQ3x/oQ3z/pQ3|/rQ4T/{Q4{1jQ5q2zQ6X3hQ6h3{Q6j3}Q6k4OQ7u6ZR8O6i#S[OPTVk!O!T!p#P$d%c%f%g%j%l%m%n%p%t%}&['^)g*T*u*y+O+`+z.T.b/]/n/o/p/r/v/y/{2z3W3h3{3}4O6O6Z6iQ!fSQ!qUQ$hlS&f!d&iQ&l!gQ'Q!xQ'X!|Q'a#SQ'b#TQ'c#UQ'd#VQ'e#WQ'f#XQ'g#YQ'h#ZQ'i#[Q'j#]Q'k#^Q'm#`Q'p#eQ't#iW(O#q(Q,z1jQ)y$uS+b&R0]S,S&g,UQ,X&oQ,Z&wQ,i'UQ,o'YQ,s9{Q,u9}Q-U([Q.W)`Q0V+[Q0Y+_Q0y,[Q1T,mQ1Y:QQ1Z:SQ1[:TQ1]:UQ1^:VQ1_:WQ1`:XQ1a:YQ1b:ZQ1c:[Q1d:]Q1e:^Q1f,tQ1i:cQ1n:_Q2a.YQ2m.kQ4[:pQ4_0eQ4o0zQ4s1UQ4t:qQ4y:sQ4z:}Q5w3TQ6o4XQ6r4aQ6};OQ7R;VQ7S;WQ8U6sQ8i7hQ8v8SQ8y8XQ9]8{Q9h9_Q9|!`R;l<PR!hSR&T!YS&P!Y+dS+a&Q&XS+l&Y+oQ0b+jU0h+m+q+rU0m+s+t+uW0r+v3_3`3aS3X/Y3]U4d0k0l0nS4h0o6TQ4i0qU6v4e4g4jQ6{4kS8Y6x6zR8|8[R'W!{R'Z!|T!vV$bS!uV$bU%Pst*wS&z!t!wQ,`&{Q,c'OQ.{*US0{,_,aR4p0|`!jS!d!g$|&g&p*R,Yh!sVst!t!w$b&{'O*U,_,a0|Q/s*wQ0W+]Q4V0OQ6n4WT;c&R*ST!mS$|S!lS$|S&h!d&pS&m!g*RS+c&R*ST,T&g,YT&W!Y$}Q#o_R(U#tT'z#o'{R1l,yT(j#|(lR(r$PQ.])fQ2g.aQ3c/[Q5d2fQ6W3gQ7a5fQ7r6VQ8h7gQ8q7tR9X8rliOTk!O!p$d%j%m%n%p*y+O/v/yQ%dzR*n%aV%Qst*wR/U*_R*m%_Q$xqR*O$yR)t$sT%h{%kT%i{%kT/x+O/y",
    nodeNames: "\u26A0 extends ArithOp ArithOp InterpolationStart LineComment BlockComment Script ExportDeclaration export Star as VariableName String from ; default FunctionDeclaration async function VariableDefinition > TypeParamList TypeDefinition ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression await yield delete LogicOp BitOp ParenthesizedExpression ClassExpression class extends ClassBody MethodDeclaration Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression PrivatePropertyName BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody MethodDeclaration AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression",
    maxTerm: 339,
    context: trackNewline,
    nodeProps: [
      ["closedBy", 4, "InterpolationEnd", 43, "]", 53, "}", 68, ")", 136, "JSXSelfCloseEndTag JSXEndTag", 152, "JSXEndTag"],
      ["group", -26, 8, 15, 17, 60, 191, 195, 198, 199, 201, 204, 207, 218, 220, 226, 228, 230, 232, 235, 241, 247, 249, 251, 253, 255, 257, 258, "Statement", -30, 12, 13, 25, 28, 29, 34, 44, 46, 47, 49, 54, 62, 70, 76, 77, 94, 95, 104, 106, 123, 126, 128, 129, 130, 131, 133, 134, 154, 155, 157, "Expression", -23, 24, 26, 30, 33, 35, 37, 158, 160, 162, 163, 165, 166, 167, 169, 170, 171, 173, 174, 175, 185, 187, 189, 190, "Type", -3, 81, 87, 93, "ClassItem"],
      ["openedBy", 31, "InterpolationStart", 48, "[", 52, "{", 67, "(", 135, "JSXStartTag", 147, "JSXStartTag JSXStartCloseTag"]
    ],
    propSources: [jsHighlight],
    skippedNodes: [0, 5, 6],
    repeatNodeCount: 28,
    tokenData: "#2T~R!bOX%ZXY%uYZ'kZ[%u[]%Z]^'k^p%Zpq%uqr(Rrs)mst7]tu9guv<avw=bwx>lxyJcyzJyz{Ka{|Lm|}MW}!OLm!O!PMn!P!Q!$v!Q!R!Er!R![!G_![!]!Nc!]!^!N{!^!_# c!_!`#!`!`!a##d!a!b#%s!b!c%Z!c!}9g!}#O#'h#O#P%Z#P#Q#(O#Q#R#(f#R#S9g#S#T#)P#T#o#)g#o#p#,a#p#q#,f#q#r#-S#r#s#-l#s$f%Z$f$g%u$g#BY9g#BY#BZ#.S#BZ$IS9g$IS$I_#.S$I_$I|9g$I|$I}#0q$I}$JO#0q$JO$JT9g$JT$JU#.S$JU$KV9g$KV$KW#.S$KW&FU9g&FU&FV#.S&FV;'S9g;'S;=`<Z<%l?HT9g?HT?HU#.S?HUO9gW%`T$[WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%ZW%rP;=`<%l%Z7Z%|i$[W'b7ROX%ZXY%uYZ%ZZ[%u[p%Zpq%uq!^%Z!_#o%Z#p$f%Z$f$g%u$g#BY%Z#BY#BZ%u#BZ$IS%Z$IS$I_%u$I_$JT%Z$JT$JU%u$JU$KV%Z$KV$KW%u$KW&FU%Z&FU&FV%u&FV;'S%Z;'S;=`%o<%l?HT%Z?HT?HU%u?HUO%Z7Z'rT$[W'c7RO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&y(YU$[W!l&qO!^%Z!_!`(l!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t(sU#i&l$[WO!^%Z!_!`)V!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t)^T#i&l$[WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z1i)t]$[W]&ZOY)mYZ*mZr)mrs,js!^)m!^!_-S!_#O)m#O#P1q#P#o)m#o#p-S#p;'S)m;'S;=`7V<%lO)m,^*rX$[WOr*mrs+_s!^*m!^!_+u!_#o*m#o#p+u#p;'S*m;'S;=`,d<%lO*m,^+fT$V,U$[WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z,U+xTOr+urs,Xs;'S+u;'S;=`,^<%lO+u,U,^O$V,U,U,aP;=`<%l+u,^,gP;=`<%l*m1i,sT$V,U$[W]&ZO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z1a-XX]&ZOY-SYZ+uZr-Srs-ts#O-S#O#P-{#P;'S-S;'S;=`1k<%lO-S1a-{O$V,U]&Z1a.OUOr-Srs.bs;'S-S;'S;=`0y;=`<%l/R<%lO-S1a.iW$V,U]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s<%lO/R&Z/WW]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s<%lO/R&Z/uO]&Z&Z/xRO;'S/R;'S;=`0R;=`O/R&Z0WX]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s;=`<%l/R<%lO/R&Z0vP;=`<%l/R1a1OX]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s;=`<%l-S<%lO/R1a1nP;=`<%l-S1i1vY$[WOr)mrs2fs!^)m!^!_-S!_#o)m#o#p-S#p;'S)m;'S;=`6e;=`<%l/R<%lO)m1i2o]$V,U$[W]&ZOY3hYZ%ZZr3hrs4hs!^3h!^!_/R!_#O3h#O#P5O#P#o3h#o#p/R#p;'S3h;'S;=`6_<%lO3h&c3o]$[W]&ZOY3hYZ%ZZr3hrs4hs!^3h!^!_/R!_#O3h#O#P5O#P#o3h#o#p/R#p;'S3h;'S;=`6_<%lO3h&c4oT$[W]&ZO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c5TW$[WO!^3h!^!_/R!_#o3h#o#p/R#p;'S3h;'S;=`5m;=`<%l/R<%lO3h&c5rX]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s;=`<%l3h<%lO/R&c6bP;=`<%l3h1i6jX]&ZOY/RZr/Rrs/ps#O/R#O#P/u#P;'S/R;'S;=`0s;=`<%l)m<%lO/R1i7YP;=`<%l)m#]7b]$[WOt%Ztu8Zu!^%Z!_!c%Z!c!}8Z!}#R%Z#R#S8Z#S#T%Z#T#o8Z#p$g%Z$g;'S8Z;'S;=`9a<%lO8Z#]8b_$[W'v#TOt%Ztu8Zu!Q%Z!Q![8Z![!^%Z!_!c%Z!c!}8Z!}#R%Z#R#S8Z#S#T%Z#T#o8Z#p$g%Z$g;'S8Z;'S;=`9a<%lO8Z#]9dP;=`<%l8Z,T9ra$[W'n#S'e)s$OSOt%Ztu9gu}%Z}!O:w!O!Q%Z!Q![9g![!^%Z!_!c%Z!c!}9g!}#R%Z#R#S9g#S#T%Z#T#o9g#p$g%Z$g;'S9g;'S;=`<Z<%lO9g[;Oa$[W$OSOt%Ztu:wu}%Z}!O:w!O!Q%Z!Q![:w![!^%Z!_!c%Z!c!}:w!}#R%Z#R#S:w#S#T%Z#T#o:w#p$g%Z$g;'S:w;'S;=`<T<%lO:w[<WP;=`<%l:w,T<^P;=`<%l9g&t<hU#a&l$[WO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t=RT$[W#s&lO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z(h=iW(P(`$[WOv%Zvw>Rw!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t>YU$[W#m&lO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z1i>s]$[W]&ZOY>lYZ?lZw>lwx,jx!^>l!^!_@|!_#O>l#O#PE_#P#o>l#o#p@|#p;'S>l;'S;=`J]<%lO>l,^?qX$[WOw?lwx+_x!^?l!^!_@^!_#o?l#o#p@^#p;'S?l;'S;=`@v<%lO?l,U@aTOw@^wx,Xx;'S@^;'S;=`@p<%lO@^,U@sP;=`<%l@^,^@yP;=`<%l?l1aARX]&ZOY@|YZ@^Zw@|wx-tx#O@|#O#PAn#P;'S@|;'S;=`EX<%lO@|1aAqUOw@|wxBTx;'S@|;'S;=`Dg;=`<%lBt<%lO@|1aB[W$V,U]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da<%lOBt&ZByW]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da<%lOBt&ZCfRO;'SBt;'S;=`Co;=`OBt&ZCtX]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da;=`<%lBt<%lOBt&ZDdP;=`<%lBt1aDlX]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da;=`<%l@|<%lOBt1aE[P;=`<%l@|1iEdY$[WOw>lwxFSx!^>l!^!_@|!_#o>l#o#p@|#p;'S>l;'S;=`Ik;=`<%lBt<%lO>l1iF]]$V,U$[W]&ZOYGUYZ%ZZwGUwx4hx!^GU!^!_Bt!_#OGU#O#PHU#P#oGU#o#pBt#p;'SGU;'S;=`Ie<%lOGU&cG]]$[W]&ZOYGUYZ%ZZwGUwx4hx!^GU!^!_Bt!_#OGU#O#PHU#P#oGU#o#pBt#p;'SGU;'S;=`Ie<%lOGU&cHZW$[WO!^GU!^!_Bt!_#oGU#o#pBt#p;'SGU;'S;=`Hs;=`<%lBt<%lOGU&cHxX]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da;=`<%lGU<%lOBt&cIhP;=`<%lGU1iIpX]&ZOYBtZwBtwx/px#OBt#O#PCc#P;'SBt;'S;=`Da;=`<%l>l<%lOBt1iJ`P;=`<%l>l*qJjT!f*i$[WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z$PKQT!e#w$[WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z)ZKjW'f#e#b&l$[WOz%Zz{LS{!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z&tLZU#_&l$[WO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z*qLtUk*i$[WO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z,TM_T!T+{$[WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z,TMuX$[Wx(dO!O%Z!O!PNb!P!Q%Z!Q![! d![!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z$oNgV$[WO!O%Z!O!PN|!P!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z$o! TT!S$g$[WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c! k]$[Wl&ZO!Q%Z!Q![! d![!^%Z!_!g%Z!g!h!!d!h#R%Z#R#S! d#S#X%Z#X#Y!!d#Y#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!!i]$[WO{%Z{|!#b|}%Z}!O!#b!O!Q%Z!Q![!$S![!^%Z!_#R%Z#R#S!$S#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!#gX$[WO!Q%Z!Q![!$S![!^%Z!_#R%Z#R#S!$S#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!$ZX$[Wl&ZO!Q%Z!Q![!$S![!^%Z!_#R%Z#R#S!$S#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z7Z!$}b$[W#`&lOY!&VYZ%ZZz!&Vz{!-n{!P!&V!P!Q!BV!Q!^!&V!^!_!(f!_!`!Ch!`!a!Dm!a!}!&V!}#O!+T#O#P!,v#P#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&VX!&^^$[W!PPOY!&VYZ%ZZ!P!&V!P!Q!'Y!Q!^!&V!^!_!(f!_!}!&V!}#O!+T#O#P!,v#P#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&VX!'aa$[W!PPO!^%Z!_#Z%Z#Z#[!'Y#[#]%Z#]#^!'Y#^#a%Z#a#b!'Y#b#g%Z#g#h!'Y#h#i%Z#i#j!'Y#j#m%Z#m#n!'Y#n#o%Z#p;'S%Z;'S;=`%o<%lO%ZP!(kX!PPOY!(fZ!P!(f!P!Q!)W!Q!}!(f!}#O!)o#O#P!*n#P;'S!(f;'S;=`!*}<%lO!(fP!)]U!PP#Z#[!)W#]#^!)W#a#b!)W#g#h!)W#i#j!)W#m#n!)WP!)rVOY!)oZ#O!)o#O#P!*X#P#Q!(f#Q;'S!)o;'S;=`!*h<%lO!)oP!*[SOY!)oZ;'S!)o;'S;=`!*h<%lO!)oP!*kP;=`<%l!)oP!*qSOY!(fZ;'S!(f;'S;=`!*}<%lO!(fP!+QP;=`<%l!(fX!+Y[$[WOY!+TYZ%ZZ!^!+T!^!_!)o!_#O!+T#O#P!,O#P#Q!&V#Q#o!+T#o#p!)o#p;'S!+T;'S;=`!,p<%lO!+TX!,TX$[WOY!+TYZ%ZZ!^!+T!^!_!)o!_#o!+T#o#p!)o#p;'S!+T;'S;=`!,p<%lO!+TX!,sP;=`<%l!+TX!,{X$[WOY!&VYZ%ZZ!^!&V!^!_!(f!_#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&VX!-kP;=`<%l!&V7Z!-u`$[W!PPOY!-nYZ!.wZz!-nz{!2U{!P!-n!P!Q!@m!Q!^!-n!^!_!4m!_!}!-n!}#O!;l#O#P!?o#P#o!-n#o#p!4m#p;'S!-n;'S;=`!@g<%lO!-n7Z!.|X$[WOz!.wz{!/i{!^!.w!^!_!0w!_#o!.w#o#p!0w#p;'S!.w;'S;=`!2O<%lO!.w7Z!/nZ$[WOz!.wz{!/i{!P!.w!P!Q!0a!Q!^!.w!^!_!0w!_#o!.w#o#p!0w#p;'S!.w;'S;=`!2O<%lO!.w7Z!0hT$[WU7RO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z7R!0zTOz!0wz{!1Z{;'S!0w;'S;=`!1x<%lO!0w7R!1^VOz!0wz{!1Z{!P!0w!P!Q!1s!Q;'S!0w;'S;=`!1x<%lO!0w7R!1xOU7R7R!1{P;=`<%l!0w7Z!2RP;=`<%l!.w7Z!2]`$[W!PPOY!-nYZ!.wZz!-nz{!2U{!P!-n!P!Q!3_!Q!^!-n!^!_!4m!_!}!-n!}#O!;l#O#P!?o#P#o!-n#o#p!4m#p;'S!-n;'S;=`!@g<%lO!-n7Z!3ha$[WU7R!PPO!^%Z!_#Z%Z#Z#[!'Y#[#]%Z#]#^!'Y#^#a%Z#a#b!'Y#b#g%Z#g#h!'Y#h#i%Z#i#j!'Y#j#m%Z#m#n!'Y#n#o%Z#p;'S%Z;'S;=`%o<%lO%Z7R!4r[!PPOY!4mYZ!0wZz!4mz{!5h{!P!4m!P!Q!:b!Q!}!4m!}#O!6|#O#P!9r#P;'S!4m;'S;=`!:[<%lO!4m7R!5m[!PPOY!4mYZ!0wZz!4mz{!5h{!P!4m!P!Q!6c!Q!}!4m!}#O!6|#O#P!9r#P;'S!4m;'S;=`!:[<%lO!4m7R!6jUU7R!PP#Z#[!)W#]#^!)W#a#b!)W#g#h!)W#i#j!)W#m#n!)W7R!7PYOY!6|YZ!0wZz!6|z{!7o{#O!6|#O#P!9S#P#Q!4m#Q;'S!6|;'S;=`!9l<%lO!6|7R!7r[OY!6|YZ!0wZz!6|z{!7o{!P!6|!P!Q!8h!Q#O!6|#O#P!9S#P#Q!4m#Q;'S!6|;'S;=`!9l<%lO!6|7R!8mVU7ROY!)oZ#O!)o#O#P!*X#P#Q!(f#Q;'S!)o;'S;=`!*h<%lO!)o7R!9VVOY!6|YZ!0wZz!6|z{!7o{;'S!6|;'S;=`!9l<%lO!6|7R!9oP;=`<%l!6|7R!9uVOY!4mYZ!0wZz!4mz{!5h{;'S!4m;'S;=`!:[<%lO!4m7R!:_P;=`<%l!4m7R!:ga!PPOz!0wz{!1Z{#Z!0w#Z#[!:b#[#]!0w#]#^!:b#^#a!0w#a#b!:b#b#g!0w#g#h!:b#h#i!0w#i#j!:b#j#m!0w#m#n!:b#n;'S!0w;'S;=`!1x<%lO!0w7Z!;q^$[WOY!;lYZ!.wZz!;lz{!<m{!^!;l!^!_!6|!_#O!;l#O#P!>q#P#Q!-n#Q#o!;l#o#p!6|#p;'S!;l;'S;=`!?i<%lO!;l7Z!<r`$[WOY!;lYZ!.wZz!;lz{!<m{!P!;l!P!Q!=t!Q!^!;l!^!_!6|!_#O!;l#O#P!>q#P#Q!-n#Q#o!;l#o#p!6|#p;'S!;l;'S;=`!?i<%lO!;l7Z!={[$[WU7ROY!+TYZ%ZZ!^!+T!^!_!)o!_#O!+T#O#P!,O#P#Q!&V#Q#o!+T#o#p!)o#p;'S!+T;'S;=`!,p<%lO!+T7Z!>vZ$[WOY!;lYZ!.wZz!;lz{!<m{!^!;l!^!_!6|!_#o!;l#o#p!6|#p;'S!;l;'S;=`!?i<%lO!;l7Z!?lP;=`<%l!;l7Z!?tZ$[WOY!-nYZ!.wZz!-nz{!2U{!^!-n!^!_!4m!_#o!-n#o#p!4m#p;'S!-n;'S;=`!@g<%lO!-n7Z!@jP;=`<%l!-n7Z!@te$[W!PPOz!.wz{!/i{!^!.w!^!_!0w!_#Z!.w#Z#[!@m#[#]!.w#]#^!@m#^#a!.w#a#b!@m#b#g!.w#g#h!@m#h#i!.w#i#j!@m#j#m!.w#m#n!@m#n#o!.w#o#p!0w#p;'S!.w;'S;=`!2O<%lO!.w7Z!B^X$[WT7ROY!BVYZ%ZZ!^!BV!^!_!By!_#o!BV#o#p!By#p;'S!BV;'S;=`!Cb<%lO!BV7R!COST7ROY!ByZ;'S!By;'S;=`!C[<%lO!By7R!C_P;=`<%l!By7Z!CeP;=`<%l!BV&u!Cq^$[W#s&l!PPOY!&VYZ%ZZ!P!&V!P!Q!'Y!Q!^!&V!^!_!(f!_!}!&V!}#O!+T#O#P!,v#P#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&V]!Dv^#{S$[W!PPOY!&VYZ%ZZ!P!&V!P!Q!'Y!Q!^!&V!^!_!(f!_!}!&V!}#O!+T#O#P!,v#P#o!&V#o#p!(f#p;'S!&V;'S;=`!-h<%lO!&V&c!Eyf$[Wl&ZO!O%Z!O!P! d!P!Q%Z!Q![!G_![!^%Z!_!g%Z!g!h!!d!h#R%Z#R#S!G_#S#U%Z#U#V!IR#V#X%Z#X#Y!!d#Y#b%Z#b#c!Hk#c#d!Js#d#l%Z#l#m!L_#m#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!Gfa$[Wl&ZO!O%Z!O!P! d!P!Q%Z!Q![!G_![!^%Z!_!g%Z!g!h!!d!h#R%Z#R#S!G_#S#X%Z#X#Y!!d#Y#b%Z#b#c!Hk#c#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!HrT$[Wl&ZO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!IWY$[WO!Q%Z!Q!R!Iv!R!S!Iv!S!^%Z!_#R%Z#R#S!Iv#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!I}[$[Wl&ZO!Q%Z!Q!R!Iv!R!S!Iv!S!^%Z!_#R%Z#R#S!Iv#S#b%Z#b#c!Hk#c#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!JxX$[WO!Q%Z!Q!Y!Ke!Y!^%Z!_#R%Z#R#S!Ke#S#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!KlZ$[Wl&ZO!Q%Z!Q!Y!Ke!Y!^%Z!_#R%Z#R#S!Ke#S#b%Z#b#c!Hk#c#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!Ld]$[WO!Q%Z!Q![!M]![!^%Z!_!c%Z!c!i!M]!i#R%Z#R#S!M]#S#T%Z#T#Z!M]#Z#o%Z#p;'S%Z;'S;=`%o<%lO%Z&c!Md_$[Wl&ZO!Q%Z!Q![!M]![!^%Z!_!c%Z!c!i!M]!i#R%Z#R#S!M]#S#T%Z#T#Z!M]#Z#b%Z#b#c!Hk#c#o%Z#p;'S%Z;'S;=`%o<%lO%Z(m!NlT!_V$[W#q(^O!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z!P# ST_w$[WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z6i# nR'i$Y!c(O#|,_(TP!P!Q# w!^!_# |!_!`#!ZW# |O$^W&l#!RP#c&l!_!`#!U&l#!ZO#s&l&l#!`O#d&l(m#!gV#O(e$[WO!^%Z!_!`(l!`!a#!|!a#o%Z#p;'S%Z;'S;=`%o<%lO%Z&u##TT#Z&m$[WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z(m##oVe!s#d&l$XS$[WO!^%Z!_!`#$U!`!a#$l!a#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#$]T#d&l$[WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#$sV#c&l$[WO!^%Z!_!`<z!`!a#%Y!a#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#%aU#c&l$[WO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z(m#%zX'w&q$[WO!O%Z!O!P#&g!P!^%Z!_!a%Z!a!b#&}!b#o%Z#p;'S%Z;'S;=`%o<%lO%Z(i#&nTy(a$[WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#'UU$[W#n&lO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z,P#'oT{+w$[WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z$P#(VT!Q#w$[WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z&t#(mU#k&l$[WO!^%Z!_!`<z!`#o%Z#p;'S%Z;'S;=`%o<%lO%Z){#)WT$[W'm)sO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z,T#)ra$[W'n#S'e)s$QSOt%Ztu#)gu}%Z}!O#*w!O!Q%Z!Q![#)g![!^%Z!_!c%Z!c!}#)g!}#R%Z#R#S#)g#S#T%Z#T#o#)g#p$g%Z$g;'S#)g;'S;=`#,Z<%lO#)g[#+Oa$[W$QSOt%Ztu#*wu}%Z}!O#*w!O!Q%Z!Q![#*w![!^%Z!_!c%Z!c!}#*w!}#R%Z#R#S#*w#S#T%Z#T#o#*w#p$g%Z$g;'S#*w;'S;=`#,T<%lO#*w[#,WP;=`<%l#*w,T#,^P;=`<%l#)g~#,fO!V~(h#,mV(O(`$[WO!^%Z!_!`<z!`#o%Z#p#q#&}#q;'S%Z;'S;=`%o<%lO%Z(}#-]T!U(soQ$[WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%ZX#-sT!mP$[WO!^%Z!_#o%Z#p;'S%Z;'S;=`%o<%lO%Z7Z#.at$[W'b7R'n#S'e)s$OSOX%ZXY%uYZ%ZZ[%u[p%Zpq%uqt%Ztu9gu}%Z}!O:w!O!Q%Z!Q![9g![!^%Z!_!c%Z!c!}9g!}#R%Z#R#S9g#S#T%Z#T#o9g#p$f%Z$f$g%u$g#BY9g#BY#BZ#.S#BZ$IS9g$IS$I_#.S$I_$JT9g$JT$JU#.S$JU$KV9g$KV$KW#.S$KW&FU9g&FU&FV#.S&FV;'S9g;'S;=`<Z<%l?HT9g?HT?HU#.S?HUO9g7Z#1Oa$[W'c7R'n#S'e)s$OSOt%Ztu9gu}%Z}!O:w!O!Q%Z!Q![9g![!^%Z!_!c%Z!c!}9g!}#R%Z#R#S9g#S#T%Z#T#o9g#p$g%Z$g;'S9g;'S;=`<Z<%lO9g",
    tokenizers: [tsExtends, noSemicolon, incdecToken, template, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, insertSemicolon],
    topRules: { "Script": [0, 7], "SingleExpression": [1, 259] },
    dialects: { jsx: 12841, ts: 12843 },
    dynamicPrecedences: { "155": 1, "183": 1 },
    specialized: [{ term: 297, get: (value) => spec_identifier[value] || -1 }, { term: 306, get: (value) => spec_word[value] || -1 }, { term: 65, get: (value) => spec_LessThan[value] || -1 }],
    tokenPrec: 12866
  });

  // node_modules/@codemirror/lang-javascript/dist/index.js
  var snippets = [
    /* @__PURE__ */ snippetCompletion("function ${name}(${params}) {\n	${}\n}", {
      label: "function",
      detail: "definition",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
      label: "for",
      detail: "loop",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion("for (let ${name} of ${collection}) {\n	${}\n}", {
      label: "for",
      detail: "of loop",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion("do {\n	${}\n} while (${})", {
      label: "do",
      detail: "loop",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion("while (${}) {\n	${}\n}", {
      label: "while",
      detail: "loop",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion("try {\n	${}\n} catch (${error}) {\n	${}\n}", {
      label: "try",
      detail: "/ catch block",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion("if (${}) {\n	${}\n}", {
      label: "if",
      detail: "block",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion("if (${}) {\n	${}\n} else {\n	${}\n}", {
      label: "if",
      detail: "/ else block",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion("class ${name} {\n	constructor(${params}) {\n		${}\n	}\n}", {
      label: "class",
      detail: "definition",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion('import {${names}} from "${module}"\n${}', {
      label: "import",
      detail: "named",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion('import ${name} from "${module}"\n${}', {
      label: "import",
      detail: "default",
      type: "keyword"
    })
  ];
  var cache = /* @__PURE__ */ new NodeWeakMap();
  var ScopeNodes = /* @__PURE__ */ new Set([
    "Script",
    "Block",
    "FunctionExpression",
    "FunctionDeclaration",
    "ArrowFunction",
    "MethodDeclaration",
    "ForStatement"
  ]);
  function defID(type) {
    return (node, def) => {
      let id3 = node.node.getChild("VariableDefinition");
      if (id3)
        def(id3, type);
      return true;
    };
  }
  var functionContext = ["FunctionDeclaration"];
  var gatherCompletions = {
    FunctionDeclaration: /* @__PURE__ */ defID("function"),
    ClassDeclaration: /* @__PURE__ */ defID("class"),
    ClassExpression: () => true,
    EnumDeclaration: /* @__PURE__ */ defID("constant"),
    TypeAliasDeclaration: /* @__PURE__ */ defID("type"),
    NamespaceDeclaration: /* @__PURE__ */ defID("namespace"),
    VariableDefinition(node, def) {
      if (!node.matchContext(functionContext))
        def(node, "variable");
    },
    TypeDefinition(node, def) {
      def(node, "type");
    },
    __proto__: null
  };
  function getScope(doc3, node) {
    let cached = cache.get(node);
    if (cached)
      return cached;
    let completions = [], top2 = true;
    function def(node2, type) {
      let name2 = doc3.sliceString(node2.from, node2.to);
      completions.push({ label: name2, type });
    }
    node.cursor(IterMode.IncludeAnonymous).iterate((node2) => {
      if (top2) {
        top2 = false;
      } else if (node2.name) {
        let gather = gatherCompletions[node2.name];
        if (gather && gather(node2, def) || ScopeNodes.has(node2.name))
          return false;
      } else if (node2.to - node2.from > 8192) {
        for (let c2 of getScope(doc3, node2.node))
          completions.push(c2);
        return false;
      }
    });
    cache.set(node, completions);
    return completions;
  }
  var Identifier = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/;
  var dontComplete = [
    "TemplateString",
    "String",
    "RegExp",
    "LineComment",
    "BlockComment",
    "VariableDefinition",
    "TypeDefinition",
    "Label",
    "PropertyDefinition",
    "PropertyName",
    "PrivatePropertyDefinition",
    "PrivatePropertyName"
  ];
  function localCompletionSource(context) {
    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);
    if (dontComplete.indexOf(inner.name) > -1)
      return null;
    let isWord = inner.name == "VariableName" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));
    if (!isWord && !context.explicit)
      return null;
    let options = [];
    for (let pos = inner; pos; pos = pos.parent) {
      if (ScopeNodes.has(pos.name))
        options = options.concat(getScope(context.state.doc, pos));
    }
    return {
      options,
      from: isWord ? inner.from : context.pos,
      validFor: Identifier
    };
  }
  var javascriptLanguage = /* @__PURE__ */ LRLanguage.define({
    name: "javascript",
    parser: /* @__PURE__ */ parser.configure({
      props: [
        /* @__PURE__ */ indentNodeProp.add({
          IfStatement: /* @__PURE__ */ continuedIndent({ except: /^\s*({|else\b)/ }),
          TryStatement: /* @__PURE__ */ continuedIndent({ except: /^\s*({|catch\b|finally\b)/ }),
          LabeledStatement: flatIndent,
          SwitchBody: (context) => {
            let after = context.textAfter, closed = /^\s*\}/.test(after), isCase = /^\s*(case|default)\b/.test(after);
            return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;
          },
          Block: /* @__PURE__ */ delimitedIndent({ closing: "}" }),
          ArrowFunction: (cx) => cx.baseIndent + cx.unit,
          "TemplateString BlockComment": () => null,
          "Statement Property": /* @__PURE__ */ continuedIndent({ except: /^{/ }),
          JSXElement(context) {
            let closed = /^\s*<\//.test(context.textAfter);
            return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
          },
          JSXEscape(context) {
            let closed = /\s*\}/.test(context.textAfter);
            return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
          },
          "JSXOpenTag JSXSelfClosingTag"(context) {
            return context.column(context.node.from) + context.unit;
          }
        }),
        /* @__PURE__ */ foldNodeProp.add({
          "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression": foldInside,
          BlockComment(tree) {
            return { from: tree.from + 2, to: tree.to - 2 };
          }
        })
      ]
    }),
    languageData: {
      closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
      commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
      indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
      wordChars: "$"
    }
  });
  var typescriptLanguage = /* @__PURE__ */ javascriptLanguage.configure({ dialect: "ts" }, "typescript");
  var jsxLanguage = /* @__PURE__ */ javascriptLanguage.configure({ dialect: "jsx" });
  var tsxLanguage = /* @__PURE__ */ javascriptLanguage.configure({ dialect: "jsx ts" }, "typescript");
  var keywords = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map((kw) => ({ label: kw, type: "keyword" }));
  function javascript(config2 = {}) {
    let lang = config2.jsx ? config2.typescript ? tsxLanguage : jsxLanguage : config2.typescript ? typescriptLanguage : javascriptLanguage;
    return new LanguageSupport(lang, [
      javascriptLanguage.data.of({
        autocomplete: ifNotIn(dontComplete, completeFromList(snippets.concat(keywords)))
      }),
      javascriptLanguage.data.of({
        autocomplete: localCompletionSource
      }),
      config2.jsx ? autoCloseTags : []
    ]);
  }
  function elementName(doc3, tree, max2 = doc3.length) {
    if (!tree)
      return "";
    let name2 = tree.getChild("JSXIdentifier");
    return name2 ? doc3.sliceString(name2.from, Math.min(name2.to, max2)) : "";
  }
  var android2 = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
  var autoCloseTags = /* @__PURE__ */ EditorView.inputHandler.of((view2, from3, to, text3) => {
    if ((android2 ? view2.composing : view2.compositionStarted) || view2.state.readOnly || from3 != to || text3 != ">" && text3 != "/" || !javascriptLanguage.isActiveAt(view2.state, from3, -1))
      return false;
    let { state } = view2;
    let changes = state.changeByRange((range) => {
      var _a2, _b, _c;
      let { head } = range, around = syntaxTree(state).resolveInner(head, -1), name2;
      if (around.name == "JSXStartTag")
        around = around.parent;
      if (text3 == ">" && around.name == "JSXFragmentTag") {
        return { range: EditorSelection.cursor(head + 1), changes: { from: head, insert: `><>` } };
      } else if (text3 == ">" && around.name == "JSXIdentifier") {
        if (((_b = (_a2 = around.parent) === null || _a2 === void 0 ? void 0 : _a2.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "JSXEndTag" && (name2 = elementName(state.doc, around.parent, head)))
          return { range: EditorSelection.cursor(head + 1), changes: { from: head, insert: `></${name2}>` } };
      } else if (text3 == "/" && around.name == "JSXFragmentTag") {
        let empty2 = around.parent, base2 = empty2 === null || empty2 === void 0 ? void 0 : empty2.parent;
        if (empty2.from == head - 1 && ((_c = base2.lastChild) === null || _c === void 0 ? void 0 : _c.name) != "JSXEndTag" && (name2 = elementName(state.doc, base2 === null || base2 === void 0 ? void 0 : base2.firstChild, head))) {
          let insert2 = `/${name2}>`;
          return { range: EditorSelection.cursor(head + insert2.length), changes: { from: head, insert: insert2 } };
        }
      }
      return { range };
    });
    if (changes.changes.empty)
      return false;
    view2.dispatch(changes, { userEvent: "input.type", scrollIntoView: true });
    return true;
  });

  // node_modules/@lezer/markdown/dist/index.js
  var CompositeBlock = class {
    constructor(type, value, from3, hash2, end, children, positions) {
      this.type = type;
      this.value = value;
      this.from = from3;
      this.hash = hash2;
      this.end = end;
      this.children = children;
      this.positions = positions;
      this.hashProp = [[NodeProp.contextHash, hash2]];
    }
    static create(type, value, from3, parentHash, end) {
      let hash2 = parentHash + (parentHash << 8) + type + (value << 4) | 0;
      return new CompositeBlock(type, value, from3, hash2, end, [], []);
    }
    addChild(child, pos) {
      if (child.prop(NodeProp.contextHash) != this.hash)
        child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);
      this.children.push(child);
      this.positions.push(pos);
    }
    toTree(nodeSet, end = this.end) {
      let last2 = this.children.length - 1;
      if (last2 >= 0)
        end = Math.max(end, this.positions[last2] + this.children[last2].length + this.from);
      let tree = new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({
        makeTree: (children, positions, length3) => new Tree(NodeType.none, children, positions, length3, this.hashProp)
      });
      return tree;
    }
  };
  var Type;
  (function(Type2) {
    Type2[Type2["Document"] = 1] = "Document";
    Type2[Type2["CodeBlock"] = 2] = "CodeBlock";
    Type2[Type2["FencedCode"] = 3] = "FencedCode";
    Type2[Type2["Blockquote"] = 4] = "Blockquote";
    Type2[Type2["HorizontalRule"] = 5] = "HorizontalRule";
    Type2[Type2["BulletList"] = 6] = "BulletList";
    Type2[Type2["OrderedList"] = 7] = "OrderedList";
    Type2[Type2["ListItem"] = 8] = "ListItem";
    Type2[Type2["ATXHeading1"] = 9] = "ATXHeading1";
    Type2[Type2["ATXHeading2"] = 10] = "ATXHeading2";
    Type2[Type2["ATXHeading3"] = 11] = "ATXHeading3";
    Type2[Type2["ATXHeading4"] = 12] = "ATXHeading4";
    Type2[Type2["ATXHeading5"] = 13] = "ATXHeading5";
    Type2[Type2["ATXHeading6"] = 14] = "ATXHeading6";
    Type2[Type2["SetextHeading1"] = 15] = "SetextHeading1";
    Type2[Type2["SetextHeading2"] = 16] = "SetextHeading2";
    Type2[Type2["HTMLBlock"] = 17] = "HTMLBlock";
    Type2[Type2["LinkReference"] = 18] = "LinkReference";
    Type2[Type2["Paragraph"] = 19] = "Paragraph";
    Type2[Type2["CommentBlock"] = 20] = "CommentBlock";
    Type2[Type2["ProcessingInstructionBlock"] = 21] = "ProcessingInstructionBlock";
    Type2[Type2["Escape"] = 22] = "Escape";
    Type2[Type2["Entity"] = 23] = "Entity";
    Type2[Type2["HardBreak"] = 24] = "HardBreak";
    Type2[Type2["Emphasis"] = 25] = "Emphasis";
    Type2[Type2["StrongEmphasis"] = 26] = "StrongEmphasis";
    Type2[Type2["Link"] = 27] = "Link";
    Type2[Type2["Image"] = 28] = "Image";
    Type2[Type2["InlineCode"] = 29] = "InlineCode";
    Type2[Type2["HTMLTag"] = 30] = "HTMLTag";
    Type2[Type2["Comment"] = 31] = "Comment";
    Type2[Type2["ProcessingInstruction"] = 32] = "ProcessingInstruction";
    Type2[Type2["URL"] = 33] = "URL";
    Type2[Type2["HeaderMark"] = 34] = "HeaderMark";
    Type2[Type2["QuoteMark"] = 35] = "QuoteMark";
    Type2[Type2["ListMark"] = 36] = "ListMark";
    Type2[Type2["LinkMark"] = 37] = "LinkMark";
    Type2[Type2["EmphasisMark"] = 38] = "EmphasisMark";
    Type2[Type2["CodeMark"] = 39] = "CodeMark";
    Type2[Type2["CodeText"] = 40] = "CodeText";
    Type2[Type2["CodeInfo"] = 41] = "CodeInfo";
    Type2[Type2["LinkTitle"] = 42] = "LinkTitle";
    Type2[Type2["LinkLabel"] = 43] = "LinkLabel";
  })(Type || (Type = {}));
  var LeafBlock = class {
    constructor(start, content2) {
      this.start = start;
      this.content = content2;
      this.marks = [];
      this.parsers = [];
    }
  };
  var Line2 = class {
    constructor() {
      this.text = "";
      this.baseIndent = 0;
      this.basePos = 0;
      this.depth = 0;
      this.markers = [];
      this.pos = 0;
      this.indent = 0;
      this.next = -1;
    }
    forward() {
      if (this.basePos > this.pos)
        this.forwardInner();
    }
    forwardInner() {
      let newPos = this.skipSpace(this.basePos);
      this.indent = this.countIndent(newPos, this.pos, this.indent);
      this.pos = newPos;
      this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);
    }
    skipSpace(from3) {
      return skipSpace(this.text, from3);
    }
    reset(text3) {
      this.text = text3;
      this.baseIndent = this.basePos = this.pos = this.indent = 0;
      this.forwardInner();
      this.depth = 1;
      while (this.markers.length)
        this.markers.pop();
    }
    moveBase(to) {
      this.basePos = to;
      this.baseIndent = this.countIndent(to, this.pos, this.indent);
    }
    moveBaseColumn(indent) {
      this.baseIndent = indent;
      this.basePos = this.findColumn(indent);
    }
    addMarker(elt2) {
      this.markers.push(elt2);
    }
    countIndent(to, from3 = 0, indent = 0) {
      for (let i = from3; i < to; i++)
        indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;
      return indent;
    }
    findColumn(goal) {
      let i = 0;
      for (let indent = 0; i < this.text.length && indent < goal; i++)
        indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;
      return i;
    }
    scrub() {
      if (!this.baseIndent)
        return this.text;
      let result = "";
      for (let i = 0; i < this.basePos; i++)
        result += " ";
      return result + this.text.slice(this.basePos);
    }
  };
  function skipForList(bl, cx, line) {
    if (line.pos == line.text.length || bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent)
      return true;
    if (line.indent >= line.baseIndent + 4)
      return false;
    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);
    return size > 0 && (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) && line.text.charCodeAt(line.pos + size - 1) == bl.value;
  }
  var DefaultSkipMarkup = {
    [Type.Blockquote](bl, cx, line) {
      if (line.next != 62)
        return false;
      line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));
      line.moveBase(line.pos + (space2(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));
      bl.end = cx.lineStart + line.text.length;
      return true;
    },
    [Type.ListItem](bl, _cx, line) {
      if (line.indent < line.baseIndent + bl.value && line.next > -1)
        return false;
      line.moveBaseColumn(line.baseIndent + bl.value);
      return true;
    },
    [Type.OrderedList]: skipForList,
    [Type.BulletList]: skipForList,
    [Type.Document]() {
      return true;
    }
  };
  function space2(ch) {
    return ch == 32 || ch == 9 || ch == 10 || ch == 13;
  }
  function skipSpace(line, i = 0) {
    while (i < line.length && space2(line.charCodeAt(i)))
      i++;
    return i;
  }
  function skipSpaceBack(line, i, to) {
    while (i > to && space2(line.charCodeAt(i - 1)))
      i--;
    return i;
  }
  function isFencedCode(line) {
    if (line.next != 96 && line.next != 126)
      return -1;
    let pos = line.pos + 1;
    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)
      pos++;
    if (pos < line.pos + 3)
      return -1;
    if (line.next == 96) {
      for (let i = pos; i < line.text.length; i++)
        if (line.text.charCodeAt(i) == 96)
          return -1;
    }
    return pos;
  }
  function isBlockquote(line) {
    return line.next != 62 ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;
  }
  function isHorizontalRule(line, cx, breaking) {
    if (line.next != 42 && line.next != 45 && line.next != 95)
      return -1;
    let count2 = 1;
    for (let pos = line.pos + 1; pos < line.text.length; pos++) {
      let ch = line.text.charCodeAt(pos);
      if (ch == line.next)
        count2++;
      else if (!space2(ch))
        return -1;
    }
    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length)
      return -1;
    return count2 < 3 ? -1 : 1;
  }
  function inList(cx, type) {
    for (let i = cx.stack.length - 1; i >= 0; i--)
      if (cx.stack[i].type == type)
        return true;
    return false;
  }
  function isBulletList(line, cx, breaking) {
    return (line.next == 45 || line.next == 43 || line.next == 42) && (line.pos == line.text.length - 1 || space2(line.text.charCodeAt(line.pos + 1))) && (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;
  }
  function isOrderedList(line, cx, breaking) {
    let pos = line.pos, next = line.next;
    for (; ; ) {
      if (next >= 48 && next <= 57)
        pos++;
      else
        break;
      if (pos == line.text.length)
        return -1;
      next = line.text.charCodeAt(pos);
    }
    if (pos == line.pos || pos > line.pos + 9 || next != 46 && next != 41 || pos < line.text.length - 1 && !space2(line.text.charCodeAt(pos + 1)) || breaking && !inList(cx, Type.OrderedList) && (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49))
      return -1;
    return pos + 1 - line.pos;
  }
  function isAtxHeading(line) {
    if (line.next != 35)
      return -1;
    let pos = line.pos + 1;
    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)
      pos++;
    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)
      return -1;
    let size = pos - line.pos;
    return size > 6 ? -1 : size;
  }
  function isSetextUnderline(line) {
    if (line.next != 45 && line.next != 61 || line.indent >= line.baseIndent + 4)
      return -1;
    let pos = line.pos + 1;
    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)
      pos++;
    let end = pos;
    while (pos < line.text.length && space2(line.text.charCodeAt(pos)))
      pos++;
    return pos == line.text.length ? end : -1;
  }
  var EmptyLine = /^[ \t]*$/;
  var CommentEnd = /-->/;
  var ProcessingEnd = /\?>/;
  var HTMLBlockStyle = [
    [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
    [/^\s*<!--/, CommentEnd],
    [/^\s*<\?/, ProcessingEnd],
    [/^\s*<![A-Z]/, />/],
    [/^\s*<!\[CDATA\[/, /\]\]>/],
    [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, EmptyLine],
    [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, EmptyLine]
  ];
  function isHTMLBlock(line, _cx, breaking) {
    if (line.next != 60)
      return -1;
    let rest = line.text.slice(line.pos);
    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)
      if (HTMLBlockStyle[i][0].test(rest))
        return i;
    return -1;
  }
  function getListIndent(line, pos) {
    let indentAfter = line.countIndent(pos, line.pos, line.indent);
    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);
    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;
  }
  function addCodeText(marks, from3, to) {
    let last2 = marks.length - 1;
    if (last2 >= 0 && marks[last2].to == from3 && marks[last2].type == Type.CodeText)
      marks[last2].to = to;
    else
      marks.push(elt(Type.CodeText, from3, to));
  }
  var DefaultBlockParsers = {
    LinkReference: void 0,
    IndentedCode(cx, line) {
      let base2 = line.baseIndent + 4;
      if (line.indent < base2)
        return false;
      let start = line.findColumn(base2);
      let from3 = cx.lineStart + start, to = cx.lineStart + line.text.length;
      let marks = [], pendingMarks = [];
      addCodeText(marks, from3, to);
      while (cx.nextLine() && line.depth >= cx.stack.length) {
        if (line.pos == line.text.length) {
          addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);
          for (let m2 of line.markers)
            pendingMarks.push(m2);
        } else if (line.indent < base2) {
          break;
        } else {
          if (pendingMarks.length) {
            for (let m2 of pendingMarks) {
              if (m2.type == Type.CodeText)
                addCodeText(marks, m2.from, m2.to);
              else
                marks.push(m2);
            }
            pendingMarks = [];
          }
          addCodeText(marks, cx.lineStart - 1, cx.lineStart);
          for (let m2 of line.markers)
            marks.push(m2);
          to = cx.lineStart + line.text.length;
          let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);
          if (codeStart < to)
            addCodeText(marks, codeStart, to);
        }
      }
      if (pendingMarks.length) {
        pendingMarks = pendingMarks.filter((m2) => m2.type != Type.CodeText);
        if (pendingMarks.length)
          line.markers = pendingMarks.concat(line.markers);
      }
      cx.addNode(cx.buffer.writeElements(marks, -from3).finish(Type.CodeBlock, to - from3), from3);
      return true;
    },
    FencedCode(cx, line) {
      let fenceEnd = isFencedCode(line);
      if (fenceEnd < 0)
        return false;
      let from3 = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;
      let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);
      let marks = [elt(Type.CodeMark, from3, from3 + len)];
      if (infoFrom < infoTo)
        marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));
      for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {
        let i = line.pos;
        if (line.indent - line.baseIndent < 4)
          while (i < line.text.length && line.text.charCodeAt(i) == ch)
            i++;
        if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {
          for (let m2 of line.markers)
            marks.push(m2);
          marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));
          cx.nextLine();
          break;
        } else {
          if (!first)
            addCodeText(marks, cx.lineStart - 1, cx.lineStart);
          for (let m2 of line.markers)
            marks.push(m2);
          let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;
          if (textStart < textEnd)
            addCodeText(marks, textStart, textEnd);
        }
      }
      cx.addNode(cx.buffer.writeElements(marks, -from3).finish(Type.FencedCode, cx.prevLineEnd() - from3), from3);
      return true;
    },
    Blockquote(cx, line) {
      let size = isBlockquote(line);
      if (size < 0)
        return false;
      cx.startContext(Type.Blockquote, line.pos);
      cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);
      line.moveBase(line.pos + size);
      return null;
    },
    HorizontalRule(cx, line) {
      if (isHorizontalRule(line, cx, false) < 0)
        return false;
      let from3 = cx.lineStart + line.pos;
      cx.nextLine();
      cx.addNode(Type.HorizontalRule, from3);
      return true;
    },
    BulletList(cx, line) {
      let size = isBulletList(line, cx, false);
      if (size < 0)
        return false;
      if (cx.block.type != Type.BulletList)
        cx.startContext(Type.BulletList, line.basePos, line.next);
      let newBase = getListIndent(line, line.pos + 1);
      cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);
      cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);
      line.moveBaseColumn(newBase);
      return null;
    },
    OrderedList(cx, line) {
      let size = isOrderedList(line, cx, false);
      if (size < 0)
        return false;
      if (cx.block.type != Type.OrderedList)
        cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));
      let newBase = getListIndent(line, line.pos + size);
      cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);
      cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);
      line.moveBaseColumn(newBase);
      return null;
    },
    ATXHeading(cx, line) {
      let size = isAtxHeading(line);
      if (size < 0)
        return false;
      let off = line.pos, from3 = cx.lineStart + off;
      let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;
      while (after > off && line.text.charCodeAt(after - 1) == line.next)
        after--;
      if (after == endOfSpace || after == off || !space2(line.text.charCodeAt(after - 1)))
        after = line.text.length;
      let buf = cx.buffer.write(Type.HeaderMark, 0, size).writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from3 + size + 1), -from3);
      if (after < line.text.length)
        buf.write(Type.HeaderMark, after - off, endOfSpace - off);
      let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);
      cx.nextLine();
      cx.addNode(node, from3);
      return true;
    },
    HTMLBlock(cx, line) {
      let type = isHTMLBlock(line, cx, false);
      if (type < 0)
        return false;
      let from3 = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];
      let marks = [], trailing = end != EmptyLine;
      while (!end.test(line.text) && cx.nextLine()) {
        if (line.depth < cx.stack.length) {
          trailing = false;
          break;
        }
        for (let m2 of line.markers)
          marks.push(m2);
      }
      if (trailing)
        cx.nextLine();
      let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;
      let to = cx.prevLineEnd();
      cx.addNode(cx.buffer.writeElements(marks, -from3).finish(nodeType, to - from3), from3);
      return true;
    },
    SetextHeading: void 0
  };
  var LinkReferenceParser = class {
    constructor(leaf) {
      this.stage = 0;
      this.elts = [];
      this.pos = 0;
      this.start = leaf.start;
      this.advance(leaf.content);
    }
    nextLine(cx, line, leaf) {
      if (this.stage == -1)
        return false;
      let content2 = leaf.content + "\n" + line.scrub();
      let finish = this.advance(content2);
      if (finish > -1 && finish < content2.length)
        return this.complete(cx, leaf, finish);
      return false;
    }
    finish(cx, leaf) {
      if ((this.stage == 2 || this.stage == 3) && skipSpace(leaf.content, this.pos) == leaf.content.length)
        return this.complete(cx, leaf, leaf.content.length);
      return false;
    }
    complete(cx, leaf, len) {
      cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));
      return true;
    }
    nextStage(elt2) {
      if (elt2) {
        this.pos = elt2.to - this.start;
        this.elts.push(elt2);
        this.stage++;
        return true;
      }
      if (elt2 === false)
        this.stage = -1;
      return false;
    }
    advance(content2) {
      for (; ; ) {
        if (this.stage == -1) {
          return -1;
        } else if (this.stage == 0) {
          if (!this.nextStage(parseLinkLabel(content2, this.pos, this.start, true)))
            return -1;
          if (content2.charCodeAt(this.pos) != 58)
            return this.stage = -1;
          this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));
          this.pos++;
        } else if (this.stage == 1) {
          if (!this.nextStage(parseURL(content2, skipSpace(content2, this.pos), this.start)))
            return -1;
        } else if (this.stage == 2) {
          let skip = skipSpace(content2, this.pos), end = 0;
          if (skip > this.pos) {
            let title = parseLinkTitle(content2, skip, this.start);
            if (title) {
              let titleEnd = lineEnd(content2, title.to - this.start);
              if (titleEnd > 0) {
                this.nextStage(title);
                end = titleEnd;
              }
            }
          }
          if (!end)
            end = lineEnd(content2, this.pos);
          return end > 0 && end < content2.length ? end : -1;
        } else {
          return lineEnd(content2, this.pos);
        }
      }
    }
  };
  function lineEnd(text3, pos) {
    for (; pos < text3.length; pos++) {
      let next = text3.charCodeAt(pos);
      if (next == 10)
        break;
      if (!space2(next))
        return -1;
    }
    return pos;
  }
  var SetextHeadingParser = class {
    nextLine(cx, line, leaf) {
      let underline2 = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);
      let next = line.next;
      if (underline2 < 0)
        return false;
      let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline2);
      cx.nextLine();
      cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [
        ...cx.parser.parseInline(leaf.content, leaf.start),
        underlineMark
      ]));
      return true;
    }
    finish() {
      return false;
    }
  };
  var DefaultLeafBlocks = {
    LinkReference(_, leaf) {
      return leaf.content.charCodeAt(0) == 91 ? new LinkReferenceParser(leaf) : null;
    },
    SetextHeading() {
      return new SetextHeadingParser();
    }
  };
  var DefaultEndLeaf = [
    (_, line) => isAtxHeading(line) >= 0,
    (_, line) => isFencedCode(line) >= 0,
    (_, line) => isBlockquote(line) >= 0,
    (p, line) => isBulletList(line, p, true) >= 0,
    (p, line) => isOrderedList(line, p, true) >= 0,
    (p, line) => isHorizontalRule(line, p, true) >= 0,
    (p, line) => isHTMLBlock(line, p, true) >= 0
  ];
  var scanLineResult = { text: "", end: 0 };
  var BlockContext = class {
    constructor(parser5, input, fragments, ranges) {
      this.parser = parser5;
      this.input = input;
      this.ranges = ranges;
      this.line = new Line2();
      this.atEnd = false;
      this.dontInject = /* @__PURE__ */ new Set();
      this.stoppedAt = null;
      this.rangeI = 0;
      this.to = ranges[ranges.length - 1].to;
      this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;
      this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);
      this.stack = [this.block];
      this.fragments = fragments.length ? new FragmentCursor3(fragments, input) : null;
      this.readLine();
    }
    get parsedPos() {
      return this.absoluteLineStart;
    }
    advance() {
      if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
        return this.finish();
      let { line } = this;
      for (; ; ) {
        while (line.depth < this.stack.length)
          this.finishContext();
        for (let mark of line.markers)
          this.addNode(mark.type, mark.from, mark.to);
        if (line.pos < line.text.length)
          break;
        if (!this.nextLine())
          return this.finish();
      }
      if (this.fragments && this.reuseFragment(line.basePos))
        return null;
      start:
        for (; ; ) {
          for (let type of this.parser.blockParsers)
            if (type) {
              let result = type(this, line);
              if (result != false) {
                if (result == true)
                  return null;
                line.forward();
                continue start;
              }
            }
          break;
        }
      let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));
      for (let parse2 of this.parser.leafBlockParsers)
        if (parse2) {
          let parser5 = parse2(this, leaf);
          if (parser5)
            leaf.parsers.push(parser5);
        }
      lines:
        while (this.nextLine()) {
          if (line.pos == line.text.length)
            break;
          if (line.indent < line.baseIndent + 4) {
            for (let stop of this.parser.endLeafBlock)
              if (stop(this, line, leaf))
                break lines;
          }
          for (let parser5 of leaf.parsers)
            if (parser5.nextLine(this, line, leaf))
              return null;
          leaf.content += "\n" + line.scrub();
          for (let m2 of line.markers)
            leaf.marks.push(m2);
        }
      this.finishLeaf(leaf);
      return null;
    }
    stopAt(pos) {
      if (this.stoppedAt != null && this.stoppedAt < pos)
        throw new RangeError("Can't move stoppedAt forward");
      this.stoppedAt = pos;
    }
    reuseFragment(start) {
      if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
        return false;
      let taken = this.fragments.takeNodes(this);
      if (!taken)
        return false;
      let withoutGaps = taken, end = this.absoluteLineStart + taken;
      for (let i = 1; i < this.ranges.length; i++) {
        let gapFrom = this.ranges[i - 1].to, gapTo = this.ranges[i].from;
        if (gapFrom >= this.lineStart && gapTo < end)
          withoutGaps -= gapTo - gapFrom;
      }
      this.lineStart += withoutGaps;
      this.absoluteLineStart += taken;
      this.moveRangeI();
      if (this.absoluteLineStart < this.to) {
        this.lineStart++;
        this.absoluteLineStart++;
        this.readLine();
      } else {
        this.atEnd = true;
        this.readLine();
      }
      return true;
    }
    get depth() {
      return this.stack.length;
    }
    parentType(depth = this.depth - 1) {
      return this.parser.nodeSet.types[this.stack[depth].type];
    }
    nextLine() {
      this.lineStart += this.line.text.length;
      if (this.absoluteLineEnd >= this.to) {
        this.absoluteLineStart = this.absoluteLineEnd;
        this.atEnd = true;
        this.readLine();
        return false;
      } else {
        this.lineStart++;
        this.absoluteLineStart = this.absoluteLineEnd + 1;
        this.moveRangeI();
        this.readLine();
        return true;
      }
    }
    moveRangeI() {
      while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {
        this.rangeI++;
        this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
      }
    }
    scanLine(start) {
      let r = scanLineResult;
      r.end = start;
      if (start >= this.to) {
        r.text = "";
      } else {
        r.text = this.lineChunkAt(start);
        r.end += r.text.length;
        if (this.ranges.length > 1) {
          let textOffset = this.absoluteLineStart, rangeI = this.rangeI;
          while (this.ranges[rangeI].to < r.end) {
            rangeI++;
            let nextFrom = this.ranges[rangeI].from;
            let after = this.lineChunkAt(nextFrom);
            r.end = nextFrom + after.length;
            r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;
            textOffset = r.end - r.text.length;
          }
        }
      }
      return r;
    }
    readLine() {
      let { line } = this, { text: text3, end } = this.scanLine(this.absoluteLineStart);
      this.absoluteLineEnd = end;
      line.reset(text3);
      for (; line.depth < this.stack.length; line.depth++) {
        let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];
        if (!handler)
          throw new Error("Unhandled block context " + Type[cx.type]);
        if (!handler(cx, this, line))
          break;
        line.forward();
      }
    }
    lineChunkAt(pos) {
      let next = this.input.chunk(pos), text3;
      if (!this.input.lineChunks) {
        let eol = next.indexOf("\n");
        text3 = eol < 0 ? next : next.slice(0, eol);
      } else {
        text3 = next == "\n" ? "" : next;
      }
      return pos + text3.length > this.to ? text3.slice(0, this.to - pos) : text3;
    }
    prevLineEnd() {
      return this.atEnd ? this.lineStart : this.lineStart - 1;
    }
    startContext(type, start, value = 0) {
      this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);
      this.stack.push(this.block);
    }
    startComposite(type, start, value = 0) {
      this.startContext(this.parser.getNodeType(type), start, value);
    }
    addNode(block, from3, to) {
      if (typeof block == "number")
        block = new Tree(this.parser.nodeSet.types[block], none4, none4, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from3);
      this.block.addChild(block, from3 - this.block.from);
    }
    addElement(elt2) {
      this.block.addChild(elt2.toTree(this.parser.nodeSet), elt2.from - this.block.from);
    }
    addLeafElement(leaf, elt2) {
      this.addNode(this.buffer.writeElements(injectMarks(elt2.children, leaf.marks), -elt2.from).finish(elt2.type, elt2.to - elt2.from), elt2.from);
    }
    finishContext() {
      let cx = this.stack.pop();
      let top2 = this.stack[this.stack.length - 1];
      top2.addChild(cx.toTree(this.parser.nodeSet), cx.from - top2.from);
      this.block = top2;
    }
    finish() {
      while (this.stack.length > 1)
        this.finishContext();
      return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
    }
    addGaps(tree) {
      return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.dontInject) : tree;
    }
    finishLeaf(leaf) {
      for (let parser5 of leaf.parsers)
        if (parser5.finish(this, leaf))
          return;
      let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);
      this.addNode(this.buffer.writeElements(inline, -leaf.start).finish(Type.Paragraph, leaf.content.length), leaf.start);
    }
    elt(type, from3, to, children) {
      if (typeof type == "string")
        return elt(this.parser.getNodeType(type), from3, to, children);
      return new TreeElement(type, from3);
    }
    get buffer() {
      return new Buffer2(this.parser.nodeSet);
    }
  };
  function injectGaps(ranges, rangeI, tree, offset, dont) {
    if (dont.has(tree.tree))
      return tree.tree;
    let rangeEnd2 = ranges[rangeI].to;
    let children = [], positions = [], start = tree.from + offset;
    function movePastNext(upto, inclusive) {
      while (inclusive ? upto >= rangeEnd2 : upto > rangeEnd2) {
        let size = ranges[rangeI + 1].from - rangeEnd2;
        offset += size;
        upto += size;
        rangeI++;
        rangeEnd2 = ranges[rangeI].to;
      }
    }
    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {
      movePastNext(ch.from + offset, true);
      let from3 = ch.from + offset, node;
      if (ch.to + offset > rangeEnd2) {
        node = injectGaps(ranges, rangeI, ch, offset, dont);
        movePastNext(ch.to + offset, false);
      } else {
        node = ch.toTree();
      }
      children.push(node);
      positions.push(from3 - start);
    }
    movePastNext(tree.to + offset, false);
    return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : void 0);
  }
  var MarkdownParser = class extends Parser {
    constructor(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers) {
      super();
      this.nodeSet = nodeSet;
      this.blockParsers = blockParsers;
      this.leafBlockParsers = leafBlockParsers;
      this.blockNames = blockNames;
      this.endLeafBlock = endLeafBlock;
      this.skipContextMarkup = skipContextMarkup;
      this.inlineParsers = inlineParsers;
      this.inlineNames = inlineNames;
      this.wrappers = wrappers;
      this.nodeTypes = /* @__PURE__ */ Object.create(null);
      for (let t2 of nodeSet.types)
        this.nodeTypes[t2.name] = t2.id;
    }
    createParse(input, fragments, ranges) {
      let parse2 = new BlockContext(this, input, fragments, ranges);
      for (let w of this.wrappers)
        parse2 = w(parse2, input, fragments, ranges);
      return parse2;
    }
    configure(spec) {
      let config2 = resolveConfig(spec);
      if (!config2)
        return this;
      let { nodeSet, skipContextMarkup } = this;
      let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;
      if (nonEmpty(config2.defineNodes)) {
        skipContextMarkup = Object.assign({}, skipContextMarkup);
        let nodeTypes2 = nodeSet.types.slice(), styles;
        for (let s of config2.defineNodes) {
          let { name: name2, block, composite, style } = typeof s == "string" ? { name: s } : s;
          if (nodeTypes2.some((t2) => t2.name == name2))
            continue;
          if (composite)
            skipContextMarkup[nodeTypes2.length] = (bl, cx, line) => composite(cx, line, bl.value);
          let id3 = nodeTypes2.length;
          let group = composite ? ["Block", "BlockContext"] : !block ? void 0 : id3 >= Type.ATXHeading1 && id3 <= Type.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"];
          nodeTypes2.push(NodeType.define({
            id: id3,
            name: name2,
            props: group && [[NodeProp.group, group]]
          }));
          if (style) {
            if (!styles)
              styles = {};
            if (Array.isArray(style) || style instanceof Tag)
              styles[name2] = style;
            else
              Object.assign(styles, style);
          }
        }
        nodeSet = new NodeSet(nodeTypes2);
        if (styles)
          nodeSet = nodeSet.extend(styleTags(styles));
      }
      if (nonEmpty(config2.props))
        nodeSet = nodeSet.extend(...config2.props);
      if (nonEmpty(config2.remove)) {
        for (let rm2 of config2.remove) {
          let block = this.blockNames.indexOf(rm2), inline = this.inlineNames.indexOf(rm2);
          if (block > -1)
            blockParsers[block] = leafBlockParsers[block] = void 0;
          if (inline > -1)
            inlineParsers[inline] = void 0;
        }
      }
      if (nonEmpty(config2.parseBlock)) {
        for (let spec2 of config2.parseBlock) {
          let found = blockNames.indexOf(spec2.name);
          if (found > -1) {
            blockParsers[found] = spec2.parse;
            leafBlockParsers[found] = spec2.leaf;
          } else {
            let pos = spec2.before ? findName(blockNames, spec2.before) : spec2.after ? findName(blockNames, spec2.after) + 1 : blockNames.length - 1;
            blockParsers.splice(pos, 0, spec2.parse);
            leafBlockParsers.splice(pos, 0, spec2.leaf);
            blockNames.splice(pos, 0, spec2.name);
          }
          if (spec2.endLeaf)
            endLeafBlock.push(spec2.endLeaf);
        }
      }
      if (nonEmpty(config2.parseInline)) {
        for (let spec2 of config2.parseInline) {
          let found = inlineNames.indexOf(spec2.name);
          if (found > -1) {
            inlineParsers[found] = spec2.parse;
          } else {
            let pos = spec2.before ? findName(inlineNames, spec2.before) : spec2.after ? findName(inlineNames, spec2.after) + 1 : inlineNames.length - 1;
            inlineParsers.splice(pos, 0, spec2.parse);
            inlineNames.splice(pos, 0, spec2.name);
          }
        }
      }
      if (config2.wrap)
        wrappers = wrappers.concat(config2.wrap);
      return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);
    }
    getNodeType(name2) {
      let found = this.nodeTypes[name2];
      if (found == null)
        throw new RangeError(`Unknown node type '${name2}'`);
      return found;
    }
    parseInline(text3, offset) {
      let cx = new InlineContext(this, text3, offset);
      outer:
        for (let pos = offset; pos < cx.end; ) {
          let next = cx.char(pos);
          for (let token of this.inlineParsers)
            if (token) {
              let result = token(cx, next, pos);
              if (result >= 0) {
                pos = result;
                continue outer;
              }
            }
          pos++;
        }
      return cx.resolveMarkers(0);
    }
  };
  function nonEmpty(a2) {
    return a2 != null && a2.length > 0;
  }
  function resolveConfig(spec) {
    if (!Array.isArray(spec))
      return spec;
    if (spec.length == 0)
      return null;
    let conf = resolveConfig(spec[0]);
    if (spec.length == 1)
      return conf;
    let rest = resolveConfig(spec.slice(1));
    if (!rest || !conf)
      return conf || rest;
    let conc2 = (a2, b) => (a2 || none4).concat(b || none4);
    let wrapA = conf.wrap, wrapB = rest.wrap;
    return {
      props: conc2(conf.props, rest.props),
      defineNodes: conc2(conf.defineNodes, rest.defineNodes),
      parseBlock: conc2(conf.parseBlock, rest.parseBlock),
      parseInline: conc2(conf.parseInline, rest.parseInline),
      remove: conc2(conf.remove, rest.remove),
      wrap: !wrapA ? wrapB : !wrapB ? wrapA : (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)
    };
  }
  function findName(names, name2) {
    let found = names.indexOf(name2);
    if (found < 0)
      throw new RangeError(`Position specified relative to unknown parser ${name2}`);
    return found;
  }
  var nodeTypes = [NodeType.none];
  for (let i = 1, name2; name2 = Type[i]; i++) {
    nodeTypes[i] = NodeType.define({
      id: i,
      name: name2,
      props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]]
    });
  }
  var none4 = [];
  var Buffer2 = class {
    constructor(nodeSet) {
      this.nodeSet = nodeSet;
      this.content = [];
      this.nodes = [];
    }
    write(type, from3, to, children = 0) {
      this.content.push(type, from3, to, 4 + children * 4);
      return this;
    }
    writeElements(elts, offset = 0) {
      for (let e of elts)
        e.writeTo(this, offset);
      return this;
    }
    finish(type, length3) {
      return Tree.build({
        buffer: this.content,
        nodeSet: this.nodeSet,
        reused: this.nodes,
        topID: type,
        length: length3
      });
    }
  };
  var Element = class {
    constructor(type, from3, to, children = none4) {
      this.type = type;
      this.from = from3;
      this.to = to;
      this.children = children;
    }
    writeTo(buf, offset) {
      let startOff = buf.content.length;
      buf.writeElements(this.children, offset);
      buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);
    }
    toTree(nodeSet) {
      return new Buffer2(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
    }
  };
  var TreeElement = class {
    constructor(tree, from3) {
      this.tree = tree;
      this.from = from3;
    }
    get to() {
      return this.from + this.tree.length;
    }
    get type() {
      return this.tree.type.id;
    }
    get children() {
      return none4;
    }
    writeTo(buf, offset) {
      buf.nodes.push(this.tree);
      buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);
    }
    toTree() {
      return this.tree;
    }
  };
  function elt(type, from3, to, children) {
    return new Element(type, from3, to, children);
  }
  var EmphasisUnderscore = { resolve: "Emphasis", mark: "EmphasisMark" };
  var EmphasisAsterisk = { resolve: "Emphasis", mark: "EmphasisMark" };
  var LinkStart = {};
  var ImageStart = {};
  var InlineDelimiter = class {
    constructor(type, from3, to, side) {
      this.type = type;
      this.from = from3;
      this.to = to;
      this.side = side;
    }
  };
  var Escapable = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
  var Punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
  try {
    Punctuation = new RegExp("[\\p{Pc}|\\p{Pd}|\\p{Pe}|\\p{Pf}|\\p{Pi}|\\p{Po}|\\p{Ps}]", "u");
  } catch (_) {
  }
  var DefaultInline = {
    Escape(cx, next, start) {
      if (next != 92 || start == cx.end - 1)
        return -1;
      let escaped = cx.char(start + 1);
      for (let i = 0; i < Escapable.length; i++)
        if (Escapable.charCodeAt(i) == escaped)
          return cx.append(elt(Type.Escape, start, start + 2));
      return -1;
    },
    Entity(cx, next, start) {
      if (next != 38)
        return -1;
      let m2 = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(cx.slice(start + 1, start + 31));
      return m2 ? cx.append(elt(Type.Entity, start, start + 1 + m2[0].length)) : -1;
    },
    InlineCode(cx, next, start) {
      if (next != 96 || start && cx.char(start - 1) == 96)
        return -1;
      let pos = start + 1;
      while (pos < cx.end && cx.char(pos) == 96)
        pos++;
      let size = pos - start, curSize = 0;
      for (; pos < cx.end; pos++) {
        if (cx.char(pos) == 96) {
          curSize++;
          if (curSize == size && cx.char(pos + 1) != 96)
            return cx.append(elt(Type.InlineCode, start, pos + 1, [
              elt(Type.CodeMark, start, start + size),
              elt(Type.CodeMark, pos + 1 - size, pos + 1)
            ]));
        } else {
          curSize = 0;
        }
      }
      return -1;
    },
    HTMLTag(cx, next, start) {
      if (next != 60 || start == cx.end - 1)
        return -1;
      let after = cx.slice(start + 1, cx.end);
      let url = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(after);
      if (url)
        return cx.append(elt(Type.URL, start, start + 1 + url[0].length));
      let comment2 = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);
      if (comment2)
        return cx.append(elt(Type.Comment, start, start + 1 + comment2[0].length));
      let procInst = /^\?[^]*?\?>/.exec(after);
      if (procInst)
        return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));
      let m2 = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(after);
      if (!m2)
        return -1;
      return cx.append(elt(Type.HTMLTag, start, start + 1 + m2[0].length));
    },
    Emphasis(cx, next, start) {
      if (next != 95 && next != 42)
        return -1;
      let pos = start + 1;
      while (cx.char(pos) == next)
        pos++;
      let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);
      let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);
      let sBefore = /\s|^$/.test(before), sAfter = /\s|^$/.test(after);
      let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);
      let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);
      let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);
      let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);
      return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 : 0) | (canClose ? 2 : 0)));
    },
    HardBreak(cx, next, start) {
      if (next == 92 && cx.char(start + 1) == 10)
        return cx.append(elt(Type.HardBreak, start, start + 2));
      if (next == 32) {
        let pos = start + 1;
        while (cx.char(pos) == 32)
          pos++;
        if (cx.char(pos) == 10 && pos >= start + 2)
          return cx.append(elt(Type.HardBreak, start, pos + 1));
      }
      return -1;
    },
    Link(cx, next, start) {
      return next == 91 ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1)) : -1;
    },
    Image(cx, next, start) {
      return next == 33 && cx.char(start + 1) == 91 ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1)) : -1;
    },
    LinkEnd(cx, next, start) {
      if (next != 93)
        return -1;
      for (let i = cx.parts.length - 1; i >= 0; i--) {
        let part = cx.parts[i];
        if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {
          if (!part.side || cx.skipSpace(part.to) == start && !/[(\[]/.test(cx.slice(start + 1, start + 2))) {
            cx.parts[i] = null;
            return -1;
          }
          let content2 = cx.takeContent(i);
          let link = cx.parts[i] = finishLink(cx, content2, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);
          if (part.type == LinkStart)
            for (let j = 0; j < i; j++) {
              let p = cx.parts[j];
              if (p instanceof InlineDelimiter && p.type == LinkStart)
                p.side = 0;
            }
          return link.to;
        }
      }
      return -1;
    }
  };
  function finishLink(cx, content2, type, start, startPos) {
    let { text: text3 } = cx, next = cx.char(startPos), endPos = startPos;
    content2.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));
    content2.push(elt(Type.LinkMark, startPos - 1, startPos));
    if (next == 40) {
      let pos = cx.skipSpace(startPos + 1);
      let dest = parseURL(text3, pos - cx.offset, cx.offset), title;
      if (dest) {
        pos = cx.skipSpace(dest.to);
        title = parseLinkTitle(text3, pos - cx.offset, cx.offset);
        if (title)
          pos = cx.skipSpace(title.to);
      }
      if (cx.char(pos) == 41) {
        content2.push(elt(Type.LinkMark, startPos, startPos + 1));
        endPos = pos + 1;
        if (dest)
          content2.push(dest);
        if (title)
          content2.push(title);
        content2.push(elt(Type.LinkMark, pos, endPos));
      }
    } else if (next == 91) {
      let label = parseLinkLabel(text3, startPos - cx.offset, cx.offset, false);
      if (label) {
        content2.push(label);
        endPos = label.to;
      }
    }
    return elt(type, start, endPos, content2);
  }
  function parseURL(text3, start, offset) {
    let next = text3.charCodeAt(start);
    if (next == 60) {
      for (let pos = start + 1; pos < text3.length; pos++) {
        let ch = text3.charCodeAt(pos);
        if (ch == 62)
          return elt(Type.URL, start + offset, pos + 1 + offset);
        if (ch == 60 || ch == 10)
          return false;
      }
      return null;
    } else {
      let depth = 0, pos = start;
      for (let escaped = false; pos < text3.length; pos++) {
        let ch = text3.charCodeAt(pos);
        if (space2(ch)) {
          break;
        } else if (escaped) {
          escaped = false;
        } else if (ch == 40) {
          depth++;
        } else if (ch == 41) {
          if (!depth)
            break;
          depth--;
        } else if (ch == 92) {
          escaped = true;
        }
      }
      return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text3.length ? null : false;
    }
  }
  function parseLinkTitle(text3, start, offset) {
    let next = text3.charCodeAt(start);
    if (next != 39 && next != 34 && next != 40)
      return false;
    let end = next == 40 ? 41 : next;
    for (let pos = start + 1, escaped = false; pos < text3.length; pos++) {
      let ch = text3.charCodeAt(pos);
      if (escaped)
        escaped = false;
      else if (ch == end)
        return elt(Type.LinkTitle, start + offset, pos + 1 + offset);
      else if (ch == 92)
        escaped = true;
    }
    return null;
  }
  function parseLinkLabel(text3, start, offset, requireNonWS) {
    for (let escaped = false, pos = start + 1, end = Math.min(text3.length, pos + 999); pos < end; pos++) {
      let ch = text3.charCodeAt(pos);
      if (escaped)
        escaped = false;
      else if (ch == 93)
        return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);
      else {
        if (requireNonWS && !space2(ch))
          requireNonWS = false;
        if (ch == 91)
          return false;
        else if (ch == 92)
          escaped = true;
      }
    }
    return null;
  }
  var InlineContext = class {
    constructor(parser5, text3, offset) {
      this.parser = parser5;
      this.text = text3;
      this.offset = offset;
      this.parts = [];
    }
    char(pos) {
      return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset);
    }
    get end() {
      return this.offset + this.text.length;
    }
    slice(from3, to) {
      return this.text.slice(from3 - this.offset, to - this.offset);
    }
    append(elt2) {
      this.parts.push(elt2);
      return elt2.to;
    }
    addDelimiter(type, from3, to, open, close) {
      return this.append(new InlineDelimiter(type, from3, to, (open ? 1 : 0) | (close ? 2 : 0)));
    }
    addElement(elt2) {
      return this.append(elt2);
    }
    resolveMarkers(from3) {
      for (let i = from3; i < this.parts.length; i++) {
        let close = this.parts[i];
        if (!(close instanceof InlineDelimiter && close.type.resolve && close.side & 2))
          continue;
        let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;
        let closeSize = close.to - close.from;
        let open, j = i - 1;
        for (; j >= from3; j--) {
          let part = this.parts[j];
          if (part instanceof InlineDelimiter && part.side & 1 && part.type == close.type && !(emp && (close.side & 1 || part.side & 2) && (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {
            open = part;
            break;
          }
        }
        if (!open)
          continue;
        let type = close.type.resolve, content2 = [];
        let start = open.from, end = close.to;
        if (emp) {
          let size = Math.min(2, open.to - open.from, closeSize);
          start = open.to - size;
          end = close.from + size;
          type = size == 1 ? "Emphasis" : "StrongEmphasis";
        }
        if (open.type.mark)
          content2.push(this.elt(open.type.mark, start, open.to));
        for (let k = j + 1; k < i; k++) {
          if (this.parts[k] instanceof Element)
            content2.push(this.parts[k]);
          this.parts[k] = null;
        }
        if (close.type.mark)
          content2.push(this.elt(close.type.mark, close.from, end));
        let element2 = this.elt(type, start, end, content2);
        this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;
        let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;
        if (keep)
          this.parts.splice(i, 0, element2);
        else
          this.parts[i] = element2;
      }
      let result = [];
      for (let i = from3; i < this.parts.length; i++) {
        let part = this.parts[i];
        if (part instanceof Element)
          result.push(part);
      }
      return result;
    }
    findOpeningDelimiter(type) {
      for (let i = this.parts.length - 1; i >= 0; i--) {
        let part = this.parts[i];
        if (part instanceof InlineDelimiter && part.type == type)
          return i;
      }
      return null;
    }
    takeContent(startIndex) {
      let content2 = this.resolveMarkers(startIndex);
      this.parts.length = startIndex;
      return content2;
    }
    skipSpace(from3) {
      return skipSpace(this.text, from3 - this.offset) + this.offset;
    }
    elt(type, from3, to, children) {
      if (typeof type == "string")
        return elt(this.parser.getNodeType(type), from3, to, children);
      return new TreeElement(type, from3);
    }
  };
  function injectMarks(elements, marks) {
    if (!marks.length)
      return elements;
    if (!elements.length)
      return marks;
    let elts = elements.slice(), eI = 0;
    for (let mark of marks) {
      while (eI < elts.length && elts[eI].to < mark.to)
        eI++;
      if (eI < elts.length && elts[eI].from < mark.from) {
        let e = elts[eI];
        if (e instanceof Element)
          elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));
      } else {
        elts.splice(eI++, 0, mark);
      }
    }
    return elts;
  }
  var NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];
  var FragmentCursor3 = class {
    constructor(fragments, input) {
      this.fragments = fragments;
      this.input = input;
      this.i = 0;
      this.fragment = null;
      this.fragmentEnd = -1;
      this.cursor = null;
      if (fragments.length)
        this.fragment = fragments[this.i++];
    }
    nextFragment() {
      this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;
      this.cursor = null;
      this.fragmentEnd = -1;
    }
    moveTo(pos, lineStart) {
      while (this.fragment && this.fragment.to <= pos)
        this.nextFragment();
      if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))
        return false;
      if (this.fragmentEnd < 0) {
        let end = this.fragment.to;
        while (end > 0 && this.input.read(end - 1, end) != "\n")
          end--;
        this.fragmentEnd = end ? end - 1 : 0;
      }
      let c2 = this.cursor;
      if (!c2) {
        c2 = this.cursor = this.fragment.tree.cursor();
        c2.firstChild();
      }
      let rPos = pos + this.fragment.offset;
      while (c2.to <= rPos)
        if (!c2.parent())
          return false;
      for (; ; ) {
        if (c2.from >= rPos)
          return this.fragment.from <= lineStart;
        if (!c2.childAfter(rPos))
          return false;
      }
    }
    matches(hash2) {
      let tree = this.cursor.tree;
      return tree && tree.prop(NodeProp.contextHash) == hash2;
    }
    takeNodes(cx) {
      let cur2 = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);
      let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;
      let prevEnd = end, prevI = blockI;
      for (; ; ) {
        if (cur2.to - off > fragEnd) {
          if (cur2.type.isAnonymous && cur2.firstChild())
            continue;
          break;
        }
        cx.dontInject.add(cur2.tree);
        cx.addNode(cur2.tree, cur2.from - off);
        if (cur2.type.is("Block")) {
          if (NotLast.indexOf(cur2.type.id) < 0) {
            end = cur2.to - off;
            blockI = cx.block.children.length;
          } else {
            end = prevEnd;
            blockI = prevI;
            prevEnd = cur2.to - off;
            prevI = cx.block.children.length;
          }
        }
        if (!cur2.nextSibling())
          break;
      }
      while (cx.block.children.length > blockI) {
        cx.block.children.pop();
        cx.block.positions.pop();
      }
      return end - start;
    }
  };
  var markdownHighlighting = styleTags({
    "Blockquote/...": tags.quote,
    HorizontalRule: tags.contentSeparator,
    "ATXHeading1/... SetextHeading1/...": tags.heading1,
    "ATXHeading2/... SetextHeading2/...": tags.heading2,
    "ATXHeading3/...": tags.heading3,
    "ATXHeading4/...": tags.heading4,
    "ATXHeading5/...": tags.heading5,
    "ATXHeading6/...": tags.heading6,
    "Comment CommentBlock": tags.comment,
    Escape: tags.escape,
    Entity: tags.character,
    "Emphasis/...": tags.emphasis,
    "StrongEmphasis/...": tags.strong,
    "Link/... Image/...": tags.link,
    "OrderedList/... BulletList/...": tags.list,
    "BlockQuote/...": tags.quote,
    "InlineCode CodeText": tags.monospace,
    URL: tags.url,
    "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": tags.processingInstruction,
    "CodeInfo LinkLabel": tags.labelName,
    LinkTitle: tags.string,
    Paragraph: tags.content
  });
  var parser2 = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map((n2) => DefaultBlockParsers[n2]), Object.keys(DefaultBlockParsers).map((n2) => DefaultLeafBlocks[n2]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map((n2) => DefaultInline[n2]), Object.keys(DefaultInline), []);
  function leftOverSpace(node, from3, to) {
    let ranges = [];
    for (let n2 = node.firstChild, pos = from3; ; n2 = n2.nextSibling) {
      let nextPos = n2 ? n2.from : to;
      if (nextPos > pos)
        ranges.push({ from: pos, to: nextPos });
      if (!n2)
        break;
      pos = n2.to;
    }
    return ranges;
  }
  function parseCode(config2) {
    let { codeParser, htmlParser } = config2;
    let wrap3 = parseMixed((node, input) => {
      let id3 = node.type.id;
      if (codeParser && (id3 == Type.CodeBlock || id3 == Type.FencedCode)) {
        let info = "";
        if (id3 == Type.FencedCode) {
          let infoNode = node.node.getChild(Type.CodeInfo);
          if (infoNode)
            info = input.read(infoNode.from, infoNode.to);
        }
        let parser5 = codeParser(info);
        if (parser5)
          return { parser: parser5, overlay: (node2) => node2.type.id == Type.CodeText };
      } else if (htmlParser && (id3 == Type.HTMLBlock || id3 == Type.HTMLTag)) {
        return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };
      }
      return null;
    });
    return { wrap: wrap3 };
  }
  var StrikethroughDelim = { resolve: "Strikethrough", mark: "StrikethroughMark" };
  var Strikethrough = {
    defineNodes: [{
      name: "Strikethrough",
      style: { "Strikethrough/...": tags.strikethrough }
    }, {
      name: "StrikethroughMark",
      style: tags.processingInstruction
    }],
    parseInline: [{
      name: "Strikethrough",
      parse(cx, next, pos) {
        if (next != 126 || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)
          return -1;
        let before = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);
        let sBefore = /\s|^$/.test(before), sAfter = /\s|^$/.test(after);
        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);
        return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));
      },
      after: "Emphasis"
    }]
  };
  function parseRow(cx, line, startI = 0, elts, offset = 0) {
    let count2 = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;
    let parseCell = () => {
      elts.push(cx.elt("TableCell", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));
    };
    for (let i = startI; i < line.length; i++) {
      let next = line.charCodeAt(i);
      if (next == 124 && !esc) {
        if (!first || cellStart > -1)
          count2++;
        first = false;
        if (elts) {
          if (cellStart > -1)
            parseCell();
          elts.push(cx.elt("TableDelimiter", i + offset, i + offset + 1));
        }
        cellStart = cellEnd = -1;
      } else if (esc || next != 32 && next != 9) {
        if (cellStart < 0)
          cellStart = i;
        cellEnd = i + 1;
      }
      esc = !esc && next == 92;
    }
    if (cellStart > -1) {
      count2++;
      if (elts)
        parseCell();
    }
    return count2;
  }
  function hasPipe(str, start) {
    for (let i = start; i < str.length; i++) {
      let next = str.charCodeAt(i);
      if (next == 124)
        return true;
      if (next == 92)
        i++;
    }
    return false;
  }
  var delimiterLine = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
  var TableParser = class {
    constructor() {
      this.rows = null;
    }
    nextLine(cx, line, leaf) {
      if (this.rows == null) {
        this.rows = false;
        let lineText;
        if ((line.next == 45 || line.next == 58 || line.next == 124) && delimiterLine.test(lineText = line.text.slice(line.pos))) {
          let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);
          if (firstCount == parseRow(cx, lineText, line.pos))
            this.rows = [
              cx.elt("TableHeader", leaf.start, leaf.start + leaf.content.length, firstRow),
              cx.elt("TableDelimiter", cx.lineStart + line.pos, cx.lineStart + line.text.length)
            ];
        }
      } else if (this.rows) {
        let content2 = [];
        parseRow(cx, line.text, line.pos, content2, cx.lineStart);
        this.rows.push(cx.elt("TableRow", cx.lineStart + line.pos, cx.lineStart + line.text.length, content2));
      }
      return false;
    }
    finish(cx, leaf) {
      if (!this.rows)
        return false;
      cx.addLeafElement(leaf, cx.elt("Table", leaf.start, leaf.start + leaf.content.length, this.rows));
      return true;
    }
  };
  var Table = {
    defineNodes: [
      { name: "Table", block: true },
      { name: "TableHeader", style: { "TableHeader/...": tags.heading } },
      "TableRow",
      { name: "TableCell", style: tags.content },
      { name: "TableDelimiter", style: tags.processingInstruction }
    ],
    parseBlock: [{
      name: "Table",
      leaf(_, leaf) {
        return hasPipe(leaf.content, 0) ? new TableParser() : null;
      },
      endLeaf(cx, line, leaf) {
        if (leaf.parsers.some((p) => p instanceof TableParser) || !hasPipe(line.text, line.basePos))
          return false;
        let next = cx.scanLine(cx.absoluteLineEnd + 1).text;
        return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);
      },
      before: "SetextHeading"
    }]
  };
  var TaskParser = class {
    nextLine() {
      return false;
    }
    finish(cx, leaf) {
      cx.addLeafElement(leaf, cx.elt("Task", leaf.start, leaf.start + leaf.content.length, [
        cx.elt("TaskMarker", leaf.start, leaf.start + 3),
        ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)
      ]));
      return true;
    }
  };
  var TaskList = {
    defineNodes: [
      { name: "Task", block: true, style: tags.list },
      { name: "TaskMarker", style: tags.atom }
    ],
    parseBlock: [{
      name: "TaskList",
      leaf(cx, leaf) {
        return /^\[[ xX]\]/.test(leaf.content) && cx.parentType().name == "ListItem" ? new TaskParser() : null;
      },
      after: "SetextHeading"
    }]
  };
  var GFM = [Table, TaskList, Strikethrough];
  function parseSubSuper(ch, node, mark) {
    return (cx, next, pos) => {
      if (next != ch || cx.char(pos + 1) == ch)
        return -1;
      let elts = [cx.elt(mark, pos, pos + 1)];
      for (let i = pos + 1; i < cx.end; i++) {
        let next2 = cx.char(i);
        if (next2 == ch)
          return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));
        if (next2 == 92)
          elts.push(cx.elt("Escape", i, i++ + 2));
        if (space2(next2))
          break;
      }
      return -1;
    };
  }
  var Superscript = {
    defineNodes: [
      { name: "Superscript", style: tags.special(tags.content) },
      { name: "SuperscriptMark", style: tags.processingInstruction }
    ],
    parseInline: [{
      name: "Superscript",
      parse: parseSubSuper(94, "Superscript", "SuperscriptMark")
    }]
  };
  var Subscript = {
    defineNodes: [
      { name: "Subscript", style: tags.special(tags.content) },
      { name: "SubscriptMark", style: tags.processingInstruction }
    ],
    parseInline: [{
      name: "Subscript",
      parse: parseSubSuper(126, "Subscript", "SubscriptMark")
    }]
  };
  var Emoji = {
    defineNodes: [{ name: "Emoji", style: tags.character }],
    parseInline: [{
      name: "Emoji",
      parse(cx, next, pos) {
        let match;
        if (next != 58 || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))
          return -1;
        return cx.addElement(cx.elt("Emoji", pos, pos + 1 + match[0].length));
      }
    }]
  };

  // node_modules/@lezer/html/dist/index.es.js
  var scriptText = 54;
  var StartCloseScriptTag = 1;
  var styleText = 55;
  var StartCloseStyleTag = 2;
  var textareaText = 56;
  var StartCloseTextareaTag = 3;
  var StartTag = 4;
  var StartScriptTag = 5;
  var StartStyleTag = 6;
  var StartTextareaTag = 7;
  var StartSelfClosingTag = 8;
  var StartCloseTag = 9;
  var NoMatchStartCloseTag = 10;
  var MismatchedStartCloseTag = 11;
  var missingCloseTag = 57;
  var IncompleteCloseTag = 12;
  var commentContent$1 = 58;
  var Element2 = 18;
  var TagName = 20;
  var Attribute = 21;
  var AttributeName = 22;
  var AttributeValue = 24;
  var UnquotedAttributeValue = 25;
  var ScriptText = 27;
  var StyleText = 30;
  var TextareaText = 33;
  var OpenTag = 35;
  var Dialect_noMatch = 0;
  var selfClosers = {
    area: true,
    base: true,
    br: true,
    col: true,
    command: true,
    embed: true,
    frame: true,
    hr: true,
    img: true,
    input: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true,
    menuitem: true
  };
  var implicitlyClosed = {
    dd: true,
    li: true,
    optgroup: true,
    option: true,
    p: true,
    rp: true,
    rt: true,
    tbody: true,
    td: true,
    tfoot: true,
    th: true,
    tr: true
  };
  var closeOnOpen = {
    dd: { dd: true, dt: true },
    dt: { dd: true, dt: true },
    li: { li: true },
    option: { option: true, optgroup: true },
    optgroup: { optgroup: true },
    p: {
      address: true,
      article: true,
      aside: true,
      blockquote: true,
      dir: true,
      div: true,
      dl: true,
      fieldset: true,
      footer: true,
      form: true,
      h1: true,
      h2: true,
      h3: true,
      h4: true,
      h5: true,
      h6: true,
      header: true,
      hgroup: true,
      hr: true,
      menu: true,
      nav: true,
      ol: true,
      p: true,
      pre: true,
      section: true,
      table: true,
      ul: true
    },
    rp: { rp: true, rt: true },
    rt: { rp: true, rt: true },
    tbody: { tbody: true, tfoot: true },
    td: { td: true, th: true },
    tfoot: { tbody: true },
    th: { td: true, th: true },
    thead: { tbody: true, tfoot: true },
    tr: { tr: true }
  };
  function nameChar(ch) {
    return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161;
  }
  function isSpace(ch) {
    return ch == 9 || ch == 10 || ch == 13 || ch == 32;
  }
  var cachedName = null;
  var cachedInput = null;
  var cachedPos = 0;
  function tagNameAfter(input, offset) {
    let pos = input.pos + offset;
    if (cachedPos == pos && cachedInput == input)
      return cachedName;
    let next = input.peek(offset);
    while (isSpace(next))
      next = input.peek(++offset);
    let name2 = "";
    for (; ; ) {
      if (!nameChar(next))
        break;
      name2 += String.fromCharCode(next);
      next = input.peek(++offset);
    }
    cachedInput = input;
    cachedPos = pos;
    return cachedName = name2 ? name2.toLowerCase() : next == question || next == bang ? void 0 : null;
  }
  var lessThan = 60;
  var greaterThan = 62;
  var slash2 = 47;
  var question = 63;
  var bang = 33;
  var dash = 45;
  function ElementContext(name2, parent) {
    this.name = name2;
    this.parent = parent;
    this.hash = parent ? parent.hash : 0;
    for (let i = 0; i < name2.length; i++)
      this.hash += (this.hash << 4) + name2.charCodeAt(i) + (name2.charCodeAt(i) << 8);
  }
  var startTagTerms = [StartTag, StartSelfClosingTag, StartScriptTag, StartStyleTag, StartTextareaTag];
  var elementContext = new ContextTracker({
    start: null,
    shift(context, term, stack, input) {
      return startTagTerms.indexOf(term) > -1 ? new ElementContext(tagNameAfter(input, 1) || "", context) : context;
    },
    reduce(context, term) {
      return term == Element2 && context ? context.parent : context;
    },
    reuse(context, node, stack, input) {
      let type = node.type.id;
      return type == StartTag || type == OpenTag ? new ElementContext(tagNameAfter(input, 1) || "", context) : context;
    },
    hash(context) {
      return context ? context.hash : 0;
    },
    strict: false
  });
  var tagStart = new ExternalTokenizer((input, stack) => {
    if (input.next != lessThan) {
      if (input.next < 0 && stack.context)
        input.acceptToken(missingCloseTag);
      return;
    }
    input.advance();
    let close = input.next == slash2;
    if (close)
      input.advance();
    let name2 = tagNameAfter(input, 0);
    if (name2 === void 0)
      return;
    if (!name2)
      return input.acceptToken(close ? IncompleteCloseTag : StartTag);
    let parent = stack.context ? stack.context.name : null;
    if (close) {
      if (name2 == parent)
        return input.acceptToken(StartCloseTag);
      if (parent && implicitlyClosed[parent])
        return input.acceptToken(missingCloseTag, -2);
      if (stack.dialectEnabled(Dialect_noMatch))
        return input.acceptToken(NoMatchStartCloseTag);
      for (let cx = stack.context; cx; cx = cx.parent)
        if (cx.name == name2)
          return;
      input.acceptToken(MismatchedStartCloseTag);
    } else {
      if (name2 == "script")
        return input.acceptToken(StartScriptTag);
      if (name2 == "style")
        return input.acceptToken(StartStyleTag);
      if (name2 == "textarea")
        return input.acceptToken(StartTextareaTag);
      if (selfClosers.hasOwnProperty(name2))
        return input.acceptToken(StartSelfClosingTag);
      if (parent && closeOnOpen[parent] && closeOnOpen[parent][name2])
        input.acceptToken(missingCloseTag, -1);
      else
        input.acceptToken(StartTag);
    }
  }, { contextual: true });
  var commentContent = new ExternalTokenizer((input) => {
    for (let dashes = 0, i = 0; ; i++) {
      if (input.next < 0) {
        if (i)
          input.acceptToken(commentContent$1);
        break;
      }
      if (input.next == dash) {
        dashes++;
      } else if (input.next == greaterThan && dashes >= 2) {
        if (i > 3)
          input.acceptToken(commentContent$1, -2);
        break;
      } else {
        dashes = 0;
      }
      input.advance();
    }
  });
  function contentTokenizer(tag, textToken, endToken) {
    let lastState = 2 + tag.length;
    return new ExternalTokenizer((input) => {
      for (let state = 0, matchedLen = 0, i = 0; ; i++) {
        if (input.next < 0) {
          if (i)
            input.acceptToken(textToken);
          break;
        }
        if (state == 0 && input.next == lessThan || state == 1 && input.next == slash2 || state >= 2 && state < lastState && input.next == tag.charCodeAt(state - 2)) {
          state++;
          matchedLen++;
        } else if ((state == 2 || state == lastState) && isSpace(input.next)) {
          matchedLen++;
        } else if (state == lastState && input.next == greaterThan) {
          if (i > matchedLen)
            input.acceptToken(textToken, -matchedLen);
          else
            input.acceptToken(endToken, -(matchedLen - 2));
          break;
        } else if ((input.next == 10 || input.next == 13) && i) {
          input.acceptToken(textToken, 1);
          break;
        } else {
          state = matchedLen = 0;
        }
        input.advance();
      }
    });
  }
  var scriptTokens = contentTokenizer("script", scriptText, StartCloseScriptTag);
  var styleTokens = contentTokenizer("style", styleText, StartCloseStyleTag);
  var textareaTokens = contentTokenizer("textarea", textareaText, StartCloseTextareaTag);
  var htmlHighlighting = styleTags({
    "Text RawText": tags.content,
    "StartTag StartCloseTag SelfClosingEndTag EndTag": tags.angleBracket,
    TagName: tags.tagName,
    "MismatchedCloseTag/TagName": [tags.tagName, tags.invalid],
    AttributeName: tags.attributeName,
    "AttributeValue UnquotedAttributeValue": tags.attributeValue,
    Is: tags.definitionOperator,
    "EntityReference CharacterReference": tags.character,
    Comment: tags.blockComment,
    ProcessingInst: tags.processingInstruction,
    DoctypeDecl: tags.documentMeta
  });
  var parser3 = LRParser.deserialize({
    version: 14,
    states: ",xOVOxOOO!WQ!bO'#CoO!]Q!bO'#CyO!bQ!bO'#C|O!gQ!bO'#DPO!lQ!bO'#DRO!qOXO'#CnO!|OYO'#CnO#XO[O'#CnO$eOxO'#CnOOOW'#Cn'#CnO$lO!rO'#DTO$tQ!bO'#DVO$yQ!bO'#DWOOOW'#Dk'#DkOOOW'#DY'#DYQVOxOOO%OQ#tO,59ZO%WQ#tO,59eO%`Q#tO,59hO%hQ#tO,59kO%sQ#tO,59mOOOX'#D^'#D^O%{OXO'#CwO&WOXO,59YOOOY'#D_'#D_O&`OYO'#CzO&kOYO,59YOOO['#D`'#D`O&sO[O'#C}O'OO[O,59YOOOW'#Da'#DaO'WOxO,59YO'_Q!bO'#DQOOOW,59Y,59YOOO`'#Db'#DbO'dO!rO,59oOOOW,59o,59oO'lQ!bO,59qO'qQ!bO,59rOOOW-E7W-E7WO'vQ#tO'#CqOOQO'#DZ'#DZO(UQ#tO1G.uOOOX1G.u1G.uO(^Q#tO1G/POOOY1G/P1G/PO(fQ#tO1G/SOOO[1G/S1G/SO(nQ#tO1G/VOOOW1G/V1G/VOOOW1G/X1G/XO(yQ#tO1G/XOOOX-E7[-E7[O)RQ!bO'#CxOOOW1G.t1G.tOOOY-E7]-E7]O)WQ!bO'#C{OOO[-E7^-E7^O)]Q!bO'#DOOOOW-E7_-E7_O)bQ!bO,59lOOO`-E7`-E7`OOOW1G/Z1G/ZOOOW1G/]1G/]OOOW1G/^1G/^O)gQ&jO,59]OOQO-E7X-E7XOOOX7+$a7+$aOOOY7+$k7+$kOOO[7+$n7+$nOOOW7+$q7+$qOOOW7+$s7+$sO)rQ!bO,59dO)wQ!bO,59gO)|Q!bO,59jOOOW1G/W1G/WO*RO,UO'#CtO*dO7[O'#CtOOQO1G.w1G.wOOOW1G/O1G/OOOOW1G/R1G/ROOOW1G/U1G/UOOOO'#D['#D[O*uO,UO,59`OOQO,59`,59`OOOO'#D]'#D]O+WO7[O,59`OOOO-E7Y-E7YOOQO1G.z1G.zOOOO-E7Z-E7Z",
    stateData: "+u~O!^OS~OSSOTPOUQOVROWTOY]OZ[O[^O^^O_^O`^Oa^Ox^O{_O!dZO~OdaO~OdbO~OdcO~OddO~OdeO~O!WfOPkP!ZkP~O!XiOQnP!ZnP~O!YlORqP!ZqP~OSSOTPOUQOVROWTOXqOY]OZ[O[^O^^O_^O`^Oa^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OdvO~OdwO~OfyOj|O~OfyOj!OO~OfyOj!QO~OfyOj!SOv!TO~OfyOj!TO~O!WfOPkX!ZkX~OP!WO!Z!XO~O!XiOQnX!ZnX~OQ!ZO!Z!XO~O!YlORqX!ZqX~OR!]O!Z!XO~O!Z!XO~P#dOd!_O~O![sO!e!aO~Oj!bO~Oj!cO~Og!dOfeXjeXveX~OfyOj!fO~OfyOj!gO~OfyOj!hO~OfyOj!iOv!jO~OfyOj!jO~Od!kO~Od!lO~Od!mO~Oj!nO~Oi!qO!`!oO!b!pO~Oj!rO~Oj!sO~Oj!tO~O_!uO`!uOa!uO!`!wO!a!uO~O_!xO`!xOa!xO!b!wO!c!xO~O_!uO`!uOa!uO!`!{O!a!uO~O_!xO`!xOa!xO!b!{O!c!xO~Ov~vj`!dx{_a_~",
    goto: "%p!`PPPPPPPPPPPPPPPPPP!a!gP!mPP!yPP!|#P#S#Y#]#`#f#i#l#r#xP!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
    nodeNames: "\u26A0 StartCloseTag StartCloseTag StartCloseTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue EndTag ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag SelfClosingEndTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
    maxTerm: 67,
    context: elementContext,
    nodeProps: [
      ["closedBy", -10, 1, 2, 3, 5, 6, 7, 8, 9, 10, 11, "EndTag", 4, "EndTag SelfClosingEndTag", -4, 19, 29, 32, 35, "CloseTag"],
      ["group", -9, 12, 15, 16, 17, 18, 39, 40, 41, 42, "Entity", 14, "Entity TextContent", -3, 27, 30, 33, "TextContent Entity"],
      ["openedBy", 26, "StartTag StartCloseTag", -4, 28, 31, 34, 36, "OpenTag", 38, "StartTag"]
    ],
    propSources: [htmlHighlighting],
    skippedNodes: [0],
    repeatNodeCount: 9,
    tokenData: "#(r!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs4ysv-_vw5iwxJ^x}-_}!OKP!O!P-_!P!Q!!O!Q![-_![!]!$c!]!^-_!^!_!(k!_!`#'S!`!a#'z!a!c-_!c!}!$c!}#R-_#R#S!$c#S#T3V#T#o!$c#o#s-_#s$f$q$f%W-_%W%o!$c%o%p-_%p&a!$c&a&b-_&b1p!$c1p4U-_4U4d!$c4d4e-_4e$IS!$c$IS$I`-_$I`$Ib!$c$Ib$Kh-_$Kh%#t!$c%#t&/x-_&/x&Et!$c&Et&FV-_&FV;'S!$c;'S;:j!(e;:j;=`4s<%l?&r-_?&r?Ah!$c?Ah?BY$q?BY?Mn!$c?MnO$q!Z$|c^PiW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX^P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV^P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT^POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W^P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYiWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]`^P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljfS^PiW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_1n!_!a&X!a#S-_#S#T3V#T#s-_#s$f$q$f;'S-_;'S;=`4s<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ecfSiWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!^!_0p!a#S/^#S#T0p#T#s/^#s$f+P$f;'S/^;'S;=`1h<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0uXfSqr0psw0px!P0p!Q!_0p!a#s0p$f;'S0p;'S;=`1b<%l?Ah0p?BY?Mn0pS1eP;=`<%l0p[1kP;=`<%l/^!U1wbfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!U3SP;=`<%l1n!V3bcfS^P!a`!cpOq&Xqr3Vrs&}sv3Vvw0pwx(tx!P3V!P!Q&X!Q!^3V!^!_1n!_!a&X!a#s3V#s$f&X$f;'S3V;'S;=`4m<%l?Ah3V?Ah?BY&X?BY?Mn3V?MnO&X!V4pP;=`<%l3V!_4vP;=`<%l-_!Z5SV!`h^P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_5rjfSiWa!ROX7dXZ8qZ[7d[^8q^p7dqr:crs8qst@Ttw:cwx8qx!P:c!P!Q7d!Q!]:c!]!^/^!^!_=p!_!a8q!a#S:c#S#T=p#T#s:c#s$f7d$f;'S:c;'S;=`?}<%l?Ah:c?Ah?BY7d?BY?Mn:c?MnO7d!Z7ibiWOX7dXZ8qZ[7d[^8q^p7dqr7drs8qst+Ptw7dwx8qx!]7d!]!^9f!^!a8q!a#S7d#S#T8q#T;'S7d;'S;=`:]<%lO7d!R8tVOp8qqs8qt!]8q!]!^9Z!^;'S8q;'S;=`9`<%lO8q!R9`O_!R!R9cP;=`<%l8q!Z9mYiW_!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z:`P;=`<%l7d!_:jjfSiWOX7dXZ8qZ[7d[^8q^p7dqr:crs8qst/^tw:cwx8qx!P:c!P!Q7d!Q!]:c!]!^<[!^!_=p!_!a8q!a#S:c#S#T=p#T#s:c#s$f7d$f;'S:c;'S;=`?}<%l?Ah:c?Ah?BY7d?BY?Mn:c?MnO7d!_<ecfSiW_!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!^!_0p!a#S/^#S#T0p#T#s/^#s$f+P$f;'S/^;'S;=`1h<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V=udfSOp8qqr=prs8qst0ptw=pwx8qx!P=p!P!Q8q!Q!]=p!]!^?T!^!_=p!_!a8q!a#s=p#s$f8q$f;'S=p;'S;=`?w<%l?Ah=p?Ah?BY8q?BY?Mn=p?MnO8q!V?[XfS_!Rqr0psw0px!P0p!Q!_0p!a#s0p$f;'S0p;'S;=`1b<%l?Ah0p?BY?Mn0p!V?zP;=`<%l=p!_@QP;=`<%l:c!_@[ifSiWOXAyXZCTZ[Ay[^CT^pAyqrDrrsCTswDrwxCTx!PDr!P!QAy!Q!]Dr!]!^/^!^!_G|!_!aCT!a#SDr#S#TG|#T#sDr#s$fAy$f;'SDr;'S;=`JW<%l?AhDr?Ah?BYAy?BY?MnDr?MnOAy!ZBOaiWOXAyXZCTZ[Ay[^CT^pAyqrAyrsCTswAywxCTx!]Ay!]!^Cu!^!aCT!a#SAy#S#TCT#T;'SAy;'S;=`Dl<%lOAy!RCWUOpCTq!]CT!]!^Cj!^;'SCT;'S;=`Co<%lOCT!RCoO`!R!RCrP;=`<%lCT!ZC|YiW`!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZDoP;=`<%lAy!_DyifSiWOXAyXZCTZ[Ay[^CT^pAyqrDrrsCTswDrwxCTx!PDr!P!QAy!Q!]Dr!]!^Fh!^!_G|!_!aCT!a#SDr#S#TG|#T#sDr#s$fAy$f;'SDr;'S;=`JW<%l?AhDr?Ah?BYAy?BY?MnDr?MnOAy!_FqcfSiW`!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!^!_0p!a#S/^#S#T0p#T#s/^#s$f+P$f;'S/^;'S;=`1h<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VHRcfSOpCTqrG|rsCTswG|wxCTx!PG|!P!QCT!Q!]G|!]!^I^!^!_G|!_!aCT!a#sG|#s$fCT$f;'SG|;'S;=`JQ<%l?AhG|?Ah?BYCT?BY?MnG|?MnOCT!VIeXfS`!Rqr0psw0px!P0p!Q!_0p!a#s0p$f;'S0p;'S;=`1b<%l?Ah0p?BY?Mn0p!VJTP;=`<%lG|!_JZP;=`<%lDr!ZJgW!bx^P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aK^lfS^PiW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMU!O!P-_!P!Q$q!Q!^-_!^!_1n!_!a&X!a#S-_#S#T3V#T#s-_#s$f$q$f;'S-_;'S;=`4s<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aMckfS^PiW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_1n!_!`&X!`!a! W!a#S-_#S#T3V#T#s-_#s$f$q$f;'S-_;'S;=`4s<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!T! cX^P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!a!!Zd^PiW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!`&X!`!a!#i!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!X!#vX^P!a`!cpvSjUOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!a!$r!ZfSdQ^PiW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!O!$c!O!P!$c!P!Q$q!Q![!$c![!]!$c!]!^-_!^!_1n!_!a&X!a!c-_!c!}!$c!}#R-_#R#S!$c#S#T3V#T#o!$c#o#s-_#s$f$q$f$}-_$}%O!$c%O%W-_%W%o!$c%o%p-_%p&a!$c&a&b-_&b1p!$c1p4U!$c4U4d!$c4d4e-_4e$IS!$c$IS$I`-_$I`$Ib!$c$Ib$Je-_$Je$Jg!$c$Jg$Kh-_$Kh%#t!$c%#t&/x-_&/x&Et!$c&Et&FV-_&FV;'S!$c;'S;:j!(e;:j;=`4s<%l?&r-_?&r?Ah!$c?Ah?BY$q?BY?Mn!$c?MnO$q!a!(hP;=`<%l!$c!V!(tcfS!a`!cpOq*Vqr!*Prs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!b!H^!b#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!*YhfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex}1n}!O!+t!O!P1n!P!Q*V!Q!_1n!_!a*V!a!f1n!f!g!.p!g#W1n#W#X!?^#X#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!+}dfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex}1n}!O!-]!O!P1n!P!Q*V!Q!_1n!_!a*V!a#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!-hbfS!a`!cp!dPOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!.ydfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!q1n!q!r!0X!r#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!0bdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!e1n!e!f!1p!f#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!1ydfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!v1n!v!w!3X!w#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!3bdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!{1n!{!|!4p!|#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!4ydfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!r1n!r!s!6X!s#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!6bdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!g1n!g!h!7p!h#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!7ycfS!a`!cpOq!9Uqr!7prs!9{sv!7pvw!=swx!;ox!P!7p!P!Q!9U!Q!_!7p!_!`!9U!`!a!<}!a#s!7p#s$f!9U$f;'S!7p;'S;=`!?W<%l?Ah!7p?Ah?BY!9U?BY?Mn!7p?MnO!9U!R!9]Y!a`!cpOr!9Urs!9{sv!9Uvw!:gwx!;ox!`!9U!`!a!<}!a;'S!9U;'S;=`!=m<%lO!9Uq!:QV!cpOv!9{vx!:gx!`!9{!`!a!;U!a;'S!9{;'S;=`!;i<%lO!9{P!:jTO!`!:g!`!a!:y!a;'S!:g;'S;=`!;O<%lO!:gP!;OO{PP!;RP;=`<%l!:gq!;]S!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!;lP;=`<%l!9{a!;tX!a`Or!;ors!:gsv!;ovw!:gw!`!;o!`!a!<a!a;'S!;o;'S;=`!<w<%lO!;oa!<hT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!<zP;=`<%l!;o!R!=WV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!=pP;=`<%l!9UT!=xbfSOq!:gqr!=srs!:gsw!=swx!:gx!P!=s!P!Q!:g!Q!_!=s!_!`!:g!`!a!:y!a#s!=s#s$f!:g$f;'S!=s;'S;=`!?Q<%l?Ah!=s?Ah?BY!:g?BY?Mn!=s?MnO!:gT!?TP;=`<%l!=s!V!?ZP;=`<%l!7p!V!?gdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#c1n#c#d!@u#d#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!AOdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#V1n#V#W!B^#W#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!BgdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#h1n#h#i!Cu#i#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!DOdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#m1n#m#n!E^#n#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!EgdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#d1n#d#e!Fu#e#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!GOdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#X1n#X#Y!7p#Y#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!HgcfS!a`!cpOq!Irqr!H^rs!Jisv!H^vw#!vwx!MZx!P!H^!P!Q!Ir!Q!_!H^!_!a!Ir!a!b#%h!b#s!H^#s$f!Ir$f;'S!H^;'S;=`#&|<%l?Ah!H^?Ah?BY!Ir?BY?Mn!H^?MnO!Ir!R!IyY!a`!cpOr!Irrs!Jisv!Irvw!KTwx!MZx!a!Ir!a!b# Z!b;'S!Ir;'S;=`#!p<%lO!Irq!JnV!cpOv!Jivx!KTx!a!Ji!a!b!LU!b;'S!Ji;'S;=`!MT<%lO!JiP!KWTO!a!KT!a!b!Kg!b;'S!KT;'S;=`!LO<%lO!KTP!KjTO!`!KT!`!a!Ky!a;'S!KT;'S;=`!LO<%lO!KTP!LOOxPP!LRP;=`<%l!KTq!LZV!cpOv!Jivx!KTx!`!Ji!`!a!Lp!a;'S!Ji;'S;=`!MT<%lO!Jiq!LwS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!MWP;=`<%l!Jia!M`X!a`Or!MZrs!KTsv!MZvw!KTw!a!MZ!a!b!M{!b;'S!MZ;'S;=`# T<%lO!MZa!NQX!a`Or!MZrs!KTsv!MZvw!KTw!`!MZ!`!a!Nm!a;'S!MZ;'S;=`# T<%lO!MZa!NtT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea# WP;=`<%l!MZ!R# bY!a`!cpOr!Irrs!Jisv!Irvw!KTwx!MZx!`!Ir!`!a#!Q!a;'S!Ir;'S;=`#!p<%lO!Ir!R#!ZV!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R#!sP;=`<%l!IrT#!{bfSOq!KTqr#!vrs!KTsw#!vwx!KTx!P#!v!P!Q!KT!Q!_#!v!_!a!KT!a!b#$T!b#s#!v#s$f!KT$f;'S#!v;'S;=`#%b<%l?Ah#!v?Ah?BY!KT?BY?Mn#!v?MnO!KTT#$YbfSOq!KTqr#!vrs!KTsw#!vwx!KTx!P#!v!P!Q!KT!Q!_#!v!_!`!KT!`!a!Ky!a#s#!v#s$f!KT$f;'S#!v;'S;=`#%b<%l?Ah#!v?Ah?BY!KT?BY?Mn#!v?MnO!KTT#%eP;=`<%l#!v!V#%qcfS!a`!cpOq!Irqr!H^rs!Jisv!H^vw#!vwx!MZx!P!H^!P!Q!Ir!Q!_!H^!_!`!Ir!`!a#!Q!a#s!H^#s$f!Ir$f;'S!H^;'S;=`#&|<%l?Ah!H^?Ah?BY!Ir?BY?Mn!H^?MnO!Ir!V#'PP;=`<%l!H^!V#'_XgS^P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!X#(VX^P!a`!cpjUOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
    tokenizers: [scriptTokens, styleTokens, textareaTokens, tagStart, commentContent, 0, 1, 2, 3, 4, 5],
    topRules: { "Document": [0, 13] },
    dialects: { noMatch: 0, selfClosing: 485 },
    tokenPrec: 487
  });
  function getAttrs(element2, input) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let att of element2.firstChild.getChildren(Attribute)) {
      let name2 = att.getChild(AttributeName), value = att.getChild(AttributeValue) || att.getChild(UnquotedAttributeValue);
      if (name2)
        attrs[input.read(name2.from, name2.to)] = !value ? "" : value.type.id == AttributeValue ? input.read(value.from + 1, value.to - 1) : input.read(value.from, value.to);
    }
    return attrs;
  }
  function maybeNest(node, input, tags3) {
    let attrs;
    for (let tag of tags3) {
      if (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs(node.node.parent, input))))
        return { parser: tag.parser };
    }
    return null;
  }
  function configureNesting(tags3 = [], attributes = []) {
    let script = [], style = [], textarea = [];
    for (let tag of tags3) {
      let array2 = tag.tag == "script" ? script : tag.tag == "style" ? style : tag.tag == "textarea" ? textarea : null;
      if (!array2)
        throw new RangeError("Only script, style, and textarea tags can host nested parsers");
      array2.push(tag);
    }
    let attrs = attributes.length ? /* @__PURE__ */ Object.create(null) : null;
    for (let attr of attributes)
      (attrs[attr.name] || (attrs[attr.name] = [])).push(attr);
    return parseMixed((node, input) => {
      let id3 = node.type.id;
      if (id3 == ScriptText)
        return maybeNest(node, input, script);
      if (id3 == StyleText)
        return maybeNest(node, input, style);
      if (id3 == TextareaText)
        return maybeNest(node, input, textarea);
      if (attrs && id3 == Attribute) {
        let n2 = node.node, nameNode;
        if (nameNode = n2.firstChild) {
          let matches = attrs[input.read(nameNode.from, nameNode.to)];
          if (matches)
            for (let attr of matches) {
              if (attr.tagName) {
                if (!tagName) {
                  let tagNameNode = n2.parent.getChild(TagName);
                  tagName = tagNameNode ? input.read(tagNameNode.from, tagNameNode.to) : " ";
                }
                if (attrTagName != tagName)
                  continue;
              }
              let value = n2.lastChild;
              if (value.type.id == AttributeValue)
                return { parser: attr.parser, overlay: [{ from: value.from + 1, to: value.to - 1 }] };
              else if (value.type.id == UnquotedAttributeValue)
                return { parser: attr.parser, overlay: [{ from: value.from, to: value.to }] };
            }
        }
      }
      return null;
    });
  }

  // node_modules/@lezer/css/dist/index.es.js
  var descendantOp = 95;
  var Unit = 1;
  var callee = 96;
  var identifier = 97;
  var VariableName = 2;
  var space3 = [
    9,
    10,
    11,
    12,
    13,
    32,
    133,
    160,
    5760,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8232,
    8233,
    8239,
    8287,
    12288
  ];
  var colon = 58;
  var parenL = 40;
  var underscore = 95;
  var bracketL = 91;
  var dash2 = 45;
  var period = 46;
  var hash = 35;
  var percent = 37;
  function isAlpha(ch) {
    return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 161;
  }
  function isDigit(ch) {
    return ch >= 48 && ch <= 57;
  }
  var identifiers = new ExternalTokenizer((input, stack) => {
    for (let inside2 = false, dashes = 0, i = 0; ; i++) {
      let { next } = input;
      if (isAlpha(next) || next == dash2 || next == underscore || inside2 && isDigit(next)) {
        if (!inside2 && (next != dash2 || i > 0))
          inside2 = true;
        if (dashes === i && next == dash2)
          dashes++;
        input.advance();
      } else {
        if (inside2)
          input.acceptToken(next == parenL ? callee : dashes == 2 && stack.canShift(VariableName) ? VariableName : identifier);
        break;
      }
    }
  });
  var descendant = new ExternalTokenizer((input) => {
    if (space3.includes(input.peek(-1))) {
      let { next } = input;
      if (isAlpha(next) || next == underscore || next == hash || next == period || next == bracketL || next == colon || next == dash2)
        input.acceptToken(descendantOp);
    }
  });
  var unitToken = new ExternalTokenizer((input) => {
    if (!space3.includes(input.peek(-1))) {
      let { next } = input;
      if (next == percent) {
        input.advance();
        input.acceptToken(Unit);
      }
      if (isAlpha(next)) {
        do {
          input.advance();
        } while (isAlpha(input.next));
        input.acceptToken(Unit);
      }
    }
  });
  var cssHighlighting = styleTags({
    "AtKeyword import charset namespace keyframes media supports": tags.definitionKeyword,
    "from to selector": tags.keyword,
    NamespaceName: tags.namespace,
    KeyframeName: tags.labelName,
    TagName: tags.tagName,
    ClassName: tags.className,
    PseudoClassName: tags.constant(tags.className),
    IdName: tags.labelName,
    "FeatureName PropertyName": tags.propertyName,
    AttributeName: tags.attributeName,
    NumberLiteral: tags.number,
    KeywordQuery: tags.keyword,
    UnaryQueryOp: tags.operatorKeyword,
    "CallTag ValueName": tags.atom,
    VariableName: tags.variableName,
    Callee: tags.operatorKeyword,
    Unit: tags.unit,
    "UniversalSelector NestingSelector": tags.definitionOperator,
    MatchOp: tags.compareOperator,
    "ChildOp SiblingOp, LogicOp": tags.logicOperator,
    BinOp: tags.arithmeticOperator,
    Important: tags.modifier,
    Comment: tags.blockComment,
    ParenthesizedContent: tags.special(tags.name),
    ColorLiteral: tags.color,
    StringLiteral: tags.string,
    ":": tags.punctuation,
    "PseudoOp #": tags.derefOperator,
    "; ,": tags.separator,
    "( )": tags.paren,
    "[ ]": tags.squareBracket,
    "{ }": tags.brace
  });
  var spec_callee = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 134 };
  var spec_AtKeyword = { __proto__: null, "@import": 114, "@media": 138, "@charset": 142, "@namespace": 146, "@keyframes": 152, "@supports": 164 };
  var spec_identifier2 = { __proto__: null, not: 128, only: 128, from: 158, to: 160 };
  var parser4 = LRParser.deserialize({
    version: 14,
    states: "8SQYQ[OOO!ZQ[OOOOQP'#Cd'#CdOOQP'#Cc'#CcO!cQ[O'#CfO#VQXO'#CaO#^Q[O'#ChO#iQ[O'#DPO#nQ[O'#DTOOQP'#Ee'#EeO#sQdO'#DeO$_Q[O'#DrO#sQdO'#DtO$pQ[O'#DvO${Q[O'#DyO%QQ[O'#EPO%`Q[O'#EROOQS'#Ed'#EdOOQS'#ET'#ETQYQ[OOOOQO'#Db'#DbO%gQWO'#DaQ%lQWOOOOQP'#Cg'#CgOOQP,59Q,59QO!cQ[O,59QO%qQ[O'#EWO&]QWO,58{O&eQ[O,59SO#iQ[O,59kO#nQ[O,59oO%qQ[O,59sO%qQ[O,59uO%qQ[O,59vO'tQ[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO'{QWO,59SO(QQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO(VQ`O,59oOOQS'#Cp'#CpO#sQdO'#CqO(_QvO'#CsO)lQtO,5:POOQO'#Cx'#CxO(QQWO'#CwO*QQWO'#CyOOQS'#Eh'#EhOOQO'#Dh'#DhO*VQ[O'#DoO*eQWO'#EkO%QQ[O'#DmO*sQWO'#DpOOQO'#El'#ElO&`QWO,5:^O*xQpO,5:`OOQS'#Dx'#DxO+QQWO,5:bO+VQ[O,5:bOOQO'#D{'#D{O+_QWO,5:eO+dQWO,5:kO+lQWO,5:mOOQS-E8R-E8RO#sQdO,59{O+tQ[O'#E]Q%lQWOOOOQP1G.l1G.lO,nQXO,5:rOOQO-E8U-E8UOOQS1G.g1G.gOOQP1G.n1G.nO'{QWO1G.nO(QQWO1G.nOOQP1G/V1G/VO,{Q`O1G/ZO-fQXO1G/_O-|QXO1G/aO.dQXO1G/bO.zQXO'#CdOOQS,59z,59zO/oQWO,59zO/wQ[O,59zO0OQ[O'#DOO0VQdO'#CoOOQP1G/Z1G/ZO#sQdO1G/ZO0^QpO,59]OOQS,59_,59_O#sQdO,59aO0fQWO1G/kOOQS,59c,59cO0kQ!bO,59eO0sQWO'#DhO1OQWO,5:TO1TQWO,5:ZO%QQ[O,5:VO%QQ[O'#EZO1]QWO,5;VO1hQWO,5:XO%qQ[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O1yQWO1G/|O2OQdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XO2^QtO1G/gOOQO,5:w,5:wOOQO-E8Z-E8ZOOQP7+$Y7+$YOOQP7+$u7+$uO#sQdO7+$uO2tQ[O'#EYO3OQWO1G/fOOQS1G/f1G/fO3OQWO1G/fO3WQXO'#EjO3_QWO,59jO3dQtO'#EUO4XQdO'#EgO4cQWO,59ZO4hQpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO4pQWO1G/PO#sQdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO4uQWO,5:uOOQO-E8X-E8XO5TQXO1G/vOOQS7+%h7+%hO5[QYO'#CsO&`QWO'#E[O5dQdO,5:hOOQS,5:h,5:hO5rQtO'#EXO#sQdO'#EXO6pQdO7+%ROOQO7+%R7+%RO7TQpO<<HaOOQO,5:t,5:tO7]Q[O,5:tOOQO-E8W-E8WOOQS7+%Q7+%QO7gQWO7+%QO7oQWO,5;UOOQP1G/U1G/UOOQS-E8S-E8SO#sQdO'#EVO7wQWO,5;ROOQT1G.u1G.uOOQP<<Ha<<HaOOQS7+$k7+$kO8PQdO7+%ZOOQO7+%b7+%bOOQS,5:v,5:vOOQS-E8Y-E8YOOQS1G0S1G0SO8WQtO,5:sOOQS-E8V-E8VOOQO<<Hm<<HmOOQPAN={AN={OOQO1G0`1G0`OOQS<<Hl<<HlO9UQdO,5:qOOQO-E8T-E8TOOQO<<Hu<<Hu",
    stateData: "9f~O#VOSROS~OUXOXXO]UO^UOtVOxWO!Y`O!ZYO!gZO!i[O!k]O!n^O!t_O#TQO#YSO~OQeO#TdO~O#TgO~O]lO^lOpjOtmOxnO|oO!PqO#RpO#YiO~O!RrO~P!hO`xO#SuO#TtO~O#TyO~O#T{O~OQ!UOb!OOf!UOh!UOn!TO#S!RO#T}O#]!PO~Ob!WO!b!YO!e!ZO#T!VO!R#_P~Oh!`On!TO#T!_O~O#T!bO~Ob!WO!b!YO!e!ZO#T!VO~O!W#_P~P$_O]!gO~O!W!hO~OUXOXXO]UO^UOtVOxWO#TQO#YSO~OpjO!RrO~O`!pO#SuO#TtO~OQeOUXOXXO]UO^UOtVOxWO!Y`O!ZYO!gZO!i[O!k]O!n^O!t_O#T!vO#YSO~O!Q!wO~P&pOb!zO~Ob!{O~Ov!|Oz!}O~OP#PObgXjgX!WgX!bgX!egX#TgXagXQgXfgXhgXngXpgX!VgX#QgX#SgX#]gXvgX!QgX~Ob!WOj#QO!b!YO!e!ZO#T!VO!W#_P~Ob#TO~Ob!WO!b!YO!e!ZO#T#UO~Op#YO!`#XO!R#_X!W#_X~Ob#]O~Oj#QO!W#_O~O!W#`O~Oh#aOn!TO~O!R#bO~O!RrO!`#XO~O!RrO!W#eO~OQeO#TdO!W#PX#Q#PX~O]lO^lOtmOxnO|oO!PqO#RpO#YiO~Op!za!R!zaa!za~P,SOv#jOz#kO~O]lO^lOtmOxnO#YiO~Op{i|{i!P{i!R{i#R{ia{i~P-TOp}i|}i!P}i!R}i#R}ia}i~P-TOp!Oi|!Oi!P!Oi!R!Oi#R!Oia!Oi~P-TO]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#RWX#YWX~O!Q#nO!W#lO~O!Q#nO~P&pOa#^P~P%qOa#ZP~P#sOa#vOj#QO~O!W#xO~Oh#yOo#yO~O]!^Xa![X!`![X~O]#zO~Oa#{O!`#XO~Op#YO!R#_a!W#_a~O!`#XOp!aa!R!aa!W!aaa!aa~O!W$QO~O!Q$UO!q$SO!r$SO#]$RO~Oj#QOp$WO!V$YO!W!Ti#Q!Ti!Q!Ti~P#sO!Q!|X!W!|X~P&pO!Q$_O!W#lO~Oa#^X~P!hOa$bO~Oj#QOQ!xXa!xXb!xXf!xXh!xXn!xXp!xX#S!xX#T!xX#]!xX~Op$dOa#ZX~P#sOa$fO~Oj#QOv$gO~Oa$hO~O!`#XOp!}a!R!}a!W!}a~Oa$jO~P,SOP#PO!RgX~O!Q$mO!q$SO!r$SO#]$RO~Oj#QOQ!{Xb!{Xf!{Xh!{Xn!{Xp!{X!V!{X!W!{X#Q!{X#S!{X#T!{X#]!{X!Q!{X~Op$WO!V$pO!W!Tq#Q!Tq!Q!Tq~P#sOj#QOv$qO~O!Q!|a!W!|a~P&pO!Q$sO!W#lO~OpjOa#^a~Op$dOa#Za~Oa$vO~P#sOj#QOQ!{ab!{af!{ah!{an!{ap!{a!V!{a!W!{a#Q!{a#S!{a#T!{a#]!{a!Q!{a~Oa!yap!ya~P#sOo#]j!Pj~",
    goto: ",`#aPPPPP#bP#j#xP#j$W#jPP$^PPP$d$m$mP%PP$mP$m%g%yPPP&c&i#jP&oP#jP&uP#jP#j#jPPP&{'_'qPP#bPP'y'y(T'yP'yP'y'yP#bP#bP#bP(W#bP(Z(^PP#bP#bP(a(o(})T)_)e)o)u){PPPPPP*R*ZP*u*xP+n+q+z]aOcr!y#l$]iXOcjopqr!y!z#]#l$]iROcjopqr!y!z#]#l$]QhSR!jiQvUR!nlQ!nxQ#S!SR#i!pq!UY[!O!g!{!}#Q#f#k#s#z$W$X$d$i$tp!UY[!O!g!{!}#Q#f#k#s#z$W$X$d$i$tT$S#b$Tq!SY[!O!g!{!}#Q#f#k#s#z$W$X$d$i$tp!UY[!O!g!{!}#Q#f#k#s#z$W$X$d$i$tQ!`]R#a!aQwUR!olQ!nwR#i!oQzVR!qmQ|WR!rnQsTQ!mkQ#^!]Q#d!dQ#e!eR$k$SQfPQ!xrQ#g!hQ#o!yQ$[#lR$r$]]ePr!h!y#l$]a![Z_`!Q!W!Y#X#YR#V!WR!a]R!c^R#c!cQcOU!fc!y$]Q!yrR$]#lQ#s!{U$c#s$i$tQ$i#zR$t$dQ$e#sR$u$eQkTS!lk$aR$a#pQ$X#fR$o$XQ#m!xS$^#m$`R$`#oQ#Z!XR$O#ZQ$T#bR$l$TQ!ifR#h!i]bOcr!y#l$][TOcr!y#l$]Q!kjQ!soQ!tpQ!uqQ#p!zR$P#]R#t!{Q!QYQ!^[Q#O!OQ#f!g[#r!{#s#z$d$i$tQ#u!}Q#w#QS$V#f$XQ$Z#kR$n$WR#q!zQ!]ZQ!e`R#R!QU!XZ`!QQ!d_Q#W!WQ#[!YQ#|#XR#}#Y",
    nodeNames: "\u26A0 Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList from to SupportsStatement supports AtRule Styles",
    maxTerm: 108,
    nodeProps: [
      ["openedBy", 17, "(", 48, "{"],
      ["closedBy", 18, ")", 49, "}"]
    ],
    propSources: [cssHighlighting],
    skippedNodes: [0, 3],
    repeatNodeCount: 9,
    tokenData: "Lq~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Cu![!]Dp!]!^El!^!_$}!_!`E}!`!aF`!a!b$}!b!cG[!c!}$}!}#OHt#O#P$}#P#QIV#Q#R6d#R#T$}#T#UIh#U#c$}#c#dJy#d#o$}#o#pK`#p#q6d#q#rKq#r#sLS#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`Lk<%lO$}W%QSOy%^z;'S%^;'S;=`%o<%lO%^W%cSoWOy%^z;'S%^;'S;=`%o<%lO%^W%rP;=`<%l%^~%zh#V~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#V~oWOX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^^)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^^)sUoWOy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^^*[UoWOy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^^*sUoWOy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^^+[UoWOy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^^+sUoWOy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^^,[UoWOy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^^,sUoWOy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^^-[UoWOy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^^-uS!VUoWOy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.R_/zYtPOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^^0oYoWOy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^^1dYoWOy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^^2ZYfUoWOy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^^3QYfUoWOy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^^3uYoWOy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^^4lYfUoWOy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^^5aYoWOy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^^6WSfUoWOy%^z;'S%^;'S;=`%o<%lO%^Y6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^Y7QSzQoWOy%^z;'S%^;'S;=`%o<%lO%^X7cSXPOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7o_9cSbVOy%^z;'S%^;'S;=`%o<%lO%^~9tOa~_9{UUPjSOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^_:fWjS!PPOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^^;TUoWOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^^;nYoW#]UOy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^^<cYoWOy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^=WUoWOy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^=qUoW#]UOy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^>[[oW#]UOy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^_?VSpVOy%^z;'S%^;'S;=`%o<%lO%^^?hWjSOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^_@VU#YPOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjSOy%^z{@}{;'S%^;'S;=`%o<%lO%^~ASUoWOy@}yzAfz{Bm{;'S@};'S;=`Co<%lO@}~AiTOzAfz{Ax{;'SAf;'S;=`Bg<%lOAf~A{VOzAfz{Ax{!PAf!P!QBb!Q;'SAf;'S;=`Bg<%lOAf~BgOR~~BjP;=`<%lAf~BrWoWOy@}yzAfz{Bm{!P@}!P!QC[!Q;'S@};'S;=`Co<%lO@}~CcSoWR~Oy%^z;'S%^;'S;=`%o<%lO%^~CrP;=`<%l@}^Cz[#]UOy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^XDuU]POy%^z![%^![!]EX!];'S%^;'S;=`%o<%lO%^XE`S^PoWOy%^z;'S%^;'S;=`%o<%lO%^_EqS!WVOy%^z;'S%^;'S;=`%o<%lO%^YFSSzQOy%^z;'S%^;'S;=`%o<%lO%^XFeU|POy%^z!`%^!`!aFw!a;'S%^;'S;=`%o<%lO%^XGOS|PoWOy%^z;'S%^;'S;=`%o<%lO%^XG_WOy%^z!c%^!c!}Gw!}#T%^#T#oGw#o;'S%^;'S;=`%o<%lO%^XHO[!YPoWOy%^z}%^}!OGw!O!Q%^!Q![Gw![!c%^!c!}Gw!}#T%^#T#oGw#o;'S%^;'S;=`%o<%lO%^XHySxPOy%^z;'S%^;'S;=`%o<%lO%^^I[SvUOy%^z;'S%^;'S;=`%o<%lO%^XIkUOy%^z#b%^#b#cI}#c;'S%^;'S;=`%o<%lO%^XJSUoWOy%^z#W%^#W#XJf#X;'S%^;'S;=`%o<%lO%^XJmS!`PoWOy%^z;'S%^;'S;=`%o<%lO%^XJ|UOy%^z#f%^#f#gJf#g;'S%^;'S;=`%o<%lO%^XKeS!RPOy%^z;'S%^;'S;=`%o<%lO%^_KvS!QVOy%^z;'S%^;'S;=`%o<%lO%^ZLXU!PPOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^WLnP;=`<%l$}",
    tokenizers: [descendant, unitToken, identifiers, 0, 1, 2, 3],
    topRules: { "StyleSheet": [0, 4], "Styles": [1, 84] },
    specialized: [{ term: 96, get: (value) => spec_callee[value] || -1 }, { term: 56, get: (value) => spec_AtKeyword[value] || -1 }, { term: 97, get: (value) => spec_identifier2[value] || -1 }],
    tokenPrec: 1120
  });

  // node_modules/@codemirror/lang-css/dist/index.js
  var _properties = null;
  function properties() {
    if (!_properties && typeof document == "object" && document.body) {
      let names = [];
      for (let prop in document.body.style) {
        if (!/[A-Z]|^-|^(item|length)$/.test(prop))
          names.push(prop);
      }
      _properties = names.sort().map((name2) => ({ type: "property", label: name2 }));
    }
    return _properties || [];
  }
  var pseudoClasses = /* @__PURE__ */ [
    "active",
    "after",
    "any-link",
    "autofill",
    "backdrop",
    "before",
    "checked",
    "cue",
    "default",
    "defined",
    "disabled",
    "empty",
    "enabled",
    "file-selector-button",
    "first",
    "first-child",
    "first-letter",
    "first-line",
    "first-of-type",
    "focus",
    "focus-visible",
    "focus-within",
    "fullscreen",
    "has",
    "host",
    "host-context",
    "hover",
    "in-range",
    "indeterminate",
    "invalid",
    "is",
    "lang",
    "last-child",
    "last-of-type",
    "left",
    "link",
    "marker",
    "modal",
    "not",
    "nth-child",
    "nth-last-child",
    "nth-last-of-type",
    "nth-of-type",
    "only-child",
    "only-of-type",
    "optional",
    "out-of-range",
    "part",
    "placeholder",
    "placeholder-shown",
    "read-only",
    "read-write",
    "required",
    "right",
    "root",
    "scope",
    "selection",
    "slotted",
    "target",
    "target-text",
    "valid",
    "visited",
    "where"
  ].map((name2) => ({ type: "class", label: name2 }));
  var values = /* @__PURE__ */ [
    "above",
    "absolute",
    "activeborder",
    "additive",
    "activecaption",
    "after-white-space",
    "ahead",
    "alias",
    "all",
    "all-scroll",
    "alphabetic",
    "alternate",
    "always",
    "antialiased",
    "appworkspace",
    "asterisks",
    "attr",
    "auto",
    "auto-flow",
    "avoid",
    "avoid-column",
    "avoid-page",
    "avoid-region",
    "axis-pan",
    "background",
    "backwards",
    "baseline",
    "below",
    "bidi-override",
    "blink",
    "block",
    "block-axis",
    "bold",
    "bolder",
    "border",
    "border-box",
    "both",
    "bottom",
    "break",
    "break-all",
    "break-word",
    "bullets",
    "button",
    "button-bevel",
    "buttonface",
    "buttonhighlight",
    "buttonshadow",
    "buttontext",
    "calc",
    "capitalize",
    "caps-lock-indicator",
    "caption",
    "captiontext",
    "caret",
    "cell",
    "center",
    "checkbox",
    "circle",
    "cjk-decimal",
    "clear",
    "clip",
    "close-quote",
    "col-resize",
    "collapse",
    "color",
    "color-burn",
    "color-dodge",
    "column",
    "column-reverse",
    "compact",
    "condensed",
    "contain",
    "content",
    "contents",
    "content-box",
    "context-menu",
    "continuous",
    "copy",
    "counter",
    "counters",
    "cover",
    "crop",
    "cross",
    "crosshair",
    "currentcolor",
    "cursive",
    "cyclic",
    "darken",
    "dashed",
    "decimal",
    "decimal-leading-zero",
    "default",
    "default-button",
    "dense",
    "destination-atop",
    "destination-in",
    "destination-out",
    "destination-over",
    "difference",
    "disc",
    "discard",
    "disclosure-closed",
    "disclosure-open",
    "document",
    "dot-dash",
    "dot-dot-dash",
    "dotted",
    "double",
    "down",
    "e-resize",
    "ease",
    "ease-in",
    "ease-in-out",
    "ease-out",
    "element",
    "ellipse",
    "ellipsis",
    "embed",
    "end",
    "ethiopic-abegede-gez",
    "ethiopic-halehame-aa-er",
    "ethiopic-halehame-gez",
    "ew-resize",
    "exclusion",
    "expanded",
    "extends",
    "extra-condensed",
    "extra-expanded",
    "fantasy",
    "fast",
    "fill",
    "fill-box",
    "fixed",
    "flat",
    "flex",
    "flex-end",
    "flex-start",
    "footnotes",
    "forwards",
    "from",
    "geometricPrecision",
    "graytext",
    "grid",
    "groove",
    "hand",
    "hard-light",
    "help",
    "hidden",
    "hide",
    "higher",
    "highlight",
    "highlighttext",
    "horizontal",
    "hsl",
    "hsla",
    "hue",
    "icon",
    "ignore",
    "inactiveborder",
    "inactivecaption",
    "inactivecaptiontext",
    "infinite",
    "infobackground",
    "infotext",
    "inherit",
    "initial",
    "inline",
    "inline-axis",
    "inline-block",
    "inline-flex",
    "inline-grid",
    "inline-table",
    "inset",
    "inside",
    "intrinsic",
    "invert",
    "italic",
    "justify",
    "keep-all",
    "landscape",
    "large",
    "larger",
    "left",
    "level",
    "lighter",
    "lighten",
    "line-through",
    "linear",
    "linear-gradient",
    "lines",
    "list-item",
    "listbox",
    "listitem",
    "local",
    "logical",
    "loud",
    "lower",
    "lower-hexadecimal",
    "lower-latin",
    "lower-norwegian",
    "lowercase",
    "ltr",
    "luminosity",
    "manipulation",
    "match",
    "matrix",
    "matrix3d",
    "medium",
    "menu",
    "menutext",
    "message-box",
    "middle",
    "min-intrinsic",
    "mix",
    "monospace",
    "move",
    "multiple",
    "multiple_mask_images",
    "multiply",
    "n-resize",
    "narrower",
    "ne-resize",
    "nesw-resize",
    "no-close-quote",
    "no-drop",
    "no-open-quote",
    "no-repeat",
    "none",
    "normal",
    "not-allowed",
    "nowrap",
    "ns-resize",
    "numbers",
    "numeric",
    "nw-resize",
    "nwse-resize",
    "oblique",
    "opacity",
    "open-quote",
    "optimizeLegibility",
    "optimizeSpeed",
    "outset",
    "outside",
    "outside-shape",
    "overlay",
    "overline",
    "padding",
    "padding-box",
    "painted",
    "page",
    "paused",
    "perspective",
    "pinch-zoom",
    "plus-darker",
    "plus-lighter",
    "pointer",
    "polygon",
    "portrait",
    "pre",
    "pre-line",
    "pre-wrap",
    "preserve-3d",
    "progress",
    "push-button",
    "radial-gradient",
    "radio",
    "read-only",
    "read-write",
    "read-write-plaintext-only",
    "rectangle",
    "region",
    "relative",
    "repeat",
    "repeating-linear-gradient",
    "repeating-radial-gradient",
    "repeat-x",
    "repeat-y",
    "reset",
    "reverse",
    "rgb",
    "rgba",
    "ridge",
    "right",
    "rotate",
    "rotate3d",
    "rotateX",
    "rotateY",
    "rotateZ",
    "round",
    "row",
    "row-resize",
    "row-reverse",
    "rtl",
    "run-in",
    "running",
    "s-resize",
    "sans-serif",
    "saturation",
    "scale",
    "scale3d",
    "scaleX",
    "scaleY",
    "scaleZ",
    "screen",
    "scroll",
    "scrollbar",
    "scroll-position",
    "se-resize",
    "self-start",
    "self-end",
    "semi-condensed",
    "semi-expanded",
    "separate",
    "serif",
    "show",
    "single",
    "skew",
    "skewX",
    "skewY",
    "skip-white-space",
    "slide",
    "slider-horizontal",
    "slider-vertical",
    "sliderthumb-horizontal",
    "sliderthumb-vertical",
    "slow",
    "small",
    "small-caps",
    "small-caption",
    "smaller",
    "soft-light",
    "solid",
    "source-atop",
    "source-in",
    "source-out",
    "source-over",
    "space",
    "space-around",
    "space-between",
    "space-evenly",
    "spell-out",
    "square",
    "start",
    "static",
    "status-bar",
    "stretch",
    "stroke",
    "stroke-box",
    "sub",
    "subpixel-antialiased",
    "svg_masks",
    "super",
    "sw-resize",
    "symbolic",
    "symbols",
    "system-ui",
    "table",
    "table-caption",
    "table-cell",
    "table-column",
    "table-column-group",
    "table-footer-group",
    "table-header-group",
    "table-row",
    "table-row-group",
    "text",
    "text-bottom",
    "text-top",
    "textarea",
    "textfield",
    "thick",
    "thin",
    "threeddarkshadow",
    "threedface",
    "threedhighlight",
    "threedlightshadow",
    "threedshadow",
    "to",
    "top",
    "transform",
    "translate",
    "translate3d",
    "translateX",
    "translateY",
    "translateZ",
    "transparent",
    "ultra-condensed",
    "ultra-expanded",
    "underline",
    "unidirectional-pan",
    "unset",
    "up",
    "upper-latin",
    "uppercase",
    "url",
    "var",
    "vertical",
    "vertical-text",
    "view-box",
    "visible",
    "visibleFill",
    "visiblePainted",
    "visibleStroke",
    "visual",
    "w-resize",
    "wait",
    "wave",
    "wider",
    "window",
    "windowframe",
    "windowtext",
    "words",
    "wrap",
    "wrap-reverse",
    "x-large",
    "x-small",
    "xor",
    "xx-large",
    "xx-small"
  ].map((name2) => ({ type: "keyword", label: name2 })).concat(/* @__PURE__ */ [
    "aliceblue",
    "antiquewhite",
    "aqua",
    "aquamarine",
    "azure",
    "beige",
    "bisque",
    "black",
    "blanchedalmond",
    "blue",
    "blueviolet",
    "brown",
    "burlywood",
    "cadetblue",
    "chartreuse",
    "chocolate",
    "coral",
    "cornflowerblue",
    "cornsilk",
    "crimson",
    "cyan",
    "darkblue",
    "darkcyan",
    "darkgoldenrod",
    "darkgray",
    "darkgreen",
    "darkkhaki",
    "darkmagenta",
    "darkolivegreen",
    "darkorange",
    "darkorchid",
    "darkred",
    "darksalmon",
    "darkseagreen",
    "darkslateblue",
    "darkslategray",
    "darkturquoise",
    "darkviolet",
    "deeppink",
    "deepskyblue",
    "dimgray",
    "dodgerblue",
    "firebrick",
    "floralwhite",
    "forestgreen",
    "fuchsia",
    "gainsboro",
    "ghostwhite",
    "gold",
    "goldenrod",
    "gray",
    "grey",
    "green",
    "greenyellow",
    "honeydew",
    "hotpink",
    "indianred",
    "indigo",
    "ivory",
    "khaki",
    "lavender",
    "lavenderblush",
    "lawngreen",
    "lemonchiffon",
    "lightblue",
    "lightcoral",
    "lightcyan",
    "lightgoldenrodyellow",
    "lightgray",
    "lightgreen",
    "lightpink",
    "lightsalmon",
    "lightseagreen",
    "lightskyblue",
    "lightslategray",
    "lightsteelblue",
    "lightyellow",
    "lime",
    "limegreen",
    "linen",
    "magenta",
    "maroon",
    "mediumaquamarine",
    "mediumblue",
    "mediumorchid",
    "mediumpurple",
    "mediumseagreen",
    "mediumslateblue",
    "mediumspringgreen",
    "mediumturquoise",
    "mediumvioletred",
    "midnightblue",
    "mintcream",
    "mistyrose",
    "moccasin",
    "navajowhite",
    "navy",
    "oldlace",
    "olive",
    "olivedrab",
    "orange",
    "orangered",
    "orchid",
    "palegoldenrod",
    "palegreen",
    "paleturquoise",
    "palevioletred",
    "papayawhip",
    "peachpuff",
    "peru",
    "pink",
    "plum",
    "powderblue",
    "purple",
    "rebeccapurple",
    "red",
    "rosybrown",
    "royalblue",
    "saddlebrown",
    "salmon",
    "sandybrown",
    "seagreen",
    "seashell",
    "sienna",
    "silver",
    "skyblue",
    "slateblue",
    "slategray",
    "snow",
    "springgreen",
    "steelblue",
    "tan",
    "teal",
    "thistle",
    "tomato",
    "turquoise",
    "violet",
    "wheat",
    "white",
    "whitesmoke",
    "yellow",
    "yellowgreen"
  ].map((name2) => ({ type: "constant", label: name2 })));
  var tags2 = /* @__PURE__ */ [
    "a",
    "abbr",
    "address",
    "article",
    "aside",
    "b",
    "bdi",
    "bdo",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "figcaption",
    "figure",
    "footer",
    "form",
    "header",
    "hgroup",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "meter",
    "nav",
    "ol",
    "output",
    "p",
    "pre",
    "ruby",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "tr",
    "u",
    "ul"
  ].map((name2) => ({ type: "type", label: name2 }));
  var identifier2 = /^[\w-]*/;
  var cssCompletionSource = (context) => {
    let { state, pos } = context, node = syntaxTree(state).resolveInner(pos, -1);
    if (node.name == "PropertyName")
      return { from: node.from, options: properties(), validFor: identifier2 };
    if (node.name == "ValueName")
      return { from: node.from, options: values, validFor: identifier2 };
    if (node.name == "PseudoClassName")
      return { from: node.from, options: pseudoClasses, validFor: identifier2 };
    if (node.name == "TagName") {
      for (let { parent } = node; parent; parent = parent.parent)
        if (parent.name == "Block")
          return { from: node.from, options: properties(), validFor: identifier2 };
      return { from: node.from, options: tags2, validFor: identifier2 };
    }
    if (!context.explicit)
      return null;
    let above = node.resolve(pos), before = above.childBefore(pos);
    if (before && before.name == ":" && above.name == "PseudoClassSelector")
      return { from: pos, options: pseudoClasses, validFor: identifier2 };
    if (before && before.name == ":" && above.name == "Declaration" || above.name == "ArgList")
      return { from: pos, options: values, validFor: identifier2 };
    if (above.name == "Block")
      return { from: pos, options: properties(), validFor: identifier2 };
    return null;
  };
  var cssLanguage = /* @__PURE__ */ LRLanguage.define({
    name: "css",
    parser: /* @__PURE__ */ parser4.configure({
      props: [
        /* @__PURE__ */ indentNodeProp.add({
          Declaration: /* @__PURE__ */ continuedIndent()
        }),
        /* @__PURE__ */ foldNodeProp.add({
          Block: foldInside
        })
      ]
    }),
    languageData: {
      commentTokens: { block: { open: "/*", close: "*/" } },
      indentOnInput: /^\s*\}$/,
      wordChars: "-"
    }
  });
  function css() {
    return new LanguageSupport(cssLanguage, cssLanguage.data.of({ autocomplete: cssCompletionSource }));
  }

  // node_modules/@codemirror/lang-html/dist/index.js
  var Targets = ["_blank", "_self", "_top", "_parent"];
  var Charsets = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
  var Methods = ["get", "post", "put", "delete"];
  var Encs = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
  var Bool = ["true", "false"];
  var S = {};
  var Tags = {
    a: {
      attrs: {
        href: null,
        ping: null,
        type: null,
        media: null,
        target: Targets,
        hreflang: null
      }
    },
    abbr: S,
    address: S,
    area: {
      attrs: {
        alt: null,
        coords: null,
        href: null,
        target: null,
        ping: null,
        media: null,
        hreflang: null,
        type: null,
        shape: ["default", "rect", "circle", "poly"]
      }
    },
    article: S,
    aside: S,
    audio: {
      attrs: {
        src: null,
        mediagroup: null,
        crossorigin: ["anonymous", "use-credentials"],
        preload: ["none", "metadata", "auto"],
        autoplay: ["autoplay"],
        loop: ["loop"],
        controls: ["controls"]
      }
    },
    b: S,
    base: { attrs: { href: null, target: Targets } },
    bdi: S,
    bdo: S,
    blockquote: { attrs: { cite: null } },
    body: S,
    br: S,
    button: {
      attrs: {
        form: null,
        formaction: null,
        name: null,
        value: null,
        autofocus: ["autofocus"],
        disabled: ["autofocus"],
        formenctype: Encs,
        formmethod: Methods,
        formnovalidate: ["novalidate"],
        formtarget: Targets,
        type: ["submit", "reset", "button"]
      }
    },
    canvas: { attrs: { width: null, height: null } },
    caption: S,
    center: S,
    cite: S,
    code: S,
    col: { attrs: { span: null } },
    colgroup: { attrs: { span: null } },
    command: {
      attrs: {
        type: ["command", "checkbox", "radio"],
        label: null,
        icon: null,
        radiogroup: null,
        command: null,
        title: null,
        disabled: ["disabled"],
        checked: ["checked"]
      }
    },
    data: { attrs: { value: null } },
    datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
    datalist: { attrs: { data: null } },
    dd: S,
    del: { attrs: { cite: null, datetime: null } },
    details: { attrs: { open: ["open"] } },
    dfn: S,
    div: S,
    dl: S,
    dt: S,
    em: S,
    embed: { attrs: { src: null, type: null, width: null, height: null } },
    eventsource: { attrs: { src: null } },
    fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
    figcaption: S,
    figure: S,
    footer: S,
    form: {
      attrs: {
        action: null,
        name: null,
        "accept-charset": Charsets,
        autocomplete: ["on", "off"],
        enctype: Encs,
        method: Methods,
        novalidate: ["novalidate"],
        target: Targets
      }
    },
    h1: S,
    h2: S,
    h3: S,
    h4: S,
    h5: S,
    h6: S,
    head: {
      children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
    },
    header: S,
    hgroup: S,
    hr: S,
    html: {
      attrs: { manifest: null }
    },
    i: S,
    iframe: {
      attrs: {
        src: null,
        srcdoc: null,
        name: null,
        width: null,
        height: null,
        sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
        seamless: ["seamless"]
      }
    },
    img: {
      attrs: {
        alt: null,
        src: null,
        ismap: null,
        usemap: null,
        width: null,
        height: null,
        crossorigin: ["anonymous", "use-credentials"]
      }
    },
    input: {
      attrs: {
        alt: null,
        dirname: null,
        form: null,
        formaction: null,
        height: null,
        list: null,
        max: null,
        maxlength: null,
        min: null,
        name: null,
        pattern: null,
        placeholder: null,
        size: null,
        src: null,
        step: null,
        value: null,
        width: null,
        accept: ["audio/*", "video/*", "image/*"],
        autocomplete: ["on", "off"],
        autofocus: ["autofocus"],
        checked: ["checked"],
        disabled: ["disabled"],
        formenctype: Encs,
        formmethod: Methods,
        formnovalidate: ["novalidate"],
        formtarget: Targets,
        multiple: ["multiple"],
        readonly: ["readonly"],
        required: ["required"],
        type: [
          "hidden",
          "text",
          "search",
          "tel",
          "url",
          "email",
          "password",
          "datetime",
          "date",
          "month",
          "week",
          "time",
          "datetime-local",
          "number",
          "range",
          "color",
          "checkbox",
          "radio",
          "file",
          "submit",
          "image",
          "reset",
          "button"
        ]
      }
    },
    ins: { attrs: { cite: null, datetime: null } },
    kbd: S,
    keygen: {
      attrs: {
        challenge: null,
        form: null,
        name: null,
        autofocus: ["autofocus"],
        disabled: ["disabled"],
        keytype: ["RSA"]
      }
    },
    label: { attrs: { for: null, form: null } },
    legend: S,
    li: { attrs: { value: null } },
    link: {
      attrs: {
        href: null,
        type: null,
        hreflang: null,
        media: null,
        sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
      }
    },
    map: { attrs: { name: null } },
    mark: S,
    menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
    meta: {
      attrs: {
        content: null,
        charset: Charsets,
        name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
        "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
      }
    },
    meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
    nav: S,
    noscript: S,
    object: {
      attrs: {
        data: null,
        type: null,
        name: null,
        usemap: null,
        form: null,
        width: null,
        height: null,
        typemustmatch: ["typemustmatch"]
      }
    },
    ol: {
      attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
      children: ["li", "script", "template", "ul", "ol"]
    },
    optgroup: { attrs: { disabled: ["disabled"], label: null } },
    option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
    output: { attrs: { for: null, form: null, name: null } },
    p: S,
    param: { attrs: { name: null, value: null } },
    pre: S,
    progress: { attrs: { value: null, max: null } },
    q: { attrs: { cite: null } },
    rp: S,
    rt: S,
    ruby: S,
    samp: S,
    script: {
      attrs: {
        type: ["text/javascript"],
        src: null,
        async: ["async"],
        defer: ["defer"],
        charset: Charsets
      }
    },
    section: S,
    select: {
      attrs: {
        form: null,
        name: null,
        size: null,
        autofocus: ["autofocus"],
        disabled: ["disabled"],
        multiple: ["multiple"]
      }
    },
    slot: { attrs: { name: null } },
    small: S,
    source: { attrs: { src: null, type: null, media: null } },
    span: S,
    strong: S,
    style: {
      attrs: {
        type: ["text/css"],
        media: null,
        scoped: null
      }
    },
    sub: S,
    summary: S,
    sup: S,
    table: S,
    tbody: S,
    td: { attrs: { colspan: null, rowspan: null, headers: null } },
    template: S,
    textarea: {
      attrs: {
        dirname: null,
        form: null,
        maxlength: null,
        name: null,
        placeholder: null,
        rows: null,
        cols: null,
        autofocus: ["autofocus"],
        disabled: ["disabled"],
        readonly: ["readonly"],
        required: ["required"],
        wrap: ["soft", "hard"]
      }
    },
    tfoot: S,
    th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
    thead: S,
    time: { attrs: { datetime: null } },
    title: S,
    tr: S,
    track: {
      attrs: {
        src: null,
        label: null,
        default: null,
        kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
        srclang: null
      }
    },
    ul: { children: ["li", "script", "template", "ul", "ol"] },
    var: S,
    video: {
      attrs: {
        src: null,
        poster: null,
        width: null,
        height: null,
        crossorigin: ["anonymous", "use-credentials"],
        preload: ["auto", "metadata", "none"],
        autoplay: ["autoplay"],
        mediagroup: ["movie"],
        muted: ["muted"],
        controls: ["controls"]
      }
    },
    wbr: S
  };
  var GlobalAttrs = {
    accesskey: null,
    class: null,
    contenteditable: Bool,
    contextmenu: null,
    dir: ["ltr", "rtl", "auto"],
    draggable: ["true", "false", "auto"],
    dropzone: ["copy", "move", "link", "string:", "file:"],
    hidden: ["hidden"],
    id: null,
    inert: ["inert"],
    itemid: null,
    itemprop: null,
    itemref: null,
    itemscope: ["itemscope"],
    itemtype: null,
    lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
    spellcheck: Bool,
    autocorrect: Bool,
    autocapitalize: Bool,
    style: null,
    tabindex: null,
    title: null,
    translate: ["yes", "no"],
    onclick: null,
    rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
    role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
    "aria-activedescendant": null,
    "aria-atomic": Bool,
    "aria-autocomplete": ["inline", "list", "both", "none"],
    "aria-busy": Bool,
    "aria-checked": ["true", "false", "mixed", "undefined"],
    "aria-controls": null,
    "aria-describedby": null,
    "aria-disabled": Bool,
    "aria-dropeffect": null,
    "aria-expanded": ["true", "false", "undefined"],
    "aria-flowto": null,
    "aria-grabbed": ["true", "false", "undefined"],
    "aria-haspopup": Bool,
    "aria-hidden": Bool,
    "aria-invalid": ["true", "false", "grammar", "spelling"],
    "aria-label": null,
    "aria-labelledby": null,
    "aria-level": null,
    "aria-live": ["off", "polite", "assertive"],
    "aria-multiline": Bool,
    "aria-multiselectable": Bool,
    "aria-owns": null,
    "aria-posinset": null,
    "aria-pressed": ["true", "false", "mixed", "undefined"],
    "aria-readonly": Bool,
    "aria-relevant": null,
    "aria-required": Bool,
    "aria-selected": ["true", "false", "undefined"],
    "aria-setsize": null,
    "aria-sort": ["ascending", "descending", "none", "other"],
    "aria-valuemax": null,
    "aria-valuemin": null,
    "aria-valuenow": null,
    "aria-valuetext": null
  };
  var Schema = class {
    constructor(extraTags, extraAttrs) {
      this.tags = Object.assign(Object.assign({}, Tags), extraTags);
      this.globalAttrs = Object.assign(Object.assign({}, GlobalAttrs), extraAttrs);
      this.allTags = Object.keys(this.tags);
      this.globalAttrNames = Object.keys(this.globalAttrs);
    }
  };
  Schema.default = /* @__PURE__ */ new Schema();
  function elementName2(doc3, tree, max2 = doc3.length) {
    if (!tree)
      return "";
    let tag = tree.firstChild;
    let name2 = tag && tag.getChild("TagName");
    return name2 ? doc3.sliceString(name2.from, Math.min(name2.to, max2)) : "";
  }
  function findParentElement(tree, skip = false) {
    for (let cur2 = tree.parent; cur2; cur2 = cur2.parent)
      if (cur2.name == "Element") {
        if (skip)
          skip = false;
        else
          return cur2;
      }
    return null;
  }
  function allowedChildren(doc3, tree, schema) {
    let parentInfo = schema.tags[elementName2(doc3, findParentElement(tree, true))];
    return (parentInfo === null || parentInfo === void 0 ? void 0 : parentInfo.children) || schema.allTags;
  }
  function openTags(doc3, tree) {
    let open = [];
    for (let parent = tree; parent = findParentElement(parent); ) {
      let tagName2 = elementName2(doc3, parent);
      if (tagName2 && parent.lastChild.name == "CloseTag")
        break;
      if (tagName2 && open.indexOf(tagName2) < 0 && (tree.name == "EndTag" || tree.from >= parent.firstChild.to))
        open.push(tagName2);
    }
    return open;
  }
  var identifier3 = /^[:\-\.\w\u00b7-\uffff]*$/;
  function completeTag(state, schema, tree, from3, to) {
    let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
    return {
      from: from3,
      to,
      options: allowedChildren(state.doc, tree, schema).map((tagName2) => ({ label: tagName2, type: "type" })).concat(openTags(state.doc, tree).map((tag, i) => ({
        label: "/" + tag,
        apply: "/" + tag + end,
        type: "type",
        boost: 99 - i
      }))),
      validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
    };
  }
  function completeCloseTag(state, tree, from3, to) {
    let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
    return {
      from: from3,
      to,
      options: openTags(state.doc, tree).map((tag, i) => ({ label: tag, apply: tag + end, type: "type", boost: 99 - i })),
      validFor: identifier3
    };
  }
  function completeStartTag(state, schema, tree, pos) {
    let options = [], level = 0;
    for (let tagName2 of allowedChildren(state.doc, tree, schema))
      options.push({ label: "<" + tagName2, type: "type" });
    for (let open of openTags(state.doc, tree))
      options.push({ label: "</" + open + ">", type: "type", boost: 99 - level++ });
    return { from: pos, to: pos, options, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
  }
  function completeAttrName(state, schema, tree, from3, to) {
    let elt2 = findParentElement(tree), info = elt2 ? schema.tags[elementName2(state.doc, elt2)] : null;
    let names = info && info.attrs ? Object.keys(info.attrs).concat(schema.globalAttrNames) : schema.globalAttrNames;
    return {
      from: from3,
      to,
      options: names.map((attrName) => ({ label: attrName, type: "property" })),
      validFor: identifier3
    };
  }
  function completeAttrValue(state, schema, tree, from3, to) {
    var _a2;
    let nameNode = (_a2 = tree.parent) === null || _a2 === void 0 ? void 0 : _a2.getChild("AttributeName");
    let options = [], token = void 0;
    if (nameNode) {
      let attrName = state.sliceDoc(nameNode.from, nameNode.to);
      let attrs = schema.globalAttrs[attrName];
      if (!attrs) {
        let elt2 = findParentElement(tree), info = elt2 ? schema.tags[elementName2(state.doc, elt2)] : null;
        attrs = (info === null || info === void 0 ? void 0 : info.attrs) && info.attrs[attrName];
      }
      if (attrs) {
        let base2 = state.sliceDoc(from3, to).toLowerCase(), quoteStart = '"', quoteEnd = '"';
        if (/^['"]/.test(base2)) {
          token = base2[0] == '"' ? /^[^"]*$/ : /^[^']*$/;
          quoteStart = "";
          quoteEnd = state.sliceDoc(to, to + 1) == base2[0] ? "" : base2[0];
          base2 = base2.slice(1);
          from3++;
        } else {
          token = /^[^\s<>='"]*$/;
        }
        for (let value of attrs)
          options.push({ label: value, apply: quoteStart + value + quoteEnd, type: "constant" });
      }
    }
    return { from: from3, to, options, validFor: token };
  }
  function htmlCompletionFor(schema, context) {
    let { state, pos } = context, around = syntaxTree(state).resolveInner(pos), tree = around.resolve(pos, -1);
    for (let scan = pos, before; around == tree && (before = tree.childBefore(scan)); ) {
      let last2 = before.lastChild;
      if (!last2 || !last2.type.isError || last2.from < last2.to)
        break;
      around = tree = before;
      scan = last2.from;
    }
    if (tree.name == "TagName") {
      return tree.parent && /CloseTag$/.test(tree.parent.name) ? completeCloseTag(state, tree, tree.from, pos) : completeTag(state, schema, tree, tree.from, pos);
    } else if (tree.name == "StartTag") {
      return completeTag(state, schema, tree, pos, pos);
    } else if (tree.name == "StartCloseTag" || tree.name == "IncompleteCloseTag") {
      return completeCloseTag(state, tree, pos, pos);
    } else if (context.explicit && (tree.name == "OpenTag" || tree.name == "SelfClosingTag") || tree.name == "AttributeName") {
      return completeAttrName(state, schema, tree, tree.name == "AttributeName" ? tree.from : pos, pos);
    } else if (tree.name == "Is" || tree.name == "AttributeValue" || tree.name == "UnquotedAttributeValue") {
      return completeAttrValue(state, schema, tree, tree.name == "Is" ? pos : tree.from, pos);
    } else if (context.explicit && (around.name == "Element" || around.name == "Text" || around.name == "Document")) {
      return completeStartTag(state, schema, tree, pos);
    } else {
      return null;
    }
  }
  function htmlCompletionSourceWith(config2) {
    let { extraTags, extraGlobalAttributes: extraAttrs } = config2;
    let schema = extraAttrs || extraTags ? new Schema(extraTags, extraAttrs) : Schema.default;
    return (context) => htmlCompletionFor(schema, context);
  }
  var htmlLanguage = /* @__PURE__ */ LRLanguage.define({
    name: "html",
    parser: /* @__PURE__ */ parser3.configure({
      props: [
        /* @__PURE__ */ indentNodeProp.add({
          Element(context) {
            let after = /^(\s*)(<\/)?/.exec(context.textAfter);
            if (context.node.to <= context.pos + after[0].length)
              return context.continue();
            return context.lineIndent(context.node.from) + (after[2] ? 0 : context.unit);
          },
          "OpenTag CloseTag SelfClosingTag"(context) {
            return context.column(context.node.from) + context.unit;
          },
          Document(context) {
            if (context.pos + /\s*/.exec(context.textAfter)[0].length < context.node.to)
              return context.continue();
            let endElt = null, close;
            for (let cur2 = context.node; ; ) {
              let last2 = cur2.lastChild;
              if (!last2 || last2.name != "Element" || last2.to != cur2.to)
                break;
              endElt = cur2 = last2;
            }
            if (endElt && !((close = endElt.lastChild) && (close.name == "CloseTag" || close.name == "SelfClosingTag")))
              return context.lineIndent(endElt.from) + context.unit;
            return null;
          }
        }),
        /* @__PURE__ */ foldNodeProp.add({
          Element(node) {
            let first = node.firstChild, last2 = node.lastChild;
            if (!first || first.name != "OpenTag")
              return null;
            return { from: first.to, to: last2.name == "CloseTag" ? last2.from : node.to };
          }
        })
      ],
      wrap: /* @__PURE__ */ configureNesting([
        {
          tag: "script",
          attrs: (attrs) => attrs.type == "text/typescript" || attrs.lang == "ts",
          parser: typescriptLanguage.parser
        },
        {
          tag: "script",
          attrs: (attrs) => attrs.type == "text/jsx",
          parser: jsxLanguage.parser
        },
        {
          tag: "script",
          attrs: (attrs) => attrs.type == "text/typescript-jsx",
          parser: tsxLanguage.parser
        },
        {
          tag: "script",
          attrs(attrs) {
            return !attrs.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(attrs.type);
          },
          parser: javascriptLanguage.parser
        },
        {
          tag: "style",
          attrs(attrs) {
            return (!attrs.lang || attrs.lang == "css") && (!attrs.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(attrs.type));
          },
          parser: cssLanguage.parser
        }
      ])
    }),
    languageData: {
      commentTokens: { block: { open: "<!--", close: "-->" } },
      indentOnInput: /^\s*<\/\w+\W$/,
      wordChars: "-._"
    }
  });
  function html(config2 = {}) {
    let lang = htmlLanguage;
    if (config2.matchClosingTags === false)
      lang = lang.configure({ dialect: "noMatch" });
    if (config2.selfClosingTags === true)
      lang = lang.configure({ dialect: "selfClosing" });
    return new LanguageSupport(lang, [
      htmlLanguage.data.of({ autocomplete: htmlCompletionSourceWith(config2) }),
      config2.autoCloseTags !== false ? autoCloseTags2 : [],
      javascript().support,
      css().support
    ]);
  }
  var autoCloseTags2 = /* @__PURE__ */ EditorView.inputHandler.of((view2, from3, to, text3) => {
    if (view2.composing || view2.state.readOnly || from3 != to || text3 != ">" && text3 != "/" || !htmlLanguage.isActiveAt(view2.state, from3, -1))
      return false;
    let { state } = view2;
    let changes = state.changeByRange((range) => {
      var _a2, _b, _c;
      let { head } = range, around = syntaxTree(state).resolveInner(head, -1), name2;
      if (around.name == "TagName" || around.name == "StartTag")
        around = around.parent;
      if (text3 == ">" && around.name == "OpenTag") {
        if (((_b = (_a2 = around.parent) === null || _a2 === void 0 ? void 0 : _a2.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "CloseTag" && (name2 = elementName2(state.doc, around.parent, head))) {
          let hasRightBracket = view2.state.doc.sliceString(head, head + 1) === ">";
          let insert2 = `${hasRightBracket ? "" : ">"}</${name2}>`;
          return { range: EditorSelection.cursor(head + 1), changes: { from: head + (hasRightBracket ? 1 : 0), insert: insert2 } };
        }
      } else if (text3 == "/" && around.name == "OpenTag") {
        let empty2 = around.parent, base2 = empty2 === null || empty2 === void 0 ? void 0 : empty2.parent;
        if (empty2.from == head - 1 && ((_c = base2.lastChild) === null || _c === void 0 ? void 0 : _c.name) != "CloseTag" && (name2 = elementName2(state.doc, base2, head))) {
          let hasRightBracket = view2.state.doc.sliceString(head, head + 1) === ">";
          let insert2 = `/${name2}${hasRightBracket ? "" : ">"}`;
          let pos = head + insert2.length + (hasRightBracket ? 1 : 0);
          return { range: EditorSelection.cursor(pos), changes: { from: head, insert: insert2 } };
        }
      }
      return { range };
    });
    if (changes.changes.empty)
      return false;
    view2.dispatch(changes, { userEvent: "input.type", scrollIntoView: true });
    return true;
  });

  // node_modules/@codemirror/lang-markdown/dist/index.js
  var data = /* @__PURE__ */ defineLanguageFacet({ block: { open: "<!--", close: "-->" } });
  var commonmark = /* @__PURE__ */ parser2.configure({
    props: [
      /* @__PURE__ */ foldNodeProp.add((type) => {
        if (!type.is("Block") || type.is("Document"))
          return void 0;
        return (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });
      }),
      /* @__PURE__ */ indentNodeProp.add({
        Document: () => null
      }),
      /* @__PURE__ */ languageDataProp.add({
        Document: data
      })
    ]
  });
  function mkLang(parser5) {
    return new Language(data, parser5, [], "markdown");
  }
  var commonmarkLanguage = /* @__PURE__ */ mkLang(commonmark);
  var extended = /* @__PURE__ */ commonmark.configure([GFM, Subscript, Superscript, Emoji]);
  var markdownLanguage = /* @__PURE__ */ mkLang(extended);
  function getCodeParser(languages, defaultLanguage) {
    return (info) => {
      if (info && languages) {
        let found = null;
        info = /\S*/.exec(info)[0];
        if (typeof languages == "function")
          found = languages(info);
        else
          found = LanguageDescription.matchLanguageName(languages, info, true);
        if (found instanceof LanguageDescription)
          return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());
        else if (found)
          return found.parser;
      }
      return defaultLanguage ? defaultLanguage.parser : null;
    };
  }
  var Context = class {
    constructor(node, from3, to, spaceBefore, spaceAfter, type, item) {
      this.node = node;
      this.from = from3;
      this.to = to;
      this.spaceBefore = spaceBefore;
      this.spaceAfter = spaceAfter;
      this.type = type;
      this.item = item;
    }
    blank(maxWidth, trailing = true) {
      let result = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
      if (maxWidth != null) {
        while (result.length < maxWidth)
          result += " ";
        return result;
      } else {
        for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)
          result += " ";
        return result + (trailing ? this.spaceAfter : "");
      }
    }
    marker(doc3, add3) {
      let number2 = this.node.name == "OrderedList" ? String(+itemNumber(this.item, doc3)[2] + add3) : "";
      return this.spaceBefore + number2 + this.type + this.spaceAfter;
    }
  };
  function getContext(node, doc3) {
    let nodes = [];
    for (let cur2 = node; cur2 && cur2.name != "Document"; cur2 = cur2.parent) {
      if (cur2.name == "ListItem" || cur2.name == "Blockquote" || cur2.name == "FencedCode")
        nodes.push(cur2);
    }
    let context = [];
    for (let i = nodes.length - 1; i >= 0; i--) {
      let node2 = nodes[i], match;
      let line = doc3.lineAt(node2.from), startPos = node2.from - line.from;
      if (node2.name == "FencedCode") {
        context.push(new Context(node2, startPos, startPos, "", "", "", null));
      } else if (node2.name == "Blockquote" && (match = /^[ \t]*>( ?)/.exec(line.text.slice(startPos)))) {
        context.push(new Context(node2, startPos, startPos + match[0].length, "", match[1], ">", null));
      } else if (node2.name == "ListItem" && node2.parent.name == "OrderedList" && (match = /^([ \t]*)\d+([.)])([ \t]*)/.exec(line.text.slice(startPos)))) {
        let after = match[3], len = match[0].length;
        if (after.length >= 4) {
          after = after.slice(0, after.length - 4);
          len -= 4;
        }
        context.push(new Context(node2.parent, startPos, startPos + len, match[1], after, match[2], node2));
      } else if (node2.name == "ListItem" && node2.parent.name == "BulletList" && (match = /^([ \t]*)([-+*])([ \t]{1,4}\[[ xX]\])?([ \t]+)/.exec(line.text.slice(startPos)))) {
        let after = match[4], len = match[0].length;
        if (after.length > 4) {
          after = after.slice(0, after.length - 4);
          len -= 4;
        }
        let type = match[2];
        if (match[3])
          type += match[3].replace(/[xX]/, " ");
        context.push(new Context(node2.parent, startPos, startPos + len, match[1], after, type, node2));
      }
    }
    return context;
  }
  function itemNumber(item, doc3) {
    return /^(\s*)(\d+)(?=[.)])/.exec(doc3.sliceString(item.from, item.from + 10));
  }
  function renumberList(after, doc3, changes, offset = 0) {
    for (let prev = -1, node = after; ; ) {
      if (node.name == "ListItem") {
        let m2 = itemNumber(node, doc3);
        let number2 = +m2[2];
        if (prev >= 0) {
          if (number2 != prev + 1)
            return;
          changes.push({ from: node.from + m2[1].length, to: node.from + m2[0].length, insert: String(prev + 2 + offset) });
        }
        prev = number2;
      }
      let next = node.nextSibling;
      if (!next)
        break;
      node = next;
    }
  }
  var insertNewlineContinueMarkup = ({ state, dispatch: dispatch2 }) => {
    let tree = syntaxTree(state), { doc: doc3 } = state;
    let dont = null, changes = state.changeByRange((range) => {
      if (!range.empty || !markdownLanguage.isActiveAt(state, range.from))
        return dont = { range };
      let pos = range.from, line = doc3.lineAt(pos);
      let context = getContext(tree.resolveInner(pos, -1), doc3);
      while (context.length && context[context.length - 1].from > pos - line.from)
        context.pop();
      if (!context.length)
        return dont = { range };
      let inner = context[context.length - 1];
      if (inner.to - inner.spaceAfter.length > pos - line.from)
        return dont = { range };
      let emptyLine = pos >= inner.to - inner.spaceAfter.length && !/\S/.test(line.text.slice(inner.to));
      if (inner.item && emptyLine) {
        if (inner.node.firstChild.to >= pos || line.from > 0 && !/[^\s>]/.test(doc3.lineAt(line.from - 1).text)) {
          let next = context.length > 1 ? context[context.length - 2] : null;
          let delTo, insert3 = "";
          if (next && next.item) {
            delTo = line.from + next.from;
            insert3 = next.marker(doc3, 1);
          } else {
            delTo = line.from + (next ? next.to : 0);
          }
          let changes3 = [{ from: delTo, to: pos, insert: insert3 }];
          if (inner.node.name == "OrderedList")
            renumberList(inner.item, doc3, changes3, -2);
          if (next && next.node.name == "OrderedList")
            renumberList(next.item, doc3, changes3);
          return { range: EditorSelection.cursor(delTo + insert3.length), changes: changes3 };
        } else {
          let insert3 = "";
          for (let i = 0, e = context.length - 2; i <= e; i++) {
            insert3 += context[i].blank(i < e ? context[i + 1].from - insert3.length : null, i < e);
          }
          insert3 += state.lineBreak;
          return { range: EditorSelection.cursor(pos + insert3.length), changes: { from: line.from, insert: insert3 } };
        }
      }
      if (inner.node.name == "Blockquote" && emptyLine && line.from) {
        let prevLine = doc3.lineAt(line.from - 1), quoted = />\s*$/.exec(prevLine.text);
        if (quoted && quoted.index == inner.from) {
          let changes3 = state.changes([
            { from: prevLine.from + quoted.index, to: prevLine.to },
            { from: line.from + inner.from, to: line.to }
          ]);
          return { range: range.map(changes3), changes: changes3 };
        }
      }
      let changes2 = [];
      if (inner.node.name == "OrderedList")
        renumberList(inner.item, doc3, changes2);
      let continued = inner.item && inner.item.from < line.from;
      let insert2 = "";
      if (!continued || /^[\s\d.)\-+*>]*/.exec(line.text)[0].length >= inner.to) {
        for (let i = 0, e = context.length - 1; i <= e; i++) {
          insert2 += i == e && !continued ? context[i].marker(doc3, 1) : context[i].blank(i < e ? context[i + 1].from - insert2.length : null);
        }
      }
      let from3 = pos;
      while (from3 > line.from && /\s/.test(line.text.charAt(from3 - line.from - 1)))
        from3--;
      insert2 = state.lineBreak + insert2;
      changes2.push({ from: from3, to: pos, insert: insert2 });
      return { range: EditorSelection.cursor(from3 + insert2.length), changes: changes2 };
    });
    if (dont)
      return false;
    dispatch2(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
  function isMark(node) {
    return node.name == "QuoteMark" || node.name == "ListMark";
  }
  function contextNodeForDelete(tree, pos) {
    let node = tree.resolveInner(pos, -1), scan = pos;
    if (isMark(node)) {
      scan = node.from;
      node = node.parent;
    }
    for (let prev; prev = node.childBefore(scan); ) {
      if (isMark(prev)) {
        scan = prev.from;
      } else if (prev.name == "OrderedList" || prev.name == "BulletList") {
        node = prev.lastChild;
        scan = node.to;
      } else {
        break;
      }
    }
    return node;
  }
  var deleteMarkupBackward = ({ state, dispatch: dispatch2 }) => {
    let tree = syntaxTree(state);
    let dont = null, changes = state.changeByRange((range) => {
      let pos = range.from, { doc: doc3 } = state;
      if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {
        let line = doc3.lineAt(pos);
        let context = getContext(contextNodeForDelete(tree, pos), doc3);
        if (context.length) {
          let inner = context[context.length - 1];
          let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);
          if (pos - line.from > spaceEnd && !/\S/.test(line.text.slice(spaceEnd, pos - line.from)))
            return {
              range: EditorSelection.cursor(line.from + spaceEnd),
              changes: { from: line.from + spaceEnd, to: pos }
            };
          if (pos - line.from == spaceEnd) {
            let start = line.from + inner.from;
            if (inner.item && inner.node.from < inner.item.from && /\S/.test(line.text.slice(inner.from, inner.to)))
              return { range, changes: { from: start, to: line.from + inner.to, insert: inner.blank(inner.to - inner.from) } };
            if (start < pos)
              return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };
          }
        }
      }
      return dont = { range };
    });
    if (dont)
      return false;
    dispatch2(state.update(changes, { scrollIntoView: true, userEvent: "delete" }));
    return true;
  };
  var markdownKeymap = [
    { key: "Enter", run: insertNewlineContinueMarkup },
    { key: "Backspace", run: deleteMarkupBackward }
  ];
  var htmlNoMatch = /* @__PURE__ */ html({ matchClosingTags: false });
  function markdown(config2 = {}) {
    let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser: parser5 } = commonmarkLanguage } = config2;
    if (!(parser5 instanceof MarkdownParser))
      throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
    let extensions = config2.extensions ? [config2.extensions] : [];
    let support = [htmlNoMatch.support], defaultCode;
    if (defaultCodeLanguage instanceof LanguageSupport) {
      support.push(defaultCodeLanguage.support);
      defaultCode = defaultCodeLanguage.language;
    } else if (defaultCodeLanguage) {
      defaultCode = defaultCodeLanguage;
    }
    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : void 0;
    extensions.push(parseCode({ codeParser, htmlParser: htmlNoMatch.language.parser }));
    if (addKeymap)
      support.push(Prec.high(keymap.of(markdownKeymap)));
    return new LanguageSupport(mkLang(parser5.configure(extensions)), support);
  }

  // src/editor/components/codeEditor.ts
  var ExtractInputWidget = class extends WidgetType {
    constructor(name2, value, from3, to, dispatch2) {
      super();
      this.name = name2;
      this.value = value;
      this.from = from3;
      this.to = to;
      this.dispatch = dispatch2;
    }
    eq(other) {
      return other.name === this.name && other.value === this.value;
    }
    toDOM(view2) {
      let wrap3 = document.createElement("span");
      wrap3.setAttribute("aria-hidden", "true");
      wrap3.className = "cm-extract-input";
      let button = wrap3.appendChild(document.createElement("button"));
      button.textContent = `Extract input ${this.name} = ${this.value}`;
      button.addEventListener("click", () => {
        const randid = create_randid();
        const newText = view2.state.doc.replace(this.from, this.to, Text.of([""]));
        this.dispatch(UpdateNode, {
          node: view2.state.field(code_editor_nodeid_field),
          property: "value",
          value: newText.sliceString(0, newText.length, "\n")
        });
        this.dispatch(CreateNode, {
          node: { id: randid, value: this.value },
          child: view2.state.field(code_editor_nodeid_field),
          child_as: this.name
        });
      });
      return wrap3;
    }
    ignoreEvent(event) {
      return false;
    }
  };
  var code_editor_nodeid = StateEffect.define();
  var code_editor_nodeid_field = StateField.define({
    create() {
      return "";
    },
    update(value, transaction) {
      return transaction.effects.filter((e) => e.is(code_editor_nodeid))?.[0]?.value ?? value;
    }
  });
  var init_code_editor = (dispatch2, { html_id }) => {
    requestAnimationFrame(() => {
      const languageConf = new Compartment();
      const autoLanguage = EditorState.transactionExtender.of((tr) => {
        if (!tr.docChanged)
          return null;
        let docLang = document.getElementsByClassName("markdown").length > 0 ? "markdown" : "javascript";
        let stateLang = tr.startState.facet(language) == markdownLanguage ? "markdown" : "javascript";
        if (docLang === stateLang)
          return null;
        return {
          effects: languageConf.reconfigure(docLang === "markdown" ? markdown() : javascript())
        };
      });
      const background = "#111";
      const highlightBackground = "#00000033";
      const code_editor = new EditorView({ extensions: [
        basicSetup,
        EditorView.theme({
          "&": {
            "backgroundColor": background
          },
          ".cm-content": {
            caretColor: "#66ccff",
            whiteSpace: "pre-wrap",
            width: "325px"
          },
          ".cm-gutters": {
            backgroundColor: background,
            outline: "1px solid #515a6b"
          },
          "&.cm-activeLine, .cm-activeLine": {
            backgroundColor: highlightBackground
          },
          "&.cm-focused .cm-cursor": {
            borderLeftColor: "#fff"
          },
          "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, ::selection": {
            backgroundColor: "#233"
          }
        }, { dark: true }),
        languageConf.of(javascript()),
        autoLanguage,
        ViewPlugin.define((view2) => {
          const viewfn = {
            decorations: RangeSet.of([]),
            update: (viewUpdate) => {
              const widgets = [];
              if (viewUpdate.state.selection.ranges.length > 0) {
                syntaxTree(viewUpdate.state).iterate({
                  to: viewUpdate.state.selection.ranges[0].to,
                  from: viewUpdate.state.selection.ranges[0].from,
                  enter: (node) => {
                    if (node.name === "VariableDeclaration") {
                      const nameNode = node.node.getChild("VariableDefinition");
                      const valueNode = node.node.getChild("String", "VariableDefinition") ?? node.node.getChild("Number", "VariableDefinition");
                      if (nameNode && valueNode) {
                        const varName = viewUpdate.state.sliceDoc(nameNode.from, nameNode.to);
                        const varValue = viewUpdate.state.sliceDoc(valueNode.from, valueNode.to);
                        console.log(`${varName} = ${varValue}`);
                        widgets.push(Decoration.widget({ widget: new ExtractInputWidget(varName, varValue, node.from, node.to, dispatch2) }).range(node.to));
                      }
                    }
                  }
                });
              }
              const decset = Decoration.set(widgets);
              viewfn.decorations = decset;
              return decset;
            }
          };
          return viewfn;
        }, {
          decorations: (v) => v.decorations
        }),
        code_editor_nodeid_field,
        EditorView.domEventHandlers({
          "blur": () => {
            dispatch2(UpdateNode, {
              node: code_editor.state.field(code_editor_nodeid_field),
              property: "value",
              value: code_editor.state.doc.sliceString(0, code_editor.state.doc.length, "\n")
            });
          }
        })
      ], parent: document.getElementById(`${html_id}-code-editor`) });
      dispatch2((s) => ({ ...s, code_editor, code_editor_nodeid }));
    });
  };

  // node_modules/idb/build/wrap-idb-value.js
  var instanceOfAny = (object2, constructors) => constructors.some((c2) => object2 instanceof c2);
  var idbProxyableTypes;
  var cursorAdvanceMethods;
  function getIdbProxyableTypes() {
    return idbProxyableTypes || (idbProxyableTypes = [
      IDBDatabase,
      IDBObjectStore,
      IDBIndex,
      IDBCursor,
      IDBTransaction
    ]);
  }
  function getCursorAdvanceMethods() {
    return cursorAdvanceMethods || (cursorAdvanceMethods = [
      IDBCursor.prototype.advance,
      IDBCursor.prototype.continue,
      IDBCursor.prototype.continuePrimaryKey
    ]);
  }
  var cursorRequestMap = /* @__PURE__ */ new WeakMap();
  var transactionDoneMap = /* @__PURE__ */ new WeakMap();
  var transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
  var transformCache = /* @__PURE__ */ new WeakMap();
  var reverseTransformCache = /* @__PURE__ */ new WeakMap();
  function promisifyRequest(request) {
    const promise = new Promise((resolve2, reject2) => {
      const unlisten = () => {
        request.removeEventListener("success", success);
        request.removeEventListener("error", error);
      };
      const success = () => {
        resolve2(wrap(request.result));
        unlisten();
      };
      const error = () => {
        reject2(request.error);
        unlisten();
      };
      request.addEventListener("success", success);
      request.addEventListener("error", error);
    });
    promise.then((value) => {
      if (value instanceof IDBCursor) {
        cursorRequestMap.set(value, request);
      }
    }).catch(() => {
    });
    reverseTransformCache.set(promise, request);
    return promise;
  }
  function cacheDonePromiseForTransaction(tx) {
    if (transactionDoneMap.has(tx))
      return;
    const done = new Promise((resolve2, reject2) => {
      const unlisten = () => {
        tx.removeEventListener("complete", complete);
        tx.removeEventListener("error", error);
        tx.removeEventListener("abort", error);
      };
      const complete = () => {
        resolve2();
        unlisten();
      };
      const error = () => {
        reject2(tx.error || new DOMException("AbortError", "AbortError"));
        unlisten();
      };
      tx.addEventListener("complete", complete);
      tx.addEventListener("error", error);
      tx.addEventListener("abort", error);
    });
    transactionDoneMap.set(tx, done);
  }
  var idbProxyTraps = {
    get(target, prop, receiver) {
      if (target instanceof IDBTransaction) {
        if (prop === "done")
          return transactionDoneMap.get(target);
        if (prop === "objectStoreNames") {
          return target.objectStoreNames || transactionStoreNamesMap.get(target);
        }
        if (prop === "store") {
          return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
        }
      }
      return wrap(target[prop]);
    },
    set(target, prop, value) {
      target[prop] = value;
      return true;
    },
    has(target, prop) {
      if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
        return true;
      }
      return prop in target;
    }
  };
  function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
  }
  function wrapFunction(func) {
    if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
      return function(storeNames, ...args2) {
        const tx = func.call(unwrap(this), storeNames, ...args2);
        transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
        return wrap(tx);
      };
    }
    if (getCursorAdvanceMethods().includes(func)) {
      return function(...args2) {
        func.apply(unwrap(this), args2);
        return wrap(cursorRequestMap.get(this));
      };
    }
    return function(...args2) {
      return wrap(func.apply(unwrap(this), args2));
    };
  }
  function transformCachableValue(value) {
    if (typeof value === "function")
      return wrapFunction(value);
    if (value instanceof IDBTransaction)
      cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes()))
      return new Proxy(value, idbProxyTraps);
    return value;
  }
  function wrap(value) {
    if (value instanceof IDBRequest)
      return promisifyRequest(value);
    if (transformCache.has(value))
      return transformCache.get(value);
    const newValue = transformCachableValue(value);
    if (newValue !== value) {
      transformCache.set(value, newValue);
      reverseTransformCache.set(newValue, value);
    }
    return newValue;
  }
  var unwrap = (value) => reverseTransformCache.get(value);

  // node_modules/idb/build/index.js
  function openDB(name2, version, { blocked, upgrade, blocking, terminated } = {}) {
    const request = indexedDB.open(name2, version);
    const openPromise = wrap(request);
    if (upgrade) {
      request.addEventListener("upgradeneeded", (event) => {
        upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
      });
    }
    if (blocked) {
      request.addEventListener("blocked", (event) => blocked(
        event.oldVersion,
        event.newVersion,
        event
      ));
    }
    openPromise.then((db) => {
      if (terminated)
        db.addEventListener("close", () => terminated());
      if (blocking) {
        db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
      }
    }).catch(() => {
    });
    return openPromise;
  }
  var readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
  var writeMethods = ["put", "add", "delete", "clear"];
  var cachedMethods = /* @__PURE__ */ new Map();
  function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
      return;
    }
    if (cachedMethods.get(prop))
      return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, "");
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (!(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {
      return;
    }
    const method = async function(storeName, ...args2) {
      const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
      let target2 = tx.store;
      if (useIndex)
        target2 = target2.index(args2.shift());
      return (await Promise.all([
        target2[targetFuncName](...args2),
        isWrite && tx.done
      ]))[0];
    };
    cachedMethods.set(prop, method);
    return method;
  }
  replaceTraps((oldTraps) => ({
    ...oldTraps,
    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
  }));

  // node_modules/lib0/map.js
  var create = () => /* @__PURE__ */ new Map();
  var copy = (m2) => {
    const r = create();
    m2.forEach((v, k) => {
      r.set(k, v);
    });
    return r;
  };
  var setIfUndefined = (map3, key, createT) => {
    let set3 = map3.get(key);
    if (set3 === void 0) {
      map3.set(key, set3 = createT());
    }
    return set3;
  };
  var map2 = (m2, f) => {
    const res = [];
    for (const [key, value] of m2) {
      res.push(f(value, key));
    }
    return res;
  };
  var any = (m2, f) => {
    for (const [key, value] of m2) {
      if (f(value, key)) {
        return true;
      }
    }
    return false;
  };

  // node_modules/lib0/set.js
  var create2 = () => /* @__PURE__ */ new Set();

  // node_modules/lib0/array.js
  var last = (arr) => arr[arr.length - 1];
  var appendTo = (dest, src) => {
    for (let i = 0; i < src.length; i++) {
      dest.push(src[i]);
    }
  };
  var from = Array.from;
  var isArray3 = Array.isArray;

  // node_modules/lib0/observable.js
  var Observable = class {
    constructor() {
      this._observers = create();
    }
    on(name2, f) {
      setIfUndefined(this._observers, name2, create2).add(f);
    }
    once(name2, f) {
      const _f = (...args2) => {
        this.off(name2, _f);
        f(...args2);
      };
      this.on(name2, _f);
    }
    off(name2, f) {
      const observers = this._observers.get(name2);
      if (observers !== void 0) {
        observers.delete(f);
        if (observers.size === 0) {
          this._observers.delete(name2);
        }
      }
    }
    emit(name2, args2) {
      return from((this._observers.get(name2) || create()).values()).forEach((f) => f(...args2));
    }
    destroy() {
      this._observers = create();
    }
  };

  // node_modules/lib0/math.js
  var floor = Math.floor;
  var abs = Math.abs;
  var log10 = Math.log10;
  var min = (a2, b) => a2 < b ? a2 : b;
  var max = (a2, b) => a2 > b ? a2 : b;
  var isNaN2 = Number.isNaN;
  var isNegativeZero = (n2) => n2 !== 0 ? n2 < 0 : 1 / n2 < 0;

  // node_modules/lib0/string.js
  var fromCharCode = String.fromCharCode;
  var fromCodePoint2 = String.fromCodePoint;
  var toLowerCase = (s) => s.toLowerCase();
  var trimLeftRegex = /^\s*/g;
  var trimLeft = (s) => s.replace(trimLeftRegex, "");
  var fromCamelCaseRegex = /([A-Z])/g;
  var fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));
  var _encodeUtf8Polyfill = (str) => {
    const encodedString = unescape(encodeURIComponent(str));
    const len = encodedString.length;
    const buf = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      buf[i] = encodedString.codePointAt(i);
    }
    return buf;
  };
  var utf8TextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder() : null;
  var _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
  var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
  var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
  if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
    utf8TextDecoder = null;
  }

  // node_modules/lib0/conditions.js
  var undefinedToNull = (v) => v === void 0 ? null : v;

  // node_modules/lib0/storage.js
  var VarStoragePolyfill = class {
    constructor() {
      this.map = /* @__PURE__ */ new Map();
    }
    setItem(key, newValue) {
      this.map.set(key, newValue);
    }
    getItem(key) {
      return this.map.get(key);
    }
  };
  var _localStorage = new VarStoragePolyfill();
  var usePolyfill = true;
  try {
    if (typeof localStorage !== "undefined") {
      _localStorage = localStorage;
      usePolyfill = false;
    }
  } catch (e) {
  }
  var varStorage = _localStorage;
  var onChange = (eventHandler) => usePolyfill || addEventListener("storage", eventHandler);

  // node_modules/lib0/object.js
  var keys2 = Object.keys;
  var length = (obj) => keys2(obj).length;
  var every = (obj, f) => {
    for (const key in obj) {
      if (!f(obj[key], key)) {
        return false;
      }
    }
    return true;
  };
  var hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
  var equalFlat = (a2, b) => a2 === b || length(a2) === length(b) && every(a2, (val, key) => (val !== void 0 || hasProperty(b, key)) && b[key] === val);

  // node_modules/lib0/function.js
  var callAll = (fs, args2, i = 0) => {
    try {
      for (; i < fs.length; i++) {
        fs[i](...args2);
      }
    } finally {
      if (i < fs.length) {
        callAll(fs, args2, i + 1);
      }
    }
  };
  var nop = () => {
  };
  var equalityStrict = (a2, b) => a2 === b;
  var equalityDeep = (a2, b) => {
    if (a2 == null || b == null) {
      return equalityStrict(a2, b);
    }
    if (a2.constructor !== b.constructor) {
      return false;
    }
    if (a2 === b) {
      return true;
    }
    switch (a2.constructor) {
      case ArrayBuffer:
        a2 = new Uint8Array(a2);
        b = new Uint8Array(b);
      case Uint8Array: {
        if (a2.byteLength !== b.byteLength) {
          return false;
        }
        for (let i = 0; i < a2.length; i++) {
          if (a2[i] !== b[i]) {
            return false;
          }
        }
        break;
      }
      case Set: {
        if (a2.size !== b.size) {
          return false;
        }
        for (const value of a2) {
          if (!b.has(value)) {
            return false;
          }
        }
        break;
      }
      case Map: {
        if (a2.size !== b.size) {
          return false;
        }
        for (const key of a2.keys()) {
          if (!b.has(key) || !equalityDeep(a2.get(key), b.get(key))) {
            return false;
          }
        }
        break;
      }
      case Object:
        if (length(a2) !== length(b)) {
          return false;
        }
        for (const key in a2) {
          if (!hasProperty(a2, key) || !equalityDeep(a2[key], b[key])) {
            return false;
          }
        }
        break;
      case Array:
        if (a2.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a2.length; i++) {
          if (!equalityDeep(a2[i], b[i])) {
            return false;
          }
        }
        break;
      default:
        return false;
    }
    return true;
  };
  var isOneOf = (value, options) => options.includes(value);

  // node_modules/lib0/environment.js
  var isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name);
  var isBrowser = typeof window !== "undefined" && !isNode;
  var isMac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
  var params;
  var args = [];
  var computeParams = () => {
    if (params === void 0) {
      if (isNode) {
        params = create();
        const pargs = process.argv;
        let currParamName = null;
        for (let i = 0; i < pargs.length; i++) {
          const parg = pargs[i];
          if (parg[0] === "-") {
            if (currParamName !== null) {
              params.set(currParamName, "");
            }
            currParamName = parg;
          } else {
            if (currParamName !== null) {
              params.set(currParamName, parg);
              currParamName = null;
            } else {
              args.push(parg);
            }
          }
        }
        if (currParamName !== null) {
          params.set(currParamName, "");
        }
      } else if (typeof location === "object") {
        params = create();
        (location.search || "?").slice(1).split("&").forEach((kv) => {
          if (kv.length !== 0) {
            const [key, value] = kv.split("=");
            params.set(`--${fromCamelCase(key, "-")}`, value);
            params.set(`-${fromCamelCase(key, "-")}`, value);
          }
        });
      } else {
        params = create();
      }
    }
    return params;
  };
  var hasParam = (name2) => computeParams().has(name2);
  var getVariable = (name2) => isNode ? undefinedToNull(process.env[name2.toUpperCase()]) : undefinedToNull(varStorage.getItem(name2));
  var hasConf = (name2) => hasParam("--" + name2) || getVariable(name2) !== null;
  var production = hasConf("production");
  var forceColor = isNode && isOneOf(process.env.FORCE_COLOR, ["true", "1", "2"]);
  var supportsColor = !hasParam("no-colors") && (!isNode || process.stdout.isTTY || forceColor) && (!isNode || hasParam("color") || forceColor || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));

  // node_modules/lib0/binary.js
  var BIT1 = 1;
  var BIT2 = 2;
  var BIT3 = 4;
  var BIT4 = 8;
  var BIT6 = 32;
  var BIT7 = 64;
  var BIT8 = 128;
  var BIT18 = 1 << 17;
  var BIT19 = 1 << 18;
  var BIT20 = 1 << 19;
  var BIT21 = 1 << 20;
  var BIT22 = 1 << 21;
  var BIT23 = 1 << 22;
  var BIT24 = 1 << 23;
  var BIT25 = 1 << 24;
  var BIT26 = 1 << 25;
  var BIT27 = 1 << 26;
  var BIT28 = 1 << 27;
  var BIT29 = 1 << 28;
  var BIT30 = 1 << 29;
  var BIT31 = 1 << 30;
  var BIT32 = 1 << 31;
  var BITS5 = 31;
  var BITS6 = 63;
  var BITS7 = 127;
  var BITS17 = BIT18 - 1;
  var BITS18 = BIT19 - 1;
  var BITS19 = BIT20 - 1;
  var BITS20 = BIT21 - 1;
  var BITS21 = BIT22 - 1;
  var BITS22 = BIT23 - 1;
  var BITS23 = BIT24 - 1;
  var BITS24 = BIT25 - 1;
  var BITS25 = BIT26 - 1;
  var BITS26 = BIT27 - 1;
  var BITS27 = BIT28 - 1;
  var BITS28 = BIT29 - 1;
  var BITS29 = BIT30 - 1;
  var BITS30 = BIT31 - 1;
  var BITS31 = 2147483647;

  // node_modules/lib0/number.js
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
  var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
  var LOWEST_INT32 = 1 << 31;
  var isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor(num) === num);
  var isNaN3 = Number.isNaN;
  var parseInt2 = Number.parseInt;

  // node_modules/lib0/error.js
  var create3 = (s) => new Error(s);
  var methodUnimplemented = () => {
    throw create3("Method unimplemented");
  };
  var unexpectedCase = () => {
    throw create3("Unexpected case");
  };

  // node_modules/lib0/decoding.js
  var errorUnexpectedEndOfArray = create3("Unexpected end of array");
  var errorIntegerOutOfRange = create3("Integer out of Range");
  var Decoder = class {
    constructor(uint8Array) {
      this.arr = uint8Array;
      this.pos = 0;
    }
  };
  var createDecoder = (uint8Array) => new Decoder(uint8Array);
  var hasContent = (decoder) => decoder.pos !== decoder.arr.length;
  var readUint8Array = (decoder, len) => {
    const view2 = createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
    decoder.pos += len;
    return view2;
  };
  var readVarUint8Array = (decoder) => readUint8Array(decoder, readVarUint(decoder));
  var readUint8 = (decoder) => decoder.arr[decoder.pos++];
  var readVarUint = (decoder) => {
    let num = 0;
    let mult = 1;
    const len = decoder.arr.length;
    while (decoder.pos < len) {
      const r = decoder.arr[decoder.pos++];
      num = num + (r & BITS7) * mult;
      mult *= 128;
      if (r < BIT8) {
        return num;
      }
      if (num > MAX_SAFE_INTEGER) {
        throw errorIntegerOutOfRange;
      }
    }
    throw errorUnexpectedEndOfArray;
  };
  var readVarInt = (decoder) => {
    let r = decoder.arr[decoder.pos++];
    let num = r & BITS6;
    let mult = 64;
    const sign = (r & BIT7) > 0 ? -1 : 1;
    if ((r & BIT8) === 0) {
      return sign * num;
    }
    const len = decoder.arr.length;
    while (decoder.pos < len) {
      r = decoder.arr[decoder.pos++];
      num = num + (r & BITS7) * mult;
      mult *= 128;
      if (r < BIT8) {
        return sign * num;
      }
      if (num > MAX_SAFE_INTEGER) {
        throw errorIntegerOutOfRange;
      }
    }
    throw errorUnexpectedEndOfArray;
  };
  var _readVarStringPolyfill = (decoder) => {
    let remainingLen = readVarUint(decoder);
    if (remainingLen === 0) {
      return "";
    } else {
      let encodedString = String.fromCodePoint(readUint8(decoder));
      if (--remainingLen < 100) {
        while (remainingLen--) {
          encodedString += String.fromCodePoint(readUint8(decoder));
        }
      } else {
        while (remainingLen > 0) {
          const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
          const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
          decoder.pos += nextLen;
          encodedString += String.fromCodePoint.apply(null, bytes);
          remainingLen -= nextLen;
        }
      }
      return decodeURIComponent(escape(encodedString));
    }
  };
  var _readVarStringNative = (decoder) => utf8TextDecoder.decode(readVarUint8Array(decoder));
  var readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
  var readFromDataView = (decoder, len) => {
    const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
    decoder.pos += len;
    return dv;
  };
  var readFloat32 = (decoder) => readFromDataView(decoder, 4).getFloat32(0, false);
  var readFloat64 = (decoder) => readFromDataView(decoder, 8).getFloat64(0, false);
  var readBigInt64 = (decoder) => readFromDataView(decoder, 8).getBigInt64(0, false);
  var readAnyLookupTable = [
    (decoder) => void 0,
    (decoder) => null,
    readVarInt,
    readFloat32,
    readFloat64,
    readBigInt64,
    (decoder) => false,
    (decoder) => true,
    readVarString,
    (decoder) => {
      const len = readVarUint(decoder);
      const obj = {};
      for (let i = 0; i < len; i++) {
        const key = readVarString(decoder);
        obj[key] = readAny(decoder);
      }
      return obj;
    },
    (decoder) => {
      const len = readVarUint(decoder);
      const arr = [];
      for (let i = 0; i < len; i++) {
        arr.push(readAny(decoder));
      }
      return arr;
    },
    readVarUint8Array
  ];
  var readAny = (decoder) => readAnyLookupTable[127 - readUint8(decoder)](decoder);
  var RleDecoder = class extends Decoder {
    constructor(uint8Array, reader) {
      super(uint8Array);
      this.reader = reader;
      this.s = null;
      this.count = 0;
    }
    read() {
      if (this.count === 0) {
        this.s = this.reader(this);
        if (hasContent(this)) {
          this.count = readVarUint(this) + 1;
        } else {
          this.count = -1;
        }
      }
      this.count--;
      return this.s;
    }
  };
  var UintOptRleDecoder = class extends Decoder {
    constructor(uint8Array) {
      super(uint8Array);
      this.s = 0;
      this.count = 0;
    }
    read() {
      if (this.count === 0) {
        this.s = readVarInt(this);
        const isNegative = isNegativeZero(this.s);
        this.count = 1;
        if (isNegative) {
          this.s = -this.s;
          this.count = readVarUint(this) + 2;
        }
      }
      this.count--;
      return this.s;
    }
  };
  var IntDiffOptRleDecoder = class extends Decoder {
    constructor(uint8Array) {
      super(uint8Array);
      this.s = 0;
      this.count = 0;
      this.diff = 0;
    }
    read() {
      if (this.count === 0) {
        const diff = readVarInt(this);
        const hasCount = diff & 1;
        this.diff = floor(diff / 2);
        this.count = 1;
        if (hasCount) {
          this.count = readVarUint(this) + 2;
        }
      }
      this.s += this.diff;
      this.count--;
      return this.s;
    }
  };
  var StringDecoder = class {
    constructor(uint8Array) {
      this.decoder = new UintOptRleDecoder(uint8Array);
      this.str = readVarString(this.decoder);
      this.spos = 0;
    }
    read() {
      const end = this.spos + this.decoder.read();
      const res = this.str.slice(this.spos, end);
      this.spos = end;
      return res;
    }
  };

  // node_modules/lib0/buffer.js
  var createUint8ArrayFromLen = (len) => new Uint8Array(len);
  var createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length3) => new Uint8Array(buffer, byteOffset, length3);
  var createUint8ArrayFromArrayBuffer = (buffer) => new Uint8Array(buffer);
  var toBase64Browser = (bytes) => {
    let s = "";
    for (let i = 0; i < bytes.byteLength; i++) {
      s += fromCharCode(bytes[i]);
    }
    return btoa(s);
  };
  var toBase64Node = (bytes) => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
  var fromBase64Browser = (s) => {
    const a2 = atob(s);
    const bytes = createUint8ArrayFromLen(a2.length);
    for (let i = 0; i < a2.length; i++) {
      bytes[i] = a2.charCodeAt(i);
    }
    return bytes;
  };
  var fromBase64Node = (s) => {
    const buf = Buffer.from(s, "base64");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  };
  var toBase64 = isBrowser ? toBase64Browser : toBase64Node;
  var fromBase64 = isBrowser ? fromBase64Browser : fromBase64Node;
  var copyUint8Array = (uint8Array) => {
    const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
    newBuf.set(uint8Array);
    return newBuf;
  };

  // node_modules/lib0/encoding.js
  var Encoder = class {
    constructor() {
      this.cpos = 0;
      this.cbuf = new Uint8Array(100);
      this.bufs = [];
    }
  };
  var createEncoder = () => new Encoder();
  var length2 = (encoder) => {
    let len = encoder.cpos;
    for (let i = 0; i < encoder.bufs.length; i++) {
      len += encoder.bufs[i].length;
    }
    return len;
  };
  var toUint8Array = (encoder) => {
    const uint8arr = new Uint8Array(length2(encoder));
    let curPos = 0;
    for (let i = 0; i < encoder.bufs.length; i++) {
      const d = encoder.bufs[i];
      uint8arr.set(d, curPos);
      curPos += d.length;
    }
    uint8arr.set(createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
    return uint8arr;
  };
  var verifyLen = (encoder, len) => {
    const bufferLen = encoder.cbuf.length;
    if (bufferLen - encoder.cpos < len) {
      encoder.bufs.push(createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos));
      encoder.cbuf = new Uint8Array(max(bufferLen, len) * 2);
      encoder.cpos = 0;
    }
  };
  var write = (encoder, num) => {
    const bufferLen = encoder.cbuf.length;
    if (encoder.cpos === bufferLen) {
      encoder.bufs.push(encoder.cbuf);
      encoder.cbuf = new Uint8Array(bufferLen * 2);
      encoder.cpos = 0;
    }
    encoder.cbuf[encoder.cpos++] = num;
  };
  var writeUint8 = write;
  var writeVarUint = (encoder, num) => {
    while (num > BITS7) {
      write(encoder, BIT8 | BITS7 & num);
      num = floor(num / 128);
    }
    write(encoder, BITS7 & num);
  };
  var writeVarInt = (encoder, num) => {
    const isNegative = isNegativeZero(num);
    if (isNegative) {
      num = -num;
    }
    write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
    num = floor(num / 64);
    while (num > 0) {
      write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
      num = floor(num / 128);
    }
  };
  var _strBuffer = new Uint8Array(3e4);
  var _maxStrBSize = _strBuffer.length / 3;
  var _writeVarStringNative = (encoder, str) => {
    if (str.length < _maxStrBSize) {
      const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
      writeVarUint(encoder, written);
      for (let i = 0; i < written; i++) {
        write(encoder, _strBuffer[i]);
      }
    } else {
      writeVarUint8Array(encoder, encodeUtf8(str));
    }
  };
  var _writeVarStringPolyfill = (encoder, str) => {
    const encodedString = unescape(encodeURIComponent(str));
    const len = encodedString.length;
    writeVarUint(encoder, len);
    for (let i = 0; i < len; i++) {
      write(encoder, encodedString.codePointAt(i));
    }
  };
  var writeVarString = utf8TextEncoder && utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
  var writeUint8Array = (encoder, uint8Array) => {
    const bufferLen = encoder.cbuf.length;
    const cpos = encoder.cpos;
    const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
    const rightCopyLen = uint8Array.length - leftCopyLen;
    encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
    encoder.cpos += leftCopyLen;
    if (rightCopyLen > 0) {
      encoder.bufs.push(encoder.cbuf);
      encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
      encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
      encoder.cpos = rightCopyLen;
    }
  };
  var writeVarUint8Array = (encoder, uint8Array) => {
    writeVarUint(encoder, uint8Array.byteLength);
    writeUint8Array(encoder, uint8Array);
  };
  var writeOnDataView = (encoder, len) => {
    verifyLen(encoder, len);
    const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
    encoder.cpos += len;
    return dview;
  };
  var writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);
  var writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);
  var writeBigInt64 = (encoder, num) => writeOnDataView(encoder, 8).setBigInt64(0, num, false);
  var floatTestBed = new DataView(new ArrayBuffer(4));
  var isFloat32 = (num) => {
    floatTestBed.setFloat32(0, num);
    return floatTestBed.getFloat32(0) === num;
  };
  var writeAny = (encoder, data2) => {
    switch (typeof data2) {
      case "string":
        write(encoder, 119);
        writeVarString(encoder, data2);
        break;
      case "number":
        if (isInteger(data2) && abs(data2) <= BITS31) {
          write(encoder, 125);
          writeVarInt(encoder, data2);
        } else if (isFloat32(data2)) {
          write(encoder, 124);
          writeFloat32(encoder, data2);
        } else {
          write(encoder, 123);
          writeFloat64(encoder, data2);
        }
        break;
      case "bigint":
        write(encoder, 122);
        writeBigInt64(encoder, data2);
        break;
      case "object":
        if (data2 === null) {
          write(encoder, 126);
        } else if (data2 instanceof Array) {
          write(encoder, 117);
          writeVarUint(encoder, data2.length);
          for (let i = 0; i < data2.length; i++) {
            writeAny(encoder, data2[i]);
          }
        } else if (data2 instanceof Uint8Array) {
          write(encoder, 116);
          writeVarUint8Array(encoder, data2);
        } else {
          write(encoder, 118);
          const keys3 = Object.keys(data2);
          writeVarUint(encoder, keys3.length);
          for (let i = 0; i < keys3.length; i++) {
            const key = keys3[i];
            writeVarString(encoder, key);
            writeAny(encoder, data2[key]);
          }
        }
        break;
      case "boolean":
        write(encoder, data2 ? 120 : 121);
        break;
      default:
        write(encoder, 127);
    }
  };
  var RleEncoder = class extends Encoder {
    constructor(writer) {
      super();
      this.w = writer;
      this.s = null;
      this.count = 0;
    }
    write(v) {
      if (this.s === v) {
        this.count++;
      } else {
        if (this.count > 0) {
          writeVarUint(this, this.count - 1);
        }
        this.count = 1;
        this.w(this, v);
        this.s = v;
      }
    }
  };
  var flushUintOptRleEncoder = (encoder) => {
    if (encoder.count > 0) {
      writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
      if (encoder.count > 1) {
        writeVarUint(encoder.encoder, encoder.count - 2);
      }
    }
  };
  var UintOptRleEncoder = class {
    constructor() {
      this.encoder = new Encoder();
      this.s = 0;
      this.count = 0;
    }
    write(v) {
      if (this.s === v) {
        this.count++;
      } else {
        flushUintOptRleEncoder(this);
        this.count = 1;
        this.s = v;
      }
    }
    toUint8Array() {
      flushUintOptRleEncoder(this);
      return toUint8Array(this.encoder);
    }
  };
  var flushIntDiffOptRleEncoder = (encoder) => {
    if (encoder.count > 0) {
      const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
      writeVarInt(encoder.encoder, encodedDiff);
      if (encoder.count > 1) {
        writeVarUint(encoder.encoder, encoder.count - 2);
      }
    }
  };
  var IntDiffOptRleEncoder = class {
    constructor() {
      this.encoder = new Encoder();
      this.s = 0;
      this.count = 0;
      this.diff = 0;
    }
    write(v) {
      if (this.diff === v - this.s) {
        this.s = v;
        this.count++;
      } else {
        flushIntDiffOptRleEncoder(this);
        this.count = 1;
        this.diff = v - this.s;
        this.s = v;
      }
    }
    toUint8Array() {
      flushIntDiffOptRleEncoder(this);
      return toUint8Array(this.encoder);
    }
  };
  var StringEncoder = class {
    constructor() {
      this.sarr = [];
      this.s = "";
      this.lensE = new UintOptRleEncoder();
    }
    write(string3) {
      this.s += string3;
      if (this.s.length > 19) {
        this.sarr.push(this.s);
        this.s = "";
      }
      this.lensE.write(string3.length);
    }
    toUint8Array() {
      const encoder = new Encoder();
      this.sarr.push(this.s);
      this.s = "";
      writeVarString(encoder, this.sarr.join(""));
      writeUint8Array(encoder, this.lensE.toUint8Array());
      return toUint8Array(encoder);
    }
  };

  // node_modules/isomorphic.js/browser.mjs
  var performance2 = typeof window === "undefined" ? null : typeof window.performance !== "undefined" && window.performance || null;
  var isoCrypto = typeof crypto === "undefined" ? null : crypto;
  var cryptoRandomBuffer = isoCrypto !== null ? (len) => {
    const buf = new ArrayBuffer(len);
    const arr = new Uint8Array(buf);
    isoCrypto.getRandomValues(arr);
    return buf;
  } : (len) => {
    const buf = new ArrayBuffer(len);
    const arr = new Uint8Array(buf);
    for (let i = 0; i < len; i++) {
      arr[i] = Math.ceil(Math.random() * 4294967295 >>> 0);
    }
    return buf;
  };

  // node_modules/lib0/random.js
  var rand = Math.random;
  var uint32 = () => new Uint32Array(cryptoRandomBuffer(4))[0];
  var uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11;
  var uuidv4 = () => uuidv4Template.replace(
    /[018]/g,
    (c2) => (c2 ^ uint32() & 15 >> c2 / 4).toString(16)
  );

  // node_modules/lib0/time.js
  var getUnixTime = Date.now;

  // node_modules/lib0/promise.js
  var create4 = (f) => new Promise(f);
  var reject = (reason) => Promise.reject(reason);
  var resolve = (res) => Promise.resolve(res);

  // node_modules/lib0/symbol.js
  var create5 = Symbol;

  // node_modules/lib0/pair.js
  var Pair = class {
    constructor(left, right) {
      this.left = left;
      this.right = right;
    }
  };
  var create6 = (left, right) => new Pair(left, right);

  // node_modules/lib0/dom.js
  var doc2 = typeof document !== "undefined" ? document : {};
  var domParser = typeof DOMParser !== "undefined" ? new DOMParser() : null;
  var mapToStyleString = (m2) => map2(m2, (value, key) => `${key}:${value};`).join("");
  var ELEMENT_NODE = doc2.ELEMENT_NODE;
  var TEXT_NODE2 = doc2.TEXT_NODE;
  var CDATA_SECTION_NODE = doc2.CDATA_SECTION_NODE;
  var COMMENT_NODE = doc2.COMMENT_NODE;
  var DOCUMENT_NODE = doc2.DOCUMENT_NODE;
  var DOCUMENT_TYPE_NODE = doc2.DOCUMENT_TYPE_NODE;
  var DOCUMENT_FRAGMENT_NODE = doc2.DOCUMENT_FRAGMENT_NODE;

  // node_modules/lib0/logging.js
  var BOLD = create5();
  var UNBOLD = create5();
  var BLUE = create5();
  var GREY = create5();
  var GREEN = create5();
  var RED = create5();
  var PURPLE = create5();
  var ORANGE = create5();
  var UNCOLOR = create5();
  var _browserStyleMap = {
    [BOLD]: create6("font-weight", "bold"),
    [UNBOLD]: create6("font-weight", "normal"),
    [BLUE]: create6("color", "blue"),
    [GREEN]: create6("color", "green"),
    [GREY]: create6("color", "grey"),
    [RED]: create6("color", "red"),
    [PURPLE]: create6("color", "purple"),
    [ORANGE]: create6("color", "orange"),
    [UNCOLOR]: create6("color", "black")
  };
  var _nodeStyleMap = {
    [BOLD]: "\x1B[1m",
    [UNBOLD]: "\x1B[2m",
    [BLUE]: "\x1B[34m",
    [GREEN]: "\x1B[32m",
    [GREY]: "\x1B[37m",
    [RED]: "\x1B[31m",
    [PURPLE]: "\x1B[35m",
    [ORANGE]: "\x1B[38;5;208m",
    [UNCOLOR]: "\x1B[0m"
  };
  var computeBrowserLoggingArgs = (args2) => {
    const strBuilder = [];
    const styles = [];
    const currentStyle = create();
    let logArgs = [];
    let i = 0;
    for (; i < args2.length; i++) {
      const arg = args2[i];
      const style = _browserStyleMap[arg];
      if (style !== void 0) {
        currentStyle.set(style.left, style.right);
      } else {
        if (arg.constructor === String || arg.constructor === Number) {
          const style2 = mapToStyleString(currentStyle);
          if (i > 0 || style2.length > 0) {
            strBuilder.push("%c" + arg);
            styles.push(style2);
          } else {
            strBuilder.push(arg);
          }
        } else {
          break;
        }
      }
    }
    if (i > 0) {
      logArgs = styles;
      logArgs.unshift(strBuilder.join(""));
    }
    for (; i < args2.length; i++) {
      const arg = args2[i];
      if (!(arg instanceof Symbol)) {
        logArgs.push(arg);
      }
    }
    return logArgs;
  };
  var computeNoColorLoggingArgs = (args2) => {
    const strBuilder = [];
    const logArgs = [];
    let i = 0;
    for (; i < args2.length; i++) {
      const arg = args2[i];
      const style = _nodeStyleMap[arg];
      if (style === void 0) {
        if (arg.constructor === String || arg.constructor === Number) {
          strBuilder.push(arg);
        } else {
          break;
        }
      }
    }
    if (i > 0) {
      logArgs.push(strBuilder.join(""));
    }
    for (; i < args2.length; i++) {
      const arg = args2[i];
      if (!(arg instanceof Symbol)) {
        if (arg.constructor === Object) {
          logArgs.push(JSON.stringify(arg));
        } else {
          logArgs.push(arg);
        }
      }
    }
    return logArgs;
  };
  var computeNodeLoggingArgs = (args2) => {
    const strBuilder = [];
    const logArgs = [];
    let i = 0;
    for (; i < args2.length; i++) {
      const arg = args2[i];
      const style = _nodeStyleMap[arg];
      if (style !== void 0) {
        strBuilder.push(style);
      } else {
        if (arg.constructor === String || arg.constructor === Number) {
          strBuilder.push(arg);
        } else {
          break;
        }
      }
    }
    if (i > 0) {
      strBuilder.push("\x1B[0m");
      logArgs.push(strBuilder.join(""));
    }
    for (; i < args2.length; i++) {
      const arg = args2[i];
      if (!(arg instanceof Symbol)) {
        logArgs.push(arg);
      }
    }
    return logArgs;
  };
  var computeLoggingArgs = supportsColor ? isNode ? computeNodeLoggingArgs : computeBrowserLoggingArgs : computeNoColorLoggingArgs;
  var print = (...args2) => {
    console.log(...computeLoggingArgs(args2));
    vconsoles.forEach((vc) => vc.print(args2));
  };
  var vconsoles = /* @__PURE__ */ new Set();
  var loggingColors = [GREEN, PURPLE, ORANGE, BLUE];
  var nextColor = 0;
  var lastLoggingTime = getUnixTime();
  var createModuleLogger = (moduleName) => {
    const color = loggingColors[nextColor];
    const debugRegexVar = getVariable("log");
    const doLogging = debugRegexVar !== null && (debugRegexVar === "*" || debugRegexVar === "true" || new RegExp(debugRegexVar, "gi").test(moduleName));
    nextColor = (nextColor + 1) % loggingColors.length;
    moduleName += ": ";
    return !doLogging ? nop : (...args2) => {
      const timeNow = getUnixTime();
      const timeDiff = timeNow - lastLoggingTime;
      lastLoggingTime = timeNow;
      print(
        color,
        moduleName,
        UNCOLOR,
        ...args2.map(
          (arg) => typeof arg === "string" || typeof arg === "symbol" ? arg : JSON.stringify(arg)
        ),
        color,
        " +" + timeDiff + "ms"
      );
    };
  };

  // node_modules/lib0/iterator.js
  var createIterator = (next) => ({
    [Symbol.iterator]() {
      return this;
    },
    next
  });
  var iteratorFilter = (iterator, filter) => createIterator(() => {
    let res;
    do {
      res = iterator.next();
    } while (!res.done && !filter(res.value));
    return res;
  });
  var iteratorMap = (iterator, fmap) => createIterator(() => {
    const { done, value } = iterator.next();
    return { done, value: done ? void 0 : fmap(value) };
  });

  // node_modules/yjs/dist/yjs.mjs
  var DeleteItem = class {
    constructor(clock2, len) {
      this.clock = clock2;
      this.len = len;
    }
  };
  var DeleteSet = class {
    constructor() {
      this.clients = /* @__PURE__ */ new Map();
    }
  };
  var iterateDeletedStructs = (transaction, ds, f) => ds.clients.forEach((deletes, clientid) => {
    const structs = transaction.doc.store.clients.get(clientid);
    for (let i = 0; i < deletes.length; i++) {
      const del2 = deletes[i];
      iterateStructs(transaction, structs, del2.clock, del2.len, f);
    }
  });
  var findIndexDS = (dis, clock2) => {
    let left = 0;
    let right = dis.length - 1;
    while (left <= right) {
      const midindex = floor((left + right) / 2);
      const mid = dis[midindex];
      const midclock = mid.clock;
      if (midclock <= clock2) {
        if (clock2 < midclock + mid.len) {
          return midindex;
        }
        left = midindex + 1;
      } else {
        right = midindex - 1;
      }
    }
    return null;
  };
  var isDeleted = (ds, id3) => {
    const dis = ds.clients.get(id3.client);
    return dis !== void 0 && findIndexDS(dis, id3.clock) !== null;
  };
  var sortAndMergeDeleteSet = (ds) => {
    ds.clients.forEach((dels) => {
      dels.sort((a2, b) => a2.clock - b.clock);
      let i, j;
      for (i = 1, j = 1; i < dels.length; i++) {
        const left = dels[j - 1];
        const right = dels[i];
        if (left.clock + left.len >= right.clock) {
          left.len = max(left.len, right.clock + right.len - left.clock);
        } else {
          if (j < i) {
            dels[j] = right;
          }
          j++;
        }
      }
      dels.length = j;
    });
  };
  var mergeDeleteSets = (dss) => {
    const merged = new DeleteSet();
    for (let dssI = 0; dssI < dss.length; dssI++) {
      dss[dssI].clients.forEach((delsLeft, client) => {
        if (!merged.clients.has(client)) {
          const dels = delsLeft.slice();
          for (let i = dssI + 1; i < dss.length; i++) {
            appendTo(dels, dss[i].clients.get(client) || []);
          }
          merged.clients.set(client, dels);
        }
      });
    }
    sortAndMergeDeleteSet(merged);
    return merged;
  };
  var addToDeleteSet = (ds, client, clock2, length3) => {
    setIfUndefined(ds.clients, client, () => []).push(new DeleteItem(clock2, length3));
  };
  var createDeleteSet = () => new DeleteSet();
  var createDeleteSetFromStructStore = (ss) => {
    const ds = createDeleteSet();
    ss.clients.forEach((structs, client) => {
      const dsitems = [];
      for (let i = 0; i < structs.length; i++) {
        const struct = structs[i];
        if (struct.deleted) {
          const clock2 = struct.id.clock;
          let len = struct.length;
          if (i + 1 < structs.length) {
            for (let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]) {
              len += next.length;
            }
          }
          dsitems.push(new DeleteItem(clock2, len));
        }
      }
      if (dsitems.length > 0) {
        ds.clients.set(client, dsitems);
      }
    });
    return ds;
  };
  var writeDeleteSet = (encoder, ds) => {
    writeVarUint(encoder.restEncoder, ds.clients.size);
    ds.clients.forEach((dsitems, client) => {
      encoder.resetDsCurVal();
      writeVarUint(encoder.restEncoder, client);
      const len = dsitems.length;
      writeVarUint(encoder.restEncoder, len);
      for (let i = 0; i < len; i++) {
        const item = dsitems[i];
        encoder.writeDsClock(item.clock);
        encoder.writeDsLen(item.len);
      }
    });
  };
  var readDeleteSet = (decoder) => {
    const ds = new DeleteSet();
    const numClients = readVarUint(decoder.restDecoder);
    for (let i = 0; i < numClients; i++) {
      decoder.resetDsCurVal();
      const client = readVarUint(decoder.restDecoder);
      const numberOfDeletes = readVarUint(decoder.restDecoder);
      if (numberOfDeletes > 0) {
        const dsField = setIfUndefined(ds.clients, client, () => []);
        for (let i2 = 0; i2 < numberOfDeletes; i2++) {
          dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
        }
      }
    }
    return ds;
  };
  var readAndApplyDeleteSet = (decoder, transaction, store) => {
    const unappliedDS = new DeleteSet();
    const numClients = readVarUint(decoder.restDecoder);
    for (let i = 0; i < numClients; i++) {
      decoder.resetDsCurVal();
      const client = readVarUint(decoder.restDecoder);
      const numberOfDeletes = readVarUint(decoder.restDecoder);
      const structs = store.clients.get(client) || [];
      const state = getState(store, client);
      for (let i2 = 0; i2 < numberOfDeletes; i2++) {
        const clock2 = decoder.readDsClock();
        const clockEnd = clock2 + decoder.readDsLen();
        if (clock2 < state) {
          if (state < clockEnd) {
            addToDeleteSet(unappliedDS, client, state, clockEnd - state);
          }
          let index2 = findIndexSS(structs, clock2);
          let struct = structs[index2];
          if (!struct.deleted && struct.id.clock < clock2) {
            structs.splice(index2 + 1, 0, splitItem(transaction, struct, clock2 - struct.id.clock));
            index2++;
          }
          while (index2 < structs.length) {
            struct = structs[index2++];
            if (struct.id.clock < clockEnd) {
              if (!struct.deleted) {
                if (clockEnd < struct.id.clock + struct.length) {
                  structs.splice(index2, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
                }
                struct.delete(transaction);
              }
            } else {
              break;
            }
          }
        } else {
          addToDeleteSet(unappliedDS, client, clock2, clockEnd - clock2);
        }
      }
    }
    if (unappliedDS.clients.size > 0) {
      const ds = new UpdateEncoderV2();
      writeVarUint(ds.restEncoder, 0);
      writeDeleteSet(ds, unappliedDS);
      return ds.toUint8Array();
    }
    return null;
  };
  var generateNewClientId = uint32;
  var Doc = class extends Observable {
    constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta: meta2 = null, autoLoad = false, shouldLoad = true } = {}) {
      super();
      this.gc = gc;
      this.gcFilter = gcFilter;
      this.clientID = generateNewClientId();
      this.guid = guid;
      this.collectionid = collectionid;
      this.share = /* @__PURE__ */ new Map();
      this.store = new StructStore();
      this._transaction = null;
      this._transactionCleanups = [];
      this.subdocs = /* @__PURE__ */ new Set();
      this._item = null;
      this.shouldLoad = shouldLoad;
      this.autoLoad = autoLoad;
      this.meta = meta2;
      this.isLoaded = false;
      this.whenLoaded = create4((resolve2) => {
        this.on("load", () => {
          this.isLoaded = true;
          resolve2(this);
        });
      });
    }
    load() {
      const item = this._item;
      if (item !== null && !this.shouldLoad) {
        transact(item.parent.doc, (transaction) => {
          transaction.subdocsLoaded.add(this);
        }, null, true);
      }
      this.shouldLoad = true;
    }
    getSubdocs() {
      return this.subdocs;
    }
    getSubdocGuids() {
      return new Set(Array.from(this.subdocs).map((doc3) => doc3.guid));
    }
    transact(f, origin = null) {
      transact(this, f, origin);
    }
    get(name2, TypeConstructor = AbstractType) {
      const type = setIfUndefined(this.share, name2, () => {
        const t2 = new TypeConstructor();
        t2._integrate(this, null);
        return t2;
      });
      const Constr = type.constructor;
      if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
        if (Constr === AbstractType) {
          const t2 = new TypeConstructor();
          t2._map = type._map;
          type._map.forEach((n2) => {
            for (; n2 !== null; n2 = n2.left) {
              n2.parent = t2;
            }
          });
          t2._start = type._start;
          for (let n2 = t2._start; n2 !== null; n2 = n2.right) {
            n2.parent = t2;
          }
          t2._length = type._length;
          this.share.set(name2, t2);
          t2._integrate(this, null);
          return t2;
        } else {
          throw new Error(`Type with the name ${name2} has already been defined with a different constructor`);
        }
      }
      return type;
    }
    getArray(name2 = "") {
      return this.get(name2, YArray);
    }
    getText(name2 = "") {
      return this.get(name2, YText);
    }
    getMap(name2 = "") {
      return this.get(name2, YMap);
    }
    getXmlFragment(name2 = "") {
      return this.get(name2, YXmlFragment);
    }
    toJSON() {
      const doc3 = {};
      this.share.forEach((value, key) => {
        doc3[key] = value.toJSON();
      });
      return doc3;
    }
    destroy() {
      from(this.subdocs).forEach((subdoc) => subdoc.destroy());
      const item = this._item;
      if (item !== null) {
        this._item = null;
        const content2 = item.content;
        content2.doc = new Doc({ guid: this.guid, ...content2.opts, shouldLoad: false });
        content2.doc._item = item;
        transact(item.parent.doc, (transaction) => {
          const doc3 = content2.doc;
          if (!item.deleted) {
            transaction.subdocsAdded.add(doc3);
          }
          transaction.subdocsRemoved.add(this);
        }, null, true);
      }
      this.emit("destroyed", [true]);
      this.emit("destroy", [this]);
      super.destroy();
    }
    on(eventName, f) {
      super.on(eventName, f);
    }
    off(eventName, f) {
      super.off(eventName, f);
    }
  };
  var DSDecoderV1 = class {
    constructor(decoder) {
      this.restDecoder = decoder;
    }
    resetDsCurVal() {
    }
    readDsClock() {
      return readVarUint(this.restDecoder);
    }
    readDsLen() {
      return readVarUint(this.restDecoder);
    }
  };
  var UpdateDecoderV1 = class extends DSDecoderV1 {
    readLeftID() {
      return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
    }
    readRightID() {
      return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
    }
    readClient() {
      return readVarUint(this.restDecoder);
    }
    readInfo() {
      return readUint8(this.restDecoder);
    }
    readString() {
      return readVarString(this.restDecoder);
    }
    readParentInfo() {
      return readVarUint(this.restDecoder) === 1;
    }
    readTypeRef() {
      return readVarUint(this.restDecoder);
    }
    readLen() {
      return readVarUint(this.restDecoder);
    }
    readAny() {
      return readAny(this.restDecoder);
    }
    readBuf() {
      return copyUint8Array(readVarUint8Array(this.restDecoder));
    }
    readJSON() {
      return JSON.parse(readVarString(this.restDecoder));
    }
    readKey() {
      return readVarString(this.restDecoder);
    }
  };
  var DSDecoderV2 = class {
    constructor(decoder) {
      this.dsCurrVal = 0;
      this.restDecoder = decoder;
    }
    resetDsCurVal() {
      this.dsCurrVal = 0;
    }
    readDsClock() {
      this.dsCurrVal += readVarUint(this.restDecoder);
      return this.dsCurrVal;
    }
    readDsLen() {
      const diff = readVarUint(this.restDecoder) + 1;
      this.dsCurrVal += diff;
      return diff;
    }
  };
  var UpdateDecoderV2 = class extends DSDecoderV2 {
    constructor(decoder) {
      super(decoder);
      this.keys = [];
      readVarUint(decoder);
      this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
      this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
      this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
      this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
      this.infoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
      this.stringDecoder = new StringDecoder(readVarUint8Array(decoder));
      this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
      this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
      this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    }
    readLeftID() {
      return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
    }
    readRightID() {
      return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
    }
    readClient() {
      return this.clientDecoder.read();
    }
    readInfo() {
      return this.infoDecoder.read();
    }
    readString() {
      return this.stringDecoder.read();
    }
    readParentInfo() {
      return this.parentInfoDecoder.read() === 1;
    }
    readTypeRef() {
      return this.typeRefDecoder.read();
    }
    readLen() {
      return this.lenDecoder.read();
    }
    readAny() {
      return readAny(this.restDecoder);
    }
    readBuf() {
      return readVarUint8Array(this.restDecoder);
    }
    readJSON() {
      return readAny(this.restDecoder);
    }
    readKey() {
      const keyClock = this.keyClockDecoder.read();
      if (keyClock < this.keys.length) {
        return this.keys[keyClock];
      } else {
        const key = this.stringDecoder.read();
        this.keys.push(key);
        return key;
      }
    }
  };
  var DSEncoderV1 = class {
    constructor() {
      this.restEncoder = createEncoder();
    }
    toUint8Array() {
      return toUint8Array(this.restEncoder);
    }
    resetDsCurVal() {
    }
    writeDsClock(clock2) {
      writeVarUint(this.restEncoder, clock2);
    }
    writeDsLen(len) {
      writeVarUint(this.restEncoder, len);
    }
  };
  var UpdateEncoderV1 = class extends DSEncoderV1 {
    writeLeftID(id3) {
      writeVarUint(this.restEncoder, id3.client);
      writeVarUint(this.restEncoder, id3.clock);
    }
    writeRightID(id3) {
      writeVarUint(this.restEncoder, id3.client);
      writeVarUint(this.restEncoder, id3.clock);
    }
    writeClient(client) {
      writeVarUint(this.restEncoder, client);
    }
    writeInfo(info) {
      writeUint8(this.restEncoder, info);
    }
    writeString(s) {
      writeVarString(this.restEncoder, s);
    }
    writeParentInfo(isYKey) {
      writeVarUint(this.restEncoder, isYKey ? 1 : 0);
    }
    writeTypeRef(info) {
      writeVarUint(this.restEncoder, info);
    }
    writeLen(len) {
      writeVarUint(this.restEncoder, len);
    }
    writeAny(any2) {
      writeAny(this.restEncoder, any2);
    }
    writeBuf(buf) {
      writeVarUint8Array(this.restEncoder, buf);
    }
    writeJSON(embed) {
      writeVarString(this.restEncoder, JSON.stringify(embed));
    }
    writeKey(key) {
      writeVarString(this.restEncoder, key);
    }
  };
  var DSEncoderV2 = class {
    constructor() {
      this.restEncoder = createEncoder();
      this.dsCurrVal = 0;
    }
    toUint8Array() {
      return toUint8Array(this.restEncoder);
    }
    resetDsCurVal() {
      this.dsCurrVal = 0;
    }
    writeDsClock(clock2) {
      const diff = clock2 - this.dsCurrVal;
      this.dsCurrVal = clock2;
      writeVarUint(this.restEncoder, diff);
    }
    writeDsLen(len) {
      if (len === 0) {
        unexpectedCase();
      }
      writeVarUint(this.restEncoder, len - 1);
      this.dsCurrVal += len;
    }
  };
  var UpdateEncoderV2 = class extends DSEncoderV2 {
    constructor() {
      super();
      this.keyMap = /* @__PURE__ */ new Map();
      this.keyClock = 0;
      this.keyClockEncoder = new IntDiffOptRleEncoder();
      this.clientEncoder = new UintOptRleEncoder();
      this.leftClockEncoder = new IntDiffOptRleEncoder();
      this.rightClockEncoder = new IntDiffOptRleEncoder();
      this.infoEncoder = new RleEncoder(writeUint8);
      this.stringEncoder = new StringEncoder();
      this.parentInfoEncoder = new RleEncoder(writeUint8);
      this.typeRefEncoder = new UintOptRleEncoder();
      this.lenEncoder = new UintOptRleEncoder();
    }
    toUint8Array() {
      const encoder = createEncoder();
      writeVarUint(encoder, 0);
      writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
      writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
      writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
      writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
      writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));
      writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
      writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));
      writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
      writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
      writeUint8Array(encoder, toUint8Array(this.restEncoder));
      return toUint8Array(encoder);
    }
    writeLeftID(id3) {
      this.clientEncoder.write(id3.client);
      this.leftClockEncoder.write(id3.clock);
    }
    writeRightID(id3) {
      this.clientEncoder.write(id3.client);
      this.rightClockEncoder.write(id3.clock);
    }
    writeClient(client) {
      this.clientEncoder.write(client);
    }
    writeInfo(info) {
      this.infoEncoder.write(info);
    }
    writeString(s) {
      this.stringEncoder.write(s);
    }
    writeParentInfo(isYKey) {
      this.parentInfoEncoder.write(isYKey ? 1 : 0);
    }
    writeTypeRef(info) {
      this.typeRefEncoder.write(info);
    }
    writeLen(len) {
      this.lenEncoder.write(len);
    }
    writeAny(any2) {
      writeAny(this.restEncoder, any2);
    }
    writeBuf(buf) {
      writeVarUint8Array(this.restEncoder, buf);
    }
    writeJSON(embed) {
      writeAny(this.restEncoder, embed);
    }
    writeKey(key) {
      const clock2 = this.keyMap.get(key);
      if (clock2 === void 0) {
        this.keyClockEncoder.write(this.keyClock++);
        this.stringEncoder.write(key);
      } else {
        this.keyClockEncoder.write(clock2);
      }
    }
  };
  var writeStructs = (encoder, structs, client, clock2) => {
    clock2 = max(clock2, structs[0].id.clock);
    const startNewStructs = findIndexSS(structs, clock2);
    writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
    encoder.writeClient(client);
    writeVarUint(encoder.restEncoder, clock2);
    const firstStruct = structs[startNewStructs];
    firstStruct.write(encoder, clock2 - firstStruct.id.clock);
    for (let i = startNewStructs + 1; i < structs.length; i++) {
      structs[i].write(encoder, 0);
    }
  };
  var writeClientsStructs = (encoder, store, _sm) => {
    const sm = /* @__PURE__ */ new Map();
    _sm.forEach((clock2, client) => {
      if (getState(store, client) > clock2) {
        sm.set(client, clock2);
      }
    });
    getStateVector(store).forEach((clock2, client) => {
      if (!_sm.has(client)) {
        sm.set(client, 0);
      }
    });
    writeVarUint(encoder.restEncoder, sm.size);
    Array.from(sm.entries()).sort((a2, b) => b[0] - a2[0]).forEach(([client, clock2]) => {
      writeStructs(encoder, store.clients.get(client), client, clock2);
    });
  };
  var readClientsStructRefs = (decoder, doc3) => {
    const clientRefs = create();
    const numOfStateUpdates = readVarUint(decoder.restDecoder);
    for (let i = 0; i < numOfStateUpdates; i++) {
      const numberOfStructs = readVarUint(decoder.restDecoder);
      const refs = new Array(numberOfStructs);
      const client = decoder.readClient();
      let clock2 = readVarUint(decoder.restDecoder);
      clientRefs.set(client, { i: 0, refs });
      for (let i2 = 0; i2 < numberOfStructs; i2++) {
        const info = decoder.readInfo();
        switch (BITS5 & info) {
          case 0: {
            const len = decoder.readLen();
            refs[i2] = new GC(createID(client, clock2), len);
            clock2 += len;
            break;
          }
          case 10: {
            const len = readVarUint(decoder.restDecoder);
            refs[i2] = new Skip(createID(client, clock2), len);
            clock2 += len;
            break;
          }
          default: {
            const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
            const struct = new Item(
              createID(client, clock2),
              null,
              (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
              null,
              (info & BIT7) === BIT7 ? decoder.readRightID() : null,
              cantCopyParentInfo ? decoder.readParentInfo() ? doc3.get(decoder.readString()) : decoder.readLeftID() : null,
              cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
              readItemContent(decoder, info)
            );
            refs[i2] = struct;
            clock2 += struct.length;
          }
        }
      }
    }
    return clientRefs;
  };
  var integrateStructs = (transaction, store, clientsStructRefs) => {
    const stack = [];
    let clientsStructRefsIds = Array.from(clientsStructRefs.keys()).sort((a2, b) => a2 - b);
    if (clientsStructRefsIds.length === 0) {
      return null;
    }
    const getNextStructTarget = () => {
      if (clientsStructRefsIds.length === 0) {
        return null;
      }
      let nextStructsTarget = clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
      while (nextStructsTarget.refs.length === nextStructsTarget.i) {
        clientsStructRefsIds.pop();
        if (clientsStructRefsIds.length > 0) {
          nextStructsTarget = clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
        } else {
          return null;
        }
      }
      return nextStructsTarget;
    };
    let curStructsTarget = getNextStructTarget();
    if (curStructsTarget === null && stack.length === 0) {
      return null;
    }
    const restStructs = new StructStore();
    const missingSV = /* @__PURE__ */ new Map();
    const updateMissingSv = (client, clock2) => {
      const mclock = missingSV.get(client);
      if (mclock == null || mclock > clock2) {
        missingSV.set(client, clock2);
      }
    };
    let stackHead = curStructsTarget.refs[curStructsTarget.i++];
    const state = /* @__PURE__ */ new Map();
    const addStackToRestSS = () => {
      for (const item of stack) {
        const client = item.id.client;
        const unapplicableItems = clientsStructRefs.get(client);
        if (unapplicableItems) {
          unapplicableItems.i--;
          restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));
          clientsStructRefs.delete(client);
          unapplicableItems.i = 0;
          unapplicableItems.refs = [];
        } else {
          restStructs.clients.set(client, [item]);
        }
        clientsStructRefsIds = clientsStructRefsIds.filter((c2) => c2 !== client);
      }
      stack.length = 0;
    };
    while (true) {
      if (stackHead.constructor !== Skip) {
        const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));
        const offset = localClock - stackHead.id.clock;
        if (offset < 0) {
          stack.push(stackHead);
          updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
          addStackToRestSS();
        } else {
          const missing = stackHead.getMissing(transaction, store);
          if (missing !== null) {
            stack.push(stackHead);
            const structRefs = clientsStructRefs.get(missing) || { refs: [], i: 0 };
            if (structRefs.refs.length === structRefs.i) {
              updateMissingSv(missing, getState(store, missing));
              addStackToRestSS();
            } else {
              stackHead = structRefs.refs[structRefs.i++];
              continue;
            }
          } else if (offset === 0 || offset < stackHead.length) {
            stackHead.integrate(transaction, offset);
            state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
          }
        }
      }
      if (stack.length > 0) {
        stackHead = stack.pop();
      } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
        stackHead = curStructsTarget.refs[curStructsTarget.i++];
      } else {
        curStructsTarget = getNextStructTarget();
        if (curStructsTarget === null) {
          break;
        } else {
          stackHead = curStructsTarget.refs[curStructsTarget.i++];
        }
      }
    }
    if (restStructs.clients.size > 0) {
      const encoder = new UpdateEncoderV2();
      writeClientsStructs(encoder, restStructs, /* @__PURE__ */ new Map());
      writeVarUint(encoder.restEncoder, 0);
      return { missing: missingSV, update: encoder.toUint8Array() };
    }
    return null;
  };
  var writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
  var readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) => transact(ydoc, (transaction) => {
    transaction.local = false;
    let retry = false;
    const doc3 = transaction.doc;
    const store = doc3.store;
    const ss = readClientsStructRefs(structDecoder, doc3);
    const restStructs = integrateStructs(transaction, store, ss);
    const pending = store.pendingStructs;
    if (pending) {
      for (const [client, clock2] of pending.missing) {
        if (clock2 < getState(store, client)) {
          retry = true;
          break;
        }
      }
      if (restStructs) {
        for (const [client, clock2] of restStructs.missing) {
          const mclock = pending.missing.get(client);
          if (mclock == null || mclock > clock2) {
            pending.missing.set(client, clock2);
          }
        }
        pending.update = mergeUpdatesV2([pending.update, restStructs.update]);
      }
    } else {
      store.pendingStructs = restStructs;
    }
    const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
    if (store.pendingDs) {
      const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store.pendingDs));
      readVarUint(pendingDSUpdate.restDecoder);
      const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
      if (dsRest && dsRest2) {
        store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);
      } else {
        store.pendingDs = dsRest || dsRest2;
      }
    } else {
      store.pendingDs = dsRest;
    }
    if (retry) {
      const update = store.pendingStructs.update;
      store.pendingStructs = null;
      applyUpdateV2(transaction.doc, update);
    }
  }, transactionOrigin, false);
  var applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {
    const decoder = createDecoder(update);
    readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
  };
  var applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);
  var writeStateAsUpdate = (encoder, doc3, targetStateVector = /* @__PURE__ */ new Map()) => {
    writeClientsStructs(encoder, doc3.store, targetStateVector);
    writeDeleteSet(encoder, createDeleteSetFromStructStore(doc3.store));
  };
  var encodeStateAsUpdateV2 = (doc3, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {
    const targetStateVector = decodeStateVector(encodedTargetStateVector);
    writeStateAsUpdate(encoder, doc3, targetStateVector);
    const updates = [encoder.toUint8Array()];
    if (doc3.store.pendingDs) {
      updates.push(doc3.store.pendingDs);
    }
    if (doc3.store.pendingStructs) {
      updates.push(diffUpdateV2(doc3.store.pendingStructs.update, encodedTargetStateVector));
    }
    if (updates.length > 1) {
      if (encoder.constructor === UpdateEncoderV1) {
        return mergeUpdates(updates.map((update, i) => i === 0 ? update : convertUpdateFormatV2ToV1(update)));
      } else if (encoder.constructor === UpdateEncoderV2) {
        return mergeUpdatesV2(updates);
      }
    }
    return updates[0];
  };
  var encodeStateAsUpdate = (doc3, encodedTargetStateVector) => encodeStateAsUpdateV2(doc3, encodedTargetStateVector, new UpdateEncoderV1());
  var readStateVector = (decoder) => {
    const ss = /* @__PURE__ */ new Map();
    const ssLength = readVarUint(decoder.restDecoder);
    for (let i = 0; i < ssLength; i++) {
      const client = readVarUint(decoder.restDecoder);
      const clock2 = readVarUint(decoder.restDecoder);
      ss.set(client, clock2);
    }
    return ss;
  };
  var decodeStateVector = (decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState)));
  var writeStateVector = (encoder, sv) => {
    writeVarUint(encoder.restEncoder, sv.size);
    Array.from(sv.entries()).sort((a2, b) => b[0] - a2[0]).forEach(([client, clock2]) => {
      writeVarUint(encoder.restEncoder, client);
      writeVarUint(encoder.restEncoder, clock2);
    });
    return encoder;
  };
  var writeDocumentStateVector = (encoder, doc3) => writeStateVector(encoder, getStateVector(doc3.store));
  var encodeStateVectorV2 = (doc3, encoder = new DSEncoderV2()) => {
    if (doc3 instanceof Map) {
      writeStateVector(encoder, doc3);
    } else {
      writeDocumentStateVector(encoder, doc3);
    }
    return encoder.toUint8Array();
  };
  var encodeStateVector = (doc3) => encodeStateVectorV2(doc3, new DSEncoderV1());
  var EventHandler = class {
    constructor() {
      this.l = [];
    }
  };
  var createEventHandler = () => new EventHandler();
  var addEventHandlerListener = (eventHandler, f) => eventHandler.l.push(f);
  var removeEventHandlerListener = (eventHandler, f) => {
    const l = eventHandler.l;
    const len = l.length;
    eventHandler.l = l.filter((g) => f !== g);
    if (len === eventHandler.l.length) {
      console.error("[yjs] Tried to remove event handler that doesn't exist.");
    }
  };
  var callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);
  var ID = class {
    constructor(client, clock2) {
      this.client = client;
      this.clock = clock2;
    }
  };
  var compareIDs = (a2, b) => a2 === b || a2 !== null && b !== null && a2.client === b.client && a2.clock === b.clock;
  var createID = (client, clock2) => new ID(client, clock2);
  var findRootTypeKey = (type) => {
    for (const [key, value] of type.doc.share.entries()) {
      if (value === type) {
        return key;
      }
    }
    throw unexpectedCase();
  };
  var isParentOf = (parent, child) => {
    while (child !== null) {
      if (child.parent === parent) {
        return true;
      }
      child = child.parent._item;
    }
    return false;
  };
  var Snapshot = class {
    constructor(ds, sv) {
      this.ds = ds;
      this.sv = sv;
    }
  };
  var createSnapshot = (ds, sm) => new Snapshot(ds, sm);
  var emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
  var isVisible = (item, snapshot) => snapshot === void 0 ? !item.deleted : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id);
  var splitSnapshotAffectedStructs = (transaction, snapshot) => {
    const meta2 = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create2);
    const store = transaction.doc.store;
    if (!meta2.has(snapshot)) {
      snapshot.sv.forEach((clock2, client) => {
        if (clock2 < getState(store, client)) {
          getItemCleanStart(transaction, createID(client, clock2));
        }
      });
      iterateDeletedStructs(transaction, snapshot.ds, (item) => {
      });
      meta2.add(snapshot);
    }
  };
  var StructStore = class {
    constructor() {
      this.clients = /* @__PURE__ */ new Map();
      this.pendingStructs = null;
      this.pendingDs = null;
    }
  };
  var getStateVector = (store) => {
    const sm = /* @__PURE__ */ new Map();
    store.clients.forEach((structs, client) => {
      const struct = structs[structs.length - 1];
      sm.set(client, struct.id.clock + struct.length);
    });
    return sm;
  };
  var getState = (store, client) => {
    const structs = store.clients.get(client);
    if (structs === void 0) {
      return 0;
    }
    const lastStruct = structs[structs.length - 1];
    return lastStruct.id.clock + lastStruct.length;
  };
  var addStruct = (store, struct) => {
    let structs = store.clients.get(struct.id.client);
    if (structs === void 0) {
      structs = [];
      store.clients.set(struct.id.client, structs);
    } else {
      const lastStruct = structs[structs.length - 1];
      if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
        throw unexpectedCase();
      }
    }
    structs.push(struct);
  };
  var findIndexSS = (structs, clock2) => {
    let left = 0;
    let right = structs.length - 1;
    let mid = structs[right];
    let midclock = mid.id.clock;
    if (midclock === clock2) {
      return right;
    }
    let midindex = floor(clock2 / (midclock + mid.length - 1) * right);
    while (left <= right) {
      mid = structs[midindex];
      midclock = mid.id.clock;
      if (midclock <= clock2) {
        if (clock2 < midclock + mid.length) {
          return midindex;
        }
        left = midindex + 1;
      } else {
        right = midindex - 1;
      }
      midindex = floor((left + right) / 2);
    }
    throw unexpectedCase();
  };
  var find3 = (store, id3) => {
    const structs = store.clients.get(id3.client);
    return structs[findIndexSS(structs, id3.clock)];
  };
  var getItem = find3;
  var findIndexCleanStart = (transaction, structs, clock2) => {
    const index2 = findIndexSS(structs, clock2);
    const struct = structs[index2];
    if (struct.id.clock < clock2 && struct instanceof Item) {
      structs.splice(index2 + 1, 0, splitItem(transaction, struct, clock2 - struct.id.clock));
      return index2 + 1;
    }
    return index2;
  };
  var getItemCleanStart = (transaction, id3) => {
    const structs = transaction.doc.store.clients.get(id3.client);
    return structs[findIndexCleanStart(transaction, structs, id3.clock)];
  };
  var getItemCleanEnd = (transaction, store, id3) => {
    const structs = store.clients.get(id3.client);
    const index2 = findIndexSS(structs, id3.clock);
    const struct = structs[index2];
    if (id3.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
      structs.splice(index2 + 1, 0, splitItem(transaction, struct, id3.clock - struct.id.clock + 1));
    }
    return struct;
  };
  var replaceStruct = (store, struct, newStruct) => {
    const structs = store.clients.get(struct.id.client);
    structs[findIndexSS(structs, struct.id.clock)] = newStruct;
  };
  var iterateStructs = (transaction, structs, clockStart, len, f) => {
    if (len === 0) {
      return;
    }
    const clockEnd = clockStart + len;
    let index2 = findIndexCleanStart(transaction, structs, clockStart);
    let struct;
    do {
      struct = structs[index2++];
      if (clockEnd < struct.id.clock + struct.length) {
        findIndexCleanStart(transaction, structs, clockEnd);
      }
      f(struct);
    } while (index2 < structs.length && structs[index2].id.clock < clockEnd);
  };
  var Transaction2 = class {
    constructor(doc3, origin, local) {
      this.doc = doc3;
      this.deleteSet = new DeleteSet();
      this.beforeState = getStateVector(doc3.store);
      this.afterState = /* @__PURE__ */ new Map();
      this.changed = /* @__PURE__ */ new Map();
      this.changedParentTypes = /* @__PURE__ */ new Map();
      this._mergeStructs = [];
      this.origin = origin;
      this.meta = /* @__PURE__ */ new Map();
      this.local = local;
      this.subdocsAdded = /* @__PURE__ */ new Set();
      this.subdocsRemoved = /* @__PURE__ */ new Set();
      this.subdocsLoaded = /* @__PURE__ */ new Set();
    }
  };
  var writeUpdateMessageFromTransaction = (encoder, transaction) => {
    if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock2, client) => transaction.beforeState.get(client) !== clock2)) {
      return false;
    }
    sortAndMergeDeleteSet(transaction.deleteSet);
    writeStructsFromTransaction(encoder, transaction);
    writeDeleteSet(encoder, transaction.deleteSet);
    return true;
  };
  var addChangedTypeToTransaction = (transaction, type, parentSub) => {
    const item = type._item;
    if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
      setIfUndefined(transaction.changed, type, create2).add(parentSub);
    }
  };
  var tryToMergeWithLeft = (structs, pos) => {
    const left = structs[pos - 1];
    const right = structs[pos];
    if (left.deleted === right.deleted && left.constructor === right.constructor) {
      if (left.mergeWith(right)) {
        structs.splice(pos, 1);
        if (right instanceof Item && right.parentSub !== null && right.parent._map.get(right.parentSub) === right) {
          right.parent._map.set(right.parentSub, left);
        }
      }
    }
  };
  var tryGcDeleteSet = (ds, store, gcFilter) => {
    for (const [client, deleteItems] of ds.clients.entries()) {
      const structs = store.clients.get(client);
      for (let di = deleteItems.length - 1; di >= 0; di--) {
        const deleteItem = deleteItems[di];
        const endDeleteItemClock = deleteItem.clock + deleteItem.len;
        for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
          const struct2 = structs[si];
          if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
            break;
          }
          if (struct2 instanceof Item && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
            struct2.gc(store, false);
          }
        }
      }
    }
  };
  var tryMergeDeleteSet = (ds, store) => {
    ds.clients.forEach((deleteItems, client) => {
      const structs = store.clients.get(client);
      for (let di = deleteItems.length - 1; di >= 0; di--) {
        const deleteItem = deleteItems[di];
        const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
        for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[--si]) {
          tryToMergeWithLeft(structs, si);
        }
      }
    });
  };
  var cleanupTransactions = (transactionCleanups, i) => {
    if (i < transactionCleanups.length) {
      const transaction = transactionCleanups[i];
      const doc3 = transaction.doc;
      const store = doc3.store;
      const ds = transaction.deleteSet;
      const mergeStructs = transaction._mergeStructs;
      try {
        sortAndMergeDeleteSet(ds);
        transaction.afterState = getStateVector(transaction.doc.store);
        doc3.emit("beforeObserverCalls", [transaction, doc3]);
        const fs = [];
        transaction.changed.forEach(
          (subs, itemtype) => fs.push(() => {
            if (itemtype._item === null || !itemtype._item.deleted) {
              itemtype._callObserver(transaction, subs);
            }
          })
        );
        fs.push(() => {
          transaction.changedParentTypes.forEach(
            (events, type) => fs.push(() => {
              if (type._item === null || !type._item.deleted) {
                events = events.filter(
                  (event) => event.target._item === null || !event.target._item.deleted
                );
                events.forEach((event) => {
                  event.currentTarget = type;
                });
                events.sort((event1, event2) => event1.path.length - event2.path.length);
                callEventHandlerListeners(type._dEH, events, transaction);
              }
            })
          );
          fs.push(() => doc3.emit("afterTransaction", [transaction, doc3]));
        });
        callAll(fs, []);
      } finally {
        if (doc3.gc) {
          tryGcDeleteSet(ds, store, doc3.gcFilter);
        }
        tryMergeDeleteSet(ds, store);
        transaction.afterState.forEach((clock2, client) => {
          const beforeClock = transaction.beforeState.get(client) || 0;
          if (beforeClock !== clock2) {
            const structs = store.clients.get(client);
            const firstChangePos = max(findIndexSS(structs, beforeClock), 1);
            for (let i2 = structs.length - 1; i2 >= firstChangePos; i2--) {
              tryToMergeWithLeft(structs, i2);
            }
          }
        });
        for (let i2 = 0; i2 < mergeStructs.length; i2++) {
          const { client, clock: clock2 } = mergeStructs[i2].id;
          const structs = store.clients.get(client);
          const replacedStructPos = findIndexSS(structs, clock2);
          if (replacedStructPos + 1 < structs.length) {
            tryToMergeWithLeft(structs, replacedStructPos + 1);
          }
          if (replacedStructPos > 0) {
            tryToMergeWithLeft(structs, replacedStructPos);
          }
        }
        if (!transaction.local && transaction.afterState.get(doc3.clientID) !== transaction.beforeState.get(doc3.clientID)) {
          print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
          doc3.clientID = generateNewClientId();
        }
        doc3.emit("afterTransactionCleanup", [transaction, doc3]);
        if (doc3._observers.has("update")) {
          const encoder = new UpdateEncoderV1();
          const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
          if (hasContent2) {
            doc3.emit("update", [encoder.toUint8Array(), transaction.origin, doc3, transaction]);
          }
        }
        if (doc3._observers.has("updateV2")) {
          const encoder = new UpdateEncoderV2();
          const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
          if (hasContent2) {
            doc3.emit("updateV2", [encoder.toUint8Array(), transaction.origin, doc3, transaction]);
          }
        }
        const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
        if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
          subdocsAdded.forEach((subdoc) => {
            subdoc.clientID = doc3.clientID;
            if (subdoc.collectionid == null) {
              subdoc.collectionid = doc3.collectionid;
            }
            doc3.subdocs.add(subdoc);
          });
          subdocsRemoved.forEach((subdoc) => doc3.subdocs.delete(subdoc));
          doc3.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc3, transaction]);
          subdocsRemoved.forEach((subdoc) => subdoc.destroy());
        }
        if (transactionCleanups.length <= i + 1) {
          doc3._transactionCleanups = [];
          doc3.emit("afterAllTransactions", [doc3, transactionCleanups]);
        } else {
          cleanupTransactions(transactionCleanups, i + 1);
        }
      }
    }
  };
  var transact = (doc3, f, origin = null, local = true) => {
    const transactionCleanups = doc3._transactionCleanups;
    let initialCall = false;
    if (doc3._transaction === null) {
      initialCall = true;
      doc3._transaction = new Transaction2(doc3, origin, local);
      transactionCleanups.push(doc3._transaction);
      if (transactionCleanups.length === 1) {
        doc3.emit("beforeAllTransactions", [doc3]);
      }
      doc3.emit("beforeTransaction", [doc3._transaction, doc3]);
    }
    try {
      f(doc3._transaction);
    } finally {
      if (initialCall) {
        const finishCleanup = doc3._transaction === transactionCleanups[0];
        doc3._transaction = null;
        if (finishCleanup) {
          cleanupTransactions(transactionCleanups, 0);
        }
      }
    }
  };
  var StackItem = class {
    constructor(deletions, insertions) {
      this.insertions = insertions;
      this.deletions = deletions;
      this.meta = /* @__PURE__ */ new Map();
    }
  };
  var clearUndoManagerStackItem = (tr, um, stackItem) => {
    iterateDeletedStructs(tr, stackItem.deletions, (item) => {
      if (item instanceof Item && um.scope.some((type) => isParentOf(type, item))) {
        keepItem(item, false);
      }
    });
  };
  var popStackItem = (undoManager, stack, eventType) => {
    let result = null;
    let _tr = null;
    const doc3 = undoManager.doc;
    const scope = undoManager.scope;
    transact(doc3, (transaction) => {
      while (stack.length > 0 && result === null) {
        const store = doc3.store;
        const stackItem = stack.pop();
        const itemsToRedo = /* @__PURE__ */ new Set();
        const itemsToDelete = [];
        let performedChange = false;
        iterateDeletedStructs(transaction, stackItem.insertions, (struct) => {
          if (struct instanceof Item) {
            if (struct.redone !== null) {
              let { item, diff } = followRedone(store, struct.id);
              if (diff > 0) {
                item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));
              }
              struct = item;
            }
            if (!struct.deleted && scope.some((type) => isParentOf(type, struct))) {
              itemsToDelete.push(struct);
            }
          }
        });
        iterateDeletedStructs(transaction, stackItem.deletions, (struct) => {
          if (struct instanceof Item && scope.some((type) => isParentOf(type, struct)) && !isDeleted(stackItem.insertions, struct.id)) {
            itemsToRedo.add(struct);
          }
        });
        itemsToRedo.forEach((struct) => {
          performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges) !== null || performedChange;
        });
        for (let i = itemsToDelete.length - 1; i >= 0; i--) {
          const item = itemsToDelete[i];
          if (undoManager.deleteFilter(item)) {
            item.delete(transaction);
            performedChange = true;
          }
        }
        result = performedChange ? stackItem : null;
      }
      transaction.changed.forEach((subProps, type) => {
        if (subProps.has(null) && type._searchMarker) {
          type._searchMarker.length = 0;
        }
      });
      _tr = transaction;
    }, undoManager);
    if (result != null) {
      const changedParentTypes = _tr.changedParentTypes;
      undoManager.emit("stack-item-popped", [{ stackItem: result, type: eventType, changedParentTypes }, undoManager]);
    }
    return result;
  };
  var UndoManager = class extends Observable {
    constructor(typeScope, {
      captureTimeout = 500,
      captureTransaction = (tr) => true,
      deleteFilter = () => true,
      trackedOrigins = /* @__PURE__ */ new Set([null]),
      ignoreRemoteMapChanges = false,
      doc: doc3 = isArray3(typeScope) ? typeScope[0].doc : typeScope.doc
    } = {}) {
      super();
      this.scope = [];
      this.addToScope(typeScope);
      this.deleteFilter = deleteFilter;
      trackedOrigins.add(this);
      this.trackedOrigins = trackedOrigins;
      this.captureTransaction = captureTransaction;
      this.undoStack = [];
      this.redoStack = [];
      this.undoing = false;
      this.redoing = false;
      this.doc = doc3;
      this.lastChange = 0;
      this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;
      this.captureTimeout = captureTimeout;
      this.afterTransactionHandler = (transaction) => {
        if (!this.captureTransaction(transaction) || !this.scope.some((type) => transaction.changedParentTypes.has(type)) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) {
          return;
        }
        const undoing = this.undoing;
        const redoing = this.redoing;
        const stack = undoing ? this.redoStack : this.undoStack;
        if (undoing) {
          this.stopCapturing();
        } else if (!redoing) {
          this.clear(false, true);
        }
        const insertions = new DeleteSet();
        transaction.afterState.forEach((endClock, client) => {
          const startClock = transaction.beforeState.get(client) || 0;
          const len = endClock - startClock;
          if (len > 0) {
            addToDeleteSet(insertions, client, startClock, len);
          }
        });
        const now3 = getUnixTime();
        let didAdd = false;
        if (this.lastChange > 0 && now3 - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {
          const lastOp = stack[stack.length - 1];
          lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);
          lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);
        } else {
          stack.push(new StackItem(transaction.deleteSet, insertions));
          didAdd = true;
        }
        if (!undoing && !redoing) {
          this.lastChange = now3;
        }
        iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {
          if (item instanceof Item && this.scope.some((type) => isParentOf(type, item))) {
            keepItem(item, true);
          }
        });
        const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? "redo" : "undo", changedParentTypes: transaction.changedParentTypes }, this];
        if (didAdd) {
          this.emit("stack-item-added", changeEvent);
        } else {
          this.emit("stack-item-updated", changeEvent);
        }
      };
      this.doc.on("afterTransaction", this.afterTransactionHandler);
      this.doc.on("destroy", () => {
        this.destroy();
      });
    }
    addToScope(ytypes) {
      ytypes = isArray3(ytypes) ? ytypes : [ytypes];
      ytypes.forEach((ytype) => {
        if (this.scope.every((yt) => yt !== ytype)) {
          this.scope.push(ytype);
        }
      });
    }
    addTrackedOrigin(origin) {
      this.trackedOrigins.add(origin);
    }
    removeTrackedOrigin(origin) {
      this.trackedOrigins.delete(origin);
    }
    clear(clearUndoStack = true, clearRedoStack = true) {
      if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) {
        this.doc.transact((tr) => {
          if (clearUndoStack) {
            this.undoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));
            this.undoStack = [];
          }
          if (clearRedoStack) {
            this.redoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));
            this.redoStack = [];
          }
          this.emit("stack-cleared", [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }]);
        });
      }
    }
    stopCapturing() {
      this.lastChange = 0;
    }
    undo() {
      this.undoing = true;
      let res;
      try {
        res = popStackItem(this, this.undoStack, "undo");
      } finally {
        this.undoing = false;
      }
      return res;
    }
    redo() {
      this.redoing = true;
      let res;
      try {
        res = popStackItem(this, this.redoStack, "redo");
      } finally {
        this.redoing = false;
      }
      return res;
    }
    canUndo() {
      return this.undoStack.length > 0;
    }
    canRedo() {
      return this.redoStack.length > 0;
    }
    destroy() {
      this.trackedOrigins.delete(this);
      this.doc.off("afterTransaction", this.afterTransactionHandler);
      super.destroy();
    }
  };
  function* lazyStructReaderGenerator(decoder) {
    const numOfStateUpdates = readVarUint(decoder.restDecoder);
    for (let i = 0; i < numOfStateUpdates; i++) {
      const numberOfStructs = readVarUint(decoder.restDecoder);
      const client = decoder.readClient();
      let clock2 = readVarUint(decoder.restDecoder);
      for (let i2 = 0; i2 < numberOfStructs; i2++) {
        const info = decoder.readInfo();
        if (info === 10) {
          const len = readVarUint(decoder.restDecoder);
          yield new Skip(createID(client, clock2), len);
          clock2 += len;
        } else if ((BITS5 & info) !== 0) {
          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
          const struct = new Item(
            createID(client, clock2),
            null,
            (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
            null,
            (info & BIT7) === BIT7 ? decoder.readRightID() : null,
            cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null,
            cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
            readItemContent(decoder, info)
          );
          yield struct;
          clock2 += struct.length;
        } else {
          const len = decoder.readLen();
          yield new GC(createID(client, clock2), len);
          clock2 += len;
        }
      }
    }
  }
  var LazyStructReader = class {
    constructor(decoder, filterSkips) {
      this.gen = lazyStructReaderGenerator(decoder);
      this.curr = null;
      this.done = false;
      this.filterSkips = filterSkips;
      this.next();
    }
    next() {
      do {
        this.curr = this.gen.next().value || null;
      } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
      return this.curr;
    }
  };
  var LazyStructWriter = class {
    constructor(encoder) {
      this.currClient = 0;
      this.startClock = 0;
      this.written = 0;
      this.encoder = encoder;
      this.clientStructs = [];
    }
  };
  var mergeUpdates = (updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
  var sliceStruct = (left, diff) => {
    if (left.constructor === GC) {
      const { client, clock: clock2 } = left.id;
      return new GC(createID(client, clock2 + diff), left.length - diff);
    } else if (left.constructor === Skip) {
      const { client, clock: clock2 } = left.id;
      return new Skip(createID(client, clock2 + diff), left.length - diff);
    } else {
      const leftItem = left;
      const { client, clock: clock2 } = leftItem.id;
      return new Item(
        createID(client, clock2 + diff),
        null,
        createID(client, clock2 + diff - 1),
        null,
        leftItem.rightOrigin,
        leftItem.parent,
        leftItem.parentSub,
        leftItem.content.splice(diff)
      );
    }
  };
  var mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
    if (updates.length === 1) {
      return updates[0];
    }
    const updateDecoders = updates.map((update) => new YDecoder(createDecoder(update)));
    let lazyStructDecoders = updateDecoders.map((decoder) => new LazyStructReader(decoder, true));
    let currWrite = null;
    const updateEncoder = new YEncoder();
    const lazyStructEncoder = new LazyStructWriter(updateEncoder);
    while (true) {
      lazyStructDecoders = lazyStructDecoders.filter((dec2) => dec2.curr !== null);
      lazyStructDecoders.sort(
        (dec1, dec2) => {
          if (dec1.curr.id.client === dec2.curr.id.client) {
            const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
            if (clockDiff === 0) {
              return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;
            } else {
              return clockDiff;
            }
          } else {
            return dec2.curr.id.client - dec1.curr.id.client;
          }
        }
      );
      if (lazyStructDecoders.length === 0) {
        break;
      }
      const currDecoder = lazyStructDecoders[0];
      const firstClient = currDecoder.curr.id.client;
      if (currWrite !== null) {
        let curr = currDecoder.curr;
        let iterated = false;
        while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
          curr = currDecoder.next();
          iterated = true;
        }
        if (curr === null || curr.id.client !== firstClient || iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {
          continue;
        }
        if (firstClient !== currWrite.struct.id.client) {
          writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
          currWrite = { struct: curr, offset: 0 };
          currDecoder.next();
        } else {
          if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
            if (currWrite.struct.constructor === Skip) {
              currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
            } else {
              writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
              const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
              const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
              currWrite = { struct, offset: 0 };
            }
          } else {
            const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
            if (diff > 0) {
              if (currWrite.struct.constructor === Skip) {
                currWrite.struct.length -= diff;
              } else {
                curr = sliceStruct(curr, diff);
              }
            }
            if (!currWrite.struct.mergeWith(curr)) {
              writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
              currWrite = { struct: curr, offset: 0 };
              currDecoder.next();
            }
          }
        }
      } else {
        currWrite = { struct: currDecoder.curr, offset: 0 };
        currDecoder.next();
      }
      for (let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = { struct: next, offset: 0 };
      }
    }
    if (currWrite !== null) {
      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
      currWrite = null;
    }
    finishLazyStructWriting(lazyStructEncoder);
    const dss = updateDecoders.map((decoder) => readDeleteSet(decoder));
    const ds = mergeDeleteSets(dss);
    writeDeleteSet(updateEncoder, ds);
    return updateEncoder.toUint8Array();
  };
  var diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
    const state = decodeStateVector(sv);
    const encoder = new YEncoder();
    const lazyStructWriter = new LazyStructWriter(encoder);
    const decoder = new YDecoder(createDecoder(update));
    const reader = new LazyStructReader(decoder, false);
    while (reader.curr) {
      const curr = reader.curr;
      const currClient = curr.id.client;
      const svClock = state.get(currClient) || 0;
      if (reader.curr.constructor === Skip) {
        reader.next();
        continue;
      }
      if (curr.id.clock + curr.length > svClock) {
        writeStructToLazyStructWriter(lazyStructWriter, curr, max(svClock - curr.id.clock, 0));
        reader.next();
        while (reader.curr && reader.curr.id.client === currClient) {
          writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
          reader.next();
        }
      } else {
        while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {
          reader.next();
        }
      }
    }
    finishLazyStructWriting(lazyStructWriter);
    const ds = readDeleteSet(decoder);
    writeDeleteSet(encoder, ds);
    return encoder.toUint8Array();
  };
  var flushLazyStructWriter = (lazyWriter) => {
    if (lazyWriter.written > 0) {
      lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });
      lazyWriter.encoder.restEncoder = createEncoder();
      lazyWriter.written = 0;
    }
  };
  var writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {
    if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
      flushLazyStructWriter(lazyWriter);
    }
    if (lazyWriter.written === 0) {
      lazyWriter.currClient = struct.id.client;
      lazyWriter.encoder.writeClient(struct.id.client);
      writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
    }
    struct.write(lazyWriter.encoder, offset);
    lazyWriter.written++;
  };
  var finishLazyStructWriting = (lazyWriter) => {
    flushLazyStructWriter(lazyWriter);
    const restEncoder = lazyWriter.encoder.restEncoder;
    writeVarUint(restEncoder, lazyWriter.clientStructs.length);
    for (let i = 0; i < lazyWriter.clientStructs.length; i++) {
      const partStructs = lazyWriter.clientStructs[i];
      writeVarUint(restEncoder, partStructs.written);
      writeUint8Array(restEncoder, partStructs.restEncoder);
    }
  };
  var convertUpdateFormat = (update, YDecoder, YEncoder) => {
    const updateDecoder = new YDecoder(createDecoder(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    const updateEncoder = new YEncoder();
    const lazyWriter = new LazyStructWriter(updateEncoder);
    for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
      writeStructToLazyStructWriter(lazyWriter, curr, 0);
    }
    finishLazyStructWriting(lazyWriter);
    const ds = readDeleteSet(updateDecoder);
    writeDeleteSet(updateEncoder, ds);
    return updateEncoder.toUint8Array();
  };
  var convertUpdateFormatV2ToV1 = (update) => convertUpdateFormat(update, UpdateDecoderV2, UpdateEncoderV1);
  var YEvent = class {
    constructor(target, transaction) {
      this.target = target;
      this.currentTarget = target;
      this.transaction = transaction;
      this._changes = null;
      this._keys = null;
      this._delta = null;
    }
    get path() {
      return getPathTo(this.currentTarget, this.target);
    }
    deletes(struct) {
      return isDeleted(this.transaction.deleteSet, struct.id);
    }
    get keys() {
      if (this._keys === null) {
        const keys3 = /* @__PURE__ */ new Map();
        const target = this.target;
        const changed = this.transaction.changed.get(target);
        changed.forEach((key) => {
          if (key !== null) {
            const item = target._map.get(key);
            let action;
            let oldValue;
            if (this.adds(item)) {
              let prev = item.left;
              while (prev !== null && this.adds(prev)) {
                prev = prev.left;
              }
              if (this.deletes(item)) {
                if (prev !== null && this.deletes(prev)) {
                  action = "delete";
                  oldValue = last(prev.content.getContent());
                } else {
                  return;
                }
              } else {
                if (prev !== null && this.deletes(prev)) {
                  action = "update";
                  oldValue = last(prev.content.getContent());
                } else {
                  action = "add";
                  oldValue = void 0;
                }
              }
            } else {
              if (this.deletes(item)) {
                action = "delete";
                oldValue = last(item.content.getContent());
              } else {
                return;
              }
            }
            keys3.set(key, { action, oldValue });
          }
        });
        this._keys = keys3;
      }
      return this._keys;
    }
    get delta() {
      return this.changes.delta;
    }
    adds(struct) {
      return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
    }
    get changes() {
      let changes = this._changes;
      if (changes === null) {
        const target = this.target;
        const added = create2();
        const deleted = create2();
        const delta = [];
        changes = {
          added,
          deleted,
          delta,
          keys: this.keys
        };
        const changed = this.transaction.changed.get(target);
        if (changed.has(null)) {
          let lastOp = null;
          const packOp = () => {
            if (lastOp) {
              delta.push(lastOp);
            }
          };
          for (let item = target._start; item !== null; item = item.right) {
            if (item.deleted) {
              if (this.deletes(item) && !this.adds(item)) {
                if (lastOp === null || lastOp.delete === void 0) {
                  packOp();
                  lastOp = { delete: 0 };
                }
                lastOp.delete += item.length;
                deleted.add(item);
              }
            } else {
              if (this.adds(item)) {
                if (lastOp === null || lastOp.insert === void 0) {
                  packOp();
                  lastOp = { insert: [] };
                }
                lastOp.insert = lastOp.insert.concat(item.content.getContent());
                added.add(item);
              } else {
                if (lastOp === null || lastOp.retain === void 0) {
                  packOp();
                  lastOp = { retain: 0 };
                }
                lastOp.retain += item.length;
              }
            }
          }
          if (lastOp !== null && lastOp.retain === void 0) {
            packOp();
          }
        }
        this._changes = changes;
      }
      return changes;
    }
  };
  var getPathTo = (parent, child) => {
    const path = [];
    while (child._item !== null && child !== parent) {
      if (child._item.parentSub !== null) {
        path.unshift(child._item.parentSub);
      } else {
        let i = 0;
        let c2 = child._item.parent._start;
        while (c2 !== child._item && c2 !== null) {
          if (!c2.deleted) {
            i++;
          }
          c2 = c2.right;
        }
        path.unshift(i);
      }
      child = child._item.parent;
    }
    return path;
  };
  var maxSearchMarker = 80;
  var globalSearchMarkerTimestamp = 0;
  var ArraySearchMarker = class {
    constructor(p, index2) {
      p.marker = true;
      this.p = p;
      this.index = index2;
      this.timestamp = globalSearchMarkerTimestamp++;
    }
  };
  var refreshMarkerTimestamp = (marker) => {
    marker.timestamp = globalSearchMarkerTimestamp++;
  };
  var overwriteMarker = (marker, p, index2) => {
    marker.p.marker = false;
    marker.p = p;
    p.marker = true;
    marker.index = index2;
    marker.timestamp = globalSearchMarkerTimestamp++;
  };
  var markPosition = (searchMarker, p, index2) => {
    if (searchMarker.length >= maxSearchMarker) {
      const marker = searchMarker.reduce((a2, b) => a2.timestamp < b.timestamp ? a2 : b);
      overwriteMarker(marker, p, index2);
      return marker;
    } else {
      const pm = new ArraySearchMarker(p, index2);
      searchMarker.push(pm);
      return pm;
    }
  };
  var findMarker = (yarray, index2) => {
    if (yarray._start === null || index2 === 0 || yarray._searchMarker === null) {
      return null;
    }
    const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a2, b) => abs(index2 - a2.index) < abs(index2 - b.index) ? a2 : b);
    let p = yarray._start;
    let pindex = 0;
    if (marker !== null) {
      p = marker.p;
      pindex = marker.index;
      refreshMarkerTimestamp(marker);
    }
    while (p.right !== null && pindex < index2) {
      if (!p.deleted && p.countable) {
        if (index2 < pindex + p.length) {
          break;
        }
        pindex += p.length;
      }
      p = p.right;
    }
    while (p.left !== null && pindex > index2) {
      p = p.left;
      if (!p.deleted && p.countable) {
        pindex -= p.length;
      }
    }
    while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {
      p = p.left;
      if (!p.deleted && p.countable) {
        pindex -= p.length;
      }
    }
    if (marker !== null && abs(marker.index - pindex) < p.parent.length / maxSearchMarker) {
      overwriteMarker(marker, p, pindex);
      return marker;
    } else {
      return markPosition(yarray._searchMarker, p, pindex);
    }
  };
  var updateMarkerChanges = (searchMarker, index2, len) => {
    for (let i = searchMarker.length - 1; i >= 0; i--) {
      const m2 = searchMarker[i];
      if (len > 0) {
        let p = m2.p;
        p.marker = false;
        while (p && (p.deleted || !p.countable)) {
          p = p.left;
          if (p && !p.deleted && p.countable) {
            m2.index -= p.length;
          }
        }
        if (p === null || p.marker === true) {
          searchMarker.splice(i, 1);
          continue;
        }
        m2.p = p;
        p.marker = true;
      }
      if (index2 < m2.index || len > 0 && index2 === m2.index) {
        m2.index = max(index2, m2.index + len);
      }
    }
  };
  var callTypeObservers = (type, transaction, event) => {
    const changedType = type;
    const changedParentTypes = transaction.changedParentTypes;
    while (true) {
      setIfUndefined(changedParentTypes, type, () => []).push(event);
      if (type._item === null) {
        break;
      }
      type = type._item.parent;
    }
    callEventHandlerListeners(changedType._eH, event, transaction);
  };
  var AbstractType = class {
    constructor() {
      this._item = null;
      this._map = /* @__PURE__ */ new Map();
      this._start = null;
      this.doc = null;
      this._length = 0;
      this._eH = createEventHandler();
      this._dEH = createEventHandler();
      this._searchMarker = null;
    }
    get parent() {
      return this._item ? this._item.parent : null;
    }
    _integrate(y3, item) {
      this.doc = y3;
      this._item = item;
    }
    _copy() {
      throw methodUnimplemented();
    }
    clone() {
      throw methodUnimplemented();
    }
    _write(encoder) {
    }
    get _first() {
      let n2 = this._start;
      while (n2 !== null && n2.deleted) {
        n2 = n2.right;
      }
      return n2;
    }
    _callObserver(transaction, parentSubs) {
      if (!transaction.local && this._searchMarker) {
        this._searchMarker.length = 0;
      }
    }
    observe(f) {
      addEventHandlerListener(this._eH, f);
    }
    observeDeep(f) {
      addEventHandlerListener(this._dEH, f);
    }
    unobserve(f) {
      removeEventHandlerListener(this._eH, f);
    }
    unobserveDeep(f) {
      removeEventHandlerListener(this._dEH, f);
    }
    toJSON() {
    }
  };
  var typeListSlice = (type, start, end) => {
    if (start < 0) {
      start = type._length + start;
    }
    if (end < 0) {
      end = type._length + end;
    }
    let len = end - start;
    const cs = [];
    let n2 = type._start;
    while (n2 !== null && len > 0) {
      if (n2.countable && !n2.deleted) {
        const c2 = n2.content.getContent();
        if (c2.length <= start) {
          start -= c2.length;
        } else {
          for (let i = start; i < c2.length && len > 0; i++) {
            cs.push(c2[i]);
            len--;
          }
          start = 0;
        }
      }
      n2 = n2.right;
    }
    return cs;
  };
  var typeListToArray = (type) => {
    const cs = [];
    let n2 = type._start;
    while (n2 !== null) {
      if (n2.countable && !n2.deleted) {
        const c2 = n2.content.getContent();
        for (let i = 0; i < c2.length; i++) {
          cs.push(c2[i]);
        }
      }
      n2 = n2.right;
    }
    return cs;
  };
  var typeListForEach = (type, f) => {
    let index2 = 0;
    let n2 = type._start;
    while (n2 !== null) {
      if (n2.countable && !n2.deleted) {
        const c2 = n2.content.getContent();
        for (let i = 0; i < c2.length; i++) {
          f(c2[i], index2++, type);
        }
      }
      n2 = n2.right;
    }
  };
  var typeListMap = (type, f) => {
    const result = [];
    typeListForEach(type, (c2, i) => {
      result.push(f(c2, i, type));
    });
    return result;
  };
  var typeListCreateIterator = (type) => {
    let n2 = type._start;
    let currentContent = null;
    let currentContentIndex = 0;
    return {
      [Symbol.iterator]() {
        return this;
      },
      next: () => {
        if (currentContent === null) {
          while (n2 !== null && n2.deleted) {
            n2 = n2.right;
          }
          if (n2 === null) {
            return {
              done: true,
              value: void 0
            };
          }
          currentContent = n2.content.getContent();
          currentContentIndex = 0;
          n2 = n2.right;
        }
        const value = currentContent[currentContentIndex++];
        if (currentContent.length <= currentContentIndex) {
          currentContent = null;
        }
        return {
          done: false,
          value
        };
      }
    };
  };
  var typeListGet = (type, index2) => {
    const marker = findMarker(type, index2);
    let n2 = type._start;
    if (marker !== null) {
      n2 = marker.p;
      index2 -= marker.index;
    }
    for (; n2 !== null; n2 = n2.right) {
      if (!n2.deleted && n2.countable) {
        if (index2 < n2.length) {
          return n2.content.getContent()[index2];
        }
        index2 -= n2.length;
      }
    }
  };
  var typeListInsertGenericsAfter = (transaction, parent, referenceItem, content2) => {
    let left = referenceItem;
    const doc3 = transaction.doc;
    const ownClientId = doc3.clientID;
    const store = doc3.store;
    const right = referenceItem === null ? parent._start : referenceItem.right;
    let jsonContent = [];
    const packJsonContent = () => {
      if (jsonContent.length > 0) {
        left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
        left.integrate(transaction, 0);
        jsonContent = [];
      }
    };
    content2.forEach((c2) => {
      if (c2 === null) {
        jsonContent.push(c2);
      } else {
        switch (c2.constructor) {
          case Number:
          case Object:
          case Boolean:
          case Array:
          case String:
            jsonContent.push(c2);
            break;
          default:
            packJsonContent();
            switch (c2.constructor) {
              case Uint8Array:
              case ArrayBuffer:
                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(c2)));
                left.integrate(transaction, 0);
                break;
              case Doc:
                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(c2));
                left.integrate(transaction, 0);
                break;
              default:
                if (c2 instanceof AbstractType) {
                  left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c2));
                  left.integrate(transaction, 0);
                } else {
                  throw new Error("Unexpected content type in insert operation");
                }
            }
        }
      }
    });
    packJsonContent();
  };
  var lengthExceeded = create3("Length exceeded!");
  var typeListInsertGenerics = (transaction, parent, index2, content2) => {
    if (index2 > parent._length) {
      throw lengthExceeded;
    }
    if (index2 === 0) {
      if (parent._searchMarker) {
        updateMarkerChanges(parent._searchMarker, index2, content2.length);
      }
      return typeListInsertGenericsAfter(transaction, parent, null, content2);
    }
    const startIndex = index2;
    const marker = findMarker(parent, index2);
    let n2 = parent._start;
    if (marker !== null) {
      n2 = marker.p;
      index2 -= marker.index;
      if (index2 === 0) {
        n2 = n2.prev;
        index2 += n2 && n2.countable && !n2.deleted ? n2.length : 0;
      }
    }
    for (; n2 !== null; n2 = n2.right) {
      if (!n2.deleted && n2.countable) {
        if (index2 <= n2.length) {
          if (index2 < n2.length) {
            getItemCleanStart(transaction, createID(n2.id.client, n2.id.clock + index2));
          }
          break;
        }
        index2 -= n2.length;
      }
    }
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, startIndex, content2.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, n2, content2);
  };
  var typeListPushGenerics = (transaction, parent, content2) => {
    const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
    let n2 = marker.p;
    if (n2) {
      while (n2.right) {
        n2 = n2.right;
      }
    }
    return typeListInsertGenericsAfter(transaction, parent, n2, content2);
  };
  var typeListDelete = (transaction, parent, index2, length3) => {
    if (length3 === 0) {
      return;
    }
    const startIndex = index2;
    const startLength = length3;
    const marker = findMarker(parent, index2);
    let n2 = parent._start;
    if (marker !== null) {
      n2 = marker.p;
      index2 -= marker.index;
    }
    for (; n2 !== null && index2 > 0; n2 = n2.right) {
      if (!n2.deleted && n2.countable) {
        if (index2 < n2.length) {
          getItemCleanStart(transaction, createID(n2.id.client, n2.id.clock + index2));
        }
        index2 -= n2.length;
      }
    }
    while (length3 > 0 && n2 !== null) {
      if (!n2.deleted) {
        if (length3 < n2.length) {
          getItemCleanStart(transaction, createID(n2.id.client, n2.id.clock + length3));
        }
        n2.delete(transaction);
        length3 -= n2.length;
      }
      n2 = n2.right;
    }
    if (length3 > 0) {
      throw lengthExceeded;
    }
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length3);
    }
  };
  var typeMapDelete = (transaction, parent, key) => {
    const c2 = parent._map.get(key);
    if (c2 !== void 0) {
      c2.delete(transaction);
    }
  };
  var typeMapSet = (transaction, parent, key, value) => {
    const left = parent._map.get(key) || null;
    const doc3 = transaction.doc;
    const ownClientId = doc3.clientID;
    let content2;
    if (value == null) {
      content2 = new ContentAny([value]);
    } else {
      switch (value.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          content2 = new ContentAny([value]);
          break;
        case Uint8Array:
          content2 = new ContentBinary(value);
          break;
        case Doc:
          content2 = new ContentDoc(value);
          break;
        default:
          if (value instanceof AbstractType) {
            content2 = new ContentType(value);
          } else {
            throw new Error("Unexpected content type");
          }
      }
    }
    new Item(createID(ownClientId, getState(doc3.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content2).integrate(transaction, 0);
  };
  var typeMapGet = (parent, key) => {
    const val = parent._map.get(key);
    return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;
  };
  var typeMapGetAll = (parent) => {
    const res = {};
    parent._map.forEach((value, key) => {
      if (!value.deleted) {
        res[key] = value.content.getContent()[value.length - 1];
      }
    });
    return res;
  };
  var typeMapHas = (parent, key) => {
    const val = parent._map.get(key);
    return val !== void 0 && !val.deleted;
  };
  var createMapIterator = (map3) => iteratorFilter(map3.entries(), (entry) => !entry[1].deleted);
  var YArrayEvent = class extends YEvent {
    constructor(yarray, transaction) {
      super(yarray, transaction);
      this._transaction = transaction;
    }
  };
  var YArray = class extends AbstractType {
    constructor() {
      super();
      this._prelimContent = [];
      this._searchMarker = [];
    }
    static from(items) {
      const a2 = new YArray();
      a2.push(items);
      return a2;
    }
    _integrate(y3, item) {
      super._integrate(y3, item);
      this.insert(0, this._prelimContent);
      this._prelimContent = null;
    }
    _copy() {
      return new YArray();
    }
    clone() {
      const arr = new YArray();
      arr.insert(0, this.toArray().map(
        (el) => el instanceof AbstractType ? el.clone() : el
      ));
      return arr;
    }
    get length() {
      return this._prelimContent === null ? this._length : this._prelimContent.length;
    }
    _callObserver(transaction, parentSubs) {
      super._callObserver(transaction, parentSubs);
      callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
    }
    insert(index2, content2) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeListInsertGenerics(transaction, this, index2, content2);
        });
      } else {
        this._prelimContent.splice(index2, 0, ...content2);
      }
    }
    push(content2) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeListPushGenerics(transaction, this, content2);
        });
      } else {
        this._prelimContent.push(...content2);
      }
    }
    unshift(content2) {
      this.insert(0, content2);
    }
    delete(index2, length3 = 1) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeListDelete(transaction, this, index2, length3);
        });
      } else {
        this._prelimContent.splice(index2, length3);
      }
    }
    get(index2) {
      return typeListGet(this, index2);
    }
    toArray() {
      return typeListToArray(this);
    }
    slice(start = 0, end = this.length) {
      return typeListSlice(this, start, end);
    }
    toJSON() {
      return this.map((c2) => c2 instanceof AbstractType ? c2.toJSON() : c2);
    }
    map(f) {
      return typeListMap(this, f);
    }
    forEach(f) {
      typeListForEach(this, f);
    }
    [Symbol.iterator]() {
      return typeListCreateIterator(this);
    }
    _write(encoder) {
      encoder.writeTypeRef(YArrayRefID);
    }
  };
  var readYArray = (decoder) => new YArray();
  var YMapEvent = class extends YEvent {
    constructor(ymap, transaction, subs) {
      super(ymap, transaction);
      this.keysChanged = subs;
    }
  };
  var YMap = class extends AbstractType {
    constructor(entries) {
      super();
      this._prelimContent = null;
      if (entries === void 0) {
        this._prelimContent = /* @__PURE__ */ new Map();
      } else {
        this._prelimContent = new Map(entries);
      }
    }
    _integrate(y3, item) {
      super._integrate(y3, item);
      this._prelimContent.forEach((value, key) => {
        this.set(key, value);
      });
      this._prelimContent = null;
    }
    _copy() {
      return new YMap();
    }
    clone() {
      const map3 = new YMap();
      this.forEach((value, key) => {
        map3.set(key, value instanceof AbstractType ? value.clone() : value);
      });
      return map3;
    }
    _callObserver(transaction, parentSubs) {
      callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
    }
    toJSON() {
      const map3 = {};
      this._map.forEach((item, key) => {
        if (!item.deleted) {
          const v = item.content.getContent()[item.length - 1];
          map3[key] = v instanceof AbstractType ? v.toJSON() : v;
        }
      });
      return map3;
    }
    get size() {
      return [...createMapIterator(this._map)].length;
    }
    keys() {
      return iteratorMap(createMapIterator(this._map), (v) => v[0]);
    }
    values() {
      return iteratorMap(createMapIterator(this._map), (v) => v[1].content.getContent()[v[1].length - 1]);
    }
    entries() {
      return iteratorMap(createMapIterator(this._map), (v) => [v[0], v[1].content.getContent()[v[1].length - 1]]);
    }
    forEach(f) {
      this._map.forEach((item, key) => {
        if (!item.deleted) {
          f(item.content.getContent()[item.length - 1], key, this);
        }
      });
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    delete(key) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeMapDelete(transaction, this, key);
        });
      } else {
        this._prelimContent.delete(key);
      }
    }
    set(key, value) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeMapSet(transaction, this, key, value);
        });
      } else {
        this._prelimContent.set(key, value);
      }
      return value;
    }
    get(key) {
      return typeMapGet(this, key);
    }
    has(key) {
      return typeMapHas(this, key);
    }
    clear() {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          this.forEach(function(value, key, map3) {
            typeMapDelete(transaction, map3, key);
          });
        });
      } else {
        this._prelimContent.clear();
      }
    }
    _write(encoder) {
      encoder.writeTypeRef(YMapRefID);
    }
  };
  var readYMap = (decoder) => new YMap();
  var equalAttrs = (a2, b) => a2 === b || typeof a2 === "object" && typeof b === "object" && a2 && b && equalFlat(a2, b);
  var ItemTextListPosition = class {
    constructor(left, right, index2, currentAttributes) {
      this.left = left;
      this.right = right;
      this.index = index2;
      this.currentAttributes = currentAttributes;
    }
    forward() {
      if (this.right === null) {
        unexpectedCase();
      }
      switch (this.right.content.constructor) {
        case ContentFormat:
          if (!this.right.deleted) {
            updateCurrentAttributes(this.currentAttributes, this.right.content);
          }
          break;
        default:
          if (!this.right.deleted) {
            this.index += this.right.length;
          }
          break;
      }
      this.left = this.right;
      this.right = this.right.right;
    }
  };
  var findNextPosition = (transaction, pos, count2) => {
    while (pos.right !== null && count2 > 0) {
      switch (pos.right.content.constructor) {
        case ContentFormat:
          if (!pos.right.deleted) {
            updateCurrentAttributes(pos.currentAttributes, pos.right.content);
          }
          break;
        default:
          if (!pos.right.deleted) {
            if (count2 < pos.right.length) {
              getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count2));
            }
            pos.index += pos.right.length;
            count2 -= pos.right.length;
          }
          break;
      }
      pos.left = pos.right;
      pos.right = pos.right.right;
    }
    return pos;
  };
  var findPosition2 = (transaction, parent, index2) => {
    const currentAttributes = /* @__PURE__ */ new Map();
    const marker = findMarker(parent, index2);
    if (marker) {
      const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
      return findNextPosition(transaction, pos, index2 - marker.index);
    } else {
      const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
      return findNextPosition(transaction, pos, index2);
    }
  };
  var insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {
    while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(negatedAttributes.get(currPos.right.content.key), currPos.right.content.value))) {
      if (!currPos.right.deleted) {
        negatedAttributes.delete(currPos.right.content.key);
      }
      currPos.forward();
    }
    const doc3 = transaction.doc;
    const ownClientId = doc3.clientID;
    negatedAttributes.forEach((val, key) => {
      const left = currPos.left;
      const right = currPos.right;
      const nextFormat = new Item(createID(ownClientId, getState(doc3.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
      nextFormat.integrate(transaction, 0);
      currPos.right = nextFormat;
      currPos.forward();
    });
  };
  var updateCurrentAttributes = (currentAttributes, format2) => {
    const { key, value } = format2;
    if (value === null) {
      currentAttributes.delete(key);
    } else {
      currentAttributes.set(key, value);
    }
  };
  var minimizeAttributeChanges = (currPos, attributes) => {
    while (true) {
      if (currPos.right === null) {
        break;
      } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[currPos.right.content.key] || null, currPos.right.content.value))
        ;
      else {
        break;
      }
      currPos.forward();
    }
  };
  var insertAttributes = (transaction, parent, currPos, attributes) => {
    const doc3 = transaction.doc;
    const ownClientId = doc3.clientID;
    const negatedAttributes = /* @__PURE__ */ new Map();
    for (const key in attributes) {
      const val = attributes[key];
      const currentVal = currPos.currentAttributes.get(key) || null;
      if (!equalAttrs(currentVal, val)) {
        negatedAttributes.set(key, currentVal);
        const { left, right } = currPos;
        currPos.right = new Item(createID(ownClientId, getState(doc3.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
        currPos.right.integrate(transaction, 0);
        currPos.forward();
      }
    }
    return negatedAttributes;
  };
  var insertText = (transaction, parent, currPos, text3, attributes) => {
    currPos.currentAttributes.forEach((val, key) => {
      if (attributes[key] === void 0) {
        attributes[key] = null;
      }
    });
    const doc3 = transaction.doc;
    const ownClientId = doc3.clientID;
    minimizeAttributeChanges(currPos, attributes);
    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
    const content2 = text3.constructor === String ? new ContentString(text3) : text3 instanceof AbstractType ? new ContentType(text3) : new ContentEmbed(text3);
    let { left, right, index: index2 } = currPos;
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, currPos.index, content2.getLength());
    }
    right = new Item(createID(ownClientId, getState(doc3.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content2);
    right.integrate(transaction, 0);
    currPos.right = right;
    currPos.index = index2;
    currPos.forward();
    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
  };
  var formatText = (transaction, parent, currPos, length3, attributes) => {
    const doc3 = transaction.doc;
    const ownClientId = doc3.clientID;
    minimizeAttributeChanges(currPos, attributes);
    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
    iterationLoop:
      while (currPos.right !== null && (length3 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {
        if (!currPos.right.deleted) {
          switch (currPos.right.content.constructor) {
            case ContentFormat: {
              const { key, value } = currPos.right.content;
              const attr = attributes[key];
              if (attr !== void 0) {
                if (equalAttrs(attr, value)) {
                  negatedAttributes.delete(key);
                } else {
                  if (length3 === 0) {
                    break iterationLoop;
                  }
                  negatedAttributes.set(key, value);
                }
                currPos.right.delete(transaction);
              } else {
                currPos.currentAttributes.set(key, value);
              }
              break;
            }
            default:
              if (length3 < currPos.right.length) {
                getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length3));
              }
              length3 -= currPos.right.length;
              break;
          }
        }
        currPos.forward();
      }
    if (length3 > 0) {
      let newlines = "";
      for (; length3 > 0; length3--) {
        newlines += "\n";
      }
      currPos.right = new Item(createID(ownClientId, getState(doc3.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
      currPos.right.integrate(transaction, 0);
      currPos.forward();
    }
    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
  };
  var cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {
    let end = curr;
    const endAttributes = copy(currAttributes);
    while (end && (!end.countable || end.deleted)) {
      if (!end.deleted && end.content.constructor === ContentFormat) {
        updateCurrentAttributes(endAttributes, end.content);
      }
      end = end.right;
    }
    let cleanups = 0;
    let reachedEndOfCurr = false;
    while (start !== end) {
      if (curr === start) {
        reachedEndOfCurr = true;
      }
      if (!start.deleted) {
        const content2 = start.content;
        switch (content2.constructor) {
          case ContentFormat: {
            const { key, value } = content2;
            if ((endAttributes.get(key) || null) !== value || (startAttributes.get(key) || null) === value) {
              start.delete(transaction);
              cleanups++;
              if (!reachedEndOfCurr && (currAttributes.get(key) || null) === value && (startAttributes.get(key) || null) !== value) {
                currAttributes.delete(key);
              }
            }
            break;
          }
        }
      }
      start = start.right;
    }
    return cleanups;
  };
  var cleanupContextlessFormattingGap = (transaction, item) => {
    while (item && item.right && (item.right.deleted || !item.right.countable)) {
      item = item.right;
    }
    const attrs = /* @__PURE__ */ new Set();
    while (item && (item.deleted || !item.countable)) {
      if (!item.deleted && item.content.constructor === ContentFormat) {
        const key = item.content.key;
        if (attrs.has(key)) {
          item.delete(transaction);
        } else {
          attrs.add(key);
        }
      }
      item = item.left;
    }
  };
  var cleanupYTextFormatting = (type) => {
    let res = 0;
    transact(type.doc, (transaction) => {
      let start = type._start;
      let end = type._start;
      let startAttributes = create();
      const currentAttributes = copy(startAttributes);
      while (end) {
        if (end.deleted === false) {
          switch (end.content.constructor) {
            case ContentFormat:
              updateCurrentAttributes(currentAttributes, end.content);
              break;
            default:
              res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
              startAttributes = copy(currentAttributes);
              start = end;
              break;
          }
        }
        end = end.right;
      }
    });
    return res;
  };
  var deleteText = (transaction, currPos, length3) => {
    const startLength = length3;
    const startAttrs = copy(currPos.currentAttributes);
    const start = currPos.right;
    while (length3 > 0 && currPos.right !== null) {
      if (currPos.right.deleted === false) {
        switch (currPos.right.content.constructor) {
          case ContentType:
          case ContentEmbed:
          case ContentString:
            if (length3 < currPos.right.length) {
              getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length3));
            }
            length3 -= currPos.right.length;
            currPos.right.delete(transaction);
            break;
        }
      }
      currPos.forward();
    }
    if (start) {
      cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
    }
    const parent = (currPos.left || currPos.right).parent;
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length3);
    }
    return currPos;
  };
  var YTextEvent = class extends YEvent {
    constructor(ytext, transaction, subs) {
      super(ytext, transaction);
      this.childListChanged = false;
      this.keysChanged = /* @__PURE__ */ new Set();
      subs.forEach((sub) => {
        if (sub === null) {
          this.childListChanged = true;
        } else {
          this.keysChanged.add(sub);
        }
      });
    }
    get changes() {
      if (this._changes === null) {
        const changes = {
          keys: this.keys,
          delta: this.delta,
          added: /* @__PURE__ */ new Set(),
          deleted: /* @__PURE__ */ new Set()
        };
        this._changes = changes;
      }
      return this._changes;
    }
    get delta() {
      if (this._delta === null) {
        const y3 = this.target.doc;
        const delta = [];
        transact(y3, (transaction) => {
          const currentAttributes = /* @__PURE__ */ new Map();
          const oldAttributes = /* @__PURE__ */ new Map();
          let item = this.target._start;
          let action = null;
          const attributes = {};
          let insert2 = "";
          let retain = 0;
          let deleteLen = 0;
          const addOp = () => {
            if (action !== null) {
              let op;
              switch (action) {
                case "delete":
                  op = { delete: deleteLen };
                  deleteLen = 0;
                  break;
                case "insert":
                  op = { insert: insert2 };
                  if (currentAttributes.size > 0) {
                    op.attributes = {};
                    currentAttributes.forEach((value, key) => {
                      if (value !== null) {
                        op.attributes[key] = value;
                      }
                    });
                  }
                  insert2 = "";
                  break;
                case "retain":
                  op = { retain };
                  if (Object.keys(attributes).length > 0) {
                    op.attributes = {};
                    for (const key in attributes) {
                      op.attributes[key] = attributes[key];
                    }
                  }
                  retain = 0;
                  break;
              }
              delta.push(op);
              action = null;
            }
          };
          while (item !== null) {
            switch (item.content.constructor) {
              case ContentType:
              case ContentEmbed:
                if (this.adds(item)) {
                  if (!this.deletes(item)) {
                    addOp();
                    action = "insert";
                    insert2 = item.content.getContent()[0];
                    addOp();
                  }
                } else if (this.deletes(item)) {
                  if (action !== "delete") {
                    addOp();
                    action = "delete";
                  }
                  deleteLen += 1;
                } else if (!item.deleted) {
                  if (action !== "retain") {
                    addOp();
                    action = "retain";
                  }
                  retain += 1;
                }
                break;
              case ContentString:
                if (this.adds(item)) {
                  if (!this.deletes(item)) {
                    if (action !== "insert") {
                      addOp();
                      action = "insert";
                    }
                    insert2 += item.content.str;
                  }
                } else if (this.deletes(item)) {
                  if (action !== "delete") {
                    addOp();
                    action = "delete";
                  }
                  deleteLen += item.length;
                } else if (!item.deleted) {
                  if (action !== "retain") {
                    addOp();
                    action = "retain";
                  }
                  retain += item.length;
                }
                break;
              case ContentFormat: {
                const { key, value } = item.content;
                if (this.adds(item)) {
                  if (!this.deletes(item)) {
                    const curVal = currentAttributes.get(key) || null;
                    if (!equalAttrs(curVal, value)) {
                      if (action === "retain") {
                        addOp();
                      }
                      if (equalAttrs(value, oldAttributes.get(key) || null)) {
                        delete attributes[key];
                      } else {
                        attributes[key] = value;
                      }
                    } else if (value !== null) {
                      item.delete(transaction);
                    }
                  }
                } else if (this.deletes(item)) {
                  oldAttributes.set(key, value);
                  const curVal = currentAttributes.get(key) || null;
                  if (!equalAttrs(curVal, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    attributes[key] = curVal;
                  }
                } else if (!item.deleted) {
                  oldAttributes.set(key, value);
                  const attr = attributes[key];
                  if (attr !== void 0) {
                    if (!equalAttrs(attr, value)) {
                      if (action === "retain") {
                        addOp();
                      }
                      if (value === null) {
                        delete attributes[key];
                      } else {
                        attributes[key] = value;
                      }
                    } else if (attr !== null) {
                      item.delete(transaction);
                    }
                  }
                }
                if (!item.deleted) {
                  if (action === "insert") {
                    addOp();
                  }
                  updateCurrentAttributes(currentAttributes, item.content);
                }
                break;
              }
            }
            item = item.right;
          }
          addOp();
          while (delta.length > 0) {
            const lastOp = delta[delta.length - 1];
            if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {
              delta.pop();
            } else {
              break;
            }
          }
        });
        this._delta = delta;
      }
      return this._delta;
    }
  };
  var YText = class extends AbstractType {
    constructor(string3) {
      super();
      this._pending = string3 !== void 0 ? [() => this.insert(0, string3)] : [];
      this._searchMarker = [];
    }
    get length() {
      return this._length;
    }
    _integrate(y3, item) {
      super._integrate(y3, item);
      try {
        this._pending.forEach((f) => f());
      } catch (e) {
        console.error(e);
      }
      this._pending = null;
    }
    _copy() {
      return new YText();
    }
    clone() {
      const text3 = new YText();
      text3.applyDelta(this.toDelta());
      return text3;
    }
    _callObserver(transaction, parentSubs) {
      super._callObserver(transaction, parentSubs);
      const event = new YTextEvent(this, transaction, parentSubs);
      const doc3 = transaction.doc;
      callTypeObservers(this, transaction, event);
      if (!transaction.local) {
        let foundFormattingItem = false;
        for (const [client, afterClock] of transaction.afterState.entries()) {
          const clock2 = transaction.beforeState.get(client) || 0;
          if (afterClock === clock2) {
            continue;
          }
          iterateStructs(transaction, doc3.store.clients.get(client), clock2, afterClock, (item) => {
            if (!item.deleted && item.content.constructor === ContentFormat) {
              foundFormattingItem = true;
            }
          });
          if (foundFormattingItem) {
            break;
          }
        }
        if (!foundFormattingItem) {
          iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {
            if (item instanceof GC || foundFormattingItem) {
              return;
            }
            if (item.parent === this && item.content.constructor === ContentFormat) {
              foundFormattingItem = true;
            }
          });
        }
        transact(doc3, (t2) => {
          if (foundFormattingItem) {
            cleanupYTextFormatting(this);
          } else {
            iterateDeletedStructs(t2, t2.deleteSet, (item) => {
              if (item instanceof GC) {
                return;
              }
              if (item.parent === this) {
                cleanupContextlessFormattingGap(t2, item);
              }
            });
          }
        });
      }
    }
    toString() {
      let str = "";
      let n2 = this._start;
      while (n2 !== null) {
        if (!n2.deleted && n2.countable && n2.content.constructor === ContentString) {
          str += n2.content.str;
        }
        n2 = n2.right;
      }
      return str;
    }
    toJSON() {
      return this.toString();
    }
    applyDelta(delta, { sanitize = true } = {}) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());
          for (let i = 0; i < delta.length; i++) {
            const op = delta[i];
            if (op.insert !== void 0) {
              const ins = !sanitize && typeof op.insert === "string" && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
              if (typeof ins !== "string" || ins.length > 0) {
                insertText(transaction, this, currPos, ins, op.attributes || {});
              }
            } else if (op.retain !== void 0) {
              formatText(transaction, this, currPos, op.retain, op.attributes || {});
            } else if (op.delete !== void 0) {
              deleteText(transaction, currPos, op.delete);
            }
          }
        });
      } else {
        this._pending.push(() => this.applyDelta(delta));
      }
    }
    toDelta(snapshot, prevSnapshot, computeYChange) {
      const ops = [];
      const currentAttributes = /* @__PURE__ */ new Map();
      const doc3 = this.doc;
      let str = "";
      let n2 = this._start;
      function packStr() {
        if (str.length > 0) {
          const attributes = {};
          let addAttributes = false;
          currentAttributes.forEach((value, key) => {
            addAttributes = true;
            attributes[key] = value;
          });
          const op = { insert: str };
          if (addAttributes) {
            op.attributes = attributes;
          }
          ops.push(op);
          str = "";
        }
      }
      transact(doc3, (transaction) => {
        if (snapshot) {
          splitSnapshotAffectedStructs(transaction, snapshot);
        }
        if (prevSnapshot) {
          splitSnapshotAffectedStructs(transaction, prevSnapshot);
        }
        while (n2 !== null) {
          if (isVisible(n2, snapshot) || prevSnapshot !== void 0 && isVisible(n2, prevSnapshot)) {
            switch (n2.content.constructor) {
              case ContentString: {
                const cur2 = currentAttributes.get("ychange");
                if (snapshot !== void 0 && !isVisible(n2, snapshot)) {
                  if (cur2 === void 0 || cur2.user !== n2.id.client || cur2.type !== "removed") {
                    packStr();
                    currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n2.id) : { type: "removed" });
                  }
                } else if (prevSnapshot !== void 0 && !isVisible(n2, prevSnapshot)) {
                  if (cur2 === void 0 || cur2.user !== n2.id.client || cur2.type !== "added") {
                    packStr();
                    currentAttributes.set("ychange", computeYChange ? computeYChange("added", n2.id) : { type: "added" });
                  }
                } else if (cur2 !== void 0) {
                  packStr();
                  currentAttributes.delete("ychange");
                }
                str += n2.content.str;
                break;
              }
              case ContentType:
              case ContentEmbed: {
                packStr();
                const op = {
                  insert: n2.content.getContent()[0]
                };
                if (currentAttributes.size > 0) {
                  const attrs = {};
                  op.attributes = attrs;
                  currentAttributes.forEach((value, key) => {
                    attrs[key] = value;
                  });
                }
                ops.push(op);
                break;
              }
              case ContentFormat:
                if (isVisible(n2, snapshot)) {
                  packStr();
                  updateCurrentAttributes(currentAttributes, n2.content);
                }
                break;
            }
          }
          n2 = n2.right;
        }
        packStr();
      }, "cleanup");
      return ops;
    }
    insert(index2, text3, attributes) {
      if (text3.length <= 0) {
        return;
      }
      const y3 = this.doc;
      if (y3 !== null) {
        transact(y3, (transaction) => {
          const pos = findPosition2(transaction, this, index2);
          if (!attributes) {
            attributes = {};
            pos.currentAttributes.forEach((v, k) => {
              attributes[k] = v;
            });
          }
          insertText(transaction, this, pos, text3, attributes);
        });
      } else {
        this._pending.push(() => this.insert(index2, text3, attributes));
      }
    }
    insertEmbed(index2, embed, attributes = {}) {
      const y3 = this.doc;
      if (y3 !== null) {
        transact(y3, (transaction) => {
          const pos = findPosition2(transaction, this, index2);
          insertText(transaction, this, pos, embed, attributes);
        });
      } else {
        this._pending.push(() => this.insertEmbed(index2, embed, attributes));
      }
    }
    delete(index2, length3) {
      if (length3 === 0) {
        return;
      }
      const y3 = this.doc;
      if (y3 !== null) {
        transact(y3, (transaction) => {
          deleteText(transaction, findPosition2(transaction, this, index2), length3);
        });
      } else {
        this._pending.push(() => this.delete(index2, length3));
      }
    }
    format(index2, length3, attributes) {
      if (length3 === 0) {
        return;
      }
      const y3 = this.doc;
      if (y3 !== null) {
        transact(y3, (transaction) => {
          const pos = findPosition2(transaction, this, index2);
          if (pos.right === null) {
            return;
          }
          formatText(transaction, this, pos, length3, attributes);
        });
      } else {
        this._pending.push(() => this.format(index2, length3, attributes));
      }
    }
    removeAttribute(attributeName) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeMapDelete(transaction, this, attributeName);
        });
      } else {
        this._pending.push(() => this.removeAttribute(attributeName));
      }
    }
    setAttribute(attributeName, attributeValue) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeMapSet(transaction, this, attributeName, attributeValue);
        });
      } else {
        this._pending.push(() => this.setAttribute(attributeName, attributeValue));
      }
    }
    getAttribute(attributeName) {
      return typeMapGet(this, attributeName);
    }
    getAttributes(snapshot) {
      return typeMapGetAll(this);
    }
    _write(encoder) {
      encoder.writeTypeRef(YTextRefID);
    }
  };
  var readYText = (decoder) => new YText();
  var YXmlTreeWalker = class {
    constructor(root, f = () => true) {
      this._filter = f;
      this._root = root;
      this._currentNode = root._start;
      this._firstCall = true;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      let n2 = this._currentNode;
      let type = n2 && n2.content && n2.content.type;
      if (n2 !== null && (!this._firstCall || n2.deleted || !this._filter(type))) {
        do {
          type = n2.content.type;
          if (!n2.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {
            n2 = type._start;
          } else {
            while (n2 !== null) {
              if (n2.right !== null) {
                n2 = n2.right;
                break;
              } else if (n2.parent === this._root) {
                n2 = null;
              } else {
                n2 = n2.parent._item;
              }
            }
          }
        } while (n2 !== null && (n2.deleted || !this._filter(n2.content.type)));
      }
      this._firstCall = false;
      if (n2 === null) {
        return { value: void 0, done: true };
      }
      this._currentNode = n2;
      return { value: n2.content.type, done: false };
    }
  };
  var YXmlFragment = class extends AbstractType {
    constructor() {
      super();
      this._prelimContent = [];
    }
    get firstChild() {
      const first = this._first;
      return first ? first.content.getContent()[0] : null;
    }
    _integrate(y3, item) {
      super._integrate(y3, item);
      this.insert(0, this._prelimContent);
      this._prelimContent = null;
    }
    _copy() {
      return new YXmlFragment();
    }
    clone() {
      const el = new YXmlFragment();
      el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
      return el;
    }
    get length() {
      return this._prelimContent === null ? this._length : this._prelimContent.length;
    }
    createTreeWalker(filter) {
      return new YXmlTreeWalker(this, filter);
    }
    querySelector(query) {
      query = query.toUpperCase();
      const iterator = new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query);
      const next = iterator.next();
      if (next.done) {
        return null;
      } else {
        return next.value;
      }
    }
    querySelectorAll(query) {
      query = query.toUpperCase();
      return Array.from(new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query));
    }
    _callObserver(transaction, parentSubs) {
      callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
    }
    toString() {
      return typeListMap(this, (xml) => xml.toString()).join("");
    }
    toJSON() {
      return this.toString();
    }
    toDOM(_document = document, hooks = {}, binding) {
      const fragment = _document.createDocumentFragment();
      if (binding !== void 0) {
        binding._createAssociation(fragment, this);
      }
      typeListForEach(this, (xmlType) => {
        fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
      });
      return fragment;
    }
    insert(index2, content2) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeListInsertGenerics(transaction, this, index2, content2);
        });
      } else {
        this._prelimContent.splice(index2, 0, ...content2);
      }
    }
    insertAfter(ref, content2) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
          typeListInsertGenericsAfter(transaction, this, refItem, content2);
        });
      } else {
        const pc = this._prelimContent;
        const index2 = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;
        if (index2 === 0 && ref !== null) {
          throw create3("Reference item not found");
        }
        pc.splice(index2, 0, ...content2);
      }
    }
    delete(index2, length3 = 1) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeListDelete(transaction, this, index2, length3);
        });
      } else {
        this._prelimContent.splice(index2, length3);
      }
    }
    toArray() {
      return typeListToArray(this);
    }
    push(content2) {
      this.insert(this.length, content2);
    }
    unshift(content2) {
      this.insert(0, content2);
    }
    get(index2) {
      return typeListGet(this, index2);
    }
    slice(start = 0, end = this.length) {
      return typeListSlice(this, start, end);
    }
    forEach(f) {
      typeListForEach(this, f);
    }
    _write(encoder) {
      encoder.writeTypeRef(YXmlFragmentRefID);
    }
  };
  var readYXmlFragment = (decoder) => new YXmlFragment();
  var YXmlElement = class extends YXmlFragment {
    constructor(nodeName = "UNDEFINED") {
      super();
      this.nodeName = nodeName;
      this._prelimAttrs = /* @__PURE__ */ new Map();
    }
    get nextSibling() {
      const n2 = this._item ? this._item.next : null;
      return n2 ? n2.content.type : null;
    }
    get prevSibling() {
      const n2 = this._item ? this._item.prev : null;
      return n2 ? n2.content.type : null;
    }
    _integrate(y3, item) {
      super._integrate(y3, item);
      this._prelimAttrs.forEach((value, key) => {
        this.setAttribute(key, value);
      });
      this._prelimAttrs = null;
    }
    _copy() {
      return new YXmlElement(this.nodeName);
    }
    clone() {
      const el = new YXmlElement(this.nodeName);
      const attrs = this.getAttributes();
      for (const key in attrs) {
        el.setAttribute(key, attrs[key]);
      }
      el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
      return el;
    }
    toString() {
      const attrs = this.getAttributes();
      const stringBuilder = [];
      const keys3 = [];
      for (const key in attrs) {
        keys3.push(key);
      }
      keys3.sort();
      const keysLen = keys3.length;
      for (let i = 0; i < keysLen; i++) {
        const key = keys3[i];
        stringBuilder.push(key + '="' + attrs[key] + '"');
      }
      const nodeName = this.nodeName.toLocaleLowerCase();
      const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
      return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
    }
    removeAttribute(attributeName) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeMapDelete(transaction, this, attributeName);
        });
      } else {
        this._prelimAttrs.delete(attributeName);
      }
    }
    setAttribute(attributeName, attributeValue) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeMapSet(transaction, this, attributeName, attributeValue);
        });
      } else {
        this._prelimAttrs.set(attributeName, attributeValue);
      }
    }
    getAttribute(attributeName) {
      return typeMapGet(this, attributeName);
    }
    hasAttribute(attributeName) {
      return typeMapHas(this, attributeName);
    }
    getAttributes() {
      return typeMapGetAll(this);
    }
    toDOM(_document = document, hooks = {}, binding) {
      const dom = _document.createElement(this.nodeName);
      const attrs = this.getAttributes();
      for (const key in attrs) {
        dom.setAttribute(key, attrs[key]);
      }
      typeListForEach(this, (yxml) => {
        dom.appendChild(yxml.toDOM(_document, hooks, binding));
      });
      if (binding !== void 0) {
        binding._createAssociation(dom, this);
      }
      return dom;
    }
    _write(encoder) {
      encoder.writeTypeRef(YXmlElementRefID);
      encoder.writeKey(this.nodeName);
    }
  };
  var readYXmlElement = (decoder) => new YXmlElement(decoder.readKey());
  var YXmlEvent = class extends YEvent {
    constructor(target, subs, transaction) {
      super(target, transaction);
      this.childListChanged = false;
      this.attributesChanged = /* @__PURE__ */ new Set();
      subs.forEach((sub) => {
        if (sub === null) {
          this.childListChanged = true;
        } else {
          this.attributesChanged.add(sub);
        }
      });
    }
  };
  var YXmlHook = class extends YMap {
    constructor(hookName) {
      super();
      this.hookName = hookName;
    }
    _copy() {
      return new YXmlHook(this.hookName);
    }
    clone() {
      const el = new YXmlHook(this.hookName);
      this.forEach((value, key) => {
        el.set(key, value);
      });
      return el;
    }
    toDOM(_document = document, hooks = {}, binding) {
      const hook = hooks[this.hookName];
      let dom;
      if (hook !== void 0) {
        dom = hook.createDom(this);
      } else {
        dom = document.createElement(this.hookName);
      }
      dom.setAttribute("data-yjs-hook", this.hookName);
      if (binding !== void 0) {
        binding._createAssociation(dom, this);
      }
      return dom;
    }
    _write(encoder) {
      encoder.writeTypeRef(YXmlHookRefID);
      encoder.writeKey(this.hookName);
    }
  };
  var readYXmlHook = (decoder) => new YXmlHook(decoder.readKey());
  var YXmlText = class extends YText {
    get nextSibling() {
      const n2 = this._item ? this._item.next : null;
      return n2 ? n2.content.type : null;
    }
    get prevSibling() {
      const n2 = this._item ? this._item.prev : null;
      return n2 ? n2.content.type : null;
    }
    _copy() {
      return new YXmlText();
    }
    clone() {
      const text3 = new YXmlText();
      text3.applyDelta(this.toDelta());
      return text3;
    }
    toDOM(_document = document, hooks, binding) {
      const dom = _document.createTextNode(this.toString());
      if (binding !== void 0) {
        binding._createAssociation(dom, this);
      }
      return dom;
    }
    toString() {
      return this.toDelta().map((delta) => {
        const nestedNodes = [];
        for (const nodeName in delta.attributes) {
          const attrs = [];
          for (const key in delta.attributes[nodeName]) {
            attrs.push({ key, value: delta.attributes[nodeName][key] });
          }
          attrs.sort((a2, b) => a2.key < b.key ? -1 : 1);
          nestedNodes.push({ nodeName, attrs });
        }
        nestedNodes.sort((a2, b) => a2.nodeName < b.nodeName ? -1 : 1);
        let str = "";
        for (let i = 0; i < nestedNodes.length; i++) {
          const node = nestedNodes[i];
          str += `<${node.nodeName}`;
          for (let j = 0; j < node.attrs.length; j++) {
            const attr = node.attrs[j];
            str += ` ${attr.key}="${attr.value}"`;
          }
          str += ">";
        }
        str += delta.insert;
        for (let i = nestedNodes.length - 1; i >= 0; i--) {
          str += `</${nestedNodes[i].nodeName}>`;
        }
        return str;
      }).join("");
    }
    toJSON() {
      return this.toString();
    }
    _write(encoder) {
      encoder.writeTypeRef(YXmlTextRefID);
    }
  };
  var readYXmlText = (decoder) => new YXmlText();
  var AbstractStruct = class {
    constructor(id3, length3) {
      this.id = id3;
      this.length = length3;
    }
    get deleted() {
      throw methodUnimplemented();
    }
    mergeWith(right) {
      return false;
    }
    write(encoder, offset, encodingRef) {
      throw methodUnimplemented();
    }
    integrate(transaction, offset) {
      throw methodUnimplemented();
    }
  };
  var structGCRefNumber = 0;
  var GC = class extends AbstractStruct {
    get deleted() {
      return true;
    }
    delete() {
    }
    mergeWith(right) {
      if (this.constructor !== right.constructor) {
        return false;
      }
      this.length += right.length;
      return true;
    }
    integrate(transaction, offset) {
      if (offset > 0) {
        this.id.clock += offset;
        this.length -= offset;
      }
      addStruct(transaction.doc.store, this);
    }
    write(encoder, offset) {
      encoder.writeInfo(structGCRefNumber);
      encoder.writeLen(this.length - offset);
    }
    getMissing(transaction, store) {
      return null;
    }
  };
  var ContentBinary = class {
    constructor(content2) {
      this.content = content2;
    }
    getLength() {
      return 1;
    }
    getContent() {
      return [this.content];
    }
    isCountable() {
      return true;
    }
    copy() {
      return new ContentBinary(this.content);
    }
    splice(offset) {
      throw methodUnimplemented();
    }
    mergeWith(right) {
      return false;
    }
    integrate(transaction, item) {
    }
    delete(transaction) {
    }
    gc(store) {
    }
    write(encoder, offset) {
      encoder.writeBuf(this.content);
    }
    getRef() {
      return 3;
    }
  };
  var readContentBinary = (decoder) => new ContentBinary(decoder.readBuf());
  var ContentDeleted = class {
    constructor(len) {
      this.len = len;
    }
    getLength() {
      return this.len;
    }
    getContent() {
      return [];
    }
    isCountable() {
      return false;
    }
    copy() {
      return new ContentDeleted(this.len);
    }
    splice(offset) {
      const right = new ContentDeleted(this.len - offset);
      this.len = offset;
      return right;
    }
    mergeWith(right) {
      this.len += right.len;
      return true;
    }
    integrate(transaction, item) {
      addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
      item.markDeleted();
    }
    delete(transaction) {
    }
    gc(store) {
    }
    write(encoder, offset) {
      encoder.writeLen(this.len - offset);
    }
    getRef() {
      return 1;
    }
  };
  var readContentDeleted = (decoder) => new ContentDeleted(decoder.readLen());
  var createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });
  var ContentDoc = class {
    constructor(doc3) {
      if (doc3._item) {
        console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
      }
      this.doc = doc3;
      const opts = {};
      this.opts = opts;
      if (!doc3.gc) {
        opts.gc = false;
      }
      if (doc3.autoLoad) {
        opts.autoLoad = true;
      }
      if (doc3.meta !== null) {
        opts.meta = doc3.meta;
      }
    }
    getLength() {
      return 1;
    }
    getContent() {
      return [this.doc];
    }
    isCountable() {
      return true;
    }
    copy() {
      return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
    }
    splice(offset) {
      throw methodUnimplemented();
    }
    mergeWith(right) {
      return false;
    }
    integrate(transaction, item) {
      this.doc._item = item;
      transaction.subdocsAdded.add(this.doc);
      if (this.doc.shouldLoad) {
        transaction.subdocsLoaded.add(this.doc);
      }
    }
    delete(transaction) {
      if (transaction.subdocsAdded.has(this.doc)) {
        transaction.subdocsAdded.delete(this.doc);
      } else {
        transaction.subdocsRemoved.add(this.doc);
      }
    }
    gc(store) {
    }
    write(encoder, offset) {
      encoder.writeString(this.doc.guid);
      encoder.writeAny(this.opts);
    }
    getRef() {
      return 9;
    }
  };
  var readContentDoc = (decoder) => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));
  var ContentEmbed = class {
    constructor(embed) {
      this.embed = embed;
    }
    getLength() {
      return 1;
    }
    getContent() {
      return [this.embed];
    }
    isCountable() {
      return true;
    }
    copy() {
      return new ContentEmbed(this.embed);
    }
    splice(offset) {
      throw methodUnimplemented();
    }
    mergeWith(right) {
      return false;
    }
    integrate(transaction, item) {
    }
    delete(transaction) {
    }
    gc(store) {
    }
    write(encoder, offset) {
      encoder.writeJSON(this.embed);
    }
    getRef() {
      return 5;
    }
  };
  var readContentEmbed = (decoder) => new ContentEmbed(decoder.readJSON());
  var ContentFormat = class {
    constructor(key, value) {
      this.key = key;
      this.value = value;
    }
    getLength() {
      return 1;
    }
    getContent() {
      return [];
    }
    isCountable() {
      return false;
    }
    copy() {
      return new ContentFormat(this.key, this.value);
    }
    splice(offset) {
      throw methodUnimplemented();
    }
    mergeWith(right) {
      return false;
    }
    integrate(transaction, item) {
      item.parent._searchMarker = null;
    }
    delete(transaction) {
    }
    gc(store) {
    }
    write(encoder, offset) {
      encoder.writeKey(this.key);
      encoder.writeJSON(this.value);
    }
    getRef() {
      return 6;
    }
  };
  var readContentFormat = (decoder) => new ContentFormat(decoder.readKey(), decoder.readJSON());
  var ContentJSON = class {
    constructor(arr) {
      this.arr = arr;
    }
    getLength() {
      return this.arr.length;
    }
    getContent() {
      return this.arr;
    }
    isCountable() {
      return true;
    }
    copy() {
      return new ContentJSON(this.arr);
    }
    splice(offset) {
      const right = new ContentJSON(this.arr.slice(offset));
      this.arr = this.arr.slice(0, offset);
      return right;
    }
    mergeWith(right) {
      this.arr = this.arr.concat(right.arr);
      return true;
    }
    integrate(transaction, item) {
    }
    delete(transaction) {
    }
    gc(store) {
    }
    write(encoder, offset) {
      const len = this.arr.length;
      encoder.writeLen(len - offset);
      for (let i = offset; i < len; i++) {
        const c2 = this.arr[i];
        encoder.writeString(c2 === void 0 ? "undefined" : JSON.stringify(c2));
      }
    }
    getRef() {
      return 2;
    }
  };
  var readContentJSON = (decoder) => {
    const len = decoder.readLen();
    const cs = [];
    for (let i = 0; i < len; i++) {
      const c2 = decoder.readString();
      if (c2 === "undefined") {
        cs.push(void 0);
      } else {
        cs.push(JSON.parse(c2));
      }
    }
    return new ContentJSON(cs);
  };
  var ContentAny = class {
    constructor(arr) {
      this.arr = arr;
    }
    getLength() {
      return this.arr.length;
    }
    getContent() {
      return this.arr;
    }
    isCountable() {
      return true;
    }
    copy() {
      return new ContentAny(this.arr);
    }
    splice(offset) {
      const right = new ContentAny(this.arr.slice(offset));
      this.arr = this.arr.slice(0, offset);
      return right;
    }
    mergeWith(right) {
      this.arr = this.arr.concat(right.arr);
      return true;
    }
    integrate(transaction, item) {
    }
    delete(transaction) {
    }
    gc(store) {
    }
    write(encoder, offset) {
      const len = this.arr.length;
      encoder.writeLen(len - offset);
      for (let i = offset; i < len; i++) {
        const c2 = this.arr[i];
        encoder.writeAny(c2);
      }
    }
    getRef() {
      return 8;
    }
  };
  var readContentAny = (decoder) => {
    const len = decoder.readLen();
    const cs = [];
    for (let i = 0; i < len; i++) {
      cs.push(decoder.readAny());
    }
    return new ContentAny(cs);
  };
  var ContentString = class {
    constructor(str) {
      this.str = str;
    }
    getLength() {
      return this.str.length;
    }
    getContent() {
      return this.str.split("");
    }
    isCountable() {
      return true;
    }
    copy() {
      return new ContentString(this.str);
    }
    splice(offset) {
      const right = new ContentString(this.str.slice(offset));
      this.str = this.str.slice(0, offset);
      const firstCharCode = this.str.charCodeAt(offset - 1);
      if (firstCharCode >= 55296 && firstCharCode <= 56319) {
        this.str = this.str.slice(0, offset - 1) + "\uFFFD";
        right.str = "\uFFFD" + right.str.slice(1);
      }
      return right;
    }
    mergeWith(right) {
      this.str += right.str;
      return true;
    }
    integrate(transaction, item) {
    }
    delete(transaction) {
    }
    gc(store) {
    }
    write(encoder, offset) {
      encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
    }
    getRef() {
      return 4;
    }
  };
  var readContentString = (decoder) => new ContentString(decoder.readString());
  var typeRefs = [
    readYArray,
    readYMap,
    readYText,
    readYXmlElement,
    readYXmlFragment,
    readYXmlHook,
    readYXmlText
  ];
  var YArrayRefID = 0;
  var YMapRefID = 1;
  var YTextRefID = 2;
  var YXmlElementRefID = 3;
  var YXmlFragmentRefID = 4;
  var YXmlHookRefID = 5;
  var YXmlTextRefID = 6;
  var ContentType = class {
    constructor(type) {
      this.type = type;
    }
    getLength() {
      return 1;
    }
    getContent() {
      return [this.type];
    }
    isCountable() {
      return true;
    }
    copy() {
      return new ContentType(this.type._copy());
    }
    splice(offset) {
      throw methodUnimplemented();
    }
    mergeWith(right) {
      return false;
    }
    integrate(transaction, item) {
      this.type._integrate(transaction.doc, item);
    }
    delete(transaction) {
      let item = this.type._start;
      while (item !== null) {
        if (!item.deleted) {
          item.delete(transaction);
        } else {
          transaction._mergeStructs.push(item);
        }
        item = item.right;
      }
      this.type._map.forEach((item2) => {
        if (!item2.deleted) {
          item2.delete(transaction);
        } else {
          transaction._mergeStructs.push(item2);
        }
      });
      transaction.changed.delete(this.type);
    }
    gc(store) {
      let item = this.type._start;
      while (item !== null) {
        item.gc(store, true);
        item = item.right;
      }
      this.type._start = null;
      this.type._map.forEach((item2) => {
        while (item2 !== null) {
          item2.gc(store, true);
          item2 = item2.left;
        }
      });
      this.type._map = /* @__PURE__ */ new Map();
    }
    write(encoder, offset) {
      this.type._write(encoder);
    }
    getRef() {
      return 7;
    }
  };
  var readContentType = (decoder) => new ContentType(typeRefs[decoder.readTypeRef()](decoder));
  var followRedone = (store, id3) => {
    let nextID2 = id3;
    let diff = 0;
    let item;
    do {
      if (diff > 0) {
        nextID2 = createID(nextID2.client, nextID2.clock + diff);
      }
      item = getItem(store, nextID2);
      diff = nextID2.clock - item.id.clock;
      nextID2 = item.redone;
    } while (nextID2 !== null && item instanceof Item);
    return {
      item,
      diff
    };
  };
  var keepItem = (item, keep) => {
    while (item !== null && item.keep !== keep) {
      item.keep = keep;
      item = item.parent._item;
    }
  };
  var splitItem = (transaction, leftItem, diff) => {
    const { client, clock: clock2 } = leftItem.id;
    const rightItem = new Item(
      createID(client, clock2 + diff),
      leftItem,
      createID(client, clock2 + diff - 1),
      leftItem.right,
      leftItem.rightOrigin,
      leftItem.parent,
      leftItem.parentSub,
      leftItem.content.splice(diff)
    );
    if (leftItem.deleted) {
      rightItem.markDeleted();
    }
    if (leftItem.keep) {
      rightItem.keep = true;
    }
    if (leftItem.redone !== null) {
      rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
    }
    leftItem.right = rightItem;
    if (rightItem.right !== null) {
      rightItem.right.left = rightItem;
    }
    transaction._mergeStructs.push(rightItem);
    if (rightItem.parentSub !== null && rightItem.right === null) {
      rightItem.parent._map.set(rightItem.parentSub, rightItem);
    }
    leftItem.length = diff;
    return rightItem;
  };
  var redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges) => {
    const doc3 = transaction.doc;
    const store = doc3.store;
    const ownClientID = doc3.clientID;
    const redone = item.redone;
    if (redone !== null) {
      return getItemCleanStart(transaction, redone);
    }
    let parentItem = item.parent._item;
    let left = null;
    let right;
    if (parentItem !== null && parentItem.deleted === true) {
      if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges) === null)) {
        return null;
      }
      while (parentItem.redone !== null) {
        parentItem = getItemCleanStart(transaction, parentItem.redone);
      }
    }
    const parentType = parentItem === null ? item.parent : parentItem.content.type;
    if (item.parentSub === null) {
      left = item.left;
      right = item;
      while (left !== null) {
        let leftTrace = left;
        while (leftTrace !== null && leftTrace.parent._item !== parentItem) {
          leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);
        }
        if (leftTrace !== null && leftTrace.parent._item === parentItem) {
          left = leftTrace;
          break;
        }
        left = left.left;
      }
      while (right !== null) {
        let rightTrace = right;
        while (rightTrace !== null && rightTrace.parent._item !== parentItem) {
          rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);
        }
        if (rightTrace !== null && rightTrace.parent._item === parentItem) {
          right = rightTrace;
          break;
        }
        right = right.right;
      }
    } else {
      right = null;
      if (item.right && !ignoreRemoteMapChanges) {
        left = item;
        while (left !== null && left.right !== null && isDeleted(itemsToDelete, left.right.id)) {
          left = left.right;
        }
        while (left !== null && left.redone !== null) {
          left = getItemCleanStart(transaction, left.redone);
        }
        if (left && left.right !== null) {
          return null;
        }
      } else {
        left = parentType._map.get(item.parentSub) || null;
      }
    }
    const nextClock = getState(store, ownClientID);
    const nextId = createID(ownClientID, nextClock);
    const redoneItem = new Item(
      nextId,
      left,
      left && left.lastId,
      right,
      right && right.id,
      parentType,
      item.parentSub,
      item.content.copy()
    );
    item.redone = nextId;
    keepItem(redoneItem, true);
    redoneItem.integrate(transaction, 0);
    return redoneItem;
  };
  var Item = class extends AbstractStruct {
    constructor(id3, left, origin, right, rightOrigin, parent, parentSub, content2) {
      super(id3, content2.getLength());
      this.origin = origin;
      this.left = left;
      this.right = right;
      this.rightOrigin = rightOrigin;
      this.parent = parent;
      this.parentSub = parentSub;
      this.redone = null;
      this.content = content2;
      this.info = this.content.isCountable() ? BIT2 : 0;
    }
    set marker(isMarked) {
      if ((this.info & BIT4) > 0 !== isMarked) {
        this.info ^= BIT4;
      }
    }
    get marker() {
      return (this.info & BIT4) > 0;
    }
    get keep() {
      return (this.info & BIT1) > 0;
    }
    set keep(doKeep) {
      if (this.keep !== doKeep) {
        this.info ^= BIT1;
      }
    }
    get countable() {
      return (this.info & BIT2) > 0;
    }
    get deleted() {
      return (this.info & BIT3) > 0;
    }
    set deleted(doDelete) {
      if (this.deleted !== doDelete) {
        this.info ^= BIT3;
      }
    }
    markDeleted() {
      this.info |= BIT3;
    }
    getMissing(transaction, store) {
      if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {
        return this.origin.client;
      }
      if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {
        return this.rightOrigin.client;
      }
      if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {
        return this.parent.client;
      }
      if (this.origin) {
        this.left = getItemCleanEnd(transaction, store, this.origin);
        this.origin = this.left.lastId;
      }
      if (this.rightOrigin) {
        this.right = getItemCleanStart(transaction, this.rightOrigin);
        this.rightOrigin = this.right.id;
      }
      if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
        this.parent = null;
      }
      if (!this.parent) {
        if (this.left && this.left.constructor === Item) {
          this.parent = this.left.parent;
          this.parentSub = this.left.parentSub;
        }
        if (this.right && this.right.constructor === Item) {
          this.parent = this.right.parent;
          this.parentSub = this.right.parentSub;
        }
      } else if (this.parent.constructor === ID) {
        const parentItem = getItem(store, this.parent);
        if (parentItem.constructor === GC) {
          this.parent = null;
        } else {
          this.parent = parentItem.content.type;
        }
      }
      return null;
    }
    integrate(transaction, offset) {
      if (offset > 0) {
        this.id.clock += offset;
        this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
        this.origin = this.left.lastId;
        this.content = this.content.splice(offset);
        this.length -= offset;
      }
      if (this.parent) {
        if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
          let left = this.left;
          let o;
          if (left !== null) {
            o = left.right;
          } else if (this.parentSub !== null) {
            o = this.parent._map.get(this.parentSub) || null;
            while (o !== null && o.left !== null) {
              o = o.left;
            }
          } else {
            o = this.parent._start;
          }
          const conflictingItems = /* @__PURE__ */ new Set();
          const itemsBeforeOrigin = /* @__PURE__ */ new Set();
          while (o !== null && o !== this.right) {
            itemsBeforeOrigin.add(o);
            conflictingItems.add(o);
            if (compareIDs(this.origin, o.origin)) {
              if (o.id.client < this.id.client) {
                left = o;
                conflictingItems.clear();
              } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {
                break;
              }
            } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {
              if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
                left = o;
                conflictingItems.clear();
              }
            } else {
              break;
            }
            o = o.right;
          }
          this.left = left;
        }
        if (this.left !== null) {
          const right = this.left.right;
          this.right = right;
          this.left.right = this;
        } else {
          let r;
          if (this.parentSub !== null) {
            r = this.parent._map.get(this.parentSub) || null;
            while (r !== null && r.left !== null) {
              r = r.left;
            }
          } else {
            r = this.parent._start;
            this.parent._start = this;
          }
          this.right = r;
        }
        if (this.right !== null) {
          this.right.left = this;
        } else if (this.parentSub !== null) {
          this.parent._map.set(this.parentSub, this);
          if (this.left !== null) {
            this.left.delete(transaction);
          }
        }
        if (this.parentSub === null && this.countable && !this.deleted) {
          this.parent._length += this.length;
        }
        addStruct(transaction.doc.store, this);
        this.content.integrate(transaction, this);
        addChangedTypeToTransaction(transaction, this.parent, this.parentSub);
        if (this.parent._item !== null && this.parent._item.deleted || this.parentSub !== null && this.right !== null) {
          this.delete(transaction);
        }
      } else {
        new GC(this.id, this.length).integrate(transaction, 0);
      }
    }
    get next() {
      let n2 = this.right;
      while (n2 !== null && n2.deleted) {
        n2 = n2.right;
      }
      return n2;
    }
    get prev() {
      let n2 = this.left;
      while (n2 !== null && n2.deleted) {
        n2 = n2.left;
      }
      return n2;
    }
    get lastId() {
      return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
    }
    mergeWith(right) {
      if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
        const searchMarker = this.parent._searchMarker;
        if (searchMarker) {
          searchMarker.forEach((marker) => {
            if (marker.p === right) {
              marker.p = this;
              if (!this.deleted && this.countable) {
                marker.index -= this.length;
              }
            }
          });
        }
        if (right.keep) {
          this.keep = true;
        }
        this.right = right.right;
        if (this.right !== null) {
          this.right.left = this;
        }
        this.length += right.length;
        return true;
      }
      return false;
    }
    delete(transaction) {
      if (!this.deleted) {
        const parent = this.parent;
        if (this.countable && this.parentSub === null) {
          parent._length -= this.length;
        }
        this.markDeleted();
        addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
        addChangedTypeToTransaction(transaction, parent, this.parentSub);
        this.content.delete(transaction);
      }
    }
    gc(store, parentGCd) {
      if (!this.deleted) {
        throw unexpectedCase();
      }
      this.content.gc(store);
      if (parentGCd) {
        replaceStruct(store, this, new GC(this.id, this.length));
      } else {
        this.content = new ContentDeleted(this.length);
      }
    }
    write(encoder, offset) {
      const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
      const rightOrigin = this.rightOrigin;
      const parentSub = this.parentSub;
      const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | (rightOrigin === null ? 0 : BIT7) | (parentSub === null ? 0 : BIT6);
      encoder.writeInfo(info);
      if (origin !== null) {
        encoder.writeLeftID(origin);
      }
      if (rightOrigin !== null) {
        encoder.writeRightID(rightOrigin);
      }
      if (origin === null && rightOrigin === null) {
        const parent = this.parent;
        if (parent._item !== void 0) {
          const parentItem = parent._item;
          if (parentItem === null) {
            const ykey = findRootTypeKey(parent);
            encoder.writeParentInfo(true);
            encoder.writeString(ykey);
          } else {
            encoder.writeParentInfo(false);
            encoder.writeLeftID(parentItem.id);
          }
        } else if (parent.constructor === String) {
          encoder.writeParentInfo(true);
          encoder.writeString(parent);
        } else if (parent.constructor === ID) {
          encoder.writeParentInfo(false);
          encoder.writeLeftID(parent);
        } else {
          unexpectedCase();
        }
        if (parentSub !== null) {
          encoder.writeString(parentSub);
        }
      }
      this.content.write(encoder, offset);
    }
  };
  var readItemContent = (decoder, info) => contentRefs[info & BITS5](decoder);
  var contentRefs = [
    () => {
      unexpectedCase();
    },
    readContentDeleted,
    readContentJSON,
    readContentBinary,
    readContentString,
    readContentEmbed,
    readContentFormat,
    readContentType,
    readContentAny,
    readContentDoc,
    () => {
      unexpectedCase();
    }
  ];
  var structSkipRefNumber = 10;
  var Skip = class extends AbstractStruct {
    get deleted() {
      return true;
    }
    delete() {
    }
    mergeWith(right) {
      if (this.constructor !== right.constructor) {
        return false;
      }
      this.length += right.length;
      return true;
    }
    integrate(transaction, offset) {
      unexpectedCase();
    }
    write(encoder, offset) {
      encoder.writeInfo(structSkipRefNumber);
      writeVarUint(encoder.restEncoder, this.length - offset);
    }
    getMissing(transaction, store) {
      return null;
    }
  };
  var glo = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
  var importIdentifier = "__ $YJS$ __";
  if (glo[importIdentifier] === true) {
    console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
  }
  glo[importIdentifier] = true;

  // node_modules/lib0/indexeddb.js
  var rtop = (request) => create4((resolve2, reject2) => {
    request.onerror = (event) => reject2(new Error(event.target.error));
    request.onblocked = () => location.reload();
    request.onsuccess = (event) => resolve2(event.target.result);
  });
  var openDB2 = (name2, initDB) => create4((resolve2, reject2) => {
    const request = indexedDB.open(name2);
    request.onupgradeneeded = (event) => initDB(event.target.result);
    request.onerror = (event) => reject2(create3(event.target.error));
    request.onblocked = () => location.reload();
    request.onsuccess = (event) => {
      const db = event.target.result;
      db.onversionchange = () => {
        db.close();
      };
      if (typeof addEventListener !== "undefined") {
        addEventListener("unload", () => db.close());
      }
      resolve2(db);
    };
  });
  var deleteDB = (name2) => rtop(indexedDB.deleteDatabase(name2));
  var createStores = (db, definitions) => definitions.forEach(
    (d) => db.createObjectStore.apply(db, d)
  );
  var transact2 = (db, stores, access = "readwrite") => {
    const transaction = db.transaction(stores, access);
    return stores.map((store) => getStore(transaction, store));
  };
  var count = (store, range) => rtop(store.count(range));
  var get3 = (store, key) => rtop(store.get(key));
  var del = (store, key) => rtop(store.delete(key));
  var put = (store, item, key) => rtop(store.put(item, key));
  var addAutoKey = (store, item) => rtop(store.add(item));
  var getAll = (store, range) => rtop(store.getAll(range));
  var queryFirst = (store, query, direction) => {
    let first = null;
    return iterateKeys(store, query, (key) => {
      first = key;
      return false;
    }, direction).then(() => first);
  };
  var getLastKey = (store, range = null) => queryFirst(store, range, "prev");
  var iterateOnRequest = (request, f) => create4((resolve2, reject2) => {
    request.onerror = reject2;
    request.onsuccess = (event) => {
      const cursor = event.target.result;
      if (cursor === null || f(cursor) === false) {
        return resolve2();
      }
      cursor.continue();
    };
  });
  var iterateKeys = (store, keyrange, f, direction = "next") => iterateOnRequest(store.openKeyCursor(keyrange, direction), (cursor) => f(cursor.key));
  var getStore = (t2, store) => t2.objectStore(store);
  var createIDBKeyRangeUpperBound = (upper, upperOpen) => IDBKeyRange.upperBound(upper, upperOpen);
  var createIDBKeyRangeLowerBound = (lower, lowerOpen) => IDBKeyRange.lowerBound(lower, lowerOpen);

  // node_modules/lib0/mutex.js
  var createMutex = () => {
    let token = true;
    return (f, g) => {
      if (token) {
        token = false;
        try {
          f();
        } finally {
          token = true;
        }
      } else if (g !== void 0) {
        g();
      }
    };
  };

  // node_modules/y-indexeddb/src/y-indexeddb.js
  var customStoreName = "custom";
  var updatesStoreName = "updates";
  var PREFERRED_TRIM_SIZE = 500;
  var fetchUpdates = (idbPersistence) => {
    const [updatesStore] = transact2(idbPersistence.db, [updatesStoreName]);
    return getAll(updatesStore, createIDBKeyRangeLowerBound(idbPersistence._dbref, false)).then(
      (updates) => transact(idbPersistence.doc, () => {
        updates.forEach((val) => applyUpdate(idbPersistence.doc, val));
      }, idbPersistence, false)
    ).then(() => getLastKey(updatesStore).then((lastKey) => {
      idbPersistence._dbref = lastKey + 1;
    })).then(() => count(updatesStore).then((cnt) => {
      idbPersistence._dbsize = cnt;
    })).then(() => updatesStore);
  };
  var storeState = (idbPersistence, forceStore = true) => fetchUpdates(idbPersistence).then((updatesStore) => {
    if (forceStore || idbPersistence._dbsize >= PREFERRED_TRIM_SIZE) {
      addAutoKey(updatesStore, encodeStateAsUpdate(idbPersistence.doc)).then(() => del(updatesStore, createIDBKeyRangeUpperBound(idbPersistence._dbref, true))).then(() => count(updatesStore).then((cnt) => {
        idbPersistence._dbsize = cnt;
      }));
    }
  });
  var IndexeddbPersistence = class extends Observable {
    constructor(name2, doc3) {
      super();
      this.doc = doc3;
      this.name = name2;
      this._mux = createMutex();
      this._dbref = 0;
      this._dbsize = 0;
      this._destroyed = false;
      this.db = null;
      this.synced = false;
      this._db = openDB2(
        name2,
        (db) => createStores(db, [
          ["updates", { autoIncrement: true }],
          ["custom"]
        ])
      );
      this.whenSynced = this._db.then((db) => {
        this.db = db;
        const currState = encodeStateAsUpdate(doc3);
        return fetchUpdates(this).then((updatesStore) => addAutoKey(updatesStore, currState)).then(() => {
          if (this._destroyed)
            return this;
          this.emit("synced", [this]);
          this.synced = true;
          return this;
        });
      });
      this._storeTimeout = 1e3;
      this._storeTimeoutId = null;
      this._storeUpdate = (update, origin) => {
        if (this.db && origin !== this) {
          const [updatesStore] = transact2(this.db, [updatesStoreName]);
          addAutoKey(updatesStore, update);
          if (++this._dbsize >= PREFERRED_TRIM_SIZE) {
            if (this._storeTimeoutId !== null) {
              clearTimeout(this._storeTimeoutId);
            }
            this._storeTimeoutId = setTimeout(() => {
              storeState(this, false);
              this._storeTimeoutId = null;
            }, this._storeTimeout);
          }
        }
      };
      doc3.on("update", this._storeUpdate);
      this.destroy = this.destroy.bind(this);
      doc3.on("destroy", this.destroy);
    }
    destroy() {
      if (this._storeTimeoutId) {
        clearTimeout(this._storeTimeoutId);
      }
      this.doc.off("update", this._storeUpdate);
      this.doc.off("destroy", this.destroy);
      this._destroyed = true;
      return this._db.then((db) => {
        db.close();
      });
    }
    clearData() {
      return this.destroy().then(() => {
        deleteDB(this.name);
      });
    }
    get(key) {
      return this._db.then((db) => {
        const [custom] = transact2(db, [customStoreName], "readonly");
        return get3(custom, key);
      });
    }
    set(key, value) {
      return this._db.then((db) => {
        const [custom] = transact2(db, [customStoreName]);
        return put(custom, value, key);
      });
    }
    del(key) {
      return this._db.then((db) => {
        const [custom] = transact2(db, [customStoreName]);
        return del(custom, key);
      });
    }
  };

  // node_modules/lib0/websocket.js
  var reconnectTimeoutBase = 1200;
  var maxReconnectTimeout = 2500;
  var messageReconnectTimeout = 3e4;
  var setupWS = (wsclient) => {
    if (wsclient.shouldConnect && wsclient.ws === null) {
      const websocket = new WebSocket(wsclient.url);
      const binaryType = wsclient.binaryType;
      let pingTimeout = null;
      if (binaryType) {
        websocket.binaryType = binaryType;
      }
      wsclient.ws = websocket;
      wsclient.connecting = true;
      wsclient.connected = false;
      websocket.onmessage = (event) => {
        wsclient.lastMessageReceived = getUnixTime();
        const data2 = event.data;
        const message = typeof data2 === "string" ? JSON.parse(data2) : data2;
        if (message && message.type === "pong") {
          clearTimeout(pingTimeout);
          pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2);
        }
        wsclient.emit("message", [message, wsclient]);
      };
      const onclose = (error) => {
        if (wsclient.ws !== null) {
          wsclient.ws = null;
          wsclient.connecting = false;
          if (wsclient.connected) {
            wsclient.connected = false;
            wsclient.emit("disconnect", [{ type: "disconnect", error }, wsclient]);
          } else {
            wsclient.unsuccessfulReconnects++;
          }
          setTimeout(setupWS, min(log10(wsclient.unsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), wsclient);
        }
        clearTimeout(pingTimeout);
      };
      const sendPing = () => {
        if (wsclient.ws === websocket) {
          wsclient.send({
            type: "ping"
          });
        }
      };
      websocket.onclose = () => onclose(null);
      websocket.onerror = (error) => onclose(error);
      websocket.onopen = () => {
        wsclient.lastMessageReceived = getUnixTime();
        wsclient.connecting = false;
        wsclient.connected = true;
        wsclient.unsuccessfulReconnects = 0;
        wsclient.emit("connect", [{ type: "connect" }, wsclient]);
        pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2);
      };
    }
  };
  var WebsocketClient = class extends Observable {
    constructor(url, { binaryType } = {}) {
      super();
      this.url = url;
      this.ws = null;
      this.binaryType = binaryType || null;
      this.connected = false;
      this.connecting = false;
      this.unsuccessfulReconnects = 0;
      this.lastMessageReceived = 0;
      this.shouldConnect = true;
      this._checkInterval = setInterval(() => {
        if (this.connected && messageReconnectTimeout < getUnixTime() - this.lastMessageReceived) {
          this.ws.close();
        }
      }, messageReconnectTimeout / 2);
      setupWS(this);
    }
    send(message) {
      if (this.ws) {
        this.ws.send(JSON.stringify(message));
      }
    }
    destroy() {
      clearInterval(this._checkInterval);
      this.disconnect();
      super.destroy();
    }
    disconnect() {
      this.shouldConnect = false;
      if (this.ws !== null) {
        this.ws.close();
      }
    }
    connect() {
      this.shouldConnect = true;
      if (!this.connected && this.ws === null) {
        setupWS(this);
      }
    }
  };

  // node_modules/lib0/broadcastchannel.js
  var channels = /* @__PURE__ */ new Map();
  var LocalStoragePolyfill = class {
    constructor(room) {
      this.room = room;
      this.onmessage = null;
      onChange((e) => e.key === room && this.onmessage !== null && this.onmessage({ data: fromBase64(e.newValue || "") }));
    }
    postMessage(buf) {
      varStorage.setItem(this.room, toBase64(createUint8ArrayFromArrayBuffer(buf)));
    }
  };
  var BC = typeof BroadcastChannel === "undefined" ? LocalStoragePolyfill : BroadcastChannel;
  var getChannel = (room) => setIfUndefined(channels, room, () => {
    const subs = /* @__PURE__ */ new Set();
    const bc = new BC(room);
    bc.onmessage = (e) => subs.forEach((sub) => sub(e.data, "broadcastchannel"));
    return {
      bc,
      subs
    };
  });
  var subscribe = (room, f) => getChannel(room).subs.add(f);
  var unsubscribe = (room, f) => getChannel(room).subs.delete(f);
  var publish = (room, data2, origin = null) => {
    const c2 = getChannel(room);
    c2.bc.postMessage(data2);
    c2.subs.forEach((sub) => sub(data2, origin));
  };

  // node_modules/y-webrtc/src/y-webrtc.js
  var import_simplepeer_min = __toESM(require_simplepeer_min(), 1);

  // node_modules/y-protocols/sync.js
  var messageYjsSyncStep1 = 0;
  var messageYjsSyncStep2 = 1;
  var messageYjsUpdate = 2;
  var writeSyncStep1 = (encoder, doc3) => {
    writeVarUint(encoder, messageYjsSyncStep1);
    const sv = encodeStateVector(doc3);
    writeVarUint8Array(encoder, sv);
  };
  var writeSyncStep2 = (encoder, doc3, encodedStateVector) => {
    writeVarUint(encoder, messageYjsSyncStep2);
    writeVarUint8Array(encoder, encodeStateAsUpdate(doc3, encodedStateVector));
  };
  var readSyncStep1 = (decoder, encoder, doc3) => writeSyncStep2(encoder, doc3, readVarUint8Array(decoder));
  var readSyncStep2 = (decoder, doc3, transactionOrigin) => {
    try {
      applyUpdate(doc3, readVarUint8Array(decoder), transactionOrigin);
    } catch (error) {
      console.error("Caught error while handling a Yjs update", error);
    }
  };
  var writeUpdate = (encoder, update) => {
    writeVarUint(encoder, messageYjsUpdate);
    writeVarUint8Array(encoder, update);
  };
  var readUpdate = readSyncStep2;
  var readSyncMessage = (decoder, encoder, doc3, transactionOrigin) => {
    const messageType = readVarUint(decoder);
    switch (messageType) {
      case messageYjsSyncStep1:
        readSyncStep1(decoder, encoder, doc3);
        break;
      case messageYjsSyncStep2:
        readSyncStep2(decoder, doc3, transactionOrigin);
        break;
      case messageYjsUpdate:
        readUpdate(decoder, doc3, transactionOrigin);
        break;
      default:
        throw new Error("Unknown message type");
    }
    return messageType;
  };

  // node_modules/y-protocols/awareness.js
  var outdatedTimeout = 3e4;
  var Awareness = class extends Observable {
    constructor(doc3) {
      super();
      this.doc = doc3;
      this.clientID = doc3.clientID;
      this.states = /* @__PURE__ */ new Map();
      this.meta = /* @__PURE__ */ new Map();
      this._checkInterval = setInterval(() => {
        const now3 = getUnixTime();
        if (this.getLocalState() !== null && outdatedTimeout / 2 <= now3 - this.meta.get(this.clientID).lastUpdated) {
          this.setLocalState(this.getLocalState());
        }
        const remove2 = [];
        this.meta.forEach((meta2, clientid) => {
          if (clientid !== this.clientID && outdatedTimeout <= now3 - meta2.lastUpdated && this.states.has(clientid)) {
            remove2.push(clientid);
          }
        });
        if (remove2.length > 0) {
          removeAwarenessStates(this, remove2, "timeout");
        }
      }, floor(outdatedTimeout / 10));
      doc3.on("destroy", () => {
        this.destroy();
      });
      this.setLocalState({});
    }
    destroy() {
      this.emit("destroy", [this]);
      this.setLocalState(null);
      super.destroy();
      clearInterval(this._checkInterval);
    }
    getLocalState() {
      return this.states.get(this.clientID) || null;
    }
    setLocalState(state) {
      const clientID = this.clientID;
      const currLocalMeta = this.meta.get(clientID);
      const clock2 = currLocalMeta === void 0 ? 0 : currLocalMeta.clock + 1;
      const prevState = this.states.get(clientID);
      if (state === null) {
        this.states.delete(clientID);
      } else {
        this.states.set(clientID, state);
      }
      this.meta.set(clientID, {
        clock: clock2,
        lastUpdated: getUnixTime()
      });
      const added = [];
      const updated = [];
      const filteredUpdated = [];
      const removed = [];
      if (state === null) {
        removed.push(clientID);
      } else if (prevState == null) {
        if (state != null) {
          added.push(clientID);
        }
      } else {
        updated.push(clientID);
        if (!equalityDeep(prevState, state)) {
          filteredUpdated.push(clientID);
        }
      }
      if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
        this.emit("change", [{ added, updated: filteredUpdated, removed }, "local"]);
      }
      this.emit("update", [{ added, updated, removed }, "local"]);
    }
    setLocalStateField(field, value) {
      const state = this.getLocalState();
      if (state !== null) {
        this.setLocalState({
          ...state,
          [field]: value
        });
      }
    }
    getStates() {
      return this.states;
    }
  };
  var removeAwarenessStates = (awareness, clients, origin) => {
    const removed = [];
    for (let i = 0; i < clients.length; i++) {
      const clientID = clients[i];
      if (awareness.states.has(clientID)) {
        awareness.states.delete(clientID);
        if (clientID === awareness.clientID) {
          const curMeta = awareness.meta.get(clientID);
          awareness.meta.set(clientID, {
            clock: curMeta.clock + 1,
            lastUpdated: getUnixTime()
          });
        }
        removed.push(clientID);
      }
    }
    if (removed.length > 0) {
      awareness.emit("change", [{ added: [], updated: [], removed }, origin]);
      awareness.emit("update", [{ added: [], updated: [], removed }, origin]);
    }
  };
  var encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {
    const len = clients.length;
    const encoder = createEncoder();
    writeVarUint(encoder, len);
    for (let i = 0; i < len; i++) {
      const clientID = clients[i];
      const state = states.get(clientID) || null;
      const clock2 = awareness.meta.get(clientID).clock;
      writeVarUint(encoder, clientID);
      writeVarUint(encoder, clock2);
      writeVarString(encoder, JSON.stringify(state));
    }
    return toUint8Array(encoder);
  };
  var applyAwarenessUpdate = (awareness, update, origin) => {
    const decoder = createDecoder(update);
    const timestamp = getUnixTime();
    const added = [];
    const updated = [];
    const filteredUpdated = [];
    const removed = [];
    const len = readVarUint(decoder);
    for (let i = 0; i < len; i++) {
      const clientID = readVarUint(decoder);
      let clock2 = readVarUint(decoder);
      const state = JSON.parse(readVarString(decoder));
      const clientMeta = awareness.meta.get(clientID);
      const prevState = awareness.states.get(clientID);
      const currClock = clientMeta === void 0 ? 0 : clientMeta.clock;
      if (currClock < clock2 || currClock === clock2 && state === null && awareness.states.has(clientID)) {
        if (state === null) {
          if (clientID === awareness.clientID && awareness.getLocalState() != null) {
            clock2++;
          } else {
            awareness.states.delete(clientID);
          }
        } else {
          awareness.states.set(clientID, state);
        }
        awareness.meta.set(clientID, {
          clock: clock2,
          lastUpdated: timestamp
        });
        if (clientMeta === void 0 && state !== null) {
          added.push(clientID);
        } else if (clientMeta !== void 0 && state === null) {
          removed.push(clientID);
        } else if (state !== null) {
          if (!equalityDeep(state, prevState)) {
            filteredUpdated.push(clientID);
          }
          updated.push(clientID);
        }
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      awareness.emit("change", [{
        added,
        updated: filteredUpdated,
        removed
      }, origin]);
    }
    if (added.length > 0 || updated.length > 0 || removed.length > 0) {
      awareness.emit("update", [{
        added,
        updated,
        removed
      }, origin]);
    }
  };

  // node_modules/y-webrtc/src/crypto.js
  var deriveKey = (secret, roomName) => {
    const secretBuffer = encodeUtf8(secret).buffer;
    const salt = encodeUtf8(roomName).buffer;
    return crypto.subtle.importKey(
      "raw",
      secretBuffer,
      "PBKDF2",
      false,
      ["deriveKey"]
    ).then(
      (keyMaterial) => crypto.subtle.deriveKey(
        {
          name: "PBKDF2",
          salt,
          iterations: 1e5,
          hash: "SHA-256"
        },
        keyMaterial,
        {
          name: "AES-GCM",
          length: 256
        },
        true,
        ["encrypt", "decrypt"]
      )
    );
  };
  var encrypt = (data2, key) => {
    if (!key) {
      return resolve(data2);
    }
    const iv = crypto.getRandomValues(new Uint8Array(12));
    return crypto.subtle.encrypt(
      {
        name: "AES-GCM",
        iv
      },
      key,
      data2
    ).then((cipher) => {
      const encryptedDataEncoder = createEncoder();
      writeVarString(encryptedDataEncoder, "AES-GCM");
      writeVarUint8Array(encryptedDataEncoder, iv);
      writeVarUint8Array(encryptedDataEncoder, new Uint8Array(cipher));
      return toUint8Array(encryptedDataEncoder);
    });
  };
  var encryptJson = (data2, key) => {
    const dataEncoder = createEncoder();
    writeAny(dataEncoder, data2);
    return encrypt(toUint8Array(dataEncoder), key);
  };
  var decrypt = (data2, key) => {
    if (!key) {
      return resolve(data2);
    }
    const dataDecoder = createDecoder(data2);
    const algorithm = readVarString(dataDecoder);
    if (algorithm !== "AES-GCM") {
      reject(create3("Unknown encryption algorithm"));
    }
    const iv = readVarUint8Array(dataDecoder);
    const cipher = readVarUint8Array(dataDecoder);
    return crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv
      },
      key,
      cipher
    ).then((data3) => new Uint8Array(data3));
  };
  var decryptJson = (data2, key) => decrypt(data2, key).then(
    (decryptedValue) => readAny(createDecoder(new Uint8Array(decryptedValue)))
  );

  // node_modules/y-webrtc/src/y-webrtc.js
  var log = createModuleLogger("y-webrtc");
  var messageSync = 0;
  var messageQueryAwareness = 3;
  var messageAwareness = 1;
  var messageBcPeerId = 4;
  var signalingConns = /* @__PURE__ */ new Map();
  var rooms = /* @__PURE__ */ new Map();
  var checkIsSynced = (room) => {
    let synced = true;
    room.webrtcConns.forEach((peer) => {
      if (!peer.synced) {
        synced = false;
      }
    });
    if (!synced && room.synced || synced && !room.synced) {
      room.synced = synced;
      room.provider.emit("synced", [{ synced }]);
      log("synced ", BOLD, room.name, UNBOLD, " with all peers");
    }
  };
  var readMessage = (room, buf, syncedCallback) => {
    const decoder = createDecoder(buf);
    const encoder = createEncoder();
    const messageType = readVarUint(decoder);
    if (room === void 0) {
      return null;
    }
    const awareness = room.awareness;
    const doc3 = room.doc;
    let sendReply = false;
    switch (messageType) {
      case messageSync: {
        writeVarUint(encoder, messageSync);
        const syncMessageType = readSyncMessage(decoder, encoder, doc3, room);
        if (syncMessageType === messageYjsSyncStep2 && !room.synced) {
          syncedCallback();
        }
        if (syncMessageType === messageYjsSyncStep1) {
          sendReply = true;
        }
        break;
      }
      case messageQueryAwareness:
        writeVarUint(encoder, messageAwareness);
        writeVarUint8Array(encoder, encodeAwarenessUpdate(awareness, Array.from(awareness.getStates().keys())));
        sendReply = true;
        break;
      case messageAwareness:
        applyAwarenessUpdate(awareness, readVarUint8Array(decoder), room);
        break;
      case messageBcPeerId: {
        const add3 = readUint8(decoder) === 1;
        const peerName = readVarString(decoder);
        if (peerName !== room.peerId && (room.bcConns.has(peerName) && !add3 || !room.bcConns.has(peerName) && add3)) {
          const removed = [];
          const added = [];
          if (add3) {
            room.bcConns.add(peerName);
            added.push(peerName);
          } else {
            room.bcConns.delete(peerName);
            removed.push(peerName);
          }
          room.provider.emit("peers", [{
            added,
            removed,
            webrtcPeers: Array.from(room.webrtcConns.keys()),
            bcPeers: Array.from(room.bcConns)
          }]);
          broadcastBcPeerId(room);
        }
        break;
      }
      default:
        console.error("Unable to compute message");
        return encoder;
    }
    if (!sendReply) {
      return null;
    }
    return encoder;
  };
  var readPeerMessage = (peerConn, buf) => {
    const room = peerConn.room;
    log("received message from ", BOLD, peerConn.remotePeerId, GREY, " (", room.name, ")", UNBOLD, UNCOLOR);
    return readMessage(room, buf, () => {
      peerConn.synced = true;
      log("synced ", BOLD, room.name, UNBOLD, " with ", BOLD, peerConn.remotePeerId);
      checkIsSynced(room);
    });
  };
  var sendWebrtcConn = (webrtcConn, encoder) => {
    log("send message to ", BOLD, webrtcConn.remotePeerId, UNBOLD, GREY, " (", webrtcConn.room.name, ")", UNCOLOR);
    try {
      webrtcConn.peer.send(toUint8Array(encoder));
    } catch (e) {
    }
  };
  var broadcastWebrtcConn = (room, m2) => {
    log("broadcast message in ", BOLD, room.name, UNBOLD);
    room.webrtcConns.forEach((conn) => {
      try {
        conn.peer.send(m2);
      } catch (e) {
      }
    });
  };
  var WebrtcConn = class {
    constructor(signalingConn, initiator, remotePeerId, room) {
      log("establishing connection to ", BOLD, remotePeerId);
      this.room = room;
      this.remotePeerId = remotePeerId;
      this.closed = false;
      this.connected = false;
      this.synced = false;
      this.peer = new import_simplepeer_min.default({ initiator, ...room.provider.peerOpts });
      this.peer.on("signal", (signal) => {
        publishSignalingMessage(signalingConn, room, { to: remotePeerId, from: room.peerId, type: "signal", signal });
      });
      this.peer.on("connect", () => {
        log("connected to ", BOLD, remotePeerId);
        this.connected = true;
        const provider = room.provider;
        const doc3 = provider.doc;
        const awareness = room.awareness;
        const encoder = createEncoder();
        writeVarUint(encoder, messageSync);
        writeSyncStep1(encoder, doc3);
        sendWebrtcConn(this, encoder);
        const awarenessStates = awareness.getStates();
        if (awarenessStates.size > 0) {
          const encoder2 = createEncoder();
          writeVarUint(encoder2, messageAwareness);
          writeVarUint8Array(encoder2, encodeAwarenessUpdate(awareness, Array.from(awarenessStates.keys())));
          sendWebrtcConn(this, encoder2);
        }
      });
      this.peer.on("close", () => {
        this.connected = false;
        this.closed = true;
        if (room.webrtcConns.has(this.remotePeerId)) {
          room.webrtcConns.delete(this.remotePeerId);
          room.provider.emit("peers", [{
            removed: [this.remotePeerId],
            added: [],
            webrtcPeers: Array.from(room.webrtcConns.keys()),
            bcPeers: Array.from(room.bcConns)
          }]);
        }
        checkIsSynced(room);
        this.peer.destroy();
        log("closed connection to ", BOLD, remotePeerId);
        announceSignalingInfo(room);
      });
      this.peer.on("error", (err) => {
        log("Error in connection to ", BOLD, remotePeerId, ": ", err);
        announceSignalingInfo(room);
      });
      this.peer.on("data", (data2) => {
        const answer = readPeerMessage(this, data2);
        if (answer !== null) {
          sendWebrtcConn(this, answer);
        }
      });
    }
    destroy() {
      this.peer.destroy();
    }
  };
  var broadcastBcMessage = (room, m2) => encrypt(m2, room.key).then(
    (data2) => room.mux(
      () => publish(room.name, data2)
    )
  );
  var broadcastRoomMessage = (room, m2) => {
    if (room.bcconnected) {
      broadcastBcMessage(room, m2);
    }
    broadcastWebrtcConn(room, m2);
  };
  var announceSignalingInfo = (room) => {
    signalingConns.forEach((conn) => {
      if (conn.connected) {
        conn.send({ type: "subscribe", topics: [room.name] });
        if (room.webrtcConns.size < room.provider.maxConns) {
          publishSignalingMessage(conn, room, { type: "announce", from: room.peerId });
        }
      }
    });
  };
  var broadcastBcPeerId = (room) => {
    if (room.provider.filterBcConns) {
      const encoderPeerIdBc = createEncoder();
      writeVarUint(encoderPeerIdBc, messageBcPeerId);
      writeUint8(encoderPeerIdBc, 1);
      writeVarString(encoderPeerIdBc, room.peerId);
      broadcastBcMessage(room, toUint8Array(encoderPeerIdBc));
    }
  };
  var Room = class {
    constructor(doc3, provider, name2, key) {
      this.peerId = uuidv4();
      this.doc = doc3;
      this.awareness = provider.awareness;
      this.provider = provider;
      this.synced = false;
      this.name = name2;
      this.key = key;
      this.webrtcConns = /* @__PURE__ */ new Map();
      this.bcConns = /* @__PURE__ */ new Set();
      this.mux = createMutex();
      this.bcconnected = false;
      this._bcSubscriber = (data2) => decrypt(new Uint8Array(data2), key).then(
        (m2) => this.mux(() => {
          const reply = readMessage(this, m2, () => {
          });
          if (reply) {
            broadcastBcMessage(this, toUint8Array(reply));
          }
        })
      );
      this._docUpdateHandler = (update, origin) => {
        const encoder = createEncoder();
        writeVarUint(encoder, messageSync);
        writeUpdate(encoder, update);
        broadcastRoomMessage(this, toUint8Array(encoder));
      };
      this._awarenessUpdateHandler = ({ added, updated, removed }, origin) => {
        const changedClients = added.concat(updated).concat(removed);
        const encoderAwareness = createEncoder();
        writeVarUint(encoderAwareness, messageAwareness);
        writeVarUint8Array(encoderAwareness, encodeAwarenessUpdate(this.awareness, changedClients));
        broadcastRoomMessage(this, toUint8Array(encoderAwareness));
      };
      this._beforeUnloadHandler = () => {
        removeAwarenessStates(this.awareness, [doc3.clientID], "window unload");
        rooms.forEach((room) => {
          room.disconnect();
        });
      };
      if (typeof window !== "undefined") {
        window.addEventListener("beforeunload", this._beforeUnloadHandler);
      } else if (typeof process !== "undefined") {
        process.on("exit", this._beforeUnloadHandler);
      }
    }
    connect() {
      this.doc.on("update", this._docUpdateHandler);
      this.awareness.on("update", this._awarenessUpdateHandler);
      announceSignalingInfo(this);
      const roomName = this.name;
      subscribe(roomName, this._bcSubscriber);
      this.bcconnected = true;
      broadcastBcPeerId(this);
      const encoderSync = createEncoder();
      writeVarUint(encoderSync, messageSync);
      writeSyncStep1(encoderSync, this.doc);
      broadcastBcMessage(this, toUint8Array(encoderSync));
      const encoderState = createEncoder();
      writeVarUint(encoderState, messageSync);
      writeSyncStep2(encoderState, this.doc);
      broadcastBcMessage(this, toUint8Array(encoderState));
      const encoderAwarenessQuery = createEncoder();
      writeVarUint(encoderAwarenessQuery, messageQueryAwareness);
      broadcastBcMessage(this, toUint8Array(encoderAwarenessQuery));
      const encoderAwarenessState = createEncoder();
      writeVarUint(encoderAwarenessState, messageAwareness);
      writeVarUint8Array(encoderAwarenessState, encodeAwarenessUpdate(this.awareness, [this.doc.clientID]));
      broadcastBcMessage(this, toUint8Array(encoderAwarenessState));
    }
    disconnect() {
      signalingConns.forEach((conn) => {
        if (conn.connected) {
          conn.send({ type: "unsubscribe", topics: [this.name] });
        }
      });
      removeAwarenessStates(this.awareness, [this.doc.clientID], "disconnect");
      const encoderPeerIdBc = createEncoder();
      writeVarUint(encoderPeerIdBc, messageBcPeerId);
      writeUint8(encoderPeerIdBc, 0);
      writeVarString(encoderPeerIdBc, this.peerId);
      broadcastBcMessage(this, toUint8Array(encoderPeerIdBc));
      unsubscribe(this.name, this._bcSubscriber);
      this.bcconnected = false;
      this.doc.off("update", this._docUpdateHandler);
      this.awareness.off("update", this._awarenessUpdateHandler);
      this.webrtcConns.forEach((conn) => conn.destroy());
    }
    destroy() {
      this.disconnect();
      if (typeof window !== "undefined") {
        window.removeEventListener("beforeunload", this._beforeUnloadHandler);
      } else if (typeof process !== "undefined") {
        process.off("exit", this._beforeUnloadHandler);
      }
    }
  };
  var openRoom = (doc3, provider, name2, key) => {
    if (rooms.has(name2)) {
      throw create3(`A Yjs Doc connected to room "${name2}" already exists!`);
    }
    const room = new Room(doc3, provider, name2, key);
    rooms.set(name2, room);
    return room;
  };
  var publishSignalingMessage = (conn, room, data2) => {
    if (room.key) {
      encryptJson(data2, room.key).then((data3) => {
        conn.send({ type: "publish", topic: room.name, data: toBase64(data3) });
      });
    } else {
      conn.send({ type: "publish", topic: room.name, data: data2 });
    }
  };
  var SignalingConn = class extends WebsocketClient {
    constructor(url) {
      super(url);
      this.providers = /* @__PURE__ */ new Set();
      this.on("connect", () => {
        log(`connected (${url})`);
        const topics = Array.from(rooms.keys());
        this.send({ type: "subscribe", topics });
        rooms.forEach(
          (room) => publishSignalingMessage(this, room, { type: "announce", from: room.peerId })
        );
      });
      this.on("message", (m2) => {
        switch (m2.type) {
          case "publish": {
            const roomName = m2.topic;
            const room = rooms.get(roomName);
            if (room == null || typeof roomName !== "string") {
              return;
            }
            const execMessage = (data2) => {
              const webrtcConns = room.webrtcConns;
              const peerId = room.peerId;
              if (data2 == null || data2.from === peerId || data2.to !== void 0 && data2.to !== peerId || room.bcConns.has(data2.from)) {
                return;
              }
              const emitPeerChange = webrtcConns.has(data2.from) ? () => {
              } : () => room.provider.emit("peers", [{
                removed: [],
                added: [data2.from],
                webrtcPeers: Array.from(room.webrtcConns.keys()),
                bcPeers: Array.from(room.bcConns)
              }]);
              switch (data2.type) {
                case "announce":
                  if (webrtcConns.size < room.provider.maxConns) {
                    setIfUndefined(webrtcConns, data2.from, () => new WebrtcConn(this, true, data2.from, room));
                    emitPeerChange();
                  }
                  break;
                case "signal":
                  if (data2.to === peerId) {
                    setIfUndefined(webrtcConns, data2.from, () => new WebrtcConn(this, false, data2.from, room)).peer.signal(data2.signal);
                    emitPeerChange();
                  }
                  break;
              }
            };
            if (room.key) {
              if (typeof m2.data === "string") {
                decryptJson(fromBase64(m2.data), room.key).then(execMessage);
              }
            } else {
              execMessage(m2.data);
            }
          }
        }
      });
      this.on("disconnect", () => log(`disconnect (${url})`));
    }
  };
  var WebrtcProvider = class extends Observable {
    constructor(roomName, doc3, {
      signaling = ["wss://signaling.yjs.dev", "wss://y-webrtc-signaling-eu.herokuapp.com", "wss://y-webrtc-signaling-us.herokuapp.com"],
      password = null,
      awareness = new Awareness(doc3),
      maxConns = 20 + floor(rand() * 15),
      filterBcConns = true,
      peerOpts = {}
    } = {}) {
      super();
      this.roomName = roomName;
      this.doc = doc3;
      this.filterBcConns = filterBcConns;
      this.awareness = awareness;
      this.shouldConnect = false;
      this.signalingUrls = signaling;
      this.signalingConns = [];
      this.maxConns = maxConns;
      this.peerOpts = peerOpts;
      this.key = password ? deriveKey(password, roomName) : resolve(null);
      this.room = null;
      this.key.then((key) => {
        this.room = openRoom(doc3, this, roomName, key);
        if (this.shouldConnect) {
          this.room.connect();
        } else {
          this.room.disconnect();
        }
      });
      this.connect();
      this.destroy = this.destroy.bind(this);
      doc3.on("destroy", this.destroy);
    }
    get connected() {
      return this.room !== null && this.shouldConnect;
    }
    connect() {
      this.shouldConnect = true;
      this.signalingUrls.forEach((url) => {
        const signalingConn = setIfUndefined(signalingConns, url, () => new SignalingConn(url));
        this.signalingConns.push(signalingConn);
        signalingConn.providers.add(this);
      });
      if (this.room) {
        this.room.connect();
      }
    }
    disconnect() {
      this.shouldConnect = false;
      this.signalingConns.forEach((conn) => {
        conn.providers.delete(this);
        if (conn.providers.size === 0) {
          conn.destroy();
          signalingConns.delete(conn.url);
        }
      });
      if (this.room) {
        this.room.disconnect();
      }
    }
    destroy() {
      this.doc.off("destroy", this.destroy);
      this.key.then(() => {
        this.room.destroy();
        rooms.delete(this.roomName);
      });
      super.destroy();
    }
  };

  // node_modules/uuid/dist/esm-browser/rng.js
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }

  // node_modules/uuid/dist/esm-browser/stringify.js
  var byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  }

  // node_modules/uuid/dist/esm-browser/native.js
  var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  var native_default = {
    randomUUID
  };

  // node_modules/uuid/dist/esm-browser/v4.js
  function v4(options, buf, offset) {
    if (native_default.randomUUID && !buf && !options) {
      return native_default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return unsafeStringify(rnds);
  }
  var v4_default = v4;

  // node_modules/@automerge/automerge/dist/mjs/uuid.js
  function defaultFactory() {
    return v4_default().replace(/-/g, "");
  }
  var factory = defaultFactory;
  var uuid = () => {
    return factory();
  };
  uuid.setFactory = (newFactory) => {
    factory = newFactory;
  };
  uuid.reset = () => {
    factory = defaultFactory;
  };

  // node_modules/@automerge/automerge/dist/mjs/constants.js
  var STATE = Symbol.for("_am_meta");
  var TRACE = Symbol.for("_am_trace");
  var OBJECT_ID = Symbol.for("_am_objectId");
  var IS_PROXY = Symbol.for("_am_isProxy");
  var UINT = Symbol.for("_am_uint");
  var INT = Symbol.for("_am_int");
  var F64 = Symbol.for("_am_f64");
  var COUNTER = Symbol.for("_am_counter");
  var TEXT = Symbol.for("_am_text");

  // node_modules/@automerge/automerge/dist/mjs/text.js
  var Text2 = class {
    constructor(text3) {
      if (typeof text3 === "string") {
        this.elems = [...text3];
      } else if (Array.isArray(text3)) {
        this.elems = text3;
      } else if (text3 === void 0) {
        this.elems = [];
      } else {
        throw new TypeError(`Unsupported initial value for Text: ${text3}`);
      }
      Reflect.defineProperty(this, TEXT, { value: true });
    }
    get length() {
      return this.elems.length;
    }
    get(index2) {
      return this.elems[index2];
    }
    [Symbol.iterator]() {
      const elems = this.elems;
      let index2 = -1;
      return {
        next() {
          index2 += 1;
          if (index2 < elems.length) {
            return { done: false, value: elems[index2] };
          } else {
            return { done: true };
          }
        }
      };
    }
    toString() {
      if (!this.str) {
        this.str = "";
        for (const elem of this.elems) {
          if (typeof elem === "string")
            this.str += elem;
          else
            this.str += "\uFFFC";
        }
      }
      return this.str;
    }
    toSpans() {
      if (!this.spans) {
        this.spans = [];
        let chars = "";
        for (const elem of this.elems) {
          if (typeof elem === "string") {
            chars += elem;
          } else {
            if (chars.length > 0) {
              this.spans.push(chars);
              chars = "";
            }
            this.spans.push(elem);
          }
        }
        if (chars.length > 0) {
          this.spans.push(chars);
        }
      }
      return this.spans;
    }
    toJSON() {
      return this.toString();
    }
    set(index2, value) {
      if (this[STATE]) {
        throw new RangeError("object cannot be modified outside of a change block");
      }
      this.elems[index2] = value;
    }
    insertAt(index2, ...values2) {
      if (this[STATE]) {
        throw new RangeError("object cannot be modified outside of a change block");
      }
      this.elems.splice(index2, 0, ...values2);
    }
    deleteAt(index2, numDelete = 1) {
      if (this[STATE]) {
        throw new RangeError("object cannot be modified outside of a change block");
      }
      this.elems.splice(index2, numDelete);
    }
    map(callback) {
      this.elems.map(callback);
    }
    lastIndexOf(searchElement, fromIndex) {
      this.elems.lastIndexOf(searchElement, fromIndex);
    }
    concat(other) {
      return new Text2(this.elems.concat(other.elems));
    }
    every(test) {
      return this.elems.every(test);
    }
    filter(test) {
      return new Text2(this.elems.filter(test));
    }
    find(test) {
      return this.elems.find(test);
    }
    findIndex(test) {
      return this.elems.findIndex(test);
    }
    forEach(f) {
      this.elems.forEach(f);
    }
    includes(elem) {
      return this.elems.includes(elem);
    }
    indexOf(elem) {
      return this.elems.indexOf(elem);
    }
    join(sep) {
      return this.elems.join(sep);
    }
    reduce(f) {
      this.elems.reduce(f);
    }
    reduceRight(f) {
      this.elems.reduceRight(f);
    }
    slice(start, end) {
      new Text2(this.elems.slice(start, end));
    }
    some(test) {
      return this.elems.some(test);
    }
    toLocaleString() {
      this.toString();
    }
  };

  // node_modules/@automerge/automerge/dist/mjs/counter.js
  var Counter = class {
    constructor(value) {
      this.value = value || 0;
      Reflect.defineProperty(this, COUNTER, { value: true });
    }
    valueOf() {
      return this.value;
    }
    toString() {
      return this.valueOf().toString();
    }
    toJSON() {
      return this.value;
    }
  };
  var WriteableCounter = class extends Counter {
    constructor(value, context, path, objectId, key) {
      super(value);
      this.context = context;
      this.path = path;
      this.objectId = objectId;
      this.key = key;
    }
    increment(delta) {
      delta = typeof delta === "number" ? delta : 1;
      this.context.increment(this.objectId, this.key, delta);
      this.value += delta;
      return this.value;
    }
    decrement(delta) {
      return this.increment(typeof delta === "number" ? -delta : -1);
    }
  };
  function getWriteableCounter(value, context, path, objectId, key) {
    return new WriteableCounter(value, context, path, objectId, key);
  }

  // node_modules/@automerge/automerge/dist/mjs/raw_string.js
  var RawString = class {
    constructor(val) {
      this.val = val;
    }
  };

  // node_modules/@automerge/automerge/dist/mjs/proxies.js
  function parseListIndex(key) {
    if (typeof key === "string" && /^[0-9]+$/.test(key))
      key = parseInt(key, 10);
    if (typeof key !== "number") {
      return key;
    }
    if (key < 0 || isNaN(key) || key === Infinity || key === -Infinity) {
      throw new RangeError("A list index must be positive, but you passed " + key);
    }
    return key;
  }
  function valueAt(target, prop) {
    const { context, objectId, path, readonly, heads, textV2 } = target;
    const value = context.getWithType(objectId, prop, heads);
    if (value === null) {
      return;
    }
    const datatype = value[0];
    const val = value[1];
    switch (datatype) {
      case void 0:
        return;
      case "map":
        return mapProxy(context, val, textV2, [...path, prop], readonly, heads);
      case "list":
        return listProxy(context, val, textV2, [...path, prop], readonly, heads);
      case "text":
        if (textV2) {
          return context.text(val, heads);
        } else {
          return textProxy(context, val, [...path, prop], readonly, heads);
        }
      case "str":
        return val;
      case "uint":
        return val;
      case "int":
        return val;
      case "f64":
        return val;
      case "boolean":
        return val;
      case "null":
        return null;
      case "bytes":
        return val;
      case "timestamp":
        return val;
      case "counter": {
        if (readonly) {
          return new Counter(val);
        } else {
          const counter = getWriteableCounter(val, context, path, objectId, prop);
          return counter;
        }
      }
      default:
        throw RangeError(`datatype ${datatype} unimplemented`);
    }
  }
  function import_value(value, textV2) {
    switch (typeof value) {
      case "object":
        if (value == null) {
          return [null, "null"];
        } else if (value[UINT]) {
          return [value.value, "uint"];
        } else if (value[INT]) {
          return [value.value, "int"];
        } else if (value[F64]) {
          return [value.value, "f64"];
        } else if (value[COUNTER]) {
          return [value.value, "counter"];
        } else if (value instanceof Date) {
          return [value.getTime(), "timestamp"];
        } else if (value instanceof RawString) {
          return [value.val, "str"];
        } else if (value instanceof Text2) {
          return [value, "text"];
        } else if (value instanceof Uint8Array) {
          return [value, "bytes"];
        } else if (value instanceof Array) {
          return [value, "list"];
        } else if (Object.getPrototypeOf(value) === Object.getPrototypeOf({})) {
          return [value, "map"];
        } else if (value[OBJECT_ID]) {
          throw new RangeError("Cannot create a reference to an existing document object");
        } else {
          throw new RangeError(`Cannot assign unknown object: ${value}`);
        }
      case "boolean":
        return [value, "boolean"];
      case "number":
        if (Number.isInteger(value)) {
          return [value, "int"];
        } else {
          return [value, "f64"];
        }
      case "string":
        if (textV2) {
          return [value, "text"];
        } else {
          return [value, "str"];
        }
      default:
        throw new RangeError(`Unsupported type of value: ${typeof value}`);
    }
  }
  var MapHandler = {
    get(target, key) {
      const { context, objectId, cache: cache2 } = target;
      if (key === Symbol.toStringTag) {
        return target[Symbol.toStringTag];
      }
      if (key === OBJECT_ID)
        return objectId;
      if (key === IS_PROXY)
        return true;
      if (key === TRACE)
        return target.trace;
      if (key === STATE)
        return { handle: context };
      if (!cache2[key]) {
        cache2[key] = valueAt(target, key);
      }
      return cache2[key];
    },
    set(target, key, val) {
      const { context, objectId, path, readonly, frozen, textV2 } = target;
      target.cache = {};
      if (val && val[OBJECT_ID]) {
        throw new RangeError("Cannot create a reference to an existing document object");
      }
      if (key === TRACE) {
        target.trace = val;
        return true;
      }
      const [value, datatype] = import_value(val, textV2);
      if (frozen) {
        throw new RangeError("Attempting to use an outdated Automerge document");
      }
      if (readonly) {
        throw new RangeError(`Object property "${key}" cannot be modified`);
      }
      switch (datatype) {
        case "list": {
          const list = context.putObject(objectId, key, []);
          const proxyList = listProxy(context, list, textV2, [...path, key], readonly);
          for (let i = 0; i < value.length; i++) {
            proxyList[i] = value[i];
          }
          break;
        }
        case "text": {
          if (textV2) {
            assertString(value);
            context.putObject(objectId, key, value);
          } else {
            assertText(value);
            const text3 = context.putObject(objectId, key, "");
            const proxyText = textProxy(context, text3, [...path, key], readonly);
            for (let i = 0; i < value.length; i++) {
              proxyText[i] = value.get(i);
            }
          }
          break;
        }
        case "map": {
          const map3 = context.putObject(objectId, key, {});
          const proxyMap = mapProxy(context, map3, textV2, [...path, key], readonly);
          for (const key2 in value) {
            proxyMap[key2] = value[key2];
          }
          break;
        }
        default:
          context.put(objectId, key, value, datatype);
      }
      return true;
    },
    deleteProperty(target, key) {
      const { context, objectId, readonly } = target;
      target.cache = {};
      if (readonly) {
        throw new RangeError(`Object property "${key}" cannot be modified`);
      }
      context.delete(objectId, key);
      return true;
    },
    has(target, key) {
      const value = this.get(target, key);
      return value !== void 0;
    },
    getOwnPropertyDescriptor(target, key) {
      const value = this.get(target, key);
      if (typeof value !== "undefined") {
        return {
          configurable: true,
          enumerable: true,
          value
        };
      }
    },
    ownKeys(target) {
      const { context, objectId, heads } = target;
      const keys3 = context.keys(objectId, heads);
      return [...new Set(keys3)];
    }
  };
  var ListHandler = {
    get(target, index2) {
      const { context, objectId, heads } = target;
      index2 = parseListIndex(index2);
      if (index2 === Symbol.hasInstance) {
        return (instance) => {
          return Array.isArray(instance);
        };
      }
      if (index2 === Symbol.toStringTag) {
        return target[Symbol.toStringTag];
      }
      if (index2 === OBJECT_ID)
        return objectId;
      if (index2 === IS_PROXY)
        return true;
      if (index2 === TRACE)
        return target.trace;
      if (index2 === STATE)
        return { handle: context };
      if (index2 === "length")
        return context.length(objectId, heads);
      if (typeof index2 === "number") {
        return valueAt(target, index2);
      } else {
        return listMethods(target)[index2];
      }
    },
    set(target, index2, val) {
      const { context, objectId, path, readonly, frozen, textV2 } = target;
      index2 = parseListIndex(index2);
      if (val && val[OBJECT_ID]) {
        throw new RangeError("Cannot create a reference to an existing document object");
      }
      if (index2 === TRACE) {
        target.trace = val;
        return true;
      }
      if (typeof index2 == "string") {
        throw new RangeError("list index must be a number");
      }
      const [value, datatype] = import_value(val, textV2);
      if (frozen) {
        throw new RangeError("Attempting to use an outdated Automerge document");
      }
      if (readonly) {
        throw new RangeError(`Object property "${index2}" cannot be modified`);
      }
      switch (datatype) {
        case "list": {
          let list;
          if (index2 >= context.length(objectId)) {
            list = context.insertObject(objectId, index2, []);
          } else {
            list = context.putObject(objectId, index2, []);
          }
          const proxyList = listProxy(context, list, textV2, [...path, index2], readonly);
          proxyList.splice(0, 0, ...value);
          break;
        }
        case "text": {
          if (textV2) {
            assertString(value);
            if (index2 >= context.length(objectId)) {
              context.insertObject(objectId, index2, value);
            } else {
              context.putObject(objectId, index2, value);
            }
          } else {
            let text3;
            assertText(value);
            if (index2 >= context.length(objectId)) {
              text3 = context.insertObject(objectId, index2, "");
            } else {
              text3 = context.putObject(objectId, index2, "");
            }
            const proxyText = textProxy(context, text3, [...path, index2], readonly);
            proxyText.splice(0, 0, ...value);
          }
          break;
        }
        case "map": {
          let map3;
          if (index2 >= context.length(objectId)) {
            map3 = context.insertObject(objectId, index2, {});
          } else {
            map3 = context.putObject(objectId, index2, {});
          }
          const proxyMap = mapProxy(context, map3, textV2, [...path, index2], readonly);
          for (const key in value) {
            proxyMap[key] = value[key];
          }
          break;
        }
        default:
          if (index2 >= context.length(objectId)) {
            context.insert(objectId, index2, value, datatype);
          } else {
            context.put(objectId, index2, value, datatype);
          }
      }
      return true;
    },
    deleteProperty(target, index2) {
      const { context, objectId } = target;
      index2 = parseListIndex(index2);
      const elem = context.get(objectId, index2);
      if (elem != null && elem[0] == "counter") {
        throw new TypeError("Unsupported operation: deleting a counter from a list");
      }
      context.delete(objectId, index2);
      return true;
    },
    has(target, index2) {
      const { context, objectId, heads } = target;
      index2 = parseListIndex(index2);
      if (typeof index2 === "number") {
        return index2 < context.length(objectId, heads);
      }
      return index2 === "length";
    },
    getOwnPropertyDescriptor(target, index2) {
      const { context, objectId, heads } = target;
      if (index2 === "length")
        return { writable: true, value: context.length(objectId, heads) };
      if (index2 === OBJECT_ID)
        return { configurable: false, enumerable: false, value: objectId };
      index2 = parseListIndex(index2);
      const value = valueAt(target, index2);
      return { configurable: true, enumerable: true, value };
    },
    getPrototypeOf(target) {
      return Object.getPrototypeOf(target);
    },
    ownKeys() {
      const keys3 = [];
      keys3.push("length");
      return keys3;
    }
  };
  var TextHandler = Object.assign({}, ListHandler, {
    get(target, index2) {
      const { context, objectId, heads } = target;
      index2 = parseListIndex(index2);
      if (index2 === Symbol.hasInstance) {
        return (instance) => {
          return Array.isArray(instance);
        };
      }
      if (index2 === Symbol.toStringTag) {
        return target[Symbol.toStringTag];
      }
      if (index2 === OBJECT_ID)
        return objectId;
      if (index2 === IS_PROXY)
        return true;
      if (index2 === TRACE)
        return target.trace;
      if (index2 === STATE)
        return { handle: context };
      if (index2 === "length")
        return context.length(objectId, heads);
      if (typeof index2 === "number") {
        return valueAt(target, index2);
      } else {
        return textMethods(target)[index2] || listMethods(target)[index2];
      }
    },
    getPrototypeOf() {
      return Object.getPrototypeOf(new Text2());
    }
  });
  function mapProxy(context, objectId, textV2, path, readonly, heads) {
    const target = {
      context,
      objectId,
      path: path || [],
      readonly: !!readonly,
      frozen: false,
      heads,
      cache: {},
      textV2
    };
    const proxied = {};
    Object.assign(proxied, target);
    const result = new Proxy(proxied, MapHandler);
    return result;
  }
  function listProxy(context, objectId, textV2, path, readonly, heads) {
    const target = {
      context,
      objectId,
      path: path || [],
      readonly: !!readonly,
      frozen: false,
      heads,
      cache: {},
      textV2
    };
    const proxied = [];
    Object.assign(proxied, target);
    return new Proxy(proxied, ListHandler);
  }
  function textProxy(context, objectId, path, readonly, heads) {
    const target = {
      context,
      objectId,
      path: path || [],
      readonly: !!readonly,
      frozen: false,
      heads,
      cache: {},
      textV2: false
    };
    const proxied = {};
    Object.assign(proxied, target);
    return new Proxy(proxied, TextHandler);
  }
  function listMethods(target) {
    const { context, objectId, path, readonly, frozen, heads, textV2 } = target;
    const methods = {
      deleteAt(index2, numDelete) {
        if (typeof numDelete === "number") {
          context.splice(objectId, index2, numDelete);
        } else {
          context.delete(objectId, index2);
        }
        return this;
      },
      fill(val, start, end) {
        const [value, datatype] = import_value(val, textV2);
        const length3 = context.length(objectId);
        start = parseListIndex(start || 0);
        end = parseListIndex(end || length3);
        for (let i = start; i < Math.min(end, length3); i++) {
          if (datatype === "list" || datatype === "map") {
            context.putObject(objectId, i, value);
          } else if (datatype === "text") {
            if (textV2) {
              assertString(value);
              context.putObject(objectId, i, value);
            } else {
              assertText(value);
              const text3 = context.putObject(objectId, i, "");
              const proxyText = textProxy(context, text3, [...path, i], readonly);
              for (let i2 = 0; i2 < value.length; i2++) {
                proxyText[i2] = value.get(i2);
              }
            }
          } else {
            context.put(objectId, i, value, datatype);
          }
        }
        return this;
      },
      indexOf(o, start = 0) {
        const length3 = context.length(objectId);
        for (let i = start; i < length3; i++) {
          const value = context.getWithType(objectId, i, heads);
          if (value && (value[1] === o[OBJECT_ID] || value[1] === o)) {
            return i;
          }
        }
        return -1;
      },
      insertAt(index2, ...values2) {
        this.splice(index2, 0, ...values2);
        return this;
      },
      pop() {
        const length3 = context.length(objectId);
        if (length3 == 0) {
          return void 0;
        }
        const last2 = valueAt(target, length3 - 1);
        context.delete(objectId, length3 - 1);
        return last2;
      },
      push(...values2) {
        const len = context.length(objectId);
        this.splice(len, 0, ...values2);
        return context.length(objectId);
      },
      shift() {
        if (context.length(objectId) == 0)
          return;
        const first = valueAt(target, 0);
        context.delete(objectId, 0);
        return first;
      },
      splice(index2, del2, ...vals) {
        index2 = parseListIndex(index2);
        del2 = parseListIndex(del2);
        for (const val of vals) {
          if (val && val[OBJECT_ID]) {
            throw new RangeError("Cannot create a reference to an existing document object");
          }
        }
        if (frozen) {
          throw new RangeError("Attempting to use an outdated Automerge document");
        }
        if (readonly) {
          throw new RangeError("Sequence object cannot be modified outside of a change block");
        }
        const result = [];
        for (let i = 0; i < del2; i++) {
          const value = valueAt(target, index2);
          if (value !== void 0) {
            result.push(value);
          }
          context.delete(objectId, index2);
        }
        const values2 = vals.map((val) => import_value(val, textV2));
        for (const [value, datatype] of values2) {
          switch (datatype) {
            case "list": {
              const list = context.insertObject(objectId, index2, []);
              const proxyList = listProxy(context, list, textV2, [...path, index2], readonly);
              proxyList.splice(0, 0, ...value);
              break;
            }
            case "text": {
              if (textV2) {
                assertString(value);
                context.insertObject(objectId, index2, value);
              } else {
                const text3 = context.insertObject(objectId, index2, "");
                const proxyText = textProxy(context, text3, [...path, index2], readonly);
                proxyText.splice(0, 0, ...value);
              }
              break;
            }
            case "map": {
              const map3 = context.insertObject(objectId, index2, {});
              const proxyMap = mapProxy(context, map3, textV2, [...path, index2], readonly);
              for (const key in value) {
                proxyMap[key] = value[key];
              }
              break;
            }
            default:
              context.insert(objectId, index2, value, datatype);
          }
          index2 += 1;
        }
        return result;
      },
      unshift(...values2) {
        this.splice(0, 0, ...values2);
        return context.length(objectId);
      },
      entries() {
        const i = 0;
        const iterator = {
          next: () => {
            const value = valueAt(target, i);
            if (value === void 0) {
              return { value: void 0, done: true };
            } else {
              return { value: [i, value], done: false };
            }
          }
        };
        return iterator;
      },
      keys() {
        let i = 0;
        const len = context.length(objectId, heads);
        const iterator = {
          next: () => {
            let value = void 0;
            if (i < len) {
              value = i;
              i++;
            }
            return { value, done: true };
          }
        };
        return iterator;
      },
      values() {
        const i = 0;
        const iterator = {
          next: () => {
            const value = valueAt(target, i);
            if (value === void 0) {
              return { value: void 0, done: true };
            } else {
              return { value, done: false };
            }
          }
        };
        return iterator;
      },
      toArray() {
        const list = [];
        let value;
        do {
          value = valueAt(target, list.length);
          if (value !== void 0) {
            list.push(value);
          }
        } while (value !== void 0);
        return list;
      },
      map(f) {
        return this.toArray().map(f);
      },
      toString() {
        return this.toArray().toString();
      },
      toLocaleString() {
        return this.toArray().toLocaleString();
      },
      forEach(f) {
        return this.toArray().forEach(f);
      },
      concat(other) {
        return this.toArray().concat(other);
      },
      every(f) {
        return this.toArray().every(f);
      },
      filter(f) {
        return this.toArray().filter(f);
      },
      find(f) {
        let index2 = 0;
        for (const v of this) {
          if (f(v, index2)) {
            return v;
          }
          index2 += 1;
        }
      },
      findIndex(f) {
        let index2 = 0;
        for (const v of this) {
          if (f(v, index2)) {
            return index2;
          }
          index2 += 1;
        }
        return -1;
      },
      includes(elem) {
        return this.find((e) => e === elem) !== void 0;
      },
      join(sep) {
        return this.toArray().join(sep);
      },
      reduce(f, initialValue) {
        return this.toArray().reduce(f, initialValue);
      },
      reduceRight(f, initialValue) {
        return this.toArray().reduceRight(f, initialValue);
      },
      lastIndexOf(search2, fromIndex = Infinity) {
        return this.toArray().lastIndexOf(search2, fromIndex);
      },
      slice(index2, num) {
        return this.toArray().slice(index2, num);
      },
      some(f) {
        let index2 = 0;
        for (const v of this) {
          if (f(v, index2)) {
            return true;
          }
          index2 += 1;
        }
        return false;
      },
      [Symbol.iterator]: function* () {
        let i = 0;
        let value = valueAt(target, i);
        while (value !== void 0) {
          yield value;
          i += 1;
          value = valueAt(target, i);
        }
      }
    };
    return methods;
  }
  function textMethods(target) {
    const { context, objectId, heads } = target;
    const methods = {
      set(index2, value) {
        return this[index2] = value;
      },
      get(index2) {
        return this[index2];
      },
      toString() {
        return context.text(objectId, heads).replace(/￼/g, "");
      },
      toSpans() {
        const spans = [];
        let chars = "";
        const length3 = context.length(objectId);
        for (let i = 0; i < length3; i++) {
          const value = this[i];
          if (typeof value === "string") {
            chars += value;
          } else {
            if (chars.length > 0) {
              spans.push(chars);
              chars = "";
            }
            spans.push(value);
          }
        }
        if (chars.length > 0) {
          spans.push(chars);
        }
        return spans;
      },
      toJSON() {
        return this.toString();
      },
      indexOf(o, start = 0) {
        const text3 = context.text(objectId);
        return text3.indexOf(o, start);
      }
    };
    return methods;
  }
  function assertText(value) {
    if (!(value instanceof Text2)) {
      throw new Error("value was not a Text instance");
    }
  }
  function assertString(value) {
    if (typeof value !== "string") {
      throw new Error("value was not a string");
    }
  }

  // node_modules/@automerge/automerge/dist/mjs/low_level.js
  function UseApi(api) {
    for (const k in api) {
      ;
      ApiHandler[k] = api[k];
    }
  }
  var ApiHandler = {
    create(textV2, actor) {
      throw new RangeError("Automerge.use() not called");
    },
    load(data2, textV2, actor) {
      throw new RangeError("Automerge.use() not called (load)");
    },
    encodeChange(change2) {
      throw new RangeError("Automerge.use() not called (encodeChange)");
    },
    decodeChange(change2) {
      throw new RangeError("Automerge.use() not called (decodeChange)");
    },
    initSyncState() {
      throw new RangeError("Automerge.use() not called (initSyncState)");
    },
    encodeSyncMessage(message) {
      throw new RangeError("Automerge.use() not called (encodeSyncMessage)");
    },
    decodeSyncMessage(msg) {
      throw new RangeError("Automerge.use() not called (decodeSyncMessage)");
    },
    encodeSyncState(state) {
      throw new RangeError("Automerge.use() not called (encodeSyncState)");
    },
    decodeSyncState(data2) {
      throw new RangeError("Automerge.use() not called (decodeSyncState)");
    },
    exportSyncState(state) {
      throw new RangeError("Automerge.use() not called (exportSyncState)");
    },
    importSyncState(state) {
      throw new RangeError("Automerge.use() not called (importSyncState)");
    }
  };

  // node_modules/@automerge/automerge-wasm/bundler/automerge_wasm.js
  var automerge_wasm_exports = {};
  __export(automerge_wasm_exports, {
    Automerge: () => Automerge,
    SyncState: () => SyncState,
    TextRepresentation: () => TextRepresentation,
    __wbg_String_91fba7ded13ba54c: () => __wbg_String_91fba7ded13ba54c,
    __wbg_apply_5435e78b95a524a6: () => __wbg_apply_5435e78b95a524a6,
    __wbg_assign_b0b6530984f36574: () => __wbg_assign_b0b6530984f36574,
    __wbg_buffer_cf65c07de34b9a08: () => __wbg_buffer_cf65c07de34b9a08,
    __wbg_call_9495de66fdbe016b: () => __wbg_call_9495de66fdbe016b,
    __wbg_call_95d1ea488d03e4e8: () => __wbg_call_95d1ea488d03e4e8,
    __wbg_call_99043a1e2a9e5916: () => __wbg_call_99043a1e2a9e5916,
    __wbg_concat_040af6c9ba38dd98: () => __wbg_concat_040af6c9ba38dd98,
    __wbg_crypto_e1d53a1d73fb10b8: () => __wbg_crypto_e1d53a1d73fb10b8,
    __wbg_defineProperty_4926f24c724d5310: () => __wbg_defineProperty_4926f24c724d5310,
    __wbg_deleteProperty_31090878b92a7c0e: () => __wbg_deleteProperty_31090878b92a7c0e,
    __wbg_done_1ebec03bbd919843: () => __wbg_done_1ebec03bbd919843,
    __wbg_entries_4e1315b774245952: () => __wbg_entries_4e1315b774245952,
    __wbg_error_f851667af71bcfc6: () => __wbg_error_f851667af71bcfc6,
    __wbg_for_9a885d0d6d415e40: () => __wbg_for_9a885d0d6d415e40,
    __wbg_freeze_4dcdbf0b5d9b50f4: () => __wbg_freeze_4dcdbf0b5d9b50f4,
    __wbg_from_67ca20fa722467e6: () => __wbg_from_67ca20fa722467e6,
    __wbg_getRandomValues_805f1c3d65988a5a: () => __wbg_getRandomValues_805f1c3d65988a5a,
    __wbg_getTime_7c59072d1651a3cf: () => __wbg_getTime_7c59072d1651a3cf,
    __wbg_get_27fe3dac1c4d0224: () => __wbg_get_27fe3dac1c4d0224,
    __wbg_get_baf4855f9a986186: () => __wbg_get_baf4855f9a986186,
    __wbg_globalThis_87cbb8506fecf3a9: () => __wbg_globalThis_87cbb8506fecf3a9,
    __wbg_global_c85a9259e621f3db: () => __wbg_global_c85a9259e621f3db,
    __wbg_instanceof_ArrayBuffer_a69f02ee4c4f5065: () => __wbg_instanceof_ArrayBuffer_a69f02ee4c4f5065,
    __wbg_instanceof_Date_e353425d719aa266: () => __wbg_instanceof_Date_e353425d719aa266,
    __wbg_instanceof_Object_f5a826c4da0d4a94: () => __wbg_instanceof_Object_f5a826c4da0d4a94,
    __wbg_instanceof_Uint8Array_01cebe79ca606cca: () => __wbg_instanceof_Uint8Array_01cebe79ca606cca,
    __wbg_isArray_39d28997bf6b96b4: () => __wbg_isArray_39d28997bf6b96b4,
    __wbg_iterator_55f114446221aa5a: () => __wbg_iterator_55f114446221aa5a,
    __wbg_keys_60443f4f867207f9: () => __wbg_keys_60443f4f867207f9,
    __wbg_length_27a2afe8ab42b09f: () => __wbg_length_27a2afe8ab42b09f,
    __wbg_length_e498fbc24f9c1d4f: () => __wbg_length_e498fbc24f9c1d4f,
    __wbg_length_ea0846e494e3b16e: () => __wbg_length_ea0846e494e3b16e,
    __wbg_log_7bb108d119bafbc1: () => __wbg_log_7bb108d119bafbc1,
    __wbg_log_d047cf0648d2678e: () => __wbg_log_d047cf0648d2678e,
    __wbg_msCrypto_6e7d3e1f92610cbb: () => __wbg_msCrypto_6e7d3e1f92610cbb,
    __wbg_new_15d3966e9981a196: () => __wbg_new_15d3966e9981a196,
    __wbg_new_537b7341ce90bb31: () => __wbg_new_537b7341ce90bb31,
    __wbg_new_abda76e883ba8a5f: () => __wbg_new_abda76e883ba8a5f,
    __wbg_new_b525de17f44a8943: () => __wbg_new_b525de17f44a8943,
    __wbg_new_f127e324c1313064: () => __wbg_new_f127e324c1313064,
    __wbg_new_f9876326328f45ed: () => __wbg_new_f9876326328f45ed,
    __wbg_newnoargs_2b8b6bd7753c76ba: () => __wbg_newnoargs_2b8b6bd7753c76ba,
    __wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5: () => __wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5,
    __wbg_newwithlength_b56c882b57805732: () => __wbg_newwithlength_b56c882b57805732,
    __wbg_next_88560ec06a094dea: () => __wbg_next_88560ec06a094dea,
    __wbg_next_b7d530c04fd8b217: () => __wbg_next_b7d530c04fd8b217,
    __wbg_node_080f4b19d15bc1fe: () => __wbg_node_080f4b19d15bc1fe,
    __wbg_ownKeys_9efe69be404540aa: () => __wbg_ownKeys_9efe69be404540aa,
    __wbg_process_038c26bf42b093f8: () => __wbg_process_038c26bf42b093f8,
    __wbg_push_49c286f04dd3bf59: () => __wbg_push_49c286f04dd3bf59,
    __wbg_randomFillSync_6894564c2c334c42: () => __wbg_randomFillSync_6894564c2c334c42,
    __wbg_require_78a3dcfbdba9cbce: () => __wbg_require_78a3dcfbdba9cbce,
    __wbg_self_e7c1f827057f6584: () => __wbg_self_e7c1f827057f6584,
    __wbg_set_17224bc548dd1d7b: () => __wbg_set_17224bc548dd1d7b,
    __wbg_set_17499e8aa4003ebd: () => __wbg_set_17499e8aa4003ebd,
    __wbg_set_20cbc34131e76824: () => __wbg_set_20cbc34131e76824,
    __wbg_set_6aa458a4ebdb65cb: () => __wbg_set_6aa458a4ebdb65cb,
    __wbg_set_wasm: () => __wbg_set_wasm,
    __wbg_slice_47202b1d012cdc55: () => __wbg_slice_47202b1d012cdc55,
    __wbg_stack_658279fe44541cf6: () => __wbg_stack_658279fe44541cf6,
    __wbg_subarray_7526649b91a252a6: () => __wbg_subarray_7526649b91a252a6,
    __wbg_toString_7a3e0cd68ea2a337: () => __wbg_toString_7a3e0cd68ea2a337,
    __wbg_unshift_06a94bcbcb492eb3: () => __wbg_unshift_06a94bcbcb492eb3,
    __wbg_value_6ac8da5cc5b3efda: () => __wbg_value_6ac8da5cc5b3efda,
    __wbg_values_7444c4c2ccefdc9b: () => __wbg_values_7444c4c2ccefdc9b,
    __wbg_versions_ab37218d2f0b24a8: () => __wbg_versions_ab37218d2f0b24a8,
    __wbg_window_a09ec664e14b1b81: () => __wbg_window_a09ec664e14b1b81,
    __wbindgen_bigint_from_i64: () => __wbindgen_bigint_from_i64,
    __wbindgen_bigint_from_u64: () => __wbindgen_bigint_from_u64,
    __wbindgen_boolean_get: () => __wbindgen_boolean_get,
    __wbindgen_debug_string: () => __wbindgen_debug_string,
    __wbindgen_error_new: () => __wbindgen_error_new,
    __wbindgen_is_function: () => __wbindgen_is_function,
    __wbindgen_is_null: () => __wbindgen_is_null,
    __wbindgen_is_object: () => __wbindgen_is_object,
    __wbindgen_is_string: () => __wbindgen_is_string,
    __wbindgen_is_undefined: () => __wbindgen_is_undefined,
    __wbindgen_json_serialize: () => __wbindgen_json_serialize,
    __wbindgen_jsval_loose_eq: () => __wbindgen_jsval_loose_eq,
    __wbindgen_memory: () => __wbindgen_memory,
    __wbindgen_number_get: () => __wbindgen_number_get,
    __wbindgen_number_new: () => __wbindgen_number_new,
    __wbindgen_object_clone_ref: () => __wbindgen_object_clone_ref,
    __wbindgen_object_drop_ref: () => __wbindgen_object_drop_ref,
    __wbindgen_string_get: () => __wbindgen_string_get,
    __wbindgen_string_new: () => __wbindgen_string_new,
    __wbindgen_throw: () => __wbindgen_throw,
    create: () => create7,
    decodeChange: () => decodeChange,
    decodeSyncMessage: () => decodeSyncMessage,
    decodeSyncState: () => decodeSyncState,
    encodeChange: () => encodeChange,
    encodeSyncMessage: () => encodeSyncMessage,
    encodeSyncState: () => encodeSyncState,
    exportSyncState: () => exportSyncState,
    importSyncState: () => importSyncState,
    initSyncState: () => initSyncState,
    load: () => load
  });

  // wasm-stub:C:\Users\ulyss\Development\nodysseus\node_modules\@automerge\automerge-wasm\bundler\automerge_wasm_bg.wasm
  var automerge_wasm_bg_exports2 = {};
  __export(automerge_wasm_bg_exports2, {
    default: () => automerge_wasm_bg_default2
  });

  // wasm-binary:C:\Users\ulyss\Development\nodysseus\node_modules\@automerge\automerge-wasm\bundler\automerge_wasm_bg.wasm
  var automerge_wasm_bg_exports = {};
  __export(automerge_wasm_bg_exports, {
    default: () => automerge_wasm_bg_default
  });
  var automerge_wasm_bg_default = __toBinary("AGFzbQEAAAABhwMyYAJ/fwBgAn9/AX9gA39/fwF/YAF/AGADf39/AGAEf39/fwBgAX8Bf2AFf39/f38AYAJ/fgF/YAd/f39/f39/AX9gAAF/YAF/AX5gBn9/f39/fwBgAn9/AX5gB39/f39/f38AYAV/f39/fwF/YAAAYAR/f39/AX9gBH9+f38AYAN/f34AYAZ/f39/f38Bf2AIf39/f39/f38AYAJ/fgBgAX8BfGADf35/AGABfgF/YAZ/f39/fn4AYAR/fH9/AX9gA39+fwF/YAR/f35/AGAFf39/fn8AYAV/f39/fAF/YAF8AX9gA39+fgBgCn9/f39/f39/f38AYAV/fn9/fwBgCX9/f39/f35+fgBgBX9/f3x/AGAJf39/f39/f39/AGADfn9/AX9gBH9/f34AYAZ/f398fH8AYAZ/f398f38AYA9/f39/f39/f39/f39/f38Bf2ALf39/f39/f39/f38Bf2AFf399f38AYAR/fX9/AGAFf398f38AYAR/fH9/AGAFf39+f38AAuUkVxYuL2F1dG9tZXJnZV93YXNtX2JnLmpzG19fd2JpbmRnZW5fb2JqZWN0X2Nsb25lX3JlZgAGFi4vYXV0b21lcmdlX3dhc21fYmcuanMaX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYAAxYuL2F1dG9tZXJnZV93YXNtX2JnLmpzFV9fd2JpbmRnZW5fc3RyaW5nX25ldwABFi4vYXV0b21lcmdlX3dhc21fYmcuanMXX193YmluZGdlbl9pc191bmRlZmluZWQABhYuL2F1dG9tZXJnZV93YXNtX2JnLmpzFV9fd2JpbmRnZW5fc3RyaW5nX2dldAAAFi4vYXV0b21lcmdlX3dhc21fYmcuanMVX193YmluZGdlbl9udW1iZXJfbmV3ACAWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcxRfX3diaW5kZ2VuX2lzX3N0cmluZwAGFi4vYXV0b21lcmdlX3dhc21fYmcuanMWX193YmluZGdlbl9pc19mdW5jdGlvbgAGFi4vYXV0b21lcmdlX3dhc21fYmcuanMVX193YmluZGdlbl9udW1iZXJfZ2V0AAAWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcxJfX3diaW5kZ2VuX2lzX251bGwABhYuL2F1dG9tZXJnZV93YXNtX2JnLmpzFl9fd2JpbmRnZW5fYm9vbGVhbl9nZXQABhYuL2F1dG9tZXJnZV93YXNtX2JnLmpzGV9fd2JpbmRnZW5fanNvbl9zZXJpYWxpemUAABYuL2F1dG9tZXJnZV93YXNtX2JnLmpzFF9fd2JpbmRnZW5fZXJyb3JfbmV3AAEWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcxpfX3diZ19uZXdfYWJkYTc2ZTg4M2JhOGE1ZgAKFi4vYXV0b21lcmdlX3dhc21fYmcuanMcX193Ymdfc3RhY2tfNjU4Mjc5ZmU0NDU0MWNmNgAAFi4vYXV0b21lcmdlX3dhc21fYmcuanMcX193YmdfZXJyb3JfZjg1MTY2N2FmNzFiY2ZjNgAAFi4vYXV0b21lcmdlX3dhc21fYmcuanMaX193YmluZGdlbl9iaWdpbnRfZnJvbV9pNjQAGRYuL2F1dG9tZXJnZV93YXNtX2JnLmpzGl9fd2JpbmRnZW5fYmlnaW50X2Zyb21fdTY0ABkWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcxRfX3diaW5kZ2VuX2lzX29iamVjdAAGFi4vYXV0b21lcmdlX3dhc21fYmcuanMZX193YmluZGdlbl9qc3ZhbF9sb29zZV9lcQABFi4vYXV0b21lcmdlX3dhc21fYmcuanMdX193YmdfU3RyaW5nXzkxZmJhN2RlZDEzYmE1NGMAABYuL2F1dG9tZXJnZV93YXNtX2JnLmpzGl9fd2JnX3NldF8yMGNiYzM0MTMxZTc2ODI0AAQWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcyVfX3diZ19yYW5kb21GaWxsU3luY182ODk0NTY0YzJjMzM0YzQyAAQWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcyZfX3diZ19nZXRSYW5kb21WYWx1ZXNfODA1ZjFjM2Q2NTk4OGE1YQAAFi4vYXV0b21lcmdlX3dhc21fYmcuanMdX193YmdfY3J5cHRvX2UxZDUzYTFkNzNmYjEwYjgABhYuL2F1dG9tZXJnZV93YXNtX2JnLmpzHl9fd2JnX3Byb2Nlc3NfMDM4YzI2YmY0MmIwOTNmOAAGFi4vYXV0b21lcmdlX3dhc21fYmcuanMfX193YmdfdmVyc2lvbnNfYWIzNzIxOGQyZjBiMjRhOAAGFi4vYXV0b21lcmdlX3dhc21fYmcuanMbX193Ymdfbm9kZV8wODBmNGIxOWQxNWJjMWZlAAYWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcx9fX3diZ19tc0NyeXB0b182ZTdkM2UxZjkyNjEwY2JiAAYWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcx5fX3diZ19yZXF1aXJlXzc4YTNkY2ZiZGJhOWNiY2UAChYuL2F1dG9tZXJnZV93YXNtX2JnLmpzGl9fd2JnX2xvZ183YmIxMDhkMTE5YmFmYmMxAAMWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcxpfX3diZ19sb2dfZDA0N2NmMDY0OGQyNjc4ZQAAFi4vYXV0b21lcmdlX3dhc21fYmcuanMaX193YmdfZ2V0XzI3ZmUzZGFjMWM0ZDAyMjQAARYuL2F1dG9tZXJnZV93YXNtX2JnLmpzHV9fd2JnX2xlbmd0aF9lNDk4ZmJjMjRmOWMxZDRmAAYWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcxpfX3diZ19uZXdfYjUyNWRlMTdmNDRhODk0MwAKFi4vYXV0b21lcmdlX3dhc21fYmcuanMgX193YmdfbmV3bm9hcmdzXzJiOGI2YmQ3NzUzYzc2YmEAARYuL2F1dG9tZXJnZV93YXNtX2JnLmpzG19fd2JnX25leHRfYjdkNTMwYzA0ZmQ4YjIxNwAGFi4vYXV0b21lcmdlX3dhc21fYmcuanMbX193YmdfbmV4dF84ODU2MGVjMDZhMDk0ZGVhAAYWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcxtfX3diZ19kb25lXzFlYmVjMDNiYmQ5MTk4NDMABhYuL2F1dG9tZXJnZV93YXNtX2JnLmpzHF9fd2JnX3ZhbHVlXzZhYzhkYTVjYzViM2VmZGEABhYuL2F1dG9tZXJnZV93YXNtX2JnLmpzH19fd2JnX2l0ZXJhdG9yXzU1ZjExNDQ0NjIyMWFhNWEAChYuL2F1dG9tZXJnZV93YXNtX2JnLmpzGl9fd2JnX2dldF9iYWY0ODU1ZjlhOTg2MTg2AAEWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcxtfX3diZ19jYWxsXzk1ZDFlYTQ4OGQwM2U0ZTgAARYuL2F1dG9tZXJnZV93YXNtX2JnLmpzGl9fd2JnX25ld19mOTg3NjMyNjMyOGY0NWVkAAoWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcx1fX3diZ19sZW5ndGhfZWEwODQ2ZTQ5NGUzYjE2ZQAGFi4vYXV0b21lcmdlX3dhc21fYmcuanMbX193Ymdfc2VsZl9lN2MxZjgyNzA1N2Y2NTg0AAoWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcx1fX3diZ193aW5kb3dfYTA5ZWM2NjRlMTRiMWI4MQAKFi4vYXV0b21lcmdlX3dhc21fYmcuanMhX193YmdfZ2xvYmFsVGhpc184N2NiYjg1MDZmZWNmM2E5AAoWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcx1fX3diZ19nbG9iYWxfYzg1YTkyNTllNjIxZjNkYgAKFi4vYXV0b21lcmdlX3dhc21fYmcuanMaX193Ymdfc2V0XzE3MjI0YmM1NDhkZDFkN2IABBYuL2F1dG9tZXJnZV93YXNtX2JnLmpzG19fd2JnX2Zyb21fNjdjYTIwZmE3MjI0NjdlNgAGFi4vYXV0b21lcmdlX3dhc21fYmcuanMeX193YmdfaXNBcnJheV8zOWQyODk5N2JmNmI5NmI0AAYWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcxtfX3diZ19wdXNoXzQ5YzI4NmYwNGRkM2JmNTkAARYuL2F1dG9tZXJnZV93YXNtX2JnLmpzHl9fd2JnX3Vuc2hpZnRfMDZhOTRiY2JjYjQ5MmViMwABFi4vYXV0b21lcmdlX3dhc21fYmcuanMtX193YmdfaW5zdGFuY2VvZl9BcnJheUJ1ZmZlcl9hNjlmMDJlZTRjNGY1MDY1AAYWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcxpfX3diZ19uZXdfMTVkMzk2NmU5OTgxYTE5NgABFi4vYXV0b21lcmdlX3dhc21fYmcuanMbX193YmdfY2FsbF85NDk1ZGU2NmZkYmUwMTZiAAIWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcxtfX3diZ19jYWxsXzk5MDQzYTFlMmE5ZTU5MTYADxYuL2F1dG9tZXJnZV93YXNtX2JnLmpzJl9fd2JnX2luc3RhbmNlb2ZfRGF0ZV9lMzUzNDI1ZDcxOWFhMjY2AAYWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcx5fX3diZ19nZXRUaW1lXzdjNTkwNzJkMTY1MWEzY2YAFxYuL2F1dG9tZXJnZV93YXNtX2JnLmpzGl9fd2JnX25ld19mMTI3ZTMyNGMxMzEzMDY0AAYWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcyhfX3diZ19pbnN0YW5jZW9mX09iamVjdF9mNWE4MjZjNGRhMGQ0YTk0AAYWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcx1fX3diZ19hc3NpZ25fYjBiNjUzMDk4NGYzNjU3NAABFi4vYXV0b21lcmdlX3dhc21fYmcuanMlX193YmdfZGVmaW5lUHJvcGVydHlfNDkyNmYyNGM3MjRkNTMxMAACFi4vYXV0b21lcmdlX3dhc21fYmcuanMeX193YmdfZW50cmllc180ZTEzMTViNzc0MjQ1OTUyAAYWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcx1fX3diZ19mcmVlemVfNGRjZGJmMGI1ZDliNTBmNAAGFi4vYXV0b21lcmdlX3dhc21fYmcuanMbX193Ymdfa2V5c182MDQ0M2Y0Zjg2NzIwN2Y5AAYWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcx1fX3diZ192YWx1ZXNfNzQ0NGM0YzJjY2VmZGM5YgAGFi4vYXV0b21lcmdlX3dhc21fYmcuanMdX193YmdfY29uY2F0XzA0MGFmNmM5YmEzOGRkOTgAARYuL2F1dG9tZXJnZV93YXNtX2JnLmpzHF9fd2JnX3NsaWNlXzQ3MjAyYjFkMDEyY2RjNTUAAhYuL2F1dG9tZXJnZV93YXNtX2JnLmpzGl9fd2JnX2Zvcl85YTg4NWQwZDZkNDE1ZTQwAAEWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcx9fX3diZ190b1N0cmluZ183YTNlMGNkNjhlYTJhMzM3AAYWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcx1fX3diZ19idWZmZXJfY2Y2NWMwN2RlMzRiOWEwOAAGFi4vYXV0b21lcmdlX3dhc21fYmcuanMxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfOWZiMmYxMTM1NWVjYWRmNQACFi4vYXV0b21lcmdlX3dhc21fYmcuanMaX193YmdfbmV3XzUzN2I3MzQxY2U5MGJiMzEABhYuL2F1dG9tZXJnZV93YXNtX2JnLmpzGl9fd2JnX3NldF8xNzQ5OWU4YWE0MDAzZWJkAAQWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcx1fX3diZ19sZW5ndGhfMjdhMmFmZThhYjQyYjA5ZgAGFi4vYXV0b21lcmdlX3dhc21fYmcuanMsX193YmdfaW5zdGFuY2VvZl9VaW50OEFycmF5XzAxY2ViZTc5Y2E2MDZjY2EABhYuL2F1dG9tZXJnZV93YXNtX2JnLmpzJF9fd2JnX25ld3dpdGhsZW5ndGhfYjU2Yzg4MmI1NzgwNTczMgAGFi4vYXV0b21lcmdlX3dhc21fYmcuanMfX193Ymdfc3ViYXJyYXlfNzUyNjY0OWI5MWEyNTJhNgACFi4vYXV0b21lcmdlX3dhc21fYmcuanMcX193YmdfYXBwbHlfNTQzNWU3OGI5NWE1MjRhNgACFi4vYXV0b21lcmdlX3dhc21fYmcuanMlX193YmdfZGVsZXRlUHJvcGVydHlfMzEwOTA4NzhiOTJhN2MwZQABFi4vYXV0b21lcmdlX3dhc21fYmcuanMeX193Ymdfb3duS2V5c185ZWZlNjliZTQwNDU0MGFhAAYWLi9hdXRvbWVyZ2Vfd2FzbV9iZy5qcxpfX3diZ19zZXRfNmFhNDU4YTRlYmRiNjVjYgACFi4vYXV0b21lcmdlX3dhc21fYmcuanMXX193YmluZGdlbl9kZWJ1Z19zdHJpbmcAABYuL2F1dG9tZXJnZV93YXNtX2JnLmpzEF9fd2JpbmRnZW5fdGhyb3cAABYuL2F1dG9tZXJnZV93YXNtX2JnLmpzEV9fd2JpbmRnZW5fbWVtb3J5AAoDwQq/ChUHBA4ABAAEEQcABQcEEQQHGgEAAAQABwAEBwUHBQcABgAABAQFBAAABAQDBBUOAAcEEQwEAAAABQAOBQAMBAQEBAUGBAUABAQADgQDAgEFBQQEFAAAAAQHAQQAAAQFAAUABQYEBQwABA4EBAAMBRoFBwEEAwAABAUABAEFAwQAAQEAAAAEDAIAABQABQIDBAAEBwAWBwEWABQEBRUHBwAAAAQEBAAAAAAAAAUbAgUAAAABAAMAAAMFAAAEBQEAAAAAAAAAIQAEFgQABQAABAQFCQQMBwAFAAAECQkJCQEUBAcDAwAEBAAMAAQFBQAEAAkMBAYEHAQGBwAFAwMDCQAiCQkDBQkJCRsMAAQHBAYEBgUABQACBAUDAAQAAAMDAAAdBwcEHgIAAAEABQEeAw0ABAEDAAMEAwMAAwMDAAAAAQMDAAcBAQ0AAQAAAAMHAQMEAwAHAAAABAAHBwAABwQAAgQFAQMNDRAAAQ0NBAMDAQMNBwQSAAUNAwAAAAQGBg0FAQEDAAAAAAMSARwAABISAgQAAQQBBAQDBAAAGAYDAAABAAAOACMFABIEAAEAAAUAAAEAGAEkHQMEBQADAQUOAAwDBAQAAAUABAAlBQAFAQcHAQUACQAGHwUFAAYEBwcHBQYDDwABBQQHBAAAAAQABwEBJgYEAQQBAQEFAwAFGAAEAAQFJwMACygBARcpKgwVAAcFBwcABAUAAQQDAAcDAgcAAQADBAADAQMEAAABAwQABAAHAAMDAwQEAQUBBQoDDwoDAAEAAQQEBAEEAQQEBAEDAAEBAwQFAAAFCQQAAwEEAQQGAQAABAEDAAAAAgECAwAAAAMBBQMBAQwGAwQBAAEBAwYAAQYGBgEDBAABAAEABREGAQEAAQEEBAQEBAQBBAQABAEBAAAAAAAAAAAAAAAAAAAAAAAAAQQEAAABBAUFBQEEBAABAAAAAQEBAQEGAgQEAwABAQcJAwEBBQwOBQEPAysDAQEDAQADACwDBgUGBQADBgQHCQMGAQEBAAUDAAEBBgYGAAEMAAIDAQAGEwEDBQEBBhMAAAEAAwQDAQYDAQEEAAMBAAYGAwYGBAcDAAABAQYGAQEEAwIDAAMDAAAEAwQGBgEEBgEBAQEBAAEBAQEBAQEBBgMAAQEBAQEBAQAABgEEAAMBAQECAAEBHwEAAQUBAQQFAQEBAQEABAYDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEDBgEBAQEGBgUDAAEBBgMBBAYAAwQDEAEAAQABBAAHAQEBAQEBAQMBAQEGAwMEAQEBAQEHAQEBBQUDAAECAwICAQQBBgQEAgICCgYDAwIBAgAQAAQAEBADAgAAAAABAQEADwAAAQEEBAEAAAABAAEBBgMBAQEBAQEBAQEBBAMBAQEBAQEBAQEBAQEKAAEBAAEAAAMBBQYBAQEDAwMCARQBAQABAQctLzEPAAMDBgAFAQEBAgAEAQEBAQQBAQoDAREEBAQOABMDAQEBAQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUCBQUFBQEHAAEAAAABAQAAAAQAAAMBAQAAAQQEBgAABgYBAQIGAQEBBAQEAQQEAgEBAQYBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBARAQAAEEAQYCAQECAgICAQEBAQEBAQEBAQEBAAADBgEXBgYGAQYAAQAGAw0LCwsLCwsLCwsLAQYIAQ0LCwsDBAAWBAcBcAH3BPcEBQMBABIGCQF/AUGAgMAACwfsC0QGbWVtb3J5AgAUX193YmdfYXV0b21lcmdlX2ZyZWUA1AQNYXV0b21lcmdlX25ldwCrBA9hdXRvbWVyZ2VfY2xvbmUAnwQOYXV0b21lcmdlX2ZvcmsAqwMUYXV0b21lcmdlX3BlbmRpbmdPcHMA2AcQYXV0b21lcmdlX2NvbW1pdADIBw9hdXRvbWVyZ2VfbWVyZ2UAtQQSYXV0b21lcmdlX3JvbGxiYWNrAOQEDmF1dG9tZXJnZV9rZXlzALkEDmF1dG9tZXJnZV90ZXh0AP8DEGF1dG9tZXJnZV9zcGxpY2UA5QQOYXV0b21lcmdlX3B1c2gA7AQUYXV0b21lcmdlX3B1c2hPYmplY3QApAQQYXV0b21lcmdlX2luc2VydADmBBZhdXRvbWVyZ2VfaW5zZXJ0T2JqZWN0AKMEDWF1dG9tZXJnZV9wdXQA5wQTYXV0b21lcmdlX3B1dE9iamVjdADIBBNhdXRvbWVyZ2VfaW5jcmVtZW50AO0EDWF1dG9tZXJnZV9nZXQAtgQVYXV0b21lcmdlX2dldFdpdGhUeXBlALcEEGF1dG9tZXJnZV9nZXRBbGwAuAQWYXV0b21lcmdlX2VuYWJsZUZyZWV6ZQCiBRdhdXRvbWVyZ2VfZW5hYmxlUGF0Y2hlcwCgBxphdXRvbWVyZ2VfcmVnaXN0ZXJEYXRhdHlwZQDIBhZhdXRvbWVyZ2VfYXBwbHlQYXRjaGVzAPYEFGF1dG9tZXJnZV9wb3BQYXRjaGVzAI0FEGF1dG9tZXJnZV9sZW5ndGgA3AQQYXV0b21lcmdlX2RlbGV0ZQDwBA5hdXRvbWVyZ2Vfc2F2ZQCEBxlhdXRvbWVyZ2Vfc2F2ZUluY3JlbWVudGFsAIUHGWF1dG9tZXJnZV9sb2FkSW5jcmVtZW50YWwAqAUWYXV0b21lcmdlX2FwcGx5Q2hhbmdlcwDEAxRhdXRvbWVyZ2VfZ2V0Q2hhbmdlcwDPBBlhdXRvbWVyZ2VfZ2V0Q2hhbmdlQnlIYXNoAPwGGWF1dG9tZXJnZV9nZXRDaGFuZ2VzQWRkZWQA8gYSYXV0b21lcmdlX2dldEhlYWRzAJ0HFGF1dG9tZXJnZV9nZXRBY3RvcklkAMMFHGF1dG9tZXJnZV9nZXRMYXN0TG9jYWxDaGFuZ2UAjQcOYXV0b21lcmdlX2R1bXAA4ggYYXV0b21lcmdlX2dldE1pc3NpbmdEZXBzAMYEHGF1dG9tZXJnZV9yZWNlaXZlU3luY01lc3NhZ2UAlAUdYXV0b21lcmdlX2dlbmVyYXRlU3luY01lc3NhZ2UAiAgOYXV0b21lcmdlX3RvSlMA2QQVYXV0b21lcmdlX21hdGVyaWFsaXplAPkEFWF1dG9tZXJnZV9lbXB0eUNoYW5nZQCwBAZjcmVhdGUAlgQEbG9hZADKAwxlbmNvZGVDaGFuZ2UAgwgMZGVjb2RlQ2hhbmdlAMUHDWluaXRTeW5jU3RhdGUAuggPaW1wb3J0U3luY1N0YXRlAP0DD2V4cG9ydFN5bmNTdGF0ZQC7CBFlbmNvZGVTeW5jTWVzc2FnZQDzBhFkZWNvZGVTeW5jTWVzc2FnZQDpBQ9lbmNvZGVTeW5jU3RhdGUA7gYPZGVjb2RlU3luY1N0YXRlAMwFFF9fd2JnX3N5bmNzdGF0ZV9mcmVlAOADFXN5bmNzdGF0ZV9zaGFyZWRIZWFkcwD3BxdzeW5jc3RhdGVfbGFzdFNlbnRIZWFkcwD4BxtzeW5jc3RhdGVfc2V0X2xhc3RTZW50SGVhZHMAtQUYc3luY3N0YXRlX3NldF9zZW50SGFzaGVzAL4HD3N5bmNzdGF0ZV9jbG9uZQCOBxFfX3diaW5kZ2VuX21hbGxvYwDhCBJfX3diaW5kZ2VuX3JlYWxsb2MAjQkfX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcgCWCg9fX3diaW5kZ2VuX2ZyZWUAtQkUX193YmluZGdlbl9leG5fc3RvcmUA+AkJ8wkBAEEBC/YEqQnsCZIL/Ar8CvwK/wj/CJwJvgjRBOYHugmuCdoGigmhCL8InAm+CNEEkguuCZILuAnvCNUIzgfWCM0HjwqSC6AInwilB6QHpgejB5ILoAqoCpoKogrbBqQK5QeiB54KmwrlCcEJvAmxCJILoQq9B/AInwqXCuUKsAf5CcIJ5wnDBuID+wbvCoIL7QnbCJMLwwm+Cb8JvQnFCZAE1AbzB+8KhAvvCe8Kkwv0BpYG+AjvCoAL6wnbCJMLxQOmA7MGkgmDC+4J3AiTC5gKyQecCq4KvwayCpIL6QrmCuwKpwr9COoK6wroCucKnQqjCpMK6QnJAZwJvgjRBJILrwjJBNoHuwnECcAJ9AaWBvII7wqBC9sIoQmvCZkKrQqvCtMGswqJA74GsAqsCpILkgumCuQK4wrtCu4K7QOqCqUKqwq0CpwJvgjRBJILsQqpCpILsAjKBNsHnAnACNIE5weSC5ILkAmUCpILsAjKBNwH6QmcCcAI0gToB5IL7AXiB5wJqQmrCe8KiAv8Ce8KkwuSC+8IwAb3CIcJrwbRCtcFyAqhCZwKxwXACu0Fpwm5CpIL3QnYCYcJlAfpBssJ0wnbCcoJmwaaCqIJ8wjPCKYGzwrrCJkImgn9CoUL6Qe2Cr0IpwSMB+8KhgvzCe8KkwvXCdkJyQnaCfQGgQvyCZMLnAqoCbwKnAm+CNEE7AeSC4MJgAikBs4J0AneCcMGggv0CZMLpgjqCO8I0gnhCf0KhQvNCdUJ5gmSC/QIugqWCJ8HjAjWCegJwAbRCZcI+wr9CoULuwqmCbcKywr+BZMItAaLB+QIgAmqB8cKuQe9CskKtwfECsYKqQmaCJcD5gWcCb4I0QSSC6sJxArmCJgIrQepB6sH0QejCK8Hswj1CKAK6Ai+CuoH5QiTCdIHxQrsCbgKrwmcCb4I0QSSC50KvQWQBNUG9gfvCoQL9wmTC/QGgAv2CZMLkAiHCZQIrgfBBv0KhQvZCKwJtQqQB9QJ/gqSC8cJwQfDB+MIpQj9CoUL2QXMCtIKygqSC68IyQTdB90IkgijBukIlAn5A6IIwwr6Bp8GsweRCc0K4AasCO8I6weoB5sKuAq2B8EKlQjTB+cIkQjUB/0KhQvCCtAKtQegCdoDiAmOCb8KtAepCaoKmAWSC98J9giPB8wJ4AmQBMgDgwvyCZIJkwv0Bv0KhQunCKkK9AeVBbkGnAm+CNEEkgvrA/cGhwvzCe8KkwvVB98I7wqJC/YJ7wqTC/QGyAm3BcgDxgn9CoULrAf1B+gFwgfOCs8J3Am4BZILqAaSC+AI0wqSC+0H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NwMAIA4gBikDADcDoAIgByAAQX9zQQV0aiIRQQhqIgspAwAhKyARQRBqIgUpAwAhKiARQRhqIgApAwAhKSAGIBEpAwA3AwAgECApNwMAIBIgKjcDACANICs3AwAgACAVKQMANwMAIAUgGikDADcDACALIBYpAwA3AwAgESAOKQOgAjcDACAILQAAIQAgFSAGQThqIhEpAwA3AwAgGiAGQTBqIhApAwA3AwAgFiAGQShqIhIpAwA3AwAgDiAGQSBqIg0pAwA3A6ACIAcgAEF/c0EFdGoiF0EIaiILKQMAISsgF0EQaiIFKQMAISogF0EYaiIAKQMAISkgDSAXKQMANwMAIBEgKTcDACAQICo3AwAgEiArNwMAIAAgFSkDADcDACAFIBopAwA3AwAgCyAWKQMANwMAIBcgDikDoAI3AwAgBkFAayEGIAggCksgCEECayEIDQALCyAZIA4pAwA3AwAgJCAnKQMANwMAICUgFCkDADcDACAeICIpAwA3AwAgHCAGIAFrQQV2IAlqIgFLBEAgIyAkKQMANwMAIA8gJSkDADcDACAgIB4pAwA3AwAgDiAZKQMANwOgASAZIAFBBXRqIgdBCGoiCikDACErIAdBEGoiBSkDACEqIAdBGGoiACkDACEpIBkgBykDADcDACAkICk3AwAgJSAqNwMAIB4gKzcDACAAICMpAwA3AwAgBSAPKQMANwMAIAogICkDADcDACAHIA4pA6ABNwMAIAEgHCABayIFIAEgBUkbIBxBA3YgB0EgaiEAAkAgBUEBayIFIAFNBEAgACAFIAIgByAEEFggGSEADAELIBkgASACIAMgBBBYIAchAyAFIQELTyElIAkgDE8hBiABQRVPDQEMAwsLIAEgHEHAwcEAEJwHAAsgBSAcQaDBwQAQnAcACyABQQJJDQAgDkGsAWohA0EAIQlBACEFQQEhEANAAkACQCAAIBBBBXRqIgspAwAiKiAQQQFrIhxBBXQiBCAAaiIKKQMAIilRBEACfyALLwEIRQRAIAtBCmovAQAiCEERTw0LIAtBDGoMAQsgC0EUaigCACEIIAtBEGooAgALAn8gACAEaiIEQQhqLwEARQRAIARBCmovAQAiDUERTw0IIARBDGoMAQsgBEEUaigCACENIARBEGooAgALIAggDSAIIA1JGxDhCiICIAggDWsgAhtBAEgN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BCAAGxEAAAALIAVBwAJqJAAgAygCoAhBAkYNAiADQegFaiADQfAHakGIAhDgChpB2PPEACgCAEEBa0EFSQ0LQdTwxAAtAAAiBA4DCwUDBAsgEARAIBwQ1AELAkAgBkUNACAJRQ0AIAcQ1AELQQAhG0EFIQVBACEYQQAhBCApDQ4MDwsgARDUAUEEIQUMCwsgA0GECmpBATYCACADQYwKakEANgIAIANB5N7BADYCgAogA0GwxMEANgKICiADQQA2AvgJIANB+AlqQezewQAQ2ggAC0ECIQQMAQtBzPDEABD1A0H/AXEiBEUNBgtB0PDEACgCACAEENAIRQ0FIANByApqIgFB0PDEACgCABCCCUHQ8MQAKAIAIQYgA0HwB2ogARDFCCADKALwB0UNEiADQZgLaiIBQRBqIBkoAgA2AgAgAUEIaiADQfAHaiIEQQhqIgEpAwA3AwAgAyADKQPwBzcDmAsgA0EBNgLsCyADQYzfwQA2AugLIANBADYC9AsgA0GwxMEANgLwCyADQQA2AuALIAQgA0HICmoQxQggAygC8AdFDRIgA0GwC2oiBEEQaiAZKAIANgIAIARBCGogASkDADcDACADIAMpA/AHNwOwCyADIANB6AVqNgLgCiADQfAHaiADQcgKahDFCCADKALwB0UNEiADQcgLaiIEQRBqIBkoAgA2AgAgBEEIaiABKQMANwMAIAMgAykD8Ac3A8gLIANB+AlqIgFBGGogA0HoBWoiBUEYaikDADcDACABQRBqIAVBEGopAwA3AwAgAUEIaiAFQQhqKQMANwMAIAMgAykD6AU3A/gJIAMgATYCiAsgA0Gk38EANgKQCCADQZTfwQA2AoQIIANB9MrBADYC+AcgAyADQYgLajYCjAggAyAENgKICCADIANB4ApqNgKACCADIANBsAtqNgL8ByADIANB4AtqNgL0ByADIANBmAtqNgLwByADIAY2AvAKIANBAzYC7AogAyADQfAHajYC6ApB0PDEACgCACADQegKahD8CAwFC0G/ysEAQSJBpODBABCQCgALQb/KwQBBIkGk4MEAEJAKAAtB/MbBAEGgASABIARBnMjBABDqCQALICJBAUHw9MQAKAIAIgBBygQgABsRAAAACyAFQQFB8PTEACgCACIAQcoEIAAbEQAAAAsgA0HIBGoiAUEIaiAeQQhqKQIA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BjYCNCAEQQE2AjAgBEEUaiAKKQMANwIAIARBHGogBykDADcCACAEQSRqIBIpAwA3AgAgBEEsaiANKAIANgIAIAQgQzYCdCAEQfgAaiAWNgIAIARB/ABqICU2AgAgBEHwAGogDCgCADYCACAEIAMpA/gCNwJoIAQgAykD8AE3A4ABIARBiAFqIANB+AFqKAIANgIAIAQgAykDsAM3AowBIARBlAFqIAspAwA3AgAgBEGcAWogDygCADYCACAEQaABaiADQegFakHkABDgChogAyAIQQFqNgJoIAMoAoQBIgQgAygCiAFHDQALDAMLEMcIAAsgGkEBQfD0xAAoAgAiAEHKBCAAGxEAAAALICtBAksNASADKQMYUA0BIANBIGoiACgCBCEBIAAoAgAgASgCCEEHakF4cWogA0EYaiABKAI0EQAAIAMpAxgiRFANASAAKAIAIAAoAgQiASgCCEEHakF4cWogRCABKAJAEQgAGiADKQMYUA0BIAMoAiAiAigCACEBIAIgAUEBazYCACABQQFHDQEgABCxBwwBCyADQYABahCnAyADQfAHaiIBQQhqIgIgA0H4AGooAgA2AgAgA0GECGogA0HoAGooAgA2AgAgACADKQNwNwIAIAMgAykDYDcC/AcgAEEIaiACKQMANwIAIABBEGogAUEQaikDADcCAAJAIAMoAlAiAEUNACAAIABBJGxBK2pBeHEiAGpBd0YNACADKAJcIABrENQBCyArQQJLDQAgAykDGFANACADQSBqIgAoAgQhASAAKAIAIAEoAghBB2pBeHFqIANBGGogASgCNBEAACADKQMYIkRQDQAgACgCACAAKAIEIgEoAghBB2pBeHFqIEQgASgCQBEIABogAykDGFANACADKAIgIgIoAgAhASACIAFBAWs2AgAgAUEBRw0AIAAQsQcLIANBgAxqJAAPC0G/ysEAQSJBtN/BABCQCgALQb/KwQBBIkH438EAEJAKAAsgBSAEQfD0xAAoAgAiAEHKBCAAGxEAAAAL71wDFX8EfgJ8IwBB0AJrIgckACAHIAI2AjggB0HIAWogASAHQThqEK4BAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAcpA8gBUARAIAdBiAFqIgJBCGog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ASAHQaACaiAHQcgBahCCCiAHKALIASICQYQBTwRAIAIQAQsgByAEuBAFNgLIASAHQaACaiAHQcgBahCCCiAHKALIASICQYQBTwRAIAIQAQsgB0HIAWogB0GQAmpBqITAAEEGELAFIAcoAsgBIQkgBygC1AEhCiAHKALMASELQRghBiAHKALQASINDS1BGiEGIAkQB0EBRw0tIAcgCTYCiAEgB0EgaiAHQYgBaiAHQZACaiAHQaACahCpCCAHKAIkIQkgBygCIEUEQCAJQYQBTwRAIAkQAQsgBygCkAIhBCAHKAKIASICQYQBTwRAIAIQAQsgBygCoAIiAkGEAU8EQCACEAELQQ4hAgwtC0EbIQYgBygCiAEiAkGEAUkNLSACEAEMLQsgB0HIAWohBCADKAIEuCEhIwBBQGoiAiQAIAIgIRAFNgIIIAIgB0H8AWooAgAQADYCDCACIAJBDGogAkEIahC2CCACKAIEIQYCQAJAIAIoAgAEQCACQQ82AiQgAiACQQhqNgIgIAJBATYCPCACQQE2AjQgAkHEksAANgIwIAJBADYCKCACIAJBIGo2AjggAkEQaiACQShqELcDIAIoAhQiCA0BCyAEQQA2AgggBCAGNgIAIAIoAggiBEGEAU8EQCAEEAELIAIoAgwiBEGEAUkNASAEEAEMAQsgAigCECEJIAQgAigCGDYCDCAEIAg2AgggBCAJNgIEIAQgBjYCACACKAIIIgRBhAFPBEAgBBABCyACKAIMIgRBhAFJDQAgBBABCyACQUBrJAAgBygCyAEhBCAHKALQASIJDQIgB0HIAWogBBDLBQJAIActAMgBIgZBHEYEQCAHQRBqIAcoAswBIggQCCAHKAIQIgkNAUEDIQIMKwsMKAsgBysDGCIgRAAAAAAAAODDZiEGIAMpAyAhHSAHQYgBaiICIB1C////////////AAJ+ICCZRAAAAAAAAOBDYwRAICCwDAELQoCAgICAgICAgH8LQoCAgICAgICAgH8gBhsgIET////////fQ2QbQgAgICAgYRt8Ihw3AwggAkEFOgAAIAJBGGoiBkEANgIAIAJBEGoiDCAcNwMAIAdByAFqIgNBGGogBikDADcDACADQRBqIAwpAwA3AwAgA0EIaiACQQhqIgwpAwA3AwAgByAHKQOIATcDyAEgB0HgAGoiAiADEMsIIAdB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BygC0AEhCyAHKAJgIgJBhAFPBEAgAhABC0EAIQJBFCEGDB8LIAdByAFqIQQjAEFAaiICJAAgAiADQQRqIgxBBGooAgAgDEEIaigCABACNgIIIAIgB0GQAmooAgAQADYCDCACIAJBDGogAkEIahC2CCACKAIEIQYCQAJAIAIoAgAEQCACQQ82AiQgAiACQQhqNgIgIAJBATYCPCACQQE2AjQgAkHEksAANgIwIAJBADYCKCACIAJBIGo2AjggAkEQaiACQShqELcDIAIoAhQiCA0BCyAEQQA2AgggBCAGNgIAIAIoAggiBEGEAU8EQCAEEAELIAIoAgwiBEGEAUkNASAEEAEMAQsgAigCECEJIAQgAigCGDYCDCAEIAg2AgggBCAJNgIEIAQgBjYCACACKAIIIgRBhAFPBEAgBBABCyACKAIMIgRBhAFJDQAgBBABCyACQUBrJAAgBygCyAEhBCAHKALQASIJDREgB0HIAWogBBDLBQJAIActAMgBIgZBHEYEQCAHQShqIAcoAswBIggQCCAHKAIoIgkNAUEDIQIMHgsMHAsgBysDMCIgRAAAAAAAAODDZiEEIAMpAyAhHSAHQYgBaiICIB1C////////////AAJ+ICCZRAAAAAAAAOBDYwRAICCwDAELQoCAgICAgICAgH8LQoCAgICAgICAgH8gBBsgIET////////fQ2QbQgAgICAgYRt8Ihw3AwggAkEFOgAAIAJBGGoiBkEANgIAIAJBEGoiDiAcNwMAIAdByAFqIgNBGGogBikDADcDACADQRBqIA4pAwA3AwAgA0EIaiACQQhqIgIpAwA3AwAgByAHKQOIATcDyAEgB0HgAGoiBiADEMsIIAdBsAJqIg4gBiABLQDRAxCwAiADIAEgDhDVAQJAIActAMgBIgZBHEYEQCAHIAcoAswBNgKgAiAHQYgBaiAHQZACaiAMIAdBoAJqENcGIActAIgBDQEgBygCoAIiAkGEAU8EQCACEAELIAcoApACIQQgB0HgAGoQiAdBDiECDB4LIAdBsAFqIgFBCGogB0HkAWopAgA3AwAgAUEQaiAHQewBaigCADYCACAHIAcpAtwBNwOwASAHLwDJASAHLQDLAUEQdHIhASAHKALYASEKIAcoAtQBIQ0gBygC0AEhCyAHKALMASEJQQAhAgwbCyAHKAKMASEEIAIo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DAMLIAZBwAFqIAcgBQR/IAVBHGxBHGsiBEEcbkEBakEHcQJAIARBxAFJBEBBACEEDAELIARBHG5BAWpB+P///wFxIQhBACEEA0AgA0HEAWooAgAgA0GoAWooAgAgA0GMAWooAgAgA0HwAGooAgAgA0HUAGooAgAgA0E4aigCACADQRxqKAIAIAQgAygCAGpqampqampqQQhqIQQgA0HgAWohAyAIQQhrIggNAAsLBEAgBUEcbEEca0EcbkEBakEHcSEIA0AgBCADKAIAakEBaiEEIANBHGohAyAIQQFrIggNAAsLIARBf3MFQX8LIAJqEFwgBSAJTw0IIAFBCGooAgAgBUEGdGoiAikDACEVIAIgBikDwAE3AwAgBkEQaiIDQQhqIAJBCGoiBykDADcDACADQRBqIAJBEGoiBSkDADcDACADQRhqIAJBGGoiBCkDADcDACADQSBqIAJBIGoiCCkDADcDACADQShqIAJBKGoiCSkDADcDACADQTBqIAJBMGoiCikDADcDACADQThqIAJBOGoiAykDADcDACAHIAZBwAFqIgJBCGopAwA3AwAgBSACQRBqKQMANwMAIAQgAkEYaikDADcDACAIIAJBIGopAwA3AwAgCSACQShqKQMANwMAIAogAkEwaikDADcDACADIAJBOGopAwA3AwAgBiAVNwMQDAMLIAUgCU8NCCAGQYABaiIEQQhqIAFBCGooAgAgBUEGdGoiA0EIaikDADcDACAEQRBqIANBEGopAwA3AwAgBEEYaiADQRhqKQMANwMAIARBIGogA0EgaikDADcDACAEQShqIANBKGopAwA3AwAgBEEwaiADQTBqKQMANwMAIARBOGogA0E4aikDADcDACAGIAMpAwA3A4ABIAMgA0FAayAJIAVBf3NqQQZ0EN8KGiABQQxqIAg2AgAgAUEYaiIJKAIAIgQgB00NCSAGQdAAaiIIQQhqIAFBFGoiCigCACAHQRxsaiIDQQhqKQIANwMAIAhBEGogA0EQaikCADcDACAIQRhqIANBGGooAgA2AgAgBiADKQIANwNQIAMgA0EcaiAEIAVrQRxsQThrEN8KGiAJIARBAWsiAzYCACADIAVNDQogCigCACEDIAZBwAFqIgdBOGogBkGAAWoiBEE4aikDADcDACAHQTBqIARBMGopAwA3AwAgB0EoaiAEQShqKQMANwMAIAdBIGogBEEgaikDADcDACAHQRhqIARBGGopAwA3AwAgB0EQaiAEQRBqKQMANwMAIAdBCGogBEEIaikDADcDACAGIAYpA4ABNwPAASAGQRBqIgRBGGogBkHQAGoiCEEYaigCADYCACAEQRBqIAhBEGopAwA3AwAgBEEIaiAIQQhqKQMANwMAIAYgBikDUDcDECADIAVBHGxqIgkgByAEEKgDAkAgBUUEQEEAIQQMAQsgBUEcbEEcayIHQRxuQQFqQQdxAkAgB0HEAUkEQEEAIQQMAQsgB0EcbkEBakH4////AXEhCEEAIQQDQCADQcQBaigCACADQagBaigCACADQYwBaigCACADQfAAaigCACADQdQAaigCACADQThqKAIAIANBHGooAgAgBCADKAIAampqampqampBCGohBCADQeABaiEDIAhBCGsiCA0ACwtFDQAgBUEcbEEca0EcbkEBakEHcSEIA0AgBCADKAIAakEBaiEEIANBHGohAyAIQQFrIggNAAsLIAZBEGogCSACIARrEFwMAgsgBUEBakF4cSEIQQAhBANAIANBxAFqKAIAIANBqAFqKAIAIANBjAFqKAIAIANB8ABqKAIAIANB1ABqKAIAIANBOGooAgAgA0EcaigCACAEIAMoAgBqampqampqakEIaiEEIANB4AFqIQMgCEEIayIIDQALCyAHBEAgBUEBakEHcSEIA0AgBCADKAIAakEBaiEEIANBHGohAyAIQQFrIggNAAsLIAZBwAFqIAogAiAEa0EBahBcIAUgCU8NCSABQQhqKAIAIAVBBnRqIgIpAwAhFSACIAYpA8ABNwMAIAZBEGoiA0EIaiACQQhqIgcpAwA3AwAgA0EQaiACQRBqIgUpAwA3AwAgA0EYaiACQRhqIgQpAwA3AwAgA0EgaiACQSBqIggpAwA3AwAgA0EoaiACQShqIgkpAwA3AwAgA0EwaiACQTBqIgopAwA3AwAgA0E4aiACQThqIgMpAwA3AwAgByAGQcABaiICQQhqKQMANwMAIAUgAkEQaikDADcDACAEIAJBGGopAwA3AwAgCCACQSBqKQMANwMAIAkgAkEoaikDADcDACAKIAJBMGopAwA3AwAgAyACQThqKQMANwMAIAYgFTcDEAsgBiABKAIAQQFqIgE2AoABIAEgDUcNASAAIAYpAxA3AwAgAEE4aiAGQRBqIgFBOGopAwA3AwAgAEEwaiABQTBqKQMANwMAIABBKGogAUEoaikDADcDACAAQSBqIAFBIGopAwA3AwAgAEEYaiABQRhqKQMANwMAIABBEGogAUEQaikDADcDACAAQQhqIAFBCGopAwA3AwAMGgsgByAKTw0IIAlBDGooAgBBD0sEQCANIQMMFAsCQAJAAkACQCAEBEAgCiAHQQFrIghNDQ4gCUEQaygCAEEPSw0BCwJAIAogB0EBaksEQCAJQShqKAIAQQ9LDQELIARFBEAgAUEMaigCACIFRQ0QIAZBgAFqIgdBCGoiBCABQQhqKAIAIgNBCGopAwA3AwAgB0EQaiIIIANBEGopAwA3AwAgB0EYaiIJIANBGGopAwA3AwAgB0EgaiIKIANBIGopAwA3AwAgB0EoaiIMIANBKGopAwA3AwAgB0EwaiIPIANBMGopAwA3AwAgB0E4aiIQIANBOGopAwA3AwAgBiADKQMANwOAASADIANBQGsgBUEBayIDQQZ0EN8KGiABIAM2AgwgAUEYaiILKAIAIgdBAU0NESAGQdAAaiIFQQhqIhEgAUEUaiISKAIAIgNBJGopAgA3AwAgBUEQaiITIANBLGopAgA3AwAgBUEYaiIOIANBNGooAgA2AgAgBiADKQIcNwNQIANBHGogA0E4aiAHQRxsQThrEN8KGiALIAdBAWsiBTYCACASKAIAIQsgBkHAAWoiA0E4aiAQKQMANwMAIANBMGogDykDADcDACADQShqIAwpAwA3AwAgA0EgaiAKKQMANwMAIANBGGogCSkDADcDACADQRBqIAgpAwA3AwAgA0EIaiAEKQMANwMAIAYgBikDgAE3A8ABIAZBEGoiB0EYaiAOKAIANgIAIAdBEGogEykDADcDACAHQQhqIBEpAwA3AwAgBiAGKQNQNwMQIAsgAyAHEKgDIAEgASgCAEEBayIJNgIADBoLIAFBDGooAgAiCSAHQQFrIgVNDREgBkGAAWoiCEEIaiABQQhqKAIAIAtqIgpBQGoiA0EIaikDADcDACAIQRBqIANBEGopAwA3AwAgCEEYaiADQRhqKQMANwMAIAhBIGogA0EgaikDADcDACAIQShqIANBKGopAwA3AwAgCEEwaiADQTBqKQMANwMAIAhBOGogA0E4aikDADcDACAGIAMpAwA3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BwALIAUgA0HYoMAAEJwHAAtBzJ7AAEErQYihwAAQnggACyAIIAVBgKLAABCcBwALIAcgA0Hoo8AAEJwHAAtBkKPAAEHFAEHYo8AAEJ4IAAsgASADQQFrIgk2AgAgAUEYaigCACIFIAdJDQMgAUEUaigCACIDIAdBHGwiAWohCyAHDQELQQAhB0EAIQQMAQsgAUEcayIEQRxuQQFqIghBB3EhAQJAIARBxAFJBEBBACEEDAELIAhB+P///wFxIQhBACEEA0AgA0HEAWooAgAgA0GoAWooAgAgA0GMAWooAgAgA0HwAGooAgAgA0HUAGooAgAgA0E4aigCACADQRxqKAIAIAQgAygCAGpqampqampqQQhqIQQgA0HgAWohAyAIQQhrIggNAAsLIAFFDQAgAUEcbCEIA0AgBCADKAIAakEBaiEEIANBHGohAyAIQRxrIggNAAsLIAUgB00EQCAHIAVB6KTAABCcBwALIAZBwAFqIAsgAiAEaxBcIAYgCUEBaiIBNgIQIAEgDUYEQCAAIAYpA8ABNwMAIABBOGogBkHAAWoiAUE4aikDADcDACAAQTBqIAFBMGopAwA3AwAgAEEoaiABQShqKQMANwMAIABBIGogAUEgaikDADcDACAAQRhqIAFBGGopAwA3AwAgAEEQaiABQRBqKQMANwMAIABBCGogAUEIaikDADcDAAwDCyAGQQA2AogBIAZBCGogBkEQaiAGQYABakGYpcAAEMwHAAsgByAFQYigwAAQjQoACyABIA1BAWs2AgAgAUEMaigCACIFIAJNDQEgBkHAAWoiB0EIaiIEIAFBCGooAgAgAkEGdGoiA0EIaikDADcDACAHQRBqIgggA0EQaikDADcDACAHQRhqIgkgA0EYaikDADcDACAHQSBqIgogA0EgaikDADcDACAHQShqIgsgA0EoaikDADcDACAHQTBqIgwgA0EwaikDADcDACAHQThqIgcgA0E4aikDADcDACAGIAMpAwA3A8ABIAMgA0FAayAFIAJBf3NqQQZ0EN8KGiABIAVBAWs2AgwgBiABKAIAQQFqIgE2AhAgASANRw0CIAAgBikDwAE3AwAgAEE4aiAHKQMANwMAIABBMGogDCkDADcDACAAQShqIAspAwA3AwAgAEEgaiAKKQMANwMAIABBGGogCSkDADcDACAAQRBqIAgpAwA3AwAgAEEIaiAEKQMANwMACyAGQYACaiQADwsgAiAFQYifwAAQmgcACyAGQQA2AogBIAZBCGogBkEQaiAGQYABakGIpcAAEMwHAAuCPQIQfwF+IwBBkAFrIgIkACACECs2AgwCQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQQFrDgYBAgMEBQYACyACQfgAaiABQQxqKAIANgIAIAIgASkCBDcDcCABQRRqKAIAIQMgAUEYaigCACEEIAEoAhAhBiACQcgAaiABQfgAaikDADcDACACQUBrIAFB8ABqKQMANwMAIAJBOGogAUHoAGopAwA3AwAgAkEwaiABQeAAaikDADcDACACQRBqIgdBGGogAUHYAGopAwA3AwAgAkEgaiABQdAAaikDADcDACAHQQhqIAFByABqKQMANwMAIAIgASkDQDcDECACQeD5wABBBhACNgJQIAJBjfrAAEEDEAI2AmAgAkGAAWogAkEMaiACQdAAaiACQeAAahD5ByACKAJQIQcCQCACLQCAASIKBEAgAigChAEhBQwBCyAHQYQBSQ0AIAcQAQsgAigCYCILQYQBTwRAIAsQAQsgCkUNDCAAIAc2AgQgAEETOgAAIABBCGogBTYCAAwUCyACQfgAaiABQRBqKAIANgIAIAIgASkCCDcDcCABKAIEIQUgAkHIAGogAUHwAGopAwA3AwAgAkFAayABQegAaikDADcDACACQThqIAFB4ABqKQMANwMAIAJBMGogAUHYAGopAwA3AwAgAkEoaiABQdAAaikDADcDACACQRBqIgRBEGogAUHIAGopAwA3AwAgBEEIaiABQUBrKQMANwMAIAIgASkDODcDECACQeD5wABBBhACNgJQIAJBjfrAAEEDEAI2AmAgAkGAAWogAkEMaiACQdAAaiACQeAAahD5ByACKAJQIQQCQCACLQCAASIGBEAgAigChAEhAwwBCyAEQYQBSQ0AIAQQAQsgAigCYCIIQYQBTwRAIAgQAQsgBkUNCiAAIAQ2AgQgAEETOgAAIABBCGogAzYCAAwSCyACQfgAaiABQSxqKAIANgIAIAIgASkCJDcDcCABKAIEIQUgAkEQaiIEQRhqIAFBIGooAgA2AgAgBEEQaiABQRhqKQIANwMAIARBCGogAUEQaikC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IIghISAFQQFrIgUNAAsLICGnIgFFDQAgEkEnSw0DIARB0AJqIBJBAnRqIAE2AgAgEkEBaiESCyAEIBI2AvADIAcgFyAHIBdLGyIGQShNDQALCwwCCyASQShB+OXEABCcBwALIAhBKEH45cQAEJwHAAsgBkEoQfjlxAAQjQoACyABQShB+OXEABCNCgALQYjmxABBGkH45cQAEJ4IAAvYLgIRfwJ+IwBBkAVrIgskAAJAAkACQAJAAkACQCADRQRAIABBATsBgAQgAEEAQaACQQ9BABBuIABBAUEgQQ9BABBuQZ4CAn9BACAAQZ0dai0AAA0AGkEBIABBnB1qLQAADQAaQQIgAEGbHWotAAANABpBAyAAQZodai0AAA0AGkEEIABBmR1qLQAADQAaQQUgAEGYHWotAAANABpBBiAAQZcdai0AAA0AGkEHIABBlh1qLQAADQAaQQggAEGVHWotAAANABpBCSAAQZQdai0AAA0AGkEKIABBkx1qLQAADQAaQQsgAEGSHWotAAANABpBDCAAQZEdai0AAA0AGkENIABBkB1qLQAADQAaQQ4gAEGPHWotAAANABpBDyAAQY4dai0AAA0AGkEQIABBjR1qLQAADQAaQREgAEGMHWotAAANABpBEiAAQYsdai0AAA0AGkETIABBih1qLQAADQAaQRQgAEGJHWotAAANABpBFSAAQYgdai0AAA0AGkEWIABBhx1qLQAADQAaQRcgAEGGHWotAAANABpBGCAAQYUdai0AAA0AGkEZIABBhB1qLQAADQAaQRogAEGDHWotAAANABpBGyAAQYIdai0AAA0AGkEcQR0gAEGBHWotAAAbCyIKayEDAkAgAEG9HWotAAANAEEBIQkgAEG8HWotAAANAEECIQkgAEG7HWotAAANAEEDIQkgAEG6HWotAAANAEEEIQkgAEG5HWotAAANAEEFIQkgAEG4HWotAAANAEEGIQkgAEG3HWotAAANAEEHIQkgAEG2HWotAAANAEEIIQkgAEG1HWotAAANAEEJIQkgAEG0HWotAAANAEEKIQkgAEGzHWotAAANAEELIQkgAEGyHWotAAANAEEMIQkgAEGxHWotAAANAEENIQkgAEGwHWotAAANAEEOIQkgAEGvHWotAAANAEEPIQkgAEGuHWotAAANAEEQIQkgAEGtHWotAAANAEERIQkg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AAACQAJAAkACQAJ/AkACQAJAAkACQAJAAkAgAUHAgARqKAIADQAgBEEERiADQf8BcUEER3ENACABQZCABGohFwJAIAFBpIAEaigCAA0AIAFBx4AEai0AAA0AIBcoAgBB/58tcUGBgAFGDQIgAigCACIYRQ0HIAFBzIAEaiEeIAFBnIAEaigCACEJIAFBmIAEaigCACEUIAFBxIAEai0AACEWIAFB3IAEaigCACEKIAFB2IAEaigCACEHIAIoAgQhESABQeSABGohEAJAA0AgCyARTwRAIAEtAMWABEUNCCAHRQ0ICyARIAtrIgNBggIgB2siBSADIAVJGyEGAkACQAJ/AkACQAJAAkACfyABKALggAQgB2pBAk9BACAGG0UEQCAGIAYgC2oiA00EQCADIBFNBEAgBgRAIAsgGGohDCAHIApqIQ9BACEEA0AgBCAPaiIFQf//AXEiCyAQKAIAakGAgAhqIAQgDGotAAAiCDoAACALQYECSQRAIBAoAgAgC2pBgIAKaiAIOgAACyABKALggAQgBCAHampBAWpBA08EQCAFQQJrIhJB//8BcSINIBAoAgAiC0GAgAhqIhVqLQAAQQp0QYD4AXEgFSAFQQFrQf//AXFqLQAAQQV0IAhzc0EBdCEFIAsgDUEBdGogBSALakGAgARqLwEAOwEAIBAoAgAgBWpBgIAEaiASOwEACyAGIARBAWoiBEcNAAsgBCAHaiEHCyADDAMLIAMgEUGMwcMAEI0KAAsgCyADQYzBwwAQjgoACyAGIAtqIgMgBkkNAiADIBFLDQEgByAKaiIFQQJrIQQgECgCAEGAgAhqIgggBUEBa0H//wFxai0AACAIIARB//8BcWotAABBBXRzIQggBiAHaiEHIAsgGGohCwNAIAVB//8BcSIFIBAoAgBqQYCACGogCy0AACIMOgAAIAVBgQJJBEAgECgCACAFakGAgApqIAw6AAALIAtBAWohCyAQKAIAIg8gBEH//wFxQQF0aiAIQQV0QeD/AXEgDHMiCEEBdCIMIA9qQYCABGovAQA7AQAgECgCACAMakGAgARqIAQ7AQAgBEEBaiEEIAVBAWohBSAGQQFrIgYNAAsgAwshCyABQYCAAiAHayIDIAEoAuCABCIFIAMgBUkbIhk2AuCABCABLQDFgARFIAdBggJJcQ0OIApB//8BcSEIIAlB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AAAgASABKAKAgARBAWo2AoCABCABKAKEgAQiBEGAgARJDQkMHAsgBCALaiENQQAhAwJAAkACQANAIAMgC2oiCkEDaiIGQXdLDQUgCkELaiAKQQtqIgRBgoICSw0RGiADIBJqIhZBg4AIaikAACADIA1qIhVBg4AIaikAAIUiJ0IAUg0BIApBE2pBgoICSw0QIBZBi4AIaikAACAVQYuACGopAACFIidCAFINAiADQRBqIgNBgAJHDQALQYICIQMgDCAIQf//A3FHDQIMCgsgBiEECyAEIAtrICd6p0EDdmoiA0EDSQ0IIANBA0cNACAQQf8/Sw0ICyABKAKAgAQiBEGAgARPDRwgASAEaiADIAUgAyAFSRsiA0EDayIGOgAAIAEgASgCgIAEQQFqIgQ2AoCABCAEQYCABE8NHCABIARqIA9BAWsiBDoAACABIAEoAoCABEEBaiIKNgKAgAQgCkGAgARPDQIgASAKaiAEQYD+A3FBCHYiCjoAACABIAEoAoCABEEBajYCgIAEIAEoAoSABCIJQYCABE8NAyABIAlqIgkgCS0AAEEBdjoAACABKAKEgAQiCUGAgARPDQQgASAJaiIJIAktAABBgAFyOgAAIARB//8DcSIJQYAETwRAIATBQQBODQYgCkGAAUGswsMAEJwHAAsgCUGstMMAagwGCyADQYCABEGIrcMAEJwHAAsgCkEDaiAKQQtqQfiswwAQjgoACyAKQYCABEGIrcMAEJwHAAsgCUGAgARBmK3DABCcBwALIAlBgIAEQZitwwAQnAcACyAKQay8wwBqCyEEIAEoAsiABCAELQAAQQF0akHABGoiBCAELwEAQQFqOwEAIAZBgAJJBEAgBkEBdEHIrcMAai8BACIEQaACSQ0DIARBoAJBzMLDABCcBwALIAZBgAJBvMLDABCcBwALIAEoAoCABCIDQYCABE8NAiABIANqIAk6AAAgASABKAKAgARBAWo2AoCABCABKAKEgAQiBEGAgARJDQAMEwtBASEDIAEgBGoiBCAELQAAQQF2OgAAIAlB/wFxIQQLIAEoAsiABCAEQQF0aiIEIAQvAQBBAWo7AQAgASABKAKMgARBAWsiBDYCjIAEAkAgBARAIAEoAoCABCEEDAELIAFBCDYCjIAEIAEgASgCgIAEIgQ2AoSABCABIARBAWoiBDYCgIAECyABIAEoAoiABCADajYCiIAEIAFBgIACIAEoAuCABCADaiIGIAZBgIACTxs2AuCABCAFIANrIQUgAyAIaiEIIAMgC2pB//8BcSELIARB+f8DSQ0EIAEgCDYC3IAEIAEgBTYC2IAEIA5BEGogASACQQAQfCAOKAIQDQEgDigCFCIDRQRAIAEoAtyABCEIIAEoAtiABCEFDAULIAEgBzYCrIAEIANBAEoNDAwJCyADQYCABEGIrcMAEJwHAAsgAUF/NgLAgAQgASAHNgKsgAQMBwsgCkETagtBgoICQfiswwAQjQoACyAFQQNLDQALC0EAIQogBUUNAANAIBQoAgAgC2pBgIAIai0AACEDIAEgASgCiIAEQQFqNgKIgAQgASgCgIAEIgRBgIAETw0MIAEgBGogAzoAACABIAEoAoCABEEBajYCgIAEIAEoAoSABCIEQYCABE8NCyABIARqIgQgBC0AAEEBdjoAACABIAEoAoyABEEBayIENgKMgAQgBEUEQCABQQg2AoyABCABIAEoAoCABCIENgKEgAQgASAEQQFqNgKAgAQLIAEoAsiABCADQQF0aiIDIAMvAQBBAWo7AQAgAUGAgAIgASgC4IAEQQFqIgMgA0GAgAJPGzYC4IAEIAVBAWshBSAIQQFqIQgCQCABKAKAgARB+P8DSwRAIAEgCDYC3IAEIAEgBTYC2IAEIA5BCGogASACQQAQfCAOKAIIDQQgDigCDCIDDQEgASgC3IAEIQggASgC2IAEIQULIAtBAWpB//8BcSELIAVFDQIMAQsLCyABIAc2AqyABCADQQBMDQEMBAsgASAHNgKsgAQgAUF/NgLAgAQLIAAgBzYCACAAIAEoAsCABDYCBCAAIAEoArCABDYCCAwFCyABIAg2AtyABCABIAo2AtiABCABIAc2AqyABAwBCyABIAo2AtyABCABIAc2AtiABCABIAs2AqyABCABIBY6AMSABCABIAk2ApyABCABIBQ2ApiABAsCQCAXQQFqLQAAQTBxRQ0AIBEgASgCrIAEIgNPBEAgDiABQaiABGoiBSgCADYCICAOQSBqIBggAxDxASAFIA4oAiA2AgAMAQsgAyARQfzCwwAQjQoACyABKAKsgAQhBCABLQDFgAQhAyABKAKkgARBAEcMAQtBACEEQQALIQUCQCADQf8BcUUNACABQdiABGooAgAN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aiAQKQMANwMAIAVBCGogBCkDADcDAAsgC0EBayELIAhBIGohCCABIAdHDQALCyAMQcACaiQAC6kxAiF/BH4jAEGAB2siAyQAIANBIGogACABEPoBIANBMGoiBCABQaACEOAKGiAAIAQgAygCKCIBELEBIAMoAiQiEiABQdgAbGohBCADKAIgIQUCQAJAIAIEQCADIBI2AtwCIAMgBDYC2AIgAyASNgLUAiADIAU2AtACIAFFDQEgAUHYAGwhGiAAQZgBaiELIANBuANqQQRyIRsgA0HYBGpBBHIhHCADQZAGaiIBQQRyIR0gA0EwaiIEQUBrIRUgAUEgaiEQIARBCGohDSADQbwEaiEWIANBzARqIRcgA0HIBGohGCAAQfABaiEeIABB7AFqIR8DQCADIBIgGWoiAUHYAGo2AtQCIAFByABqKAIAIgVBAkYNAiABKAIAIQQgAyABQQRqKAIANgLkAiADIAQ2AuACIANB+AJqIgRBCGoiBiABQRBqKQMANwMAIARBEGoiByABQRhqKQMANwMAIARBGGoiCSABQSBqKQMANwMAIARBIGoiCCABQShqKQMANwMAIARBKGoiDCABQTBqKQMANwMAIARBMGoiCiABQThqKQMANwMAIARBOGoiDiABQUBrKQMANwMAIANB8AJqIhMgAUHUAGooAgA2AgAgAyABQQhqKQMANwP4AiADIAFBzABqKQIANwPoAiADQYgEaiIEQThqIA4pAwA3AwAgBEEwaiAKKQMANwMAIARBKGogDCkDADcDACAEQSBqIAgpAwA3AwAgBEEYaiAJKQMANwMAIARBEGogBykDADcDACAEQQhqIAYpAwA3AwAgAyADKQP4AjcDiAQgAyAFNgLIBCAXIAMpA+gCNwIAIBdBCGogEygCADYCACADQTBqIQECfyALIANB4AJqEKMFQf8BcSIHQQRHBEBBAiAALQDIAkEARyAHQQNHG0H/AXEMAQtBAgshBSABIAQQ3wEgAUHgAGpCBDcCACABIAU6AIABIAFCADcDWCABQgA3A1AgAUEAOwCBASABQfAAakKAgICAIDcDACABQoCAgIDAADcDaCADQdgEaiEJIANB4AJqIQVBACEGIwBBkAFrIgQkAAJAAkACQAJAAkAgC0HoAGooAgBFDQAgBUEEaigCACIOIAUoAgAiCkGVlYi5AmxBBXdzQZWViLkCbCIFQRl2rUKBgoSIkKDAgAF+ISYgC0HsAGooAgAiE0H0AGshESALQeAAaigCACEIA0AgBSAIcSIMIBNqKQAAIiUgJoUiJEKBgoSIkKDAgAF9ICRCf4WDQoCBgoSIkKDAgH+DISQDQCAkUARAICUgJUIBhoNCgIGChIiQoMCAf4NCAFINAyAMIAZBCGoiBmohBQwCCyAkeiEnICRCAX0gJIMhJCARICenQQN2IAxqIAhxQYx/bGoiBSgCACAKRw0AIAVBBGooAgAgDkcNAAsLIARBCGogAUGIARDgChogBUEUaigCACIGRQ0DIAQgBEEIaiAFQQhqIgFBACAGGyIFIAsgAUHIAGoiBigCACABQcwAaiIBKAIAEN0BIAQoAgBBAWsOAgECAwsgCSABQYgBEOAKGgwDCyAFIARBCGogCyAGKAIAIAEoAgBBASAEKAIEEKgCGgwBCyAFIARBCGogCyAGKAIAIAEoAgBBACABEKgCGgsgCSAEQQhqQYgBEOAKGgsgBEGQAWokACADKAKoBSEgIAMoArQFIAMoArgFIRMgAygCvAUhFCADKAKsBSEFIAMoArAFIQkgAygCwAUgAygCxAUhDiADKALIBSEEIAMtANoFIQEgA0HgBWogCyADKALgAiADKALkAhCWBQJAAkACQAJAAkACQAJAIAMoAsgERQRAIB4oAgAiCCADKALMBCIGTQ0CIANBkAZqIgggHygCACAGQQxsahDKByANIAhBCGooAgA2AgAgAyADKQOQBjcDMCADQYAGaiIGIANBMGoiCCkCADcCACAGQQhqIAhBCGooAgA2AgAMAQsgA0GABmoiBkEANgIEIAYgBTYCAAsCQAJAAkAgAy0A1ARFBEAgA0GIBGotAABBC0YNASADQQhqIgYgA0GIBGoiBykDCDcDCCAGIActAABBDEatNwMAIAMoAghBAUcNAkEBIQZBACEMIAQNA0EAIQUMCQsgB0EDRwRAIANBkAZqIgEgA0GIBGoQ3wYgECALIAMoAqgEIAMoAqwEEJYFIANB0AZqIgZBGGogA0HgBWoiBEEYaikDADcDACAGQRBqIARBEGopAwA3AwAgBkEIaiAEQQhqKQMANwMAIAMgAykD4AU3A9AGIANBMGoiBEE4aiABQThqKQMANwMAIARBMGogAUEwaikDADcDACAEQShqIAFBKGopAwA3AwAgBEEgaiAQKQMANwMAIARBGGogAUEYaikDADcDACAEQRBqIAFBEGopAwA3AwAgDSABQQhqKQMANwMAIAMgAykDkAY3AzAgAiAAIAYgBSAEEMgBDAcLIANBMGoiAUEYaiADQeAFaiIEQRhqKQMANwMAIAFBEGogBEEQaikDADcDACANIARBCGopAwA3AwAgAyADKQPgBTcDMCADQRhqIANBiARqEIkIIAIgACABIAUgAygCGCADKAIcEIoBDAYLIAQEQCADQZAGaiIBIARBAnQgDmpBBGsiBCgCABDfBiAQIAsgBCgCACIEKAIgIARBJGooAgAQlgUgA0HQBmoiB0EYaiADQeAFaiIEQRhqKQMANwMAIAdBEGogBEEQaikDADcDACAHQQhqIARBCGopAwA3AwAgAyADKQPgBTcD0AYgA0HwBmoiCkEIaiADQYgGaigCADYCACADIAMpA4AGNwPwBiADQTBqIglBOGogAUE4aikDADcDACAJQTBqIAFBMGopAwA3AwAgCUEoaiABQShqKQMANwMAIAlBIGogECkDADcDACAJQRhqIAFBGGopAwA3AwAgCUEQaiABQRBqKQMANwMAIA0gAUEIaikDADcDACADIAMpA5AGNwMwQQEhDCMAQdABayIEJAACQAJAIAItAAxFDQAgBEEIaiAAIAcQ5gEgBCgCDEUNACAEKQIMISQgBCgCCCEFIARBGGoiASAJEN4IIAFBOGoiBiAJQThqKQMANwMAIAFBMGoiCCAJQTBqKQMANwMAIAFBKGoiESAJQShqKQMANwMAIAQgCSkDIDcDOCAKKAIAIQECfyAKKAIEIiMEQCAEQeQAaiAHQQhqKQIANwIAIARB7ABqIAdBEGopAgA3AgAgBEH0AGogB0EYaikCADcCACAEQYQBaiAEQRhqIg9BCGopAwA3AgAgBEGMAWogD0EQaikDADcCACAEQZQBaiAPQRhqKQMANwIAIARBnAFqIARBOGopAwA3AgAgBEGkAWogESkDADcCACAEQawBaiAIKQMANwIAIARBtAFqIAYpAwA3AgAgBCAEKQMYNwJ8IAQgBykCADcCXCAKKQIEISUgASEGQQAMAQsgBEHYAGoiD0EIaiAHQQxqKQIANwMAIA9BEGogB0EUaikCADcDACAPQRhqIAdBHGooAgA2AgAgBEH8AGog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BEEYRw0BIAMoAtwEIgQoAgAhASAEIAFBAWs2AgAgAUEBRw0BIBwQrggMAQsgAygC3ARFDQAgAygC4AQQ1AELIAMoAoAFBEAgAygChAUQ1AELIAMoAowFBEAgAygCkAUQ1AELAkAgAy0AuAMiAUEKa0H/AXFBA0kNAAJAAkACQCABDgkAAQMDAwMDAwIDCyADKAK8A0UNAiADKALAAxDUAQwCCyADLQDTA0EYRw0BIAMoArwDIgQoAgAhASAEIAFBAWs2AgAgAUEBRw0BIBsQrggMAQsgAygCvANFDQAgAygCwAMQ1AELIAMoAuADBEAgAygC5AMQ1AELIAMoAuwDBEAgAygC8AMQ1AELIBogGUHYAGoiGUcNAAsMAQsgAyASNgLEAyADIAQ2AsADIAMgEjYCvAMgAyAFNgK4AwJAIAFFDQAgAUHYAGwhBiADQdgEakEEciEHIANB9ABqIQVBACEEA0AgAyAEIBJqIgFB2ABqNgK8AyABQcgAaigCACIJQQJGDQEgASgCACECIAMgAUEEaigCADYC/AIgAyACNgL4AiADQYgEaiICQQhqIgsgAUEQaikDADcDACACQRBqIgggAUEYaikDADcDACACQRhqIg0gAUEgaikDADcDACACQSBqIhAgAUEoaikDADcDACACQShqIgwgAUEwaikDADcDACACQTBqIgogAUE4aikDADcDACACQThqIgIgAUFAaykDADcDACADQZgGaiIOIAFB1ABqKAIANgIAIAMgAUEIaikDADcDiAQgAyABQcwAaikCADcDkAYgA0EwaiIBQThqIAIpAwA3AwAgAUEwaiAKKQMANwMAIAFBKGogDCkDADcDACABQSBqIBApAwA3AwAgAUEYaiANKQMANwMAIAFBEGogCCkDADcDACABQQhqIAspAwA3AwAgAyADKQOIBDcDMCADIAk2AnAgBSADKQOQBjcCACAFQQhqIA4oAgA2AgAgA0HYBGogACADQfgCaiABENECAkAgAy0A2AQiAUEKa0H/AXFBA0kNAAJAAkACQCABDgkAAQMDAwMDAwIDCyADKALcBEUNAiADKALgBBDUAQwCCyADLQDzBEEYRw0BIAMoAtwEIgIoAgAhASACIAFBAWs2AgAgAUEBRw0BIAcQrggMAQsgAygC3ARFDQAgAygC4AQQ1AELIAMoAoAFBEAgAygChAUQ1AELIAMoAowFBEAgAygCkAUQ1AELIAYgBEHYAGoiBEcNAAsLIANBuANqEPQEDAELIANB0AJqEPQECyADQYAHaiQAC6IpAQ9/IwBB0AFrIgkkACAJIAE2AgggCSAAKAIoIg82AgwCQAJAAkACQCAAQTRqIgwoAgAiCgRAIApBxABsIREgAEEwaiILKAIAIQ0CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAA0BBfyAFIA1qIg5BKGooAgAgBGoiECABRyABIBBLGyISQX9HBEAgEkH/AXFBAWsNAgwDCyAHQQRqIQcgEEEBaiEEIAhBAWohCCARIAVBxABqIgVHDQALIAkgBDYCECAJIA82AhQgABDhBSECIAlBpAFqQR82AgAgCUGIAWoiAEEUakEfNgIAIABBDGpBHzYCACAJQUBrIgFBDGpBBDYCACABQRRqQQQ2AgAgCUEfNgKMASAJIAI2AhggCUHoiMIANgJIIAlBADYCQCAJIAlBGGo2AqABIAkgCUEUajYCmAEgCSAJQRBqNgKQASAJIAlBCGo2AogBIAkgADYCUCABQYiJwgAQ2ggACyAAIA9BAWs2AiggCCAAQUBrKAIAIg5BAWsiBSAFIAhLGyIHIApPDQICQAJAAkACQCANIAdBxABsaiIEQUBrKAIAQQ9NBEAgB0EBaiIEIApPDQggDSAEQcQAbGoiCkFAaygCAEEPTQ0BIAdBxABsIgRBxABuQQFqQQdxIQsgBEHcA08NAgwDCyAEIAcEfyAHQcQAbEHEAGsiCEHEAG5BAWpBB3EgCEHcA08EQCANQYQEaiEFIAhBxABuQQFqQfj//z9xIQgDQCAFKAIAIAVBxABrKAIAIAVBiAFrKAIAIAVBzAFrKAIAIAVBkAJrKAIAIAVB1AJrKAIAIAVBmANrKAIAIAYgBUHcA2soAgBqampqampqakEIaiEGIAVBoARqIQUgCEEIayIIDQALIAVBhARrIQ0LBEAgDUEoaiEFIAdBxABsQcQAa0HEAG5BAWpBB3EhCANAIAYgBSgCAGpBAWohBiAFQcQAaiEFIAhBAWsiCA0ACwsgBkF/cwVBfwsgAWogAiADEGUhASAHIA5PDQggAEE8aigCACAHQQJ0aiIEKAIAIQUgBCABNgIADAMLIAcgDk8NCCAAQTxqKAIAIAdBAnRqIggoAgAhCiAIIAhBBGogDiAHQX9zakECdBDfChogAEFAayAFNgIAIABBNGooAgAiCCAETQ0JIAlBQGsgCygCACAEQcQAbGoiBEHEABDgChogBCAEQcQAaiAIIAdrQcQAbEGIAWsQ3woaIAwgCEEBayIENgIAIAQgB00NCiALKAIAIAlBiAFqIgggCUFAa0HEABDgChogB0HEAGxqIAogCCACIAMQmwMgDCgCACIMIAdJDQsgB0HEAGwhCiALKAIAIQQCQCAHRQ0AIApBxABrIghBxABuQQFqQQdxIAhB3ANJBH8gBAUgBEGEBGohBSAHQcQAbEHEAGtBxABuQQFqQfj//z9xIQgDQCAFKAIAIAVBxABrKAIAIAVBiAFrKAIAIAVBzAFrKAIAIAVBkAJrKAIAIAVB1AJrKAIAIAVBmANrKAIAIAYgBUHcA2soAgBqampqampqakEIaiEGIAVBoARqIQUgCEEIayIIDQALIAVBhARrCyEIRQ0AIAhBKGohBSAHQcQAbEHEAGtBxABuQQFqQQdxIQgDQCAGIAUoAgBqQQFqIQYgBUHEAGohBSAIQQFrIggNAAsLIAcgDE8NDCAEIApqIAEgBmsgAiADEGUhBQwCCyANQYQEaiEFIAdBxABsQcQAbkEBakH4//8/cSEIA0AgBSgCACAFQcQAaygCACAFQYgBaygCACAFQcwBaygCACAFQZACaygCACAFQdQCaygCACAFQZgDaygCACAGIAVB3ANrKAIAampqampqampBCGohBiAFQaAEaiEFIAhBCGsiCA0ACyAFQYQEayENCyALBEAgDUEoaiEFIAdBxABsQcQAbkEBakEHcSEIA0AgBiAFKAIAakEBaiEGIAVBxABqIQUgCEEBayIIDQALCyAKIAEgBmtBAWogAiADEGUhASAHIA5PDQsgAEE8aigCACAHQQJ0aiIEKAIAIQUgBCABNgIACyADIAVNDQEgACACIAVB0ABsahDzAiAJIAAoAihBAWoiADYCQCAJKAIMIABGDTUgCUEANgKQASAJQQxqIAlBQGsgCUGIAWpBvIjCABDQBwALIAkgBDYCECAIIApPDQoCQAJAAkACQCAO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AkACQAJAAkACQCABLQAAIgRBwgBGBEAgAyACNgI8IAMgAkEBazYCNCADIAE2AjggA0EBNgJAIAMgAUEBajYCMCADQdACaiADQTBqEP8BIAMoAtACIgFFDQIgAygC7AIhJSADKALoAiEcIAMoAuQCIR0gAykC1AIhMCADIAMpAtwCNwI8IAMgMDcCNCADIAE2AjAgA0HQAmogA0EwahD/ASADKALQAiIBDQEgAygC1AIiAkEQdiEJIAJBCHYhBCADQewCaigCACEHIANB6AJqKAIAIQggA0HkAmooAgAhBiADQdACaiIFQRBqKAIAIQEgA0HcAmooAgAhCiAFQQhqKAIAIQsMDQtBASEBQQFBARDwCSIKRQ0CIApBwgA6AABBASELQQAhAkEADA4LIAMoAuwCISYgAygC6AIhHiADKALkAiEfIAMpAtQCITAgAyADKQLcAjcC1AogAyAwNwLMCiADIAE2AsgKIANB0AJqIANByApqEJECAkACQAJAAkACQCADAn8CQAJAAkACQAJAAn8CQAJAAkAgAygC0AJFBEAgAykC1AIiMEL/AYNCAFINASADQTBqQQRyIDBCCIinEJwFDAILIANBMGoiAUEYaiADQdACaiICQRhqKQMANwMAIAFBEGogAkEQaikDADcDACABQQhqIAJBCGopAwA3AwAgAyADKQPQAiIwNwMwIDCnIglFDQEgAygCQCEFIAMoAjwhASADKQI0ITAgAykDSCExIANBADYC+AQgA0KAgICAwAA3A/AEIDFCAFINAkEAIQJBBAwDCyADQThqIDBCIIg+AgAgA0EEOgA0CyADQcwAaigCACEHIANByABqKAIAIQggA0HEAGooAgAhBiADQUBrKAIAIQEgA0E8aigCACEKIAMpAjQMFgsgA0HQAGohDwNAIAMgBTYCQCADIAE2AjwgAyAwNwI0IAMgCTYCMCADQdACaiADQTBqEP8BIAMpAtQCITIgAygC3AIhCiADKALgAiEBIAMoAuQCIQYgAygC6AIhCCADKALsAiEHIAMoAtACIgJFDQ8gAyABNgJAIAMgCjYCPCADIDI3AjQgAyACNgIwIANB0AJqIANBMGoQkwQgAygC1AIhCSADKQPYAiEwIAMoAuACIQEgAygC5AIhBSADKALoAiECIAMoAuwCIQQCQAJAIAMoAtACRQRAIANBADYC2AogAyAENgLMCiADIAI2AsgKIAMgBDYC1AogAyACNgLQCiADQdACaiADQcgKahD2AiADKALQAg0CIAMpAtQCIjBC/wGDQgBSDQEgA0EwakEEciAwQgiIpxCcBQwWCyAwQiCIpwwWCyADQThqIDBCIIg+AgAgA0EEOgA0DBQLIANBMGoiBEEoaiADQdACaiICQShqKAIANgIAIA8gAkEgaikDADcDACAEQRhqIAJBGGopAwA3AwAgBEEQaiACQRBqKQMANwMAIARBCGogAkEIaikDADcDACADIAMpA9ACIjI3AzAgMqdFDRMgA0GAB2oiEiAPQQhqKAIANgIAIAMgDykCADcD+AYgAygCTCEEIAMoAkghCiADKAJEIQsgCUUNAiADKAL4BCICIAMoAvAERgRAIANB8ARqIQ0jAEEgayIMJAACQAJAIAJBAWoiAkUNAEEEIA0oAgAiDkEBdCIRIAIgAiARSRsiAiACQQRNGyICQSRsIREgAkHk8bgcSUECdCEVAkAgDgRAIAwgDkEkbDYCFCAMQQQ2AhggDCANQQRqKAIANgIQDAELIAxBADYCGAsgDCARIBUgDEEQahDKBiAMKAIEIQ4gDCgCAEUEQCANIAI2AgAgDUEEaiAONgIADAILIAxBCGooAgAiAkGBgICAeEYNASACRQ0AIA4gAkHw9MQAKAIAIgBBygQgABsRAAAACxDHCAALIAxBIGokACADKAL4BCECCyADKAL0BCACQSRsaiICIAQ2AgggAiAKNgIEIAIgCzYCACACIAMpA/gGNwIMIAJBFGogEigCADYCACACQSBqIAc2AgAgAkEcaiAINgIAIAJBGGogBjYCACADIAMoAvgEQQFqIgI2AvgEIDFCAX0iMUIAUg0ACyADKALwBCEMIAMoAvQECyEEIAMgAjYCGCADIAQ2AhQgAyAMNgIQIAMgBTYC2AogAyABNgLUCiADIDA3AswKIAMgCTYCyAogA0HQAmogA0HICmoQkQIgAygC0AINASADKQLUAiIwQv8Bg0IAUg0CIANBMGpBBHIgMEIIiKcQnAUMAwsgMKchCSAwQiCIITAgCiEIIAQhByALIQYgASEKIAUhAQwSCyADQTBqIgFBGGogA0HQAmoiAkEYaikDADcDACABQRBqIAJBEGopAwA3AwAgAUEIaiACQQhqKQMANwMAIAMgAykD0AIiMDcDMCAwpyIERQ0BIAMoAkAhCSADKQM4ITAgAygCNCECIAMpA0ghMUEAIQYgA0EANgLwCCADQoCAgICAATcD6AggMUIAUg0CQQAhB0EIDAMLIANBOGogMEIgiD4CACADQQQ6ADQLIANBQGs1AgBCIIYgA0E4aikDACIwQiCIhCExIANBzABqKAIAIQcgA0HIAGooAgAhCCADQcQAaigCACEGIAMoAjQhAiAwpyELDAMLIDBCIIghMiADQfwAaiEFIANBzABqIQYDQCADIAk2AkAgAyAwQv////8PgyAyQiCGhDcDOCADIAI2AjQgAyAENgIwIANB0AJqIANBMGoQkwQgAygC1AIhBCADKALYAiECIAMpAtwCITAgAygC5AIhCSADKALoAiEIIAMoAuwCIQcCQAJ/IAMoAtACBEAgAiELIDAhMSAJIQYgBAwBCyADQQA2AoAFIAMgBzYC9AQgAyAINgLwBCADIAc2AvwEIAMgCDYC+AQgA0HQAmogA0HwBGoQuAECQCADKAKYA0ECRgRAIAMoAtQCIQEgAy0A0AIiAkEGRwRAIAMoAtgCIQQgAyACOgDwBCADIAMvANECOwDxBCADIAMtANMCOgDzBCADIAQ2AvgEIAMgATYC9AQjAEEwayIBJAAgAUG+AjYCFCABIANB8ARqIgI2AhAgAUEBNgIsIAFBATYCJCABQfyMwgA2AiAgAUEANgIYIAEgAUEQajYCKCABIAFBGGoQtwMgA0EwaiIEQQxqIAFBCGooAgA2AgAgBCABKQMANwIEIARBAToAAAJAIAItAAAiBEEETQRAIARBAkcNASACLQAEQQNHDQEgAkEIaigCACIEKAIAIAQoAgQoAgARAwAgBCgCBCIIQQRqKAIABEAgCEEIaigCABogBCgCABDUAQsgAigCCBDUAQwBCyACKAIEIAJBCGoiBCgCACgCABEDACAEKAIAIgRBBGooAgBFDQAgBEEIaigCABogAigCBBDUAQsgAUEwaiQADAILIANBBDoAMCADIAE2AjQMAQsgA0EwaiADQdACakGgAhDgChogAygCeCIIQQJHDQILIAMoAkghByADKAJEIQggAygCQCEGIAMpAzghMSADKAI0IQsgAygCMAshAiADQegIaiIBKAIIIgQEQCAEQYgCbCABKAIEIgRqIQkDQAJAIAQiASgCMEUNACABQTRqKAIARQ0AIAFBOGooAgAQ1AELIAEoAnQEQCABQfgAaigCABDUAQsCQCABLwGMAUUNACABQZABaigCAEUNACABQZQBaigCABDUAQsgAUGEAWohCiABQYgBaigCACIFBEAgCigCACEEIAVBFGwhBQNAAkAgBC8BAEUNACAEQQRqKAIARQ0AIARBCGooAgAQ1AELIARBFGohBCAFQRRrIgUNAAsLIAEoAoABBEAgCigCABDUAQsgAUGIAmohBAJAIAFB7ABqKAIAIgVFDQAgASgCaEUNACAFENQBCyAEIAlHDQALCyADKALoCEUNBCADKALsCBDUAQwECyADQfgGaiIBQQhqIgcgBkEIaikCADcDACABQRBqIgogBkEQaikCADcDACABQRhqIgsgBkEYaikCADcDACABQSBqIg0gBkEgaikCADcDACABQShqIg8gBkEoaigCADYCACADIAYpAgA3A/gGIAMoAkghDiADQcgKaiAFQdQBEOAKGiADKALwCCIBIAMoAugIRgRAIANB6AhqIAEQjwYgAygC8AghAQsgMEIgiCEyIAMoAuwIIAFBiAJsaiIBIA42AgAgASADKQP4BjcCBCABIAg2AjAgAUEMaiAHKQMANwIAIAFBFGogCikDADcCACABQRxqIAspAwA3AgAgAUEkaiANKQMANwIAIAFBLGogDygCADYCACABQTRqIANByApqQdQBEOAKGiADIAMoAvAIQQFqIgc2AvAIIDFCAX0iMUIAUg0ACyADKALsCCEIIAMoAugIIQYgBEUNASAICyIENgIkIAMgBjYCICADIAQ2AiwgAyAHQYgCbCIRIARqIgk2AihBACECIANBCGohBgJAIAdFBEBBCCEBDAELAkAgB0GcjscDSw0AIAdBoAJsIghBAEgNAAJ/IAdBnY7HA0lBA3QiBSAIRQ0AGiAIIAUQ8AkLIgENASAIIAVB8PTEACgCACIAQcoEIAAbEQAAAAsQxwgACyAGIAE2AgQgBiAHNgIAIAMoAgwhBSADKAIIIQwgB0UNBCADQZQDaiEnIANB4AJqIQ0gA0H8CmohKCADQeQKaiEPIANB0AFqISkgA0G8AWohDiADQbABaiEVIANBpAFqISAgA0GYAWohISADQYAEaiEqIANB7ANqIRIgA0HgA2ohIiADQdQDaiEjIANByANqISQDQCAEKAIwIgdBAkYNBCADQcgGaiIBQQhqIgogBEEIaikDADcDACABQRBqIgsgBEEQaikDADcDACABQRhqIhAgBEEYaikDADcDACABQSBqIhYgBEEgaikDADcDACABQShqIhcgBEEoaikDADcDACADIAQpAwA3A8gGIANB8ARqIgEgBEE0akHUARDgChogDSADKQPIBjcDACANQQhqIAopAwA3AwAgDUEQaiALKQMANwMAIA1BGGogECkDADcDACANQSBqIBYpAwA3AwAgDUEoaiAXKQMANwMAIAMgAjYC2AIgAyAFNgLUAiADIAw2AtACICcgAUHUARDgChogAyAHNgKQAyADQcAKaiITICRBCGooAgA2AgAgA0GwCmoiGCAjQQhqKAIANgIAIAMgJCkDADcDuAogAyAjKQIANwOoCiADKAKUAyEIIAMoApgDIQEgAygCnAMhBiADKQOgAyEwIAMpA6gDITEgAygCsAMhGSADKAK0AyErIAMoArgDISwgAygCvAMhLSADKQPAAyEyIANBoApqIhogIkEIaigCADYCACADQcgKaiIUQQhqIhsgEkEIaikCADcDACAUQRBqIhQgEkEQaigCADYCACADICIpAwA3A5gKIAMgEikCADcDyAogA0EwaiAqQeQAEOAKGgJAIAdFBEACQCABRQRAQQEhBwwBCyABQQBIDQwgAUEBEPAJIgdFDQ0LIAcgCCABEOAKGiABIQgMAQsgASEHIAYhAQsgA0HQCWoiBkEQaiIuIBQoAgA2AgAgBkEIaiIUIBspAwA3AwAgA0HwCWoiGyAaKAIANgIAIANBkApqIhogEygCADYCACADIAMpA8gKNwPQCSADIAMpA5gKNwPoCSADIAMpA7gKNwOICiADQegIaiITIANBMGoiBkHkABDgChogA0GACmoiLyAYKAIANgIAIAMgAykDqAo3A/gJIANBADYCuAogBkEoaiAXKQMANwMAIAZBIGogFikDADcDACAGQRhqIBApAwA3AwAgBkEQaiALKQMANwMAIAZBCGogCikDADcDACADIAMpA8gGNwMwIAMgMjcDkAEgAyAtNgKMASADICw2AogBIAMgKzYChAEgAyAZNgKAASADIDE3A3ggAyAwNwNwIAMgATYCbCADIAc2AmggAyAINgJkIANBATYCYCAhQQhqIBooAgA2AgAgISADKQOICjcDACAgIAMpA/gJNwIAICBBCGogLygCADYCACAVIAMpA+gJNwMAIBVBCGogGygCADYCACAOIAMpA9AJNwIAIA5BCGogFCkDADcCACAOQRBqIC4oAgA2AgAgKSATQeQAEOAKGiADQcgKaiAGIANBuApqENwBIAMoAtwKIQcgAygC2AohCCADKALUCiEGIAMoAtAKIQEgAygCzAohCiADKALICiELIAMoAvgKIhZBAkYNAyADQdAIaiIQQQhqIhcgD0EIaikCADcDACAQQRBqIhMgD0EQaigCADYCACADIA8pAgA3A9AIIAMoAuAKIRggA0H4BmogKEHUARDgChogC0EIdiEQIAMoArgKIRkgBEGIAmohBCACIAxGBEAgA0HQAmogAhCABiADKALUAiEFIAMoAtgCIQILIAJBoAJsIAVqIgIgEDsAASACIAs6AAAgAkEYaiAYNgAAIAJBFGogBzYAACACQRBqIAg2AAAgAkEMaiAGNgAAIAJBCGogATYAACACQQRqIAo2AAAgAkEDaiAQQRB2OgAAIAIgAykD0Ag3AhwgAkEkaiAXKQMANwIAIAJBLGogEygCADYCACACIBY2AjAgAkE0aiADQfgGakHUARDgChogAkGMAmpBAjYCACACQYgCaiAZNgIAIAMoAtgCQQFqIQIgAygC0AIhDCADKALUAiEFIBFBiAJrIhENAAsgCSEEDAQLIAmtQiCGIDKEITEgMKchCwsgAkEQdiEJIAJBCHYhBCAxQiCIpyEBIDGnIQoMCAsgAyAEQYgCajYCJCADQdACahDZByADKALQAgRAIAMoAtQCENQBCyADQSBqELsEQQIhAkEAIQkgAygCECEMQQAhBAwHCyAEQYgCaiEECyADIAQ2AiQgA0EgahC7BCADQdgCaiADQRhqKAIAIgE2AgAgAyADKQMQIjA3A9ACIAAgJjYCFCAAIB42AhAgACAfNgIMIAAgJTYCCCAAIBw2AgQgACAdNgIAIAAgMDcCGCAAQSBqIAE2AgAgACACNgIsIAAgBTYCKCAAIAw2AiQMDwsgAygC1AIiAkEQdiEJIAJBCHYhBCADQewCaigCACEHIANB6AJqKAIAIQggA0HkAmooAgAhBiADQdACaiIFQRBqKAIAIQEgA0HcAmooAgAhCiAFQQhqKAIAIQsMCwtBAUEBQfD0xAAoAgAiAEHK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aiIBSwRAIBogGCgCADYCACAbIBUpAgA3AwAgCSAOKQIANwOoASAOIAFBFGxqIgVBEGoiACgCACEGIAVBCGoiBykCACEkIA4gBSkCADcCACAVICQ3AgAgGCAGNgIAIAAgGigCADYCACAHIBspAwA3AgAgBSAJKQOoATcCACABIA8gAWsiBiABIAZJGyAPQQN2IAVBFGohAAJAIAZBAWsiBiABTQRAIAAgBiACIAUgBBBnIA4hAAwBCyAOIAEgAiADIAQQZyAFIQMgBiEBC08hEyAMIBdNIQUgAUEVTw0BDAULCyABIA9BwMHBABCcBwALIAwgAEGwwcEAEI0KAAsgFyAMQbDBwQAQjgoACwwCCyABQQJJDQBBASEFA0AgACAFQQFqIgUQmwIgASAFRw0ACwsgCUHAAmokAA8LIAhBEEGswsEAEI0KAAsgCkEQQazCwQAQjQoAC9knAhR/An4jAEHACGsiBiQAIANBBGooAgAiFgRAIAFBHGohBwJAIAFBIGooAgAiCEUNACAHKAIARQ0AIAgQ1AELIAcgAykCADcCACAHQQhqIANBCGooAgA2AgALIASnQQFGBEAgASAFNwMICyABQTxqKAIAIRcgBkGgAmoiB0E4aiABQThqKQMANwMAIAdBMGogAUEwaikDADcDACAHQShqIAFBKGopAwA3AwAgB0EgaiABQSBqKQMANwMAIAdBGGogAUEYaikDADcDACAHQRBqIAFBEGopAwA3AwAgB0EIaiABQQhqKQMANwMAIAYgASkDADcDoAICQEHY88QAKAIAIhhBA08NAAJAAkACQEHY88QAKAIAQQJLDQACQAJAAkBBsPPEAC0AACIBDgMDAgABC0ECIQEMAQtBqPPEABD1A0H/AXEiAUUNAQtBrPPEACgCACABENAIDQELIAZBADYC+AIgBkIANwPoAgwBCyAGQazzxAAoAgAiATYCCCAGQQA2AgQgBkHQ+MIANgIAIAZB6AJqIAEgBhDtCAsgBkGIBWoiAUEQaiAGQegCaiIHQRBqKQMANwMAIAFBCGoiASAHQQhqKQMANwMAIAYgBikD6AIiBDcDiAUgBFANACABKAIAIAEoAgQiASgCCEEHakF4cWogBkGIBWogASgCMBEAAAsCQAJAAkACQAJAAkACQCACQcABaigCACIHIAYoArgCIgFLBEACfyACQbwB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ACEMIAJB+ABqKAIAIQggAkH0AGooAgAhAEEAIRAgAkHwAGooAgAMAQsgAkH0AGooAgAhC0EBIRBBASEAIAJB+ABqKAIAIggEQCAIQQBIDREgCEEBEPAJIgBFDQ0LIAAgCyAIEOAKGiAICyENIAMgDDYCjAEgAyAINgKIASADIAA2AoQBIAMgDTYCgAEgAyALOwF+IAMgEDsBfCADICg3A3AgAyACQegAaigCADYCeAsgA0EIaiATQQhqKQMANwMAIANBEGogE0EQaikDADcDACADQRhqIBNBGGopAwA3AwAgA0EgaiATQSBqKQMANwMAIANBKGogE0EoaikDADcDACADIBMpAwA3AwAgBUEQdiEZIARBEHYhFiADNQJIIClCgICAgHCDhCEpIAJBAWotAAAhHiADKQI0IihCIIinIRcgJ0IwiKchECAnQiCIpyELIAMoAlwhGyADKAJYIQogAygCVCEOIAMoAlAhDSADKAJEIQggAygCQCEAIAMoAjAhFCAnpyEMICinIRhBAAwGC0ECIQsgAkEkai8BACIAQQJHBEAgAkEYaikDACEpAn8gAEUEQCACQSZqLwEAIRAgAkE0aigCACEEIAJBMGooAgAhByACQSxqKAIAIQlBACELIAJBKGooAgAMAQsgAkEsaigCACEEQQEhC0EBIQkgAkEwaigCACIHBEAgB0EASA0QIAdBARDwCSIJRQ0TCyAJIAQgBxDgChogBwshEiACQSBqKAIAIQwLIANBQGsgAkEIahCHAyACQQRqKAIAIRQCQCACQThqIgAtAAAiBkELRgRAIANBCzoAUCADIAJBOWotAAA6AFEMAQsgBkEKRgRAIANBCjoAUCADIAJBPGooAgA2AlQMAQsgA0HQAGogABD+AgsCQCACQeQAai8BACIAQQJGBEAgA0ECOwF8DAELIAJB2ABqKQMAIScCfyAARQRAIAJB5gBqLwEAIQ8gAkH0AGooAgAhDiACQfAAaigCACEFIAJB7ABqKAIAIQZBACEAIAJB6ABqKAIADAELIAJB7ABqKAIAIQ9BASEAQQEhBiACQfAAaigCACIFBEAgBUEASA0QIAVBARDwCSIGRQ0NCyAGIA8gBRDgChogBQshDSADIA42AowBIAMgBTYCiAEgAyAGNgKEASADIA02AoABIAMgDzsBfiADIAA7AXwgAyAnNwNwIAMgAkHgAGooAgA2AngLIANBCGogGkEIaikDADcDACADQRBqIBpBEGopAwA3AwAgA0EYaiAaQRhqKQMANwMAIANBIGogGkEgaikDADcDACADIBopAwA3AwAgAygCVCIFQRB2IRkgBEEQdiEWIAlBEHYhDyACQQFqLQAAIR4gAykDQCInQiCIpyEXIAMoAmQhGyADKAJgIQogAygCXCEOIAMoAlghDSADKAJQIQYgAygCSCEAICenIRhBAQwFC0ECIQUgAkE8ai8BACIAQQJHBEAgAkEwaikDACEnAn8gAEUEQCACQT5qLwEAIRkgAkHMAGooAgAhGyACQcgAaigCACEKIAJBxABqKAIAIQ5BACEFIAJBQGsoAgAMAQsgAkHEAGooAgAhAEEBIQVBASEOIAJByABqKAIAIgoEQCAKQQBIDQ8gCkEBEPAJIg5FDRMLIA4gACAKEOAKGiAKCyENIAJBOGooAgAhBgsgAyACQSRqEIcDIAJBBGooAgAhFAJ/IAJBEGooAgBFBEAgKiEpICIhDEEADAELICEgAkEMahDpAiATIAJBGGoQ8QQgAyACQQhqKAIANgJQIAMoAlwhIyADKQNQISggAykDYCIpISogAygCaCIMISIgAygCWAshACADKAIIIglBEHYhDyAoQiCIpyEXICdCMIinIRYgJ0IgiKchBCADKAIEIRIgAy8BAiEQIAMvAQAhCyAnpyEHICMhCCAopyEYQQIMBAtBAiEFIAJBPGovAQAiAEECRwRAIAJBMGopAwAhJwJ/IABFBEAgAkE+ai8BACEZIAJBzABqKAIAIRsgAkHIAGooAgAhCiACQcQAaigCACEOQQAhBSACQUBrKAIADAELIAJBxABqKAIAIQBBASEFQQEhDiACQcgAaigCACIKBEAgCkEASA0OIApBARDwCSIORQ0SCyAOIAAgChDgChogCgshDSACQThqKAIAIQYLIAMgAkEkahCHAyACQQRqKAIAIRQCQCACQRBqKAIAIgxFBEBBACEAICQhCCArISkgJSEMDAELAkAgAkEUaigCACIIRQRAQQIhAEEAIQQMAQsgCEH/////A0sNDSAIQQF0IgRBAEgNDSAIQYCAgIAESUEBdCEHIAQEfyAEIAcQ8AkFIAcLIgBFDQsLIAAgDCAEEOAKGiATIAJBGGoQ8wMgAyAINgJUIAMgAkEI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AgAgEkEoaiAmNgIAIBJBJGogDTYCACASQSBqIAI2AgAMCAtB5PDEABD1A0H/AXEiAg0BDAYLQQIhAgtB6PDEACgCACACENAIRQ0EIANB+ABqIgBB6PDEACgCABCCCUHo8MQAKAIAIQ8gA0GAA2ogABDFCCADKAKAA0UNAiADQaAGaiICQRBqIANBgANqIgBBEGooAgA2AgAgAkEIaiAAQQhqKQMANwMAIAMgAykDgAM3A6AGIANBjANqQQE2AgAgAEEUakEANgIAIANB0O3BADYCiAMgA0GE58EANgKQAyADQQA2AoADIANB6AhqIANB+ABqEMUIIAMoAugIRQ0DIANBOGoiAEEQaiADQegIaiICQRBqKAIANgIAIABBCGogAkEIaikDADcDACADQeAGaiIMQRRqQdjtwQA2AgAgAyADKQPoCDcDOCADQYDqwQA2AugGIAxBEGogAjYCACADIA82AsgKIANBAjYCxAogAyAANgLsBiADIANBgANqNgLkBiADIANBoAZqNgLgBiADIANBCGo2AugIIAMgDDYCwApB6PDEACgCACADQcAKahD8CCADLQA0ISsMBAsgBCAmQaTjwgAQjQoACyAZICZBtOPCABCMCgALQbTpwQBBIkGI7sEAEJAKAAtBtOnBAEEiQYjuwQAQkAoACwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAICtBAWsOAgIBAAsgAyAGNgLQCiADIAQ2AswKIAMgDTYCyAogAyALNgLECiADIAU2AsAKIANBoAZqIh9BKGogA0EIaiIAQShqKQMANwMAIB9BIGogAEEgaikDADcDACAfQRhqIABBGGopAwA3AwAgH0EQaiAAQRBqKQMANwMAIB9BCGogAEEIaikDADcDACADIAMpAwg3A6AGIANBgANqIRBBACECIwBB8ANrIgkkACADQcAKaiITKAIQIRsgCUEQaiIAQQhqIgQgE0EIaikCADcDACAJIBs2AiAgCSATKQIANwMQIAlBwAJqIQFCACFPQQAhDyMAQaABayIKJAAgCkEwaiIFQRBqIABBEGooAgA2AgAgBUEIaiAEKQIANwMAIAogACkCADcDMCAKQegAaiAFEJECAkACQAJAIAooAmgiBUUEQCAKKQJsIlJC/wGDUCEAIFJCCEIgIAAbiKdB/wFxQQAgUkIgiKdBgH5xIAAb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IgAgAygC0AYgAygC2AYiAWtLBEAgA0HQBmogASAAEJwGIAMoAtgGIQELIAMoAtQGIAFqIAIgABDgChogAyAAIAFqIgA2AtgGIANB7AZqIgEgADYCACADQQA2AvAGIAMgADYC5AYgAyADKALUBiIANgLgBiADIAA2AugGIANBgANqIANB4AZqELgBAkAgAygCyAMiBUECRwRAIANByApqIgIgA0GAA2oiAEEkaikCADcDACADQdAKaiIGIABBLGopAgA3AwAgA0HYCmoiCyAAQTRqKQIANwMAIANB4ApqIgwgA0G8A2opAgA3AwAgA0HoCmoiDyADQcQDaigCADYCACADIAMpApwDNwPACiAAQRhqNQIAIU8gAygChAMgA0HoCGoiByADQcwDakHUARDgChogASACKQMANwIAIANB9AZqIAYpAwA3AgAgA0H8BmogCykDADcCACADQeAGaiIAQSRqIAwpAwA3AgAgAEEsaiAPKAIANgIAIAMgTz4C4AYgAyADKQPACjcC5AYgAyAFNgKQByAAQTRqIAdB1AEQ4AoaDQEgA0GAA2oiASADQeAGakGIAhDgChogA0H4AGohACABQThqKAIAIQUgAUE0aigCACELAkACQAJAAkAgASgCMEUEQAJAIAVFBEBBASEGDAELIAVBAE4iDEUNAyAFIAwQ8AkiBkUNBAsgACAFNgI0IABBOGogBjYCACAGIAsgBRDgChogAEE8aiAFNgIADAELIAFBPGooAgAhBiAAIAs2AjQgAEE8aiAGNgIAIABBOGogBTYCAAsgACABKQMANwMAIAAgASkCjAE3AowBIABBKGogAUEoaikDADcDACAAQSBqIAFBIGopAwA3AwAgAEEYaiABQRhqKQMANwMAIABBEGogAUEQaikDADcDACAAQQhqIAFBCGopAwA3AwAgAEGUAWogAUGUAWopAgA3AgAgAEGcAWogAUGcAWooAgA2AgAgAEGIAWogAUGIAWooAgA2AgAgACABKQOAATcDgAEgAEHwAGogAUHwAGooAgA2AgAgACABKQNoNwNoIAEpA0ghTyABKQNAIVAgASkDYCFRIABBoAFqIAFBoAFqQeQAEOAKGiAAQQE2AjAgACBRNwNgIAAgUDcDQCAAIE83A0ggACABKQJ0NwJ0IABB/ABqIAFB/ABqKAIANgIAIAAgASkDWDcDWCAAIAEpA1A3A1AMAgsQxwgACyAFIAxB8PTEACgCACIAQcoEIAAbEQAAAAsgAygCKCEBIAMoAtAGBEAgAygC1AYQ1AELIAMoApAGBEAgAygClAYQ1AELIAMoAogGENQBQQAhAAwLCyADKAKAAyEAIAMoAoQDIQEgEkEoaiADKAKIAzYCACASQSRqIAE2AgAgEkEDNgIYIBJBIGogASAAIABB/wFxQQZGIgAbNgIAIBJBDkELIAAbNgIcDAkLIBJCg4CAgIABNwMYIANB4AZqEKoFDAgLIAMgBjYC0AogAyAENgLMCiADIA02AsgKIAMgCzYCxAogAyAFNgLACiADQegIaiIAQShqIANBCGoiAUEoaikDADcDACAAQSBqIAFBIGopAwA3AwAgAEEYaiABQRhqKQMANwMAIABBEGogAUEQaikDADcDACAAQQhqIAFBCGopAwA3AwAgAyADKQMINwPoCCADQYADaiADQcAKaiAAEGwgAygCyAMiAkECRg0FIANBoAZqIgFBCGoiACADQaQDaiIFKQIANwMAIAFBEGoiBCADQawDaiIGKQIANwMAIAFBGGoiCyADQbQDaiIMKQIANwMAIAFBIGoiDyADQbwDaikCADcDACABQShqIgEgA0HEA2ooAgA2AgAgAyADKQKcAzcDoAYgA0GYA2ooAgAhDSADKAKEAyADQeAGaiIHIANBzANqQdQBEOAKGiADQYwDaiAAKQMANwIAIANBlANqIAQpAwA3AgAgA0GcA2ogCykDADcCACAFIA8pAwA3AgAgBiABKAIANgIAIAMgDTYCgAMgAyADKQOgBjcChAMgAyACNgKwAyAMIAdB1AEQ4AoaRQRAIAMoAowDIQEgAygCiAMhAiADKAKEAyEEIANB+ABqIANBkANqQfgBEOAKGgwJCyASQoOAgICAATcDGCADQYADahCqBQwKCyADQfgFaiADQYADaiIBQRBqKAIANgIAIAMgAykDiAM3A/AFIAMoAoQDIAMpApQDIU8gA0HoCGoiBSADQZwDakHkABDgChogA0HgBmoiBCADQYQEakHoARDgChogAyBPNwOAAyABQQhqIAVB5AAQ4AoaIAMgADYC7AMgA0HwA2ogBEHoARDgChpFDQUgEkKDgICAgAE3AxgCQCADKALABEUNACADQcQEaigCAEUNACADQcgEaigCABDUAQsCQAJAIAMoArAEDgMBAAEACyADQbQEaigCAEUNACADQbgEaigCABDUAQsgA0HgBGoQ/wcgAygC4AQEQCADQeQEaigCABDUAQsgAygC7AQEQCADQfAEaigCABDUAQsgA0HgA2oQ8QcgAygC4AMEQCADQeQDaigCABDUAQsgA0HABWoiABDxByAAKAIABEAgA0HEBWooAgAQ1AELIAMoAswFRQ0JIANB0AVqKAIAENQBDAkLIAUgAEGY7sEAEI4KAAsgACAGQZjuwQAQjQoACxDHCAALIAAgAUHw9MQAKAIAIgBBygQgABsRAAAACyADKAKAAyEAIAMoAoQDIQEgEkEoaiADKAKIAzYCACASQSRqIAE2AgAgEkEDNgIYIBJBIGogASAAIABB/wFxQQZGIgAbNgIAIBJBDkELIAAbNgIcDAQLIAMoApADIQEgAygCjAMhAiADKAKIAyEEIANB+ABqIANBlANqQYgCEOAKGiADQfAAaiADQdQFaigCADYCACADQegAaiADQcwFaikCADcDACADQeAAaiADQcQFaikCADcDACADQdgAaiADQbwFaikCADcDACADQdAAaiADQbQFaikCADcDACADQcgAaiADQawFaikCADcDACADQUBrIANBpAVqKQIANwMAIAMgAykCnAU3AzggT0IgiKchDSBPpyEADAELIAMoAtAGRQ0BIAMoAtQGENQBDAELIBIgATYCLCASIAI2AiggEiAENgIkIBIgDTYCICASIAA2AhwgEiAZNgIQIBIgJjYCDCASIEU2AgggEiBENgIEIBIgMjYCACASQTBqIANB+ABqQYgCEOAKGiASICs2AhggEkHwAmogA0HwAGooAgA2AgAgEkHoAmogA0HoAGopAwA3AgAgEkHgAmogA0HgAGopAwA3AgAgEkHYAmogA0HYAGopAwA3AgAgEkHQAmogA0HQAGopAwA3AgAgEkHIAmogA0HIAGopAwA3AgAgEkHAAmogA0FAaykDADcCACASIAMpAzg3ArgCDAELIAMoApAGBEAgAygClAYQ1AELIAMoAogGENQBCyADQfAKaiQAC4EcAQ1/IwBBkCxrIgskACALQQhqQQBBhAEQ4goaIAtBjAFqQQBBhAEQ4goaAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBEUEQCALQZACakEA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CyADLQCrAUEYRw0BIAMoApQBIgcoAgAhASAHIAFBAWs2AgAgAUEBRw0BIAoQrggMAQsgAyADNQKoATcDmAEgA0IBNwOQASAIIQEgBAwBCyADQgA3A5ABIAMoAnAhASADKAJsIQdBAAsQhgIgASAHRw0ACwsgA0G1AWpCADcAACADQb8BaiADQeIBai0AADoAACADQgA3A7ABIANBADYCqAEgA0Gcs8IANgKkASADQQA2AqABIANCADcDkAEgAyADLwDgATsAvQEgA0HwAWogA0GQAWoQgQICQAJ/AkACQAJAAkACQAJAIAMoAvABIgFBAkcEQCADQdABaiEHA0AgAykD+AEhISABDQIgAyADKQOAAjcD0AEgAyAhNwPIASADQTBqQQAgByAhUBsQhgIgA0HwAWogA0GQAWoQgQIgAygC8AEiAUECRw0ACwsCQCADKAKgAUUNACADKAKkAUUNACADKAKoARDUAQsgA0GQAWoiAUEYaiADQTBqIgdBGGopAwA3AwAgAUEQaiAHQRBqKQMANwMAIAFBCGogB0EIaikDADcDACADIAMpAzA3A5ABIANBEGogARDAAiAUrSADKAIUIBRqrUIghoQhIQwBCyADKAL0ASEBAkAgAygCoAFFDQAgAygCpAFFDQAgAygCqAEQ1AELAkAgAygCMEEDRw0AIAMoAjRFDQAgA0E4aigCABDUAQsgAUH/AXFBCEcNAQsgAyASNgKcASADIAY2ApgBIAMgCTYClAEgAyAPNgKQASADQTBqIQogA0GQAWohBCMAQeABayIIJAACQCATKAIEIgEgEygCACIHTwRAIAFFBEAgAigCCCETIAhBIGogASAHazYCACAIQRxqIAdBnLPCAGo2AgAgCEEoakIANwMAIAhBLWpCADcAACAIQQA2AhggCEIANwMIIAhCADcDOCAIQQA2AlggCCACNgJcIAhCADcDYCAIQQA2AkAMAgsgAUEAQayRwQAQjQoACyAHIAFBrJHBABCOCgALIAhB8ABqIARBCGopAgAiIjcDACAIIAQpAgA3A2gCQCAipyIBIAgoAmwiFEYNACAIQfgAakEEciEEA0AgCCABQdgAaiIHNgJwIAgoAnQhDSAIIAgoAmg2AtwBIAggDTYC2AEgCCABQQhqNgLUASAIIAE2AtABIAhB+ABqIAhB0AFqEJ4EIAgoAngi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IB83AgQgBSAJOgAAAkACQAJAIAYtAAAOCQABBAQEBAQEAgQLIAYoAgRFDQMgBkEIaigCABDUAQwDCyAGQRtqLQAAQRhHDQIgBkEEaiIGKAIAIgcoAgAhBSAHIAVBAWs2AgAgBUEBRw0CIAYQrggMAgsgBigCBEUNASAGQQhqKAIAENQBDAELAkACQAJAIAMtAAgOCQABAwMDAwMDAgMLIAMoAgxFDQIgA0EQaigCABDUAQwCCyADQSNqLQAAQRhHDQEgAygCDCIGKAIAIQUgBiAFQQFrNgIAIAVBAUcNASADQQhqQQRyEK4IDAELIAMoAgxFDQAgA0EQaigCABDUAQsgA0GwAWokACAELQC4ASIDQRNGDQggAEEJaiAEKQC5ATcAACAAQShqIARB2AFqKQAANwAAIABBIWogBEG4AWoiAUEZaikAADcAACAAQRlqIAFBEWopAAA3AAAgAEERaiABQQlqKQAANwAAIABBBDYCACAAIAM6AAgMBgsgBEH/AWoiASAEQbgBaiICQRBqKAAANgAAIARB+AFqIgUgAkEJaikAADcDACAEQdgAaiICQQhqIgYgC0EIaikAADcDACACQRBqIgIgC0EQai8AADsBACAEIAQpALkBIh83A/ABIAQgCykAADcDWCAELwHMASEKIABBGGogASgAADYAACAAQRFqIAUpAwA3AAAgAEEJaiAfNwAAIABBHGogCjsBACAAIAM6AAggAEEENgIAIABBHmogBCkDWDcAACAAQSZqIAYpAwA3AAAgAEEuaiACLwEAOwAADAULQYzEwABBK0GkxcAAEJ4IAAtBjMTAAEErQdTFwAAQnggAC0GMxMAAQStBhMXAABCeCAALQYzEwABBK0G0xcAAEJ4IAAsgFyASKQAANwAAIBdBCGoiBSASQQhqKAAANgAAIAogC0EIaikAACIfNwMAIARB6ABqIAtBEGovAAAiAzsBACAUIAM7AQAgESAfNwMAIAQgCykAACIfNwNYIAQvAcwBIQMgBEGoAmogBSgAADYCACAEIB83A0AgBCAXKQAANwOgAiADQQNGDQIgFiAEKQNANwEAIARB8AFqIgVBCGogBEGoAmooAgA2AgAgFkEIaiARKQMANwEAIBZBEGogFC8BADsBACAEIAQpA6ACNwPwASAEIAM7AfwBIARBADYCWCAEIAg2AmAgBCAI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ACADQQxqIgItAAAhBiACIARBDGoiAi0AADoAACACIAY6AAAgA0ENaiICLQAAIQYgAiAEQQ1qIgItAAA6AAAgAiAGOgAAIANBDmoiAi0AACEGIAIgBEEOaiICLQAAOgAAIAIgBjoAACADQQ9qIgItAAAhBiACIARBD2oiAi0AADoAACACIAY6AAAgA0EQaiICLQAAIQYgAiAEQRBqIgItAAA6AAAgAiAGOgAAIANBEWoiAi0AACEGIAIgBEERaiICLQAAOgAAIAIgBjoAACADQRJqIgItAAAhBiACIARBEmoiAi0AADoAACACIAY6AAAgA0ETaiICLQAAIQYgAiAEQRNqIgItAAA6AAAgAiAGOgAAIANBFGoiAi0AACEGIAIgBEEUaiICLQAAOgAAIAIgBjoAACADQRVqIgItAAAhBiACIARBFWoiAi0AADoAACACIAY6AAAgA0EWaiICLQAAIQYgAiAEQRZqIgItAAA6AAAgAiAGOgAAIANBF2oiAi0AACEGIAIgBEEXaiICLQAAOgAAIAIgBjoAACADQRhqIgItAAAhBiACIARBGGoiAi0AADoAACACIAY6AAAgA0EZaiICLQAAIQYgAiAEQRlqIgItAAA6AAAgAiAGOgAAIANBGmoiAi0AACEGIAIgBEEaaiICLQAAOgAAIAIgBjoAACADQRtqIgItAAAhBiACIARBG2oiAi0AADoAACACIAY6AAAgA0EcaiICLQAAIQYgAiAEQRxqIgItAAA6AAAgAiAGOgAAIANBHWoiAi0AACEGIAIgBEEdaiICLQAAOgAAIAIgBjoAACADQR5qIgItAAAhBiACIARBHmoiAi0AADoAACACIAY6AAAgA0EfaiICLQAAIQYgAiAEQR9qIgItAAA6AAAgAiAGOgAAIANBIGohAyAEQSBrIQQgCkEBayIKDQALDAILIAUgB0GY9cIAEI4KAAsgByABQZj1wgAQjQoACyAFRQRAIAUhAgwBCyAJQQlLBEAgBSECDAELAkAgASAHTwRAIAAgBUEFdGohBgNAIAcgBUEBayICSQ0CAkAgByACayIJQQFNDQAgACACQQV0aiILQSBqIgMgC0EgEOEKQQBODQAgCykAACEYIAsgAykAADcAACAIQRBqIgRBGGoiDCALQRhqIgopAAA3AwAgBEEQaiIOIAtBEGoiDykAADcDACAE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ACADQagBaiIEQRRqQciewQA2AgAgAyADKQOIAjcD8AEgA0GkmsEANgKwASADIAU2AogBIANBAjYChAEgBEEQaiADQfwAajYCACADIAE2ArQBIAMgA0HYAWo2AqwBIAMgA0HAAWo2AqgBIAMgBDYCgAFBtO/EACgCACADQYABahD8CAwBCyADLQAAQQJGDQ9B2PPEACgCAEEFRg0AAkACQAJAQazvxAAtAAAiBA4DAwIAAQtBAiEEDAELQaTvxAAQ9QNB/wFxIgRFDQELQajvxAAoAgAgBBDQCEUNACADQZABaiIBQajvxAAoAgAQgglBqO/EACgCACEGIANB2AFqIAEQxQggAygC2AFFDQ0gA0HAAWoiBEEQaiADQdgBaiIBQRBqKAIANgIAIARBCGogAUEIaikDADcDACADIAMpA9gBNwPAASADQeQBakEBNgIAIAFBFGpBADYCACADQYSfwQA2AuABIANB1JbBADYC6AEgA0EANgLYASADQYgCaiADQZABahDFCCADKAKIAkUNDiADQfABaiIBQRBqIANBiAJqIgRBEGooAgA2AgAgAUEIaiAEQQhqKQMANwMAIANBqAFqIgVBFGpBjJ/BADYCACADIAMpA4gCNwPwASADQaSawQA2ArABIAMgBjYCiAEgA0ECNgKEASAFQRBqIAQ2AgAgAyABNgK0ASADIANB2AFqNgKsASADIANBwAFqNgKoASADIAU2AoABIAMgAzYCiAJBqO/EACgCACADQYABahD8CAsgAy0AAA4JAwQGBgYGBgYFBgtBAiEEDA4LIAAgAykCDDcCDCAAQRRqIANBFGopAgA3AgAgAEEcaiADQRxqKQIANwIAIABBJGogA0EkaigCADYCACADKQIEIREgAEECNgJAIAAgETcCBCAAIAQ2AgAMEAsgA0H4AGogAy8BBjsBACADQegAaiAJKQMANwMAIAMgAygBAjYCdCADIAMpAxA3A2AgAy0AASEEIAMtAAAhBiADKQMIIREMDQsgAygCBEUNAiADQQhqKAIAENQBDAILIANBG2otAABBGEcNASADKAIEIgQoAgAhASAEIAFBAWs2AgAgAUEBRw0BIANBBHIQrggMAQsgAygCBEUNACADQQhqKAIAENQBCyADQdwAaiADQfgAai8BACIBOwEAIANB0ABqIANB6ABqKQMAIhE3AwAg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KAIgIgsEQCADKAIkIQ8gAyALNgIsIAMgDzYCMCADIA82AiggA0EBOwFcIANBLzYCWCADQoGAgIDwBTcDUCADIA82AkwgA0EANgJIIAMgDzYCRCADIAs2AkAgAyAPNgI8IANBADYCOCADQRhqIANBOGoQ/wICQCADKAIYIgYEQCADKAIcIgcNAUECIQogA0HSAmpBg4TAAC0AADoAACADQYGEwAAvAAA7AdACDAMLQfiCwAAhBgsgA0HwAWogAUGAAWogBiAHEJwBIAMpA/ABUARAIANBsgJqIANB+wFqLQAAIgs6AAAgAyADLwD5ASIGOwFwIAMgBjsBsAIgA0H8AWooAgAhBSADQYACaigCACEMIANBhAJqKAIAIQogA0GIAmooAgAhCCADQYwCaigCACEEIANBkAJqKQMAIR0gA0GYAmotAAAhCSADLQD4ASEHIANB0gJqIAs6AAAgAyAGOwHQAgwCCyADQfIAaiADQfsBai0AACIBOgAAIANBsgJqIgYgAToAACADIANB+QFqLwAAIgE7AXAgAyADQZkCaigAADYCoAEgAyADQZwCaigAADYAowEgA0GYAmotAAAhCSADQfwBaikCACEdIANBhAJqKQIAIR4gA0GMAmooAgAhCCADQZACaikDACEfIAMtAPgBIQQgACADKQKgATcAKSADIAE7AbACIABBMGogA0GnAWopAAA3AAAgACAEOgAIIAAgHzcCICAAIAg2AhwgACAeNwIUIAAgHTcCDCAAIAk6ACggAEECNgIAIAAgAy8BsAI7AAkgAEELaiAGLQAAOgAAIA8EQCALENQBCyACQYQBSQ0EDAMLIABBADYCAAwBCyADQeYAaiADQdICai0AACIGOgAAIAMgAy8B0AIiCzsBZCADQe4AaiIVIAY6AAAgAyALOwFsIANB8ABqIgZBIGogA0E4aiILQSBqKQMANwMAIAZBGGogC0EYaikDADcDACAGQRBqIAtBEGopAwA3AwAgBkEIaiALQQhqKQMANwMAIAMgAykDODcDcCADQQA2ApgBIANBEGogBhD/AgJAAkACQAJAAkACfwJAAkACQAJAAkAgAygCECIURQ0AIANBoAFqIgtBAXIhFiADQfABaiINQS5qIREgC0EuaiESIAMoAhQhBiABQYABaiEaIA1BAXIhFyADQbACakEBciEYIAtBIWoh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IANBADYC2AYgAyACNgLUBiADIAE2AtAGIAMgAjYCzAYgAyABNgLIBiADQegCaiADQcgGahBtAkACQAJAAkAgAygCgAMiAUEDRgRAQRxBBBDwCSIBRQ0BIAEgAykChAM3AgAgAUEYaiADQZwDaigCADYCACABQRBqIANBlANqKQIANwIAIAFBCGogA0GMA2opAgA3AgAgAEECNgIwIABBrJ/CADYCCCAAIAE2AgQgAEEANgIADAMLIAMoAuwCIANBCGoiBSADQYQDakHcAhDgChogAyABNgLoAiADQegCakEEciAFQdwCEOAKGkUNASAAQQI2AjAgAEEBNgIAIANB6AJqEIUDDAILQRxBBEHw9MQAKAIAIgBBygQgABsRAAAACwJAAkACQAJAAkACQAJAAkACQCABQQFrDgIAAQILIANB0ANqKQMAIQ8gA0HMA2ooAgAhCSADQcgDaigCACEGIANBxANqKAIAIQggA0HAA2ooAgAhDCADQbgDaikDACEQIANBsANqKQMAIREgA0GoA2ooAgAhASADQaQDaigCACEFAn8gA0GgA2ooAgBFBEACQCABRQRAQQEhAgwBCyABQQBOIgdFDQUgASAHEPAJIgJFDQYLIAIgBSABEOAKGiABDAELIAEhAiAFIQEgA0GsA2ooAgALIQUgA0EANgKUBiADQQhqIgdBKGogA0HwAmoiBEEoaikDADcDACAHQSBqIARBIGopAwA3AwAgB0EYaiAEQRhqKQMANwMAIAdBEGogBEEQaikDADcDACAHQQhqIARBCGopAwA3AwAgAyAPNwNoIAMgCTYCZCADIAY2AmAgAyAINgJcIAMgDDYCWCADIBA3A1AgAyARNwNIIAMgBTYCRCADIAI2AkAgAyABNgI8IANBATYCOCADIAQpAwA3AwggA0H4AGogA0HYA2oiAkEIaigCADYCACADQYQBaiADQeQDaiIFQQhqKAIANgIAIANBkAFqIANB8ANqIgRBCGooAgA2AgAgA0GcAWogA0H8A2oiAUEIaikCADcCACADQaQBaiABQRBqKAIANgIAIAMgAikDADcDcCADIAUpAgA3AnwgAyAEKQMANwOIASADIAEpAgA3ApQBIANBqAFqIANBkARqQeQAEOAKGiADQcgGaiAHIANBlAZqENwBIAMoAvgGIgVBAkcEQCADQZgGaiICQShqIgcgA0HIBmoiAUEoaikDADcDACACQSBqIgQgAUEgaikDADcDACACQRhqIgkgAUEYaikDADcDACACQRBqIgYgAUEQaikDADcDACACQQhqIgIgAUEIaikDADcDACADIAMpA8gGNwOYBiAAQTRqIAFBNGpB1AEQ4AoaIANB4AVqIgFBKGogBykDACIPNwMAIAFBIGogBCkDACIQNwMAIAFBGGogCSkDACIRNwMAIAFBEGogBikDACISNwMAIAFBCGogAikDACITNwMAIAMgAykDmAYiFDcD4AUgAygClAYhASAAQShqIA83AwAgAEEgaiAQNwMAIABBGGogETcDACAAQRBqIBI3AwAgAEEIaiATNwMAIAAgFDcDACAAQQI2AowCIAAgATYCiAIgACAFNgIwDAkLIANB4AVqIgFBCGogA0HIBmoiAkEIaikDADcDACABQRBqIAJBEGopAwA3AwAgAyADKQPIBjcD4AVBGEEEEPAJIgFFDQkgASADKQPgBTcCACAAQQI2AjAgAEHon8IANgIIIAAgATYCBCAAQQA2AgAgAUEQaiADQeAFaiIAQRBqKQMANwIAIAFBCGogAEEIaikDADcCAAwICyADKAL8AiEMIAMoAvgCIQYgAygC9AIhAiADKALwAiEHIAMoAuwCIQggA0HgA2opAwAhDyADQdwDaigCACEKIANB2ANqKAIAIQsgA0HUA2ooAgAhDSADQdADaigCACEOIANByANqKQMAIRAgA0HAA2opAwAhESADQbgDaigCACEBIANBtANqKAIAIQkCQCADQbADaigCAEUEQAJAIAFFBEBBASEEDAELIAFBAE4iBUUNBCABIAUQ8AkiBEUNBgsgBCAJIAEQ4AoaIAEhCQwBCyABIQQgA0G8A2ooAgAhAQsCQCAIRQRAAkAgAkUEQEEBIQUMAQsgAkEATiIGRQ0EIAIgBhDwCSIFRQ0HCyAFIAcgAhDgChogAiEHDAELIAIhBSAGIQILIANBADYClAYgA0EIaiIGQShqIANBgANqIghBKGopAwA3AwAgBkEgaiAIQSBqKQMANwMAIAZBGGogCEEYaikDADcDACAGQRBqIAhBEGopAwA3AwAgBkEIaiAIQQhqKQMANwMAIAMgDzcDaCADIAo2AmQgAyALNgJgIAMgDTYCXCADIA42AlggAyAQNwNQIAMgETcDSCADIAE2AkQgAyAENgJAIAMgCTYCPCADQQE2AjggAyAIKQMANwMIIANB+ABqIANB6ANqIgRBCGooAgA2AgAgA0GEAWogA0H0A2oiCUEIaigCADYCACADQZABaiADQYAEaiIIQQhqKAIANgIAIANBnAFqIANBjARqIgFBCGopAgA3AgAgA0GkAWogAUEQaigCADYCACADIAQpAwA3A3AgAyAJKQIANwJ8IAMgCCkDADcDiAEgAyABKQIANwKUASADQagBaiADQaAEakHkABDgChogA0HIBmogBiADQZQGahDcASADKAL4BiIJQQJHDQUgA0HgBWoiAUEIaiADQcgGaiICQQhqKQMANwMAIAFBEGogAkEQaikDADcDACADIAMpA8gGNwPgBSAHBEAgBRDUAQtBGEEEEPAJIgFFDQYgASADKQPgBTcCACAAQQI2AjAgAEHon8IANgIIIAAgATYCBCAAQQA2AgAgAUEQaiADQeAFaiIAQRBqKQMANwIAIAFBCGogAEEIaikDADcCAAwHCyAAQQI2AjAgAEECNgIAIANB6AJqEIUDDAYLEMcIAAsgASAHQfD0xAAoAgAiAEHKBCAAGxEAAAALIAEgBUHw9MQAKAIAIgBBygQgABsRAAAACyACIAZB8PTEACgCACIAQcoEIAAbEQAAAAsgA0GYBmoiBEEoaiIGIANByAZqIgFBKGopAwA3AwAgBEEgaiIIIAFBIGopAwA3AwAgBEEYaiIKIAFBGGopAwA3AwAgBEEQaiILIAFBEGopAwA3AwAgBEEIaiIEIAFBCGopAwA3AwAgAyADKQPIBjcDmAYgAEE0aiABQTRqQdQBEOAKGiADQeAFaiIBQQhqIg0gBCkDADcDACABQRBqIgQgCykDADcDACABQRhqIgsgCikDADcDACABQSBqIgogCCkDADcDACABQShqIgEgBikDADcDACADIAMpA5gGNwPgBSAAIAw2ApwCIAAgAjYCmAIgACAFNgKUAiAAIAc2ApACIAMoApQGIQIgAEEBNgKMAiAAIAI2AogCIAAgCTYCMCAAQShqIAEpAwA3AwAgAEEgaiAKKQMANwMAIABBGGogCykDADcDACAAQRBqIAQpAwA3AwAgAEEIaiANKQMANwMAIAAgAykD4AU3AwAMAQsMAQsgA0HQCGokAA8LQRhBBEHw9MQAKAIAIgBBygQg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AAAgACAFNgIECyAIQYADaiQADwsgCSAQQfD0xAAoAgAiAEHKBCAAGxEAAAAL4x0CDX8FfiMAQYABayICJAAgAkE4aiABEIECQgIhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIoAjhBAWsOAgECAAsgAkHIAGopAwAhESACKQNAIQ8MAQsgAigCPCEEIAIgAkFAaykDADcCPCACIAQ2AjggAkHgAGpBvKXCAEEFIAJBOGoQpgQgAikDYCEPIAIoAnAiAw0BIAIpA2ghEQsgD0J9g1AEQCACQThqIAFB6ABqEIACAkACQAJAIAIoAjgiC0EBaw4CAQACCyACQQI2AggMCgsgAkEUaiACQcQAaigCADYCACACIAIpAjw3AgwgAkEBNgIIDAkLIAIpA0BQDQcgAUGYAWoiAykDACIRIAJByABqKQMAIg98IhBCP4dCgICAgICAgICAf4UgECAPQgBTIBAgEVNzGyEPIAMgDzcDACACQgE3AxAgAkEANgIIIAIgDzcDGAwICyACQeAAaiABQegAakHBpcIAQQMQkgQCQCACKAJwRQRAIAIpA2AiD0IAUwRAIAJBADYCECACQoCAgIAQNwMIIAJBOGoiBEEDOgAgIARCgICAgIAENwIYIARBADYCECAEQQA2AgggBEG0mMIANgIEIAQgAkEIajYCACAEENsKDQ4gAkEgakHBpcIAQQMgAkEIahDPBQwCCyACQQA2AjAgAiAPNwMgDAELIAJBIGoiDkEQaiACQeAAaiIEQRBqKQMANwMAIA5BCGogBEEIaikDADcDACACIAIpA2A3AyALIAIpAyAhDyACKAIwIgMNASACQeAAaiABQaABakHEpcIAQQYQkgQCQCACKAJwRQRAIAIpA2AiEEIAUwRAIAJBADYCECACQoCAgIAQNwMIIAJBOGoiBEEDOgAgIARCgICAgIAENwIYIARBADYCECAEQQA2AgggBEG0mMIANgIEIAQgAkEIajYCACAEENsKDQ4gAkEgakHBpcIAQQMgAkEIahDPBQwCCyACQQA2AjAgAiAQNwMgDAELIAJBIGoiDkEQaiACQeAAaiIEQRBqKQMANwMAIA5BCGogBEEIaikDADcDACACIAIpA2A3AyALIAIoAjAiAw0CIAIoAiQhDSACKAIgIQ4gAkE4aiABQdgBakHKpcIA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H0YNASAJRQ0IAkAgACIDKAIwRQRAIAEgCGoiAEE0aigCACEKIABBOGooAgAhDkEAIRQMAQsgASAIaiIFQThqKAIAIQBBASEUQQEhDiAFQTxqKAIAIgoEQCAKQQBIDQggCkEBEPAJIg5FDQULIA4gACAKEOAKGiAKISALIARBMGoiAEEIaiIVIANBCGopAgA3AwAgAEEQaiIWIANBEGopAgA3AwAgAEEYaiIXIANBGGopAgA3AwAgBCADKQIANwMwIANB+ABqKAIAIQIgAygCKCEhIAMoAiQhIiADLQAsISMgAygCICEkAkAgA0H8AGooAgAiDUUEQEEBIQtBACEGDAELIA1B////H0sNByANQQV0IgZBAEgNByANQYCAgCBJIQUgBgR/IAYgBRDwCQUgBQsiC0UNBQsgCyACIAYQ4AohJQJ/IAMvAYwBRQRAIAEgCGoiAEGOAWovAQAhJiAAQZwBaigCACEnIABBlAFqKAIAIQsgAEGQAWooAgAhBkEAIRggAEGYAWooAgAMAQsgASAIaiIFQZQBaigCACEAQQEhGEEBIQsgBUGYAWooAgAiBgRAIAZBAEgNCCAGQQEQ8AkiC0UNBwsgCyAAIAYQ4AoaIAYLIQUgBEHQAGogA0GAAWoQhQQgAykDSCFIIAMpA2AhSSADKQNAIUpBACEZQQAhGiADQewAaigCAARAIARBEGogASAIakHoAGoQygcgBCgCGCEoIAQoAhQhGiAEKAIQIRsLIANB8AFqKAIABEAgASAIaiIAQYACaigCACEpIABB/AFqKAIAISogAEH4AWooAgAhK0EBIRkgAEH0AWooAgAhHAsgA0HcAGooAgAhLCADQdQAaigCACEtIANB7AFqKAIAIS4gA0HoAWooAgAhLyADQeQBaigCACEwIANB4AFqKAIAITEgA0HcAWooAgAhMiADQdgBaigCACEzIANBrAFqKAIAITQgA0GoAWooAgAhNSADQaQBaigCACE2IANB1AFqKAIAITcgA0HQAWooAgAhOCADQcwBaigCACE5IANByAFqKAIAITogA0HEAWooAgAhOyADQcABaigCACE8IANBvAFqKAIAIT0gA0G4AWooAgAhPiADQbQBaigCACE/IANBsAFqKAIAIUAgAygCWCFBIAMoAlAhQiADKAKgASFDIARBEGoiAEEYaiJEIBcpAwA3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ASEYQQEhCyAFQZgBaigCACIGBEAgBkEASA0IIAZBARDwCSILRQ0HCyALIAAgBhDgChogBgshBSAEQdAAaiADQYABahCIBCADKQNIIUggAykDYCFJIAMpA0AhSkEAIRlBACEaIANB7ABqKAIABEAgBEEQaiABIAhqQegAahDKByAEKAIYISggBCgCFCEaIAQoAhAhGwsgA0HwAWooAgAEQCABIAhqIgBBgAJqKAIAISkgAEH8AWooAgAhKiAAQfgBaigCACErQQEhGSAAQfQBaigCACEcCyADQdwAaigCACEsIANB1ABqKAIAIS0gA0HsAWooAgAhLiADQegBaigCACEvIANB5AFqKAIAITAgA0HgAWooAgAhMSADQdwBaigCACEyIANB2AFqKAIAITMgA0GsAWooAgAhNCADQagBaigCACE1IANBpAFqKAIAITYgA0HUAWooAgAhNyADQdABaigCACE4IANBzAFqKAIAITkgA0HIAWooAgAhOiADQcQBaigCACE7IANBwAFqKAIAITwgA0G8AWooAgAhPSADQbgBaigCACE+IANBtAFqKAIAIT8gA0GwAWooAgAhQCADKAJYIUEgAygCUCFCIAMoAqABIUMgBEEQaiIAQRhqIkQgFykDADcDACAAQRBqIkUgFikDADcDACAAQQhqIkYgFSkDADcDACAEQQhqIgIgBEHYAGoiHSgCADYCACAEIAQpAzA3AxAgBCAEKQNQNwMAQQIhDwJAAkACQEEBIAMoAowCIgBBAmsgAEEBTRtBAWsOAgABAgsgASAIaiIQQZwCaigCACFHIABFBEAgEEGQAmooAgAhHiAQQZQCaigCACERQQAhDwwCCyAQQZQCaigCACEAQQEhD0EBIREgEEGYAmooAgAiDARAIAxBAEgNCSAMQQEQ8AkiEUUNCgsgESAAIAwQ4AoaIAwhHgwBC0EEIQ8LIANBoAJqIQAgFSBGKQMAIks3AwAgFiBFKQMAIkw3AwAgFyBEKQMAIk03AwAgHSACKAIANgIAIAQgBCkDECJONwMwIAQgBCkDADcDUCADKAKIAiEDIAEgE2oiAkEYaiBNNwMAIAJBEGogTDcDACACQQhqIEs3AwAgAiBONwMAIAJB/ABqIA02AgAgAkH4AGogJTYCACACQfQAaiANNgIAIAJB8ABqICg2AgAgAkHsAGogGjYC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KAIANgIAIAcgBSkCADcDgAEgB0GwAWoiCEEIaiABQZgBaiAGKAIgIAZBJGooAgAQlgUgByALNwOwASACIAEgAyAEIAgQpQMMBwsgAUGYAWogB0EYahCjBUH/AXEiA0EERg0EIAcgAzoAsAEgB0GwAWotAABBAU0NBSAFKAIAIQggBSgCBCIEDQICQAJAIANBAmsOAgABBQsgB0FAayIDIAYQ3wYgA0EgaiIKIAFBmAFqIAYoAiAgBkEkaigCABCWBSAHQYABaiIJQRhqIAdBIGoiBEEYaikDADcDACAJQRBqIARBEGopAwA3AwAgCUEIaiAEQQhqKQMANwMAIAcgBykDIDcDgAEgB0GwAWoiBEE4aiADQThqKQMANwMAIARBMGogA0EwaikDADcDACAEQShqIANBKGopAwA3AwAgBEEgaiAKKQMANwMAIARBGGogA0EYaikDADcDACAEQRBqIANBEGopAwA3AwAgBEEIaiADQQhqKQMANwMAIAcgBykDQDcDsAEgAiABIAkgCCAEEMgBDAcLIAItAA0EQCAHQbABaiIDQRhqIAdBIGoiBEEYaikDADcDACADQRBqIARBEGopAwA3AwAgA0EIaiAEQQhqKQMANwMAIAcgBykDIDcDsAEgB0EQaiAGEIkIIAIgASADIAggBygCECAHKAIUEIoBDAcLIAdBQGsiAyAGEN8GIANBIGoiCiABQZgBaiAGKAIgIAZBJGooAgAQlgUgB0GAAWoiCUEYaiAHQSBqIgRBGGopAwA3AwAgCUEQaiAEQRBqKQMANwMAIAlBCGogBEEIaikDADcDACAHIAcpAyA3A4ABIAdBsAFqIgRBOGogA0E4aikDADcDACAEQTBqIANBMGopAwA3AwAgBEEoaiADQShqKQMANwMAIARBIGogCikDADcDACAEQRhqIANBGGopAwA3AwAgBEEQaiADQRBqKQMANwMAIARBCGogA0EIaikDADcDACAHIAcpA0A3A7ABIAIgASAJIAggBBDIAQwGCyAFKAIAIQQgBSgCBCIIBEAgBSgCCCEKIAdBsAFqIgNBGGogB0EgaiIJQRhqKQMANwMAIANBEGogCUEQaikDADcDACADQQhqIAlBCGopAwA3AwAgByAHKQMgNwOwASACIAEgAyAIIAoQtQMgBEUNBiAIENQBDAYLIAdBsAFqIgNBGGogB0EgaiIIQRhqKQMANwMAIANBEGogCEEQaikDADcDACADQQhqIAhBCGopAwA3AwAgByAHKQMgNwOwASACIAEgAyAEQQEQqwIMBQsgB0FAayIDIAYQ3wYgA0EgaiIJIAFBmAFqIAYoAiAgBkEkaigCABCWBSAHQYABaiIIQRhqIAdBIGoiBEEYaikDADcDACAIQRBqIARBEGopAwA3AwAgCEEIaiAEQQhqKQMANwMAIAcgBykDIDcDgAEgB0GgAWoiCkEIaiAFQQhqKAIANgIAIAcgBSkCADcDoAEgB0GwAWoiBEE4aiADQThqKQMANwMAIARBMGogA0EwaikDADcDACAEQShqIANBKGopAwA3AwAgBEEgaiAJKQMANwMAIARBGGogA0EYaikDADcDACAEQRBqIANBEGopAwA3AwAgBEEIaiADQQhqKQMANwMAIAcgBykDQDcDsAEgAiABIAggCiAEEPUBDAQLIAhFDQAgBBDUAQsgBy8BLCIBQQNxQQNHQQAgAUEBaxsNAiAHQTBqKAIARQ0CIAdBNGooAgAQ1AEMAgtBiKrAAEErQdyrwAAQnggAC0GYq8AAQTFBzKvAABCeCAALIAcoAhwhBCAHKAIYIQMLIAdBsAFqIAZB0AAQ4AoaIABBPGooAgAiBiAAKAI0RgRAIABBNGogBhCGBiAAKAI8IQYLIABBOGooAgAgBkHYAGxqIgEgBDYCBCABIAM2AgAgAUEIaiAHQbABakHQABDgChogACAAKAI8QQFqNgI8AkAgAg0AIAVBBGooAgAiAEUNACAFKAIARQ0AIAAQ1AELIAdBgAJqJAALqhACDX8FfiMAQdACayIEJAAgBCACNgIMAkBB2PPEACgCACINQQNPDQACQAJAAkACQAJAQdjzxAAoAgBBAksNAAJAAkACQEHE8sQALQAAIgIOAwMCAAELQQIhAgwBC0G88sQAEPUDQf8BcSICRQ0BC0HA8sQAKAIAIAIQ0AgNAQsgBEEANgJQIARCADcDQAwBCyAEQUBrIgVBwPLEACgCACICEIIJIARB2AFqIAUQxQggBCgC2AFFDQEgBEEoaiIFQRBqIARB2AFqIgZBEGoiBygCADYCACAFQQhqIAZBCGopAwA3AwAgBCAEKQPYATcDKCAEIARBDGo2AjwgBEEQaiAEQUBrEMUIIAQoAhBFDQIgBEHAAWoiBUEQaiAEQRBqIgZBEGooAgA2AgAgBUEIaiAGQQhqKQMANwMAIARB7AFqQeSFwwA2AgAgBCAEKQMQNwPAASAEQdSFwwA2AuABIAQgAjYCuAEgBEECNgK0ASAHIAY2AgAgBCADNgIQIAQgBTYC5AEgBCAEQTxqNgLcASAEIARBKGo2AtgBIAQgBEHYAWo2ArABIARBQGsgAiAEQbABahDtCAsgBEEQaiICQRBqIARBQGsiBUEQaikDADcDACACQQhqIgIgBUEIaikDADcDACAEIAQpA0AiETcDECARUA0CIAIoAgAgAigCBCICKAIIQQdqQXhxaiAEQRBqIAIoAjARAAAMAgtB3P/CAEEiQfSFwwAQkAoAC0Hc/8IAQSJB9IXDABCQCgALIAMtAABBCkYEQCADLQABIQYgA0EkaigCACIIIAMoAiAiB0GVlYi5AmxBBXdzQZWViLkCbCICrSITQhmIQoGChIiQoMCAAX4hFCAAQewAaigCACIOQfQAayEPIABB4ABqIhAoAgAhCSAEKAIMIgUoAgQhCiAFKAIAIQtBACEFAkACQANAIA4gAiAJcSIMaikAACISIBSFIhFCgYKEiJCgwIABfSARQn+Fg0KAgYKEiJCgwIB/gyERA0AgEVAEQCASIBJCAYaDQoCBgoSIkKDAgH+DQgBSDQMgDCAFQQhqIgVqIQIMAgsgEXohFSARQgF9IBGDIREgDyAVp0EDdiAMaiAJcUGMf2xqIgIoAgAgB0cNACACQQRqKAIAIAhHDQALCyAEQUBrIAJBCGpB7AAQ4AoaIAJB8ABqIAY6AAAgAkHkAGpBADYCACACQeAAaiAKNgIAIAJB3ABqIAs2AgAgAkHUAGpCgICAgBA3AgAgAkHMAGpCgICAgIABNwIAIAJBFGpBADYCAAwBCyAEQcgCaiAGOgAAIARBvAJqQQA2AgAgBEG4AmogCjYCACAEQbQCaiALNgIAIARBrAJqQoCAgIAQNwIAIARBpAJqQoCAgICAATcCACAEQewBakEANgIAIAQgCDYC3AEgBCAHNgLYASAQIBMgBEHYAWoQjAQgBEECNgKQAQsgBEFAaxCPBQsCQAJAAkAgAEHoAGooAgBFDQAgBCgCDCICKAIAIQYgAkEEaigCACIJIAZBlZWIuQJsQQV3c0GVlYi5AmwiAkEZdq1CgYKEiJCgwIABfiETIABB7ABqKAIAIgpB9ABrIQsgAEHgAGooAgAhB0EAIQUDQCACIAdxIgggCmopAAAiEiAThSIRQoGChIiQoMCAAX0gEUJ/hYNCgIGChIiQoMCAf4MhEQNAIBFQBEAgEiASQgGGg0KAgYKEiJCgwIB/g0IAUg0DIAggBUEIaiIFaiECDAILIBF6IRQgEUIBfSARgyERIAsgFKdBA3YgCGogB3FBjH9saiICKAIAIAZHDQAgAkEEaigCACAJRw0ACwtBACEFIAJB5ABqQQA2AgAgBEHYAWoiBiADQdAAEOAKGiACQQhqIAEgBhCeASAAIAAoAnBBAWo2AnAMAQtBASEFQdjzxAAoAgBBA0sNAAJAAkACQEHQ8sQALQAAIgIOAwMCAQALQcjyxAAQ9QNB/wFxIgINAQwCC0ECIQILQczyxAAoAgAgAhDQCEUNACAEQUBrIgBBzPLEACgCABCCCUHM8sQAKAIAIQIgBEHYAWogABDFCCAEKALYAUUNASAEQcABaiIAQRBqIARB2AFqIgFBEGooAgA2AgAgAEEIaiABQQhqKQMANwMAIAQgBCkD2AE3A8ABIARB5AFqQQE2AgAgBEHsAWpBADYCACAEQaiAwwA2AjAgBCACNgK4ASAEQQE2ArQBIARBsIbDADYC4AEgBEHQ+MIANgLoASAEQQA2AtgBIAQgATYCLCAEIAA2AiggBCAEQShqNgKwAUHM8sQAKAIAIARBsAFqEPwICwJAIA1BAksNACAEKQMQUA0AIARBGGoiACgCBCEBIAAoAgAgASgCCEEHakF4cWogBEEQaiABKAI0EQAAIAQpAxAiEVANACAAKAIAIAAoAgQiASgCCEEHakF4cWogESABKAJAEQgAGiAEKQMQUA0AIAQoAhgiAigCACEBIAIgAUEBazYCACABQQFHDQAgABCxBwsCQCAFRQ0AAkAgAy0AACIAQQprQf8BcUEDSQ0AAkACQAJAIAAOCQABAwMDAwMDAgMLIAMoAgRFDQIgA0EIaigCABDUAQwCCyADQRtqLQAAQRhHDQEgA0EEaiIBKAIAIgIoAgAhACACIABBAWs2AgAgAEEBRw0BIAEQrggMAQsgAygCBEUNACADQQhqKAIAENQBCyADKAIoBEAgA0EsaigCABDUAQsgAygCNEUNACADQThqKAIAENQBCyAEQdACaiQADwtB3P/CAEEiQbiGwwAQkAoAC94MAQV/IAEEQCAAIAFBB3RqIQYDQCAAIgJBgAFqIQACQAJAAkACQAJAAkACQAJAIAItAAAOBgECAwQFBgALAkAgAkEkai8BACIBQQNxQQNHQQAgAUEBaxsNACACQShqKAIARQ0AIAJBLGooAgAQ1AELIAJBEGohBCACQRRqKAIAIgEEQCABQTBsIQUgBCgCAEEUaiEBA0ACQCABQQhrLwEAIgNBA3FBA0dBACADQQFrGw0AIAFBBGsoAgBFDQAgASgCABDUAQsCQCABQRBqKAIAIgNFDQAgAUEMaigCAEUNACADENQBCyABQTBqIQEgBUEwayIFDQALCyACKAIMRQ0GIAQoAgAQ1AEMBgsCQCACQSxqLwEAIgFBA3FBA0dBACABQQFrGw0AIAJBMGooAgBFDQAgAkE0aigCABDUAQsgAkEIaiEEIAJBDGooAgAiAQRAIAFBMGwhBSAEKAIAQRRqIQEDQAJAIAFBCGsvAQAiA0EDcUEDR0EAIANBAWsbDQAgAUEEaygCAEUNACABKAIAENQBCwJAIAFBEGooAgAiA0UNACABQQxqKAIARQ0AIAMQ1AELIAFBMGohASAFQTBrIgUNAAsLIAIoAgQEQCAEKAIAENQBCyACKAIQBEAgAkEUaigCABDUAQsgAkFAaxC9BgwFCwJAIAJBJGovAQAiAUEDcUEDR0EAIAFBAWsbDQAgAkEoaigCAEUNACACQSxqKAIAENQBCyACQQxqIQQgAkEQaigCACIBBEAgAUEwbCEFIAQoAgBBFGohAQNAAkAgAUEIay8BACIDQQNxQQNHQQAgA0EBaxsNACABQQRrKAIARQ0AIAEoAgAQ1AELAkAgAUEQaigCACIDRQ0AIAFBDGooAgBFDQAgAxDUAQsgAUEwaiEBIAVBMGsiBQ0ACwsgAigCCARAIAQoAgAQ1AELIAJBOGoQvQYMBAsCQCACQTxqLwEAIgFBA3FBA0dBACABQQFrGw0AIAJBQGsoAgBFDQAgAkHEAGooAgAQ1AELIAJBKGohBCACQSxqKAIAIgEEQCABQTBsIQUgBCgCAEEUaiEBA0ACQCABQQhrLwEAIgNBA3FBA0dBACADQQFrGw0AIAFBBGsoAgBFDQAgASgCABDUAQsCQCABQRBqKAIAIgNFDQAgAUEMaigCAEUNACADENQBCyABQTBqIQEgBUEwayIFDQALCyACKAIkBEAgBCgCABDUAQsgAkEQaigCAEUNAyACQQhqEMYGDAMLAkAgAkE8ai8BACIBQQNxQQNHQQAgAUEBaxsNACACQUBrKAIARQ0AIAJBxABqKAIAENQBCyACQShqIQQgAkEsaigCACIBBEAgAUEwbCEFIAQoAgBBFGohAQNAAkAgAUEIay8BACIDQQNxQQNHQQAgA0EBaxsNACABQQRrKAIARQ0AIAEoAgAQ1AELAkAgAUEQaigCACIDRQ0AIAFBDGooAgBFDQAgAxDUAQsgAUEwaiEBIAVBMGsiBQ0ACwsgAigCJARAIAQoAgAQ1AELIAJBEGooAgBFDQIgAkEIahCWBwwCCwJAIAJBNGovAQAiAUEDcUEDR0EAIAFBAWsbDQAgAkE4aigCAEUNACACQTxqKAIAENQBCyACQRRqIQQgAkEYaigCACIBBEAgAUEwbCEFIAQoAgBBFGohAQNAAkAgAUEIay8BACIDQQNxQQNHQQAgA0EBaxsNACABQQRrKAIARQ0AIAEoAgAQ1AELAkAgAUEQaigCACIDRQ0AIAFBDGooAgBFDQAgAxDUAQsgAUEwaiEBIAVBMGsiBQ0ACwsgAigCEARAIAQoAgAQ1AELIAJBCGooAgAiAUUNASACKAIERQ0BIAEQ1AEMAQsCQCACQSxqLwEAIgFBA3FBA0dBACABQQFrGw0AIAJBMGooAgBFDQAgAkE0aigCABDUAQsgAkEIaiEEIAJBDGooAgAiAQRAIAFBMGwhBSAEKAIAQRRqIQEDQAJAIAFBCGsvAQAiA0EDcUEDR0EAIANBAWsbDQAgAUEEaygCAEUNACABKAIAENQBCwJAIAFBEGooAgAiA0UNACABQQxqKAIARQ0AIAMQ1AELIAFBMGohASAFQTBrIgUNAAsLIAIoAgQEQCAEKAIAENQBCyACKAIQRQ0AIAJBFGooAgAQ1AELIAAgBkcNAAsLC8sOAhl/An4jAEGQAWsiByQAIAFBLGohGQJAAkACQCACKAIoIgYEQANAIAdBGGogAiAGIA1qQQF2IgsQkgUgBygCGEUNAyAHKAIcIgwgBU8NAiALQQFqIA0gAyAEIAxB0ABsakFAayAZEMgFQf8BcUH/AUYiDBshDSANIAYgCyAMGyIGSQ0ACwsCfkGQ9cQAKQMAQgBSBEBBoPXEACkDACEfQZj1xAApAwAMAQsgB0EIaiIDQgI3AwggA0IBNwMAQZD1xABCATcDAEGg9cQAIAcpAxAiHzcDACAHKQMICyEgIAEgDTYCECAHQTxqQbjCwgA2AgAgB0E4akEANgIAIAcgIDcDIEGY9cQAICBCAXw3AwAgB0IANwMwIAcgHzcDKCACKAIoIh0gDU0NAiABQSBqIRogAUEUaiEbIAFBKGohECABQSRqIRMDQCAHIAIgDRCSBQJAAkACQCAHKAIABEACQAJAIAcoAgQiAyAFSQRAIAQgA0HQAGxqIgsoAkAiAyAZKAIARw0KIAtBQGshDCADRQ0BIAwoAgQgASgCMEcNCiAMQQhqKAIAIAEoAjRGDQIMCgsgAyAFQcykwgAQnAcACyAMKAIEIAEoAjBHDQgLIAdBIGogCyANIAEQiQFFDQMgB0HQAGogB0EgaiALIA0QggMgBygCVCIMIAcoAlgiA0HYAGxqIRQgBygCUCEeIAwhCyADRQ0BIAwhBgNAIAZB2ABqIQsgBigCSCIcQQJGDQIgBkHMAGohCCAGQQlqIQogBigCACESAkAgBi0ACCIOQQVHBEAgB0HQAGoiA0EIaiIVIApBCGopAAA3AwAgA0EQaiIWIApBEGopAAA3AwAgA0EYaiIXIApBGGopAAA3AwAgA0EgaiIYIApBIGopAAA3AwAgA0EoaiIRIApBKGopAAA3AwAgA0EwaiIPIApBMGopAAA3AwAgA0E3aiIJIApBN2opAAA3AAAgB0HIAGoiAyAIQQhqKAIANgIAIAcgCikAADcDUCAHIAgpAgA3A0AgASgCHCIGIAEoAhRGBEAgGyAGEIsGIAEoAhwhBgsgASgCGCAGQdAAbGoiBiAOOgAAIAYgBykDUDcAASAGIBw2AkAgBkEJaiAVKQMANwAAIAZBEWogFikDADcAACAGQRlqIBcpAwA3AAAgBkEhaiAYKQMANwAAIAZBKWogESkDADcAACAGQTFqIA8pAwA3AAAgBkE4aiAJKQAANwAAIAYgBykDQDcCRCAGQcwAaiADKAIANgIAIAEgASgCHEEBajYCHCAQKAIAIgYgASgCIEYEQCAaIAYQhAYgECgCACEGCyATKAIAIAZBAnRqIBI2AgAgECgCACEJDAELAkACQAJAAkAgECgCACIDRQRAQQAhBgwBCyATKAIAIRFBACEGIAMhCQNAAkBBfyARIANBAXYgBmoiA0ECdGooAgAiDyASRyAPIBJJGyIPQQFGBEAgAyEJDAELIA9B/wFxQf8BRw0DIANBAWohBgsgCSAGayEDIAYgCUkNAAsLIAdB0ABqIgNBCGoiFSAKQQhqKQAANwMAIANBEGoiFiAKQRBqKQAANwMAIANBGGoiFyAKQRhqKQAANwMAIANBIGoiGCAKQSBqKQAANwMAIANBKGoiESAKQShqKQAANwMAIANBMGoiDyAKQTBqKQAANwMAIANBN2oiCSAKQTdqKQAANwAAIAdByABqIgMgCEEIaigCADYCACAHIAopAAA3A1AgByAIKQIANwNAIAEoAhwiDiABKAIURg0BDAILIAcgAzYCUEG8o8IAQS4gB0HQAGpB7KPCAEHcpMIAEIcHAAsgGyAOEPsFCyABKAIYIAZB0ABsaiEIAkAgBiAOTwRAIAYgDkYNASAGIA4QmQcACyAIQdAAaiAIIA4gBmtB0ABsEN8KGgsgCEEFOgAAIAggBykDUDcAASAIIBw2AkAgCEEJaiAVKQMANwAAIAhBEWogFikDADcAACAIQRlqIBcpAwA3AAAgCEEhaiAYKQMANwAAIAhBKWogESkDADcAACAIQTFqIA8pAwA3AAAgCEE4aiAJKQAANwAAIAEgDkEBajYCHCAIQcwAaiADKAIANgIAIAggBykDQDcCRCAQKAIAIgkgASgCIEYEQCAaIAlBARD0BQsgEygCACAGQQJ0aiEDAkAgBiAJTwRAIAYgCUYNASAGIAkQmQcACyADQQRqIAMgCSAGa0ECdBDfChoLIAMgEjYCAAsgECAJQQFqNgIAIBQgCyIGRw0ACwwCC0GsnsIAQStB7KTCABCeCAALIAsgFEYNACAUIAtrQdgAbkHYAGwhCSALQQhqIQYDQCAGELIGIAZB2ABqIQYgCUHYAGsiCQ0ACwsgHkUNACAMENQBCyABIAEoAhBBAWo2AhAgHSANQQFqIg1HDQALDAILIAwgBUHw7MEAEJwHAAtBgO3BAEErQaztwQAQnggACyAHQTBqELwDIABBAzYCACAHQZABaiQAC8sOAg9/AX4jAEEgayIKJAAgAEEIaigCACIIIAFqIQECQCABIAhJBEAQhwggCigCDBoMAQsgACgCACIHQQFqIQQCQAJAAkACQCAHIARBA3ZBB2wgB0EISRsiC0EBdiABSQRAIApBEGpBICABIAtBAWoiAyABIANLGxDuAyAKKAIcIgYNASAKKAIUGgwFCyAAQQxqKAIAIQVBACEBA0ACQAJ/IANBAXEEQCABQQdqIgMgAUkNAiADIARPDQIgAUEIagwBCyABIARJIgZFDQEgBiABIgNqCyEBIAMgBWoiAykDACESIAMgEkJ/hUIHiEKBgoSIkKDAgAGDIBJC//79+/fv37//AIR8NwMAQQEhAwwBCwsgBEEITwRAIAQgBWogBSkAADcAAAwCCyAFQQhqIAUgBBDfChogB0F/Rw0BQQAhCwwCCyAKKAIQIQUgCigCFCAIayELAkAgBEUEQCAAIAs2AgQgACAFNgIAIAAoAgwhCCAAIAY2AgwMAQsgAEEMaigCACIIQSBrIQ1BACEEA0AgBCAIaiwAAEEATgRAIAYgAiANIARBBXRrEM8DpyIJIAVxIgNqKQAAQoCBgoSIkKDAgH+DIhJQBEBBCCEBA0AgASADaiEDIAFBCGohASAGIAMgBXEiA2opAABCgIGChIiQoMCAf4MiElANAAsLIAYgEnqnQQN2IANqIAVxIgFqLAAAQQBOBEAgBikDAEKAgYKEiJCgwIB/g3qnQQN2IQELIAEgBmogCUEZdiIDOgAAIAFBCGsgBXEgBmpBCGogAzoAACAGIAFBf3NBBXRqIgFBGGogCCAEQX9zQQV0aiIDQRhqKQAANwAAIAFBEGogA0EQaikAADcAACABQQhqIANBCGopAAA3AAAgASADKQAANwAACyAEIAdGIARBAWohBEUNAAsgACALNgIEIAAgBTYCACAAQQxqIAY2AgAgB0UNAwsgB0EFdEEgaiIAIAdqQXdGDQMgCCAAaxDUAQwDCyAFQSBrIQ9BACEBA0ACQCAFIAEiBmoiDS0AAEGAAUcNACAPIAZBBXRrIRAgBSAGQX9zQQV0aiEEAkADQCAFIAIgEBDPA6ciCSAHcSIMIgNqKQAAQoCBgoSIkKDAgH+DIhJQBEBBCCEBA0AgASADaiEDIAFBCGohASAFIAMgB3EiA2opAABCgIGChIiQoMCAf4MiElANAAsLIAUgEnqnQQN2IANqIAdxIgNqLAAAQQBOBEAgBSkDAEKAgYKEiJCgwIB/g3qnQQN2IQMLIAMgDGsgBiAMa3MgB3FBCE8EQCAFIANBf3NBBXRqIQEgAyAFaiIMLQAAIAwgCUEZdiIJOgAAIANBCGsgB3EgBWpBCGogCToAAEH/AUYNAiAELQAFIQMgBC0ABCEJIAQgAS8ABDsABCABLQAHIQwgAS0ABiEOIAEgBC8ABjsABiAEKAAAIREgBCABKAAANgAAIAEgETYAACABIAk6AAQgBCAOOgAGIAEgAzoABSAEIAw6AAcgBC0ACCEDIAQgAS0ACDoACCABIAM6AAggBC0ACSEDIAQgAS0ACToACSABIAM6AAkgBC0ACiEDIAQgAS0ACjoACiABIAM6AAogBC0ACyEDIAQgAS0ACzoACyABIAM6AAsgBC0ADCEDIAQgAS0ADDoADCABIAM6AAwgBC0ADSEDIAQgAS0ADToADSABIAM6AA0gBC0ADiEDIAQgAS0ADjoADiABIAM6AA4gBC0ADyEDIAQgAS0ADzoADyABIAM6AA8gBC0AECEDIAQgAS0AEDoAECABIAM6ABAgBC0AESEDIAQgAS0AEToAESABIAM6ABEgBC0AEiEDIAQgAS0AEjoAEiABIAM6ABIgBC0AEyEDIAQgAS0AEzoAEyABIAM6ABMgBC0AFCEDIAQgAS0AFDoAFCABIAM6ABQgBC0AFSEDIAQgAS0AFToAFSABIAM6ABUgBC0AFiEDIAQgAS0AFjoAFiABIAM6ABYgBC0AFyEDIAQgAS0AFzoAFyABIAM6ABcgBC0AGCEDIAQgAS0AGDoAGCABIAM6ABggBC0AGSEDIAQgAS0AGToAGSABIAM6ABkgBC0AGiEDIAQgAS0AGjoAGiABIAM6ABogBC0AGyEDIAQgAS0AGzoAGyABIAM6ABsgBC0AHCEDIAQgAS0AHDoAHCABIAM6ABwgBC0AHSEDIAQgAS0AHToAHSABIAM6AB0gBC0AHiEDIAQgAS0AHjoAHiABIAM6AB4gBC0AHyEDIAQgAS0AHzoAHyABIAM6AB8MAQsLIA0gCUEZdiIBOgAAIAZBCGsgB3EgBWpBCGogAToAAAwBCyANQf8BOgAAIAZBCGsgB3EgBWpBCGpB/wE6AAAgAUEYaiAEQRhqKQAANwAAIAFBEGogBEEQaikAADcAACABQQhqIARBCGopAAA3AAAgASAEKQAANwAACyAGQQFqIQEgBiAHRw0ACwsgACALIAhrNgIECwsgCkEgaiQAC8sOAg9/AX4jAEEgayIKJAAgAEEIaigCACIIIAFqIQECQCABIAhJBEAQhwggCigCDBoMAQsgACgCACIHQQFqIQQCQAJAAkACQCAHIARBA3ZBB2wgB0EISRsiC0EBdiABSQRAIApBEGpBICABIAtBAWoiAyABIANLGxDvAyAKKAIcIgYNASAKKAIUGgwFCyAAQQxqKAIAIQVBACEBA0ACQAJ/IANBAXEEQCABQQdqIgMgAUkNAiADIARPDQIgAUEIagwBCyABIARJIgZFDQEgBiABIgNqCyEBIAMgBWoiAykDACESIAMgEkJ/hUIHiEKBgoSIkKDAgAGDIBJC//79+/fv37//AIR8NwMAQQEhAwwBCwsgBEEITwRAIAQgBWogBSkAADcAAAwCCyAFQQhqIAUgBBDfChogB0F/Rw0BQQAhCwwCCyAKKAIQIQUgCigCFCAIayELAkAgBEUEQCAAIAs2AgQgACAFNgIAIAAoAgwhCCAAIAY2AgwMAQsgAEEMaigCACIIQSBrIQ1BACEEA0AgBCAIaiwAAEEATgRAIAYgAiANIARBBXRrEM8DpyIJIAVxIgNqKQAAQoCBgoSIkKDAgH+DIhJQBEBBCCEBA0AgASADaiEDIAFBCGohASAGIAMgBXEiA2opAABCgIGChIiQoMCAf4MiElANAAsLIAYgEnqnQQN2IANqIAVxIgFqLAAAQQBOBEAgBikDAEKAgYKEiJCgwIB/g3qnQQN2IQELIAEgBmogCUEZdiIDOgAAIAFBCGsgBXEgBmpBCGogAzoAACAGIAFBf3NBBXRqIgFBGGogCCAEQX9zQQV0aiIDQRhqKQAANwAAIAFBEGogA0EQaikAADcAACABQQhqIANBCGopAAA3AAAgASADKQAANwAACyAEIAdGIARBAWohBEUNAAsgACALNgIEIAAgBTYCACAAQQxqIAY2AgAgB0UNAwsgB0EFdEEgaiIAIAdqQXdGDQMgCCAAaxDUAQwDCyAFQSBrIQ9BACEBA0ACQCAFIAEiBmoiDS0AAEGAAUcNACAPIAZBBXRrIRAgBSAGQX9zQQV0aiEEAkADQCAFIAIgEBDPA6ciCSAHcSIMIgNqKQAAQoCBgoSIkKDAgH+DIhJQBEBBCCEBA0AgASADaiEDIAFBCGohASAFIAMgB3EiA2opAABCgIGChIiQoMCAf4MiElANAAsLIAUgEnqnQQN2IANqIAdxIgNqLAAAQQBOBEAgBSkDAEKAgYKEiJCgwIB/g3qnQQN2IQMLIAMgDGsgBiAMa3MgB3FBCE8EQCAFIANBf3NBBXRqIQEgAyAFaiIMLQAAIAwgCUEZdiIJOgAAIANBCGsgB3EgBWpBCGogCToAAEH/AUYNAiAELQAFIQMgBC0ABCEJIAQgAS8ABDsABCABLQAHIQwgAS0ABiEOIAEgBC8ABjsABiAEKAAAIREgBCABKAAANgAAIAEgETYAACABIAk6AAQgBCAOOgAGIAEgAzoABSAEIAw6AAcgBC0ACCEDIAQgAS0ACDoACCABIAM6AAggBC0ACSEDIAQgAS0ACToACSABIAM6AAkgBC0ACiEDIAQgAS0ACjoACiABIAM6AAogBC0ACyEDIAQgAS0ACzoACyABIAM6AAsgBC0ADCEDIAQgAS0ADDoADCABIAM6AAwgBC0ADSEDIAQgAS0ADToADSABIAM6AA0gBC0ADiEDIAQgAS0ADjoADiABIAM6AA4gBC0ADyEDIAQgAS0ADzoADyABIAM6AA8gBC0AECEDIAQgAS0AEDoAECABIAM6ABAgBC0AESEDIAQgAS0AEToAESABIAM6ABEgBC0AEiEDIAQgAS0AEjoAEiABIAM6ABIgBC0AEyEDIAQgAS0AEzoAEyABIAM6ABMgBC0AFCEDIAQgAS0AFDoAFCABIAM6ABQgBC0AFSEDIAQgAS0AFToAFSABIAM6ABUgBC0AFiEDIAQgAS0AFjoAFiABIAM6ABYgBC0AFyEDIAQgAS0AFzoAFyABIAM6ABcgBC0AGCEDIAQgAS0AGDoAGCABIAM6ABggBC0AGSEDIAQgAS0AGToAGSABIAM6ABkgBC0AGiEDIAQgAS0AGjoAGiABIAM6ABogBC0AGyEDIAQgAS0AGzoAGyABIAM6ABsgBC0AHCEDIAQgAS0AHDoAHCABIAM6ABwgBC0AHSEDIAQgAS0AHToAHSABIAM6AB0gBC0AHiEDIAQgAS0AHjoAHiABIAM6AB4gBC0AHyEDIAQgAS0AHzoAHyABIAM6AB8MAQsLIA0gCUEZdiIBOgAAIAZBCGsgB3EgBWpBCGogAToAAAwBCyANQf8BOgAAIAZBCGsgB3EgBWpBCGpB/wE6AAAgAUEYaiAEQRhqKQAANwAAIAFBEGogBEEQaikAADcAACABQQhqIARBCGopAAA3AAAgASAEKQAANwAACyAGQQFqIQEgBiAHRw0ACwsgACALIAhrNgIECwsgCkEgaiQAC6YOAg5/AX4jAEEgayIKJAAgAEEIaigCACIJIAFqIQECQCABIAlJBEAQhwggCigCDBoMAQsgACgCACIHQQFqIQQCQAJAAkACQCAHIARBA3ZBB2wgB0EISRsiC0EBdiABSQRAIApBEGpBJCABIAtBAWoiAyABIANLGxDuAyAKKAIcIgYNASAKKAIUGgwFCyAAQQxqKAIAIQVBACEBA0ACQAJ/IANBAXEEQCABQQdqIgMgAUkNAiADIARPDQIgAUEIagwBCyABIARJIgZFDQEgBiABIgNqCyEBIAMgBWoiAykDACERIAMgEUJ/hUIHiEKBgoSIkKDAgAGDIBFC//79+/fv37//AIR8NwMAQQEhAwwBCwsgBEEITwRAIAQgBWogBSkAADcAAAwCCyAFQQhqIAUgBBDfChogB0F/Rw0BQQAhCwwCCyAKKAIQIQUgCigCFCAJayELAkAgBEUEQCAAIAs2AgQgACAFNgIAIAAoAgwhCSAAIAY2AgwMAQsgAEEMaigCACIJQSRrIQxBACEEA0AgBCAJaiwAAEEATgRAIAYgAiAMIARBXGxqEM8DpyIIIAVxIgNqKQAAQoCBgoSIkKDAgH+DIhFQBEBBCCEBA0AgASADaiEDIAFBCGohASAGIAMgBXEiA2opAABCgIGChIiQoMCAf4MiEVANAAsLIAYgEXqnQQN2IANqIAVxIgFqLAAAQQBOBEAgBikDAEKAgYKEiJCgwIB/g3qnQQN2IQELIAEgBmogCEEZdiIDOgAAIAFBCGsgBXEgBmpBCGogAzoAACAGIAFBf3NBJGxqIgFBIGogCSAEQX9zQSRsaiIDQSBqKAAANgAAIAFBGGogA0EYaikAADcAACABQRBqIANBEGopAAA3AAAgAUEIaiADQQhqKQAANwAAIAEgAykAADcAAAsgBCAHRiAEQQFqIQRFDQALIAAgCzYCBCAAIAU2AgAgAEEMaiAGNgIAIAdFDQMLIAdBJGxBK2pBeHEiACAHakF3Rg0DIAkgAGsQ1AEMAwsgBUEkayEOQQAhAQNAAkAgBSABIgZqIgwtAABBgAFHDQAgDiAGQVxsaiEPIAUgBkF/c0EkbGohBAJAA0AgBSACIA8QzwOnIgggB3EiDSIDaikAAEKAgYKEiJCgwIB/gyIRUARAQQghAQNAIAEgA2ohAyABQQhqIQEgBSADIAdxIgNqKQAAQoCBgoSIkKDAgH+DIhFQDQALCyAFIBF6p0EDdiADaiAHcSIDaiwAAEEATgRAIAUpAwBCgIGChIiQoMCAf4N6p0EDdiEDCyADIA1rIAYgDWtzIAdxQQhPBEAgBSADQX9zQSRsaiEBIAMgBWoiDS0AACANIAhBGXYiCDoAACADQQhrIAdxIAVqQQhqIAg6AABB/wFGDQIgASgAACEDIAEgBCgAADYAACAEIAM2AAAgBCgABCEDIAQgASgABDYABCABIAM2AAQgAS8ACCEDIAEgBC8ACDsACCAEIAM7AAggAS8ACiEDIAEgBC8ACjsACiAEIAM7AAogBC8ADCEDIAQgAS8ADDsADCABIAM7AAwgBC8ADiEDIAQgAS8ADjsADiABIAM7AA4gBC0AESEDIAQtABAhCCAEIAEvABA7ABAgASAIOgAQIAEgAzoAESAELQATIQMgBC0AEiEIIAQgAS8AEjsAEiABIAg6ABIgASADOgATIAQtABQhAyAEIAEtABQ6ABQgASADOgAUIAQtABUhAyAEIAEtABU6ABUgASADOgAVIAQtABYhAyAEIAEtABY6ABYgASADOgAWIAQtABchAyAEIAEtABc6ABcgASADOgAXIAQtABghAyAEIAEtABg6ABggASADOgAYIAQtABkhAyAEIAEtABk6ABkgASADOgAZIAQtABohAyAEIAEtABo6ABogASADOgAaIAQtABshAyAEIAEtABs6ABsgASADOgAbIAQtABwhAyAEIAEtABw6ABwgASADOgAcIAQtAB0hAyAEIAEtAB06AB0gASADOgAdIAQtAB4hAyAEIAEtAB46AB4gASADOgAeIAQtAB8hAyAEIAEtAB86AB8gASADOgAfIAQtACAhAyAEIAEtACA6ACAgASADOgAgIAQtACEhAyAEIAEtACE6ACEgASADOgAhIAQtACIhAyAEIAEtACI6ACIgASADOgAiIAQtACMhAyAEIAEtACM6ACMgASADOgAjDAELCyAMIAhBGXYiAToAACAGQQhrIAdxIAVqQQhqIAE6AAAMAQsgDEH/AToAACAGQQhrIAdxIAVqQQhqQf8BOgAAIAFBIGogBEEgaigAADYAACABQRhqIARBGGopAAA3AAAgAUEQaiAEQRBqKQAANwAAIAFBCGogBEEIaikAADcAACABIAQpAAA3AAALIAZBAWohASAGIAdHDQALCyAAIAsgCWs2AgQLCyAKQSBqJAALpg4CDn8BfiMAQSBrIgokACAAQQhqKAIAIgkgAWohAQJAIAEgCUkEQBCHCCAKKAIMGgwBCyAAKAIAIgdBAWohBAJAAkACQAJAIAcgBEEDdkEHbCAHQQhJGyILQQF2IAFJBEAgCkEQakEkIAEgC0EBaiIDIAEgA0sbEO8DIAooAhwiBg0BIAooAhQaDAULIABBDGooAgAhBUEAIQEDQAJAAn8gA0EBcQRAIAFBB2oiAyABSQ0CIAMgBE8NAiABQQhqDAELIAEgBEkiBkUNASAGIAEiA2oLIQEgAyAFaiIDKQMAIREgAyARQn+FQgeIQoGChIiQoMCAAYMgEUL//v379+/fv/8AhHw3AwBBASEDDAELCyAEQQhPBEAgBCAFaiAFKQAANwAADAILIAVBCGogBSAEEN8KGiAHQX9HDQFBACELDAILIAooAhAhBSAKKAIUIAlrIQsCQCAERQRAIAAgCzYCBCAAIAU2AgAgACgCDCEJIAAgBjYCDAwBCyAAQQxqKAIAIglBJGshDEEAIQQDQCAEIAlqLAAAQQBOBEAgBiACIAwgBEFcbGoQzwOnIgggBXEiA2opAABCgIGChIiQoMCAf4MiEVAEQEEIIQEDQCABIANqIQMgAUEIaiEBIAYgAyAFcSIDaikAAEKAgYKEiJCgwIB/gyIRUA0ACwsgBiAReqdBA3YgA2ogBXEiAWosAABBAE4EQCAGKQMAQoCBgoSIkKDAgH+DeqdBA3YhAQsgASAGaiAIQRl2IgM6AAAgAUEIayAFcSAGakEIaiADOgAAIAYgAUF/c0EkbGoiAUEgaiAJIARBf3NBJGxqIgNBIGooAAA2AAAgAUEYaiADQRhqKQAANwAAIAFBEGogA0EQaikAADcAACABQQhqIANBCGopAAA3AAAgASADKQAANwAACyAEIAdGIARBAWohBEUNAAsgACALNgIEIAAgBTYCACAAQQxqIAY2AgAgB0UNAwsgB0EkbEErakF4cSIAIAdqQXdGDQMgCSAAaxDUAQwDCyAFQSRrIQ5BACEBA0ACQCAFIAEiBmoiDC0AAEGAAUcNACAOIAZBXGxqIQ8gBSAGQX9zQSRsaiEEAkADQCAFIAIgDxDPA6ciCCAHcSINIgNqKQAAQoCBgoSIkKDAgH+DIhFQBEBBCCEBA0AgASADaiEDIAFBCGohASAFIAMgB3EiA2opAABCgIGChIiQoMCAf4MiEVANAAsLIAUgEXqnQQN2IANqIAdxIgNqLAAAQQBOBEAgBSkDAEKAgYKEiJCgwIB/g3qnQQN2IQMLIAMgDWsgBiANa3MgB3FBCE8EQCAFIANBf3NBJGxqIQEgAyAFaiINLQAAIA0gCEEZdiIIOgAAIANBCGsgB3EgBWpBCGogCDoAAEH/AUYNAiABKAAAIQMgASAEKAAANgAAIAQgAzYAACAEKAAEIQMgBCABKAAENgAEIAEgAzYABCABLwAIIQMgASAELwAIOwAIIAQgAzsACCABLwAKIQMgASAELwAKOwAKIAQgAzsACiAELwAMIQMgBCABLwAMOwAMIAEgAzsADCAELwAOIQMgBCABLwAOOwAOIAEgAzsADiAELQARIQMgBC0AECEIIAQgAS8AEDsAECABIAg6ABAgASADOgARIAQtABMhAyAELQASIQggBCABLwASOwASIAEgCDoAEiABIAM6ABMgBC0AFCEDIAQgAS0AFDoAFCABIAM6ABQgBC0AFSEDIAQgAS0AFToAFSABIAM6ABUgBC0AFiEDIAQgAS0AFjoAFiABIAM6ABYgBC0AFyEDIAQgAS0AFzoAFyABIAM6ABcgBC0AGCEDIAQgAS0AGDoAGCABIAM6ABggBC0AGSEDIAQgAS0AGToAGSABIAM6ABkgBC0AGiEDIAQgAS0AGjoAGiABIAM6ABogBC0AGyEDIAQgAS0AGzoAGyABIAM6ABsgBC0AHCEDIAQgAS0AHDoAHCABIAM6ABwgBC0AHSEDIAQgAS0AHToAHSABIAM6AB0gBC0AHiEDIAQgAS0AHjoAHiABIAM6AB4gBC0AHyEDIAQgAS0AHzoAHyABIAM6AB8gBC0AICEDIAQgAS0AIDoAICABIAM6ACAgBC0AISEDIAQgAS0AIToAISABIAM6ACEgBC0AIiEDIAQgAS0AIjoAIiABIAM6ACIgBC0AIyEDIAQgAS0AIzoAIyABIAM6ACMMAQsLIAwgCEEZdiIBOgAAIAZBCGsgB3EgBWpBCGogAToAAAwBCyAMQf8BOgAAIAZBCGsgB3EgBWpBCGpB/wE6AAAgAUEgaiAEQSBqKAAANgAAIAFBGGogBEEYaikAADcAACABQRBqIARBEGopAAA3AAAgAUEIaiAEQQhqKQAANwAAIAEgBCkAADcAAAsgBkEBaiEBIAYgB0cNAAsLIAAgCyAJazYCBAsLIApBIGokAAuUEQMBfwF8AX4jAEHAAWsiBCQAAkACQAJAAkACQAJAIAJFBEAgARAJQQFHDQEgAEEJOgAADAYLAkACQAJAAkACQAJAIANBA2sOBwACBAUBBQMFCyACQbWEwABBAxDhCkUNCAJAIAJBuITAAEEDEOEKBEAgAkG7hMAAQQMQ4QoNBiAEQcgAaiABEAggBCgCSA0BIABBCjoAAAwMCyAEQUBrIAEQBCAEKAJAIgFFBEAgAEEKOgAADAwLIAQgBCgCRCICNgKAASAEIAE2AnwgBCACNgJ4IARBkAFqIgFBBHIgBEH4AGoQ0gMgAEEIaiABQQhqKQMANwMAIABBEGogAUEQaikDADcDACAAQRhqIAFBGGopAwA3AwAgBEEBOgCQASAAIAQpA5ABNwMADAsLIAQrA1AhBSAAQQQ6AAAgACAFOQMIDAoLIAJBroTAAEEHEOEKRQ0IIAJBsIXAAEEHEOEKDQMgBEEgaiABEAggBCgCIEUEQCAAQQo6AAAMCgsgBCsDKCIFRAAAAAAAAODDZiEBIABC////////////AAJ+IAWZRAAAAAAAAOBDYwRAIAWwDAELQoCAgICAgICAgH8LQoCAgICAgICAgH8gARsgBUT////////fQ2QbQgAgBSAFYRsiBjcDCCAAQQU6AAAgAEEYakEANgIAIABBEGogBjcDAAwJCyACKAAAQfXSuaMHRg0FIAIoAABB7uqx4wZHDQIgAEEJOgAADAgLIAJBt4XAAEEJEOEKDQEgBEHoAGogARAIIAQoAmgEQCAEKwNwIQUgAEEGOgAAIAVEAAAAAAAA4MNmIQEgAEL///////////8AAn4gBZlEAAAAAAAA4ENjBEAgBbAMAQtCgICAgICAgICAfwtCgICAgICAgICAfyABGyAFRP///////99DZBtCACAFIAVhGzcDCAwICyAEIAEQADYCkAEgBEGQAWoQgwogBCgCkAEhAQRAIAQgATYCkAEgBEGQAWoQ9AohBSAAQQY6AAAgBUQAAAAAAADgw2YhASAAQv///////////wACfiAFmUQAAAAAAADgQ2MEQCAFsAwBC0KAgICAgICAgIB/C0KAgICAgICAgIB/IAEbIAVE////////30NkG0IAIAUgBWEbNwMIIAQoApABIgBBhAFJDQggABABDAgLIABBCjoAACABQYQBSQ0HIAEQAQwHCyACQb6EwABBBRDhCkUNAgsgAEEKOgAADAULQQAhAgJAAkACQCABEAoOAgEAAgtBASECCyAAIAI6AAEgAEEHOgAADAULIARBGGogARAEIAQoAhgiAgRAIAQgBCgCHCIBNgK4ASAEIAI2ArQBIAQgATYCsAEgBEH4AGoiASAEQbABahDSAyAEQaMBaiABQRBqKQMANwAAIARBmwFqIAFBCGopAwA3AAAgBCAEKQN4NwCTASAAQQE6AAAgACAEKQCQATcAASAAQQlqIARBkAFqIgFBCGopAAA3AAAgAEERaiABQRBqKQAANwAAIABBGGogBEGnAWooAAA2AAAMBQsgBEEIaiABEAgCQCAEKAIIBEAgBCsDECIFvUKAgICAgICAgIB/g0L/////////7z+EvyAFoJ0gBaGZRAAAAAAAALA8Yw0BIAAgBTkDCCAAQQQ6AAAMBgsgBCABEAA2ApABIARBkAFqEIMKIAQoApABIQIEQCAEIAI2ApABIARBkAFqEPQKIQUgAEEGOgAAIAVEAAAAAAAA4MNmIQEgAEL///////////8AAn4gBZlEAAAAAAAA4ENjBEAgBbAMAQtCgICAgICAgICAfwtCgICAgICAgICAfyABGyAFRP///////99DZBtCACAFIAVhGzcDCCAEKAKQASIAQYQBSQ0GIAAQAQwGCyAEIAEQADYCkAEgBEGQAWoQiAohASAEIAQoApABIgM2ArQBIAQgAUEBczYCsAECQCABBEAgBEH4AGoiASAEQbABakEEchDwBiAEQZsBaiABQQhqKAIANgAAIAQgBCkDeDcAkwEgAEEAOgAAIAAgBCkAkAE3AAEgAEEIaiAEQZcBaikAADcAACAEKAK0ASEDDAELIABBCjoAAAsgA0GEAU8EQCADEAELIAJBhAFJDQUgAhABDAULIABBAjoAACAFRAAAAAAAAODDZiEBIABC////////////AAJ+IAWZRAAAAAAAAOBDYwRAIAWwDAELQoCAgICAgICAgH8LQoCAgICAgICAgH8gARsgBUT////////fQ2QbQgAgBSAFYRs3AwgMBAsgBCABEAA2ApABIARBkAFqEIgKIAQoApABIQEEQCAEIAE2ArABIARB+ABqIgEgBEGwAWoQ8AYgBEGbAWogAUEIaigCADYAACAEIAQpA3g3AJMBIABBADoAACAAIAQpAJABNwABIABBCGogBEGXAWopAAA3AAAgBCgCsAEiAEGEAUkNBCAAEAEMBAsgBCABNgKQAUHDhMAAQSsgBEGQAWpB8ITAAEGghcAAEIcHAAsgBEHYAGogARAIIAQoAlhFBEAgAEEKOgAADAMLIAQrA2AhBSAAQQM6AAAgAEJ/An4gBUQAAAAAAAAAAGYiASAFRAAAAAAAAPBDY3EEQCAFsQwBC0IAC0IAIAEbIAVE////////70NkGzcDCAwCCyAEQTBqIAEQCCAEKAIwRQRAIABBCjoAAAwCCyAEKwM4IQUgAEECOgAAIAVEAAAAAAAA4MNmIQEgAEL///////////8AAn4gBZlEAAAAAAAA4ENjBEAgBbAMAQtCgICAgICAgICAfwtCgICAgICAgICAfyABGyAFRP///////99DZBtCACAFIAVhGzcDCAwBC0EBQQIgARAKIgFBAUYbQQAgARsiAUECRgRAIABBCjoAAAwBCyAAIAE6AAEgAEEHOgAACyAEQcABaiQAC8MZAhN/AX4jAEFAaiIFJAAgAEEEaigCACEMIABBCGooAgAhCEEBIQpBASECQQEhAQNAIAEhBwJAAkAgAyAEaiIBQQlJBEAgAkGc9MMAai0AACICIAFBnPTDAGotAAAiAU8EQCABIAJGDQJBASEKIAdBAWohAUEAIQMgByEEDAMLIAMgB2pBAWoiASAEayEKQQAhAwwCCyABQQlBsNfEABCcBwALIANBAWoiASAKRiECQQAgASACGyEDIAFBACACGyAHaiEBCyABIANqIgJBCUkNAAtBASECQQEhAUEAIQNBASELA0AgASEHAkACQCADIAZqIgFBCUkEQCACQZz0wwBqLQAAIgIgAUGc9MMAai0AACIBTQRAIAEgAkYNAkEBIQsgB0EBaiEBQQAhAyAHIQYMAwsgAyAHakEBaiIBIAZrIQtBACEDDAILIAFBCUGw18QAEJwHAAsgA0EBaiIBIAtGIQJBACABIAIbIQMgAUEAIAIbIAdqIQELIAEgA2oiAkEJ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ECAAQbDswwA2AhggAEEANgIIIABBCGpBqO3DABDaCAALIAUgCTYCACAFQQRqIAE2AgALIABBIGokACAFKAIIIQkLIAUoAgQhAUEUQQQQ8AkiAARAIAAgCTYCECAAIAE2AgwgAEEANgIIIABBACAPIAQbNgIEIABBACAOIAQbNgIAIAVBQGskACAADwtBFEEEQfD0xAAoAgAiAEHKBCAAGxEAAAALIA4gAkEAIAFBxPDDABDqCQAL9A4COX8DfiMAQeAAayIDJAAgASgCACgCACEBIANBMGoiBkEYaiACQRhqKQAANwMAIAZBEGogAkEQaikAADcDACAGQQhqIAJBCGopAAA3AwAgAyACKQAANwMwAkACQAJAAkACQAJAAkAgASgCBCIGRQ0AIANBEGogASgCACAGIANBMGoQmQYgAygCEA0AIANBGGooAgBFDQAgAEECNgIwDAELAkAgAigCMEUEQCACQTRqKAIAIQggAkE4aigCACELDAELIAJBOGooAgAhBkEBIQ5BASELIAJBPGooAgAiCARAIAhBAE4iAUUNAyAIIAEQ8AkiC0UNBAsgCyAGIAgQ4AoaCyADQTBqIgFBCGogAkEIaikCADcDACABQRBqIAJBEGopAgA3AwAgAUEYaiACQRhqKQIANwMAIAMgAikCADcDMCACQfgAaigCACEGIAIoAighDyACKAIkIRAgAi0ALCERIAIoAiAhEgJAIAJB/ABqKAIAIgpFBEBBASEBDAELIApB////H0sNAiAKQQV0IgRBAEgNAiAKQYCAgCBJIQUgBAR/IAQgBRDwCQUgBQsiAUUNBAsgASAGIAQQ4AohEwJ/IAIvAYwBRQRAIAJBjgFqLwEAIRQgAkGcAWooAgAhFSACQZQBaigCACEMIAJBkAFqKAIAIQEgAkGYAWooAgAMAQsgAkGUAWooAgAhBEEBIRZBASEMIAJBmAFqKAIAIgEEQCABQQBOIgVFDQMgASAFEPAJIgxFDQYLIAwgBCABEOAKGiABCyEXIANB0ABqIAJBgAFqEIgEIAIpA0ghPCACKQNgIT0gAikDQCE+IAJB7ABqKAIABH8gA0EQaiACQegAahDKByADKAIYIRggAygCECEZIAMoAhQFQQALIQYgAkHwAWooAgAEQCACQfwBaigCACEaIAJB+AFqKAIAIRsgAkH0AWooAgAhHEEBIR0gAkGAAmooAgAhDQsgAkHcAGooAgAhHiACQdQAaigCACEfIAJB7AFqKAIAISAgAkHoAWooAgAhISACQeQBaigCACEiIAJB4AFqKAIAISMgAkHcAWooAgAhJCACQdgBaigCACElIAJBrAFqKAIAISYgAkGoAWooAgAhJyACQaQBaigCACEoIAJB1AFqKAIAISkgAkHQAWooAgAhKiACQcwBaigCACErIAJByAFqKAIAISwgAkHEAWooAgAhLSACQcABaigCACEuIAJBvAFqKAIAIS8gAkG4AWooAgAhMCACQbQBaigCACExIAJBsAFqKAIAITIgAigCWCEzIAIoAlAhNCACKAKgASE1IANBEGoiCUEYaiI2IANBMGoiB0EYaikDADcDACAJQRBqIjcgB0EQaikDADcDACAJQQhqIjggB0EIaikDADcDACADQQhqIjkgA0HYAGooAgA2AgAgAyADKQMwNwMQIAMgAykDUDcDAEECIQkCQAJAAkBBASACKAKMAiIHQQJrIAdBAU0bQQFrDgIAAQILIAJBnAJqKAIAITogB0UEQCACQZACaigCACEEIAJBlAJqKAIAIQVBACEJDAILIAJBlAJqKAIAITtBASEJQQEhBSACQZgCaigCACIEBEAgBEEATiIHRQ0EIAQgBxDwCSIFRQ0ICyAFIDsgBBDgChoMAQtBBCEJCyAAIAMpAxA3AwAgACADLwAwOwAtIAAgCDYCPCAAIAs2AjggACAINgI0IAAgDjYCMCAAIAMpAwA3A4ABIABBCGogOCkDADcDACAAQRBqIDcpAwA3AwAgAEEYaiA2KQMANwMAIABBL2ogA0Eyai0AADoAACAAQYgBaiA5KAIANgIAIAIoAogCIQIgACAENgKYAiAAIAU2ApQCIAAgBDYCkAIgACAVNgKcASAAIBc2ApgBIAAgDDYClAEgACABNgKQASAAIBQ7AY4BIAAgFjsBjAEgACA6NgKcAiAAIAk2AowCIAAgAjYCiAIgACANNgKAAiAAIBo2AvwBIAAgGzYC+AEgACAcNgL0ASAAIB02AvABIAAgIDYC7AEgACAhNgLoASAAICI2AuQBIAAgIzYC4AEgACAkNgLcASAAICU2AtgBIAAgKTYC1AEgACAqNgLQASAAICs2AswBIAAgLDYCyAEgACAtNgLEASAAIC42AsABIAAgLzYC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xAAoAgAQgglB3PDEACgCACEDIAJByABqIAEQxQggAigCSEUNCSACQfAAaiIEQRBqIAJByABqIgFBEGoiBSgCADYCACAEQQhqIAFBCGoiBCkDADcDACACIAIpA0g3A3AgAkGUAWpBATYCACACQZwBakEANgIAIAJB+OnBADYCkAEgAkGE58EANgKYASACQQA2AogBIAEgAkEwahDFCCACKAJIRQ0JIAJBoAFqIgFBEGogBSgCADYCACABQQhqIAQpAwA3AwAgAiACKQNINwOgASACIAJB6AFqNgK0ASACQdABaiACQTBqEMUIIAIoAtABRQ0JIAJBuAFqIgFBEGogAkHQAWoiBEEQaigCADYCACABQQhqIARBCGopAwA3AwAgAkHoAGpBoOrBADYCACACQdwAakGQ6sEANgIAIAIgAikD0AE3A7gBIAJBgOrBADYCUCACIAM2AiggAkEDNgIkIAJB5ABqIAJBGGo2AgAgAkHIAGoiA0EQaiACQbQBajYCACACIAE2AmAgAiACQaABajYCVCACIAJBiAFqNgJMIAIgAkHwAGo2AkggAiADNgIgQdzwxAAoAgAgAkEgahD8CAwDCyACKQOQASIIQoCAgIBwgyEJIAIoApwBIQUgAigCiAEhBCACKAKMASEBDAQLQQVBAUHw9MQAKAIAIgBBygQgABsRAAAACyADQQhB8PTEACgCACIAQcoEIAAbEQAAAAsCQEEMQQQQ8AkiAwRAQQRBARDwCSIBRQ0IIANBBDYCCCADIAE2AgQgA0EENgIAIAFB5MrBmwc2AABBISEEQSFBARDwCSIBRQ0BIAFBIGpB9unBAC0AADoAACABQRhqQe7pwQApAAA3AAAgAUEQakHm6cEAKQAANwAAIAFBCGpB3unBACkAADcAACABQdbpwQApAAA3AABBASEFQiEhCEKAgICAECEJDAILDAULQSFBAUHw9MQAKAIAIgBBygQgABsRAAAACyACKAIIRQ0AIAIoAgwQ1AELIAAgBDYCBCAAQRhqIAU2AgAgAEEUaiADNgIAIABBCGogATYCACAAQQxqIAhC/////w+DIAlCgICAgHCDhDcCAAtBASEFCyAAIAU2AgAgAkHwAWokAA8LQQxBBEHw9MQAKAIAIgBBygQgABsRAAAAC0G06cEAQSJB3OrBABCQCgALQQRBAUHw9MQAKAIA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IAEoAjggAUEgahCJASIABEAgASgCVEEBRw0BCyABKAI0IQQMAQsgASACIAEtAGAQ2QMgASgCNGoiBDYCNCABAn8CQAJ/IAItAEwEQCACQSRqIQcgAkEgagwBCyACKAJARQ0BIAJByABqIQcgAkHEAGoLKAIAIQYgBygCACEHQQEMAQtBAAs2AlQgAUHcAGogBzYCACABQdgAaiAGNgIACwJAIAAgBCABKAIwS3FFDQAgBUEQaiABIAIgASgCOBCCAyAFKAIUIgAgBSgCGCICQdgAbGohDiAFKAIQIAAhCgJAAkAgAkUNACABQcgAaiETIAFBPGohFCABQdAAaiEJIAAhAgNAIAJB2ABqIQogAigCSCIVQQJGDQEgAkHMAGohCCACQQlqIQMgAigCACEMAkAgAi0ACCINQQVHBEAgBUEQaiICQQhqIg8gA0EIaikAADcDACACQRBqIhAgA0EQaikAADcDACACQRhqIhEgA0EYaikAADcDACACQSBqIhIgA0EgaikAADcDACACQShqIgsgA0EoaikAADcDACACQTBqIgcgA0EwaikAADcDACACQTdqIgYgA0E3aikAADcAACAFQQhqIgQgCEEIaigCADYCACAFIAMpAAA3AxAgBSAIKQIANwMAIAEoAkQiAiABKAI8RgRAIBQgAhCLBiABKAJEIQILIAEoAkAgAkHQAGxqIgIgDToAACACIAUpAxA3AAEgAiAVNgJAIAJBCWogDykDADcAACACQRFqIBApAwA3AAAgAkEZaiARKQMANwAAIAJBIWogEikDADcAACACQSlqIAspAwA3AAAgAkExaiAHKQMANwAAIAJBOGogBikAADcAACACIAUpAwA3AkQgAkHMAGogBCgCADYCACABIAEoAkRBAWo2AkQgCSgCACICIAEoAkhGBEAgEyACEIQGIAkoAgAhAgsgAUHMAGooAgAgAkECdGogDDYCACAJKAIAIQQMAQsgAUHMAGohDQJAAkACQAJAIAkoAgAiBkUEQEEAIQIMAQsgDSgCACELQQAhAiAGIQQDQAJAQX8gCyAGQQF2IAJqIgZBAnRqKAIAIgcgDEcgByAMSRsiB0EBRgRAIAYhBAwBCyAHQf8BcUH/AUcNAyAGQQFqIQILIAQgAmshBiACIARJDQALCyAFQRBqIgRBCGoiDyADQQhqKQAANwMAIARB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aygCACAAQZgDaygCACAAQdwDaygCACAHampqampqamohByAAQaAEaiEAIAVBCGsiBQ0ACyAAQYQEayEACyAKRQ0AIApBxABsIQUgAEEoaiEAA0AgACgCACAHaiEHIABBxABqIQAgBUHEAGsiBQ0ACwsgByAPajYCAAJAIAhFDQAgCEHEAGxBxABrIgBBxABuQQFqIgVBB3EhCCAAQdwDTwRAIAZBhARqIQAgBUH4//8/cSEFA0AgACgCACAAQcQAaygCACAAQYgBaygCACAAQcwBaygCACAAQZACaygCACAAQdQCaygCACAAQZgDaygCACAAQdwDaygCACAJampqampqamohCSAAQaAEaiEAIAVBCGsiBQ0ACyAAQYQEayEGCyAIRQ0AIAhBxABsIQUgBkEoaiEAA0AgACgCACAJaiEJIABBxABqIQAgBUHEAGsiBQ0ACwsgBCAJIAtqIgU2AjggDSACIAMQrwMgBEEQaiACIAMQrwMgAUEBaiEDIAQoAggiAEE0aigCACECIAIgACgCLEYEQCAAQSxqIAJBARD6BQsgAEEwaigCACADQcQAbGohBgJAIAIgA00EQCACIANGDQEgAyACEJkHAAsgBkHEAGogBiACIANrQcQAbBDfChoLIAYgBEEQakHEABDgChogACACQQFqNgI0IABBQGsoAgAiAiAAKAI4RgRAIABBOGogAkEBEPQFCyAAQTxqKAIAIAFBAnRqIQMCQCABIAJPBEAgASACRg0BIAEgAhCZBwALIANBBGogAyACIAFrQQJ0EN8KGgsgAyAONgIAIAAgAkEBajYCQCAEIAcgDGogBWoiATYCXAJAIAQoAlggAUYEQCAEIAAoAigiADYCYCAAIAQoAgxGDQEgBEEANgJwIARBDGogBEHgAGogBEHoAGpB0P/BABDQBwALIARBATYCfCAEQQE2AnQgBEGk/MEANgJwIARBATYCbCAEQaD/wQA2AmggBEGgAjYCZCAEIARB4ABqNgJ4IAQgBEEIajYCYCAEQdwAaiAEQdgAaiAEQegAakHA/8EAENAHAAsgBEGAAWokAAuvDAEGfyABLQCBASEEAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEoAkBFBEAgBEUNAUEDIQQgAigCQA0PIAJBxABqKAIAIAFBxABqKAIARw0PQQAhBCAC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aiIBQQxqQQE2AgAgAUEUakEANgIAIANBmITBADYCcCADQQA2AmggA0G/ATYCXCADQbSEwQA2AkAgA0GQgsEANgJIIANBADYCOCADIANB2ABqNgJ4IAMgATYCWCAAQbyEwQAQ2ggACyABQewCaigCACIGLwHmAiAJQf//A3FqQQtPBEAgA0EANgJQIAMgATYCTCADIAQ2AkggAyAGNgJEIAMgBTYCQCADIAc2AjwgAyAFNgI4IANBOGpBARDaAQwCCyADQQA2AlAgAyABNgJMIAMgBDYCSCADIAY2AkQgAyAFNgJAIAMgBzYCPCADIAU2AjggA0HYAGogA0E4akEAIAoQ4wEMAwsgASAGQQFrIgZBAnRqQegCaigCACILLwHmAiAJQf//A3FqQQtPBEAgAyAGNgJQIAMgATYCTCADIAQ2AkggAyAHNgJEIAMgBTYCQCADIAs2AjwgAyAFNgI4IANBOGpBARCjAiADIAw2AmAMAgsgAyAGNgJQIAMgATYCTCADIAQ2AkggAyAHNgJEIAMgBTYCQCADIAs2AjwgAyAFNgI4IANB2ABqIANBOGpBASAKEOMBDAILIAMgCjYCYAsgAyAHNgJcIAMgBTYCWAsgAygCYCEKIAMoAlghBSADKAJcIgcoAuACIgRFDQAgBUEBaiEBA0AgBC8B5gIiCUEESw0BIAQoAuACIgYEQCABQQFqIQsgBEHkAmovAQAiCEUEQCAGLwHmAkUEQCADQegAaiIAQQxqQQE2AgAgAEEUakEBNgIAIANBOGoiAUEMakEBNgIAIAFBFGpBADYCACADQZiEwQA2AnAgA0EANgJoIANBvwE2AowBIANBtITBADYCQCADQZCCwQA2AkggA0EANgI4IAMgA0GIAWo2AnggAyABNgKIASAAQbyEwQAQ2ggACyAGQewCaigCACEIIANBADYCgAEgAyAGNgJ8IAMgCzYCeCADIAg2AnQgAyABNgJwIAMgBDYCbCADIAE2AmggCSAILwHmAmpBC08EQCADQegAakEFIAlrENoBDAQLIANBOGoiAUEYaiADQegAaiIEQRhqKAIANgIAIAFBEGogBEEQaikDADcDACABQQhqIARBCGopAwA3AwAgAyADKQNoNwM4IANBCGogARDvASADKAIIIQEgAygCDCIEDQIMAwsgBiAIQQFrIgxBAnRqQegCaigCACEIIAMgDDYCgAEgAyAGNgJ8IAMgCzYCeCADIAQ2AnQgAyABNgJwIAMgCDYCbCADIAE2AmggCSAILwHmAmpBC08EQCADQegAakEFIAlrEKMCDAMLIANBOGoiAUEYaiADQegAaiIEQRhqKAIANgIAIAFBEGogBEEQaikDADcDACABQQhqIARBCGopAwA3AwAgAyADKQNoNwM4IANBEGogARDvASADKAIQIQEgAygCFCIEDQEMAgsLIAkNACACQQE6AAALIAAgAykDGDcAACAAIAU2AiAgAEEoaiAKNgIAIABBJGogBzYCACAAQRhqIA0pAwA3AAAgAEEQaiAOKQMANwAAIABBCGogDykDADcAACADQZABaiQAC8gSAiJ/B34jAEHQAGsiAyQAIAJBxgBqLQAAIQwgASgCACEFIAItAFQhHCACKAJQIQ4gAigCTCEHIAIoAkghCSACLQBHIRYgAigBQCEZIAIvAT4hGiACLwE8IRQgAigCMCEXIAIoAiwhECACKAIoIQYgAikCNCEoIAIvAUQhCCACKQMgISUgA0EgaiIEQRhqIgEgAkEYaikDADcDACAEQRBqIgogAkEQaikDADcDACAEQQhqIgsgAkEIaikDADcDACADIAIpAwA3AyAgAyAlIAQQ1wQCQAJAAkACQAJAIAMtAABBDUcEQCABIANBGGopAwA3AwAgCiADQRBqKQMANwMAIAsgA0EIaikDADcDACADIAMpAwA3AyAgFkEbRg0BIAggDEEQdHIhCAwCCyADIAMpAwg3AyAgAyADQRBqKQMANwMoQcCgwgBBKyADQSBqQeygwgBB/KDCABCHBwALQQEhHSAXICinIgJyRQRAQQIhFAwBCyADIAI2AgACQCAFQRhqKAIARQ0AIAUgAxDXAyElIAVBHGooAgAiBEEYayENICVCGYhC/wCDQoGChIiQoMCAAX4hKCAFQRBqKAIAIQogJachAiADKAIAIQxBACEIA0AgBCACIApxIgFqKQAAIiYgKIUiJUKBgoSIkKDAgAF9ICVCf4WDQoCBgoSIkKDAgH+DISUDQCAlUARAICYgJkIBhoNCgIGChIiQoMCAf4NCAFINAyAIQQhqIgggAWohAgwCCyAleiEnICVCAX0gJYMhJSANICenQQN2IAFqIApxQWhsaiICKAIAIAxHDQALCwJAAn8gAi8BBEUE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akECNgIAIAIgAEEYajYCECACQcCkwQA2AiAgAkEANgIYIAJB0AE2AgQgAiAAQQRqNgIUIAIgAjYCKCACIAJBFGo2AgggAiACQRBqNgIAIAEgAxDkByEADBALIAJBJGpBATYCACACQSxqQQA2AgAgAkGYpMEANgIgIAJB1JbBADYCKCACQQA2AhggASACQRhqEOQHIQAMDwsgAkEkakEBNgIAIAJBLGpBADYCACACQfCjwQA2AiAgAkHUlsEANgIoIAJBADYCGCABIAJBGGoQ5AchAAwOCyACQSRqQQI2AgAgAkEsakEBNgIAIAJB0KPBADYCICACQQA2AhggAkHRATYCBCACIABBBGo2AhQgAiACNgIoIAIgAkEUajYCACABIAJBGGoQ5AchAAwNCyACQSRqQQE2AgAgAkEsakEBNgIAIAJBtKPBADYCICACQQA2AhggAkHSATYCBCACIABBBGo2AhQgAiACNgIoIAIgAkEUajYCACABIAJBGGoQ5AchAAwMCyACQSRqQQE2AgAgAkEsakEBNgIAIAJBkKPBADYCICACQQA2AhggAkHTATYCBCACIABBAWo2AhQgAiACNgIoIAIgAkEUajYCACABIAJBGGoQ5AchAAwLCyACQSRqQQI2AgAgAkEsakEBNgIAIAJB8KLBADYCICACQQA2AhggAkHSATYCBCACIABBBGo2AhQgAiACNgIoIAIgAkEUajYCACABIAJBGGoQ5AchAAwKCyACQSRqQQI2AgAgAkEsakEBNgIAIAJB2KLBADYCICACQQA2AhggAkHRATYCBCACIABBBGo2AhQgAiACNgIoIAIgAkEUajYCACABIAJBGGoQ5AchAAwJCyACQSRqQQI2AgAgAkEsakEBNgIAIAJBuKLBADYCICACQQA2AhggAkHRATYCBCACIABBBGo2AhQgAiACNgIoIAIgAkEUajYCACABIAJBGGoQ5AchAAwICyACQSRqQQI2AgAgAkEsakEBNgIAIAJBkKLBADYCICACQQA2AhggAkHUATYCBCACIABBAWo2AhQgAiACNgIoIAIgAkEUajYCACABIAJBGGoQ5AchAAwHCyACQSRqQQI2AgAgAkEsakEBNgIAIAJB4KHBADYCICACQQA2AhggAkHQATYCBCACIABBCGo2AhQgAiACNgIoIAIgAkEUajYCACABIAJBGGoQ5AchAAwGCyACQQxqQdEBNgIAIAJBGGoiA0EMakEDNgIAIAJBLGpBAjYCACACIABBBGo2AhAgAkGwocEANgIgIAJBADYCGCACQdEBNgIEIAIgAEEQajYCFCACIAI2AiggAiACQRRqNgIIIAIgAkEQajYCACABIAMQ5AchAAwFCyMAQTBrIgMkAAJ/AkACQAJAAkACQAJAIABBBGoiACgCAEEBaw4FAQIDBAUACyADQSRqQQE2AgAgA0EsakEBNgIAIANBlJDDADYCICADQQA2AhggA0GBAjYCDCADIABBBGo2AhQgAyADQQhqNgIoIAMgA0EUajYCCCABIANBGGoQ5AcMBQsgA0EkakEBNgIAIANBLGpBATYCACADQfSPwwA2AiAgA0EANgIYIANBgQI2AgwgAyAAQQRqNgIUIAMgA0EIajYCKCADIANBFGo2AgggASADQRhqEOQHDAQLIANBJGpBATYCACADQSxqQQE2AgAgA0HUj8MANgIgIANBADYCGCADQYECNgIMIAMgAEEEajYCFCADIANBCGo2AiggAyADQRRqNgIIIAEgA0EYahDkBwwDCyADQSRqQQE2AgAgA0EsakEANgIAIANBtI/DADYCICADQdD4wgA2AiggA0EANgIYIAEgA0EYahDkBwwCCyADQSRqQQE2AgAgA0EsakEBNgIAIANBjI/DADYCICADQQA2AhggA0GBAjYCDCADIABBBGo2AhQgAyADQQhqNgIoIAMgA0EUajYCCCABIANBGGoQ5AcMAQsgA0EkakEBNgIAIANBLGpBADYCACADQeCOwwA2AiAgA0HQ+MIANgIoIANBADYCGCABIANBGGoQ5AcLIQAgA0EwaiQADAQLIAJBJGpBATYCACACQSxqQQA2AgAgAkH0oMEANgIgIAJB1JbBADYCKCACQQA2AhggASACQRhqEOQHIQAMAwsgAkEkakECNgIAIAJBLGpBATYCACACQbCgwQA2AiAgAkEANgIYIAJB0wE2AgQgAiAAQQFqNgIUIAIgAjYCKCACIAJBFGo2AgAgASACQRhqEOQHIQAMAgsgAkEkakEBNgIAIAJBLGpBADYCACACQfCfwQA2AiAgAkHUlsEANgIoIAJBADYCGCABIAJBGGoQ5AchAAwBCyACQSRqQQE2AgAgAkEsakEANgIAIAJBxJ/BADYCICAC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8ABqKAIAIABB1ABqKAIAIABBOGooAgAgAEEcaigCACAAKAIAIAdqampqampqaiEHIABB4AFqIQAgAkEIayICDQALCyAGRQ0AIAZBHGwhAgNAIAAoAgAgB2ohByAAQRxqIQAgAkEcayICDQALCyABQQFqIQkgAygCACIAQRhqKAIAIQYgBiAAKAIQRgRAIABBEGogBkEBEPIFCyAAQRRqKAIAIAlBHGxqIQICQCAGIAlNBEAgBiAJRg0BIAkgBhCZBwALIAJBHGogAiAGIAlrQRxsEN8KGgsgAiAINgIYIAIgBTYCFCACIAg2AhAgAiAKNgIMIAIgDTYCCCACIAo2AgQgAiAHIApqIgg2AgAgACAGQQFqNgIYIABBDGooAgAiBSAAKAIERgRAIABBBGogBUEBEJIGCyAAQQhqKAIAIAFBAXRqIQICQCABIAVPBEAgASAFRg0BIAEgBRCZBwALIAJBAmogAiAFIAFrQQF0EN8KGgsgAiAOOwEAIAAgBUEBajYCDCADIAQgC2ogCGoiATYCDAJAIAMoAgggAUYEQCADIAAoAgAiADYCECAAIAMoAgRGDQEgA0EANgIgIANBBGogA0EQaiADQRhqQbyewAAQzAcACyADQQE2AiwgA0EBNgIkIANB+JvAADYCICADQQE2AhwgA0GAnMAANgIYIANBHDYCFCADIANBEGo2AiggAyADNgIQIANBDGogA0EIaiADQRhqQayewAAQzAcACyADQTBqJAAL2woCD38BfiMAQeABayICJAAgAkEYaiIDQRBqIAFBEGooAgAiBDYCACADQQhqIAFBCGopAgA3AwAgAiABKQIANwMYIAJBEGogA0EEchDBCCACKAIUIQECQAJAAkACQAJAIAIoAhAiA0EBRgRAIAIoAhghAyACQbgBaiABEIQFIAItALgBIgENASACQdoAaiACLQC7AToAACACQaABaiIDQQhqIAJB0AFqKQMAIhE3AwAgA0EQaiACQdgBai0AACIDOgAAIAJBQGsiBUEIaiARNwMAIAVBEGogAzoAACACIAIvALkBOwFYIAIgAkHIAWopAwAiETcDoAEgAiARNwNAIAJBxAFqKAIAIQUgAikCvAEhEQwCCyADRQ0CIAFBhAFJDQIgARABDAILIAIpArwBIREgBCADNgIIIAQgETcCAAsgAkGeAWoiAyACQdoAai0AADoAACACQYgBaiIEQQhqIgYgAkFAayIHQQhqKQMANwMAIARBEGoiBCAHQRBqLQAAOgAAIAIgAi8BWDsBnAEgAiACKQNANwOIASACIAIoAhhBAWo2AhggAUUNAQsgAEEANgIIIABCgICAgBA3AgAMAQsgAkGGAWogAy0AADoAACACQfAAaiIBQQhqIAYpAwA3AwAgAUEQaiAELQAAOgAAIAIgAi8BnAE7AYQBIAIgAikDiAE3A3ACQAJAQYABQQEQ8AkiAwRAIAMgAi8BhAE7AAAgAyAFNgALIAMgETcAAyADIAIpA3A3AA8gA0ECaiACQYYBaiIJLQAAOgAAIANBF2ogAkHwAGoiAUEIaiIKKQMANwAAIANBH2ogAUEQaiILLQAAOgAAIAIgAzYCNCACQQE2AjggAkEENgIwIAJBQGsiBUEQaiACQRhqIgRBEGooAgAiATYCACAFQQhqIARBCGopAwA3AwAgAiACKQMYNwNAIAJBCGogBUEEciINEMEIIAIoAgwhBSACKAIIIgRBAUcNASACQbgBaiIEQRBqIQcgBEEBciEMQS8hCEEBIQYDQCACKAJAIQQgAkG4AWogBRCEBQJAIAItALgBIgVFBEAgAkGeAWogDEECai0AADoAACACQaABaiIBQQhqIAdBCGopAgAiETcDACABQRBqIAdBEGotAAAiAToAACACQYgBaiIEQQhqIBE3AwAgBEEQaiABOgAAIAIgDC8AADsBnAEgAiAHKQIAIhE3A6ABIAIgETcDiAEgAikCvAEhESACKALEASEEDAELIAIpArwBIREgASAENgIIIAEgETcCAAsgCSACQZ4Bai0AADoAACAKIAJBiAFqIgFBCGopAwA3AwAgCyABQRBqLQAAOgAAIAIgAi8BnAE7AYQBIAIgAikDiAE3A3AgAiACKAJAQQFqNgJAIAUNAyACQe4AaiIFIAktAAA6AAAgAkHYAGoiAUEIaiIOIAopAwA3AwAgAUEQaiIPIAstAAA6AAAgAiACLwGEATsBbCACIAIpA3A3A1ggAigCMCAGRgRAIAJBMGogBkEBEJMGIAIoAjQhAwsgAyAIaiIBQQ9rIhAgAi8BbDsAACABQQRrIAQ2AAAgAUEMayARNwAAIBBBAmogBS0AADoAACABIAIpA1g3AAAgAUEQaiAPLQAAOgAAIAFBCGogDikDADcAACACIAZBAWoiBjYCOCACKAJQIQEgAiANEMEIIAhBIGohCCACKAIEIQUgAigCACIEQQFGDQALDAELQYABQQFB8PTEACgCACIAQcoEIAAbEQAAAAsgBEUNACAFQYQBSQ0AIAUQAQsgAEEIaiACQThqKAIANgIAIAAgAikDMDcCAAsgAkHgAWokAAuZCgELfyMAQfAAayIDJAAgASgCBCIHQQRqIgQgASgCCCIKQQJ0aiIIKAIAIQwgASgCACEFIAggBCAKQQFqIglBAnRqIAcvATIiASAKQX9zakECdBDfChogByABQQFrIgg7ATICQCAIQf//A3FBBU8NAAJAAkACQCAHKAIAIgFFDQAgBUEBaiEEIAdBMGovAQAiBkUEQCABLwEyRQRAIANBKGoiAEEMakEBNgIAIABBFGpBATYCACADQcgAaiIBQQxqQQE2AgAgAUEUakEANgIAIANBmITBADYCMCADQQA2AiggA0G/ATYCHCADQbSEwQA2AlAgA0GQgsEANgJYIANBADYCSCADIANBGGo2AjggAyABNgIYIABBvITBABDaCAALIAFBOGooAgAiBi8BMiAIQf//A3FqQQtPBEAgA0EANgJgIAMgATYCXCADIAQ2AlggAyAGNgJUIAMgBTYCUCADIAc2AkwgAyAFNgJIIANByABqQQEQmgIMAgsgA0EANgJgIAMgATYCXCADIAQ2AlggAyAGNgJUIAMgBTYCUCADIAc2AkwgAyAFNgJIIANBGGogA0HIAGpBACAKEIUCDAMLIAEgBkEBayIGQQJ0akE0aigCACILLwEyIAhB//8DcWpBC08EQCADIAY2AmAgAyABNgJcIAMgBDYCWCADIAc2AlQgAyAFNgJQIAMgCzYCTCADIAU2AkggA0HIAGpBARCUAyADIAk2AiAMAgsgAyAGNgJgIAMgATYCXCADIAQ2AlggAyAHNgJUIAMgBTYCUCADIAs2AkwgAyAFNgJIIANBGGogA0HIAGpBASAKEIUCDAILIAMgCjYCIAsgAyAHNgIcIAMgBTYCGAsgAygCICEKIAMoAhghBSADKAIcIgcoAgAiAUUNACAFQQFqIQQDQCABLwEyIghBBEsNASABKAIAIgYEQCAEQQFqIQsgAUEwai8BACIJRQRAIAYvATJFBEAgA0EoaiIAQQxqQQE2AgAgAEEUakEBNgIA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LGogCkEYaikCADcCACAAQTRqIApBIGopAgA3AgAgAEE8aiAKQShqKQIANwIAIABBxABqIApBMGooAgA2AgAgACAINgJIDAULIAUhCwsgAEECNgJIIAAgCzYCCCAAIAE2AgQgACAENgIADAMLIAJBiAFqIAJB0AFqKAIAIgE2AgAgAiACKQPIASIQNwOAASAAQQhqIAE2AgAgACAQNwIAIABBAjYCSAwCCyAMIAtBpOPCABCNCgALIAYgC0G048IAEIwKAAsgAkGwBGokAAvcCQIFfwF+IwBBwAFrIgQkACAEQcwAakEANgIAIARCgICAgMAANwJEIARBADYCOCAEIAE2AkAgBEEANgIQAkADQCACIANGBEAgBEHQAGoiA0E4aiAEQRBqIgJBOGopAwA3AwAgA0EwaiACQTBqKQMANwMAIANBKGogAkEoaikDADcDACADQSBqIgEgAkEgaikDADcDACADQRhqIAJBGGopAwA3AwAgA0EQaiACQRBqKQMANwMAIANBCGoiBSACQQhqKQMANwMAIAQgBCkDECIJNwNQAkACQAJAAkAgCadBAWsOAgECAAsgBEGEAWohAwwCCyAEQYQBaiEDIARB3ABqKAIAIQYgBSgCACEFIAQoAlQhASAEQYwBaigCACICIAQoAoQBRgRAIAMgAhCIBiAEKAKMASECCyAEQYgBaigCACACQRxsaiICIAY2AhggAkIANwIMIAIgBTYCCCACIAE2AgQgAkEBNgIAIAQgBCgCjAFBAWo2AowBDAELAkAgASgCACIBRQRAIARB7ABqKAIAIQcgBEHoAGooAgAhCCAEQeQAaigCACEGIARB4ABqKAIAIQUgBEHcAGooAgAhAiAEKAJYIQEgBEGMAWooAgAiAyAEKAKEAUYEQCAEQYQBaiADEIgGIAQoAowBIQMLIARBiAFqKAIAIANBHGxqIgMgBTYCGCADIAc2AhQgAyAINgIQIAMgBjYCDCADIAI2AgggAyABNgIEIANBAjYCACAEIAQoAowBQQFqNgKMAQwBCyAEQfQAaigCACEDIARBoAFqIgJBEGogBUEQaikCADcDACACQQhqIAVBCGopAgAiCTcDACAEIAM2ArwBIAQgATYCuAEgBCAFKQIANwOgASAJpyEFIAJBDGooAgAhAiAEKAK0ASADRgRAIARBtAFqIAMQjAYgBCgC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azYCACAEQQFHDQAgARCuCAsgASACKQIYNwIAIAFBGzoAFyABQQ9qIAJBGGoiBEEPaikAADcAACABQQhqIARBCGopAgA3AgAMAwsgEUKAgICAcIMhECARpyEGIANBgH5xDAULIAQgA0H468EAEIwKAAtCACEQQQYhA0EADAMLQQAhBCABQQA6ADQgASgCMCIDRQ0ACwsgASADQQFrNgIwAkACQAJ/AkACQAJAIARB/wFxRQRAQRshBCABLQAXIgZBG0YNBUEBIAZBGGsgBkEXTRtB/wFxQQFrDgICAwELIAJBGGogAUEYahD3AiACKQIcIQ8gAigCGCEDIAItAC8iBEEbRg0FIAIgAikCJDcDCCACIAJBK2ooAAA2AA8gD0IgiKchByAPpyEFDAgLIAFBBGooAgAhBSABKAIAIgMoAgAhASADIAFBAWo2AgAgAUEASA0GQRgMAgsgAiABKQIMNwMYIAIgAUETaigAADYAHyABKAIIIQcgASgCBCEFIAEoAgAhAyAGDAELIAEoAgQhBSABKAIAIQNBGgshBCACIAIoAB82ADcgAiACKQMYNwMwCyACIAIoADc2AA8gAiACKQMwNwMIDAMLIA9CgICAgHCDIRAgD6chBiADQYB+cQshASAAQRw6ABcgACAQIAathDcCBCAAIANB/wFxIAFyNgIADAILAAsgACADNgIAIAAgAikDCDcCDCAAIAQ6ABcgAEETaiACKAAPNgAAIAAgBa0gB61CIIaENwIECyACQUBrJAALoAkCCX8BfiMAQfAAayIDJAAgAyAANgIMIAAoAgAhCQJAAkACQAJAAkACQCAAQQhqKAIAIggEQCAAQQAgCBsiBEEMaiIFKAIAQR5LDQEgA0EoaiIFQThqIAJBOGopAwA3AwAgBUEwaiACQTBqKQMANwMAIAVBKGogAkEoaikDADcDACAFQSBqIAJBIGopAwA3AwAgBUEYaiACQRhqKQMANwMAIAVBEGogAkEQaikDADcDACAFQQhqIAJBCGopAwA3AwAgAyACKQMANwMoIAQgASAFEOgBDAYLQcAAQQgQ8AkiAUUNASABIAIpAwA3AwAgAUE4aiACQThqKQMANwMAIAFBMGogAkEwaikDADcDACABQShqIAJBKGopAwA3AwAgAUEgaiACQSBqKQMANwMAIAFBGGogAkEYaikDADcDACAB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AGohAyAAQdgAayIADQALCyABKAI0RQ0AIAIQ1AELIAZB4AFqJAALtAkCCn8BfiMAQfAAayIEJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgASgCUAR+IAFB2ABqKAIAIgUgAUHUAGooAgAiB0kNASADIAVJDQwgBEEpakIANwAAIARCADcCJCABQeAAaigCACIGIAFB3ABqKAIAIghJDQIgAyAGSQ0DIAUgB2shCiACIAdqIQsgBEEVakIANwAAIARCADcCECAGIAhrIQwgAiAIaiENQgAFQgILIQ4gAEGAAWogAUEQaiACIAMQhwQgAUEsaigCACIFIAEoAigiBkkNAyADIAVJDQQgAEEBOgAcIABCADcDECAAQQA2AgAgAEEANgIYIAAgBSAGazYCCCAAIAIgBmo2AgQgAUE0aigCACIFIAEoAjAiBkkNBSADIAVJDQsgAEIANwOgAiAAQbgCaiAFIAZrNgIAIABBtAJqIAIgBmo2AgAgAEGwAmpBADYCACAAQcACakIANwMAIABBxQJqQgA3AAAgAEHQAmogASACIAMQmgYgAUE8aigCACIFIAEoAjgiCEkNBiADIAVJDQsgBEHlAGpCADcAACAEQgA3AmAgAUHEAGooAgAiBiABQUBrKAIAIglJDQcgAyAGSQ0IIARB0QBqQgA3AAAgBEIANwJMIAFBzABqKAIAIgcgAUHIAGooAgAiAUkNCSADIAdJDQogAEEAOgCwBCAAIAs2AjQgACAONwMgIAAgBCkCIDcCPCAAIA02AmQgBEE9akIANwAAIABBOGogCjYCACAAQTBqQQA2AgAgAEHoAGogDDYCACAAQeAAakEANgIAIABB0ABqQgA3AwAgAEHEAGogBEEgaiIDQQhqKQIANwIAIABBzABqIANBEGotAAA6AAAgBEIANwI4IABCADcDmAMgAEGoA2pBADYCACAAQawDaiACIAhqNgIAIABBsANqIAUgCGs2AgAgAEHIA2pCADcDACAAQdgDakEANgIAIABB3ANqIAIgCWo2AgAgAEHgA2ogBiAJazYCACAAQfwAaiAEQQxqIgNBEGotAAA6AAAgAEH0AGogA0EIaikCADcCACAAIAQpAgw3AmwgAEG0A2ogBCkCXDcCACAAQbwDaiAEQdwAaiIDQQhqKQIANwIAIABBxANqIANBEGotAAA6AAAgAEGQBGogByABazYCACAAQYwEaiABIAJqNgIAIABBiARqQQA2AgAgAEH4A2pCADcDACAAQagEakIANwMAIABB9ANqIARByABqIgFBEGotAAA6AAAgAEHsA2ogAUEIaikCADcCACAAQeQDaiAEKQJINwIAIABBlARqIAQpAjQ3AgAgAEGcBGogBEE0aiIBQQhqKQIANwIAIABBpARqIAFBEGotAAA6AAAgBEHwAGokAA8LIAcgBUHIs8IAEI4KAAsgCCAGQcizwgAQjgoACyAGIANByLPCABCNCgALIAYgBUG4+8EAEI4KAAsgBSADQbj7wQAQjQoACyAGIAVByLPCABCOCgALIAggBUHIs8IAEI4KAAsgCSAGQcizwgAQjgoACyAGIANByLPCABCNCgALIAEgB0GskcEAEI4KAAsgByADQayRwQAQjQoACyAFIANByLPCABCNCgALvAgBCn8jAEHQAWsiBSQAAkACQAJAIAAtAAwEQCAFIAQQ3gggBUE4aiAEQThqKQMANwMAIAVBMGogBEEwaikDADcDACAFQShqIARBKGopAwA3AwAgBSAEKQMgNwMgIABBBGooAgAhCyAAQQhqKAIAIgdFDQEgB0EHdCALakGAAWtBACAHGyIGLQAAQQJHDQEgBkEQaigCACEJIAYoAgggBigCBCEIIAZBMGogAhCRBkUNASADIAhJDQFBACAJGyAIaiADSQ0BIAYoAgQhASAFQZABaiIAQThqIAVBOGopAwA3AwAgAEEwaiAFQTBqKQMANwMAIABBKGogBUEoaikDADcDACAAQSBqIAVBIGopAwA3AwAgAEEYaiAFQRhqKQMANwMAIABBEGogBUEQaikDADcDACAAQQhqIAVBCGopAwA3AwAgBSAFKQMANwOQASAGQQhqIAMgAWsgABC/ASAEEIgHIAIvAQwiAEEDcUEDR0EAIABBAWsbDQMgAkEQaigCAEUNAyACQRRqKAIAENQBDAMLIAQQiAcgBEEsai8BACIAQQNxQQNHQQAgAEEBaxsNASAEQTBqKAIARQ0BIARBNGooAgAQ1AEMAQsgBUFAayABIAIQ5gEgBSgCRARAIAVB0ABqIgZBCGoiDEEANgIAIAVBkAFqIgFBOGogBUE4aikDADcDACABQTBqIAVBMGopAwA3AwAgAUEoaiAFQShqKQMANwMAIAFBIGogBUEgaikDADcDACABQRhqIgggBUEYaikDADcDACABQRBqIgkgBUEQaikDADcDACABQQhqIgogBUEIaikDADcDACAFIAUpAwA3A5ABIAZBACABEL8BIAVB8ABqIgFBCGoiDSAMKQMANwMAIAFBEGoiDCAGQRBqKQMANwMAIAFBGGoiDiAGQRhqKAIANgIAIAogAkEIaikDADcDACAJIAJBEGopAwA3AwAgCCACQRhqKQMANwMAIAUgBSkDUDcDcCAFIAIpAwA3A5ABIAAoAgAgB0YEQCAAIAcQhQYgAEEEaigCACELIABBCGooAgAhBwsgB0EHdCALaiIBIAM2AgQgAUECOgAAIAEgBSkDcDcDCCABIAUpA0A3AiQgASAFKQOQATcDMCABQRBqIA0pAwA3AwAgAUEYaiAMKQMANwMAIAFBIGogDigCADYCACABQSxqIAVByABqKAIANgIAIAFBOGogCikDADcDACABQUBrIAkpAwA3AwAgAUHIAGogCCkDADcDACAAQQhqIgAgACgCAEEBajYCACAEEIgHDAILIAUQiAcCQCAFQSxqLwEAIgBBA3FBA0dBACAAQQFrGw0AIAVBMGooAgBFDQAgBUE0aigCABDUAQsgBBCIBwsgAi8BDCIAQQNxQQNHQQAgAEEBaxsNACACQRBqKAIARQ0AIAJBFGooAgAQ1AELIAVB0AFqJAALmQoBAX8jAEEwayICJAACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAALQAAQQFrDhEBAgMEBQYHCAkKCwwNDg8QEQALIAIgAC0AAToACCACQSRqQQI2AgAgAkEsakEBNgIAIAJB4IvEADYCICACQQA2AhggAkGpAzYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahDkBwwRCyACIAApAwg3AwggAkEkakECNgIAIAJBLGpBATYCACACQcSLxAA2AiAgAkEANgIYIAJBswE2AhQgAiACQRBqNgIoIAIgAkEIajYCECABIAJBGGoQ5AcMEAsgAiAAKQMINwMIIAJBJGpBAjYCACACQSxqQQE2AgAgAkHEi8QANgIgIAJBADYCGCACQbIBNgIUIAIgAkEQajYCKCACIAJBCGo2AhAgASACQRhqEOQHDA8LIAIgACsDCDkDCCACQSRqQQI2AgAgAkEsakEBNgIAIAJBqIvEADYCICACQQA2AhggAkG+BDYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahDkBwwOCyACIAAoAgQ2AgggAkEkakECNgIAIAJBLGpBATYCACACQYiLxAA2AiAgAkEANgIYIAJBvwQ2AhQgAiACQRBqNgIoIAIgAkEIajYCECABIAJBGGoQ5AcMDQsgAiAAKQIENwMIIAJBJGpBATYCACACQSxqQQE2AgAgAkH0isQANgIgIAJBADYCGCACQcAENgIUIAIgAkEQajYCKCACIAJBCGo2AhAgASACQRhqEOQHDAwLIAJBJGpBATYCACACQSxqQQA2AgAgAkHkisQANgIgIAJBlInEADYCKCACQQA2AhggASACQRhqEOQHDAsLIAJBJGpBATYCACACQSxqQQA2AgAgAkHQisQANgIgIAJBlInEADYCKCACQQA2AhggASACQRhqEOQHDAoLIAJBJGpBATYCACACQSxqQQA2AgAgAkG8isQANgIgIAJBlInEADYCKCACQQA2AhggASACQRhqEOQHDAkLIAJBJGpBATYCACACQSxqQQA2AgAgAkGoisQANgIgIAJBlInEADYCKCACQQA2AhggASACQRhqEOQHDAgLIAJBJGpBATYCACACQSxqQQA2AgAgAkGQisQANgIgIAJBlInEADYCKCACQQA2AhggASACQRhqEOQHDAcLIAJBJGpBATYCACACQSxqQQA2AgAgAkGAisQANgIgIAJBlInEADYCKCACQQA2AhggASACQRhqEOQHDAYLIAJBJGpBATYCACACQSxqQQA2AgAgAkH0icQANgIgIAJBlInEADYCKCACQQA2AhggASACQRhqEOQHDAULIAJBJGpBATYCACACQSxqQQA2AgAgAkHoicQANgIgIAJBlInEADYCKCACQQA2AhggASACQRhqEOQHDAQLIAJBJGpBATYCACACQSxqQQA2AgAgAkHUicQANgIgIAJBlInEADYCKCACQQA2AhggASACQRhqEOQHDAMLIAJBJGpBATYCACACQSxqQQA2AgAgAkG8icQANgIgIAJBlInEADYCKCACQQA2AhggASACQRhqEOQHDAILIAJBJGpBATYCACACQSxqQQA2AgAgAkGkicQANgIgIAJBlInEADYCKCACQQA2AhggASACQRhqEOQHDAEL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IQFFBEAgAUGEAU8EQCABEAELIAAgATYCBCAAQQM2AgAMAQsgBCABNgIcIAQgBEEcaiIBEPUKNgJQIARBQGsiAiAEQdAAahCeCSAEIAEQ9go2AlQgBEEwaiIBIARB1ABqEJ4JIARB7ABqIAJBCGooAgA2AgAgBEH4AGogAUEIaigCADYCACAEQQA2AmAgBEIANwNYIAQgBCkDQDcCZCAEIAQpAzA3A3AgBEEgaiEJIwBBwAFrIgMkACADQThqIgJBIGogBEHYAGoiAUEgaigCADYCACACQRhqIgUgAUEYaikCADcDACACQRBqIAFBEGopAgA3AwAgAkEIaiABQQhqKQIANwMAIAMgASkCADcDOCADQTBqIANBxABqEMEIAkACQAJAAkACQAJAAkAgAygCMEUNACADKAI0IQEgA0EoaiAFEMEIIAMoAigNASABQYQBSQ0AIAEQAQsgCUEANgIIIAlCgICAgMAANwIADAELIAMoAiwhBiADQSBqIAEQBCADKAIgIgVFDQMgAygCJCECIAMgBTYCnAEgAyACNgKgASADIAI2ApgBIANB8ABqIgJBBHIiBSADQZgBaiIIKQIANwIAIAVBCGogCEEIaigCADYCACACQRBqIAY2AgAgAUGEAU8EQCABEAELQQQgA0HIAGooAgAiASADKAJEayICQQAgASACTxsiASADQdQAaigCACICIAMoAlBrIgZBACACIAZPGyICIAEgAkkbQQFqIgFBfyABGyIBIAFBBE0bIgZB////P0sNAiAGQQR0IghBAEgNAiAGQYCAgMAASUECdCECIAgEfyAIIAIQ8AkFIAILIgFFDQEgASAFKQIANwIAIAFBCGogBUEIaikCADcCACADQQE2AmggAyABNgJkIAMgBjYCYCADQfAAaiICQSBqIANBOGoiBUEgaigCADYCACACQRhqIgogBUEYaikDADcDACACQRBqIAVBEGopAwA3AwAgAkEIaiAFQQhqKQMANwMAIAMgAykDODcDcCADQRhqIANB/ABqIgsQwQgCQCADKAIYRQ0AIANBmAFqQQRyIQYgAygCHCECQRAhCEEBIQUDQCADQRBqIAoQwQggAygCEEUEQCACQYQBSQ0CIAIQAQwCCyADKAIUIQwgA0EIaiACEAQCQAJAIAMoAggiDQRAIAMoAgwhByADIA02ArQBIAMgBzYC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BkkNCSADIARJDQogAEEBOgAcIABCADcDECAAQQA2AgAgAEEANgIYIAAgBCAGazYCCCAAIAIgBmo2AgQgAEG4A2ogAUEQaiACIAMQmgYgAEGABGohBAJAAkACQAJAIAFByABqIgEoAgQiBiABKAIAIgdPBEAgAyAGSQ0QIARBADYCECAEQgA3AwAgBEEYaiAGIAdrNgIAIARBFGogAiAHajYCACAEQSBqQgA3AwAgBEElakIANwAAIAFBDGooAgAiBiABKAIIIgdJDQEgAyAGSQ0QIARCADcDMCAEQcgAaiAGIAdrNgIAIARBxABqIAIgB2o2AgAgBEFAa0EANgIAIARB0ABqQgA3AwAgBEHVAGpCADcAACABQRRqKAIAIgYgASgCECIBSQ0CIAMgBkkNAyAEQgA3A2AgBEH4AGogBiABazYCACAEQfQAaiABIAJqNgIAIARB8ABqQQA2AgAgBEGAAWpCADcDACAEQYUBakIANwAAIARBkAFqQgA3AwAMBAsgByAGQcizwgAQjgoACyAHIAZByLPCABCOCgALIAEgBkGskcEAEI4KAAsgBiADQayRwQAQjQoACyAAQegCaiAKIAxrNgIAIABB5AJqIAIgDGo2AgAgAEHgAmpBADYCACAAQgA3A9ACIABBmANqIAsgDWs2AgAgAEGUA2ogAiANajYCACAAQZADakEANgIAIABBgANqQgA3AwAgAEHsAmogBSkDIDcCACAAQfQCaiAFQSBqIgFBCGopAwA3AgAgAEH8AmogAUEQai0AADoAACAAQZwDaiAFKQIMNwIAIABBpANqIAVBDGoiAUEIaikCADcCACAAQawDaiABQRBqLQAAOgAAIABCADcDoAIgAEGwA2pCADcDACAAQbACakEANgIAIABBtAJqIAIgDmo2AgAgAEG4AmogCCAOazYCACAAIBI3AyAgAEEwakEANgIAIAAgEDYCNCAAQThqIA82AgAgAEG8AmogBSkCNDcCACAAQcQCaiAFQTRqIgFBCGopAgA3AgAgAEHMAmogAUEQai0AADoAACAAIAUpAlw3AjwgAEHEAGogBUHcAGoiAUEIaikCADcCACAAQcwAaiABQRBqLQAAOgAAIABB6ABqIBE2AgAgACAJNgJkIABB4ABqQQA2AgAgAEHQAGpCADcDACAAIAUpAkg3AmwgAEH0AGogBUHIAGoiAUEIaikCADcCACAAQfwAaiABQRBqLQAAOgAAIAVB8ABqJAAPCyAMIApByLPCABCOCgALIAogA0HIs8IAEI0KAAsgDSALQayRwQAQjgoACyALIANBrJHBABCNCgALIA4gCEHIs8IAEI4KAAsgCCADQcizwgAQjQoACyAHIARByLPCABCOCgALIAQgA0HIs8IAEI0KAAsgCSAGQcizwgAQjgoACyAGIARBuPvBABCOCgALIAQgA0G4+8EAEI0KAAsgBiADQcizwgAQjQoAC/oGAQV/IABBCGsiACgCBEF4cSECIAAgAmohAQJAAkACQCAAKAIEQQFxDQAgACgCACEDAkAgAC0ABEEDcQRAIAIgA2ohAiAAIANrIgBB0PjEACgCAEcNASABKAIEQQNxQQNHDQJByPjEACACNgIAIAEgASgCBEF+cTYCBCAAIAJBAXI2AgQgACACaiACNgIADwsMAgsgA0GAAk8EQCAAEIIFDAELIABBDGooAgAiBCAAQQhqKAIAIgVHBEAgBSAENgIMIAQgBTYCCAwBC0HA+MQAQcD4xAAoAgBBfiADQQN2d3E2AgALAkAgAS0ABEECcUEBdgRAIAEgASgCBEF+cTYCBCAAIAJBAXI2AgQgACACaiACNgIADAELAkACQAJAQdT4xAAoAgAgAUcEQCABQdD4xAAoAgBHDQFB0PjEACAANgIAQcj4xABByPjEACgCACACaiIBNgIAIAAgAUEBcjYCBCAAIAFqIAE2AgAPC0HU+MQAIAA2AgBBzPjEAEHM+MQAKAIAIAJqIgE2AgAgACABQQFyNgIEIABB0PjEACgCAEYNAQwCCyABKAIEQXhxIgMgAmohAgJAIANBgAJPBEAgARCCBQwBCyABQQxqKAIAIgQgAUEIaigCACIBRwRAIAEgBDYCDCAEIAE2AggMAQtBwPjEAEHA+MQAKAIAQX4gA0EDdndxNgIACyAAIAJBAXI2AgQgACACaiACNgIAIABB0PjEACgCAEcNAkHI+MQAIAI2AgAMAwtByPjEAEEANgIAQdD4xABBADYCAAtB4PjEACgCACABTw0BQdT4xAAoAgBFDQFBACECAkBBzPjEACgCAEEoTQ0AQdT4xAAoAgAhAUGo9sQAIQACQANAIAEgACgCAE8EQCAAKAIAIAAoAgRqIAFLDQILIAAoAggiAA0AC0EAIQALIAAoAgxBAXENACAAQQxqKAIAGgsQlwUNAUHM+MQAKAIAQeD4xAAoAgBNDQFB4PjEAEF/NgIADwsgAkGAAkkNASAAIAIQ/ARB6PjEAEHo+MQAKAIAQQFrIgA2AgAgAA0AEJcFGg8LDwsgAkF4cUG49sQAaiEBAn9BwPjEACgCACIDQQEgAkEDdnQiAnEEQCABKAIIDAELQcD4xAAgAiADcjYCACABCyECIAEgADYCCCACIAA2AgwgACABNgIMIAAgAjYCCAuXCQECfyMAQZABayIDJAAgAyACLwEAOwEQIAMgAigCBCICNgIYAkACQAJAAkAgASADQRBqEKADIgEEQCADQYABNgIcIANBCGogASADQRxqIANBGGoQqAggAygCDCECAkACQAJAAkACQAJAIAMoAggEQCADQQA2AlAgA0KAgICAEDcDSCADQSBqIgFBAzoAICABQoCAgICABDcCGCABQQA2AhAgAUEANgIIIAFBvIHAADYCBCABIANByABqNgIAIANB+ABqIgQgAy0AECADLQAREPkBIANB5ABqQQE2AgAgA0HsAGpBATYCACADQQE2AnQgA0Gs3sAANgJgIANBADYCWCADIAQ2AnAgAyADQfAAajYCaCABIANB2ABqEOQHIAMoAngEQCADKAJ8ENQBC0UNAQwLCyADKAIcIgFBhAFPBEAgARABCyADIAI2AiAgA0EgahCECiADKAIgIQJFDQEgAyACNgJIIANB2IPAAEEOEPgKNgJ4IANBIGogA0HIAGogA0H4AGogA0EYahCTAiADLQAgIgJBHEcNAiADQeaDwABBDRD4CjYCWCADQSBqIANByABqIANB2ABqIAMtABAgAy0AERD0ASADLQAgIgJBHEcNAyAAIAMoAkg2AgQgAEEcOgAAIAMoAlgiAEGEAU8EQCAAEAELIAMoAngiAEGEAUkNBSAAEAEMBQsgACADKQNINwIIIABBEGogA0HQAGooAgA2AgAgACACNgIEIABBFzoAACADKAIcIgBBhAFJDQcgABABDAcLIANBADYCUCADQoCAgIAQNwNIIANBIGoiAUEDOgAgIAFCgICAgIAENwIYIAFBADYCECABQQA2AgggAUG8gcAANgIEIAEgA0HIAGo2AgAgA0H4AGoiBCADLQAQIAMtABEQ+QEgA0HkAGpBATYCACADQewAakEBNgIAIANBATYCdCADQazewAA2AmAgA0EANgJYIAMgBDYCcCADIANB8ABqNgJoIAEgA0HYAGoQ5AcgAygCeARAIAMoAnwQ1AELRQ0CDAgLIAAgAykAITcAASAAQSBqIANBIGoiAUEgaikAADcAACAAQRlqIAFBGWopAAA3AAAgAEERaiABQRFqKQAANwAAIABBCWogAUEJaikAADcAACAAIAI6AAAMBAsgACADKQAhNwABIABBIGogA0EgaiIBQSBqKQAANwAAIABBGWogAUEZaikAADcAACAAQRFqIAFBEWopAAA3AAAgAEEJaiABQQlqKQAANwAAIAAgAjoAACADKAJYIgBBhAFJDQMgABABDAMLIANB4wBqIANB0ABqKAIANgAAIAMgAykDSDcAWyAAQRY6AAAgACADKQBYNwABIABBCGogA0HfAGopAAA3AAAgAkGEAUkNACACEAELIAMoAhgiAEGEAUkNAyAAEAEMAwsgAEEcOgAAIAAgAjYCBAwCCyADKAJ4IgBBhAFPBEAgABABCyADKAJIIgBBhAFJDQAgABABCyADKAIYIgBBhAFJDQAgABABCyADQZABaiQADwtB1IHAAEE3IANBiAFqQYyCwABB6ILAABCHBwAL9QgCEH8BfiMAQRBrIgokACABQSRqKAIAIQ8gASgCICEQQQshBQJAAkACQAJAAkACQAJAAkACQEEDIAEtAAAiBkEKayAGQQlNG0H/AXFBAWsOAwMBAgALIAEtAAEhDEEKIQUMAgsgASkDCCISQiCIpyEDIBKnIQRBDCEFDAELQQkhBQJAAkACQAJAAkACQAJAAkACQAJAIAZBAWsOCQECAwQFBgcICQALIAFBCGooAgAhBwJAIAFBDGooAgAiA0UEQEEBIQQMAQsgA0EATiICRQ0LIAMgAhDwCSIERQ0PCyAEIAcgAxDgChpBACEFIAMhBwwIC0EBIQUCQAJAAkBBASABQRtqLQAAIgJBGGsgAkEXTRtB/wFxQQFrDgIBAgALIAFBBGooAgAiBygCACEGIAcgBkEBajYCACAGQQBIDQwgAUEIaigCACEEQRghAgwJCyABQRhqLwEAIAFBGmotAABBEHRyIQggAUEQaikDACESIAFBDGooAgAhAyABQQhqKAIAIQQgASgCBCEHDAgLIAFBCGooAgAhBCABKAIEIQdBGiECDAcLIAEoAgwhAyABKAIIIQRBAiEFDAYLIAEoAgwhAyABKAIIIQRBAyEFDAULIAEpAwgiEkIgiKchAyASpyEEQQQhBQwECyABQRhqKAIAIghBGHYhAiABQRBqKQMAIRIgASgCDCEDIAEoAgghBEEFIQUMAwsgASgCDCEDIAEoAgghBEEGIQUMAgsgAS0AASEMQQchBQwBC0EIIQUgAUEIaigCACEHIAEtAAEhDAJAIAFBDGooAgAiA0UEQEEBIQQMAQsgA0EATiICRQ0DIAMgAhDwCSIERQ0HCyAEIAcgAxDgChogAyEHCyAIQf///wdxIAJBGHRyIRELIApBCGogAUHIAGooAgA2AgAgCiABKQJANwMAIAFBLGooAgAhDUEEIQ5BACEIQQAhAkEEIQYgAUEwaigCACILBEAgC0H/////AEsNASALQQN0IgJBAEgNASALQYCAgIABSUECdCEJIAIEfyACIAkQ8AkFIAkLIgZFDQMLIAYgDSACEOAKIQ0gAUE4aigCACEGIAFBPGooAgAiAgRAIAJB/////wBLDQEgAkEDdCIIQQBIDQEgAkGAgICAAUlBAnQhCSAIBH8gCCAJEPAJBSAJCyIORQ0ECyAOIAYgCBDgCiEGIABBJGogDzYCACAAIBA2AiAgACARNgIYIAAgEjcDECAAIAc2AgQgACAMOgABIAAgBToAACAAQTxqIAI2AgAgAEE4aiAGNgIAIAAgAjYCNCAAQTBqIAs2AgAgAEEsaiANNgIAIAAgCzYCKCAAIAopAwA3AkAgAEHIAGogCkEIaigCADYCACAAIAEtAEw6AEwgACAErSADrUIghoQ3AwggCkEQaiQADwsQxwgACwALIAIgCUHw9MQAKAIAIgBBygQgABsRAAAACyAIIAlB8PTEACgCACIAQcoEIAAbEQAAAAsgAyACQfD0xAAoAgAiAEHKBCAAGxEAAAAL7AgBA38jAEFAaiICJAACfwJAAkACQAJAAkACQAJAAkACQAJAQQkgAC0AACIDQRNrIANBEk0bQf8BcUEBaw4JAQIDBAUGBwgJAAsgAiAAQQRqNgIMIAIgAEEIajYCJCACQShqIgBBDGpBAjYCACACQTxqQQI2AgAgAkEQaiIDQQxqQesANgIAIAJBuOXAADYCMCACQQA2AiggAkHrADYCFCACIAM2AjggAiACQSRqNgIYIAIgAkEMajYCECABIAAQ5AcMCQsgAiAAQQRqNgIMIAJBKGoiA0EMakECNgIAIAJBPGpBAjYCACACQRBqIgRBDGpB6wA2AgAgAkGI6cAANgIwIAJBADYCKCACQYsBNgIUIAIgAEEIajYCJCACIAQ2AjggAiACQQxqNgIYIAIgAkEkajYCECABIAMQ5AcMCAsgAkE0akEBNgIAIAJBPGpBATYCACACQejowAA2AjAgAkEANgIoIAJBjAE2AhQgAiAAQQRqNgIkIAIgAkEQajYCOCACIAJBJGo2AhAgASACQShqEOQHDAcLIAJBNGpBAjYCACACQTxqQQE2AgAgAkG46MAANgIwIAJBADYCKCACQYsBNgIUIAIgAEEEajYCJCACIAJBEGo2AjggAiACQSRqNgIQIAEgAkEoahDkBwwGCyACIABBBGo2AgwgAkEoaiIDQQxqQQI2AgAgAkE8akECNgIAIAJBEGoiBEEMakHrADYCACACQfTnwAA2AjAgAkEANgIoIAJBiwE2AhQgAiAAQQhqNgIkIAIgBDYCOCACIAJBDGo2AhggAiACQSRqNgIQIAEgAxDkBwwFCyACIABBBGo2AgwgAkEoaiIDQQxqQQI2AgAgAkE8akECNgIAIAJBEGoiBEEMakHrADYCACACQfzkwAA2AjAgAkEANgIoIAJBiwE2AhQgAiAAQQhqNgIkIAIgBDYCOCACIAJBDGo2AhggAiACQSRqNgIQIAEgAxDkBwwECwJAAkACQCAAKAIEQQFrDgIBAgALIAJBNGpBATYCACACQTxqQQA2AgAgAkHI38AANgIwIAJBgNTAADYCOCACQQA2AiggASACQShqEOQHDAULIAJBNGpBATYCACACQTxqQQA2AgAgAkGw38AANgIwIAJBgNTAADYCOCACQQA2AiggASACQShqEOQHDAQLIAJBNGpBATYCACACQTxqQQA2AgAgAkGQ38AANgIwIAJBgNTAADYCOCACQQA2AiggASACQShqEOQHDAMLIAIgAEEEajYCJCACQTRqQQE2AgAgAkE8akEBNgIAIAJByOfAADYCMCACQQA2AiggAkHrADYCFCACIAJBEGo2AjggAiACQSRqNgIQIAEgAkEoahDkBwwCCyACIABBBGo2AiQgAkE0akEBNgIAIAJBPGpBATYCACACQZznwAA2AjAgAkEANgIoIAJB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BAJAAkACQAJAIAFB+AFqIhMoAgAiBSATKAIEIghNBEAgAiAISQ0BIARBADYCECAEQgA3AwAgBEEYaiAIIAVrNgIAIARBFGogBSAGajYCACAEQSBqQgA3AwAgBEElakIANwAAIBNBDGooAgAiCCATKAIIIgVJDQIgAiAISQ0DIARCADcDMCAEQcgAaiAIIAVrNgIAIARBxABqIAUgBmo2AgAgBEFAa0EANgIAIARB0ABqQgA3AwAgBEHVAGpCADcAACAEQeAAakIANwMADAQLIAUgCEHIs8IAEI4KAAsgCCACQcizwgAQjQoACyAFIAhBrJHBABCOCgALIAggAkGskcEAEI0KAAsgAEH4AmogAUGIAmogBiACEJoGIAAgCSAPazYCGCAAIAYgD2o2AhQgAEEANgIQIABCADcDACAAQYABaiAKIBBrNgIAIABB/ABqIAYgEGo2AgAgAEH4AGpBADYCACAAQgA3A2ggACADKQIANwIcIABBJGogA0EIaikCADcCACAAQSxqIANBEGotAAA6AAAgAEGEAWogAykCFDcCACAAQYwBaiADQRRqIgFBCGopAgA3AgAgAEGUAWogAUEQai0AADoAACAAQZgBakIANwMAIABBsAFqQQA2AgAgAEGgAWpCADcDACAAQbQBaiAGIBFqNgIAIABBuAFqIAsgEWs2AgAgAEHoAWpBADYCACAAQdABakIANwMAIABB2AFqQgA3AwAgAEHsAWogBiASajYCACAAQfABaiAMIBJrNgIAIABBvAFqIAMpAig3AgAgAEHEAWogA0EoaiIBQQhqKQIANwIAIABBzAFqIAFBEGotAAA6AAAgAEGEAmogA0E8aiIBQRBqLQAAOgAAIABB/AFqIAFBCGopAgA3AgAgAEH0AWogAykCPDcCACAAQRs6AEcgAEGIAmpCADcDACAAQdAAaiAONgIAIABBzABqIA02AgAgAEHIAGogBzYCACAAQdgAakIANwMAIABB3QBqQgA3AAAgA0HQAGokAA8LIAUgAkGQqMIAEI4KAAsgAiAHQZCowgAQjQoACyAPIAlByLPCABCOCgALIAkgAkHIs8IAEI0KAAsgECAKQayRwQAQjgoACyAKIAJBrJHBABCNCgALIBEgC0GskcEAEI4KAAsgCyACQayRwQAQjQoACyASIAxBrJHBABCOCgALIAwgAkGs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AigCECIDKAIAIQEgAyABQQFrNgIAIAFBAUcNACACQRBqEK4IC0ECIQZBASEBCyAAEP0EIAAgATYCBCAAIAY2AgAgAEEIaiIAIAIpAhA3AgAgAEEIaiACQRBqIgFBCGopAgA3AgAgAEEQaiABQRBqKQIANwIAIABBGGogAUEYaikCADcCACACQUBrJAAPC0EYQQRB8PTEACgCACIAQcoEIAAbEQAAAAuZEQINfwR+IwBBgAFrIgMkACADQdgAaiABIAIQ+wICQCADLQBYIgJBE0YEQCADKAJcIQQgA0HgAGoiBigCACEFIANBBHIiAiABQZgBajYCCCACIAU2AgQgAiAENgIAIAYgA0EMaigCADYCACADIAMpAgQ3A1gjAEGAAWsiAiQAIAJBADYCCCACQoCAgICAATcDACACQRBqIgFBCGogA0HYAGoiBEEIaigCADYCACACIAQpAgA3AxAgAkEgaiABEMMBAkACQCACLwEsIgRBA0YNAAJAAn8gAi0ATEUEQCACKAJAIQYgAigCNCEFIAIoAjAhByACQcQAaigCAAwBCyACQfAAaiEGIAJBQGshBQNAIAYgBSkDADcDACACQdAAaiIBQRhqIgggAkEgaiIEQRhqKQMANwMAIAFBEGoiDCAEQRBqKQMANwMAIAFBCGoiCSAEQQhqKQMANwMAIAZBCGogBUEIaigCADYCACACIAIpAyA3A1AgAigCCCIBIAIoAgBGBEAjAEEgayIEJAACQAJAIAFBAWoiAUUNAEEEIAIoAgAiB0EBdCIKIAEgASAKSRsiASABQQRNGyIBQTBsIQogAUGr1aoVSUEDdCELAkAgBwRAIARBCDYCGCAEIAdBMGw2AhQgBCACQQRqKAIANgIQDAELIARBADYCGAsgBCAKIAsgBEEQahDKBiAEKAIEIQcgBCgCAEUEQCACIAE2AgAgAkEEaiAHNgIADAILIARBCGooAgAiAUGBgICAeEYNASABRQ0AIAcgAUHw9MQAKAIAIgBBygQgABsRAAAACxDHCAALIARBIGokACACKAIIIQELIAIoAgQgAUEwbGoiBCACKQNQNwMAIARBCGogCSkDADcDACAEQRBqIAwpAwA3AwAgBEEYaiAIKQMANwMAIARBIGogAkHQAGoiB0EgaikDADcDACAEQShqIAdBKGopAwA3AwAgAiABQQFqNgIIIAJBIGogAkEQahDDASACLwEsIgRBA0YNAiACLQBMDQALIAIoAjAhByACKAI0IQUgAigCQCEGIAIoAkQLIQEgAEEANgIEAkAgAUUNACAGRQ0AIAEQ1AELAkAgBEEDcSIAQQNHQQAgAEEBaxsNACAHRQ0AIAUQ1AELIAIoAggiAARAIABBMGwhASACKAIEQRRqIQQDQAJAIARBCGsvAQAiAEEDcUEDR0EAIABBAWsbDQAgBEEEaygCAEUNACAEKAIAENQBCwJAIARBEGooAgAiAEUNACAEQQxqKAIARQ0AIAAQ1AELIARBMGohBCABQTBrIgENAAsLIAIoAgBFDQIgAigCBBDUAQwCCyACKAIIIgFBAkkNACABQQF2IQYgAigCBCIEIAFBMGxqQTBrIQEDQCAEKQMAIRAgBCABKQMANwMAIAJB0ABqIgVBKGoiByAEQShqIggpAwA3AwAgBUEgaiIMIARBIGoiCSkDADcDACAFQRhqIgogBEEYaiILKQMANwMAIAVBEGoiDyAEQRBqIg0pAwA3AwAgBUEIaiIFIARBCGoiDikDADcDACAIIAFBKGoiCCkDADcDACAJIAFBIGoiCSkDADcDACALIAFBGGoiCykDADcDACANIAFBEGoiDSkDADcDACAOIAFBCGoiDikDADcDACACIBA3A1AgCCAHKQMANwMAIAkgDCkDADcDACALIAopAwA3AwAgDSAPKQMANwMAIA4gBSkDADcDACABIAIpA1A3AwAgAUEwayEBIARBMGohBCAGQQFrIgYNAAsLIAAgAikDADcCACAAQQhqIAJBCGooAgA2AgALIAJBgAFqJAAMAQsgA0EQaiADKQNoIhA3AwAgA0EYaiADQdgAaiIBQRhqIgQpAwAiETcDACADQSBqIAFBIGoiBikDACISNwMAIANBCGogAykDYCITNwMAIAMgAy0AWzoAAyADIAMvAFk7AAEgAyADKAJcNgIEIAMgAjoAACAGIBI3AwAgBCARNwMAIAFBEGogEDcDACABQQhqIBM3AwAgAyADKQMANwNYIANBkgE2AjwgAyABNgI4IANBATYCVCADQQE2AkwgA0GU4MAANgJIIANBADYCQCADIANBOGo2AlAgA0EoaiADQUBrELcDIAMoAiggAygCLCICIAMoAjAQAiEEBEAgAhDUAQsgAyAENgJAIANBQGsQ8QogAygCQCIBQYQBTwRAIAEQAQsgAEEANgIEAkACQAJAAkACQAJAAkAgAy0AWEEBaw4OAAEHBwIHBwcDBAcHBQYHCyADLQBcQQNHDQYgA0HgAGooAgAiACgCACAAKAIEKAIAEQMAIAAoAgQiAUEEaigCAARAIAFBCGooAgAaIAAoAgAQ1AELIAMoAmAQ1AEMBgsgAy8BXEUNBSADQeAAaigCAEUNBSADQeQAaigCABDUAQwFCyADKAJcRQ0EIANB4ABqKAIAENQBDAQLIAMoAlxFDQMgA0HgAGooAgAQ1AEMAwsgAygCXEUNAiADQeAAaigCABDUAQwCCyADKAJcBEAgA0HgAGooAgAQ1AELIAMoAmhFDQEgA0HsAGooAgAQ1AEMAQsCQAJAAkACQCADKAJcDgUAAQIEAwQLIANB4ABqKAIAIANB5ABqIgAoAgAoAgARAwAgACgCACIAQQRqKAIARQ0DIABBCGooAgAaIAMoAmAQ1AEMAwsgA0HgAGooAgAgA0HkAGoiACgCACgCABEDACAAKAIAIgBBBGooAgBFDQIgAEEIaigCABogAygCYBDUAQwCCyADQeAAaigCACADQeQAaiIAKAIAKAIAEQMAIAAoAgAiAEEEaigCAEUNASAAQQhqKAIAGiADKAJgENQBDAELIANB4ABqKAIAIANB5ABqIgAoAgAoAgARAwAgACgCACIAQQRqKAIARQ0AIABBCGooAgAaIAMoAmAQ1AELIANBgAFqJAALyAcBB38jAEEQayIDJAACQEH4AEEEEPAJIgIEQCACIAEoAmwEfyABQfwAaigCACEEIAFB+ABqKAIAIQYgAUH0AGooAgAhBSABQfAAaigCAAVBAAs2AgAgAiAFNgIEIAJBATYCCCACIAY2AgwgAkH0AGpB1gA2AgAgAiABKQIQNwJsIAJBEGogBDYCACACQRRqQQI2AgAgAkEgakERNgIAIAJBLGpBEzYCACACQThqQRU2AgAgAkHEAGpBITYCACACQdAAakEjNgIAIAJB3ABqQTQ2AgAgAkHoAGpBwgA2AgAgAiABKQJANwJgIAIgASkCODcCVCACIAEpAgg3AkggAiABKQIANwI8IAIgASkCIDcCGCACIAFBMGopAgA3AjAgAiABQShqKQIANwIkQQohBSADQQo2AgggAyACNgIEIANBCjYCAAJAAkAgAUEYaigCACIEIAFBHGooAgAiB08EQCABQcwAaigCACEHIAEoAkghBAwBCyADQQoQgwYgAygCBCADKAIIQQxsaiICQdcANgIIIAIgBzYCBCACIAQ2AgAgAyADKAIIQQFqIgI2AgggAUHMAGooAgAhByABKAJIIQQgAygCACIFIAJHDQELIAMgBRCDBiADKAIIIQILIAMoAgQgAkEMbGoiAkGAATYCCCACIAc2AgQgAiAENgIAIAMgAygCCEEBaiIFNgIIIAFB0ABqKAIAIgIgAUHUAGooAgAiBE8NASABQdwAaigCACEHIAFB2ABqKAIAIQYgAygCACAFa0EBTQRAIAMgBUECEPkFIAMoAgghBQsgAygCBCAFQQxsaiIBQYMBNgIUIAEgBzYCECABIAY2AgwgAUGBATYCCCABIAQ2AgQgASACNgIAIAMgBUECaiIFNgIIDAELQfgAQQRB8PTEACgCACIAQcoEIAAbEQAAAAsgAygCACEHIAMoAgQiBCEBAkAgBUUNAAJ/IAQiAiAFQQxsQQxrIgZBDG5BAXENABogBEEMaiECIAQgASgCACIIIAEoAgQiAU8NABogBCABNgIEIAQgCDYCACAEQQxqCyEBIAZBDEkNACAEIAVBDGxqIQUDQCACKAIAIgYgAigCBCIISQRAIAEgAigCCDYCCCABIAg2AgQgASAGNgIAIAFBDGohAQsgAkEMaigCACIGIAJBEGooAgAiCEkEQCABIAJBFGooAgA2AgggASAINgIEIAEgBjYCACABQQxqIQELIAUgAkEYaiICRw0ACwsgACAENgIEIAAgBzYCACAAIAEgBGtBDG42AgggA0EQaiQAC/wGAQd/IwBBQGoiAyQAAkACQAJAAkACQAJAAkAgAEEMaiIFKAIAIgRBHk0EQAJAIABBGGooAgAiBwRAIAdBHGwhCCAAQRRqKAIAIQRBACEFAkADQCAEKAIAIAVqIgkgAU8NASAJQQFqIQUgBEEcaiEEIAZBAWohBiAIQRxrIggNAAsMCgsgBiAHTw0DIARBDGooAgBBHksNASADQThqIAJBOGopAwA3AwAgA0EwaiACQTBqKQMANwMAIANBKGogAkEoaikDADcDACADQSBqIAJBIGopAwA3AwAgA0EYaiACQRhqKQMANwMAIANBEGogAkEQaikDADcDACADQQhqIAJBCGopAwA3AwAgAyACKQMANwMAIAQgASAFayADEOgBDAcLIAAgACgCAEEBajYCACAAKAIEIARGDQMMBQsgACAGEJ0BAkAgAEEYaigCACIHBEAgAEEUaigCACEEIAdBHGwhCEEAIQZBACEFA0AgBCgCACAGaiIJIAFPDQIgCUEBaiEGIARBHGohBCAFQQFqIQUgCEEcayIIDQALCwwICyAFIAdPDQMgA0E4aiACQThqKQMANwMAIANBMGogAkEwaikDADcDACADQShqIAJBKGopAwA3AwAgA0EgaiACQSBqKQMANwMAIANBGGogAkEYaikDADcDACADQRBqIAJBEGopAwA3AwAgA0EIaiACQQhqKQMANwMAIAMgAikDADcDACAEIAEgBmsgAxDoAQwFC0GQncAAQSFBtJ3AABCeCAALIAYgB0HEncAAEJwHAAsgAEEEaiAEQQEQ9wUMAQsgBSAHQdSdwAAQnAcACyAAQQhqKAIAIAFBBnRqIQACQCABIARPBEAgASAERg0BIAEgBBCZBwALIABBQGsgACAEIAFrQQZ0EN8KGgsgACACKQMANwMAIABBOGogAkE4aikDADcDACAAQTBqIAJBMGopAwA3AwAgAEEoaiACQShqKQMANwMAIABBIGogAkEgaikDADcDACAAQRhqIAJBGGopAwA3AwAgAEEQaiACQRBqKQMANwMAIABBCGogAkEIaikDADcDAAwBCyAAKAIAIQQgACEFCyAFIARBAWo2AgAgA0FAayQADwsgA0EMakEBNgIAIANBFGpBADYCACADQficwAA2AgggA0Gkm8AANgIQIANBADYCACADQYCdwAAQ2ggAC9ccAhF/AX4jAEHAAWsiByQAIAFBgAFqIhIgAhCAAyEVIAcQIiITNgIEAkAgFQRAIAdBKGohFEEAIRMDQAJAIAMEQCAHQQhqIQggA0EEaigCACEJIANBCGooAgAhCkEAIREjAEGgA2siBSQAIAVB+ABqIgZBADYCBCAGIBM2AgAgBUGoAmogEiACEPsCAkACQAJAAkACQAJAAkAgBS0AqAIiD0ETRgRAIAUgBSkCrAI3A4gBIAVBkAFqIBIgCSAKEOMJIAUoAnxFDQFBCCEKIAVBsAFqIgZBCGogBUGAAWooAgA2AgAgBSAFKQN4NwOwASAFQQhqIBJByAFqIAYQgwVBACEQQQAhDyAFKAIIIglBAUYEQCAFKAIMIQogBUHAAWoiDEEIaiAFQZgBaikDADcDACAFIAUpA5ABNwPAASAFQagCaiIGIAogDBC1CCAMIBJBmAFqIAVBiAFqIAYQwgIgBUHcAWooAgAiDkHQAGwhDSAFQdgBaigCACEMIAUoAtQBIQZBCCEPIA4EQCANQbD///95Sw0IIA5BBnQiCkEASA0IIAogDUGx////eUlBA3QiERDwCSIPRQ0HCyAFQQA2AqgBIAUgDzYCpAEgBSAONgKgASAFIBI2ArgCIAUgDDYCtAIgBSAMIA1qNgKwAiAFIAw2AqwCIAUgBjYCqAIgBSAPNgKYAyAFIAVBqAFqNgKUAyAFQQA2ApADIAVBqAJqIAVBkANqEPgBAkAgBSgCwAEiBkUNACAGIAZBAWpBGGwiBmpBd0YNACAFKALMASAGaxDUAQsgBSgC4AEEQCAFQeQBaigCABDUAQsgBSgCqAEhECAFKAKgASEPIAUoAqQBIQoLIAUoArABBEAgBSgCtAEQ1AELIAlBAUYNAiAFKAKQASIGRQ0CIAYgBkEBakEYbCIGakF3Rg0CIAUoApwBIAZrENQBDAILIAVB9gBqIhAgBS0AqwI6AAAgBUHgAGoiDiAFQagCaiIGQRhqKQMANwMAIAVB6ABqIg0gBkEgaikDADcDACAFIAUvAKkCOwF0IAUgBSkDuAI3A1ggBSgCrAIhDCAFKAKwAiEJIAUoArQCIQoCQCAFKAJ8IgZFDQAgBSgCeEUNACAGENQBCyAIIAUvAXQ7AAEgCCAFKQNYNwMQIAhBA2ogEC0AADoAACAIQRhqIA4pAwA3AwAgCEEgaiANKQMANwMAIAhBBDsBLCAIIAo2AgwgCCAJNgIIIAggDDYCBCAIIA86AAAMAgsgBSgCeCEJAn8gEkGYAWoiCiAFQYgBahCjBUH/AXEiBkEERwRAQQIgEkHIAmotAABBAEcgBkEDRxtB/wFxDAELQQILIQ0gBUHAAWoiDEEIaiAFQZgBaikDADcDACAFIAUpA5ABNwPAASAFQagCaiIGIAkgDCANELUGIAwgCiAFQYgBaiAGELEEIAVBhAJqKAIAIg5B0ABsIQ0gBUGAAmooAgAhDCAFKAL8ASEKQQghDyAOBEAgDUGw////eUsNBSAOQQZ0IglBAEgNBSAJIA1Bsf///3lJQQN0IgYQ8AkiD0UNAwsgBUEANgKoASAFIA82AqQBIAUgDjYCoAEgBSASNgK4AiAFIAw2ArQCIAUgDCANajYCsAIgBSAMNgKsAiAFIAo2AqgCIAUgDzYCmAMgBSAFQagBajYClAMgBUEANgKQAyAFQagCaiAFQZADahD4AQJAIAUoAuABIgZFDQAgBiAGQQFqQRhsIgZqQXdGDQAgBUHsAWooAgAgBmsQ1AELIAVB0AFqELwDIAUoAogCBEAgBUGMAmooAgAQ1AELIAUoAqABIQ8gBSgCpAEhCiAFKAKoASEQCwJAIBBFBEBBAyEODAELAkAgEEEGdCAKakFAakEAIBAbIgstAAAiBkELRgRAIAVBCzoAqAIgBSALLQABOgCpAgwBCyAGQQpGBEAgBUEKOgCoAiAFIAsoAgQ2AqwCDAELIAVBqAJqIAsQ/gILQQIhDiALQSxqLwEAIgZBAkcEQCALKQMgIRYCfyAGRQRAIAtBLmovAQAhDCALQTxqKAIAIREgC0E0aigCACENIAtBMGooAgAhCUEAIQ4gC0E4aigCAAwBCyALQTRqKAIAIQxBASEOQQEhDSALQThqKAIAIgkEQCAJQQBOIhFFDQcgCSAREPAJIg1FDQgLIA0gDCAJEOAKGiAJCyEGIAVB5AJqIBE2AgAgBUHgAmogBjYCACAFQdwCaiANNgIAIAVB2AJqIAk2AgAgBUHWAmogDDsBACAFQdQCaiAOOwEAIAVB0AJqIAsoAig2AgAgBSAWNwPIAgsgBUEoaiIJQShqIAVBqAJqIgZBKGooAgA2AgAgCUEgaiAGQSBqKQMANwMAIAlBGGogBkEYaikDADcDACAJQRBqIAZBEGopAwA3AwAgCUEIaiAGQQhqKQMANwMAIAVBEGoiBkEIaiAFQd4CaikBADcDACAGQRBqIAVB5gJqLwEAOwEAIAUgBSkDqAI3AyggBSAFKQHWAjcDEAsgCCAFKQMoNwMAIAggDjsBLCAIIAUpAxA3AS4gCEEoaiAFQShqIgZBKGooAgA2AgAgCEEgaiAGQSBqKQMANwMAIAhBGGogBkEYaikDADcDACAIQRBqIAZBEGopAwA3AwAgCEEIaiAGQQhqKQMANwMAIAhBNmogBUEQaiIGQQhqKQMANwEAIAhBPmogBkEQai8BADsBACAQBEAgEEEGdCEJIAohBgNAIAYQvQYgBkFAayEGIAlBQGoiCQ0ACwsgD0UNACAKENQBCyAFQaADaiQADAULIAkgBkHw9MQAKAIAIgBBygQgABsRAAAACyAKIBFB8PTEACgCACIAQcoEIAAbEQAAAAsQxwgACyAJIBFB8PTEACgCACIAQcoEIAAbEQAAAAsgB0EIaiEIQQAhESMAQdAAayIFJAAgBUEANgIEIAUgEzYCACAFQRBqIBIgAiAFENsCAkACQAJAAkAgBS0AECIKQRNGBEAgBUEYaigCACEJIAUoAhQCQCAFQRxqKAIAIg5FBEAgCEEDOwEsDAELAkAgDkEGdCAJakFAakEAIA4bIgstAAAiBkELRgRAIAVBCzoAECAFIAstAAE6ABEMAQsgBkEKRgRAIAVBCjoAECAFIAsoAgQ2AhQMAQsgBUEQaiALEP4CC0ECIQ8gC0Esai8BACIGQQJHBEAgCykDICEWAn8gBkUEQCALQS5qLwEAIQ0gC0E8aigCACERIAtBNGooAgAhECALQTBqKAIAIQZBACEPIAtBOGooAgAMAQsgC0E0aigCACENQQEhD0EBIRAgC0E4aigCACIGBEAgBkEATiIRRQ0GIAYgERDwCSIQRQ0HCyAQIA0gBhDgChogBgshCiAFQcwAaiARNgIAIAVByABqIAo2AgAgBUHEAGogEDYCACAFQUBrIAY2AgAgBUE+aiANOwEAIAVBPGogDzsBACAFQThqIAsoAig2AgAgBSAWNwMwCyAIIAUpAxA3AwAgCCAFKQE+NwEuIAhBKGogBUEQaiIGQShqKAIANgIAIAhBIGogBkEgaikDADcDACAIQRhqIAZBGGopAwA3AwAgCEEQaiAGQRBqKQMANwMAIAhBCGogBkEIaikDADcDACAIQTZqIAZBNmopAQA3AQAgCEE+aiAGQT5qLwEAOwEAIAggDzsBLCAOQQZ0IQogCSEGA0AgBhC9BiAGQUBrIQYgCkFAaiIKDQALC0UNASAJENQBDAELIAggBS8AETsAASAIIAUpAyA3AxAgCEEDaiAFLQATOgAAIAhBGGogBUEQaiIGQRhqKQMANwMAIAhBIGogBkEgaikDADcDACAFKQIUIRYgCCAFKAIcNgEMIAggFjcBBCAIQQQ7ASwgCCAKOgAACyAFQdAAaiQADAILEMcIAAsgBiARQfD0xAAoAgAiAEHKBCAAGxEAAAALCwJAIAcvATQiBkEDa0H//wNxQQFLIgpFDQAgB0HIAGoiCUEYaiAHQQhqIgZBGGopAwA3AwAgCUEQaiAGQRBqKQMANwMAIAlBCGogBkEIaikDADcDACAHIAcpAwgiFjcDSCAHQegAaiIGQRhqIBRBGGopAwA3AwAgBkEQaiAUQRBqKQMANwMAIAZBCGogFEEIaikDADcDACAHIBQpAwA3A2gCQAJAAkACQAJAAkAgFqdB/wFxQQtGBEAgB0GQAWogASAHQegAaiAHLQBJIAcgAyAEEIUBIActAJABIgZBHEYNAQwCCyAHQbgBaiIGIAdByABqIAEtANEDELACIAdBkAFqIAEgBhDVASAHLQCQASIGQRxHDQELIAcgBygClAE2AowBIAdBBGogB0GMAWoQgQogBygCjAEiBkGEAU8EQCAGEAELIAcvAXQiBkEDcUEDRg0BIAZBAWsNAgwBCyAAIAcvAJEBOwABIAAgBykDmAE3AwggAEEDaiAHLQCTAToAACAAQRBqIAdBkAFqIgFBEGopAwA3AwAgAEEYaiABQRhqKQMANwMAIABBIGogAUEgaikDADcDACAAIAcoApQBNgIEIAAgBjoAAAJAIAcvAXQiAEEDcUEDR0EAIABBAWsbDQAgBygCeEUNACAHKAJ8ENQBCyAHQcgAahCIByAHLwE0QQRGDQIMAwsgBygCeEUNACAHKAJ8ENQBCyAHQcgAahCIByAHLwE0IQYMAgsgB0EIahCkAwsgBygCBCIAQYQBSQ0DIAAQAQwDCyATQQFqIRMCQAJAIAZBBEcEQCAKDQIgBkEDRg0CIAdBCGoQiAcgBy8BNCIGQQNxQQNGDQEgBkEBaw0CDAELIAdBCGoQpAMMAQsgBygCOEUNACAHKAI8ENQBCyATIBVHDQALIAcoAgQhEwsgAEEcOgAAIAAgEzYCBAsgB0HAAWokAAuhBwIIfwR+IwBB8ABrIgIkACACQdgAaiIDQRBqIAFBEGooAgA2AgBBCCEEIANBCGogAUEIaikCADcDACACIAEpAgA3A1ggAkE4aiADEJYCAkACQCACAn8CQCACKAI4IgdFBEAgAikCPCIKQv8Bg0IGUQ0BIAIgCjcCHCACKQMgIQpBBQwCCyACQcQAaikCACEKIAIpAjwhDCACKAJQIQUgAkEANgIwIAJCgICAgIABNwMoAn8CQAJ/IAVFBEBBACEBQQAMAQsDQCACIAo3AmQgAiAMNwJcIAIgBzYCWCACQThqIAJB2ABqEJYCAkACfiACKQI8IgwgAigCOCIBRQ0AGkIFIAIpA1AiDUL/////D1YNABogAiACKQJENwJkIAIgDDcCXCACIAE2AlggAkE4aiACQdgAahCWAiACKAI4IgcNASACKQI8CyELIAIoAigEQCACKAIsENQBCyALQv8Bg0IGUQ0DIAIgCzcCHEEFDAQLIAIpA1AhCyACKQJEIQogAikCPCEMIA2nIQMgAigCMCIBIAIoAihGBEAgAkEoaiABEIoGIAIoAjAhAQsgAigCLCABQQR0aiIBIAs3AwggASADNgIAIAIgAigCMEEBaiIBNgIwIAVBAWsiBQ0ACyACKAIsIQQgAigCKAshAyACQRBqIAo3AwAgAiAMNwMIIAJB4ABqIgUgCjcDACACIAw3A1ggAkEANgJIIAIgBDYCRCACIAQgAUEEdGo2AkAgAiAENgI8IAIgAzYCOCACQRhqIAJBOGoQrAQgAigCICIGQQJJDQQgAigCHCEIIAZBDGwhA0F/IQRBDCEBAkADQCABIANGDQYgBiAEQQFqIgRGDQEgASAIaiEJIAFBDGohASAJQQhqKAIAQfcBcSAJQQRrKAIAQfcBcU8NAAsgAEKAgICA0AA3AgAgAEEIakIENwIAIAIoAhhFDQYgCBDUAQwGCyAGIAZBtO/BABCcBwALIAIgC0IgiD4CHEEICyEBIAJBEGogAkEgaikDACINNwMAIAIgATYCGCACIAIpAxgiCzcDCCAAQQxqIA03AgAgACALNwIEIABBADYCAAwDCyACIApCIIg+AhxBCAs2AhggAikDGCELIABBDGogCjcCACAAIAs3AgQgAEEANgIADAELIAAgAikDWDcCBCAAIAc2AgAgACACKQMYNwIUIABBDGogBSkDADcCACAAQRxqIAJBIGooAgA2AgALIAJB8ABqJAAL+AYCCX8CfiMAQSBrIgQkACAAKAIAIQUgAEEANgIAIABBCGoiCikDACELIAAoAgQhBkEEIQMgASEMAkACQAJ/AkACQAJAAkACQAJAAkACQCAFQQFrDgUEBAMAAQoLIAEgC1INAUECIQIMCAsgASALUQ0DIABBJGooAgAhAiAGrSEMQQAhBSAAQRxqIQcDQCAMp0H/AHEgDEI/ViIIQQd0ciEJIAxCB4ghDCAAIAIgACgCHEcEfyACBSAHIAJBARCcBiAAKAIkCyIDQQFqIgI2AiQgAyAAKAIgIgZqIAk6AAAgBUEBaiEFIAgNAAsgACAAKAIYIAVqNgIYQQAhBSAAQRxqIQcDQCALp0H/AHEgC0JAfUL/AFYiCEEHdHIhCSALQgeHIQsgACACIAAoAhxHBH8gAgUgByACQQEQnAYgACgCICEGIAAoAiQLIgNBAWoiAjYCJCADIAZqIAk6AAAgBUEBaiEFIAgNAAsMBQtBEEEIEPAJIgJFDQMgAiALNwMAIAKtQoCAgIAQhCEMQQIhAkEDDAULIAApAxAhDCAEIAs3AgQgBCAGNgIAIAEgDFIEQCAGIAtCIIinIgJHBH8gC6cFIAQgBhCNBiAEKAIIIQIgBCgCBAsgAkEDdGogDDcDACAEIAQoAghBAWo2AgggBCgCACECIAQpAgQhDEEDDAULIARBEGoiAkEIaiAEQQhqKAIANgIAIAQgBCkDADcDECAAIAIQrgRBAiECIAEhDEEFDAQLIABBJGooAgAiAyAAKAIcRgRAIABBHGogA0EBEJwGIAAoAiQhAwsgACADQQFqIgI2AiRBACEFIAAoAiAiByADakEAOgAAIAAgACgCGEEBajYCGCAGrSELIABBHGohBgNAIAunQf8AcSALQv8AViIIQQd0ciEJIAtCB4ghCyAAIAIgACgCHEcEfyACBSAGIAJBARCcBiAAKAIgIQcgACgCJAsiA0EBaiICNgIkIAMgB2ogCToAACAFQQFqIQUgCA0ACwwCCyAGQQFqIQIMAwtBEEEIQfD0xAAoAgAiAEHKBCAAGxEAAAALIAAgACgCGCAFajYCGCABIQxBBAshAyAAKAIAQQNHDQEgACgCBEUNASAAQQhqKAIAENQBDAELQQUhAwsgACABNwMQIAAgAjYCBCAAIAM2AgAgCiAMNwMAIARBIGokAAuNCQIHfwR+IwBB0ABrIgYkAAJAAkACQAJAAkACQCABQegAaigCAEUNACABQewAaigCACIJQfQAayELIAJBlZWIuQJsQQV3IANzQZWViLkCbCIKQRl2rUKBgoSIkKDAgAF+IQ8gAUHgAGooAgAhBwNAIA8gByAKcSIIIAlqKQAAIg6FIg1CgYKEiJCgwIABfSANQn+Fg0KAgYKEiJCgwIB/gyEMA0AgDFAEQCAOIA5CAYaDQoCBgoSIkKDAgH+DQgBSDQMgCCAFQQhqIgVqIQoMAgsgDHohDSAMQgF9IAyDIQwgCyANp0EDdiAIaiAHcUGMf2xqIgooAgAgAkcNACAKQQRqKAIAIANHDQALC0EAIQIjAEEQayIIJAACQAJAAkAgCkEIaiIHIgUoAlxBAUcNACAFKAIMRQ0AIAhBCGogBSAFKAJkEJIFIAgoAghFDQAgCCgCDCIJIAVBzABqKAIAIgNPDQEgBUHgAGooAgAgBUHIAGooAgAiCyAJQdAAbGoiAyAELQA8ENkDaiAEKAIIRw0AQQEhAiAEQQE2AgAgBCAFKAJkQQFqNgIEIAMtAExFBEAgBEEkaiIFIAsgCUHQAGxqIgMpAkA3AgAgBUEIaiADQcgAaigCADYCAAwBCyAEQQE2AiQgBEEoaiALIAlB0ABsaikDIDcCAAsgCEEQaiQADAELIAkgA0Hki8IAEJwHAAsgAg0EIAZBEGoiAkE4aiIIIARBOGopAgA3AwAgAkEwaiIKIARBMGopAgA3AwAgAkEoaiIJIARBKGopAgA3AwAgAkEgaiILIARBIGopAgA3AwAgAkEYaiIFIARBGGopAgA3AwAgAkEQaiIDIARBEGopAgA3AwAgAkEIaiAEQQhqKQIANwMAIAYgBCkCADcDECAHKAIMIgJFDQMgBkEIaiAGQRBqIAdBACACGyIEIAdByABqIgIoAgAgB0HMAGoiBygCABD5AiAGKAIIQQFrDgIBAgMLIAAgBCkCADcCACAAQThqIARBOGopAgA3AgAgAEEwaiAEQTBqKQIANwIAIABBKGogBEEoaikCADcCACAAQSBqIARBIGopAgA3AgAgAEEYaiAEQRhqKQIANwIAIABBEGogBEEQaikCADcCACAAQQhqIARBCGopAgA3AgAMBAsgBCAGQRBqIAEgAigCACAHKAIAQQEgBigCDBC0AhoMAQsgBCAGQRBqIAEgAigCACAHKAIAQQAgBxC0AhoLIAAgBikDEDcCACAAQThqIAgpAwA3AgAgAEEwaiAKKQMANwIAIABBKGogCSkDADcCACAAQSBqIAspAwA3AgAgAEEYaiAFKQMANwIAIABBEGogAykDADcCACAAQQhqIAZBGGopAwA3AgAMAQsgACAEKQIANwIAIABBOGogBEE4aikCADcCACAAQTBqIARBMGopAgA3AgAgAEEoaiAEQShqKQIANwIAIABBIGogBEEgaikCADcCACAAQRhqIARBGGopAgA3AgAgAEEQaiAEQRBqKQIANwIAIABBCGogBEEIaikCADcCAAsgBkHQAGokAAucBwMFfwJ+AXwjAEEQayIGJAACQAJAAn8CQAJAAkACQAJAAkACQAJAIAEtAABBAWsOCQECAwQFBgoHCgALIAFBCGooAgAhBSAAKAIEIgMoAgghAiABQQxqKAIAIgQgAygCACACa0sEQCADIAIgBBCcBiADKAIIIQILIAMoAgQgAmogBSAEEOAKGiADQQhqDAcLIAZBCGogAUEEahCgBiAGKAIIIQUgACgCBCIDKAIIIQIgBigCDCIEIAMoAgAgAmtLBEAgAyACIAQQnAYgAygCCCECCyADKAIEIAJqIAUgBBDgChogA0EIagwGCyABKQMIIQcgACgCBCICKAIIIQEDQCAHp0H/AHEgB0JAfSIIQv8AVkEHdHIhAyAHQgeHIQcgASACKAIARgR/IAIgAUEBEJwGIAIoAggFIAELIAIoAgRqIAM6AAAgAiACKAIIQQFqIgE2AgggBEEBaiEEIAhCgAFaDQALDAYLIAEpAwghByAAKAIEIgIoAgghAQNAIAenQf8AcSAHQv8AVkEHdHIhAyABIAIoAgBGBH8gAiABQQEQnAYgAigCCAUgAQsgAigCBGogAzoAACACIAIoAghBAWoiATYCCCAEQQFqIQQgB0KAAVQgB0IHiCEHRQ0ACwwFC0EIIQQgASsDCCEJIAAoAgQiAygCCCECIAMoAgAgAmtBB00EQCADIAJBCBCcBiADKAIIIQILIAMoAgQgAmogCTkAACADQQhqDAMLIAEpAwghByAAKAIEIgIoAgghAQNAIAenQf8AcSAHQkB9IghC/wBWQQd0ciEDIAdCB4chByABIAIoAgBGBH8gAiABQQEQnAYgAigCCAUgAQsgAigCBGogAzoAACACIAIoAghBAWoiATYCCCAEQQFqIQQgCEKAAVoNAAsMAwsgASkDCCEHIAAoAgQiAigCCCEBA0AgB6dB/wBxIAdCQH0iCEL/AFZBB3RyIQMgB0IHhyEHIAEgAigCAEYEfyACIAFBARCcBiACKAIIBSABCyACKAIEaiADOgAAIAIgAigCCEEBaiIBNgIIIARBAWohBCAIQoABWg0ACwwCCyABQQhqKAIAIQUgACgCBCIDKAIIIQIgAUEMaigCACIEIAMoAgAgAmtLBEAgAyACIAQQnAYgAygCCCECCyADKAIEIAJqIAUgBBDgChogA0EIagsiASABKAIAIARqNgIACyAAIAAoAgAgBGo2AgALIAZBEGokACAEC/UGAgl/An4jAEEgayIEJAAgACgCACEFIABBADYCACAAQQhqIgopAwAhCyAAKAIEIQZBBCEDIAEhDAJAAkACfwJAAkACQAJAAkACQAJAAkAgBUEBaw4FBAQDAAEKCyABIAtSDQFBAiECDAgLIAEgC1ENAyAAQSRqKAIAIQIgBq0hDEEAIQUgAEEcaiEHA0AgDKdB/wBxIAxCP1YiCEEHdHIhCSAMQgeIIQwgACACIAAoAhxHBH8gAgUgByACQQEQnAYgACgCJAsiA0EBaiICNgIkIAMgACgCICIGaiAJOgAAIAVBAWohBSAIDQALIAAgACgCGCAFajYCGEEAIQUgAEEcaiEHA0AgC6dB/wBxIAtC/wBWIghBB3RyIQkgC0IHiCELIAAgAiAAKAIcRwR/IAIFIAcgAkEBEJwGIAAoAiAhBiAAKAIkCyIDQQFqIgI2AiQgAyAGaiAJOgAAIAVBAWohBSAIDQALDAULQRBBCBDwCSICRQ0DIAIgCzcDACACrUKAgICAEIQhDEECIQJBAwwFCyAAKQMQIQwgBCALNwIEIAQgBjYCACABIAxSBEAgBiALQiCIpyICRwR/IAunBSAEIAYQjQYgBCgCCCECIAQoAgQLIAJBA3RqIAw3AwAgBCAEKAIIQQFqNgIIIAQoAgAhAiAEKQIEIQxBAwwFCyAEQRBqIgJBCGogBEEIaigCADYCACAEIAQpAwA3AxAgACACELMEQQIhAiABIQxBBQwECyAAQSRqKAIAIgMgACgCHEYEQCAAQRxqIANBARCcBiAAKAIkIQMLIAAgA0EBaiICNgIkQQAhBSAAKAIgIgcgA2pBADoAACAAIAAoAhhBAWo2AhggBq0hCyAAQRxqIQYDQCALp0H/AHEgC0L/AFYiCEEHdHIhCSALQgeIIQsgACACIAAoAhxHBH8gAgUgBiACQQEQnAYgACgCICEHIAAoAiQLIgNBAWoiAjYCJCADIAdqIAk6AAAgBUEBaiEFIAgNAAsMAgsgBkEBaiECDAMLQRBBCEHw9MQAKAIAIgBBygQgABsRAAAACyAAIAAoAhggBWo2AhggASEMQQQLIQMgACgCAEEDRw0BIAAoAgRFDQEgAEEIaigCABDUAQwBC0EFIQMLIAAgATcDECAAIAI2AgQgACADNgIAIAogDDcDACAEQSBqJAAL/QYBEH8jAEEgayIJJAAgASgCBCIGLwHmAiIKQQFqIgQgASgCDCIMLwHmAiIIaiIOQQtNBEAgASgCECEPIAEoAhQiBS8B5gIhByAGIA47AeYCIAlBGGoiDSAFIAEoAhgiAUEFdGoiAkEYaikAADcDACAJQRBqIhAgAkEQaikAADcDACAJQQhqIhEgAkEIaikAADcDACAJIAIpAAA3AwAgAiAFIAFBAWoiAkEFdGogByABQX9zaiILQQV0EN8KGiAGIApBBXRqIgNBGGogDSkDADcAACADQRBqIBApAwA3AAAgA0EIaiARKQMANwAAIAMgCSkDADcAACAGIARBBXRqIAwgCEEFdBDgChogBUHoAmoiAyACQQJ0aiABQQJ0IANqQQhqIAtBAnQQ3woaAkAgAiAHTw0AIAcgAWtBAmsgC0EDcSIDBEAgAUECdCAFakHsAmohAQNAIAEoAgAiCyACOwHkAiALIAU2AuACIAFBBGohASACQQFqIQIgA0EBayIDDQALC0EDSQ0AIAJBA2ohAUEAIAdrIQcgAkECdCAFakH0AmohAgNAIAJBDGsoAgAiAyABQQNrOwHkAiADIAU2AuACIAJBCGsoAgAiAyABQQJrOwHkAiADIAU2AuACIAJBBGsoAgAiAyABQQFrOwHkAiADIAU2AuACIAIoAgAiAyABOwHkAiADIAU2AuACIAJBEGohAiAHIAFBBGoiAWpBA0cNAAsLIAUgBS8B5gJBAWs7AeYCAkAgD0EBTQ0AIAYgBEECdGpB6AJqIAxB6AJqIAhBAnRBBGoQ4AoaIAogDk8NACAIQQFqQQNxIgIEQCAKQQJ0IAZqQewCaiEBA0AgASgCACIHIAQ7AeQCIAcgBjYC4AIgAUEEaiEBIARBAWohBCACQQFrIgINAAsLIAhBA0kNACAEQQNqIQFBfiAIIApqayEIIARBAnQgBmpB9AJqIQIDQCACQQxrKAIAIgQgAUEDazsB5AIgBCAGNgLgAiACQQhrKAIAIgQgAUECazsB5AIgBCAGNgLgAiACQQRrKAIAIgQgAUEBazsB5AIgBCAGNgLgAiACKAIAIgQgATsB5AIgBCAGNgLgAiACQRBqIQIgCCABQQRqIgFqQQNHDQALCyAMENQBIAAgBTYCBCAAIA82AgAgCUEgaiQADwtBhIrBAEEqQbCKwQAQnggAC4MHAgx/BH4jAEEgayIHJAACQAJAAkACQCAAQTRqKAIAIgYEQCAGQcQAbCEJIABBMGooAgAhBiAERQ0BIABBPGooAgAhCCAAQUBrKAIAIQpBACEEA0ACQAJAAkAgBSAGQShqKAIAIgBNBEAgACAFRg0BQQEhACAGIAEgAiADQQEgBRDwAQ0IQQAhBSAEIApPDQMgCCgCACILIANPDQIgB0EYaiABIAIgC0HQAGxqEPEDIAcoAhhBA0cNAwwICyAFIABBf3NqIQUMAgtBACEFIAQgCk8NASADIAgoAgAiAEsEQCAHQRBqIAEgAiAAQdAAbGoQ8QMgBygCEEEDRw0CDAYLIAAgA0HM/MEAEJwHAAsgCyADQcz8wQAQnAcACyAGQcQAaiEGIARBAWohBCAIQQRqIQggCUHEAGsiCQ0AC0EAIQAMAwsgBUEAIAQbIQQgAEE8aigCACIFIABBQGsoAgBBAnRqIQADQAJAIARFBEAgACAFRw0BQQAhAAwFCyAEIAAgBWtBAnZPBEBBACEADAULIAUgBEECdGohBQsgAyAFKAIAIgRLBEAgByABIAIgBEHQAGxqEPEDIAVBBGohBUEAIQQgBygCAEEDRw0BDAMLCyAEIANB3PzBABCcBwALIAYgCWohCiAAQTxqKAIAIQsgAEFAaygCACEMIAFBBGohDUEAIQADQAJAIAZBGGooAgBFDQAgDSgCACIOIAEoAgAiD0GVlYi5AmxBBXdzQZWViLkCbCIFQRl2rUKBgoSIkKDAgAF+IRQgBkEcaigCACIQQQhrIREgBkEQaigCACEEQQAhCANAIAQgBXEiBSAQaikAACITIBSFIhJCgYKEiJCgwIABfSASQn+Fg0KAgYKEiJCgwIB/gyESA0AgElAEQCATIBNCAYaDQoCBgoSIkKDAgH+DQgBSDQMgBSAIQQhqIghqIQUMAgsgEnohFSASQgF9IBKDIRIgESAVp0EDdiAFaiAEcUEDdGsiCSgCACAPRw0AIAlBBGooAgAgDkcNAAsLIAYgASACIANBACAJEPABDQILIAAgDEkEQCALIABBAnRqKAIAIgQgA08NBCAHQQhqIAEgAiAEQdAAbGoQ8QMgBygCCEEDRg0CCyAAQQFqIQAgCiAGQcQAaiIGRw0AC0EAIQAMAQtBASEACyAHQSBqJAAgAA8LIAQgA0HM/MEAEJwHAAutBgETfyAALwECIRAgAC8BACERIAJBfHEiFEHArQFwIRICQCAUIBJrIg5BwK0BSQRADAELIBFBwK0BbCEVIAEhAyAOIQ8DQEEAIQQDQCAFIAMgBGoiDS0AAGoiBSAJaiAFIA1BBGotAABqIgVqIQkgCCANQQNqLQAAaiITIA1BB2otAABqIQggCCAMIBNqaiEMIAcgDUECai0AAGoiEyANQQZqLQAAaiEHIAcgCyATamohCyANQQVqLQAAIAYgDUEBai0AAGoiDWohBiAGIAogDWpqIQogBEEIaiIEQcCtAUcNAAsgDEHx/wNwIQwgC0Hx/wNwIQsgCkHx/wNwIQogCUHx/wNwIQkgCEHx/wNwIQggB0Hx/wNwIQcgBkHx/wNwIQYgBUHx/wNwIQUgA0HArQFqIQMgECAVakHx/wNwIRAgD0HArQFrIg9BwK0BTw0ACwsgAkEDcSEPAkAgEkH8/wFxIgRFDQAgASAOaiEDIARBBGsiDkEEcQR/IAMFIAggAy0AA2oiCCAMaiEMIAcgAy0AAmoiByALaiELIAYgAy0AAWoiBiAKaiEKIAUgAy0AAGoiBSAJaiEJIA4hBCADQQRqCyECIA5FDQADQCAFIAItAABqIgMgAkEEai0AAGohBSAFIAMgCWpqIQkgCCACQQNqLQAAaiIDIAItAAdqIQggCCADIAxqaiEMIAcgAkECai0AAGoiAyACLQAGaiEHIAcgAyALamohCyAGIAJBAWotAABqIgMgAi0ABWohBiAGIAMgCmpqIQogAkEIaiECIARBCGsiBA0ACwsgECARIBJsakHx/wNwIAlB8f8DcEECdGogBkHx/wNwIgRrIAtB8f8DcCAKQfH/A3BqIAxB8f8DcGpBAnRqIAdB8f8DcCIDQQF0ayAIQfH/A3AiDkF9bGpBpv8XaiECIAVB8f8DcCARaiAEaiADaiAOaiEEAkAgD0UNACACIAQgASAUaiIBLQAAaiIEaiECIA9BAUYNACACIAQgAS0AAWoiBGohAiAPQQJGDQAgAiAEIAEtAAJqIgRqIQILIAAgAkHx/wNwOwECIAAgBEHx/wNwOwEAC+wGAg1/BX4jAEEwayIEJAAgBEEIaiABQeAAaiACIAMQggIgBEEANgIgIARCgICAgMAANwMYIAQoAgghBwJAAkACQCABQThqKAIAIgtFBEBBBCEIDAELIAQoAhQiDEEYayENIAQoAhAhDiABQTxqKAIAIgJBCGohCSACKQMAQn+FQoCBgoSIkKDAgH+DIRFBBCEIA0ACfiARUARAIAkhAwNAIAJBgAFrIQIgAykDACADQQhqIgkhA0J/hUKAgYKEiJCgwIB/gyIRUA0ACyARQgF9IBGDDAELIAJFDQIgEUIBfSARgwsgAiAReqdBAXRB8AFxayEGIAQCfwJAIA5FDQAgBkEQaygCACIPQZWViLkCbCIDQRl2rUKBgoSIkKDAgAF+IRRBACEKA0AgFCADIAdxIgMgDGopAAAiE4UiEUKBgoSIkKDAgAF9IBFCf4WDQoCBgoSIkKDAgH+DIREDQCARUARAIBMgE0IBhoNCgIGChIiQoMCAf4NCAFINAyADIApBCGoiCmohAwwCCyAReiEVIBFCAX0gEYMhESANIBWnQQN2IANqIAdxQWhsaiIQKAIAIA9HDQALCyAGQQRrKAIAIgogEEEQaikDAKciA0kNBCAGQQhrKAIAIANBAnRqIQYgCiADayIDIAQoAhggBWtLBEAgBEEYaiAFIAMQ9AUgBCgCHCEIIAQoAiAhBQsgCCAFQQJ0aiAGIANBAnQQ4AoaIAMgBWoMAQsgBkEQayIDQQhqKAIAIQYgA0EMaigCACIDIAQoAhggBWtLBEAgBEEYaiAFIAMQ9AUgBCgCHCEIIAQoAiAhBQsgCCAFQQJ0aiAGIANBAnQQ4AoaIAMgBWoLIgU2AiAhESALQQFrIgsNAAsLIAggBSAEQShqQQBBICAFZ2sQcyAEKAIYIQYgBQRAIAFBpAJqIQcgCCEDIAUhAgNAIAcoAgAiCyADKAIAIglNDQMgAyABQaACaigCACAJQaACbGo2AgAgA0EEaiEDIAJBAWsiAg0ACyAEKAIIIQcLIAAgBjYCBCAAQRM6AAAgAEEMaiAFNgIAIABBCGogCDYCAAJAIAdFDQAgB0EBakEYbCIAIAdqQXdGDQAgBCgCFCAAaxDUAQsgBEEwaiQADwsgAyAKQdjbwgAQjAoACyAJIAtBsLrCABCcBwALzwcBBX8jAEGgAmsiCCQAIAggBTYCDCAIIAQ2AgggCCABKAIYNgIEIAggAUE8aigCACABKAIQajYCACAIKAIEIQogCCgCACELIAhBsAFqIgkgBkECELIIIAhBEGoiDCACQZgBaiAEIAUgCRDsASAJIAwQwgYCQCAILQCwASIEQRNGBEAgCEHYAGoiBSAIQbwBaigCADYCACAIIAgpArQBNwNQIAhBhAFqIAo2AgAgCEHgAGoiBEEYaiAHQRhqKQMANwMAIARBEGogB0EQaikDADcDACAEQQhqIAdBCGopAwA3AwAgCEGYAWpCBDcDACAIQZABakIANwMAIAggCzYCgAEgCCAHKQMANwNgIAhBqAFqIAUoAgA2AgAgCEEBOgCsASAIQoCAgIDAADcDiAEgCCAIKQNQNwOgASACQZgBaiAIQRBqIgRBBEEUIAQoAgAbaigCAAJAAkACQAJAAkBBAyAILQBgIgRBCmsgBEEJTRtB/wFxQQFrDgMBAgMACyAIIAgtAGE6AIECIAhBCjoAgAIMAwsgCEELOgCAAgwCCyAIIAgpA2g3A4gCIAhBDDoAgAIMAQsgCEGAAmogCEHgAGoQ/gILIAhB4AFqQQA2AgAgCEHUAWogCjYCACAIQewBakEANgIAIAhB+AFqIAhB2ABqKAIANgIAIAhBsAFqIgRBCGogCEGAAmoiBUEIaikDADcDACAEQRBqIAVBEGopAwA3AwAgBEEYaiAFQRhqKQMANwMAIAggCCkDUDcD8AEgCEKAgICAwAA3A9gBIAggCzYC0AEgCCAIKQOAAjcDsAEgCEKAgICAwAA3AuQBIAhBAToA/AEgCEEIaiAEEJIBIAgoAgghByAIKAIMIQkgCEEANgKEAiAIIAY2AoACIAQgCEHgAGpB0AAQ4AoaIAEgAiADIAcgCSAFIAQQkQEgAEEIaiAKNgIAIAAgCzYCBCAAQRM6AAAMAQsgACAIKQPAATcDECAAQRhqIAhBsAFqIgFBGGopAwA3AwAgAEEgaiABQSBqKQMANwMAIAggCCkAsQE3A2AgCCABQQhqKQAANwBnIABBCGogCCkAZzcAACAAIAgpA2A3AAEgACAEOgAAIActAAAiAEEKa0H/AXFBA0kNAAJAAkACQCAADgkAAQMDAwMDAwIDCyAHKAIERQ0CIAdBCGooAgAQ1AEMAgsgB0Ebai0AAEEYRw0BIAdBBGoiASgCACICKAIAIQAgAiAAQQFrNgIAIABBAUcNASABEK4IDAELIAcoAgRFDQAgB0EIaigCABDUAQsgCEGgAmokAAuJBwEFfyMAQSBrIgUkACAFECs2AgQgBUEQaiADIAQQ+QEgBSgCECAFKAIUIgYgBSgCGBACIQQEQCAGENQBCyAFQfCSwABBBRACNgIIIAUgBBAANgIMIAVBEGogBUEEaiAFQQhqIAVBDGoQ+QcgBSgCCCEGAkAgBS0AECIDBEAgBSgCFCEHDAELIAUtABEhCCAGQYQBTwRAIAYQAQsLIAUoAgwiCUGEAU8EQCAJEAELAkACQCADBEAgBkGEAU8EQCAGEAELIAdBhAFPBEAgBxABCyAAQQU2AgggAEHwksAANgIEIAAgCDoAASAAQRU6AAAgBEGEAUkNASAEEAEMAQsgBEGEAU8EQCAEEAELIAVB9ZLAAEEIEAI2AgggBUGDATYCDCAFQRBqIAVBBGogBUEIaiAFQQxqEPkHIAUoAgghBAJAIAUtABAiBgRAIAUoAhQhAwwBCyAFLQARIQcgBEGEAU8EQCAEEAELCyAFKAIMIghBhAFPBEAgCBABCyAGBEAgBEGEAU8EQCAEEAELIANBhAFPBEAgAxABCyAAQQg2AgggAEH1ksAANgIEIAAgBzoAASAAQRU6AAAMAQsgBUH9ksAAQQoQAjYCCCAFQYMBNgIMIAVBEGogBUEEaiAFQQhqIAVBDGoQ+QcgBSgCCCEEAkAgBS0AECIGBEAgBSgCFCEDDAELIAUtABEhByAEQYQBTwRAIAQQAQsLIAUoAgwiCEGEAU8EQCAIEAELIAYEQCAEQYQBTwRAIAQQAQsgA0GEAU8EQCADEAELIABBCjYCCCAAQf2SwAA2AgQgACAHOgABIABBFToAAAwBCyAFQYeTwABBDBACNgIIIAVBgwE2AgwgBUEQaiAFQQRqIAVBCGogBUEMahD5ByAFKAIIIQQCQCAFLQAQIgYEQCAFKAIUIQMMAQsgBS0AESEHIARBhAFPBEAgBBABCwsgBSgCDCIIQYQBTwRAIAgQAQsgBgRAIARBhAFPBEAgBBABCyADQYQBTwRAIAMQAQsgAEEMNgIIIABBh5PAADYCBCAAIAc6AAEgAEEVOgAADAELIAUgAigCABAANgIQIAEgBUEQaiAFQQRqEOQJIgFBhAFPBEAgARABCyAFKAIQIgFBhAFPBEAgARABCyAAQRw6AAAgBSgCBCIAQYQBSQ0BIAAQAQwBCyAFKAIEIgBBhAFJDQAgABABCyAFQSBqJAAL9wYCB38CfiMAQdABayIFJAACQAJAIAAtAAxFDQAgBUEIaiABIAIQ5gEgBSgCDEUNACAFKQIMIQwgBSgCCCEHIAVBGGoiASAEEN4IIAFBOGoiCSAEQThqKQMANwMAIAFBMGoiCiAEQTBqKQMANwMAIAFBKGoiCCAEQShqKQMANwMAIAUgBCkDIDcDOCADKAIAIQECfyADKAIEIgsEQCAFQeQAaiACQQhqKQIANwIAIAVB7ABqIAJBEGopAgA3AgAgBUH0AGogAkEYaikCADcCACAFQYQBaiAFQRhqIgZBCGopAwA3AgAgBUGMAWogBkEQaikDADcCACAFQZQBaiAGQRhqKQMANwIAIAVBnAFqIAVBOGopAwA3AgAgBUGkAWogCCkDADcCACAFQawBaiAKKQMANwIAIAVBtAFqIAkpAwA3AgAgBSAFKQMYNwJ8IAUgAikCADcCXCADKQIEIQ0gASEIQQAMAQsgBUHYAGoiBkEIaiACQQxqKQIANwMAIAZBEGogAkEUaikCADcDACAGQRhqIAJBHGooAgA2AgAgBUH8AGogBUEYaiIGQQhqKQMANwIAIAVBhAFqIAZBEGopAwA3AgAgBUGMAWogBkEYaikDADcCACAFQZQBaiAFQThqKQMANwIAIAVBnAFqIAgpAwA3AgAgBUGkAWogCikDADcCACAFQawBaiAJKQMANwIAIAUgBzYCwAEgBSAFKQMYNwJ0IAUgAikCBDcDWCACNQIAQiCGIQ0gBSAMNwLEASAMQiCIpyEIIAUpA8ABIQwgASEHQQELIQYgACgCCCIBIAAoAgBGBEAgACABEIUGIAAoAgghAQsgACgCBCABQQd0aiIBIA03AhQgASAINgIQIAEgDDcDCCABIAc2AgRBACEHIAFBADoAASABIAY6AAAgAUEcaiAFQdgAakHkABDgChogACAAKAIIQQFqNgIIIAQQiAcgC0EARyEADAELIAQQiAdBASEHQQAhACAEQSxqLwEAIgFBA3FBA0dBACABQQFrGw0AIARBMGooAgBFDQAgBEE0aigCABDUAQsCQCADQQRqKAIAIgFFDQAgAA0AIAMoAgBFDQAgARDUAQsCQCAHRQ0AIAIvAQwiAEEDcUEDR0EAIABBAWsbDQAgAkEQaigCAEUNACACQRRqKAIAENQBCyAFQdABaiQAC8kHAgd/An4jAEEwayICJAACQAJAAkACQAJAAkACQAJAIAEoAgAiBCgCCCIDIAQoAgQiBkkEQCAEKAIAIQUDQAJAIAMgBWotAAAiB0EJaw4kAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQGAwsgBCADQQFqIgM2AgggAyAGRw0ACwsgAkECNgIYIAAgBCACQRhqEPwHNgIEDAYLIAdB3QBGDQELIAEtAAQNAiACQQc2AhggACAEIAJBGGoQ/Ac2AgQMBAtBACEBIABBADoAAQwECyABLQAEDQBBASEBIAQgA0EBaiIDNgIIIAMgBkkEQANAIAMgBWotAAAiB0EJayIIQRdLDQNBASAIdEGTgIAEcUUNAyAEIANBAWoiAzYCCCADIAZHDQALCyACQQU2AhggACAEIAJBGGoQ/Ac2AgQMAwsgAUEAOgAECyAHQd0ARgRAIAJBEjYCGCAAIAQgAkEYahD8BzYCBAwBCyAAAn8CQAJAAkACQAJAAkAgAyAGSQRAA0ACQCADIAVqLQAAIgFBCWsOJQAAAwMAAwMDAwMDAwMDAwMDAwMDAwMDAAMDAwMDAwMDAwMDAwQDCyAEIANBAWoiAzYCCCADIAZHDQALCyACQQU2AhggBCACQRhqEPwHDAYLIAFBMGtB/wFxQQpPBEAgBCACQShqQYzxwAAQ3gEgBBCKCAwGCyACQQhqIARBARDFAiACKQMIIgpCA1ENAyACKQMQIQkCQAJAIAqnQQFrDgIAAQMLIAlCgAJaBEAgAkEBOgAYIAIgCTcDICACQRhqIAJBKGpBjPHAABCTByEFDAYLDAMLIAlCgAJaBEAgAkECOgAYIAIgCTcDICACQRhqIAJBKGpBjPHAABCTByEFDAULDAILIAQgA0EBajYCCCACQQhqIARBABDFAiACKQMIIgpCA1ENAiACKQMQIQkCQAJAAkACQCAKp0EBaw4CAQIACyACQQM6ABggAiAJNwMgIAJBGGogAkEoakHsysAAEKkGIQUMBgsgCUKAAlQNASACQQE6ABggAiAJNwMgIAJBGGogAkEoakGM8cAAEJMHIQUMBQsgCUKAAlQNACACQQI6ABggAiAJNwMgIAJBGGogAkEoakGM8cAAEJMHIQUMBAsMAQsgAkEDOgAYIAIgCTcDICACQRhqIAJBKGpB7MrAABCpBiEFDAILIAmnIQMgAEEBOgABIABBAmogAzoAAEEAIQEMBAsgAigCEAwBCyAFIAQQiggLNgIEC0EBIQELIAAgAToAACACQTBqJAALnAcBB38jAEEQayIDJAACQEHgAEEEEPAJIgIEQCABKAJQBH8gAUHgAGooAgAhBCABQdwAaigCACEHIAFB2ABqKAIAIQUgAUHUAGooAgAFQQALIQYgAiAHNgIMIAJBATYCCCACIAU2AgQgAiAGNgIAIAJB3ABqQdYANgIAIAIgASkCADcCVCACQdAAakHCADYCACACIAEpAjA3AkggAkHEAGpBNDYCACACIAEpAig3AjwgAkE4akEVNgIAIAJBLGpBEzYCACACQSBqQRE2AgAgAiABKQIQNwIYIAJBFGpBAjYCACACQRBqIAQ2AgAgAiABQSBqKQIANwIwIAIgAUEYaikCADcCJEEIIQUgA0EINgIIIAMgAjYCBCADQQg2AgACQAJAIAEoAggiBCABQQxqKAIAIgZPBEAgAUE8aigCACEGIAEoAjghBAwBCyADQQgQgwYgAygCBCADKAIIQQxsaiICQdcANgIIIAIgBjYCBCACIAQ2AgAgAyADKAIIQQFqIgI2AgggAUE8aigCACEGIAEoAjghBCADKAIAIgUgAkcNAQsgAyAFEIMGIAMoAgghAgsgAygCBCACQQxsaiICQfAANgIIIAIgBjYCBCACIAQ2AgAgAyADKAIIQQFqIgU2AgggAUFAaygCACICIAFBxABqKAIAIgRPDQEgAUHMAGooAgAhBiABQcgAaigCACEHIAMoAgAgBWtBAU0EQCADIAVBAhD5BSADKAIIIQULIAMoAgQgBUEMbGoiAUHzADYCFCABIAY2AhAgASAHNgIMIAFB8QA2AgggASAENgIEIAEgAjYCACADIAVBAmoiBTYCCAwBC0HgAEEEQfD0xAAoAgAiAEHKBCAAGxEAAAALIAMoAgAhBiADKAIEIgQhAQJAIAVFDQACfyAEIgIgBUEMbEEMayIHQQxuQQFxDQAaIARBDGohAiAEIAEoAgAiCCABKAIEIgFPDQAaIAQgATYCBCAEIAg2AgAgBEEMagshASAHQQxJDQAgBCAFQQxsaiEFA0AgAigCACIHIAIoAgQiCEkEQCABIAIoAgg2AgggASAINgIEIAEgBzYCACABQQxqIQELIAJBDGooAgAiByACQRBqKAIAIghJBEAgASACQRRqKAIANgIIIAEgCDYCBCABIAc2AgAgAUEMaiEBCyAFIAJBGGoiAkcNAAsLIAAgBDYCBCAAIAY2AgAgACABIARrQQxuNgIIIANBEGokAAv9CQISfwF+IwBB8AFrIgIkACACQQhqIABBCGopAgAiFDcDACACIAApAgA3AwAgASgCBCABKAIAIQUCQCACKAIEIgMgFKciBkYNACACQeQBaiEKIAJBgAFqIQsgACgCECENIAEoAgggBUEGdGohACACQaABakEEciEOA0AgAygCQCIHQQJHBEAgAkEgaiIBQQhqIgggA0EIaikDADcDACABQRBqIg8gA0EQaikDADcDACABQRhqIhAgA0EYaikDADcDACABQSBqIhEgA0EgaikDADcDACABQShqIgkgA0EoaikDADcDACABQTBqIhIgA0EwaikDADcDACABQThqIgEgA0E4aikDADcDACACQRhqIhMgA0HMAGooAgA2AgAgAiADKQMANwMgIAIgAykCRDcDECACQaABaiIEQThqIAEpAwA3AwAgBEEwaiASKQMANwMAIARBKGogCSkDADcDACAEQSBqIgkgESkDADcDACAEQRhqIBApAwA3AwAgBEEQaiAPKQMANwMAIARBCGogCCkDADcDACACIAIpAyA3A6ABIAIgBzYC4AEgCiACKQMQNwIAIApBCGogEygCADYCACACQeAAaiEHIwBBMGsiASQAIAEgBDYCDAJAAkACQAJAQQMgBC0AACIIQQprIAhBCU0bQf8BcQ4EAQAAAgALIAFBHGpBATYCACABQSRqQQE2AgAgAUG0jsIANgIYIAFBADYCECABQb8CNgIsIAEgAUEoajYCICABIAFBDGo2AiggAUEQakHMjsIAENoIAAsgB0ELOgAAIAcgBC0AAToAAQwBCyAHIAQQ/gILIAFBMGokACALIA0gCSgCACACKALEARDiCQJAIAItAKABIgFBCmtB/wFxQQNJDQACQAJAAkAgAQ4JAAEDAwMDAwMCAwsgAigCpAFFDQIgAigCqAEQ1AEMAgsgAi0AuwFBGEcNASACKAKkASIEKAIAIQEgBCAB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AEUEQCAFIAg2AgAgBUEEaiAKNgIADAILIAJBCGooAgAiBUGBgICAeEYNASAFRQ0AIAogBUHw9MQAKAIAIgBBygQgABsRAAAACxDHCAALIAJBIGokACABKALcBCECDAELIAFBqAxqIgBBEGogAUHIC2oiAkEQaikDADcDACAAQQhqIAJBCGopAwA3AwAgASABKQPICzcDqAwMBQsgAiAGaiABQbgJakHYABDgChogASAEQQFqIgQ2AuAEIAZB2ABqIQYgAUHIC2ogAUHoBGoQ2wEgAS0AnAwiBUEDRw0ACwsgAUHoBGoQmQMgAEEIaiABQeAEaigCADYCACAAIAEpA9gENwIACyABQcAMaiQADAILQeACQQhB8PTEACgCACIAQcoEIAAbEQAAAAtB0P7CAEErIABB/P7CAEGs/8IAEIcHAAsgAygCCARAIAMoAgwQ1AELIANBsAlqJAAPCxDHCAALIAUgB0Hw9MQAKAIAIgBBygQgABsRAAAACyAHIAVB8PTEACgCACIAQcoEIAAbEQAAAAsgBkEEQfD0xAAoAgAiAEHKBCAAGxEAAAALIAQgAUHM/8IAEI4KAAsgASAHQcz/wgAQjQoAC4EHAgd/AX4jAEHgAGsiAyQAIANBATsBJCADQcAANgIgIANCgYCAgIAINwMYIAMgAjYCFCADQQA2AhAgAyACNgIMIAMgATYCCCADIAI2AgQgA0EANgIAIANBKGogA0EIaiIHEKoDAkACQAJAAkACQAJ/IAMoAihFBEAgAy0AJQ0CAkAgAy0AJA0AIAMoAgQgAygCAEcNAEEADAILIANBAToAJQwCCyADKAIAIQUgAyADQTBqKAIANgIAIAMtACUNASADKAIsIAVrIQkgASAFagshBSADKAIIIQYgA0EoaiAHEKoDAkACQCADKAIoRQRAQQAhBiADLQAlDQIgAygCACEGIAMoAgQhCAJAIAMtACQNACAGIAhHDQBBACEGDAILIANBAToAJSAIIAZrIQggAygCCCAGaiEGDAILIAMoAgAhBCADIANBMGooAgA2AgAgAygCLCAEayEIIAQgBmohBkEAIQQgAy0AJQ0BCyADKAIIIANBKGogBxCqAyADKAIoRQRAQQAhBCADLQAlDQEgAygCACEHIAMtACRFBEAgAygCBCAHRg0CCyADQQE6ACUgAygCCCAHaiEEDAEL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AjYCACAAIAOtIAhCIIaENwIEDwsgAEEAOwEEIABBADYCACAAQQZqQQE6AAAPCyAAQoCAgIAQNwMAIABBCGpBATYCAA8LIABBADYCACAAQQNqQQA2AAALzQYCDn8CfiMAQeAAayICJAAgAkHIAGoiA0EQaiABQRBqKAIANgIAIANBCGogAUEIaikCADcDACACIAEpAgA3A0ggAkEoaiADEJECAkACQAJAAkACQAJAAkAgAigCKEUEQCACKQIsIhBC/wGDQgBSDQEgAkEIakEEciAQQgiIpxCcBQwCCyACQQhqIgFBGGogAkEoaiIDQRhqKQMANwMAIAFBEGogA0EQaikDADcDACABQQhqIANBCGopAwA3AwAgAiACKQMoIhA3AwggEKciBEUNASACKAIYIQggAigCFCEJIAIoAhAhCiACKAIMIQMgAikDICEQQQAhASACQQA2AhAgAkKAgICAEDcDCCAQUA0FIANBIEkNAyAQQgF9IRAgA0Ega61CBYhCAXwhESACQThqIQsMAgsgAkEQaiAQQiCIPgIAIAJBBDoADAsgAkEIaiIBQQxqKQIAIRAgAUEUaigCACEDIAIpAgwhESAAQRhqIAFBGGopAwA3AgAgAEEUaiADNgIAIABBDGogEDcCACAAIBE3AgQgAEEANgIADAQLA0AgAkEwaiINIAEgBGoiBUEUaikAADcDACALIAVBHGooAAA2AgAgAiAFQQxqKQAANwMoIAUoAAAhDCAFQQhqKAAAIQ4gBUEEaigAACEPIAIoAgggBkYEQCACQQhqIAYQlAYgAigCECEGCyACKAIMIAZBBXRqIgcgDjYACCAHIA82AAQgByAMNgAAIAcgAikDKDcADCAHQRRqIA0pAwA3AAAgB0EcaiALKAIANgAAIAIgBkEBaiIGNgIQIBBQDQIgAUEgaiEBIBBCAX0hECARQgF9IhFCAFINAAsgAyABayEDIAEgBGohBCACKAIIIQELIABCgICAgMAANwIAIABBHGpBIDYCACAAQRhqIAQ2AgAgAEEUaiAMNgIAIABBEGogCTYCACAAQQxqIAo2AgAgAEEIakEgIANrNgIAIAFFDQIgAigCDBDUAQwCCyABIAhqQSBqIQggAyABa0EgayEDIAVBIGohBAsgACAINgIQIAAgCTYCDCAAIAo2AgggACADNgIEIAAgBDYCACAAIAIpAwg3AhQgAEEcaiACQRBqKAIANgIACyACQeAAaiQAC+8GAgh/A34jAEEgayICJAACQAJAAkACQCABKAIoIgUEQCABLQAsIQMMAQsgAUEYaigCACIDIAFBFGooAgAgAUEQaigCACIFGyEJIAFBHGooAgAgAyAFGyEHIAFBIGooAgAhBANAIAQgB08EQCAAQQI2AgAMBQsgAiAHIARrIgM2AgwgAiAEIAlqNgIIIAJBEGogAkEIahCGBCACKAIQDQIgAyACKAIMIgVGBEBBBiEBDAQLIAIpAxghCiABIAMgBWsiBTYCJCABIAQgBWoiBDYCIAJAAkACQAJAIApCAFcEQCAKQgBZDQEgAUEAIAqnayIFNgIoQQEhAwwECyABIAqnIgU2AiggBCAHSw0BIAIgByAEayIINgIMIAIgBCAJajYCCCACQRBqIAJBCGoQhgQgAigCEA0GIAIoAgwiAyAIRgRAQQYhASALIQoMCAsgAikDGCELIAEgCCADayIDNgIkIAEgAyAEaiIENgIgIAEgCzcDCCABQgE3AwBBACEDDAMLIAQgB0sNASACIAcgBGsiAzYCDCACIAQgCWo2AgggAkEQaiACQQhqEIMEAn4CQAJ/IAIoAhBFBEAgAikDGCIMQv////8PWA0CQQEMAQsgAikCFCEKQQILIQEgCqchBiAKQoCAgIBwgwwBCyADIAIoAgwiBUcEQCABIAMgBWsiBjYCJCABIAQgBmoiBDYCICABQgA3AwAgASAMpyIGNgIoQQAhAyAGIQUMBAtBBiEBQgALIAathCEKDAYLIAQgB0H468EAEIwKAAsgBCAHQfjrwQAQjAoACyABIAM6ACwgBUUNAAsLIAEgBUEBazYCKAJAAn4gA0UEQCABKQMIIQogASkDAAwBCyABQRxqKAIAIAFBGGooAgAiBSABQRBqKAIAIgYbIgMgAUEgaigCACIISQ0BIAIgAyAIayIDNgIMIAIgBSABQRRqKAIAIAYbIAhqNgIIIAJBEGogAkEIahCGBCACKAIQDQIgAikDGCEKIAMgAigCDCIGRgRAQQYhAQwECyABQSRqIAMgBmsiBjYCACABIAYgCGo2AiBCAQshCyAAIAo3AxAgACALNwMIIABBADYCAAwDCyAIIANB+OvBABCMCgALIAIpAhQhCkECIQELIAAgCjcCCCAAIAE2AgQgAEEBNgIACyACQSBqJAAL7wYCCH8DfiMAQSBrIgIkAAJAAkACQAJAIAEoAigiBQRAIAEtACwhAwwBCyABQRhqKAIAIgMgAUEUaigCACABQRBqKAIAIgUbIQkgAUEcaigCACADIAUbIQcgAUEgaigCACEEA0AgBCAHTwRAIABBAjYCAAwFCyACIAcgBGsiAzYCDCACIAQgCWo2AgggAkEQaiACQQhqEIYEIAIoAhANAiADIAIoAgwiBUYEQEEGIQEMBAsgAikDGCEKIAEgAyAFayIFNgIkIAEgBCAFaiIENgIgAkACQAJAAkAgCkIAVwRAIApCAFkNASABQQAgCqdrIgU2AihBASEDDAQLIAEgCqciBTYCKCAEIAdLDQEgAiAHIARrIgg2AgwgAiAEIAlqNgIIIAJBEGogAkEIahCDBCACKAIQDQYgAigCDCIDIAhGBEBBBiEBIAshCgwICyACKQMYIQsgASAIIANrIgM2AiQgASADIARqIgQ2AiAgASALNwMIIAFCATcDAEEAIQMMAwsgBCAHSw0BIAIgByAEayIDNgIMIAIgBCAJajYCCCACQRBqIAJBCGoQgwQCfgJAAn8gAigCEEUEQCACKQMYIgxC/////w9YDQJBAQwBCyACKQIUIQpBAgshASAKpyEGIApCgICAgHCDDAELIAMgAigCDCIFRwRAIAEgAyAFayIGNgIkIAEgBCAGaiIENgIgIAFCADcDACABIAynIgY2AihBACEDIAYhBQwEC0EGIQFCAAsgBq2EIQoMBgsgBCAHQfjrwQAQjAoACyAEIAdB+OvBABCMCgALIAEgAzoALCAFRQ0ACwsgASAFQQFrNgIoAkACfiADRQRAIAEpAwghCiABKQMADAELIAFBHGooAgAgAUEYaigCACIFIAFBEGooAgAiBhsiAyABQSBqKAIAIghJDQEgAiADIAhrIgM2AgwgAiAFIAFBFGooAgAgBhsgCGo2AgggAkEQaiACQQhqEIMEIAIoAhANAiACKQMYIQogAyACKAIMIgZGBEBBBiEBDAQLIAFBJGogAyAGayIGNgIAIAEgBiAIajYCIEIBCyELIAAgCjcDECAAIAs3AwggAEEANgIADAMLIAggA0H468EAEIwKAAsgAikCFCEKQQIhAQsgACAKNwIIIAAgATYCBCAAQQE2AgALIAJBIGokAAvDFwIbfwZ+IwBBQGoiCCQAIABBuMLCADYCDCAAQQA2AgggAEIANwIAIAggATYCMCAIIAI2AiwgCCACIANBBXRqNgIoIAhBCGogCEEoahCJBCAIQgA3AhwCQAJAAkAgCCgCECINBEAgCCgCDCETIAFBFGohFSABQRBqIRYgAUEsaiEZIAFBIGohGiABQRxqIRsDQCAIIA1BAWsiAzYCECATIANBAnRqKAIAIQsCQAJAAkAgCCgCHCIGRQRAQQAhBgwBCyAGIQQgCCgCGCIHIQkDQCAEQQRqIQIgBC8BMiIMQQJ0IQFBfyEFAkADQCABRQRAIAwhBQwCCyACKAIAIQogBUEBaiEFIAFBBGshASACQQRqIQJBfyAKIAtHIAogC0sbIgpBAUYNAAsgCkH/AXENACADIQEMBAsgCQRAIAlBAWshCSAEIAVBAnRqQTRqKAIAIQQMAQsLA0AgBi8BMiIEQQJ0IQVBACEBQX8hAgJAA0AgASAFRgRAIAQhAgwCCyABIAZqIQwgAkEBaiECIAFBBGohAUF/IAxBBGooAgAiDCALRyALIAxJGyIMQQFGDQALIAxB/wFxRQ0DCyAHRQ0BIAdBAWshByAGIAJBAnRqQTRqKAIAIQYMAAsACyAIIAI2AjQgCCAGNgIwIAhBADYCLCAIIAs2AiggCCAIQRhqNgI4IAhBKGoQlAQLIBUoAgAiASALTQ0FIAtBBXQiAiAWKAIAaiIBKAIYIgQgGSgCACIGTw0EIAEpAwghICABKQMAISFBACEGIAEoAhwiF0GVlYi5AmwiDEEZdiIYrUKBgoSIkKDAgAF+ISMgAEEMaigCACEEIAAoAgAhBSAMIQECQANAICMgASAFcSIBIARqKQAAIiKFIh9CgYKEiJCgwIABfSAfQn+Fg0KAgYKEiJCgwIB/gyEfA0AgH1AEQCAiICJCAYaDQoCBgoSIkKDAgH+DUARAIAEgBkEIaiIGaiEBDAMLIAAoAgRFBEBBACEEIwBBIGsiCiQAIABBCGooAgAiDkEBaiEBAkAgASAOSQRAEIcIIAooAgwaDAELIAAoAgAiCUEBaiEFAkACQAJAAkAgCSAFQQN2QQdsIAlBCEkbIhBBAXYgAUkEQCAKQRBqQRggASAQQQFqIgQgASAESxsQ7wMgCigCHCIGDQEgCigCFBoMBQsgAEEMaigCACEHQQAhAQNAAkACfyAEQQFxBEAgAUEHaiIEIAFJDQIgBCAFTw0CIAFBCGoMAQsgASAFSSIGRQ0BIAYgASIEagshASAEIAdqIgQpAwAhHyAEIB9Cf4VCB4hCgYKEiJCgwIABgyAfQv/+/fv379+//wCEfDcDAEEBIQQMAQsLIAVBCE8EQCAFIAdqIAcpAAA3AAAMAgsgB0EIaiAHIAUQ3woaIAlBf0cNAUEAIRAMAgsgCigCECEHIAooAhQgDmshEAJAIAVFBEAgACAQNgIEIAAgBzYCACAAKAIMIQ4gACAGNgIMDAELIABBDGooAgAiDkEYayESQQAhBQNAIAUgDmosAABBAE4EQCAGIBIgBUFobGooAgBBlZWIuQJsIg8gB3EiBGopAABCgIGChIiQoMCAf4MiH1AEQEEIIQEDQCABIARqIQQgAUEIaiEBIAYgBCAHcSIEaikAAEKAgYKEiJCgwIB/gyIfUA0ACwsgBiAfeqdBA3YgBGogB3EiAWosAABBAE4EQCAGKQMAQoCBgoSIkKDAgH+DeqdBA3YhAQsgASAGaiAPQRl2IgQ6AAAgAUEIayAHcSAGakEIaiAEOgAAIAYgAUF/c0EYbGoiAUEQaiAOIAVBf3NBGGxqIgRBEGopAAA3AAAgAUEIaiAEQQhqKQAANwAAIAEgBCkAADcAAAsgBSAJRiAFQQFqIQVFDQALIAAgEDYCBCAAIAc2AgAgAEEMaiAGNgIAIAlFDQMLIAlBAWpBGGwiASAJakF3Rg0DIA4gAWsQ1AEMAwsgB0EYayEcQQAhAQNAAkAgByABIgZqIhItAABBgAFHDQAgHCAGQWhsaiEdIAcgBkF/c0EYbGohBQJAA0AgByAdKAIAQZWViLkCbCIPIAlxIhEiBGopAABCgIGChIiQoMCAf4MiH1AEQEEIIQEDQCABIARqIQQgAUEIaiEBIAcgBCAJcSIEaikAAEKAgYKEiJCgwIB/gyIfUA0ACwsgByAfeqdBA3YgBGogCXEiBGosAABBAE4EQCAHKQMAQoCBgoSIkKDAgH+DeqdBA3YhBAsgBCARayAGIBFrcyAJcUEITwRAIAcgBEF/c0EYbGohASAEIAdqIhEtAAAgESAPQRl2Ig86AAAgBEEIayAJcSAHakEIaiAPOgAAQf8BRg0CIAUtAAUhBCAFLQAEIQ8gBSABLwAEOwAEIAEtAAchESABLQAGIRQgASAFLwAGOwAGIAUoAAAhHiAFIAEoAAA2AAAgASAeNgAAIAEgDzoABCAFIBQ6AAYgASAEOgAFIAUgEToAByAFLQAIIQQgBSABLQAIOgAIIAEgBDoACCAFLQAJIQQgBSABLQAJOgAJIAEgBDoACSAFLQAKIQQgBSABLQAKOgAKIAEgBDoACiAFLQALIQQgBSABLQALOgALIAEgBDoACyAFLQAMIQQgBSABLQAMOgAMIAEgBDoADCAFLQANIQQgBSABLQANOgANIAEgBDoADSAFLQAOIQQgBSABLQAOOgAOIAEgBDoADiAFLQAPIQQgBSABLQAPOgAPIAEgBDoADyAFLQAQIQQgBSABLQAQOgAQIAEgBDoAECAFLQARIQQgBSABLQAROgARIAEgBDoAESAFLQASIQQgBSABLQASOgASIAEgBDoAEiAFLQATIQQgBSABLQATOgATIAEgBDoAEyAFLQAUIQQgBSABLQAUOgAUIAEgBDoAFCAFLQAVIQQgBSABLQAVOgAVIAEgBDoAFSAFLQAWIQQgBSABLQAWOgAWIAEgBDoAFiAFLQAXIQQgBSABLQAXOgAXIAEgBDoAFwwBCwsgEiAPQRl2IgE6AAAgBkEIayAJcSAHakEIaiABOgAADAELIBJB/wE6AAAgBkEIayAJcSAHakEIakH/AToAACABQRBqIAVBEGopAAA3AAAgAUEIaiAFQQhqKQAANwAAIAEgBSkAADcAAAsgBkEBaiEBIAYgCUcNAAsLIAAgECAOazYCBAsLIApBIGokACAAKAIAIQUgAEEMaigCACEECyAEIAUgDHEiBmopAABCgIGChIiQoMCAf4MiH1AEQEEIIQEDQCABIAZqIQYgAUEIaiEBIAQgBSAGcSIGaikAAEKAgYKEiJCgwIB/gyIfUA0ACwsgBCAfeqdBA3YgBmogBXEiAWosAAAiBkEATgRAIAQgBCkDAEKAgYKEiJCgwIB/g3qnQQN2IgFqLQAAIQYLIAEgBGogGDoAACABQQhrIAVxIARqQQhqIBg6AAAgACAAKAIEIAZBAXFrNgIEIAAgACgCCEEBajYCCCAEIAFBaGxqQRhrIgEgITcDECABICA3AwggASAXNgIADAMLIB96ISQgH0IBfSAfgyEfIAQgJKdBA3YgAWogBXFBaGxqIgdBGGsoAgAgF0cNAAsLICAgB0EQayIBKQMAVgRAIAEgIDcDACAHQQhrICE3AwALCyAVKAIAIgEgC00NAyADIQEgFigCACACaiIDKAIQRQ0AIANBFGooAgAhASANQQJ0QQRrIQIDQAJAAkAgGigCACIDIAFLBEAgGygCACABQQxsaiIDKAIIIQQgAygCBCEBIAMoAgAhAyANQQFrIgYgCCgCCEYNAQwCCyABIANB4LrCABCcBwALIAhBCGogBkEBEPQFIAgoAgwhEwsgAiATaiAENgIAIAJBBGohAiAIIA02AhAgDUEBaiENIAMNAAsgDUEBayEBCyABIg0NAAsLIAhBGGoQkQMgCCgCCARAIAgoAgwQ1AELIAhBQGskAA8LIAsgAUGQw8IAEJwHAAsgBCAGQbDDwgAQnAcACyALIAFBoMPCABCcBwAL5DUCI38GfiMAQfAIayILJAAgAb0hJwJAIAEgAWIEQEECIQUMAQsgJ0L/////////B4MiK0KAgICAgICACIQgJ0IBhkL+////////D4MgJ0I0iKdB/w9xIgQbIihCAYMhKUEDIQUCQAJAAkBBAUECQQQgJ0KAgICAgICA+P8AgyIsUCIMGyAsQoCAgICAgID4/wBRG0EDQQQgDBsgK1AbQQJrDgMAAQIDC0EEIQUMAgsgBEGzCGshCSApUCEFQgEhKgwBC0KAgICAgICAICAoQgGGIChCgICAgICAgAhRIgkbIShCAkIBIAkbISogKVAhBUHLd0HMdyAJGyAEaiEJCyALIAk7AegIIAsgKjcD4AggC0IBNwPYCCALICg3A9AIIAsgBToA6ggCfyAFQQJGBEBBhK/EAAwBCyACRQRAICdCP4inIR1BqMjEAEGEr8QAICdCAFMbDAELQQEhHUGoyMQAQanIxAAgJ0IAUxsLIR9BASEEAkACQAJ/AkACQAJAAkBBAyAFQQJrIAVBAU0bQf8BcUEBaw4DAgEAAwtBdEEFIAnBIgJBAEgbIAJsIgJBv/0ASw0EIAtBkAhqIQ8gC0EQaiEIIAJBBHZBFWoiDiEJQYCAfkEAIANrIANBgIACTxshCgJAAkACQAJAAkACQAJAIAtB0AhqIgIpAwAiJ0IAUgRAICdC//////////8fVg0BIAlFDQMgAi8BGCICQSBrIAIgJ0KAgICAEFQiAhsiBUEQayAFICdCIIYgJyACGyInQoCAgICAgMAAVCICGyIFQQhrIAUgJ0IQhiAnIAIbIidCgICAgICAgIABVCICGyIFQQRrIAUgJ0IIhiAnIAIbIidCgICAgICAgIAQVCIFGyECICdCBIYgJyAFGyInQoCAgICAgICAwABUIQVBoH8gJ0IChiAnIAUbIidCP4enQX9zIAJBAmsgAiAFG2oiBWvBQdAAbEGwpwVqQc4QbSICQdEATw0CIAJBBHQiAkGCt8QAai8BACEEAn8gAkH4tsQAaikDACIoQv////8PgyIpICcgJ0J/hUI/iIYiKkIgiCIrfiEnIChCIIgiLCAqQv////8PgyIqfiEoAkACQCArICx+ICdCIIh8IChCIIh8ICdC/////w+DICkgKn5CIIh8IChC/////w+DfEKAgICACHxCIIh8IilBQCAFIAJBgLfEAGovAQBqayINQT9xrSIniKciBUGQzgBPBEAgBUHAhD1JDQEgBUGAwtcvSQ0CQQhBCSAFQYCU69wDSSICGyEMQYDC1y9BgJTr3AMgAhsMAwsgBUHkAE8EQEECQQMgBUHoB0kiAhshDEHkAEHoByACGwwDCyAFQQlLIQxBAUEKIAVBCkkbDAILQQRBBSAFQaCNBkkiAhshDEGQzgBBoI0GIAIbDAELQQZBByAFQYCt4gRJIgIbIQxBwIQ9QYCt4gQgAhsLIQJCASAnhiEoAkAgDCAEa0EQdEGAgARqQRB1IgcgCsEiBEoEQCAoQgF9IisgKYMhKSANQf//A3EhGCAHIAprwSAJIAcgBGsgCUkbIg1BAWshBkEAIQQDQCAFIAJuIREgBCAJRg0HIAUgAiARbGshBSAEIAhqIBFBMGo6AAAgBCAGRg0IIAQgDEYNAiAEQQFqIQQgAkEKSSACQQpuIQJFDQALQYDDxABBGUH8xMQAEJ4IAAsgDyAIIAlBACAHIAogKUIKgCACrSAnhiAoEI4EDAgLIARBAWoiBCAJIAQgCUsbIQIgGEEBa0E/ca0hLEIBISoDQCAqICyIQgBSBEAgD0EANgIADAkLIAIgBEYNByAEIAhqIClCCn4iKSAniKdBMGo6AAAgKkIKfiEqICkgK4MhKSANIARBAWoiBEcNAAsgDyAIIAkgDSAHIAogKSAoICoQjgQMBwtBu7LEAEEcQajExAAQnggAC0G4xMQAQSRB3MTEABCeCAALIAJB0QBBuMHEABCcBwALQdzDxABBIUHsxMQAEJ4IAAsgCSAJQYzFxAAQnAcACyAPIAggCSANIAcgCiAFrSAnhiApfCACrSAnhiAoEI4EDAELIAIgCUGcxcQAEJwHAAsgCsEhGAJAIAsoApAIRQRAIAtBwAhqIR4gC0EQaiEPQQAhAiMAQdAGayIGJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCALQdAIaiIFKQMAIidCAFIEQCAFKQMIIihQDQEgBSkDECIpUA0CICcgKXwgJ1QNAyAnIChUDQQgBS8BGCEFIAYgJz4CCCAGQQFBAiAnQoCAgIAQVCIEGzYCqAEgBkEAICdCIIinIAQbNgIMIAZBEGpBAEGYARDiChogBkGwAWpBBHJBAEGcARDiChogBkEBNgKwASAGQQE2AtACIAWtwyAnQgF9eX1CwprB6AR+QoChzaC0AnxCIIinIgTBIRICQCAFwSIJQQBOBEAgBkEIaiAFENgBGgwBCyAGQbABakEAIAlrwRDYARoLAkAgEkEASARAIAZBCGpBACASa8EQlQIMAQsgBkGwAWogBEH//wNxEJUCCyAGKALQAiEMIAZBqAVqIAZBsAFqQaABEOAKGiAGIAw2AsgGAkAgDiIJQQpJDQACQCAMQShLBEAgDCEEDAELIAZBoAVqIQggDCEEA0ACQCAERQ0AIARBAWtB/////wNxIgpBAWoiB0EBcSAEQQJ0IQUCfyAKRQRAQgAhJyAGQagFaiAFagwBCyAHQf7///8HcSEHIAUgCGohBEIAIScDQCAEQQRqIgU1AgAgJ0IghoQiKEKAlOvcA4AhJyAFICc+AgAgBCAENQIAICggJ0KAlOvcA359QiCGhCInQoCU69wDgCIoPgIAICcgKEKAlOvcA359IScgBEEIayEEIAdBAmsiBw0ACyAEQQhqCyEFRQ0AIAVBBGsiBSAFNQIAICdCIIaEQoCU69wDgD4CAAsgCUEJayIJQQlNDQIgBigCyAYiBEEpSQ0ACwsMEAsCfwJ/AkAgCUECdEGMsMQAaigCACIJBEAgBigCyAYiBUEpTw0cQQAgBUUNAxogBUEBa0H/////A3EiBEEBaiIIQQFxIQogBUECdCEFIAmtISggBA0BQgAhJyAGQagFaiAFagwCC0G/5sQAQRtB+OXEABCeCAALIAhB/v///wdxIQcgBSAGakGgBWohBEIAIScDQCAEQQRqIgU1AgAgJ0IghoQiKSAogCEnIAUgJz4CACAEIAQ1AgAgKSAnICh+fUIghoQiJyAogCIpPgIAICcgKCApfn0hJyAEQQhrIQQgB0ECayIHDQALIARBCGoLIQUgCgRAIAVBBGsiBSAFNQIAICdCIIaEICiAPgIACyAGKALIBgsiBCAGKAKoASIKIAQgCksbIgVBKEsNGCAFRQRAQQAhBQwHCyAFQQFxIQ0gBUEBRgRAQQAhCQwGCyAFQX5xIRFBACEJIAZBqAVqIQQgBkEIaiEHA0AgBCAEKAIAIhAgBygCAGoiCCAJQQFxaiIaNgIAIARBBGoiGygCACIcIAdBBGooAgBqIgkgCCAQSSAIIBpLcmohCCAbIAg2AgAgCCAJSSAJIBxJciEJIAdBCGohByAEQQhqIQQgESACQQJqIgJHDQALDAULQbuyxABBHEHUtcQAEJ4IAAtB6LLEAEEdQeS1xAAQnggAC0GYs8QAQRxB9LXEABCeCAALQcSzxABBNkGEtsQAEJ4IAAtBjLTEAEE3QZS2xAAQnggACyANBEAgAkECdCIEIAZBqAVqaiIIKAIAIQIgCCACIAZBCGogBGooAgBqIgQgCWoiCTYCACACIARLIAQgCUtyIQkLIAlBAXFFDQAgBUEnSw0BIAZBqAVqIAVBAnRqQQE2AgAgBUEBaiEFCyAGIAU2AsgGIAUgDCAFIAxLGyIEQSlPDQggBEECdCEEAkADQCAEBEBBfyAEQQRrIgQgBkGwAWpqKAIAIgIgBCAGQagFamooAgAiBUcgAiAFSxsiB0UNAQwCCwtBf0EAIAQbIQcLIAdBAU0EQCASQQFqIRIMBQsgCkEpTw0BIApFBEBBACEKDAQLIApBAWtB/////wNxIgJBAWoiBUEDcSEHIAJBA0kEQCAGQQhqIQRCACEnDAMLIAVB/P///wdxIQggBkEIaiEEQgAhJwNAIAQgBDUCAEIKfiAnfCInPgIAIARBBGoiAjUCAEIKfiAnQiCIfCEnIAIgJz4CACAEQQhqIgI1AgBCCn4gJ0IgiHwhJyACICc+AgAgBEEMaiICNQIAQgp+ICdCIIh8IScgAiAnPgIAICdCIIghJyAEQRBqIQQgCEEEayIIDQALDAILIAVBKEH45cQAEJwHAAsgCkEoQfjlxAAQjQoACyAHBEADQCAEIAQ1AgBCCn4gJ3wiJz4CACAEQQRqIQQgJ0IgiCEnIAdBAWsiBw0ACwsgJ6ciAkUNACAKQSdLDQIgBkEIaiAKQQJ0aiACNgIAIApBAWohCgsgBiAKNgKoAQtBACEFAkAgEsEiAiAYwSIETgRAIBIgGGvBIA4gAiAEayAOSRsiCQ0BC0EAIQkMAgsgBkHYAmoiBSAGQbABaiICQaABEOAKGiAGIAw2AvgDIAVBARDYASEgIAYoAtACIQwgBkGABGoiBCACQaABEOAKGiAGIAw2AqAFIARBAhDYASEhIAYoAtACIQggBkGoBWoiDCACQaABEOAKGiAGIAg2AsgGIAJBBGshIiAFQQRrISMgBEEEayEkIAxBBGshJSAMQQMQ2AEhJiAGKAKoASEFIAYoAtACIQwgBigC+AMhGiAGKAKgBSEbIAYoAsgGIRxBACERAkADQCARIQ0CQAJAAkACQAJAAkACQCAFQSlJBEAgDUEBaiERIAVBAnQhAkEAIQQCQAJAAkADQCACIARGDQEgBkEIaiAEaiAEQQRqIQQoAgBFDQALIAUgHCAFIBxLGyIIQSlPDQQgCEECdCEEAkADQCAEBEBBfyAEICVqKAIAIgIgBEEEayIEIAZBCGpqKAIAIgpHIAIgCksbIgdFDQEMAgsLQX9BACAEGyEHC0EAIRAgB0ECSQRAIAgEQEEBIQIgCEEBcUEAIQUgCEEBRwRAIAhBfnEhEyAGQQhqIQQgBkGoBWohBwNAIAQgBCgCACIUIAcoAgBBf3NqIgogAkEBcWoiFTYCACAEQQRqIhYoAgAiFyAHQQRqKAIAQX9zaiICIAogFEkgCiAVS3JqIQogFiAKNgIAIAIgF0kgAiAKS3IhAiAHQQhqIQcgBEEIaiEEIBMgBUECaiIFRw0ACwsEQCAFQQJ0IgQgBkEIamoiCigCACEFIAogAiAFIAQgJmooAgBBf3NqIgJqIgQ2AgAgAiAFSSACIARLciECCyACQQFxRQ0TCyAGIAg2AqgBQQghECAIIQULIAUgGyAFIBtLGyIIQSlPDQcgCEECdCEEA0AgBEUNAkF/IAQgJGooAgAiAiAEQQRrIgQgBkEIamooAgAiCkcgAiAKSxsiB0UNAAsMAgsgCSANSQ0EIAkgDksNBSAJIA1GDQ4gDSAPakEwIAkgDWsQ4goaDA4LQX9BACAEGyEHCwJAIAdBAUsEQCAFIQgMAQsgCARAQQEhAiAIQQFxQQAhBSAIQQFHBEAgCEF+cSEUIAZBCGohBCAGQYAEaiEHA0AgBCAEKAIAIhUgBygCAEF/c2oiCiACQQFxaiIWNgIAIARBBGoiFygCACIZIAdBBGooAgBBf3NqIgIgCiAVSSAKIBZLcmohCiAXIAo2AgAgAiAZSSACIApLciECIAdBCGohByAEQQhqIQQgFCAFQQJqIgVHDQALCwRAIAVBAnQiBCAGQQhqaiIKKAIAIQUgCiACIAUgBCAhaigCAEF/c2oiAmoiBDYCACACIAVJIAIgBEtyIQILIAJBAXFFDRALIAYgCDYCqAEgEEEEciEQCyAIIBogCCAaSxsiCkEpTw0FIApBAnQhBAJAA0AgBARAQX8gBCAjaigCACICIARBBGsiBCAGQQhqaigCACIFRyACIAVLGyIHRQ0BDAILC0F/QQAgBBshBwsCQCAHQQFLBEAgCCEKDAELIAoEQEEBIQIgCkEBcUEAIQUgCkEBRwRAIApBfnEhFCAGQQhqIQQgBkHYAmohBwNAIAQgBCgCACIVIAcoAgBBf3NqIgggAkEBcWoiFjYCACAEQQRqIhcoAgAiGSAHQQRqKAIAQX9zaiICIAggFUkgCCAWS3JqIQggFyAINgIAIAIgGUkgAiAIS3IhAiAHQQhqIQcgBEEIaiEEIBQgBUECaiIFRw0ACwsEQCAFQQJ0IgQgBkEIamoiCCgCACEFIAggAiAFIAQgIGooAgBBf3NqIgJqIgQ2AgAgAiAFSSACIARLciECCyACQQFxRQ0QCyAGIAo2AqgBIBBBAmohEAsgCiAMIAogDEsbIgVBKU8NFiAFQQJ0IQQCQANAIAQEQEF/IAQgImooAgAiAiAEQQRrIgQgBkEIamooAgAiCEcgAiAISxsiB0UNAQwCCwtBf0EAIAQbIQcLAkAgB0EBSwRAIAohBQwBCyAFBEBBASECIAVBAXFBACEKIAVBAUcEQCAFQX5xIRQgBkEIaiEEIAZBsAFqIQcDQCAEIAJBAXEgBCgCACIVIAcoAgBBf3NqIgJqIhY2AgAgBEEEaiIXKAIAIhkgB0EEaigCAEF/c2oiCCACIBVJIAIgFktyaiECIBcgAjYCACAIIBlJIAIgCElyIQIgB0EIaiEHIARBCGohBCAUIApBAmoiCkcNAAsLBEAgCkECdCIIIAZBCGpqIgooAgAhBCAKIAIgBCAGQbABaiAIaigCAEF/c2oiAmoiCDYCACACIARJIAIgCEtyIQILIAJBAXFFDRALIAYgBTYCqAEgEEEBaiEQCyANIA5HBEAgDSAPaiAQQTBqOgAAIAVBKU8NFyAFRQRAQQAhBQwJCyAFQQFrQf////8DcSICQQFqIgRBA3EhByACQQNJBEAgBkEIaiEEQgAhJwwICyAEQfz///8HcSEIIAZBCGohBEIAIScDQCAEIAQ1AgBCCn4gJ3wiJz4CACAEQQRqIgI1AgBCCn4gJ0IgiHwhJyACICc+AgAgBEEIaiICNQIAQgp+ICdCIIh8IScgAiAnPgIAIARBDGoiAjUCAEIKfiAnQiCIfCEnIAIgJz4CACAnQiCIIScgBEEQaiEEIAhBBGsiCA0ACwwHCyAOIA5BtLbEABCcBwALDBULIAhBKEH45cQAEI0KAAsgDSAJQaS2xAAQjgoACyAJIA5BpLbEABCNCgALIAhBKEH45cQAEI0KAAsgCkEoQfjlxAAQjQoACyAHBEADQCAEIAQ1AgBCCn4gJ3wiJz4CACAEQQRqIQQgJ0IgiCEnIAdBAWsiBw0ACwsgJ6ciAkUNACAFQSdLDQIgBkEIaiAFQQJ0aiACNgIAIAVBAWohBQsgBiAFNgKoASAJIBFHDQALQQEhBQwCCyAFQShB+OXEABCcBwALIApBKEH45cQAEJwHAAsCQAJAAkACQAJAAkAgDEEpSQRAIAxFBEBBACEMDAMLIAxBAWtB/////wNxIgJBAWoiBEEDcSEHIAJBA0kEQCAGQbABaiEEQgAhJwwCCyAEQfz///8HcSEIIAZBsAFqIQRCACEnA0AgBCAENQIAQgV+ICd8Iic+AgAgBEEEaiICNQIAQgV+ICdCIIh8IScgAiAnPgIAIARBCGoiAjUCAEIFfiAnQiCIfCEnIAIgJz4CACAEQQxqIgI1AgBCBX4gJ0IgiHwhJyACICc+AgAgJ0IgiCEnIARBEGohBCAIQQRrIggNAAsMAQsgDEEoQfjlxAAQjQoACyAHBEADQCAEIAQ1AgBCBX4gJ3wiJz4CACAEQQRqIQQgJ0IgiCEnIAdBAWsiBw0ACwsgJ6ciAkUNACAMQSdLDQEgBkGwAWogDEECdGogAjYCACAMQQFqIQwLIAYgDDYC0AIgBigCqAEiAiAMIAIgDEsbIgRBKU8NBSAEQQJ0IQQCQANAIAQEQEF/IARBBGsiBCAGQbABamooAgAiAiAEIAZBCGpqKAIAIgxHIAIgDEsbIgdFDQEMAgsLQX9BACAEGyEHCwJAAkAgB0H/AXEOAgABBQsgBUUNBCAJQQFrIgIgDk8NAiACIA9qLQAAQQFxRQ0ECyAJIA5LDQJBACEEIA8hBwJAA0AgBCAJRg0BIARBAWohBCAJIAdBAWsiB2oiAi0AAEE5Rg0ACyACIAItAABBAWo6AAAgCSAJIARrQQFqTQ0EIAJBAWpBMCAEQQFrEOIKGgwECwJ/QTEgCUUNABogD0ExOgAAQTAgCUEBRg0AGiAPQQFqQTAgCUEBaxDiChpBMAshAiASQRB0QYCABGpBEHUiEiAYwUwNAyAJIA5PDQMgCSAPaiACOgAAIAlBAWohCQwDCyAMQShB+OXEABCcBwALIAIgDkHEtsQAEJwHAAsgCSAOQdS2xAAQjQoACyAJIA5NDQAgCSAOQeS2xAAQjQoACyAeIBI7AQggHiAJNgIEIB4gDzYCACAGQdAGaiQADAMLIARBKEH45cQAEI0KAAtBiObEAEEaQfjlxAAQnggACyALQcgIaiALQZgIaigCADYCACALIAspA5AINwPACAsgCy4ByAgiAiAYSgRAIAtBCGogCygCwAggCygCxAggAiADIAtBkAhqEJkEIAsoAgwhBCALKAIIDAQLQQIhBCALQQI7AZAIIAMEQCALQaAIaiADNgIAIAtBADsBnAggC0ECNgKYCCALQfjGxAA2ApQIIAtBkAhqDAQLQQEhBCALQQE2ApgIIAtBqsjEADYClAggC0GQCGoMAwtBAiEEIAtBAjsBkAggAwRAIAtBoAhqIAM2AgAgC0EAOwGcCCALQQI2ApgIIAtB+MbEADYClAggC0GQCGoMAwtBASEEIAtBATYCmAggC0GqyMQANgKUCCALQZAIagwCCyALQQM2ApgIIAtBq8jEADYClAggC0ECOwGQCCALQZAIagwBCyALQQM2ApgIIAtBrsjEADYClAggC0ECOwGQCCALQZAIagshAiALQcwIaiAENgIAIAsgAjYCyAggCyAdNgLECCALIB82AsAIIAAgC0HACGoQgwMgC0HwCGokAA8LQbfIxABBJUHcyMQAEJ4IAAsgBUEoQfjlxAAQjQoAC4wHAQ1/AkACQCACKAIAIgtBIiACKAIEIg0oAhAiDhEBAEUEQAJAIAFFBEBBACECDAELIAAgAWohD0EAIQIgACEHAkADQAJAIAciCCwAACIFQQBOBEAgCEEBaiEHIAVB/wFxIQMMAQsgCC0AAUE/cSEEIAVBH3EhAyAFQV9NBEAgA0EGdCAEciEDIAhBAmohBwwBCyAILQACQT9xIARBBnRyIQQgCEEDaiEHIAVBcEkEQCAEIANBDHRyIQMMAQsgA0ESdEGAgPAAcSAHLQAAQT9xIARBBnRyciIDQYCAxABGDQIgCEEEaiEHC0GCgMQAIQVBMCEEAkACQAJAAkACQAJAAkACQAJAIAMOIwYBAQEBAQEBAQIEAQEDAQEBAQEBAQEBAQEBAQEBAQEBAQEFAAsgA0HcAEYNBAsgAxCvBEUEQCADENQFDQYLIANBgYDEAEYNBSADQQFyZ0ECdkEHcyEEIAMhBQwEC0H0ACEEDAMLQfIAIQQMAgtB7gAhBAwBCyADIQQLIAIgBksNAQJAIAJFDQAgASACTQRAIAEgAkYNAQwDCyAAIAJqLAAAQUBIDQILAkAgBkUNACABIAZNBEAgASAGRw0DDAELIAAgBmosAABBv39MDQILIAsgACACaiAGIAJrIA0oAgwRAgAEQEEBDwtBBSECA0AgAiEMIAUhCkGBgMQAIQVB3AAhCQJAAkACQAJAAkBBAyAKQYCAxABrIApB///DAE0bQQFrDgMBBAACC0EAIQJB/QAhCSAKIQUCQAJAAkAgDEH/AXFBAWsOBQYFAAECBAtBAiECQfsAIQkMBQtBAyECQfUAIQkMBAtBBCECQdwAIQkMAwtBgIDEACEFIAQhCSAEQYCAxABHDQILAn9BASADQYABSQ0AGkECIANBgBBJDQAaQQNBBCADQYCABEkbCyAGaiECDAMLIAxBASAEGyECIAUgBEECdHZBD3EiCkEwQdcAIApBCkkbaiEJIARBAWtBACAEGyEECyALIAkgDhEBAEUNAAtBAQ8LIAYgCGsgB2ohBiAHIA9HDQEMAgsLIAAgASACIAZBhNLEABDqCQALIAJFBEBBACECDAELIAEgAk0EQCABIAJGDQEMBAsgACACaiwAAEG/f0wNAwsgCyAAIAJqIAEgAmsgDSgCDBECAEUNAQtBAQ8LIAtBIiAOEQEADwsgACABIAIgAUGU0sQAEOoJAAuwBgERfwJAIAMgAUEMaigCACIPLwEyIgkgAUEEaigCACIGLwEyIgogAhtNBEAgCkEBaiILIAlqIhFBC0sNASABKAIQIRIgASgCACETIAEoAhQiBy8BMiEMIAYgETsBMiABKAIYIg1BAnQiFCAHQQRqIgRqIgEoAgAhECABIAQgDUEBaiIEQQJ0IghqIAwgDUF/c2oiDkECdCIFEN8KGiAGQQRqIgEgCkECdGogEDYCACABIAtBAnRqIA9BBGogCUECdCIQEOAKGiAHQTRqIgEgCGogASAUakEIaiAFEN8KGgJAIAQgDE8NACAMIA1rQQJrIA5BA3EiDgRAIA1BAnQgB2pBOGohAQNAIAEoAgAiBSAEOwEwIAUgBzYCACABQQRqIQEgBEEBaiEEIA5BAWsiDg0ACwtBA0kNACAEQQNqIQFBACAMayEIIARBAnQgB2pBQGshBANAIARBDGsoAgAiBSABQQNrOwEwIAUgBzYCACAEQQhrKAIAIgUgAUECazsBMCAFIAc2AgAgBEEEaygCACIFIAFBAWs7ATAgBSAHNgIAIAQoAgAiBSABOwEwIAUgBzYCACAEQRBqIQQgCCABQQRqIgFqQQNHDQALCyAHIAcvATJBAWs7ATICQCASQQFNDQAgBiALQQJ0akE0aiAPQTRqIBBBBGoQ4AoaIAogEU8NACALIQQgCUEBakEDcSIIBEAgCkECdCAGakE4aiEBA0AgASgCACIFIAQ7ATAgBSAGNgIAIAFBBGohASAEQQFqIQQgCEEBayIIDQALCyAJQQNJDQAgBEEDaiEBQX4gCSAKamshCCAEQQJ0IAZqQUBrIQQDQCAEQQxrKAIAIgUgAUEDazsBMCAFIAY2AgAgBEEIaygCACIFIAFBAms7ATAgBSAGNgIAIARBBGsoAgAiBSABQQFrOwEwIAUgBjYCACAEKAIAIgUgATsBMCAFIAY2AgAgBEEQaiEEIAggAUEEaiIBakEDRw0ACwsgDxDUASAAIAY2AgQgACATNgIAIAAgC0EAIAIbIANqNgIIDwtB4IjBAEGRAUH0icEAEJ4IAAtBhIrBAEEqQbCKwQAQnggAC/wGAgZ/A34jAEEgayIEJAACQCABRQRAIAAQjAMMAQsgACgCACECIABBADYCACAAQQhqKQMAIQggACgCBCEFAkACQAJAAkACQAJAAkACQAJAIAJBAWsOBQQEAwABBQtBAiECIAEpAwAiCSAIUg0BQQUhAwwHCyABKQMAIgogCFIEQCAFrSEJIAAoAhwiAigCCCEDA0AgCadB/wBxIAlCP1YiAUEHdHIhBSAJQgeIIQkgAyACKAIARgRAIAIgA0EBEJwGIAIoAgghAwsgAyACKAIEaiAFOgAAIAIgAigCCEEBaiIDNgIIIAZBAWohBiABDQALIAAoAhggBmohBgNAIAinQf8AcSAIQv8AViIBQQd0ciEFIAhCB4ghCCADIAIoAgBGBEAgAiADQQEQnAYgAigCCCEDCyADIAIoAgRqIAU6AAAgAiACKAIIQQFqIgM2AgggBkEBaiEGIAENAAsgACAGNgIYQQQhAyAKIQgMBwsgBUEBaiECQQUhAwwGC0EQQQgQ8AkiAUUNAyABIAg3AwAgAa1CgICAgBCEIQhBAyEDDAULIAApAxAhCiAEIAg3AgQgBCAFNgIAIAogASkDACIJUQ0DIAUgCEIgiKciAkcEfyAIpwUgBCAFEI0GIAQoAgghAiAEKAIEC0EDIQMgAkEDdGogCjcDACAEIAQoAghBAWo2AgggBCgCACECIAQpAgQhCAwECyAAKAIcIgIoAgghAyADIAIoAgBGBEAgAiADQQEQnAYgAigCCCEDCyADIAIoAgRqQQA6AAAgAiACKAIIQQFqIgM2AgggACgCGEEBaiEGIAWtIQgDQCAIp0H/AHEgCEL/AFYiBUEHdHIhByAIQgeIIQggAyACKAIARgRAIAIgA0EBEJwGIAIoAgghAwsgAyACKAIEaiAHOgAAIAIgAigCCEEBaiIDNgIIIAZBAWohBiAFDQALIAAgBjYCGAsgASkDACEIQQQhAwwCC0EQQQhB8PTEACgCACIAQcoEIAAbEQAAAAsgBEEQaiIBQQhqIARBCGooAgA2AgAgBCAEKQMANwMQIAAgARDfBEECIQJBBSEDIAAoAgBBA0cEQCAKIQgMAQsgACgCBEUEQCAKIQgMAQsgAEEIaigCABDUASAKIQgLIAAgCTcDECAAIAI2AgQgACADNgIAIABBCGogCDcDAAsgBEEgaiQAC+QIAQ5/IwBB4ABrIgIkACACQSBqIAFBIGooAgA2AgAgAkEYaiABQRhqKQIANwMAIAJBEGogAUEQaikCADcDACACQQhqIAFBCGopAgA3AwAgAiABKQIANwMAAkACQAJAIAIQygIiAQRAAn8gAS8BAEUEQCABQRBqKAIAIQogAUEMaigCACEFIAFBCGooAgAhByABLwECIQ0gAUEEaigCAAwBCyABQQhqKAIAIQNBASEIQQEhByABQQxqKAIAIgUEQCAFQQBOIgFFDQQgBSABEPAJIgdFDQMLIAcgAyAFEOAKGiAFC0EEIAIoAiBBAWoiA0F/IAMbIgMgA0EETRsiCUHmzJkzSw0CIAlBFGwiBkEASA0CIQsgCUHnzJkzSUECdCEEIAYEfyAGIAQQ8AkFIAQLIgMEQCADIAs2AgQgAyANOwECIAMgCDsBACADIAU2AgwgAyAHNgIIIAMgCjYCECACQQE2AjAgAiADNgIsIAIgCTYCKCACQThqIgFBIGogAkEgaigCADYCACABQRhqIAJBGGopAwA3AwAgAUEQaiACQRBqKQMANwMAIAFBCGogAkEIaikDADcDACACIAIpAwA3AzggARDKAiIBBEBBJCELQQEhBwNAAkACQAJAAn8gAS8BAEUEQCABQRBqKAIAIQogAUEIaigCACEIIAFBBGooAgAhBSABLwECIQ1BACEJIAFBDGooAgAMAQsgAUEIaigCACEKQQEhCUEBIQggAUEMaigCACIFBEAgBUEASA0KIAVBARDwCSIIRQ0CCyAIIAogBRDgChogBQshASAHIAIoAihGDQEMAgsgBUEBQfD0xAAoAgAiAEHKBCAAGxEAAAALIAJBKGohBCACKAJYQQFqIQYjAEEgayIDJAACQAJAIAcgBkF/IAYbaiIGIAdJDQBBBCAEKAIAIgxBAXQiDiAGIAYgDkkbIgYgBkEETRsiBkEUbCEOIAZB58yZM0lBAnQhDwJAIAwEQCADIAxBFGw2AhQgA0EENgIYIAMgBEEEaigCADYCEAwBCyADQQA2AhgLIAMgDiAPIANBEGoQygYgAygCBCEMIAMoAgBFBEAgBCAGNgIAIARBBGogDDYCAAwCCyADQQhqKAIAIgRBgYCAgHhGDQEgBEUNACAMIARB8PTEACgCACIAQcoEIAAbEQAAAAsQxwgACyADQSBqJAAgAigCLCEDCyADIAtqIgQgCjYCACAEQQRrIAE2AgAgBEEIayAINgIAIARBDGsgBTYCACAEQQ5rIA07AQAgBEEQayAJOwEAIAIgB0EBaiIHNgIwIAtBFGohCyACQThqEMoCIgENAAsLIAJBOGoQ1AIgACACKQMoNwIAIABBCGogAkEwaigCADYCAAwECyAGIARB8PTEACgCACIAQcoEIAAbEQAAAAsgAEEANgIIIABCgICAgMAANwIAIAIQ1AIMAgsgBSABQfD0xAAoAgAiAEHKBCAAGxEAAAALEMcIAAsgAkHgAGokAAvYBgIIfwJ+IwBBIGsiBCQAIAEoAgAhAiABQQA2AgAgAUEIaikDACEKIAEoAgQhBQJAAkACQAJAAkACQAJAAkAgAkECaw4EAQIDBAALIAAgASkCHDcCACAAIAEoAhg2AgwgAEEIaiABQSRqKAIANgIADAYLIAFBJGooAgAiAyABKAIcRgRAIAFBHGogA0EBEJwGIAEoAiQhAwsgASADQQFqIgI2AiQgAyABKAIgIgNqQQA6AAAgASABKAIYQQFqNgIYIAWtIQogAUEcaiEFA0AgCqdB/wBxIApC/wBWIghBB3RyIQkgCkIHiCEKIAEgAiABKAIcRwR/IAIFIAUgAkEBEJwGIAEoAiAhAyABKAIkCyIHQQFqIgI2AiQgAyAHaiAJOgAAIAZBAWohBiAIDQALIAEgASgCGCAGajYCGAwECyABKQMQIQsgBCAKNwIEIAQgBTYCACAFIApCIIinIgJHBH8gCqcFIAQgBRCNBiAEKAIIIQIgBCgCBAsgAkEDdGogCzcDACAEQQhqIgMoAgBBAWohAiADIAI2AgAgBEEQaiIDQQhqIAI2AgAgBCAEKQMANwMQIAEgAxCuBAwDC0EIQQgQ8AkiAkUNASACIAo3AwAgBEEBNgIYIAQgAjYCFCAEQQE2AhAgASAEQRBqEK4EDAILIAFBJGooAgAhAiAFrSELIAFBHGohBQNAIAunQf8AcSALQj9WIghBB3RyIQkgC0IHiCELIAEgAiABKAIcRwR/IAIFIAUgAkEBEJwGIAEoAiQLIgdBAWoiAjYCJCAHIAEoAiAiA2ogCToAACAGQQFqIQYgCA0ACyABIAEoAhggBmo2AhhBACEGIAFBHGohBQNAIAqnQf8AcSAKQkB9Qv8AViIIQQd0ciEJIApCB4chCiABIAIgASgCHEcEfyACBSAFIAJBARCcBiABKAIgIQMgASgCJAsiB0EBaiICNgIkIAMgB2ogCToAACAGQQFqIQYgCA0ACyABIAEoAhggBmo2AhgMAQtBCEEIQfD0xAAoAgAiAEHKBCAAGxEAAAALIAAgASkCHDcCACAAIAEoAhg2AgwgAEEIaiABQSRqKAIANgIAIAEoAgBBA0cNACABKAIERQ0AIAFBCGooAgAQ1AELIARBIGokAAuABwELfwJAAkACQAJAIAAoAggiBSABKAIIRgRAIAVBACAAKAIEIgMbIQkgBUEAIAEoAgQiBBshCiADRUEBdCEHIARFQQF0IQwgASgCACECIAAoAgAhAQNAIAlFBEBBAQ8LAkACQCAHQQFrDgIBBAALQQAhBQJAIAFFDQAgAUEBayABQQdxIgAEQANAIAFBAWshASADKALoAiEDIABBAWsiAA0ACwtBB0kNAANAIAMoAugCKALoAigC6AIoAugCKALoAigC6AIoAugCKALoAiEDIAFBCGsiAQ0ACwtBACEBCyADLwHmAiAFTQRAA0AgAygC4AIiAEUNBSABQQFqIQEgA0HkAmovAQAiBSAAIgMvAeYCTw0ACwsgAyEGIAUiB0EBaiEFAkAgAUUEQAwBCyAGIAVBAnRqQegCaigCACEDQQAhBSABQQFrIgBFDQAgAUECayAAQQdxIgEEQANAIABBAWshACADKALoAiEDIAFBAWsiAQ0ACwtBB0kNAANAIAMoAugCKALoAigC6AIoAugCKALoAigC6AIoAugCKALoAiEDIABBCGsiAA0ACwsgCkUEQEEBDwsCQAJAIAxBAWsOAgEGAAtBACEIAkAgAkUNACACQQFrIAJBB3EiAQRAA0AgAkEBayECIAQoAugCIQQgAUEBayIBDQALC0EHSQ0AA0AgBCgC6AIoAugCKALoAigC6AIoAugCKALoAigC6AIoAugCIQQgAkEIayICDQALC0EAIQILIAQvAeYCIAhNBEADQCAEKALgAiIARQ0HIAJBAWohAiAEQeQCai8BACIIIAAiBC8B5gJPDQALCyAEIQAgBiAHQQV0aiAIIgZBAWohCAJAIAJFBEAMAQsgACAIQQJ0akHoAmooAgAhBEEAIQggAkEBayIBRQ0AIAJBAmsgAUEHcSICBEADQCABQQFrIQEgBCgC6AIhBCACQQFrIgINAAsLQQdJDQADQCAEKALoAigC6AIoAugCKALoAigC6AIoAugCKALoAigC6AIhBCABQQhrIgENAAsLIAlBAWshCSAKQQFrIQpBACECQQEh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CUH0AGshCiABQeAAaigCACEEA0AgDiACIARxIgIgCWopAAAiDYUiDEKBgoSIkKDAgAF9IAxCf4WDQoCBgoSIkKDAgH+DIQwDQCAMUARAIA0gDUIBhoNCgIGChIiQoMCAf4NCAFINAyACIAtBCGoiC2ohAgwCCyAMeiEPIAxCAX0gDIMhDCAKIA+nQQN2IAJqIARxQYx/bGoiBSgCACAHRw0AIAVBBGooAgAgCEcNAAsLQQAhAiMAQRBrIgckAAJAAkACQCAFQQhqIgQoAlxBAUcNACAEQeAAaigCACADKAIARw0AIAQoAgxFDQAgB0EIaiAEIAQoAmQQkgUgBygCCEUNACAHKAIMIgIgBEHMAGooAgAiBU8NASADIARByABqKAIAIAJB0ABsaiIFIAMtADQQ2QMiAjYCCCADIAIgBCgCYGo2AgQgA0EYaigCACICIAMoAhBGBEAgA0EQaiACEIQGIAMoAhghAgsgA0EUaigCACACQQJ0aiAFNgIAQQEhAiADIAMoAhhBAWo2AhggBCgCZCEIIANBJGooAgAiBSADKAIcRgRAIANBHGogBRCEBiADKAIkIQULIANBIGooAgAgBUECdGogCDYCACADIAMoAiRBAWo2AiQgAyAEKAJkQQFqNgIMCyAHQRBqJAAMAQsgAiAFQeSLwgAQnAcACyACDQQgBkEIaiICQTBqIgUgA0EwaikCADcDACACQShqIgggA0EoaikCADcDACACQSBqIgkgA0EgaikCADcDACACQRhqIgogA0EYaikCADcDACACQRBqIgsgA0EQaikCADcDACACQQhqIANBCGopAgA3AwAgBiADKQIANwMIIAQoAgwiAkUNAyAGIAZBCGogBEEAIAIbIgMgBEHIAGoiBygCACAEQcwAaiICKAIAEPoCIAYoAgBBAWsOAgECAwsgACADKQIANwIAIABBMGogA0EwaikCADcCACAAQShqIANBKGopAgA3AgAgAEEgaiADQSBqKQIANwIAIABBGGogA0EYaikCADcCACAAQRBqIANBEGopAgA3AgAgAEEIaiADQQhqKQIANwIADAQLIAMgBkEIaiABIAcoAgAgAigCAEEBIAYoAgQQsgIaDAELIAMgBkEIaiABIAcoAgAgAigCAEEAIAIQsgIaCyAAIAYpAwg3AgAgAEEwaiAFKQMANwIAIABBKGog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BCAAIAg2AgAgCiALNwMACyAFQSBqJAALhQYBEH8jAEHgA2siAiQAIAJBCGogACABEPoBIAJBGGoiBCABQaACEOAKGiAAIAQgAigCECIEELEBIARB2ABsIQYgAigCCCACKAIMIgUhAQJAAkAgBEUNACACQZADakEEciEJIAJB3ABqIQdBACEEA0AgBCAFaiIBQcgAaigCACIKQQJGBEAgAUHYAGohAQwCCyABKAIAIQMgAiABQQRqKAIANgK8AiACIAM2ArgCIAJB0AJqIgNBCGoiCyABQRBqKQMANwMAIANBEGoiDCABQRhqKQMANwMAIANBGGoiDSABQSBqKQMANwMAIANBIGoiDiABQShqKQMANwMAIANBKGoiDyABQTBqKQMANwMAIANBMGoiECABQThqKQMANwMAIANBOGoiAyABQUBrKQMANwMAIAJByAJqIhEgAUHUAGooAgA2AgAgAiABQQhqKQMANwPQAiACIAFBzABqKQIANwPAAiACQRhqIgFBOGogAykDADcDACABQTBqIBApAwA3AwAgAUEoaiAPKQMANwMAIAFBIGogDikDADcDACABQRhqIA0pAwA3AwAgAUEQaiAMKQMANwMAIAFBCGogCykDADcDACACIAIpA9ACNwMYIAIgCjYCWCAHIAIpA8ACNwIAIAdBCGogESgCADYCACACQZADaiAAIAJBuAJqIAEQ0QICQCACLQCQAyIBQQprQf8BcUEDSQ0AAkACQAJAIAEOCQABAwMDAwMDAgMLIAIoApQDRQ0CIAIoApgDENQBDAILIAItAKsDQRhHDQEgAigClAMiAygCACEBIAMgAUEBazYCACABQQFHDQEgCRCuCAwBCyACKAKUA0UNACACKAKYAxDUAQsgAigCuAMEQCACKAK8AxDUAQsgAigCxAMEQCACKALIAxDUAQsgBiAEQdgAaiIERw0ACwwBCyAFIAZqIgAgAUYNACAAIAFrQdgAbkHYAGwhBCABQQhqIQEDQCABELIGIAFB2ABqIQEgBEHYAGsiBA0ACwsEQCAFENQBCyACQeADaiQAC7olAhd/Bn4jAEFAaiITJAACQAJAQQMgAi0AACIFQQprIAVBCU0bQf8BcQ4EAAEBAAELIAIoAkBFBEAgAkEkaigCACEGIAIoAiAhBCATQSBqIglBCGogAkFAayIDQQhqKAIANgIA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CSkDADcDGCABQRRqIAlByABqKAIANgIAIAFBIGogCikDADcDACABQShqIAcpAwA3AwAgAUEwaiAIKQMANwMAIABBCGoiACAAKAIAQQFqNgIADAELIAIvAQwiAEEDcUEDR0EAIABBAWsbDQAgAkEQaigCAEUNACACQRRqKAIAENQBCyAJQdAAaiQAC7cGAQZ/AkAgASgCICICRQRAIAEoAgAhBCABQQI2AgAgASgCCCEDIAEoAgQhAgJAAkACQCAEQQFrDgIBBAALIAJFBEBBACECDAILIAJBAWsgAkEHcSIEBEADQCACQQFrIQIgAygC6AIhAyAEQQFrIgQNAAsLQQdJBEBBACECDAILA0AgAygC6AIoAugCKALoAigC6AIoAugCKALoAigC6AIoAugCIQMgAkEIayICDQALQQAhAgwBCyADRQ0CCwNAIAMoAuACQZgDQegCIAIbBEAgAxDUAQsgAkEBaiECIgMNAAsMAQsgASACQQFrNgIgAn8CQAJAAkAgASgCAEEBaw4CAgEACyABQQhqKAIAIQICQCABKAIEIgNFDQAgA0EBayADQQdxIgQEQANAIANBAWshAyACKALoAiECIARBAWsiBA0ACwtBB0kNAANAIAIoAugCKALoAigC6AIoAugCKALoAigC6AIoAugCKALoAiECIANBCGsiAw0ACwsgAUEANgIMIAEgAjYCCCABQgE3AgBBAAwCC0HsicAAQStB+IrAABCeCAALIAFBDGooAgAhBiABQQhqKAIAIQIgASgCBAshBANAIAIvAeYCIAZLBEAgBkEBaiEFAkACQAJAIARFBEAgAiEDDAELIAIgBUECdGpB6AJqKAIAIQMgBEEBayIFDQFBACEFCyABIAU2AgwgASADNgIIIAFBADYCBAwBCyAEQQJrIAVBB3EiBARAA0AgBUEBayEFIAMoAugCIQMgBEEBayIEDQALC0EHTwRAA0AgAygC6AIoAugCKALoAigC6AIoAugCKALoAigC6AIoAugCIQMgBUEIayIFDQALC0EAIQUgAUEANgIMIAEgAzYCCCABQQA2AgQgAkUNAwsgACACIAZBBXRqIgEpAAA3AAEgAEEZaiABQRhqKQAANwAAIABBEWogAUEQaikAADcAACAAQQlqIAFBCGopAAA3AABBASEFDAILIAIoAuACIgMEQCACQeQCai8B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QcgAaiABNgIAIAJBCzYCRCACQQo6AEALIAAgAikDQDcDACAAQRhqIAJBQGsiAUEYaikDADcDACAAQRBqIAFBEGopAwA3AwAgAEEIaiABQQhqKQMANwMADAELIAIgBTYCOCACQQc6ADAgAkEANgJ4IAJCgICAgBA3A3AgAkFAayIBQQM6ACAgAUKAgICAgAQ3AhggAUEANgIQIAFBADYCCCABQfTCwQA2AgQgASACQfAAajYCACACQQxqQQE2AgAgAkEUakEANgIAIAJB1PHBADYCCCACQYTnwQA2AhAgAkEANgIAIAEgAhDkBw0PIAJB5MnBAEEFIAJB8ABqEM8FIAJB0wBqIAJBEGopAwA3AAAgAkHLAGogAkEIaikDADcAACACIAIpAwA3AEMgAEEKOgAAIAAgAikAQDcAASAAQQlqIAJBQGsiAUEIaikAADcAACAAQRFqIAFBEGopAAA3AAAgAEEYaiACQdcAaigAADYAACACLQAwIgBBBnFBBkYgAEEGT3ENACACQTBqENgGCyACQZABaiQADAkLIwBBkAFrIgIkAAJAIAFBQGsoAgAiAyALQgSIpyIFaiIEIAFBPGooAgAgAUE4aigCACIHIAFBMGooAgAiCBtNBEAgAyAESw0LIAFBNGooAgAhCSABIAQ2AkAgAUHEAGogBTYCACACQQA2AlAgAiAFNgJMIAIgByAJIAgbIANqIgE2AkggAiAFNgJEIAIgATYCQCACIAJBQGsQ0AECQAJAIAIoAgAEQCACKAIEDQEgAiACKQMYNwNIIAJBAjoAQAwCCyACQShqIAJBDGooAgA2AgAgAiACKQIENwMgIAJBADYCOCACQoCAgIAQNwMwIAJBQGsiAUEDOgAgIAFCgICAgIAENwIYIAFBADYCECABQQA2AgggAUH0wsEANgIEIAEgAkEwajYCAAJAIAItACBBBkYEQCACQfAAaiIBQQxqQQE2AgAgAkGEAWpBADYCACACQdTjwgA2AnggAkHo0cIANgKAASACQQA2AnAgAkFAayABEOQHRQ0BDBMLIAIgAkEgajYCZCACQfAAaiIBQQxqQQE2AgAgAkGEAWpBATYCACACQZTgwgA2AnggAkEANgJwIAJBggI2AmwgAiACQegAajYCgAEgAiACQeQAajYCaCACQUBrIAEQ5AcNEgsgAkFAa0EEckHkycEA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A0AgAkEANgJYIAJCgICAgBA3A1AgAUEDOgAgIAFCgICAgIAENwIYIAFBADYCECABQQA2AgggAUH0wsEANgIEIAEgAkHQAGo2AgACQCACLQBAQQZGBEAgAkGQAWoiAUEMakEBNgIAIAJBpAFqQQA2AgAgAkHU48IANgKYASACQejRwgA2AqABIAJBADYCkAEgAkHgAGogARDkB0UNAQwRCyACIAJBQGs2AoQBIAJBkAFqIgFBDGpBATYCACACQaQBakEBNgIAIAJBlODCADYCmAEgAkEANgKQASACQYICNgKMASACIAJBiAFqNgKgASACIAJBhAFqNgKIASACQeAAaiABEOQHDRALIAJB4ABqQQRyQeTJwQBBBSACQdAAahDPBSACQQo6AGAgAi0AQEEGRg0BIAJBQGsQ2AYMAQtBDEEEEPAJIgFFDQpBBUEBEPAJIgNFDQsgAUEFNgIIIAEgAzYCBCABQQU2AgAgA0EEakHoycEALQAAOgAAIANB5MnBACgAADYAACACQfgAakEBNgIAIAJB9ABqIAE2AgAgAkEBNgJwQQtBARDwCSIBRQ0MIAFBB2pBu8rBACgAADYAACABQbTKwQApAAA3AAAgAkHsAGpBCzYCACACQegAaiABNgIAIAJBCzYCZCACQQo6AGALIAAgAikDYDcDACAAQRhqIAJB4ABqIgFBGGopAwA3AwAgAEEQaiABQRBqKQMANwMAIABBCGogAUEIaikDADcDAAwBCyACIAU2AlggAkEHOgBQIAJBADYCmAEgAkKAgICAEDcDkAEgAkEIaiIBQQM6ACAgAUKAgICAgAQ3AhggAUEANgIQIAFBADYCCCABQfTCwQA2AgQgASACQZABajYCACACQewAakEBNgIAIAJB9ABqQQA2AgAgAkHU8cEANgJoIAJBhOfBADYCcCACQQA2AmAgASACQeAAahDkBw0MIAJB4ABqIgFB5MnBAEEFIAJBkAFqEM8FIAJBG2ogAUEQaikDADcAACACQRNqIAFBCGopAwA3AAAgAiACKQNgNwALIABBCjoAACAAIAIpAAg3AAEgAEEJaiACQQhqIgFBCGopAAA3AAAgAEERaiABQRBqKQAANwAAIABBGGogAkEfaigAADYAACACLQBQIgBBBnFBBkYgAEEGT3ENACACQdAAahDYBgsgAkGwAWokAAwFCyMAQbABayICJAACQCABQUBrKAIAIgMgC0IEiKciBWoiBCABQTxqKAIAIAFBOGooAgAiByABQTBqKAIAIggbTQRAIAMgBEsNByABQTRqKAIAIQkgASAENgJAIAFBxABqIAU2AgAgAkEANgIYIAIgBTYCFCACIAcgCSAIGyADaiIBNgIQIAIgBTYCDCACIAE2AgggAkHgAGogAkEIahDQAQJAAkAgAigCYARAIAJBCGoiAUEIaiACQeAAaiIDQQhqIgQpAwA3AwAgAUEQaiADQRBqIgMoAgA2AgAgAiACKQNgNwMIIAIgAikDeDcDKCACQQY6ACAgAigCDA0BIAJB+ABqIAJBIGoiAUEYaikDADcDACADIAFBEGopAwA3AwAgBCABQQhqKQMANwMAIAIgASkDADcDYAwCCyACQRBqIAJB4ABqIgFBDGooAgAiAzYCACACIAIpAmQiCzcDCCACQQo6ACAgAkHIAGogAzYCACACIAs3A0AgAkEANgJYIAJCgICAgBA3A1AgAUEDOgAgIAFCgICAgIAENwIYIAFBADYCECABQQA2AgggAUH0wsEANgIEIAEgAkHQAGo2AgACQCACLQBAQQZGBEAgAkGQAWoiAUEMakEBNgIAIAJBpAFqQQA2AgAgAkHU48IANgKYASACQejRwgA2AqABIAJBADYCkAEgAkHgAGogARDkB0UNAQwQCyACIAJBQGs2AoQBIAJBkAFqIgFBDGpBATYCACACQaQBakEBNgIAIAJBlODCADYCmAEgAkEANgKQASACQYICNgKMASACIAJBiAFqNgKgASACIAJBhAFqNgKIASACQeAAaiABEOQHDQ8LIAJB4ABqQQRyQeTJwQBBBSACQdAAahDPBSACQQo6AGAgAi0AQEEGRg0BIAJBQGsQ2AYMAQtBDEEEEPAJIgFFDQlBBUEBEPAJIgNFDQogAUEFNgIIIAEgAzYCBCABQQU2AgAgA0EEakHoycEALQAAOgAAIANB5MnBACgAADYAACACQfgAakEBNgIAIAJB9ABqIAE2AgAgAkEBNgJwQQtBARDwCSIBRQ0LIAFBB2pBu8rBACgAADYAACABQbTKwQApAAA3AAAgAkHsAGpBCzYCACACQegAaiABNgIAIAJBCzYCZCACQQo6AGALIAAgAikDYDcDACAAQRhqIAJB4ABqIgFBGGopAwA3AwAgAEEQaiABQRBqKQMANwMAIABBCGogAUEIaikDADcDAAwBCyACIAU2AlggAkEHOgBQIAJBADYCmAEgAkKAgICAEDcDkAEgAkEIaiIBQQM6ACAgAUKAgICAgAQ3AhggAUEANgIQIAFBADYCCCABQfTCwQA2AgQgASACQZABajYCACACQewAakEBNgIAIAJB9ABqQQA2AgAgAkHU8cEANgJoIAJBhOfBADYCcCACQQA2AmAgASACQeAAahDkBw0LIAJB4ABqIgFB5MnBAEEFIAJBkAFqEM8FIAJBG2ogAUEQaikDADcAACACQRNqIAFBCGopAwA3AAAgAiACKQNgNwALIABBCjoAACAAIAIpAAg3AAEgAEEJaiACQQhqIgFBCGopAAA3AAAgAEERaiABQRBqKQAANwAAIABBGGogAkEfaigAADYAACACLQBQIgBBBnFBBkYgAEEGT3ENACACQdAAahDYBgsgAkGwAWokAAwECyMAQeAAayICJAACQAJAAkACQAJAIAFBQGsoAgAiAyALQgSIpyIFaiIEIAFBPGooAgAgAUE4aigCACIIIAFBMGooAgAiCRtNBEAgAyAESw0KIAFBNGooAgAhCiABIAQ2AkAgAUHEAGogBTYCAAJAIAVFBEBBASEBDAELIAVBAE4iBEUNAyAFIAQQ8AkiAUUNBAsgASAIIAogCRsgA2ogBRDgCiEBIAAgBTYCDCAAIAE2AgggACAFNgIEIAAgBzoAASAAQQg6AAAMAQsgAiAFNgIIIAJBBzoAACACQQA2AhggAkKAgICAEDcDECACQSBqIgFBAzoAICABQoCAgICABDcCGCABQQA2AhAgAUEANgIIIAFB9MLBADYCBCABIAJBEGo2AgAgAkHUAGpBATYCACACQdwAakEANgIAIAJB1PHBADYCUCACQYTnwQA2AlggAkEANgJIIAEgAkHIAGoQ5AcNAyACQcgAaiIBQeTJwQBBBSACQRBqEM8FIAJBM2ogAUEQaikDADcAACACQStqIAFBCGopAwA3AAAgAiACKQNINwAjIABBCjoAACAAIAIpACA3AAEgAEEJaiACQSBqIgFBCGopAAA3AAAgAEERaiABQRBqKQAANwAAIABBGGogAkE3aigAADYAACACLQAAIgBBBnFBBkYgAEEGT3ENACACENgGCyACQeAAaiQADAMLEMcIAAsgBSAEQfD0xAAoAgAiAEHKBCAAGxEAAAALQYzDwQBBNyACQcgAakHEw8EAQaDEwQAQhwcACwwDCyALQgSIpyIEIAFBMGoiASgCECIDaiECAkACQCAGQQhqIgUgAiABQQxqKAIAIAFBCGooAgAiByABKAIAIggbTQR/IAIgA0kNASABQQRqKAIAIQkgASACNgIQIAEgBDYCFCAFQQhqIAQ2AgAgBSAHIAkgCBsgA2o2AgRBCAVBBws6AAAMAQsgAyACQYjswQAQjgoACyAGLQAIQQhGDQEgBkEYaiIEQQhqIAZBEGooAgA2AgAgBiAGKQMINwMYIwBB0ABrIgEkACAGQeAAaiIDQQA2AgggA0KAgICAEDcCACABQQhqIgJBAzoAICACQoCAgICABDcCGCACQQA2AhAgAkEANgIIIAJB9MLBADYCBCACIAM2AgACQAJAAkACQAJAQQIgBC0AACICQQZrIAJBBU0bQf8BcUEBaw4CAgABCyAEIAFBCGoQwQNFDQMMAgsgAUE8akEBNgIAIAFBxABqQQA2AgAgAUH48cEANgI4IAFBhOfBADYCQCABQQA2AjAgAUEIaiABQTBqEOQHDQEMAgsgAUE8akEBNgIAIAFBxABqQQA2AgAgAUHU8cEANgI4IAFBhOfBADYCQCABQQA2AjAgAUEIaiABQTBqEOQHRQ0BC0GMw8EAQTcgAUHIAGpBxMPBAEGgxMEAEIcHAAsgAUHQAGokACAGQcgAaiIBQeTJwQBBBSADEM8FIAZBO2ogAUEQaikDADcAACAGQTNqIAFBCGopAwA3AAAgBiAGKQNINwArIABBCjoAACAAIAYpACg3AAEgAEEJaiAGQShqIgFBCGopAAA3AAAgAEERaiABQRBqKQAANwAAIABBGGogBkE/aigAADYAACAGLQAYIgBBBnFBBkYgAEEGT3ENAiAGQRhqENgGDAILQQRBAUHw9MQAKAIAIgBBygQgABsRAAAACyAGKAIMIQMCQCAGQRBqKAIAIgFFBEBBASECDAELIAFBAE4EQCABIAFBf3NBH3YiBBDwCSICDQEgASAEQfD0xAAoAgAiAEHKBCAAGxEAAAALEMcIAAsgBiACNgIEIAYgATYCACAGKAIAIQIgBigCBCADIAEQ4AohAyAAIAE2AAwgACADNgAIIAAgAjYABCAAQQA6AAALIAZB8ABqJAAPCyADIARBiOzBABCOCgALQQxBBEHw9MQAKAIAIgBBygQgABsRAAAAC0EFQQFB8PTEACgCACIAQcoEIAAbEQAAAAtBC0EBQfD0xAAoAgAiAEHKBCAAGxEAAAALQYzDwQBBNyACQYgBakHEw8EAQaDEwQAQhwcAC0GMw8EAQTcgAkGoAWpBxMPBAEGgxMEAEIcHAAu3BgEGfwJAIAEoAiAiAkUEQCABKAIAIQQgAUECNgIAIAEoAgghAyABKAIEIQICQAJAAkAgBEEBaw4CAQQACyACRQRAQQAhAgwCCyACQQFrIAJBB3EiBARAA0AgAkEBayECIAMoAugCIQMgBEEBayIEDQALC0EHSQRAQQAhAgwCCwNAIAMoAugCKALoAigC6AIoAugCKALoAigC6AIoAugCKALoAiEDIAJBCGsiAg0AC0EAIQIMAQsgA0UNAgsDQCADKALgAkGYA0HoAiACGwRAIAMQ1AELIAJBAWohAiIDDQALDAELIAEgAkEBazYCIAJ/AkACQAJAIAEoAgBBAWsOAgIBAAsgAUEIaigCACECAkAgASgCBCIDRQ0AIANBAWsgA0EHcSIEBEADQCADQQFrIQMgAigC6AIhAiAEQQFrIgQNAAsLQQdJDQADQCACKALoAigC6AIoAugCKALoAigC6AIoAugCKALoAigC6AIhAiADQQhrIgMNAAsLIAFBADYCDCABIAI2AgggAUIBNwIAQQAMAgtB0PjCAEErQdz5wgAQnggACyABQQxqKAIAIQYgAUEIaigCACECIAEoAgQLIQQDQCACLwHmAiAGSwRAIAZBAWohBQJAAkACQCAERQRAIAIhAwwBCyACIAVBAnRqQegCaigCACEDIARBAWsiBQ0BQQAhBQsgASAFNgIMIAEgAzYCCCABQQA2AgQMAQsgBEECayAFQQdxIgQEQANAIAVBAWshBSADKALoAiEDIARBAWsiBA0ACwtBB08EQANAIAMoAugCKALoAigC6AIoAugCKALoAigC6AIoAugCKALoAiEDIAVBCGsiBQ0ACwtBACEFIAFBADYCDCABIAM2AgggAUEANgIEIAJFDQMLIAAgAiAGQQV0aiIBKQAANwABIABBGWogAUEYaikAADcAACAAQRFqIAFBEGopAAA3AAAgAEEJaiABQQhqKQAANwAAQQEhBQwCCyACKALgAiID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AE8NAyAMKAIAIAVqKAIAIg0gBE8NAiAHQSBqIAEgAyANQdAAbGoQlwYgBygCIEEDRw0DDAgLIAYgCUF/c2ohBgwCC0EAIQYgACALKAIATw0BIAwoAgAgBWooAgAiCSAESQRAIAdBGGogASADIAlB0ABsahCXBiAHKAIYQQNHDQIMBQsgCSAEQYz5wAAQnAcACyANIARBjPnAABCcBwALIAhBxABqIQggAEEBaiEAIAVBBGohBSAKQcQAayIKDQALQQAhCQwDCyAGQQAgBRshBiAAQTxqKAIAIgggAEFAaygCAEECdGohAANAAkAgBkUEQCAAIAhHDQEMBQsgBiAAIAhrQQJ2Tw0EIAggBkECdGohCAsgCCgCACICIARJBEAgByABIAMgAkHQAGxqEJcGIAhBBGohCEEAIQYgBygCAEEDRw0BDAILCyACIARBnPnAABCcBwALQQEhCQwBCyAJQcQAbCEFIABBQGshCyAAQTxqIQxBASEJQQAhAEEAIQYDQCAHQRBqIAEgCCADIAQQwQQCQAJAIAcoAhBBAWsOAwUAAwELIAggASACIAMgBEEAIAgQswINAgsgCygCACAGSwRAIAwoAgAgAGooAgAiCiAETw0DIAdBCGogASADIApB0ABsahCXBiAHKAIIQQNGDQILIAhBxABqIQggBkEBaiEGIABBBGohACAFQcQAayIFDQALQQAhCQsgB0FAayQAIAkPCyAKIARBjPnAABCcBwALIAdBNGpBATYCACAHQTxqQQA2AgAgB0HI+cAANgIwIAdBkPXAADYCOCAHQQA2AiggB0EoakHQ+cAAENoIAAuMBgEHfyMAQUBqIgckAAJAAkACQAJAAkAgAEE0aigCAARAIABBNGooAgAiCUUEQEEAIQkMBAsgAEEwaigCACEIIAVFDQIgCUHEAGwhCkEAIQUgAEFAayELIABBPGohDEEAIQADQAJAAkACQCAIKAIoIgkgBk8EQCAGIAlGDQFBASEJIAggASACIAMgBEEBIAYQtAINCEEAIQYgACALKAIATw0DIAwoAgAgBWooAgAiDSAETw0CIAdBIGogASADIA1B0ABsahDzBCAHKAIgQQNHDQMMCAsgBiAJQX9zaiEGDAILQQAhBiAAIAsoAgBPDQEgDCgCACAFaigCACIJIARJBEAgB0EYaiABIAMgCUHQAGxqEPME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IAUtAA4hACAFIAYtAA46AA4gBiAAOgAOIAUtAA8hACAFIAYtAA86AA8gBiAAOgAPDAELCyAOIA1BGXYiADoAACAEQQhrIAtxIAlqQQhqIAA6AAAMAQsgDkH/AToAACAEQQhrIAtxIAlqQQhqQf8BOgAAIAZBCGogBUEIaikAADcAACAGIAUpAAA3AAALIARBAWohACAEIAtHDQALCyAHIBAgFms2AgQLCyARQSBqJAAgFCAHKAIAIgRxIgAgB0EMaigCACIDaikAAEKAgYKEiJCgwIB/gyIXUARAQQghAgNAIAAgAmohACACQQhqIQIgAyAAIARxIgBqKQAAQoCBgoSIkKDAgH+DIhdQDQALCyADIBd6p0EDdiAAaiAEcSICaiwAAEEASA0AIAMpAwBCgIGChIiQoMCAf4N6p0EDdiECCyACIANqIBRBGXYiADoAACACQQhrIARxIANqQQhqIAA6AAAgByAHKAIEIBVrNgIEIAcgBygCCEEBajYCCCADIAJBBHRrQRBrIgBBCGogE0EIaikCADcCACAAIBMpAgA3AgALIApBIGokACASC/UFAQd/An8gAQRAQStBgIDEACAAKAIYIglBAXEiARshCiABIAVqDAELIAAoAhghCUEtIQogBUEBagshCAJAIAlBBHFFBEBBACECDAELAkAgA0EQTwRAIAIgAxDSASEGDAELIANFBEAMAQsgA0EDcSELAkAgA0EBa0EDSQRAIAIhAQwBCyADQXxxIQcgAiEBA0AgBiABLAAAQb9/SmogASwAAUG/f0pqIAEsAAJBv39KaiABLAADQb9/SmohBiABQQRqIQEgB0EEayIHDQALCyALRQ0AA0AgBiABLAAAQb9/SmohBiABQQFqIQEgC0EBayILDQALCyAGIAhqIQgLAkACQCAAKAIIRQRAQQEhASAAKAIAIgcgAEEEaigCACIAIAogAiADENIIDQEMAgsCQAJAAkACQCAIIABBDGooAgAiB0kEQCAJQQhxDQQgByAIayIGIQdBASAALQAgIgEgAUEDRhtBA3EiAUEBaw4CAQIDC0EBIQEgACgCACIHIABBBGooAgAiACAKIAIgAxDSCA0EDAULQQAhByAGIQEMAQsgBkEBdiEBIAZBAWpBAXYhBwsgAUEBaiEBIABBBGooAgAhBiAAKAIcIQggACgCACEAAkADQCABQQFrIgFFDQEgACAIIAYoAhARAQBFDQALQQEPC0EBIQEgCEGAgMQARg0BIAAgBiAKIAIgAxDSCA0BIAAgBCAFIAYoAgwRAgANAUEAIQECfwNAIAcgASAHRg0BGiABQQFqIQEgACAIIAYoAhARAQBFDQALIAFBAWsLIAdJIQEMAQsgACgCHCELIABBMDYCHCAALQAgIQxBASEBIABBAToAICAAKAIAIgYgAEEEaigCACIJIAogAiADENIIDQAgByAIa0EBaiEBAkADQCABQQFrIgFFDQEgBkEwIAkoAhARAQBFDQALQQEPC0EBIQEgBiAEIAUgCSgCDBECAA0AIAAgDDoAICAAIAs2AhxBAA8LIAEPCyAHIAQgBSAAKAIMEQIAC/IZAgd/BX4jAEHwAGsiBSQAIwBBkAJrIgMkACADQUBrIAEQgQJCAiEKAkACQAJAAkAgBUHQAGoiBwJ/AkACQAJAAkACQAJAAkAgAygCQEEBaw4CAQIACyADQdAAaikDACEOIAMpA0ghCgwBCyADKAJEIQQgAyADQcgAaikDADcCRCADIAQ2AkAgA0GwAWpB8LXCAEEFIANBQGsQpgQgAykDsAEhCiADKALAASIEDQEgAykDuAEhDgsgA0FAayABQegAahCAAgJAAkACQCADKAJAQQFrDgICAAELQgIhCwwECyADKQNIUA0DIAFBmAFqIgQpAwAiDCADQdAAaikDACINfCILQj+HQoCAgICAgICAgH+FIAsgDUIAUyALIAxTcxshDCAEIAw3AwBCASELDAMLIAMoAkQhBCADIANByABqKQMANwJEIAMgBDYCQCADQbABakH4tMIAQQcgA0FAaxCmBCADKQOwASELIAMoAsABIgRFDQEgA0EgaiADKALEATYCACADQRxqIAQ2AgAgA0EUaiADKQO4ATcCACADIAs3AgwMAwsgA0EgaiADKALEATYCACADQRxqIAQ2AgAgA0EUaiADKQO4ATcCACADIAo3AgwgA0EBNgIIDAILIAMpA7gBIQwLIANBCGogAUEwahC+AQJAAkACQAJAAkACQAJAAkACQAJAIAMtAB8iAUEcaw4CAwEACyADQZgBaiIEQQ9qIANBCGoiBkEPaikAADcAACAEQQhqIAZBCGopAwA3AwAgAyADKQMINwOYASABQR1HDQEMAwtBHCEBCyADQdMAaiAD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DQEgAEE0ayIKKAIAIgsoAgAhAiALIAJBAWs2AgAgAkEBRw0BIAoQrggMAQsgAEE0aygCAEUNACAAQTBrKAIAENQBCyABQShqKAIABEAgAEEMaygCABDUAQsgAUE0aigCAARAIAAoAgAQ1AELIABB0ABqIQAgAUHQAGogCUcNAAsLIAxCAX0hDSAFQQFrIQUgBCgCAARAIARBBGooAgAQ1AELIAwgDYMhDCAFDQALCyAHQfQAbEH7AGpBeHEiACAHakF3Rg0AIAMgAGsQ1AELC+EFAQ9/IwBB8ANrIgIkACACQQhqIAAgARD6ASACQRhqIgMgAUGgAhDgChogACADIAIoAhAiARCxASACKAIIIQMgAiACKAIMIgQ2AsQCIAIgAUHYAGwiByAEajYCwAIgAiAENgK8AiACIAM2ArgCAkAgAUUNACACQaADakEEciEIIAJB3ABqIQUDQCACIAQgBmoiAUHYAGo2ArwCIAFByABqKAIAIglBAkYNASABKAIAIQMgAiABQQRqKAIANgLMAiACIAM2AsgCIAJB4AJqIgNBCGoiCiABQRBqKQMANwMAIANBEGoiCyABQRhqKQMANwMAIANBGGoiDCABQSBqKQMANwMAIANBIGoiDSABQShqKQMANwMAIANBKGoiDiABQTBqKQMANwMAIANBMGoiDyABQThqKQMANwMAIANBOGoiAyABQUBrKQMANwMAIAJB2AJqIhAgAUHUAGooAgA2AgAgAiABQQhqKQMANwPgAiACIAFBzABqKQIANwPQAiACQRhqIgFBOGogAykDADcDACABQTBqIA8pAwA3AwAgAUEoaiAOKQMANwMAIAFBIGogDSkDADcDACABQRhqIAwpAwA3AwAgAUEQaiALKQMANwMAIAFBCGogCikDADcDACACIAIpA+ACNwMYIAIgCTYCWCAFIAIpA9ACNwIAIAVBCGogECgCADYCACACQaADaiAAIAJByAJqIAEQ0QICQCACLQCgAyIBQQprQf8BcUEDSQ0AAkACQAJAIAEOCQABAwMDAwMDAgMLIAIoAqQDRQ0CIAIoAqgDENQBDAILIAItALsDQRhHDQEgAigCpAMiAygCACEBIAMgAUEBazYCACABQQFHDQEgCBCuCAwBCyACKAKkA0UNACACKAKoAxDUAQsgAigCyAMEQCACKALMAxDUAQsgAigC1AMEQCACKALYAxDUAQsgByAGQdgAaiIGRw0ACwsgAkG4AmoQ9AQgAkHwA2okAAv+DQIRfwV+IwBB8ABrIgQkACACKAIIIRIgBEEwaiABQdAAaikDADcDACAEQShqIAFByABqKQMANwMAIARBIGogAUFAaykDADcDACAEQRhqIAFBOGopAwA3AwAgBCABKQMwNwMQIARByABqIARBEGoQigIgBCgCSCAEKAJMIQggBCgCUCILIAIoAgAgEiIDa0sEQCACIBIgCxCcBiACKAIIIQMLIAIoAgQiESADaiAIIAsQ4AoaIAIgAyALaiILNgIIBEAgCBDUAQsgBEEQaiIDQShqIAFBKGopAwAiFTcDACADQSBqIAFBIGopAwAiFjcDACADQRhqIAFBGGopAwAiFzcDACADQRBqIAFBEGopAwAiGDcDACADQQhqIAFBCGopAwAiFDcDACAEIAEpAwA3AxAgBEHIAGoiA0EgaiAVNwMAIANBGGogFjcDACADQRBqIBc3AwAgA0EIaiAYNwMAIAQgFDcDSCAEIAMQiAIgBCgCACAEKAIEIQcgBCgCCCIIIAIoAgAgCyIDa0sEQCACIAsgCBCcBiACKAIEIREgAigCCCEDCyADIBFqIAcgCBDgChogAiADIAhqIgg2AggEQCAHENQBCyAEQUBrIAFBiAFqKQIANwMAIARBOGogAUGAAWopAgA3AwAgBEEwaiABQfgAaikCADcDACAEQShqIAFB8ABqKQIANwMAIARBIGogAUHoAGopAgA3AwAgBEEYaiABQeAAaikCADcDACAEIAEpAlg3AxAgBEHIAGohEyMAQTBrIgYkACAEQRBqIgEoAgAhBSABQQA2AgAgASgCHCEMIAEoAhghDyABKAIUIRAgASgCECEJIAEoAgwhAyABKAIIIQ0gASgCBCEOAkACQAJAAkACQAJAAkAgBUECaw4EAAECAwQLIAFBNGooAgAiAyABKAIsRgRAIAFBLGogA0EBEJwGIAEoAjQhAwsgASgCMCADakEAOgAAIAEgA0EBaiIDNgI0IAEgASgCKEEBajYCKCAOrSEUIAFBLGohCQNAIBSnQf8AcSAUQv8AViIMQQd0ciEHIBRCB4ghFCABIAMgASgCLEcEfyADBSAJIANBARCcBiABKAI0CyIFQQFqIgM2AjQgASgCMCAFaiAHOgAAIApB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IgcgAU8NDCAIQQNqIAFPDQIgCkEDaiAAIAdqLQAAOgAAIAZBBGohBiALQQFrIgsNAAsgAyAGaiEDIAIgBmohAgsgBEEDcUEBaw4DAwIBFAsgCEEDaiABQazGwwAQnAcACyACIAVxIgQgAU8NCSABIANNDQogACADaiAAIARqLQAAOgAAIAJBAWogBXEiBCABTw0LIANBAWoiBiABTw0MIAAgBmogACAEai0AADoAACACQQJqIAVxIgYgAU8NDSADQQJqIgMgAUkNESADIAFBjMfDABCcBwALIAIgBXEiBCABTw0NIAEgA00EQCADIAFBrMfDABCcBwALIAAgA2ogACAEai0AADoAACACQQFqIAVxIgYgAUkNDyAGIAFBvMfDABCcBwALIAIgBXEiBiABSQ0NIAYgAUHcx8MAEJwHAAsgByABQbzFwwAQnAcACyAIIAFBzMXDABCcBwALIAcgAUHcxcMAEJwHAAsgCEEBaiABQezFwwAQnAcACyAHIAFB/MXDABCcBwALIAhBAmogAUGMxsMAEJwHAAsgByABQZzGwwAQnAcACyAEIAFBvMbDABCcBwALIAMgAUHMxsMAEJwHAAsgBCABQdzGwwAQnAcACyAGIAFB7MbDABCcBwALIAYgAUH8xsMAEJwHAAsgBCABQZzHwwAQnAcACyABIANLDQEgAyABQezHwwAQnAcACyADQQFqIgMgAUkNACADIAFBzMfDABCcBwALIAAgA2ogACAGai0AADoAAAsLjAYCBn8CfiMAQSBrIgQkACABKAIAIQIgAUEANgIAIAFBCGopAwAhCCABKAIEIQUCQAJAAkACQAJAAkACQAJAIAJBAmsOBAECAwQACyABKAIYIQMgASgCHCECDAYLIAEoAhwiAygCCCECIAIgAygCAEYEQCADIAJBARCcBiADKAIIIQILIAIgAygCBGpBADoAACADIAMoAghBAWoiAjYCCCABKAIYQQFqIQYgBa0hCANAIAinQf8AcSAIQv8AViIFQQd0ciEHIAhCB4ghCCACIAMoAgBGBEAgAyACQQEQnAYgAygCCCECCyACIAMoAgRqIAc6AAAgAyADKAIIQQFqIgI2AgggBkEBaiEGIAUNAAsgASAGNgIYDAQLIAEpAxAhCSAEIAg3AgQgBCAFNgIAIAUgCEIgiKciA0cEfyAIpwUgBCAFEI0G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AkHIAGoiBSgCACACQcwAaiICKAIAEJQBIAQoAgBBAWsOAgECAwsgACADKQIANwIAIABBMGogA0EwaikCADcCACAAQShqIANBKGopAgA3AgAgAEEgaiADQSBqKQIANwIAIABBGGogA0EYaikCADcCACAAQRBqIANBEGopAgA3AgAgAEEIaiADQQhqKQIANwIADAMLIAMgBEEIaiABIAUoAgAgAigCAEEBIAQoAgQQ3AIaDAELIAMgBEEIaiABIAUoAgAgAigCAEEAIAIQ3AIaCyAAIAQpAwg3AgAgAEEwaiAGKQMANwIAIABBKGogBykDADcCACAAQSBqIAgpAwA3AgAgAEEYaiAJKQMANwIAIABBEGogCikDADcCACAAQQhqIAspAwA3AgALIARBQGskAAvLBQEJfyABKAIAIQYgAEEMaigCACEKAkACQAJAAkACQAJAAkACfyAAKAIAIgcgAigCACIEQRRsaiIFLwEARQRAIAUvAQIiCEERTw0DIAVBBGoMAQsgBUEMaigCACEIIAVBCGooAgALAn8gByAGQRRsaiIFLwEARQRAIAUvAQIiCUERTw0EIAVBBGoMAQsgBUEMaigCACEJIAVBCGooAgALIAggCSAIIAlJGxDhCiIFIAggCWsgBRtBAE4EQCAGIQUgBCEGDAELIAogCigCAEEBajYCACACIAY2AgAgASAENgIAIABBDGooAgAhCiAAKAIAIQcgBCEFCwJAAn8gByADKAIAIgtBFGxqIgQvAQBFBEAgBC8BAiIIQRFPDQUgBEEEagwBCyAEQQxqKAIAIQggBEEIaigCAAsCfyAHIAZBFGxqIgQvAQAiDEUEQCAELwECIglBEU8NBiAEQQRqDAELIARBDGooAgAhCSAEQQhqKAIACyAIIAkgCCAJSRsQ4QoiBCAIIAlrIAQbQQBOBEAgBiELDAELIAogCigCAEEBajYCACADIAY2AgAgAiALNgIAIABBDGooAgAhCiAAKAIAIgcgC0EUbGovAQAhDAsgByALQRRsaiEAAn8gDEUEQCAALwECIgZBEU8NBiAAQQRqDAELIABBDGooAgAhBiAAQQhqKAIACwJ/IAcgBUEUbGoiAC8BAEUEQCAALwECIgdBEU8NByAAQQRqDAELIABBDGooAgAhByAAQQhqKAIACyAGIAcgBiAHSRsQ4QoiACAGIAdr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AgAgBCgCCCIHa0sEQCAEIAcgCxCcBiAEKAIIIQcLIAQoAgQgB2ogASALEOAKGiAEIAcgC2o2AgggBigCACIBIAwoAgBrIgZBACABIAZPGyEBIAxBCGooAgALIQYgASAOaiEBIAgoAggiByAIKAIARgRAIAggBxCDBiAIKAIIIQcLIAxBDGohDCAIKAIEIAdBDGxqIgcgBjYCCCAHIAE2AgQgByAONgIAIAggCCgCCEEBajYCCCABIQ4gFEEMayIUDQALCyAAIAgpAwA3AgAgAEEIaiAIQQhqKAIANgIAIAhBQGskAA8LEMcIAAsgDCAGQfD0xAAoAgAiAEHKBCAAGxEAAAALIAcgAUH07sEAEI4KAAsgASADQfTuwQAQjQoACyAHIAFB5O7BABCOCgALIAEgA0Hk7sEAEI0KAAsgCCAIKQMwNwM4QcTkwQBBKyAIQThqQajuwQBBhO/BABCHBwALtgUCCH8FfiMAQfAAayIDJAAgAigCCCEJIANBOGogAUHQAGopAwA3AwAgA0EwaiABQcgAaikDADcDACADQShqIAFBQGspAwA3AwAgA0EgaiABQThqKQMANwMAIAMgASkDMDcDGCADQcgAaiADQRhqEIoCIAMoAkggAygCTCEEIAMoAlAiBSACKAIAIAkiBmtLBEAgAiAJIAUQnAYgAigCCCEGCyACKAIEIgggBmogBCAFEOAKGiACIAUgBmoiBjYCCARAIAQQ1AELIANBOGogAUH4AGopAwA3AwAgA0EwaiABQfAAaikDADcDACADQShqIAFB6ABqKQMANwMAIANBIGogAUHgAGopAwA3AwAgAyABKQNYNwMYIANByABqIANBGGoQigIgAygCSCADKAJMIQcgAygCUCIEIAIoAgAgBiIFa0sEQCACIAYgBBCcBiACKAIEIQggAigCCCEFCyAFIAhqIAcgBBDgChogAiAEIAVqIgU2AggEQCAHENQBCyADQRhqIgRBKGogAUEoaikDACILNwMAIARBIGogAUEgaikDACIMNwMAIARBGGogAUEYaikDACINNwMAIARBEGogAUEQaikDACIONwMAIARBCGogAUEIaikDACIPNwMAIAMgASkDADcDGCADQcgAaiIBQSBqIAs3AwAgAUEYaiAMNwMAIAFBEGogDTcDACABQQhqIA43AwAgAyAPNwNIIANBCGog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IARBEGopAwA3AwAgA0EIaiAEQQhqKQMANwMAIAEgASkD+AQ3A8gEIAFB3AJqIAFBrAVqQewBEOAKGiAKQQJHDQELIAtBADYCCCALQoCAgICAATcCAAwBCyABQagCaiIDQShqIAkpAwA3AwAgA0EgaiAMKQMANwMAIANBGGogDSkDADcDACADQRBqIA4pAwA3AwAgA0EIaiIJIAFB0ARqKQMANwMAIAEgASkDyAQ3A6gCIAFBPGogAUHcAmpB7AEQ4AoaQYAJQQgQ8AkiA0UNASADIAEpA6gCNwMAIAMgCjYCMCADQShqIAFBqAJqIgRBKGoiDikDADcDACADQSBqIARBIGoiESkDADcDACADQRhqIARBGGoiEikDADcDACADQRBqIARBEGoiEykDADcDACADQQhqIAkpAwA3AwAgA0E0aiABQTxqQewBEOAKGiABQQE2AiAgASADNgIcIAFBBDYCGCABQShqIgRBCGogAUEQaikDADcDACABIAEpAwg3AyggAUH4BGogBCABKAI0EOQCAkAgASgCqAUiDEEDRg0AIAFBrAVqIRRB1AIhDUEBIQoDQCABQcgEaiIEQShqIg8gAUH4BGoiCUEoaikDADcDACAEQSBqIhUgCUEgaikDADcDACAEQRhqIhYgCUEYaikDADcDACAEQRBqIhcgCUEQaikDADcDACAEQQhqIgQgCUEIaikDADcDACABIAEpA/gENwPIBCABQdwCaiAUQewBEOAKGiAMQQJGDQEgDiAPKQMANwMAIBEgFSkDADcDACASIBYpAwA3AwAgEyAXKQMANwMAIAFBsAJqIg8gBCkDADcDACABIAEpA8gENwOoAiABQTxqIAFB3AJqQewBEOAKGiABKAIYIApGBEAgAUEYaiAKQQEQ9gUgASgCHCEDCyADIA1qIglBNGsiBCABKQOoAjcDACAPKQMAIRggEykDACEZIBIpAwAhGiARKQMAIRsgDikDACEcIAlBBGsgDDYCACAEQShqIBw3AwAgBEEgaiAbNwMAIARBGGogGjcDACAEQRBqIBk3AwAgBEEIaiAYNwMAIAkgAUE8akHsARDgChogASAKQQFqIgo2AiAgAUH4BGogAUEoaiABKAI0EOQCIA1BoAJqIQ0gASgCqAUiDEEDRw0ACwsgC0EIaiABQSBqKAIANgIAIAsgASkDGDcCAAsg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DQAgEyADQXRsaiEOIAIgA0F/c0EMbGohBAJAA0AgAiAOKAIAIgAgDkEEaigCACAAGyIMIAVxIg8iAWopAABCgIGChIiQoMCAf4MiFVAEQEEIIQADQCAAIAFqIQEgAEEIaiEAIAIgASAFcSIBaikAAEKAgYKEiJCgwIB/gyIVUA0ACwsgAiAVeqdBA3YgAWogBXEiAWosAABBAE4EQCACKQMAQoCBgoSIkKDAgH+DeqdBA3YhAQsgASAPayADIA9rcyAFcUEITwRAIAIgAUF/c0EMbGohACABIAJqIg8tAAAgDyAMQRl2Igw6AAAgAUEIayAFcSACakEIaiAMOgAAQf8BRg0CIAQoAAAhASAEIAAoAAA2AAAgACABNgAAIAAoAAQhASAAIAQoAAQ2AAQgBCABNgAEIAQtAAohASAEIAAtAAo6AAogACABOgAKIAQtAAshASAEIAAtAAs6AAsgACABOgALIAQvAAghASAEIAAvAAg7AAggACABOwAIDAELCyANIAxBGXYiADoAACADQQhrIAVxIAJqQQhqIAA6AAAMAQsgDUH/AToAACADQQhrIAVxIAJqQQhqQf8BOgAAIABBCGogBEEIaigAADYAACAAIAQpAAA3AAALIANBAWohACADIAVHDQALCyAHIAggCWs2AgQMBAtBBEEIIAFBBEkbCyIArUIMfiIVQiCIpw0AIBWnIgJBB2ohASABIAJJDQAgAUF4cSIEIABBCGoiCGohASABIARPDQELEIcIIAsoAhQaDAELAkACQCABQQBOBEBBCCECAkAgAUUNACABQQgQ8AkiAg0AIAFBCEHw9MQAKAIAIgBBygQgABsRAAAACyACIARqQf8BIAgQ4gohBCAAQQFrIgggAEEDdkEHbCAIQQhJGyAJayENIANFBEAgByANNgIEIAcgCDYCACAHKAIMIQkgByAENgIMDAMLIAdBDGooAgAiCUEMayEOQQAhAgNAIAIgCWosAABBAE4EQCAEIA4gAkF0bGoiACgCACIBIABBBGooAgAgARsiDCAIcSIBaikAAEKAgYKEiJCgwIB/gyIVUARAQQghAANAIAAgAWohASAAQQhqIQAgBCABIAhxIgFqKQAAQoCBgoSIkKDAgH+DIhVQDQALCyAEIBV6p0EDdiABaiAIcSIAaiwAAEEATgRAIAQpAwBCgIGChIiQoMCA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AigCACIDKAIAIQEgAyABQQFrNgIAIAFBAUcNACACEK4ICwJAIAAoAgBFDQAgACgCBEUNACAAQQhqKAIAENQBCwJAIABByANqKAIARQ0AIABBzANqKAIARQ0AIABB0ANqKAIAENQBCwJAIABB6ANqKAIARQ0AIABB7ANqKAIARQ0AIABB8ANqKAIAENQBCwJAIABBkARqKAIARQ0AIABBlARqKAIARQ0AIABBmARqKAIAENQBCwJAIABBwARqKAIARQ0AIABBxARqKAIARQ0AIABByARqKAIAENQBCwJAIABB8ARqKAIARQ0AIABB9ARqKAIARQ0AIABB+ARqKAIAENQBCwudCAIJfwV+IwBBgAFrIgQkAAJAAkADQAJAIAEoAjQiAgRAIAFBACACQSBqIAIgASgCMEYiAxs2AjQgA0UNAQsgASgCLEUNAiABKAIkIgMgASgCKEYNAiABIANBBGo2AiQgAygCACICRQ0CCyAEQeAAaiIDQRhqIAJBGGopAAA3AwAgA0EQaiACQRBqKQAANwMAIANBCGogAkEIaikAADcDACAEIAIpAAA3A2AgBEEoaiECQQAhBiABIAMQzwMiDEIZiEL/AINCgYKEiJCgwIABfiEOIAynIQUgAUEcaigCACEHIAFBEGoiCCgCACEJAkACQANAIAUgCXEiBSAHaikAACINIA6FIgtCgYKEiJCgwIABfSALQn+Fg0KAgYKEiJCgwIB/gyELA0AgC1AEQCANIA1CAYaDQoCBgoSIkKDAgH+DQgBSDQMgBSAGQQhqIgZqIQUMAgsgC3ohDyALQgF9IAuDIQsgByAPp0EDdiAFaiAJcUEFdGsiCkEgayADQSAQ4QoNAAsLIAIgCjYCBCACQQ1qIAMpAAA3AAAgAkEMakEBOgAAIAJBCGogCDYCACACQSVqIANBGGopAAA3AAAgAkEdaiADQRBqKQAANwAAIAJBFWogA0EIaikAADcAACACQQA2AgAMAQsgAUEUaigCAEUEQCABQRBqQQEgARCVAQsgAiADKQAANwAIIAJBMGogCDYCACACQShqIAw3AwAgAkEgaiADQRhqKQAANwAAIAJBGGogA0EQaikAADcAACACQRBqIANBCGopAAA3AAAgAkEBNgIACyAEKAIoRQ0ACyAEQSBqIARByABqKQMANwIAIARBGGogBEFAaykDADcC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IAM2AiQgACAGIAEQ9AMMAQsgAkEkakEBNgIAIAJBLGpBADYCACACQbDswQA2AiAgAkGE58EANgIoIAJBADYCGCACQRhqQeDswQAQ2ggACyACQUBrJAAL7wQBB38CQCAAKAIEIgJFDQAgACgCACEBAkAgACgCCCIGBEBBASEAA0ACQCAAQQFxRQRAIAQhBQwBC0EAIQUCQCABRQ0AIAFBAWshAyABQQdxIgAEQANAIAFBAWshASACKAKQAiECIABBAWsiAA0ACwsgA0EHSQ0AA0AgAigCkAIoApACKAKQAigCkAIoApACKAKQAigCkAIoApACIQIgAUEIayIBDQALC0EAIQELIAIhACAGQQFrIQYDQCAALwGOAiAFSwRAIAVBAWohBAJAIAFFBEAgACECDAELIAAgBEECdGpBkAJqKAIAIQJBACEEIAFBAWsiA0UNACABQQJrIANBB3EiAQRAA0AgA0EBayEDIAIoApACIQIgAUEBayIBDQALC0EHTwRAA0AgAigCkAIoApACKAKQAigCkAIoApACKAKQAigCkAIoApACIQIgA0EIayIDDQALCyAARQ0GCwJAIAAgBUEUbGpBBGoiAC8BAEUNACAAKAIERQ0AIABBCGooAgAQ1AELQQAhAUEAIQAgBg0CDAQLIAAoAgAiAgRAIAFBAWohAyAAQYwCai8BACEFC0HAAkGQAiABGwRAIAAQ1AELIAMhASACIgANAAsLQeyKwQBBK0H4i8EAEJ4IAAsgAUUNACABQQFrIAFBB3EiAARAA0AgAUEBayEBIAIoApACIQIgAEEBayIADQALC0EHSQ0AA0AgAigCkAIoApACKAKQAigCkAIoApACKAKQAigCkAIoApACIQIgAUEIayIBDQALC0EAIQADQCACKAIAQcACQZACIAAbBEAgAhDUAQsgAEEBayEAIgINAAsLC+8EAgl/An4jAEEgayIDJAAgACgCACEFIABBADYCACAAQQhqKQMAIQogACgCBCECQQEhBkEBIQECQAJAAkACQAJAAkACQAJAIAVBAWsOBQABAgMEBgsgAkEBaiEGDAULIAJBAWohBkECIQEMBAsgACkDECELIAMgCjcCBCADIAI2AgAgAiAKQiCIpyIBRwR/IAqnBSADIAIQjQYgAygCCCEBIAMoAgQLIAFBA3RqIAs3AwAgA0EIaiICKAIA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ACAAIAEgBxD9BzYCBEEBDAELIAAgDCAMmiACGzkDCEEACzYCAAsgB0EQaiQAC/kEAQp/IwBBMGsiAyQAIANBAzoAKCADQoCAgICABDcDICADQQA2AhggA0EANgIQIAMgATYCDCADIAA2AggCfwJAAkAgAigCACIKRQRAIAJBFGooAgAiAEUNASACKAIQIQEgAEEDdCEFIABBAWtB/////wFxQQFqIQcgAigCCCEAA0AgAEEEaigCACIEBEAgAygCCCAAKAIAIAQgAygCDCgCDBECAA0ECyABKAIAIANBCGogAUEEaigCABEBAA0DIAFBCGohASAAQQhqIQAgBUEIayIFDQALDAELIAIoAgQiAEUNACAAQQV0IQsgAEEBa0H///8/cUEBaiEHIAIoAgghAANAIABBBGooAgAiAQRAIAMoAgggACgCACABIAMoAgwoAgwRAgANAwsgAyAFIApqIgRBHGotAAA6ACggAyAEQRRqKQIANwMgIARBEGooAgAhBiACKAIQIQhBACEJQQAhAQJAAkACQCAEQQxqKAIAQQFrDgIAAgELIAggBkEDdGoiDEEEaigCAEHmBEcNASAMKAIAKAIAIQYLQQEhAQsgAyAGNgIUIAMgATYCECAEQQhqKAIAIQECQAJAAkAgBEEEaigCAEEBaw4CAAIBCyAIIAFBA3RqIgZBBGooAgBB5gRHDQEgBigCACgCACEBC0EBIQkLIAMgATYCHCADIAk2AhggCCAEKAIAQQN0aiIBKAIAIANBCGogASgCBBEBAA0CIABBCGohACALIAVBIGoiBUcNAAsLIAJBDGooAgAgB0sEQCADKAIIIAIoAgggB0EDdGoiACgCACAAKAIEIAMoAgwoAgwRAgANAQtBAAwBC0EBCyADQTBqJAALuQUBBn8jAEEQayIEJABBCSECAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQQFrDgkBAgMEBQYHCAkACyABQQhqKAIAIQUCQCABQQxqKAIAIgFFBEBBASECDAELIAFBAE4iA0UNCiABIAMQ8AkiAkUNCwsgACABNgIEIABBCGogAjYCACACIAUgARDgChogAEEMaiABNgIAQQAhAgwICwJ/AkACQAJAQQEgAUEbai0AACICQRhrIAJBF00bQf8BcUEBaw4CAQIACyABQQRqKAIAIgMoAgAhAiADIAJBAWo2AgAgAkEASA0NQRghAiABQQhqKAIADAILIAQgAUEMaikCADcDACAEIAFBE2opAAA3AAcgASgCBCEDIAFBCGooAgAMAQsgASgCBCEDQRohAiABQQhqKAIACyEBIABBE2ogBCkABzcAACAAQQxqIAQpAwA3AgAgAEEbaiACOgAAIABBCGogATYCACAAIAM2AgRBASECDAcLIAAgASkDCDcDCEECIQIMBgsgACABKQMINwMIQQMhAgwFCyAAIAErAwg5AwhBBCECDAQLIAAgASkDCDcDCCAAQRhqIAFBGGooAgA2AgAgAEEQaiABQRBqKQMANwMAQQUhAgwDCyAAIAEpAwg3AwhBBiECDAILIAAgAS0AAToAAUEHIQIMAQtBCCECIAFBCGooAgAhBiABLQABIQcCQCABQQxqKAIAIgFFBEBBASEDDAELIAFBAE4iBUUNAiABIAUQ8AkiA0UNBQsgACABNgIEIABBCGogAzYCACADIAYgARDgChogACAHOgABIABBDGogATYCAAsgACACOgAAIARBEGokAA8LEMcIAAsgASADQfD0xAAoAgAiAEHKBCAAGxEAAAALAAsgASAFQfD0xAAoAgAiAEHKBCAAGxEAAAALqAQBDX8jAEEQayIFJAACQCABLQAlDQAgASgCCCEIAkAgAUEUaigCACIGIAFBEGooAgAiAkkNACABQQxqKAIAIgwgBkkNACABQRhqKAIAIgcgAUEcaiIOakEBayENAkAgB0EETQRAA0AgAiAIaiEJIA0tAAAhCgJ/IAYgAmsiBEEITwRAIAVBCGogCiAJIAQQ6wQgBSgCDCEDIAUoAggMAQtBACEDQQAgBEUNABoDQEEBIAogAyAJai0AAEYNARogBCADQQFqIgNHDQALIAQhA0EAC0EBRw0CIAEgAiADakEBaiICNgIQAkAgAiAHSQ0AIAIgDEsNACACIAdrIgMgCGogDiAHEOEKDQAgASgCACEEIAEgAjYCACADIARrIQMgBCAIaiELDAULIAIgBk0NAAwDCwALA0AgAiAIaiEJIA0tAAAhCgJ/IAYgAmsiBEEITwRAIAUgCiAJIAQQ6wQgBSgCBCEDIAUoAgAMAQtBACEDQQAgBEUNABoDQEEBIAogAyAJai0AAEYNARogBCADQQFqIgNHDQALIAQhA0EAC0EBRw0B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AhQgA0EBNgIQIAAgA0EQahDaBAwBCyABrSEJIAAoAhwiASgCCCECA0AgCadB/wBxIAlCP1YiBUEHdHIhByAJQgeIIQkgAiABKAIARgRAIAEgAkEBEJwGIAEoAgghAgsgAiABKAIEaiAHOgAAIAEgASgCCEEBaiICNgIIIARBAWohBCAFDQALIAAoAhggBGohBANAIAinQf8AcSAIQkB9Qv8AViIFQQd0ciEHIAhCB4chCCACIAEoAgBGBEAgASACQQEQnAYgASgCCCECCyACIAEoAgRqIAc6AAAgASABKAIIQQFqIgI2AgggBEEBaiEEIAUNAAsgACAENgIYC0ECIQIgACgCAEEDRw0AIAAoAgRFDQAgAEEIaigCABDUAQsgACAGNgIEIAAgAjYCACADQSBqJAAPC0EIQQhB8PTEACgCACIAQcoEIAAbEQAAAAvlBAEHfyMAQeAAayICJAAgAkEYaiIDQQhqIAFBCGopAgA3AwAgAiABKQIANwMYIAJBEGogA0EEchDBCAJAAkACQCACKAIQRQRAIABBADYCCCAAQoCAgIDAADcCAAwBCyACKAIUIQEgAiACKAIYIgNBAWo2AhggAkHIAGpBBHIiBkEANgIEIAYgAzYCACACQdgAaiABNgIAQQQgAigCICIBIAIoAhxrIgNBACABIANPG0EBaiIBQX8gARsiASABQQRNGyIEQf///z9LDQIgBEEEdCIHQQBIDQIgBEGAgIDAAElBAnQhBSAHBH8gByAFEPAJBSAFCyIDRQ0BIAMgBikCADcCACADQQhqIAZBCGopAgA3AgAgAkEBNgIwIAIgAzYCLCACIAQ2AiggAkE4aiIBQQhqIAJBIGopAwA3AwAgAiACKQMYNwM4IAJBCGogAUEEciIHEMEIIAIoAggEQCACQcgAakEEciEFIAIoAgwhBEEQIQZBASEBA0AgAiACKAI4IghBAWo2AjggBUEANgIEIAUgCDYCACACIAQ2AlggAigCKCABRgRAIAJBKGogASACKAJAIgMgAigCPGsiBEEAIAMgBE8bQQFqIgNBfyADGxDzBSACKAIsIQMLIAMgBmoiBCAFKQIANwIAIARBCGogBUEIaikCADcCACACIAFBAWoiATYCMCACIAcQwQggBkEQaiEGIAIoAgQhBCACKAIADQALCyAAIAIpAyg3AgAgAEEIaiAC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AkUNACAAKAIAIQECQCAAKAIIIgUEQEEBIQADQCAAQQFxBEBBACEEAkAgAUUNACABQQFrIQMgAUEHcSIABEADQCABQQFrIQEgAigClAMhAiAAQQFrIgANAAsLIANBB0kNAANAIAIoApQDKAKUAygClAMoApQDKAKUAygClAMoApQDKAKUAyECIAFBCGsiAQ0ACwtBACEBCyACIQAgBUEBayEFA0AgAC8BkgMgBEsEQCAEQQFqIQQCQCABRQRAIAAhAgwBCyAAIARBAnRqQZQDaigCACECQQAhBCABQQFrIgNFDQAgAUECayADQQdxIgEEQANAIANBAWshAyACKAKUAyECIAFBAWsiAQ0ACwtBB08EQANAIAIoApQDKAKUAygClAMoApQDKAKUAygClAMoApQDKAKUAyECIANBCGsiAw0ACwsgAEUNBgtBACEBQQAhACAFDQIMBAsgACgC4AIiAgRAIABBkANqLwEAIQQgAUEBaiEDC0HEA0GUAyABGwRAIAAQ1AELIAMhASACIgANAAsLQeDCwABBK0Hsw8AAEJ4IAAsgAUUNACABQQFrIAFBB3EiAARAA0AgAUEBayEBIAIoApQDIQIgAEEBayIADQALC0EHSQ0AA0AgAigClAMoApQDKAKUAygClAMoApQDKAKUAygClAMoApQDIQIgAUEIayIBDQALC0EAIQADQCACKALgAkHEA0GUAyAAGwRAIAIQ1AELIABBAWshACICDQALCwvaBAEIfyMAQSBrIgQkACAAAn8CQAJAIAEoAgQiBSABKAIIIgJLBEBBACAFayEDIAJBBWohAiABKAIAIQcDQCACIAdqIgZBBWstAAAiCEEJayIJQRdLDQJBASAJdEGTgIAEcUUNAiABIAJBBGs2AgggAyACQQFqIgJqQQVHDQALCyAEQQU2AgggACABIARBCGoQ/Ac2AgQMAQsCQAJAAkACQAJAAkAgCEHmAGsODwEDAwMDAwMDAwMDAwMDAAMLIAEgAkEEayIDNgIIIAMgBU8NBCABIAJBA2siAzYCCAJAIAZBBGstAABB8gBHDQAgAyAFTw0FIAEgAkECayIDNgIIIAZBA2stAABB9QBHDQAgAyAFTw0FIAEgAkEBazYCCEEBIQIgBkECay0AAEHlAEYNAgsgBEEJNgIIIAAgASAEQQhqEP0HNgIEDAULIAEgAkEEayIDNgIIIAMgBU8NAiABIAJBA2siAzYCCAJAIAZBBGstAABB4QBHDQAgAyAFTw0DIAEgAkECayIDNgIIIAZBA2stAABB7ABHDQAgAyAFTw0DIAEgAkEBayIDNgIIIAZBAmstAABB8wBHDQAgAyAFTw0DIAEgAjYCCEEAIQIgBkEBay0AAEHlAEYNAQsgBEEJNgIIIAAgASAEQQhqEP0HNgIEDAQLIAAgAjoAAUEADAQLIAAgASAEQRhqQZTzwAAQ3gEgARCKCDYCBAwCCyAEQQU2AgggACABIARBCGoQ/Qc2AgQMAQsgBEEFNgIIIAAgASAEQQhqEP0HNgIEC0EBCzoAACAEQSBqJAALnAQBBn8CQCAAKAIEIgJFDQAgACgCACEBAkAgACgCCCIFBEBBASEAA0AgAEEBcQRAQQAhBAJAIAFFDQAgAUEBayEDIAFBB3EiAARAA0AgAUEBayEBIAIoAjQhAiAAQQFrIgANAAsLIANBB0kNAANAIAIoAjQoAjQoAjQoAjQoAjQoAjQoAjQoAjQhAiABQQhrIgENAAsLQQAhAQsgAiEAIAVBAWshBQNAIAAvATIgBEsEQCAEQQFqIQQCQCABRQRAIAAhAgwBCyAAIARBAnRqQTRqKAIAIQJBACEEIAFBAWsiA0UNACABQQJrIANBB3EiAQRAA0AgA0EBayEDIAIoAjQhAiABQQFrIgENAAsLQQdPBEADQCACKAI0KAI0KAI0KAI0KAI0KAI0KAI0KAI0IQIgA0EIayIDDQALCyAARQ0GC0EAIQFBACEAIAUNAgwECyAAKAIAIgIEQCAAQTBqLwEAIQQgAUEBaiEDC0HkAEE0IAEbBEAgABDUAQsgAyEBIAIiAA0ACwtB7IrBAEErQfiLwQAQnggACyABRQ0AIAFBAWsgAUEHcSIABEADQCABQQFrIQEgAigCNCECIABBAWsiAA0ACwtBB0kNAANAIAIoAjQoAjQoAjQoAjQoAjQoAjQoAjQoAjQhAiABQQhrIgENAAsLQQAhAANAIAIoAgBB5ABBNCAAGwRAIAIQ1AELIABBAWshACICDQALCwugBAEGfwJAIAAoAgQiAkUNACAAKAIAIQECQCAAKAIIIgUEQEEBIQADQCAAQQFxBEBBACEEAkAgAUUNACABQQFrIQMgAUEHcSIABEADQCABQQFrIQEgAigCYCECIABBAWsiAA0ACwsgA0EHSQ0AA0AgAigCYCgCYCgCYCgCYCgCYCgCYCgCYCgCYCECIAFBCGsiAQ0ACwtBACEBCyACIQAgBUEBayEFA0AgAC8BXiAESwRAIARBAWohBAJAIAFFBEAgACECDAELIAAgBEECdGpB4ABqKAIAIQJBACEEIAFBAWsiA0UNACABQQJrIANBB3EiAQRAA0AgA0EBayEDIAIoAmAhAiABQQFrIgENAAsLQQdPBEADQCACKAJgKAJgKAJgKAJgKAJgKAJgKAJgKAJgIQIgA0EIayIDDQALCyAARQ0GC0EAIQFBACEAIAUNAgwECyAAKAJYIgIEQCAAQdwAai8BACEEIAFBAWohAwtBkAFB4AAgARsEQCAAENQBCyADIQEgAiIADQALC0HsisEAQStB+IvBABCeCAALIAFFDQAgAUEBayABQQdxIgAEQANAIAFBAWshASACKAJgIQIgAEEBayIADQALC0EHSQ0AA0AgAigCYCgCYCgCYCgCYCgCYCgCYCgCYCgCYCECIAFBCGsiAQ0ACwtBACEAA0AgAigCWEGQAUHgACAAGwRAIAIQ1AELIABBAWshACICDQALCwu+BAEGfwJAIAAoAgQiAkUNACAAKAIAIQECQCAAKAIIIgUEQEEBIQADQCAAQQFxBEBBACEEAkAgAUUNACABQQFrIQMgAUEHcSIABEADQCABQQFrIQEgAigClAMhAiAAQQFrIgANAAsLIANBB0kNAANAIAIoApQDKAKUAygClAMoApQDKAKUAygClAMoApQDKAKUAyECIAFBCGsiAQ0ACwtBACEBCyACIQAgBUEBayEFA0AgAC8BkgMgBEsEQCAEQQFqIQQCQCABRQRAIAAhAgwBCyAAIARBAnRqQZQDaigCACECQQAhBCABQQFrIgNFDQAgAUECayADQQdxIgEEQANAIANBAWshAyACKAKUAyECIAFBAWsiAQ0ACwtBB08EQANAIAIoApQDKAKUAygClAMoApQDKAKUAygClAMoApQDKAKUAyECIANBCGsiAw0ACwsgAEUNBgtBACEBQQAhACAFDQIMBAsgACgC4AIiAgRAIABBkANqLwEAIQQgAUEBaiEDC0HEA0GUAyABGwRAIAAQ1AELIAMhASACIgANAAsLQeyKwQBBK0H4i8EAEJ4IAAsgAUUNACABQQFrIAFB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IAAQnAYgASgCCCEECyABKAIEIARqIAJBDGogABDgChogASAAIARqNgIIDAALAAv5BAEBfyMAQTBrIgIkAAJ/AkACQAJAAkACQAJAIAAtAABBAWsOBQECAwQFAAsCQAJAAkAgAC0AAUEBaw4CAQIACyACQSRqQQE2AgAgAkEsakEANgIAIAJBlJbBADYCICACQdCQwQA2AiggAkEANgIYIAEgAkEYahDkBwwHCyACQSRqQQE2AgAgAkEsakEANgIAIAJB3JXBADYCICACQdCQwQA2AiggAkEANgIYIAEgAkEYahDkBwwGCyACQSRqQQE2AgAgAkEsakEANgIAIAJBtJXBADYCICACQdCQwQA2AiggAkEANgIYIAEgAkEYahDkBwwFCyACQSRqQQE2AgAgAkEsakEANgIAIAJBuPTCADYCICACQejRwgA2AiggAkEANgIYIAEgAkEYahDkBwwECyACQSRqQQE2AgAgAkEsakEBNgIAIAJB4IzDADYCICACQQA2AhggAkHEAzYCDCACIABBBGo2AhQgAiACQQhqNgIoIAIgAkEUajYCCCABIAJBGGoQ5AcMAwsgAkEkakEBNgIAIAJBLGpBATYCACACQbiMwwA2AiAgAkEANgIYIAJBggM2AgwgAiAAQQFqNgIUIAIgAkEIajYCKCACIAJBFGo2AgggASACQRhqEOQHDAILIAJBJGpBATYCACACQSxqQQA2AgAgAkGYjMMANgIgIAJB0PjCADYCKCACQQA2AhggASACQRhqEOQHDAELIAJBJGpBATYCACACQSxqQQE2AgAgAkHsi8MANgIgIAJBADYCGCACQYECNgIMIAIgAEEEajYCFCACIAJBCGo2AiggAiACQRRqNgIIIAEgAkEYahDkBwsgAkEwaiQAC+UEAQV/IwBB8AFrIgEkACAALQAMQQJGBEAgASAAQeAAahCtASABQagBaiIDQRhqIAFBGGopAwA3AwAgA0EQaiABQRBqKQMANwMAIANBCGogAUEIaikDADcDACABIAEpAwA3A6gBIAFBIGoiAkKAgICAgAE3AjQgAkIANwMIIAIgAykCFDcCKCACIAMoAhA2AhggAiADKQMINwMQIAIgAykDADcDACACQTxqQQA2AgAgAkEgakEANgIAIAJBMGogA0EcaigCADYCACABQbIBaiACQQhqKQMANwEA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Igs3A1ggBEEIaiIFQQhqIAI2AgAgBCALNwMIIARB6ABqIwBBwAFrIgIkACABQShqIgMtAAwhBiACIANBDWpBwwAQ4AohAiADQQI6AAwCQCAGQQJGDQAgAygCACADQdAAaiADKAIEIgYgAygCCCIJEM8HIAJBqAFqIAJBO2opAAA3AwAgAkGgAWogAkEzaikAADcDACACQZgBaiACQStqKQAANwMAIAJBkAFqIAJBI2opAAA3AwAgAkGIAWogAkEbaikAADcDACACQYABaiACQRNqKQAANwMAIAJB8ABqIgpBCGogAkELaikAADcDACACIAIpAAM3A3AgAkEANgK0ASACQcgAaiAKIANB4ABqIAJBsAFqQgBCABDGASAGIAkQkwFFDQAgBhDUAQsgAkEIaiAFQQhqKAIANgIAIAIgBSkCADcDACADQeAAaiACIANB0ABqEI8BIAJBwAFqJAAgBC0AaCICQRNGBEBBACECIAFBADYCAEEAIQEMBQsgBEHPAGogBEGIAWopAAA3AAAgBEHIAGogBEGBAWopAAA3AwAgBEFAayAEQfkAaikAADcDACAEQThqIARB8QBqKQAANwMAIAQgBCkAaTcDMAwDCxDVCgALENYKAAsgBEE7aiAEQfQAaikCADcAACAEIAQpAmw3ADNBEyECCyAEQQhqIgNBH2oiBiAEQTBqIgVBH2opAAA3AAAgA0EYaiIHIAVBGGopAwA3AwAgA0EIaiAFQQhqKQMAIgs3AwAgA0EQaiAFQRBqKQMAIgw3AwAgBCAEKQMwIg03AwggAUEANgIAIARB8QBqIAs3AAAgBEH5AGogDDcAACAEQYEBaiAHKQMANwAAIARBiAFqIAYpAAA3AAAgBCACOgBoIAQgDTcAaUEBIQIjAEHgAGsiAyQAIANBADYCCCADQoCAgIAQNwMAIANBEGoiAUEDOgAgIAFCgICAgIAENwIYIAFBADYCECABQQA2AgggAUHU88AANgIEIAEgAzYCAAJAAkACQCAEQegAaiIFLQAAQRNGBEAgBUEEaiADQRBqEKwFRQ0BDAILIANBxABqQQE2AgAgA0HMAGpBATYCACADQZzOwAA2AkAgA0EANgI4IANBMTYCVCADIAU2AlwgAyADQdAAajYCSCADIANB3ABqNgJQIANBEGogA0E4ahDkBw0BCyADKAIEIAMoAggQAiEBIAMoAgAEQCADKAIEENQBCwJAIAUtAABBE0YEQCAFQQhqKAIADQEgBUEMaigCACAFQRBqIgYoAgAoAgARAwAgBigCACIGQQRqKAIARQ0BIAZBCGooAgAaIAUoAgwQ1AEMAQsgBRCkAwsgA0HgAGokAAwBC0Hs88AAQTcgA0E4akGk9MAAQYD1wAAQhwcACwsgACACNgIEIAAgATYCACAEQZABaiQAC+MDAQN/IwBBMGsiAiQAAkACQAJAAkAgACgCAEEBaw4FAAMDAQIDCyAAKAIEIABBCGoiASgCACgCABEDACABKAIAIgFBBGooAgBFDQIgAUEIaigCABogACgCBBDUAQwCCyAAKAIEQQNHDQEgAEEIaigCACAAQQxqIgEoAgAoAgARAwAgASgCACIBQQRqKAIARQ0BIAFBCGooAgAaIAAoAggQ1AEMAQsgAEEkaigCACIDBEAgAEEgaigCACEBIANBiAJsIQMDQCABEKoFIAFBiAJqIQEgA0GIAmsiAw0ACwsgACgCHARAIABBIGooAgAQ1AELAn8gAEEIaigCACIBBEAgAkEgaiABNgIAIAJBHGogACgCBCIDNgIAIAIgATYCECACQQA2AgggAiADNgIMIABBDGooAgAhA0EADAELIAJBAjYCCEEAIQNBAgshASACIAM2AiggAiABNgIYIAJBCGoQ0gICfyAAQRRqKAIAIgEEQCACQQhqIgNBGGogATYCACADQRRqIABBEGooAgAiAzYCACACIAE2AhAgAkEANgIIIAIgAzYCDCAAQRhqKAIAIQNBAAwBCyACQQI2AghBACEDQQILIQAgAiADNgIoIAIgADYCGCACQQhqENICCyACQTBqJAALzgMBBH8gACgCCCIBBEAgAUH4AGwgACgCBCIBaiEEA0ACQCABLQAAIgBBCmtB/wFxQQNJDQACQAJAAkAgAA4JAAEDAwMDAwMCAwsgASgCBEUNAiABQQhqKAIAENQBDAILIAFBG2otAABBGEcNASABQQRqIgIoAgAiAygCACEAIAMgAEEBazYCACAAQQFHDQEgAhCuCAwBCyABKAIERQ0AIAFBCGooAgAQ1AELAkAgAUEoai8BACIAQQNxQQNHQQAgAEEBaxsNACABQSxqKAIARQ0AIAFBMGooAgAQ1AELAkAgASgCQEUEQCABLQBbQRhHDQEgAUHE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QgIhCAwDCyACQgA3AygLQQELIQEgAkEYaiACQTxqIgQoAgAiAzYCACACQRBqIAJBNGoiBSkCACIINwMAIAJBCGogAkEsaiIHKQIAIgk3AwAgAiACKQIkIgo3AwAgByAJNwIAIAUgCDcCACAEIAM2AgAgAiABNgIgIAIgCjcCJCAGBEBCASEIIAIpAyhQBEBCACEJDAILIAJBMGopAwAhCQwBC0IAIQggAkE7ai0AAEEYRw0AIAIoAiQiBCgCACEBIAQgAUEBazYCACABQQFHDQAgAkEgakEEchCuCAsgACAJNwMIIAAgCDcDACACQUBrJAAPCyAEIANBiMTCABCcBwALIAMgBUHUlMEAEJwHAAunBAECfwJAAkACQAJAAkACQAJAIAJBA08EQCADRQ0BIANBgIACSw0EIAEgASgCiIAEIAJqNgKIgAQgASgCgIAEIgRBgIAETw0HIAEgBGogAkEDayICOgAAIAEgASgCgIAEQQFqIgQ2AoCABCAEQYCABE8NByABIARqIANBAWsiAzoAACABIAEoAoCABEEBaiIENgKAgAQgBEGAgARPDQcgASAEaiADQQh2IgU6AAAgASABKAKAgARBAWo2AoCABCABKAKEgAQiBEGAgARPDQIgASAEaiIEIAQtAABBAXY6AAAgASgChIAEIgRBgIAETw0DIAEgBGoiBCAELQAAQYABcjoAACABIAEoAoyABEEBayIENgKMgAQgBEUEQCABQQg2AoyABCABIAEoAoCABCIENgKEgAQgASAEQQFqNgKAgAQLIAAgA0GstMMAaiAFQay8wwBqIANBgARJGy0AAEEBdGpBwARqIgEgAS8BAEEBajsBACACQYACTw0FIAJBAXRByK3DAGovAQAiAUGgAkkNBiABQaACQezAwwAQnAcAC0Gcv8MAQTNB0L/DABCeCAALQeC/wwBBIUGEwMMAEJ4IAAsgBEGAgARBmK3DABCcBwALIARBgIAEQZitwwAQnAcAC0GUwMMAQTVBzMDDABCeCAALIAJBgAJB3MDDABCcBwALIAAgAUEBdGoiACAALwEAQQFqOwEADwsgBEGAgARBiK3DABCcBwAL1QMCBn4CfyMAQdAAayIIJAAgCEFAayIJQgA3AwAgCEIANwM4IAggACkDACIDNwMoIAggAEEIaikDACICNwMwIAggA0Lh5JXz1uzZvOwAhTcDECAIIANC9crNg9es27fzAIU3AwggCCACQvPK0cunjNmy9ACFNwMgIAggAkLt3pHzlszct+QAhTcDGCAIQSA2AkwgCEEIaiIAIAhBzABqQQQQ5gIgACABQSAQ5gIgCTUCACECIAgpAzggCCkDICEEIAgpAxAhBiAIKQMIIQcgCCkDGCEDIAhB0ABqJAAgAkI4hoQiBSAEhSICIAZ8IgQgAkIQiYUiBiADIAd8IgdCIIl8IQIgBCADQg2JIAeFIgR8IQMgAyAEQhGJhSIEIAIgBYV8IQUgBSAEQg2JhSIEIAZCFYkgAoUiAiADQiCJQv8BhXwiBnwhAyADIARCEYmFIgQgAkIQiSAGhSICIAVCIIl8IgV8IgYgBEINiYUiBCADQiCJIAJCFYkgBYUiA3wiAnwiBSAEQhGJhSIEIANCEIkgAoUiAyAGQiCJfCICfCAEQg2JhSIEIANCFYkgAoUiAiAFQiCJfCIFfCEDIAMgAkIQiSAFhUIViYUgBEIRiYUgA0IgiYULqQMBCX8gACgCCCIBBEAgACgCBCIAIAFB4ABsaiEFA0AgACgCSARAIABBzABqKAIAENQBCwJAIABBP2otAABBGEcNACAAQShqIgIoAgAiAygCACEBIAMgAUEBazYCACABQQFHDQAgAhCuCAsCQCAAKAIARQ0AIAAoAgRFDQAgAEEIaigCABDUAQsgAEHYAGohAyAAQdwAaigCACIBBEAgAygCACEGIAFB2ABsIQdBACECA0ACQCACIAZqIgFBCGotAAAiBEEKa0H/AXFBA0kNAAJAAkACQCAEDgkAAQMDAwMDAwIDCyABQQxqKAIARQ0CIAFBEGooAgAQ1AEMAgsgAUEjai0AAEEYRw0BIAFBDGoiCCgCACIJKAIAIQQgCSAEQQFrNgIAIARBAUcNASAIEK4IDAELIAFBDGooAgBFDQAgAUEQaigCABDUAQsgAUEwaigCAARAIAFBNGooAgAQ1AELIAFBPGooAgAEQCABQUBrKAIAENQBCyAHIAJB2ABqIgJHDQALCyAAQeAAaiEBIAAoAlQEQCADKAIAENQBCyAFIAEiAEcNAAsLC+QDAgt/An4jAEFAaiIDJAAgA0EoaiICQRBqIAFBEGooAgA2AgAgAkEIaiABQQhqKQIANwMAIAMgASkCADcDKCADQQhqIAIQkQICQAJAAkAgAygCCCIERQRAIAMpAgwhDSAAQQI7ARQgACANQiCIPgIEIAAgDadBgP4DcUEGIA1C/wGDUBs2AgAMAQsgAygCFCEGIAMoAgwiByADKQMgIg2nIgJJBEAgAEECOwEUIAAgBjYCCCAAQQY2AgAgACACIAdrIgBBACAAIAJNGzYCBAwBCyADKQMYIQ4gAygCECEIAn8gAkEQTQRAIANBCGoiASACakEAQhAgDUL/////D4MiDX1CACACQRBHG6cQ4goaIAEgBCACEOAKGiADKAIUIQkgAygCECEBIAMoAgwhBSANpyEKIAMoAggMAQsgAkEATiIBRQ0CIAIgARDwCSIFRQ0DIAUgBCACEOAKGkEBIQsgAiIBCyEMIAAgCTYCJCAAIAE2AiAgACAFNgIcIAAgDDYCGCAAIAo7ARYgACALOwEUIAAgAiAOp2o2AhAgACAGNgIMIAAgCDYCCCAAIAcgAms2AgQgACACIARqNgIACyADQUBrJAAPCxDHCAALIAIgAUHw9MQAKAIAIgBBygQgABsRAAAAC90DAQh/IwBBQGoiAiQAIAEoAgQhBSABKAIAAn8CQAJAIAEoAggiA0EYTwRAIANBoQFPDQJBICADIANBIE8bIQRBACEBAkADQCABIAVqLQAAQQpHDQEgBCABQQFqIgFHDQALIAQhAQsgAyABayIGQYABSw0CIAEgA0sNASABIAVqIQggAyEHA0BBGiABIAdGDQQaIAdBAWshByAILQAAIAhBAWohCEEgRg0ACwwCCyACQShqIgEgA2pBAEEXIANrEOIKGiABIAUgAxDgChogAiACKQIwNwMYIAIgAkE3aikAADcAHyACKAIsIQYgAigCKCEBIAMMAgsgASADQZSZwAAQjAoACwJAIANBAE4EQCACQRBqIANBARCGByACKAIUIQQgAigCECACQQhqIANBARCGByACKAIMIQEgAigCCCIHBEAgByABEPAJIQELIAENASAEQfD0xAAoAgAiAEHKBCAAGxEAAAALQaDWwABBKyACQShqQczWwABBqNfAABCHBwALIAFCgYCAgBA3AgAgAUEIaiAFIAMQ4AoaIAMhBkEYCyEEBEAgBRDUAQsgACAGNgIEIAAgATYCACAAIAIpAxg3AgggACAEOgAXIABBD2ogAikAHzcAACACQUBrJAALjAQBBH8jAEEwayICJAAgAEEANgIIIABCgICAgBA3AgAgAkEIaiIDQQhqIgUgAUEIaikCADcDACACIAEpAgA3AwggAkEYaiIEQQE2AgQgBEEIaiADKAIAIAMoAgRrQQF0IAMoAgxBgIDEAEdyIgE2AgAgBCABNgIAIAIoAhgiAQRAIABBACABEJwGCyACQRhqIgFBCGogBSkDADcDACACIAIpAwg3AxggARDyByIBQYCAxABHBEADQAJAAn8CQAJAIAFBgAFPBEAgAkEANgIsIAFBgBBJDQEgAUGAgARPDQIgAiABQT9xQYABcjoALiACIAFBDHZB4AFyOgAsIAIgAUEGdkE/cUGAAXI6AC1BAwwDCyAAKAIIIgMgACgCAEYEQCAAIAMQoQYgACgCCCEDCyADIAAoAgRqIAE6AAAgACAAKAIIQQFqNgIIDAMLIAIgAUE/cUGAAXI6AC0gAiABQQZ2QcABcjoALEECDAELIAIgAUE/cUGAAXI6AC8gAiABQRJ2QfABcjoALCACIAFBBnZBP3FBgAFyOgAuIAIgAUEMdkE/cUGAAXI6AC1BBAshASABIAAoAgAgACgCCCIDa0sEQCAAIAMgARCcBiAAKAIIIQMLIAAoAgQgA2ogAkEsaiABEOAKGiAAIAEgA2o2AggLIAJBGGoQ8gciAUGAgMQARw0ACwsgAkEwaiQAC7MDAQd/IwBBQGoiAyQAIAIoAgghByADQRhqIgRBIGogAUEgaikDADcDACAEQRhqIAFBGGopAwA3AwAgBEEQaiABQRBqKQMANwMAIARBCGogAUEIaikDADcDACADIAEpAwA3AxggA0EIaiAEEIoCIAMoAgggAygCDCEGIAMoAhAiBSACKAIAIAciBGtLBEAgAiAHIAUQnAYgAigCCCEECyACKAIEIgkgBGogBiAFEOAKGiACIAQgBWoiBDYCCARAIAYQ1AELIANBOGogAUHIAGopAwA3AwAgA0EwaiABQUBrKQMANwMAIANBKGogAUE4aikDADcDACADQSBqIAFBMGopAwA3AwAgAyABKQMoNwMYIANBCGogA0EYahCKAiADKAIIIAMoAgwhBiADKAIQIgUgAigCACAEIgFrSwRAIAIgBCAFEJwGIAIoAgQhCSACKAIIIQELIAEgCWogBiAFEOAKGiACIAEgBWoiATYCCARAIAYQ1AELIAAgASAHRwR/IAAgBzYCBCAAQRBqIAE2AgAgAEEMaiAENgIAIABBCGogBDYCAEEBBUEACzYCACADQUBrJAAL+AMBB38gACgCICICRQRAQQAPCyAAIAJBAWs2AiACfwJAAkACQCAAKAIAQQFrDgICAQALIABBCGooAgAhAQJAIAAoAgQiAkUNACACQQFrIAJBB3EiAwRAA0AgAkEBayECIAEoAugCIQEgA0EBayIDDQALC0EHSQ0AA0AgASgC6AIoAugCKALoAigC6AIoAugCKALoAigC6AIoAugCIQEgAkEIayICDQALCyAAQQA2AgwgACABNgIIIABCATcCAEEAIQNBAAwCC0HsicAAQStBiIvAABCeCAALIABBCGooAgAhASAAKAIEIQMgAEEMaigCAAshBgJAAkAgAS8B5gIgBksEQCABIQIMAQsDQCABKALgAiICRQ0CIANBAWohAyABQeQCai8BACIGIAIiAS8B5gJPDQALCyAGQQFqIQcCQCADRQRAIAIhAQwBCyACIAdBAnRqQegCaigCACEBQQAhByADQQFrIgVFDQAgA0ECayAFQQdxIgMEQANAIAVBAWshBSABKALoAiEBIANBAWsiAw0ACwtBB0kNAANAIAEoAugCKALoAigC6AIoAugCKALoAigC6AIoAugCKALoAiEBIAVBCGsiBQ0ACwsgACAHNgIMIAAgATYCCCAAQQA2AgQgAiAGQQV0ag8LQeDCwABBK0H8w8AAEJ4IAAv4AwEHfyAAKAIgIgJFBEBBAA8LIAAgAkEBazYCIAJ/AkACQAJAIAAoAgBBAWsOAgIBAAsgAEEIaigCACEBAkAgACgCBCICRQ0AIAJBAWsgAkEHcSIDBEADQCACQQFrIQIgASgC6AIhASADQQFrIgMNAAsLQQdJDQADQCABKALoAigC6AIoAugCKALoAigC6AIoAugCKALoAigC6AIhASACQQhrIgINAAsLIABBADYCDCAAIAE2AgggAEIBNwIAQQAhA0EADAILQdD4wgBBK0Hs+cIAEJ4IAAsgAEEIaigCACEBIAAoAgQhAyAAQQxqKAIACyEGAkACQCABLwHmAiAGSwRAIAEhAgwBCwNAIAEoAuACIgJFDQIgA0EBaiEDIAFB5AJqLwEAIgYgAiIBLwHmAk8NAAsLIAZBAWohBwJAIANFBEAgAiEBDAELIAIgB0ECdGpB6AJq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FGpBATYCACACQRxqQQA2AgAgAkHc4sIANgIQIAJB6NHCADYCGCACQQA2AgggASACQQhqEOQHDAULIAJBFGpBATYCACACQRxqQQA2AgAgAkHM4sIANgIQIAJB6NHCADYCGCACQQA2AgggASACQQhqEOQHDAQLIAJBFGpBATYCACACQRxqQQA2AgAgAkG44sIANgIQIAJB6NHCADYCGCACQQA2AgggASACQQhqEOQHDAMLIAJBFGpBATYCACACQRxqQQA2AgAgAkGo4sIANgIQIAJB6NHCADYCGCACQQA2AgggASACQQhqEOQHDAILIAJBFGpBATYCACACQRxqQQA2AgAgAkGY4sIANgIQIAJB6NHCADYCGCACQQA2AgggASACQQhqEOQHDAELIAJBFGpBATYCACACQRxqQQA2AgAgAkGA4sIANgIQIAJB6NHCADYCGCACQQA2AgggASACQQhqEOQHCyACQSBqJAALuQcCBH8EfiMAQaABayIEJAACfkGQ9cQAKQMAQgBSBEBBoPXEACkDACEFQZj1xAApAwAMAQsgBEEIaiIBQgI3AwggAUIBNwMAQZD1xABCATcDAEGg9cQAIAQpAxAiBTcDACAEKQMICyEGIABCADcDECAAIAU3AwggACAGNwMAIABBjAFqQQA2AgAgAEGEAWpCgICAgBA3AgAgAEH8AGpCBDcCACAAQfQAakIANwIAIABB7ABqQoCAgICAATcCACAAQeQAakIANwIAIABBHGpBuMLCADYCACAAQRhqQQA2AgBBmPXEACAGQgJ8NwMAIABBPGpBuMLCADYCACAAQThqQQA2AgAgAEEwakIANwMAIABBKGogBTcDACAAIAZCAXw3AyAjAEGAAmsiASQAIAFBEGoiA0EANgIAIAFBuMLCADYCFCABQgA3AwggAUH4AWpBADoAACABQewBakEANgIAIAFB3AFqQgA3AgAgAUHUAWpCgICAgIABNwIAIAFBnAFqQQA2AgAgAUIANwOIASABQQhqQgAgAUGIAWoQjAQgAUECNgJoIAFBGGoQjwUgBEEYaiICQegAaiADKQMANwIAIAIgASkDCDcCYAJAQQAQsAciAwRAAkAgAyADKQMAIgZCAXw3AwAgAykDCCEFQQAQsAciA0UNACADIAMpAwAiB0IBfDcDACADKQMIIQggAkEANgJYIAJCgICA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IAJBiLLAAEGQssAAEJMHIQUMAgsgAigCKCEFIAIoAiwiBkUNASACIAYgAigCMBDOBiAAAn8gAi0AAEUEQCAAIAIpAAE3AAEgAEEZaiACQRlqKQAANwAAIABBEWogAkERaikAADcAACAAQQlqIAJBCWopAAA3AABBAAwBCyACQQhqKAIAIQcgAigCBCACQShqIglBCGogAzYCACACIAE2AiwgAkEFOgAoIAlBvLLAAEGQssAAEJMHIQMEQCAHENQBCyAAIAM2AgRBAQs6AAAgBQRAIAYQ1AELIARFDQIgARDUAQwCCyAAQQE6AAAgACAENgIEDAELIABBAToAACAAIAU2AgQgBEUNACABENQBCyACQUBrJAAL9AMBAX8jAEEwayICJAACfwJAAkACQAJAAkACQAJAIAAoAgBBAWsOBgECAwQFBgALIAJBJGpBATYCACACQSxqQQE2AgAgAkGQ0cEANgIgIAJBADYCGCACQYACNgIMIAIgAEEEajYCFCACIAJBCGo2AiggAiACQRRqNgIIIAEgAkEYahDkBwwGCyACQSRqQQE2AgAgAkEsakEANgIAIAJB5NDBADYCICACQbDEwQA2AiggAkEANgIYIAEgAkEYahDkBwwFCyACQSRqQQE2AgAgAkEsakEANgIAIAJByNDBADYCICACQbDEwQA2AiggAkEANgIYIAEgAkEYahDkBwwECyACQSRqQQE2AgAgAkEsakEANgIAIAJBtNDBADYCICACQbDEwQA2AiggAkEANgIYIAEgAkEYahDkBwwDCyACQSRqQQE2AgAgAkEsakEANgIAIAJBhNDBADYCICACQbDEwQA2AiggAkEANgIYIAEgAkEYahDkBwwCCyACQSRqQQE2AgAgAkEsakEANgIAIAJBvM/BADYCICACQbDEwQA2AiggAkEANgIYIAEgAkEYahDkBwwBCyACQSRqQQE2AgAgAkEsakEANgIAIAJBnM/BADYCICACQbDEwQA2AiggAkEANgIYIAEgAkEYahDkBwsgAkEwaiQAC8ADAQZ/IwBBQGoiBCQAAn8CQAJAIAJBGE8EQCACQaEBTw0CQSAgAiACQSBPGyEFAkADQCABIANqLQAAQQpHDQEgBSADQQFqIgNHDQALIAUhAwsgAiADayIFQYABSw0CIAIgA0kNASABIANqIQggAiEGA0BBGiAD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ADYCACAEQfTzxAA2AgQgCkHQ+sMAKAIAEQYARQ0BIARBAjYCAAwBCwNAEL8DIAQtAAhFDQALDAILIwBBIGsiBiQAIAQoAgQiAigCACEBIAIgBCgCADYCACAGIAFBA3EiAjYCBAJAIAJBAUYEQAJAIAFBAWsiAQRAA0AgASgCBCABKAIAIQggAUEANgIAIAhFDQIgAUEBOgAIIAYgCDYCCCAIQRBqEIcFIAYoAggiCCgCACEBIAggAUEBazYCACABQQFGBEAgBkEIahD6BwsiAQ0ACwsgBkEgaiQADAILQfiFxABBK0GkhsQAEJ4IAAsgBkEANgIQIwBBIGsiACQAIABBiIXEADYCBCAAIAZBBGo2AgAgAEEIaiIBQRBqIAZBCGoiAkEQaikCADcDACABQQhqIAJBCGopAgA3AwAgACACKQIANwMIQQAgAEH4hMQAIABBBGpB+ITEACABQeiFxAAQ/AMACwsgBEEQaiQADAELAkAgBCgCACIBRQ0AIAEgASgCACIBQQFrNgIAIAFBAUcNACAEEPoHC0H088QAKAIAIQEMAQsLIAdBIGokAAtB4PPEACgCACIBQQBIBEAgA0EANgIEAkAgAygCBEUNACADQRBqIgVBCGogA0EIaigCADYCACADIAMpAwA3AxAgA0EoaiICQQxqQQI2AgAgAkEUakEBNgIAIANByABqIgBBDGpBATYCACAAQRRqQQA2AgAgA0GY/MMANgIwIANBADYCKCADQb8BNgJEIANBxPzDADYCUCADQcz8wwA2AlggA0EANgJIIAMgA0FAazYCOCADIAA2AkAgA0EgaiEBIwBBMGsiACQAIABBBDoACCAAIAU2AhAgAEEYaiIFQRBqIAJBEGopAgA3AwAgBUEIaiACQQhqKQIANwMAIAAgAikCADcDGAJAIABBCGpB7IDEACAFEP0CBEAgAC0ACEEERgRAIAFBlIHEADYCBCABQQI2AgAMAgsgASAAKQMINwIADAELIAFBBDoAACAALQAIQQNHDQAgACgCDCICKAIAIAIoAgQoAgARAwAgAigCBCIFQQRqKAIABEAgBUEIaigCABogAigCABDUAQsgACgCDBDUAQsgAEEwaiQAIAEQlwggAygCEEUNACADKAIUENQBCwALQQEhBEHg88QAIAFBAWo2AgBB5PPEAC0AAARAIANB4PPEADYCTCADQejzxAA2AkhBzPzDAEErIANByABqQfj8wwBB6P3DABCHBwALIAlB6PPEADYCBCAJQQhqQeDzxAA2AgALIAkgBDYCACADQeAAaiQAIAUgACgCBDYCGCAFQQM6ABQgBUEYaiEIIAVBFGohByMAQRBrIgYkAAJAAkACQAJ/AkACQAJAIAkoAgBBAWsOAgECAAtBACEEIwBBIGsiAyQAAkBB3PTEACgCAA0AQdz0xAApAgAhDkHc9MQAQgE3AgBB7PTEACgCACEBQez0xABBAToAACADQRhqIAE2AgAgA0EQaiIBQeT0xAApAgA3AwBB5PTEAEEANgIAIAMgDjcDCCAOp0UNACABKAIAIgRFDQAgBCAEKAIAIgJBAWs2AgAgAkEBRw0AIAEQsQcLQez0xAAtAAAhAUHs9MQAQQA6AAACQAJAAkACQAJAIAFBAXEiAQRAQQAgAWtB4PTEAHEiCSgCAA0CIAlBfzYCAEEAIQECQEHk9MQAKAIAIgIEQEHo9MQAKAIAIQQMAQtB0PTEACgCAEECRgRAQdT0xAAoAgAiAUUNBUHY9MQAKAIAIQQgASABKAIAIgJBAWo2AgAgAkEASA0GCwJAIAFFBEBBCEEEEPAJIgJFDRMgAkKBgICAEDcCAEHAgcQAIQQMAQsgASECC0Ho9MQAIAQ2AgBB5PTEACACNgIACyACIAQoAghBB2pBeHFqIAgoAgAgBCgCEBEBACEBQez0xABBAToAACAJIAkoAgBBAWo2AgAgByABQf8BcSICQQEgBy0AACIBIAEgAkcbIAFBA0YbOgAADAELQQhBBBDwCSIBRQ0PIAFCgICAgBA3AgAgByAHLQAAIgJBA0cgAkEAR3E6AAAgA0HAgcQANgIMIAMgATYCCCADQQhqELEHCyADQSBqJAAMAwtBoIHEAEEQIANBCGpBsIHEAEHwgsQAEIcHAAtBgIPEAEHRAEHUg8QAEJAKAAsACwwDCyAJKAIEDAELIAkoAgRBCGoLIgFBCGooAgAiAkUNACABQQRqKAIAIgQgAkEDdGohCQNAAkAgBCgCACIDQX9GBEBBACEBDAELIAMoAgAhAQJ/A0BBACABRQ0BGiABQQBIDQUgAyABQQFqIAMoAgAiAiABIAJGGzYCACABIAJHIAIhAQ0ACyAEKAIACyEBIARBBGooAgAhAgsgBEEIaiEEAkAgAUUNACAGIAI2AgwgAigCCCEDIAYgATYCCCAHIAEgA0EHakF4cWogCCgCACACKAIQEQEAQf8BcSICQQEgBy0AACIBIAEgAkcbIAFBA0YbOgAAIAYoAggiAygCACEBIAMgAUEBazYCACABQQFHDQAgBkEIahCxBwsgBCAJRw0ACwsgBkEQaiQADAELAAsgAEECQQEgBS0AFCIBQQAgAUEDRxsiAUECRhtBACABGzoACAJAAkACQCAFKAIIDgICAQALIAUoAgwhAQJAIAVBEGotAAANAEGE9cQAKAIAQf////8HcUUNAEH0+MQAKAIARQ0AIAFBAToABAsgASgCACECIAFBADYCACAFIAI2AhQgAkF/Rg0BIAVBADYCICMAQSBrIgAkACAAQeSDxAA2AgQgACAFQRRqNgIAIABBCGoiAUEQaiAFQRhqIgJBEGopAgA3AwAgAUEIaiACQQhqKQIANwMAIAAgAikCADcDCEEAIABBhPrDACAAQQRqQYT6wwAgAUHQhMQAEPwDAAsgBUEQaigCACIBIAEoAgBBAWs2AgALQcj0xAAoAgAhAQNAIAAgATYCACAFIAE2AhQgBSAANgIIIAAgAUYNBCABQcj0xAAoAgAiAUYhAkHI9MQAIAAgASACGzYCACACRQ0ACyAAQQI6AAkMAQsgAUECRw0BC0ECQQEgAC0ACCIAQQJGG0EAIAAbIQILIAVBMGokACACDwsgBUEANgIsIAVB+P3DADYCKCAFQQE2AiQgBUHUgMQANgIgIAVBADYCGCMAQSBrIgAkACAAIAVBFGo2AgQgACAFQQhqNgIAIABBCGoiAUEQaiAFQRhqIgJBEGopAgA3AwAgAUEIaiACQQhqKQIANwMAIAAgAikCADcDCEEBIABBlPrDACAAQQRqQaT6wwAgAUHcgMQAEPwDAAtBCEEEQfD0xAAoAgAiAEHKBCAAGxEAAAALlwMBA38CQCAAKAIQRQ0AIABBFGooAgBFDQAgAEEYaigCABDUAQsCQCAAQfgAaigCAEUNACAAQfwAaigCAEUNACAAQYABaigCABDUAQsCQCAAQbABaigCAEUNACAAQbQBaigCAEUNACAAQbgBaigCABDUAQsCQCAAQegBaigCAEUNACAAQewBaigCAEUNACAAQfABaigCABDUAQsCQAJAAkAgAEHIAGooAgAOAwEAAgALIABBzABqKAIARQ0AIABB0ABqKAIAENQBCyAALQBHQRhHDQAgAEEwaiICKAIAIgMoAgAhASADIAFBAWs2AgAgAUEBRw0AIAIQrggLAkAgAEGgAmooAgBFDQAgAEGkAmooAgBFDQAgAEGoAmooAgAQ1AELAkAgAEHQAmooAgBFDQAgAEHUAmooAgBFDQAgAEHYAmooAgAQ1AELAkAgAEGIA2ooAgBFDQAgAEGMA2ooAgBFDQAgAEGQA2ooAgAQ1AELAkAgAEGoA2ooAgBFDQAgAEGsA2ooAgBFDQAgAEGwA2ooAgAQ1AELC+6DAQMufwV+AXwjAEEwayIWJAACQAJAIAEoAggiAyABKAIEIgtJBEAgASgCACECA0AgAiADai0AACIGQQlrIhNBF0sNAkEBIBN0QZOAgARxRQ0CIAEgA0EBaiIDNgIIIAMgC0cNAAsLIBZBBTYCGCABIBZBGGoQ/AchASAAQQA2AgQMAQsCQCAGQdsARgRAIAEgAS0AGEEBayILOgAYIAtB/wFxRQRAIBZBFTYCGCABIBZBGGoQ/AchASAAQQA2AgQMAwsgASADQQFqNgIIIBZBCGohISMAQZABayIRJAAgEUEBOgAEIBEgATYCACARQQA2AhAgEUKAgICAgAE3AwggEUHcAGohHQJAA0ACQCARQRhqIRkjAEGAAWsiFyQAAkACQAJAAkACQAJAAkAgESgCACIQKAIIIgMgECgCBCILSQRAIBAoAgAhBgNAAkAgAyAGai0AACICQQlrDiQAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAYDCyAQIANBAWoiAzYCCCADIAtHDQALCyAXQQI2AgggECAXQQhqEPwHIQMgGUEDNgJAIBkgAzYCAAwGCyACQd0ARg0BCyARLQAEDQIgF0EHNgIIIBAgF0EIahD8ByEDIBlBAzYCQCAZIAM2AgAMBAsgGUECNgJADAMLIBEtAAQNACAQIANBAWoiAzYCCCADIAtJBEADQCADIAZqLQAAIgJBCWsiE0EXSw0DQQEgE3RBk4CABHFFDQMgECADQQFqIgM2AgggAyALRw0ACwsgF0EFNgIIIBAgF0EIahD8ByEDIBlBAzYCQCAZIAM2AgAMAgsgEUEAOgAECyACQd0ARgRAIBdBEjYCCCAQIBdBCGoQ/AchAyAZQQM2AkAgGSADNgIADAELIBdBCGohFCMAQYACayISJAACQAJAIBAoAggiAyAQKAIEIgJJBEAgECgCACEGA0AgAyAGai0AACILQQlrIhNBF0sNAkEBIBN0QZOAgARxRQ0CIBAgA0EBaiIDNgIIIAIgA0cNAAsLIBJBBTYCgAEgECASQYABahD8ByEDIBRBAjYCQAwBCwJAAn8CQAJAAkAgC0H7AEcEQCALQdsARg0BIBAgEkEIakHE88AAEN4BIQMMBQsgECAQLQAYQQFrIgs6ABggC0H/AXEEQCAQIANBAWo2AgggEkEIaiEJQgAhMEEAIQ5EAAAAAAAAAAAhNUEAIRhBACEeQQAhIkEAIQtBACEjQQAhJUEAISZBACErQQAhLEEAIRMjAEGAA2siBSQAIAVBAToAFCAFIBA2AhAgBUECNgIoIAVBCzoAUCAFQQI6AHcgBUECOwGAASAFQShqQQRyIScgBUHAAmogBUEQahCzAyAFKALEAiEGAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBSgCwAIEQEEDIRoMAQsgBUHEAGohLSAFQcACakEEciEoIAVBOmohKSAFQTBqIR8gBUHKAmohKiAFQdQCaiEuQQchHEEDIRpBAiEkQQchIANAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBSgCyAIiCgRAIAUoAswCIgJBA2sOBgEGBwIMCwwLIBxBB0YNDAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAaQf//A3FBA0YiA0UEQCAFQaABaiAFQSBqKAIANgIAIAUgBSkDGDcDmAEgBSgCKCIGQQJGIggNASAFQagBaiICQRBqIB9BCGopAwA3AwAgAkEYaiAfQRBqKQMANwMAIAVByAFqIB9BGGopAwA3AwAgBSAFKAIsNgKsASAFIAY2AqgBIAUgHykDADcDsAEgGEUNAiAFICI2AtgBIAUgGDYC1AEgBSALNgLQAUEBIQdBCiECIBxBBGsOAwUDBCwLQc/GwABBAxDGByECIAlBAjYCQCAJIAI2AgBBASETQQEhCAwuC0HSxsAAQQMQxgchAiAJQQI2AkAgCSACNgIAQQEhEwwsC0HbxsAAQQQQxgchAiAJQQI2AkAgCSACNgIADCoLIAVB4ABqIQRBACEHQQwhAiAFKQNYITAgBSgCWCEMIAUoAlQhCiAFLQBQQQFrDgsEKCgFBigHCAkCAgMLAkACQAJAICBBB0cEQCAFLQBQIgJBC0YNASAFKAJUIQQgBUEJOgDAAiACQQpHDQIgBUGAAmoiAkEYaiAFQcACaiIGQRhqKQMANwMAIAJBEGogBkEQaikDADcDACACQQhqIAZBCGopAwA3AwAgBSAFKQPAAjcDgAIMAwsgBS0AUCIEQQtGDRsgBSkDWCEwIAUoAlQhDiAFLwFSIQYgBS0AUSEcQQkhAiAFQQk6AMACIARBCkYEQCAFKQPIAiEwIAUoAsQCIQ4gBS8BwgIhBiAFLQDBAiEcDCoLIAVB+AFqIAVB4ABqIgNBCGopAwA3AwAgBSADKQMANwPwASAFQcACahCXByAEIQIMKQtBxMbAAEEFEMYHIQIgCUECNgJAIAkgAjYCAAwmCyAFQZACaiAFQdgAaiIGQQhqKQMANwMAIAVBmAJqIAZBEGopAwA3AwAgBSAENgKEAiAFIAI6AIACIAUgBUHQAGpBAXIiAi8AADsAgQIgBSAGKQMANwOIAiAFIAJBAmotAAA6AIMCIAVBwAJqEJcHCyAFQcACaiEGIAVBgAJqIQQjAEGgAWsiAiQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAgQQFrDgYBDwIDBBYACyAELQAAQQJrDgITFBILIAQtAABBAmsOAg8QDgsCQAJ+AkACQAJAIAQtAABBAmsOBQICAAECBAtCfwJ+IAQrAwgiNUQAAAAAAAAAAGYhByAHIDVEAAAAAAAA8ENjcQRAIDWxDAELQgALQgAgBxsgNUT////////vQ2QbDAILIARBEGopAwAMAQsgBCkDCAshMEEAIQcLIAJBQGsgBBD+AkEGQQEQ8AkiDkUNFyAOQQRqQfaOwgAvAAA7AAAgDkHyjsIAKAAANgAAIAJBADYCaCACQoCAgIAQNwNgIAJB8ABqIgpBAzoAICAKQoCAgICABDcCGCAKQQA2AhAgCkEANgIIIApB4PjBADYCBCAKIAJB4ABqNgIAIAQgChCUAg0YIAJBNGpBBjYCACACQTBqIgogDjYCACACQQhqIAJBQGsiBEEIaikDADcDACACQRBqIg4gBEEQaikDADcDACACQRhqIgwgBEEYaikDADcDACACQShqIgQgAkHoAGooAgA2AgAgAiACKQNANwMAIAJBAzoAOCACIAIpA2A3AyAgAkEGNgIsIAcNCyACLQAADgkHCAoKCgoKCgkKCwJAAn4CQAJAAkAgBC0AAEECaw4FAgIAAQIECyAEKwMIIjVEAAAAAAAA4MNmIQdC////////////AAJ+IDWZRAAAAAAAAOBDYwRAIDWwDAELQoCAgICAgICAgH8LQoCAgICAgICAgH8gBxsgNUT////////fQ2QbQgAgNSA1YRsMAgsgBEEQaikDAAwBCyAEKQMICyEwQQAhBwsgAkFAayAEEP4CQQZBARDwCSIORQ0WIA5BBGpB8I7CAC8AADsAACAOQeyOwgAoAAA2AAAgAkEANgJoIAJCgICAgBA3A2AgAkHwAGoiCkEDOgAgIApCgICAgIAENwIYIApBADYCECAKQQA2AgggCkHg+MEANgIEIAogAkHgAGo2AgAgBCAKEJQCDRcgAkE0akEGNgIAIAJBMGoiCiAONgIAIAJBCGogAkFAayIEQQhqKQMANwMAIAJBEGoiDiAEQRBqKQMANwMAIAJBGGoiDCAEQRhqKQMANwMAIAJBKGoiBCACQegAaigCADYCACACIAIpA0A3AwAgAkEEOgA4IAIgAikDYDcDICACQQY2AiwgBw0FIAItAAAOCQECBAQEBAQEAwQLAkACfAJAAkACQAJAAkAgBC0AAEECaw4FAAECAwQGCyAEKQMIuQwECyAEKQMIugwDCyAEKwMIDAILIARBEGopAwC5DAELIAQpAwi5CyE1QQAhBwsgAkFAayAEEP4CQQZBARDwCSIORQ0VIA5BBGpB6o7CAC8AADsAACAOQeaOwgAoAAA2AAAgAkEANgJoIAJCgICAgBA3A2AgAkHwAGoiCkEDOgAgIApCgICAgIAENwIYIApBADYCECAKQQA2AgggCkHg+MEANgIEIAogAkHgAGo2AgAgBCAKEJQCDRYgAkE0akEGNgIAIAJBMGoiCiAONgIAIAJBCGogAkFAayIEQQhqKQMANwMAIAJBEGoiDiAEQRBqKQMANwMAIAJBGGoiDCAEQRhqKQMANwMAIAJBKGoiBCACQegAaigCADYCACACIAIpA0A3AwAgAkEFOgA4IAIgAikDYDcDICACQQY2AiwgB0UEQAJAAkACQAJAIAItAAAOCQABAwMDAwMDAgMLIAIoAgRFDQIgAkEIaigCABDUAQwCCyACQRtqLQAAQRhHDQEgAigCBCIHKAIAIQQgByAEQQFrNgIAIARBAUcNASACQQRyEK4IDAELIAIoAgRFDQAgAkEIaigCABDUAQsgAigCIARAIAJBJGooAgAQ1AELIAIoAiwEQCACKAIwENQBCyAGQQc6ADggBiA1OQMIIAZBBDoAAAwVCyAGIAIpAwg3AwggBiACKAA5NgA5IAZBEGogDikDADcDACAGQRhqIAwpAwA3AwAgBkEgaiACQSBqKQMANwMAIAZBKGogBCkDADcDACAGQTBqIAopAwA3AwAgBkE8aiACQTxqKAAANgAAIAIrAwAhNSAGQQU6ADggBiA1OQMADBQLIAIoAgRFDQIgAkEIaigCABDUAQwCCyACQRtqLQAAQRhHDQEgAigCBCIHKAIAIQQgByAEQQFrNgIAIARBAUcNASACQQRyEK4IDAELIAIoAgRFDQAgAkEIaigCABDUAQsgAigCIARAIAJBJGooAgAQ1AELIAIoAiwEQCACKAIwENQBCyAGQQc6ADggBiAwNwMIIAZBAjoAAAwQCyAGIAIpAwg3AwggBiACKAA5NgA5IAZBEGogDikDADcDACAGQRhqIAwpAwA3AwAgBkEgaiACQSBqKQMANwMAIAZBKGogBCkDADcDACAGQTBqIAopAwA3AwAgBkE8aiACQTxqKAAANgAAIAIpAwAhMCAGQQQ6ADggBiAwNwMADA8LIAIoAgRFDQIgAkEIaigCABDUAQwCCyACQRtqLQAAQRhHDQEgAigCBCIHKAIAIQQgByAEQQFrNgIAIARBAUcNASACQQRyEK4IDAELIAIoAgRFDQAgAkEIaigCABDUAQsgAigCIARAIAJBJGooAgAQ1AELIAIoAiwEQCACKAIwENQBCyAGQQc6ADggBiAwNwMIIAZBAzoAAAwLCyAGIAIpAwg3AwggBiACKAA5NgA5IAZBEGogDikDADcDACAGQRhqIAwpAwA3AwAgBkEgaiACQSBqKQMANwMAIAZBKGogBCkDADcDACAGQTBqIAopAwA3AwAgBkE8aiACQTxqKAAANgAAIAIpAwAhMCAGQQM6ADggBiAwNwMADAoLIAQtAABFDQggAkFAayAEEP4CQRFBARDwCSIKRQ0HIApBEGpBiI/CAC0AADoAACAKQQhqQYCPwgApAAA3AAAgCkH4jsIAKQAANwAAIAJBADYCaCACQoCAgIAQNwNgIAJB8ABqIgdBAzoAICAHQoCAgICABDcCGCAHQQA2AhAgB0EANgIIIAdB4PjBADYCBCAHIAJB4ABqNgIAIAQgBxCUAg0LIAJBIGogAikDYCIwNwMAIAJBCGogAkFAayIEQQhqKQMAIjE3AwAgAkEQaiAEQRBqKQMAIjI3AwAgAkEYaiAEQRhqKQMAIjM3AwAgAkEoaiACQegAaigCACIENgIAIAIgAikDQCI0NwMAIAZBKGogBDYCACAGQSBqIDA3AwAgBkEYaiAzNwMAIAZBEGogMjcDACAGQQhqIDE3AwAgBiA0NwMAIAZBAjoAOCAGQRE2AjQgBiAKNgIwIAZBETYCLAwJCyACQUBrIAQQ/gJBCkEBEPAJIgpFDTkgCkEIakGRj8IALwAAOwAAIApBiY/CACkAADcAACACQQA2AmggAkKAgICAEDcDYCACQfAAaiIHQQM6ACAgB0KAgICAgAQ3AhggB0EANgIQIAdBADYCCCAHQeD4wQA2AgQgByACQeAAajYCACAEIAcQlAINCiACQSBqIAIpA2AiMDcDACACQQhqIAJBQGsiBEEIaikDACIxNwMAIAJBEGogBEEQaikDACIyNwMAIAJBGGogBEEYaikDACIzNwMAIAJBKGogAkHoAGooAgAiBDYCACACIAIpA0AiNDcDACAGQShqIAQ2AgAgBkEgaiAwNwMAIAZBGGogMzcDACAGQRBqIDI3AwAgBkEIaiAxNwMAIAYgNDcDACAGQQE6ADggBkEKNgI0IAYgCjYCMCAGQQo2AiwMCAsgBkEHOgA4IAZBBjoAACAGIAQpAwg3AwgMBwsgBCkDCCIwQgBZBEAgBkEHOgA4IAYgMDcDCCAGQQY6AAAMBwsgAiAEEP4CIAJB8ABqIgRBiY/CAEEKEIEIIAJBIGoiB0GTj8IAQSUQgQggAkE0aiAEQQhqKAIANgIAIAIgAikDcDcCLCAGQTBqIAJBMGopAwA3AwAgBkEoaiACQShqKQMANwMAIAZBIGogBykDADcDACAGQRhqIAJBGGopAwA3AwAgBkEQaiACQRBqKQMANwMAIAZBCGogAkEIaikDADcDACAGIAIpAwA3AwAgBkEBOgA4DAYLIAJBQGsgBBD+AkEKQQEQ8AkiCkUNNiAKQQhqQZGPwgAvAAA7AAAgCkGJj8IAKQAANwAAIAJBADYCaCACQoCAgIAQNwNgIAJB8ABqIgdBAzoAICAHQoCAgICABDcCGCAHQQA2AhAgB0EANgIIIAdB4PjBADYCBCAHIAJB4ABqNgIAIAQgBxCUAg0HIAJBIGogAikDYCIwNwMAIAJBCGogAkFAayIEQQhqKQMAIjE3AwAgAkEQaiAEQRBqKQMAIjI3AwAgAkEYaiAEQRhqKQMAIjM3AwAgAkEoaiACQegAaigCACIENgIAIAIgAikDQCI0NwMAIAZBKGogBDYCACAGQSBqIDA3AwAgBkEYaiAzNwMAIAZBEGogMjcDACAGQQhqIDE3AwAgBiA0NwMAIAZBADoAOCAGQQo2AjQgBiAKNgIwIAZBCjYCLAwFCyAGQQc6ADggBkEANgAYIAZBBToAACAGIAQpAwgiMDcAECAGIDA3AAgMBAsgBCkDCCIwQgBZBEAgBkEHOgA4IAZBADYAGCAGIDA3ABAgBiAwNwAIIAZBBToAAAwECyACIAQQ/gIgAkHwAGoiBEGJj8IAQQoQgQggAkEgaiIHQZOPwgBBJRCBCCACQTRqIARBCGooAgA2AgAgAiACKQNwNwIsIAZBMGogAkEwaikDADcDACAGQShqIAJBKGopAwA3AwAgBkEgaiAHKQMANwMAIAZBGGogAkEYaikDADcDACAGQRBqIAJBEGopAwA3AwAgBkEIaiACQQhqKQMANwMAIAYgAikDADcDACAGQQA6ADgMAwsgBiAEEP4CIAZBBzoAOAwCC0ERQQFB8PTEACgCACIAQcoEIAAbEQAAAAsgBEEIaigCACEOAkACQCAEQQxqKAIAIgQEQCAEQQBOIgpFDQEgBCAKEPAJIgdFDQILIAcgDiAEEOAKIQcgBkEHOgA4IAYgBDYADCAGIAc2AAggBiAENgAEIAZBADoAAAwCCxDHCAALIAQgCkHw9MQAKAIAIgBBygQgABsRAAAACyACQaABaiQADAILQQZBAUHw9MQAKAIAIgBBygQgABsRAAAAC0H4+MEAQTcgAkGYAWpBsPnBAEGM+sEAEIcHAAsgBUGgAmohBCMAQeAAayICJAACQCAGLQA4QQdGBEAgBCAGKQMANwMAIARBGGogBkEYaikDADcDACAEQRBqIAZBEGopAwA3AwAgBEEIaiAGQQhqKQMANwMADAELIAJBCGoiB0E4aiAGQThqKQMANwMAIAdBMGoiCiAGQTBqKQMANwMAIAdBKGogBkEoaikDADcDACAHQSBqIAZBIGopAwA3AwAgB0EYaiAGQRhqKQMANwMAIAdBEGogBkEQaikDADcDACAHQQhqIAZBCGopAwA3AwAgAiAGKQMANwMIIAIgAkEsaikCADcCTCACQRE6AEggAiAKKQMANwNYIAJByABqIAJB2ABqQbTGwAAQkwchBwJAAkACQAJAIAItAAgOCQABAwMDAwMDAgMLIAIoAgxFDQIgAkEQaigCABDUAQwCCyACQSNqLQAAQRhHDQEgAigCDCIKKAIAIQYgCiAGQQFrNgIAIAZBAUcNASACQQhqQQRyEK4IDAELIAIoAgxFDQAgAkEQaigCABDUAQsgAigCKARAIAIoAiwQ1AELIAIoAjQEQCACKAI4ENQBCyAEQQo6AAAgBCAHNgIECyACQeAAaiQAIAUtAKACIgJBCkcEQCAFQfgBaiAFQbgCaikDADcDACAFIAUpA7ACNwPwASAFKQOoAiEwIAUoAqQCIQ4gBS8BogIhBiAFLQChAiEcIAVBgAJqEJcHDCcLIAUoAqQCIQIgCUECNgJAIAkgAjYCACAFQYACahCXBwwkC0ELIQIMJgtBxMbAAEEFEMYHIQ4MBwsgBUEGOgDAAiAFIDA3AsQCIAVBwAJqQazGwABBtMbAABCTByEOIApFDQYgDBDUAQwGCyAFQdQCaiAEQQhqKAIANgIAIAUgMDcCxAIgBSAKNgLAAiAFIAQpAgA3AswCIAVBCGogBUHAAmoQoAYgBUEFOgCgAiAFIAUpAwg3AqQCIAVBoAJqQazGwABBtMbAABCTByEOAkAgBS0A1wJBGEcNACAFKALAAiIGKAIAIQIgBiACQQFrNgIAIAJBAUcNACAFQcACahCuCAsgBSgC0AEMBgsgML8iNUQAAAAAAADgw2YhA0L///////////8AAn4gNZlEAAAAAAAA4ENjBEAgNbAMAQtCgICAgICAgICAfwtCgICAgICAgICAfyADGyA1RP///////99DZBtCACA1IDVhGyEwDCILIAVBwAJqIgNBEGogBEEIaikDADcDACAFIDA3A8ACIAUgBCkDADcDyAIgAykDCCEwDCELIAUtAFEhAiAFQQA6AMACIAUgAkEBcToAwQIgBUHAAmpBrMbAAEG0xsAAEJMHIQ4MAgsgBUEGOgDAAiAFIDA3AsQCIAVBwAJqQazGwABBtMbAABCTByEOIApFDQEgDBDUAQwBCyAFQcgCakEENgIAIAVBoMbAADYCxAIgBUEROgDAAiAFQcACakGsxsAAQbTGwAAQkwchDgsgCwshBiAJQQI2AkAgCSAONgIADBoLIApBz8bAAEEDEOEKBEAgCkHSxsAAQQMQ4QpFDQIgCkH3xsAAQQMQ4QoNCyAFQRBqIQIjAEEgayIDJAACQCAFQfgAaiIELwEIQQJGBEAgAigCACIIEIEHIgINASADIAgQ2AUgAygCACECIAMvAQgiCEECRg0BIAQgAykBCjcBCiAEQRJqIANBEmopAQA3AQAgBEEYaiADQRhqKQEANwEAIAMoAgQhByAEIAg7AQggBCAHNgIEIAQgAjYCAEEAIQIMAQtB98bAAEEDEMcHIQILIANBIGokACACRQ0VIAlBAjYCQCAJIAI2AgAMFAsCQCAaQf//A3FBA0YEQCAFKAIQIgQQgQciAw0BIAVBwAJqIQIjAEEwayIDJAAgAyAEEO4EIAMoAgAhCAJAAkACQAJAIAMoAgQiBARAIAMoAggiB0EFRgRAIARBzNnAAEEFEOEKRQ0CCyADIAQgBxD7ASADLwEIQQJGDQIgAiADKQMANwMAIAJBGGogA0EYaikDADcDACACQRBqIANBEGopAwA3AwAgAkEIaiADQQhqKQMANwMADAMLIAJBAzsBCCACIAg2AgAMAwsgAkECOwEIDAELIANBKGogBzYCACADIAQ2AiQgA0EFOgAgIANBIGpB5NnAAEG82cAAEJMHIQcgAkEDOwEIIAIgBzYCACADKAIMRQ0AIANBEGooAgAQ1AELIAhFDQAgBBDUAQsgA0EwaiQAIAUoAsACIQMgBS8ByAIiAkEDRwRAIAVBIGogLkEIaigCADYCACAFIC4pAgA3AxggBSgC0AIhJSAFKALMAiEjIAUvAcoCISsgBSgCxAIhLCACIRogAyETDBcLIAMNAUEDIRoMFgtBz8bAAEEDEMcHIQMLIAlBAjYCQCAJIAM2AgAMEwsgCkHJxsAAQQYQ4QpFDREgCkHVxsAAQQYQ4QpFDQEgCkHfxsAAQQYQ4QpFDQIgCkHxxsAAQQYQ4QoNCSAFQRBqIQIjAEEQayIDJAACQAJAIAVB9wBqIgQtAABBAkYEQCACKAIAIggQgQciAg0CIANBCGogCBCQAyADLQAIRQ0BIAMoAgwhAgwCC0HxxsAAQQYQxwchAgwBCyAEIAMtAAk6AABBACECCyADQRBqJAAgAkUNEyAJQQI2AkAgCSACNgIADBILIAUoAihBAkcNCwJAIAUoAhAiAhCBByIDDQAgBUHAAmohBCMAQTBrIgMkAAJAAkAgAigCCCIIIAIoAgQiB0kEQCACKAIAIQwDQCAIIAxqLQAAIg1BCWsiD0EXSw0CQQEgD3RBk4CABHFFDQIgAiAIQQFqIgg2AgggByAIRw0ACwsgA0EFNgIAIAIgAxD8ByECIARBGzoAFyAEIAI2AgAMAQsCQCANQSJGBEAgAkEUakEANgIAIAIgCEEBajYCCCADQRhqIAIgAkEMahDKAQJAIAMoAhhBAkcEQCADIAMoAhwgAygCIBDpAyADLQAXQRtHDQEgAygCACEIDAMLIARBGzoAFyAEIAMoAhw2AgAMAwsgBCADKQMANwIAIARBEGogA0EQaikDADcCACAEQQhqIANBCGopAwA3AgAMAgsgAyACIANBKGpBhPPAABDeASIINgIACyAIIAIQigghAiAEQRs6ABcgBCACNgIACyADQTBqJAAgBSgCwAIhAyAFLQDXAiIEQRtGDQAgBUGoAWoiAkEPaiIIIChBD2ooAAA2AAAgAkEIaiIHIChBCGopAgA3AwAgBSAoKQIANwOoAQJAAkACQCAFKAIoDgMAAQIBCyAFLQBDQRhHDQEgBSgCLCIMKAIAIQIgDCACQQFrNgIAIAJBAUcNASAnEK4IDAELIAUvATgiAkEDcUEDR0EAIAJBAWsbDQAgBSgCPEUNACAFKAJAENQBCyAfIAUpA6gBNwIAIC0gBSkCoAI3AgAgH0EIaiAHKQMANwIAIB9BD2ogCCgAADYAACAtQQhqIAVBqAJqKAIANgIAIAUgAzYCLCAFQQA2AiggBSAEOgBDDBMLIAlBAjYCQCAJIAM2AgAMEQsgBSgCKEECRw0LIAUoAhAiAhCBByIDBEAgBSADNgLAAgwPCyAFQcACaiEHIwBBIGsiAyQAIAMgAhDuBCADKAIAIQ0CQCADKAIEIgwEQCADKAIIIQQjAEEgayICJAACQAJAAkAgBEEFRgRAIAxBsOHCAEEFEOEKRQ0BCyACIAwgBBD7ASACLwEIIghBAkYNASACKQMAITEgAikDGCEyIAIvAQohBCACKQIMITMgAyACKAIUNgEUIAMgMzcBDCADIAQ7AQogAyAyNwMYIAMgCDsBCCADIDE3AwAMAgsgA0ECOwEIDAELIAJBEGooAgAhFSACKAIMIRsCQAJAAkAgBEUEQEEBIQgMAQsgBEEATiIPRQ0BIAQgDxDwCSIIRQ0CCyAIIAwgBBDgCiEIIBsEQCAVENQBCyADIAQ2AgwgA0EDOwEIIANBFGogBDYCACADQRBqIAg2AgAMAgsQxwgACyAEIA9B8PTEACgCACIAQcoEIAAbEQAAAAsgAkEgaiQAAkAgAy8BCEEDRwRAIAcgAykDADcDACAHQRhqIANBGGopAwA3AwAgB0EQaiADQRBqKQMANwMAIAdBCGogA0EIaikDADcDAAwBCyADQRBqKAIAIQggAygCDCMAQUBqIgIkACACQQA2AgggAkKAgICAEDcDACACQRBqIgRBAzoAICAEQoCAgICABDcCGCAEQQA2AhAgBEEANgIIIARB1PPAADYCBCAEIAI2AgBB4djAAEESIAQQ3AoEQEHs88AAQTcgAkE4akGk9MAAQYD1wAAQhwcACyACEJoBIQQgAkFAayQABEAgCBDUAQsgB0EDOwEIIAcgBDYCAAsgDUUNASAMENQBDAELIAdBAzsBCCAHIA02AgALIANBIGokACAFKALAAiEDIAUvAcgCIgRBA0YNDiAFQagBaiICQQhqIgggKkEIaikBADcDACACQQ5qIgcgKkEOaikBADcBACAFICopAQA3A6gBIAUoAsQCIQwCQAJAAkAgBSgCKA4DAAECAQsgBS0AQ0EYRw0BIAUoAiwiDSgCACECIA0gAkEBazYCACACQQFHDQEgJxCuCAwBCyAFLwE4IgJBA3FBA0dBACACQQFrGw0AIAUoAjxFDQAgBSgCQBDUAQsgKSAFKQOoATcBACApQQhqIAgpAwA3AQAgKUEOaiAHKQEANwEAIAUgBDsBOCAFIAw2AjQgBSADNgIwIAVBATYCKAwRCwJAICRBAkYEQCAFKAIQIgMQgQciBw0BIAVBwAJqIAMQkAMgBS0AwAJFBEAgBS0AwQIhJAwTC0ECISQgBSgCxAIiB0UNEgwBC0HfxsAAQQYQxwchBwsgCUECNgJAIAkgBzYCAAwPCyAKKAAAQfDklaMGRg0LIAooAABB7sK1qwZHDQUgHg0CIAUoAhAiAhCBByIDDQMgBUHAAmogAhDuBCAFKALAAiEDIAUoAsQCIgJFDQEgAiEeIAMhJgwPCyAKQcTGwABBBRDhCg0EIAVBEGohAyMAQeAAayIIJAACQAJAIAVB0ABqIgwtAABBC0YEQCADKAIAIgMQgQciAg0CIAhBQGshB0IAITEjAEHQAGsiBCQAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkAgAygCCCICIAMoAgQiDUkEQCADKAIAIRUDQAJAIAIgFWoiDy0AACIbQQlrIi9BF0sNAEEBIC90QZOAgARxRQ0AIAMgAkEBaiICNgIIIAIgDUcNAQwDCwsgG0HuAEYNAwsgAiANTw0AIAMoAgAhGwNAIAIgG2otAAAiFUEJayIPQRdLDQJBASAPdEGTgIAEcUUNAiADIAJBAWoiAjYCCCACIA1HDQALCyAEQQU2AiggAyAEQShqEPwHIQIMCAsCQAJAAkACQAJAAkACQAJAAkACQAJAIBVB2wBrDiEFAwMDAwMDAwMDAwIDAwMDAwMDCAMDAwMDAQMDAwMDAwQACyAVQSJrDgwFAgICAgICAgICAgYCC0EBIQ8gAyACQQFqNgIIIANB1LHAAEEDEOMGIgINEEEHIQIMEgsgAyACQQFqNgIIIANB0LHAAEEEEOMGIgIND0EHIQJBACEPDBELIBVBMGtB/wFxQQpPBEAgBEEKNgIoIAMgBEEoahD8ByADEIoIIQIMDwsgBEEoaiADQQEQxQIgBCkDKCIxQgNRDQ0MDwsgAyADLQAYIg1BAWsiDzoAGCAPQf8BcUUNBSADIAJBAWo2AgggBEELOgAoIARBKGogBEEYakHIsMAAEKkGIQIgAyANOgAYIAQgAxDnBiINNgJIIAQgAjYCLCAEQQo6ACggDUUNBCAEQcgAahD+BiACIAMQigghAgwNCyADIAMtABgiDUEBayIPOgAYIA9B/wFxRQ0KIAMgAkEBajYCCCAEQQo6ACggBEEoaiAEQRhqQciwwAAQqQYhAiADIA06ABggBCADELwFIg02AkggBCACNgIsIARBCjoAKCANRQ0DIARByABqEP4GIAIgAxCKCCECDAwLIANBFGpBADYCACADIAJBAWo2AgggBEEYaiADIANBDGoQygEgBCgCGEECRg0FIAQoAiAhDyAEKAIcIQMMCAsgAyACQQFqNgIIIARBKGogA0EAEMUCIAQpAygiMUIDUQ0JDAsLIAMgAkEBajYCCCADQdexwABBAxDjBiICDQkgBEEHOgAoIARBKGogBEEYakHIsMAAEKkGIQILIAIgAxCKCCECDAgLIARBFTYCKCADIARBKGoQ/AchAgwHCyADIAJBAWoiFTYCCCANIBVNDQEgAyACQQJqIhs2AggCQAJAIA9BAWotAABB9QBHDQAgFSANIA0gFUkbIg0gG0YNAyADIAJBA2oiFTYCCCAPQQJqLQAAQewARw0AIA0gFUYNAyADIAJBBGo2AgggD0EDai0AAEHsAEYNAQsgBEEJNgIoIAMgBEEoahD9BwwDCyAHQQo6AAAMCQsgBCgCHCECDAULIARBBTYCKCADIARBKGoQ/QcLIQMgB0ELOgAAIAcgAzYCBAwGCyAEQShqIAMgDxDpAyAEQRBqIARBPGooAgA2AgAgBCAEKQI0NwMIIAQpAiwhMSAEKAIoIQNBASECDAQLIARBFTYCKCADIARBKGoQ/AchAgwBCyAEKAIwIQILIAdBCzoAACAHIAI2AgQMAgtBBCAxp2shAiAEKQMwITELIAcgMTcDCCAHIA86AAEgByAEKQMINwMQIAdBGGogBEEQaikDADcDACAHIAM2AgQgByACOgAACyAEQdAAaiQAIAgtAEAiA0ELRw0BIAgoAkQhAgwCC0HExsAAQQUQxwchAgwBCyAIQT5qIgIgCC0AQzoAACAIQSBqIgRBCGoiByAIQUBrIg1BEGopAwA3AwAgBEEQaiIEIA1BGGopAwA3AwAgCCAILwBBOwE8IAggCCkDSDcDICAIKAJEIQ0gCEEIaiAMQQhqIg8pAwA3AwAgCEEQaiAMQRBqIhUpAwA3AwAgCEEYaiAMQRhqIhspAwA3AwAgDCkDACExIAwgAzoAACAMIA02AgQgCCAxNwMAIAwgCC8BPDsAASAMQQNqIAItAAA6AAAgDyAIKQMgNwMAIBUgBykDADcDACAbIAQpAwA3AwACQCAILQAAIgNBDnFBCkYNAAJAAkACQCADDgkAAQMDAwMDAwIDCyAIKAIERQ0CIAhBCGooAgAQ1AEMAgsgCEEbai0AAEEYRw0BIAgoAgQiAigCACEDIAIgA0EBazYCACADQQFHDQEgCEEEchCuCAwBCyAIKAIERQ0AIAhBCGooAgAQ1AELQQAhAgsgCEHgAGokACACRQ0OIAlBAjYCQCAJIAI2AgAMDQsgAw0BQQAhHgwNC0HtxsAAQQQQxwchAwsgCUECNgJAIAkgAzYCAAwKCyAKKQAAQuTC0YvGrp645QBRDQULIwBBQGoiAyQAIAMgAjYCDCADIAo2AgggA0EoaiICQQxqQZ0BNgIAIANBEGoiE0EMakECNgIAIANBJGpBAjYCACADQaD2wAA2AhggA0EANgIQIANBAjYCLCADQQY2AjwgA0Gcx8AANgI4IAMgAjYCICADIANBOGo2AjAgAyADQQhqNgIoIBMQ/gchAiADQUBrJAAgCUECNgJAIAkgAjYCAAwIC0HJxsAAQQYQxgchAyAJQQI2AkAgCSADNgIADAsLQcTGwABBBRDGByECIAlBAjYCQCAJIAI2AgAMCwtB0sbAAEEDEMcHIQMgCUECNgJAIAkgAzYCAAwFC0HVxsAAQQYQxwchAyAJQQI2AkAgCSADNgIADAQLAkAgIEEHRgRAIAUoAhAiBBCBByIHDQEgBUHAAmohDCMAQRBrIggkAAJAAkACQAJAIAQoAggiAiAEKAIEIgdJBEAgBCgCACENA0AgAiANai0AACIPQQlrIgNBGUsNA0EBIAN0QZOAgARxRQRAIANBGUcNBCAIIAQQhQUgCC0AAA0DIAwgCC0AAToAAUEAIQcMBgsgBCACQQFqIgI2AgggAiAHRw0ACwsgCEEFNgIAIAwgBCAIEPwHNgIEDAILIAwgCCgCBDYCBAwBCyAPQfsARwRAIAhBCjYCACAMIAQgCBD8BzYCBAwBCyAEIAQtABhBAWsiAzoAGCADQf8BcQRAIAQgAkEBajYCCCAIIAQQhQUCQAJAIAgtAABFBEAgCC0AASEDIAQQgQciAg0BAn8CQAJAAkACQAJAAkACQCADQQFrDgYBAgMEBQYACyAEEMwEIgINCEEADAYLIAQQzAQiAg0HQQEMBQsgBBDMBCICDQZBAgwECyAEEMwEIgINBUEDDAMLIAQQzAQiAg0EQQQMAgsgBBDMBCICDQNBBQwBCyAEEMwEIgINAkEGCyEDQQEhByAEIAQtABhBAWo6ABggBCgCCCICIAQoAgQiDUkEQCAEKAIAIQ8DQCACIA9qLQAAIiBBCWsiFUEXSw0EQQEgFXRBk4CABHFFDQQgBCACQQFqIgI2AgggAiANRw0ACwsgCEEDNgIAIAwgBCAIEP0HNgIEDAULIAgoAgQhAgsgDCACNgIEDAILICBB/QBGBEAgDCADOgABIAQgAkEBajYCCEEAIQcMAwsgCEEKNgIAIAwgBCAIEP0HNgIEDAELIAhBFTYCACAMIAQgCBD8BzYCBAtBASEHCyAMIAc6AAAgCEEQaiQAIAUtAMACRQRAIAUtAMECISAMBwtBByEgIAUoAsQCIgdFDQYMAQtB5cbAAEEIEMcHIQcLIAlBAjYCQCAJIAc2AgAMAwsCQCAYRQRAIAUoAhAiBxCBByIDDQEgBUHAAmohDSMAQTBrIgQkAAJAAkAgBygCCCICIAcoAgQiA0kEQCAHKAIAIQgDQCACIAhqLQAAIgxBCWsiD0EXSw0CQQEgD3RBk4CABHFFDQIgByACQQFqIgI2AgggAiADRw0ACwsgBEEFNgIYIAcgBEEYahD8ByEDIA1BADYCBAwBCwJAIAxB2wBGBEAgByAHLQAYQQFrIgM6ABggA0H/AXFFBEAgBEEVNgIYIAcgBEEYahD8ByEDIA1BADYCBAwDCyAHIAJBAWo2AgggBEEIaiEMIwBBQGoiAyQAIANBAToADCADIAc2AgggA0EANgIYIANCgICAgIABNwMQIANBIGogA0EIahDyAwJAAkAgAy8BKCIIQQNHBEAgA0EqaiIPQQhqIRUgD0EOaiEbAkADQCAIQf//A3FBAkYNASADKQMgITEgAygCGCICIAMoAhBGBEAgA0EQaiACEIIGIAMoAhghAgsgAygCFCACQQV0aiICIAg7AQggAiAxNwMAIAIgDykBADcBCiACQRJqIBUpAQA3AQAgAkEYaiAbKQEANwEAIAMgAygCGEEBajYCGCADQSBqIANBCGoQ8gMgAy8BKCIIQQNHDQALIAxBADYCBCAMIAMoAiA2AgAgAygCGCICRQ0CIAJBBXQhCCADKAIUQRBqIQIDQAJAIAJBCGsvAQBFDQAgAkEEaygCAEUNACACKAIAENQBCyACQSBqIQIgCEEgayIIDQALDAILIAwgAykDEDcCACAMQQhqIANBGGooAgA2AgAMAgsgDEEANgIEIAwgAygCIDYCAAsgAygCEEUNACADKAIUENQBCyADQUBrJAAgByAHLQAYQQFqOgAYIARBIGogDEEIaigCADYCACAEIAQpAwg3AxggBCAHELwFIgM2AiQCQCAEKAIcIgwEQCADRQ0BIAQoAiAiAgRAIAJBBXQhCCAMQRBqIQIDQAJAIAJBCGsvAQBFDQAgAkEEaygCAEUNACACKAIAENQBCyACQSBqIQIgCEEgayIIDQALCyAEKAIYBEAgDBDUAQsgAyECDAMLIAQoAhghAiADRQ0CIARBJGoQ/gYMAgsgBCgCGCEDIA0gBCgCIDYCCCANIAw2AgQMAgsgByAEQShqQdTywAAQ3gEhAgsgAiAHEIoIIQMgDUEANgIECyANIAM2AgAgBEEwaiQAIAUoAsACIQMgBSgCxAIiAgRAIAIgBSgCyAIiIiAFQcACakEAQSAgImdrEGMgAiEYIAMhCwwGCyADDQFBACEYDAULQdvGwABBBBDHByEDCyAJQQI2AkAgCSADNgIADAILIAlBAjYCQCAJIAM2AgAMAQsCQCAcQQdGBEAgBSgCECIDEIEHIgcNASMAQRBrIgQkACAEIAMQ7gQgBCgCACEIAkAgBUHAAmoiAwJ/AkACQAJAAkACQAJAAkAgBCgCBCICBEAgBCgCCCIMQQNrDgcDBQUFBAIBBQsgA0EBOgAAIAMgCDYCBAwICyACQc3LwABBCRDhCg0DIANBAToAAUEADAYLIAIpAABC7cKtq8ap2rn0AFIEQCACKQAAQu3CravGqpm89ABSDQMgA0EDOgABQQAMBgsgA0ECOgABQQAMBQsgAkG6y8AAQQMQ4QpFDQIgAkG3y8AAQQMQ4QoEQCACQbTLwABBAxDhCg0CIANBBjoAAUEADAULIANBBToAAUEADAQLIAJB1svAAEEHEOEKRQ0CCyADIAIgDEHoy8AAQQkQ6wU2AgRBAQwCCyADQQQ6AAFBAAwBCyADQQA6AAFBAAs6AAAgCEUNACACENQBCyAEQRBqJAAgBS0AwAJFBEAgBS0AwQIhHAwEC0EHIRwgBSgCxAIiB0UNAwwBC0HJxsAAQQYQxwchBwsgCUECNgJAIAkgBzYCAAsgBkUNAyAKENQBDAMLIAYEQCAKENQBCyAFQcACaiAFQRBqELMDIAUoAsQCIQYgBSgCwAJFDQALCyAJQQI2AkAgCSAGNgIAC0EBIRNBASEIQQEhAwwHCyALIQYLIAVB0AFqIgIoAggiEwRAIBNBBXQhEyACKAIEQRBqIQIDQAJAIAJBCGsvAQBFDQAgAkEEaygCAEUNACACKAIAENQBCyACQSBqIQIgE0EgayITDQALCyAGRQ0CIAUoAtQBENQBDAILIAVB6AFqIAVB+AFqKQMANwMAIAUgBSkD8AE3A+ABQQAhBwsgCSAFKQPgATcBECAJICU2AjAgCSAjNgIsIAkgKzsBKiAJIBo7ASggCSAsNgIkIAkgEzYCICAJIAUpA5gBNwI0IAkgBSkDqAE3A0AgCUEYaiAFQegBaikDADcBACAJQTxqIAVBoAFqKAIANgIAIAlByABqIAVBqAFqIgNBCGopAwA3AwAgCUHQAGogBUG4AWopAwA3AwAgCUHYAGogA0EYaikDADcDACAJQeAAaiAFQcgBaikDADcDACAJIA42AgQgCSAwNwIIIAkgJEECRyAkcToAdCAJIAY7AQIgCSAcOgABIAkgAjoAACAJQfAAaiAFQdgBaigCADYCACAJIAUpA9ABNwJoAkAgBS8BgAEiA0EDcUEDR0EAIANBAWsbDQAgBUGEAWooAgBFDQAgBUGIAWooAgAQ1AELAkAgHkUNACAmRQ0AIB4Q1AELIAdFDQQgBS0AUCIDQQ5xQQpGDQQCQAJAAkAgAw4JAAEHBwcHBwcCBwsgBSgCVEUNBiAFQdgAaigCABDUAQwGCyAFQesAai0AAEEYRw0FIAUoAlQiCygCACEDIAsgA0EBazYCACADQQFHDQUgBUHQAGpBBHIQrggMBQsgBSgCVEUNBCAFQdgAaigCABDUAQwECyAYRSETIAUoAqgBRQRAIAVBwwFqLQAAQRhHDQEgBSgCrAEiBigCACECIAYgAkEBazYCACACQQFHDQEgBUGoAWpBBHIQrggMAQsgBUG4AWovAQAiAkEDcUEDR0EAIAJBAWsbDQAgBUG8AWooAgBFDQAgBUHAAWooAgAQ1AELIBpBA3EiAkEDR0EAIAJBAWsbDQAgI0UEQEEAISMMAQsgJRDUAQtBASEOCwJAIAUvAYABIgJBA3FBA0dBACACQQFrGw0AIAVBhAFqKAIARQ0AIAVBiAFqKAIAENQBCwJAIB5FDQAgJkUNACAeENQBCwJAIBNFDQAgBS0AUCICQQ5xQQpGDQACQAJAAkAgAg4JAAEDAwMDAwMCAwsgBSgCVEUNAiAFQdgAaigCABDUAQwCCyAFQesAai0AAEEYRw0BIAUoAlQiBigCACECIAYgAkEBazYCACACQQFHDQEgBUHQAGpBBHIQrggMAQsgBSgCVEUNACAFQdgAaigCABDUAQsCQCAIRQ0AIBhFDQAgIgRAICJBBXQhBiAYQRBqIQgDQAJAIAhBCGsvAQBFDQAgCEEEaygCAEUNACAIKAIAENQBCyAIQSBqIQggBkEgayIGDQALCyALRQ0AIBgQ1AELAkAgA0UNAAJAAkAgBSgCKA4DAAECAQsgBS0AQ0EYRw0BIAUoAiwiCygCACEDIAsgA0EBazYCACADQQFHDQEgJxCuCAwBCyAFLwE4IgNBA3FBA0dBACADQQFrGw0AIAUoAjxFDQAgBUFAaygCABDUAQsgDiAaQf//A3FBA0ZyDQAgGkEDcSIDQQNHQQAgA0EBaxsNACAjRQ0AICUQ1AELIAVBgANqJAAMAQtBCkEBQfD0xAAoAgAiAEHKBCAAGxEAAAALIBAgEC0AGEEBajoAGCASQYABaiAJQfgAEOAKGiASIBAQ5wYiAzYC+AEgEigCwAEiC0ECRwRAIANFDQMgEkGAAWoQ8AMMBgsgEigCgAEgAwRAIBJB+AFqEP4GCyEDDAULIBJBFTYCgAEgECASQYABahD8BwwDCyAQIBAtABgiC0EBayICOgAYIAJB/wFxRQ0BIBAgA0EBajYCCCASQQo6AIABIBJBgAFqIBJBCGpB/MrAABCpBiEDIBAgCzoAGCASQQI2AsABIBIgAzYCgAEgEiAQELwFIgs2AvgBIAtFDQMgEkH4AWoQ/gYMAwsgFCASKQKEATcCBCAUIBIpAsQBNwJEIBRBDGogEkGAAWoiA0EMaikCADcCACAUQRRqIANBFGopAgA3AgAgFEEcaiADQRxqKQIANwIAIBRBJGogA0EkaikCADcCACAUQSxqIANBLGopAgA3AgAgFEE0aiADQTRqKQIANwIAIBRBPGogA0E8aigCADYCACAUQcwAaiADQcwAaikCADcCACAUQdQAaiADQdQAaikCADcCACAUQdwAaiADQdwAaikCADcCACAUQeQAaiADQeQAaikCADcCACAUQewAaiADQewAaikCADcCACAUQfQAaiADQfQAaigCADYCACASKAKAASEDIBQgCzYCQAwDCyASQRU2AoABIBAgEkGAAWoQ/AcLIQMgFEECNgJADAELIAMgEBCKCCEDIBRBAjYCQAsgFCADNgIAIBJBgAJqJAAgFygCSEECRwRAIBkgF0EIakH4ABDgChoMAQsgGUEDNgJAIBkgFygCCDYCAAsgF0GAAWokAAJAAkAgESgCWCITQQJrDgICAAELICFBADYCBCAhIBEoAhg2AgAgEUEIahDGAyARKAIIRQ0DIBEoAgwQ1AEMAwsgESgCECIDIBEoAghGBEAgEUEIaiECIwBBIGsiCyQAAkACQCADQQFqIgNFDQBBBCACKAIAIgZBAXQiGCADIAMgGEkbIgMgA0EETRsiA0H4AGwhGCADQZKixAhJQQN0IRoCQCAGBEAgC0EINgIYIAsgBkH4AGw2AhQgCyACQQRqKAIANgIQDAELIAtBADYCGAsgCyAYIBogC0EQahDKBiALKAIEIQYgCygCAEUEQCACIAM2AgAgAkEEaiAGNgIADAILIAtBCGooAgAiA0GBgICAeEYNASADRQ0AIAYgA0Hw9MQAKAIAIgBBygQgABsRAAAACxDHCAALIAtBIGokACARKAIQIQMLIBEoAgwgA0H4AGxqIgMgESkDGDcDACADIBM2AkAgA0EIaiARQRhqIgtBCGopAwA3AwAgA0EQaiALQRBqKQMANwMAIANBGGogC0EYaikDADcDACADQSBqIAtBIGopAwA3AwAgA0EoaiALQShqKQMANwMAIANBMGogC0EwaikDADcDACADQThqIAtBOGopAwA3AwAgAyAdKQIANwJEIANB9ABqIB1BMGooAgA2AgAgA0HsAGogHUEoaikCADcCACADQeQAaiAdQSBqKQIANwIAIANB3ABqIB1BGGopAgA3AgAgA0HUAGogHUEQaikCADcCACADQcwAaiAdQQhqKQIANwIAIBEgESgCEEEBajYCEAwBCwsgISARKQMINwIAICFBCGogEUEQaigCADYCAAsgEUGQAWokACABIAEtABhBAWo6ABggFkEgaiAhQQhqKAIANgIAIBYgFikDCDcDGCAWIAEQvAUiAzYCJAJAIBYoAhwiCwRAIANFDQEgFkEYahDGAyAWKAIYBEAgCxDUAQsgAyELDAMLIBYoAhghCyADRQ0CIBZBJGoQ/gYMAgsgFigCGCEBIAAgFigCIDYCCCAAIAs2AgQMAgsgASAWQShqQbTywAAQ3gEhCwsgCyABEIoIIQEgAEEANgIECyAA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AEECdGogAjYCACABIAEoAhhBAWo2AhggASgCDCEAIAFBJGooAgAiAiABKAIcRgRAIAFBHGogAhCEBiABKAIkIQILIAFBIGooAgAgAkECdGogADYCACABIAEoAiRBAWo2AiQLIAEgASgCDEEBajYCDEEACzYCAAugAwIIfwF+IwBBEGsiAiQAAkACQAJAIAEoAgQiAwRAIAMgASgCACIIaiEJAkADQCAEQT9GIAUgCGoiBywAACIGQQJPcUUEQCAGrUL/AIMgBEE/ca2GIAqEIQogBkEATg0FIARBB2ohBCADIAVBAWoiBUcNAQwCCwsgASADIAVrIgNBAWs2AgQgASAHQQFqIgU2AgAgBkEASARAIANBAmshBANAIARBf0YNBCABIAQ2AgQgASAFQQFqIgM2AgAgBEEBayEEIAUsAAAgAyEFQQBIDQALCyAAQQE2AgAgAEEEOgAEDAQLIAFBADYCBCABIAk2AgALIAJBADoACyACQQA7AAkgAkHowsEANgIMIAJBAjoACCACIAJBCGopAgA3AgAgACACKQMANwIEIABBATYCAAwCCyACQQA6AAsgAkEAOwAJIAJB6MLBADYCDCACQQI6AAggAiACQQhqKQIANwIAIAAgAikDADcCBCAAQQE2AgAMAQsgACAKNwMIIABBADYCACABIAVBf3MgA2o2AgQgASAHQQFqNgIACyACQRBqJAALogMBA38CQAJAAkACQCABQQlPBEAgAUEQSQ0BDAILIAAQdyEDDAILQRAhAQtBzf97IAFrIABNDQBBECAAQQRqIABBC0kbQQdqQXhxIgQgAWpBDGoQdyICRQ0AIAJBCGshAAJAIAFBAWsiAyACcUUEQCAAIQEMAQsgACgCBEF4cSABQQAgAiADakEAIAFrcUEIayIBIABrQRBNGyABaiIBIABrIgJrIQMgAC0ABEEDcQRAIAEgASgCBEEBcSADckECcjYCBCABIANqIgMgAygCBEEBcjYCBCAAIAAoAgRBAXEgAnJBAnI2AgQgACACaiIDIAMoAgRBAXI2AgQgACACEJoDDAELIAAoAgAhACABIAM2AgQgASAAIAJqNgIACyABLQAEQQNxRQ0BIAEoAgRBeHEiAiAEQRBqTQ0BIAEgASgCBEEBcSAEckECcjYCBCABIARqIgAgACgCBEEBcjYCBCAAIAIgBGsiBCAAKAIEQQFxckECcjYCBCAAIARqIgIgAigCBEEBcjYCBCAAIAQQmgMMAQsgAw8LIAEtAAQaIAFBCGoLtwMBDH8gAUEIaigCACIDRQRAIABCgICAgMAANwIAIAAgAzYCCA8LAkACQAJAIANB5syZM0sNACADQRRsIgJBAEgNACABQQRqKAIAIQsgA0HnzJkzSUECdCEEIAIEfyACIAQQ8AkFIAQLIgkEQCAAIAk2AgQgACADNgIAIANBFGwhDCADIQQDQCAGIAxHBEAgBEUNBQJ/IAYgC2oiAi8BAEUEQCACQQJqLwEAIQggAkEQaigCACENIAJBDGooAgAhASACQQhqKAIAIQdBACEKIAJBBGooAgAMAQsgAkEIaigCACEIQQEhCkEBIQcgAkEMaigCACIBBEAgAUEASA0FIAFBARDwCSIHRQ0GCyAHIAggARDgChogAQshAiAGIAlqIgUgCjsBACAFQRBqIA02AgAgBUEMaiABNgIAIAVBCGogBzYCACAFQQRqIAI2AgAgBUECaiAIOwEAIAZBFGohBiAEQQFrIgQNAQsLIAAgAzYCCA8LIAIgBEHw9MQAKAIAIgBBygQgABsRAAAACxDHCAALIAFBAUHw9MQAKAIAIgBBygQgABsRAAAACyADIANB8L7AABCcBwALmwMCB38BfiMAQRBrIgIkACABKAIEQQFrIQQgASgCACEFAkACQANAIARBf0YNASABIAQ2AgQgASAFIgZBAWoiBTYCACAGLQAAIgjAIQcCQCADQT9HDQAgCEUNACAIQf8ARg0AAkAgB0EASARAIAZBAWohBSAEQQFrIQMDQCADQX9GDQIgASADNgIEIAEgBUEBaiIGNgIAIANBAWshAyAFLAAAIAYhBUEASA0ACwsgAEEBNgIAIABBBDoABAwECyACQQA6AAsgAkEAOwAJIAJB6MLBADYCDCACQQI6AAggAiACQQhqKQIANwIAIAAgAikDADcCBCAAQQE2AgAMAwsgB61C/wCDIANBP3GthiAJhCEJIARBAWshBCADQQdqIQMgB0EASA0ACyAAQQA2AgAgACAJQn8gA0E/ca2GQgAgB0HAAHFBBnYbQgAgA0HAAEgbhDcDCAwBCyACQQA6AAsgAkEAOwAJIAJB6MLBADYCDCACQQI6AAggAiACQQhqKQIANwIAIAAgAikDADcCBCAAQQE2AgALIAJBEGokAAvBAwEGfyMAQSBrIgQkAAJAAkACQAJAAkAgASgCBCIFIAEoAgAiCE8EQCADIAVJDQEgAUEMaigCACIGIAEoAggiCUkNAiADIAZJDQMgBEEVakIANwAAIARCADcCECABQRRqKAIAIgcgASgCECIBSQ0EIAMgB0kNBSAAQgA3AyAgAEEANgIQIABCADcDACAAQgA3A2ggAEHYAGpCADcDACAAQdAAaiAHIAFrNgIAIABBzABqIAEgAmo2AgAgAEHIAGpBADYCACAAQeQAakEAOgAAIABB4ABqQQA2AgAgAEHHAGpBGzoAACAAIAUgCGs2AhggACACIAhqNgIUIABBJWpCADcAACAAQYABaiAGIAlrNgIAIABB/ABqIAIgCWo2AgAgAEH4AGpBADYCACAAQZgBakIANwMAIABBlAFqIARBHGotAAA6AAAgAEGMAWogBEEUaikCADcCACAAQYQBaiAEKQIMNwIAIARBIGokAA8LIAggBUHIs8IAEI4KAAsgBSADQcizwgAQjQoACyAJIAZBrJHBABCOCgALIAYgA0GskcEAEI0KAAsgASAHQcizwgAQjgoACyAHIANByLPCABCNCgALtwMBDH8gAUEIaigCACIDRQRAIABCgICAgMAANwIAIAAgAzYCCA8LAkACQAJAIANB5syZM0sNACADQRRsIgJBAEgNACABQQRqKAIAIQsgA0HnzJkzSUECdCEEIAIEfyACIAQQ8AkFIAQLIgkEQCAAIAk2AgQgACADNgIAIANBFGwhDCADIQQDQCAGIAxHBEAgBEUNBQJ/IAYgC2oiAi8BAEUEQCACQQJqLwEAIQggAkEQaigCACENIAJBDGooAgAhASACQQhqKAIAIQdBACEKIAJBBGooAgAMAQsgAkEIaigCACEIQQEhCkEBIQcgAkEMaigCACIBBEAgAUEASA0FIAFBARDwCSIHRQ0GCyAHIAggARDgChogAQshAiAGIAlqIgUgCjsBACAFQRBqIA02AgAgBUEMaiABNgIAIAVBCGogBzYCACAFQQRqIAI2AgAgBUECaiAIOwEAIAZBFGohBiAEQQFrIgQNAQsLIAAgAzYCCA8LIAIgBEHw9MQAKAIAIgBBygQgABsRAAAACxDHCAALIAFBAUHw9MQAKAIAIgBBygQgABsRAAAACyADIANBhLrCABCc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AEEMaigCADYCACANIAApAgQ3AyAgDUEIaiEPIAAoAgAhCSMAQRBrIg4kACACKAIIIQUCQAJAAkACQAJAAkACQAJAAkAgAigCBCIDLwEyIgFBC08EQCACKAIAIQIgDiAFEPsHIA5BCGooAgAhBSAOKAIEIQcgDigCACEBQTRBBBDwCSIERQ0OIARBADYCACAEIAMvATIiCiABQX9zaiILOwEyIAtBDE8NAiAKIAFBAWoiBmsgC0cNCCADQQRqIgggAUECdGooAgAhCiAEQQRqIAggBkECdGogC0ECdBDgChogAyABOwEyIAQgAyAHGyILQQRqIQEgBUEBaiIGIAsvATIiB00EQCABIAZBAnRqIAEgBUECdGogByAFa0ECdBDfChoLIAEgBUECdGogCTYCACALIAdBAWo7ATIgAygCACIBDQFBACEFDAYLIANBBGohAiAFQQFqIgQgAU0EQCACIARBAnRqIAIgBUECdGogASAFa0ECdBDfChoLIAIgBUECdGogCTYCACAPQQA2AgQgAyABQQFqOwEyIAMhCwwGCyACIQVBACECA0AgCiEJIAQhByADIAEhAyACIAVHDQJBMGovAQAhASADLwEyIgpBC08EQCAOIAEQ+wcgDigCCCEIIA4oAgQhDCAOKAIAIQIgAy8BMkHkAEEEEPAJIgRFDQ8gBEEANgIAIAQgAy8BMiIKIAJBf3NqIgE7ATIgAUEMTw0EIAogAkEBaiIGayABRw0IIANBBGoiESACQQJ0aigCACEKIARBBGogESAGQQJ0IhFqIAFBAnQQ4AoaIAMgAjsBMiAELwEyIgZBAWohASAGQQxPDQUgAmsiAiABRw0IIAVBAWohBSAEQTRqIAMgEWpBNGogAkECdBDgCiECQQAhAQNAAkAgAiABQQJ0aigCACIQIAE7ATAgECAENgIAIAEgBk8NACAGIAEgASAGSWoiAU8NAQsLIAQgAyAMGyIGQQRqIQEgCEEBaiICIAYvATIiDE0EQCABIAJBAnRqIAEgCEECdGogDCAIa0ECdBDfChoLIAxBAWohECAIQQJ0IhEgAWogCTYCACAGQTRqIQEgDEECaiIJIAhBAmoiEksEQCABIBJBAnRqIAEgAkECdGogDCAIa0ECdBDfChoLIAEgAkECdGogBzYCACAGIBA7ATICQCACIAlPDQAgDCAIayIHQQFqQQNxIgkEQCAGIBFqQThqIQEDQCABKAIAIgggAjsBMCAIIAY2AgAgAUEEaiEBIAJBAWohAiAJQQFrIgkNAAsLIAdBA0kNACACQQNqIQFBfiAMayEJIAYgAkECdGpBQGshAgNAIAJBDGsoAgAiByABQQNrOwEwIAcgBjYCACACQQhrKAIAIgcgAUECazsBMCAHIAY2AgAgAkEEaygCACIHIAFBAWs7ATAgByAGNgIAIAIoAgAiByABOwEwIAcgBjYCACACQRBqIQIgCSABQQRqIgFqQQNHDQALCyAFIQIgAygCACIBRQ0GDAELCyABQQFqIQIgA0EEaiEFIApBAWohBCABIApJBEAgAkECdCIGIAVqIAFBAnQiCCAFaiAKIAFrQQJ0IgwQ3woaIAggA0E0aiIIakEIaiAGIAhqIAwQ3woaCyAFIAFBAnRqIAk2AgAgAyACQQJ0akE0aiAHNgIAIAMgBDsBMgJAIAIgCkECak8NACAKIAFrIgVBAWpBA3EiBARAIAMgAUECdGpBOGohAQNAIAEoAgAiCSACOwEwIAkgAzYCACABQQRqIQEgAkEBaiECIARBAWsiBA0ACwsgBUEDSQ0AIAJBA2ohAUF+IAprIQUgAkECdCADakFAayECA0AgAkEMaygCACIEIAFBA2s7ATAgBCADNgIAIAJBCGsoAgAiBCABQQJrOwEwIAQgAzYCACACQQRrKAIAIgQgAUEBazsBMCAEIAM2AgAgAigCACIEIAE7ATAgBCADNgIAIAJBEGohAiAFIAFBBGoiAWpBA0cNAAsLIA9BADYCBAwFCyALQQtBuIXBABCNCgALQdiFwQBBNUGQhsEAEJ4IAAsgAUELQbiFwQAQjQoACyABQQxByIXBABCNCgALIA8gCjYCECAPIAQ2AgwgDyAFNgIIIA8gAzYCBCAPIAI2AgALIA8gCzYCFCAOQRBqJAAMAQtBgIXBAEEoQaiFwQAQnggACyAAKAIQIQMgDSgCHBogDSgCDARAIAMoAgQiAkUNAiADKAIAIQEgDSgCECEEIA0oAhQhBSANKAIYIQtB5ABBBBDwCSIARQ0GIAAgAjYCNCAAQQA7ATIgAEEANgIAIAMgADYCBCACQQA7ATAgAiAANgIAIAMgAUEBajYCACABIARHDQMgAC8BMiICQQpLDQQgACACQQFqIgE7ATIgAEE0aiABQQJ0aiAFNgIAIAAgAkECdGpBBGogCzYCACAFIAE7ATAgBSAANgIACyADIAMoAghBAWo2AggLIA1BMGokAA8LQZDSwgBBK0Gc08IAEJ4IAAtBnIPBAEEwQcyDwQAQnggAC0GQgsEAQSBB3IPBABCeCAALQTRBBEHw9MQAKAIAIgBBygQgABsRAAAAC0HkAEEEQfD0xAAoAgAiAEHKBCAAGxEAAAAL1AMBAn8jAEFAaiICJAACQAJAAkACQAJAAkAgAC0AAEEBaw4DAQIDAAsgAiAAKAIENgIEQRRBARDwCSIARQ0EIABBEGpB85/EACgAADYAACAAQQhqQeufxAApAAA3AAAgAEHjn8QAKQAANwAAIAJBFDYCECACIAA2AgwgAkEUNgIIIAJBKGoiAEEMakEDNgIAIABBFGpBAjYCACACQRhqIgNBDGpBrAM2AgAgAkGAmMQANgIwIAJBADYCKCACQcgENgIcIAIgAzYCOCACIAJBBGo2AiAgAiACQQhqNgIYIAEgABDkByEAIAIoAghFDQMgAigCDBDUAQwDCyAALQABIQAgAkE0akEBNgIAIAJBPGpBATYCACACQaCRxAA2AjAgAkEANgIoIAJByQQ2AgwgAiAAQSBzQT9xQQJ0IgBBmKXEAGooAgA2AhwgAiAAQZinxABqKAIANgIYIAIgAkEIajYCOCACIAJBGGo2AgggASACQShqEOQHIQAMAgsgACgCBCIAKAIAIAAoAgQgARDcCiEADAELIAAoAgQiACgCACABIABBBGooAgAoAhARAQAhAAsgAkFAayQAIAAPC0EUQQFB8PTEACgCACIAQcoEIAAbEQAAAAvpCgIJfwN+IwBBsAdrIgYkAEGE9MQAKAIAQQNHBEAgBkEBOgAoIAYgBkEoajYC2AMgBkHYA2ohCiMAQTBrIgUkACAFQRhqQQJyIQtBhPTEACgCACEEA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAQiCA4EAAMCAQILIAhBhPTEACgCACIERiEHQYT0xABBAiAEIAcbNgIAIAdFDQ0gBSAIQQFGOgAcIAVBAzYCGCAKIAVBGGpBsIDAACgCABEAAEGE9MQAKAIAIQRBhPTEACAFKAIYNgIAIAUgBEEDcSIINgIQIAhBAkcNCCAEQQJrIgRFDQADQCAEKAIAIQcgBEEANgIAIAdFDQogBCgCBCAEQQE6AAggB0EQahCHBSAHIAcoAgAiBEEBazYCACAEQQFGBEAgBxCGCAsiBA0ACwsgBUEwaiQADAsLIAhBA3FBAkYEQANAQez4xAAoAgANA0Hs+MQAQX82AgBB8PjEACgCACIERQRAIAVBCGpBGEEIEIYHIAUoAgwhByAFKAIIIQkgBUEYQQgQhgcgBSgCBCEEIAUoAgAiDARAIAwgBBDwCSEECyAERQ0FIARCgYCAgBA3AgAgBEEANgIIQYj1xAApAwAhDQNAIA1CAXwiDlANByANQYj1xAApAwAiDVEhB0GI9cQAIA4gDSAHGzcDACAHRQ0ACyAEQQA7ARRB8PjEACAENgIAIARBEGpBADYCACAEQRhqIA43AwALIAQgBCgCACIHQQFqNgIAIAdBAEgNBiAIIQdB7PjEAEHs+MQAKAIAQQFqNgIAIAdBhPTEACgCACIIRiEJQYT0xAAgCyAIIAkbNgIAIAVBADoAICAFIAQ2AhggBSAHQXxxNgIcIAkEQCAFLQAgRQ0IDAsLAkAgBSgCGCIERQ0AIAQgBCgCACIEQQFrNgIAIARBAUcNACAFKAIYEIYICyAIQQNxQQJGDQAMCwsAC0HUocQAQcAAQZyHwAAQnggACyAFQSRqQQE2AgAgBUEsakEANgIAIAVBwKLEADYCICAFQZyOxAA2AiggBUEANgIYIAVBGGpBnIfAABDaCAALQZyOxABBECAFQRBqQayOxABBzJjEABCHBwALIAkgB0Hw9MQAKAIAIgBBygQgABsRAAAACxDGCAALAAsDQBC/AyAFLQAgRQ0ACwwCCyAFQQA2AiAgBUEQaiAFQRhqQfiixAAQ1wcAC0HgjsQAQStBiKPEABCeCAALIAUoAhgiBEUNACAEIAQoAgAiBEEBazYCACAEQQFHDQAgBSgCGBCGCEGE9MQAKAIAIQQMAgtBhPTEACgCACEEDAELCwsgBiADNgIwIAYgAjYCLCAGIAM2AiggBkHYA2oiBCAGQShqIgggAUEARxDiAiAGKALYAyEBIAYoAtwDIQIgCCAEQQhqQawDEOAKGiAGQQhqIAZBlgdqKQEANwMAIAZBEGogBkGeB2opAQA3AwAgBkEYaiAGQaYHaikBADcDACAGQSBqIAZBrgdqLwEAOwEAIAYgBikBjgc3AwACQAJ/IAYvAYwHIghBA0cEQEHgA0EIEPAJIgNFDQIgAyACNgIMIAMgATYCCEEAIQQgA0EANgIAIANBEGogBkEoakGsAxDgChogAyAIOwG8AyADIAYpAwA3Ab4DIANBxgNqIAZBCGopAwA3AQAgA0HOA2ogBkEQaikDADcBACADQdYDaiAGQRhqKQMANwEAIANB3gNqIAZBIGovAQA7AQBBAAwBC0EBIQQgASACEKUGCyEBIAAgBDYCCCAAIAE2AgQgACADNgIAIAZBsAdqJAAPC0HgA0EIQfD0xAAoAgAiAEHKBCAAGxEAAAALoQMCA38BfiMAQdAAayIHJAAgB0EIaiACIAQQ+wICQAJAAkAgBy0ACCIEQRNGBEAgB0EUai0AACIEQf4BcUECRw0BIAdBEGooAgAhCCAHKAIMIQkgB0EwaiIEQQo6AAAgBCAGOgABIAdBCGogASACIAMgCSAIIAUgBBDzASAHLQAIIgNBE0cNAiAAQQhqIAIgBygCDCAHQRBqKAIAEOIJIABBEzoAAAwDCyAAIAcvAAk7AAEgACAHKQAVNwANIABBA2ogBy0ACzoAACAAQRVqIAdBCGoiAUEVaikAADcAACAAQR1qIAFBHWopAAA3AAAgAEEkaiABQSRqKAAANgAAIAcpAgwhCiAAIActABQ6AAwgACAKNwIEIAAgBDoAAAwCCyAAIAQ6AAEgAEELOgAADAELIAAgBy8ACTsAASAAIAcpAhQ3AgwgAEEDaiAHLQALOgAAIABBFGogB0EIaiIBQRRqKQIANwIAIABBHGogAUEcaikCADcCACAAQSRqIAFBJGooAgA2AgAgACAHKQIMNwIEIAAgAzoAAAsgB0HQAGokAAubAwEJfyMAQUBqIgMkACABKAIIIgcgASgCBCIGayICQQJ2IQUgASgCDCEIIAEoAgAhCQJAAkACQCAGIAdGBEAgAEEINgIEIAAgBTYCAEEAIQIMAQsgAkH8//8/Sw0BIAJBBHQiBEEASA0BIAEoAhAhCiACQf3//z9JQQN0IQIgBAR/IAQgAhDwCQUgAgsiAUUNAiAAIAE2AgQgACAFNgIAIANBIGohBUEAIQIDQCAGKAIAIgRFDQEgAyAEEN8GIAUgCiAEKAIgIARBJGooAgAQ4gkgAUE4aiADQThqKQMANwMAIAFBMGogA0EwaikDADcDACABQShqIANBKGopAwA3AwAgAUEgaiAFKQMANwMAIAFBGGogA0EYaikDADcDACABQRBqIANBEGopAwA3AwAgAUEIaiADQQhqKQMANwMAIAEgAykDADcDACABQUBrIQEgAkEBaiECIAcgBkEEaiIGRw0ACwsgACACNgIIIAkEQCAIENQBCyADQUBrJAAPCxDHCAALIAQgAkHw9MQAKAIAIgBBygQgABsRAAAAC5IDAQJ/AkACQAJAIAIEQCABLQAAQTFJDQECQCADwSIHQQBKBEAgBSABNgIEQQIhBiAFQQI7AQAgA0H//wNxIgMgAk8NASAFQQI7ARggBUECOwEMIAUgAzYCCCAFQSBqIAIgA2siAjYCACAFQRxqIAEgA2o2AgAgBUEUakEBNgIAIAVBEGpB+sbEADYCAEEDIQYgAiAETw0FIAQgAmshBAwECyAFQQI7ARggBUEAOwEMIAVBAjYCCCAFQfjGxAA2AgQgBUECOwEAIAVBIGogAjYCACAFQRxqIAE2AgAgBUEQakEAIAdrIgE2AgBBAyEGIAIgBE8NBCABIAQgAmsiAU8NBCABIAdqIQQMAwsgBUEAOwEMIAUgAjYCCCAFQRBqIAMgAms2AgAgBEUNAyAFQQI7ARggBUEgakEBNgIAIAVBHGpB+sbEADYCAAwCC0Hcw8QAQSFBgMbEABCeCAALQZDGxABBIUG0xsQAEJ4IAAsgBUEAOwEkIAVBKGogBDYCAEEEIQYLIAAgBjYCBCAAIAU2AgALoBABEn8jAEEwayINJAACQAJAAkACQAJAAkAgACgCBEUEQCAAKAIQIQJBNEEEEPAJIgNFDQUgA0EBOwEyIANBADYCACADIAAoAgw2AgQgAkEBNgIIIAIgAzYCBCACQQA2AgAMAQsgDUEgaiICQQhqIABBCGooAgA2AgAgDSAAKQIANwMgIA1BCGohECAAKAIMIQYjAEEQayIOJAAgAigCCCEEAkACQAJAAkACQAJAAkACQAJAAkAgAigCBCIDLwEyIgFBC08EQCACKAIAIQIgDiAEEPsHIA5BCGooAgAhBCAOKAIEIQggDigCACEBQTRBBBDwCSIHRQ0PIAdBADYCACAHIAMvATIiCiABQX9zaiIMOwEyIAxBDE8NAiAKIAFBAWoiBWsgDEcNCSADQQRqIgkgAUECdGooAgAhCiAHQQRqIAkgBUECdGogDEECdBDgChogAyABOwEyIAcgAyAIGyIMQQRqIQEgBEEBaiIFIAwvATIiCE0EQCABIAVBAnRqIAEgBEECdGogCCAEa0ECdBDfChoLIAEgBEECdGogBjYCACAMIAhBAWo7ATIgAygCACIBDQFBACEEDAYLQQQhByADQQRqIQIgBEEBaiIMIAFNBEAgAiAMQQJ0aiACIARBAnRqIAEgBGtBAnQQ3woaCyACIARBAnRqIAY2AgAgAyABQQFqOwEyDAcLIAIhBEEAIQIDQCAKIQYgByEIIAMgASEDIAIgBEcNAkEwai8BACEBIAMvATIiBUELTwRAIA4gARD7ByAOKAIIIQkgDigCBCELIA4oAgAhAiADLwEyQeQAQQQQ8AkiB0UNECAHQQA2AgAgByADLwEyIgogAkF/c2oiATsBMiABQQxPDQQgCiACQQFqIgVrIAFHDQkgA0EEaiIRIAJBAnRqKAIAIQogB0EEaiARIAVBAnQiEWogAUECdBDgChogAyACOwEyIAcvATIiBUEBaiEBIAVBDE8NBSACayICIAFHDQkgBEEBaiEEIAdBNGogAyARakE0aiACQQJ0EOAKIQJBACEBA0ACQCACIAFBAnRqKAIAIg8gATsBMCAPIAc2AgAgASAFTw0AIAUgASABIAVJaiIBTw0BCwsgByADIAsbIgVBBGohASAJQQFqIgIgBS8BMiILTQRAIAEgAkECdGogASAJQQJ0aiALIAlrQQJ0EN8KGgsgC0EBaiEPIAlBAnQiESABaiAGNgIAIAVBNGohASALQQJqIgYgCUECaiISSwRAIAEgEkECdGogASACQQJ0aiALIAlrQQJ0EN8KGgsgASACQQJ0aiAINgIAIAUgDzsBMgJAIAIgBk8NACALIAlrIghBAWpBA3EiBgRAIAUgEWpBOGohAQNAIAEoAgAiCSACOwEwIAkgBTYCACABQQRqIQEgAkEBaiECIAZBAWsiBg0ACwsgCEEDSQ0AIAJBA2ohAUF+IAtrIQYgBSACQQJ0akFAayECA0AgAkEMaygCACIIIAFBA2s7ATAgCCAFNgIAIAJBCGsoAgAiCCABQQJrOwEwIAggBTYCACACQQRrKAIAIgggAUEBazsBMCAIIAU2AgAgAigCACIIIAE7ATAgCCAFNgIAIAJBEGohAiAGIAFBBGoiAWpBA0cNAAsLIAQhAiADKAIAIgFFDQYMAQsLIAFBAWohAkEEIQcgA0EEaiEEIAVBAWohCiABIAVJBEAgAkECdCIJIARqIAFBAnQiCyAEaiAFIAFrQQJ0Ig8Q3woaIAsgA0E0aiILakEIaiAJIAtqIA8Q3woaCyAEIAFBAnRqIAY2AgAgAyACQQJ0akE0aiAINgIAIAMgCjsBMkEAIQogAiAFQQJqTw0FIAUgAWsiBEEBakEDcSIGBEAgAyABQQJ0akE4aiEBA0AgASgCACIIIAI7ATAgCCADNgIAIAFBBGohASACQQFqIQIgBkEBayIGDQALCyAEQQNJDQUgAkEDaiEBQX4gBWshBCACQQJ0IANqQUBrIQIDQCACQQxrKAIAIgYgAUEDazsBMCAGIAM2AgAgAkEIaygCACIGIAFBAms7ATAgBiADNgIAIAJBBGsoAgAiBiABQQFrOwEwIAYgAzYCACACKAIAIgYgATsBMCAGIAM2AgAgAkEQaiECIAQgAUEEaiIBakEDRw0ACwwFCyAMQQtBuIXBABCNCgALQdiFwQBBNUGQhsEAEJ4IAAsgAUELQbiFwQAQjQoACyABQQxByIXBABCNCgALIBAgBzYCDCAQIAQ2AgggECADNgIEIBAgAjYCAEEQIQcLIAwhAwsgByAQaiAKNgIAIBAgAzYCFCAOQRBqJAAMAQtBgIXBAEEoQaiFwQAQnggACyAAKAIQIQMgDSgCHBogDSgCDARAIAMoAgQiAkUNAiADKAIAIQEgDSgCECEHIA0oAhQhBCANKAIYIQpB5ABBBBDwCSIARQ0GIAAgAjYCNCAAQQA7ATIgAEEANgIAIAMgADYCBCACQQA7ATAgAiAANgIAIAMgAUEBajYCACABIAdHDQMgAC8BMiICQQpLDQQgACACQQFqIgE7ATIgAEE0aiABQQJ0aiAENgIAIAAgAkECdGpBBGogCjYCACAEIAE7ATAgBCAANgIACyADIAMoAghBAWo2AggLIA1BMGokAA8LQZDSwgBBK0Gc08IAEJ4IAAtBnIPBAEEwQcyDwQAQnggAC0GQgsEAQSBB3IPBABCeCAALQTRBBEHw9MQAKAIAIgBBygQgABsRAAAAC0HkAEEEQfD0xAAoAgAiAEHKBCAAGxEAAAALqAQBBX8jAEEQayIGJAAgAEEMaiIEKAIAIgMgAEEEaiIFKAIARgRAIAUgAxCVBiAEKAIAIQMLIABBCGooAgAgA0EBdGogATsBACAEIAQoAgBBAWoiAzYCACACQQxqKAIAIgFBAXQhBSACQQhqKAIAIQQgAigCBCABIAAoAgQgA2tLBEAgAEEEaiADIAEQkgYgAEEMaigCACEDCyAAKAIIIANBAXRqIAQgBRDgChogAEEMaiABIANqNgIABEAgBBDUAQsgBiACKAIQNgIAIAYgAkEUaigCACIENgIMIAYgAkEYaigCACIBQRxsIgUgBGoiBzYCCCABIAAoAhAgAEEYaigCACIDa0sEQCAAQRBqIAMgARDyBSAAKAIYIQMLIABBFGooAgAgA0EcbGogBCAFEOAKGiAAIAEgA2o2AhggBiAHNgIEIAZBCGooAgAiAyAGQQRqKAIAIgFrQRxuIQQgASADRwRAIAEgBEEcbGohBwNAIAEoAgQEQCABQQhqKAIAENQBCyABQRRqIQQgAUEYaigCACIFBEAgBCgCACEDIAVBHGwhBQNAIAMQlgcgA0EcaiEDIAVBHGsiBQ0ACwsgAUEcaiEDIAEoAhAEQCAEKAIAENQBCyAHIAMiAUcNAAsLIAYoAgAEQCAGKAIMENQBCyAAIAIoAgAgACgCAGpBAWo2AgAgAEEMaigCAEEfTwRAIAZBEGokAA8LQYSmwABBIEGkpsAAEJ4IAAuMBAEFfyMAQdAAayIDJAACQAJAAkBBDEEEEPAJIgQEQCABKAIAIQcCQCABQQRqKAIAIgFFBEBBASEFDAELIAFBAE4iBkUNAiABIAYQ8AkiBUUNAwsgBSAHIAEQ4AohBSAEIAE2AgggBCAFNgIEIAQgATYCACADQQA2AgggA0KAgICAEDcDACADQRBqIgFBAzoAICABQoCAgICABDcCGCABQQA2AhAgAUEANgIIIAFB4PjBADYCBCABIAM2AgACQAJAAkACQEECIAItAAAiAUEGayABQQVNG0H/AXFBAWsOAgIAAQsgAiADQRBqEMEDDQYMAgsgA0HEAGpBATYCACADQcwAakEANgIAIANB+PHBADYCQCADQYTnwQA2AkggA0EANgI4IANBEGogA0E4ahDkB0UNAQwFCyADQcQAakEBNgIAIANBzABqQQA2AgAgA0HU8cEANgJAIANBhOfBADYCSCADQQA2AjggA0EQaiADQThqEOQHDQQLIAAgAykDADcCACAAQQhqIANBCGooAgA2AgAgAEEUakEBNgIAIABBEGogBDYCACAAQQE2AgwgAhDABiADQdAAaiQADwtBDEEEQfD0xAAoAgAiAEHKBCAAGxEAAAALEMcIAAsgASAGQfD0xAAoAgAiAEHKBCAAGxEAAAALQfj4wQBBNyADQThqQbD5wQBBjPrBABCHBwALrgMBCH8jAEFAaiICJAAgASgCACIIIAEoAgQiBWsiA0EDdiEEAkACQAJAAkAgBSAIRgRAIABBBDYCBCAAIAQ2AgAgAEEIaiEEQQAhAAwBCyADQdCq1aoFSw0BIARBDGwiBkEASA0BIAEoAgghByADQdGq1aoFSUECdCEDIAYEfyAGIAMQ8AkFIAMLIgFFDQIgAEEANgIIIAAgATYCBCAAIAQ2AgAgAEEIaiEEIAdBwAFqIQYgB0G8AWohB0EAIQADQCAFQQRqKAIAIQMgAiAFNQIANwMgIAMgBigCACIJTw0EIAJBgQM2AhwgAkGzATYCFCACIAcoAgAgA0EUbGo2AhggAiACQSBqNgIQIAJBAjYCPCACQQI2AjQgAkGk3cIANgIwIAJBADYCKCACIAJBEGo2AjggAiACQShqELcDIAFBCGogAkEIaigCADYCACABIAIpAwA3AgAgAUEMaiEBIABBAWohACAIIAVBCGoiBUcNAAsLIAQgADYCACACQUBrJAAPCxDHCAALIAYgA0Hw9MQAKAIAIgBBygQgABsRAAAACyADIAlBtN3CABCcBwALngMCBX8BfiMAQTBrIgIkACABKAIEIgNBxABqIQQgASgCDCEGIAEoAgghAQJAAkAgAAJ/AkACQAJAIAMoAkBFBEAgBCgCACIDIAFB2ABqKAIAIgRJDQEgAyAEQYjEwgAQnAcACyADKAJEIANByABqKAIAckUNASACIAE2AgwgAiAENgIIDAILIAJBCGogAUHUAGooAgAgA0EMbGoQ3gMgAi0AH0EcRg0BIAAgAikDCDcCBCAAQRRqIAJBGGopAwA3AgAgAEEMaiACQRBqKQMANwIAQQAMAgsgAkEANgIICyAAIAIoAggiAQR+IAIoAgwiBEEoaigCACIFIAEoAgQiA00NAiAGKAIEIgVFDQMgAkEgaiAGKAIAIAUgBEEkaigCACADQRRsahDoAiACKAIgDQMgAkEoaigCACACQSxqKAIAQQJ0akHgAWooAgAhAyABNQIAIQdCAQVCAAs3AwggAEEYaiADNgIAIABBEGogBzcDAEEBCzYCACACQTBqJAAPCyADIAVBiMTCABCcBwALQezEwgBBK0Ggx8IAEJ4IAAvSQAIofwR+IwBBsAdrIg8kAAJAAkACQAJAAkAgAQRAIAEoAgANASABQX82AgAgDyADNgIwIA8gAjYCLCAPIAM2AiggD0HYA2ohGyAPQShqIR1BACEDIwBBoAprIgQkACAEQcAJaiABQQhqIgdBkANqEIwBIARB0AlqIAdBnANqEIwBIAdBgAFqKQMAISwgB0GIAWopAwAhLSAEQfAJaiEFIwBBIGsiDSQAAkACQAJAAkACQAJAAkACfyAHQZABaiIGKAIAIgJFBEBBgIDAACEJQQAMAQsgAkEBaq1CJH4iLkIgiKcNAiAupyIJQQdqIQMgAyAJSQ0CIANBeHEiCSACQQlqIgtqIQMgAyAJSQ0CAkACQCADQQBOBEAgAw0BQQghCAwCCwwECyADQQgQ8AkiCEUNDAsgCCAJaiIJIAZBDGooAgAiAyALEOAKIAJBf3NBJGwiCGogAyAIaiACQSRsQSRqEOAKGiAGKAIEIQMgBigCCAshBiAFIAk2AgwgBSAGNgIIIAUgAzYCBCAFIAI2AgAgDUEgaiQADAALIAQgLTcD6AkgBCAsNwPgCSAEQYQJaiEIAkAgB0HsAWoiAkEIaigCACIDRQRAIAhCgICAgIABNwIADAELIANB////H0sNAiADQQV0Ig1BAEgNAiACQQRqKAIAIQkgA0GAgIAgSUEDdCEFAkAgDQR/IA0gBRDwCQUgBQsiBgRAIAggBjYCBCAIIAM2AgAgA0EFdCENIAMhAgNAIAwgDUcEQCACRQ0DIAlBFGopAgAhLCAJKQMAIS0gCSgCHCELIAkoAhAhDiAGIAxqIgVBCGogCSkDCDcDACAFQRBqIA42AgAgBUEcaiALNgIAIAVBFGogLDcCACAFIC03AwAgDEEgaiEMIAlBIGohCSACQQFrIgINAQsLDAILIA0gBUHw9MQAKAIAIgBBygQgABsRAAAACwwDCyAIIAM2AgggBEGQCWohBgJAIAdB+AFqIgJBCGooAgAiA0UEQCAGQoCAgIDAADcCAAwBCyADQarVqtUASw0CIANBDGwiCEEASA0CIAJBBGooAgAhCSADQavVqtUASUECdCEFAkAgCAR/IAggBRDwCQUgBQsiAgRAIAYgAjYCBCAGIAM2AgAgA0EMbCEIIAMhBQNAIAgEQCAFRQ0DIAkoAgAhDSACQQRqIAkpAgQ3AgAgAiANNgIAIAhBDGshCCACQQxqIQIgCUEMaiEJIAVBAWsiBQ0BCwsMAgsMDAsMAwsgBiADNgIIIAdBiAJqKAIAIQkCQCAHQYwCaigCACIFRQRAQQEhAgwBCyAFQf///x9LDQIgBUEFdCIKQQBIDQIgBUGAgIAgSSEDIAoEfyAKIAMQ8AkFIAMLIgJFDQQLIARBoAlqIAI2AgAgBCAFNgKcCSACIAkgChDgChogBEGkCWogBTYCAAJAAkAgB0HoAWooAgAEQCAHQeQBaigCACICRQ0BIARB+AhqIAcoAuABIAIQpQIMAgsgBEIANwL8CAwBC0HsicAAQStB1I/AABCeCAALIAdBoAFqKQMAIS0gB0GoAWopAwAhLiAEQZAKaiEMQQAhAyMAQSBrIhEkAAJAAkACfyAHQbABaiIUKAIAIhJFBEBBgIDAACELQQAMAQsgEkEBaiICQf////8AcSACRw0DIAJBBHQiAiASQQlqIgNqIgUgAkkNAwJAAkAgBUEATgRAIAUNAUEIIQgMAgsMBQsgBUEIEPAJIghFDQgLIAIgCGoiCyAUKAIMIgogAxDgCiECIBQoAggiAwRAIAJBEGshEyAKQQhqIQYgCikDAEJ/hUKAgYKEiJCgwIB/gyEsIAMhCSAKIQUDQCAsUARAA0AgBUGAAWshBSAGKQMAIAZBCGohBkJ/hUKAgYKEiJCgwIB/gyIsUA0ACwsgBSAseqdBAXRB8AFxayIVQRBrIg0oAgAhGSANQQhqKAIAIRBBACEIQQQhAiANQQxqKAIAIg4EQCAOQf////8BSw0HIA5BAnQiCEEASA0HIA5BgICAgAJJQQJ0IQ0gCAR/IAggDRDwCQUgDQsiAkUNBAsgLEIBfSAsgyEsIAIgECAIEOAKIQggE0EAIAogFWtBBHVrQQR0aiICIA42AgwgAiAINgIIIAIgDjYCBCACIBk2AgAgCUEBayIJDQALCyAUKAIECyECIAwgCzYCDCAMIAM2AgggDCACNgIEIAwgEjYCACARQSBqJAAMAQsgCCANQfD0xAAoAgAiAEHKBCAAGxEAAAALIAQgLjcDiAogBCAtNwOACiAHQcABaikDACEsIAdByAFqKQMAIS0gBEGQBmohBkEAIQojAEEgayINJAACfyAHQdABaiIIKAIAIgJFBEBBgIDAACEDQQAMAQsgAkEBaiIDQf///z9xIANHDQEgA0EFdCIDIAJBCWoiCmoiBSADSQ0BAkACQCAFQQBOBEAgBQ0BQQghCQwCCwwDCyAFQQgQ8AkiCUUNBgsgAyAJaiIDIAhBDGooAgAiBSAKEOAKIAJBf3NBBXQiCmogBSAKaiACQQV0QSBqEOAKGiAIKAIEIQogCCgCCAshBSAGIAM2AgwgBiAFNgIIIAYgCjYCBCAGIAI2AgAgDUEgaiQAIAQgLTcDiAYgBCAsNwOABiAHQawDaigCACEFAkACQCAHQbADaigCACIZRQRAQQEhCkEAIQIMAQsgGUH///8fSw0DIBlBBXQiAkEASA0DIBlBgICAIEkhAyACBH8gAiADEPAJBSADCyIKRQ0NCyAKIAUgAhDgCiEiIARB8ARqIiNB4ABqIRZBACEKIwBBsAJrIgskAAJAAkACQAJAAn8gB0H4AmoiHCgCACIXRQRAQYCAwAAhFEEADAELIBdBAWqtQvQAfiIsQiCIpw0GICynQQdqQXhxIgIgF0EJaiIDaiIFIAJJDQYCQAJAIAVBAE4EQCAFDQFBCCEKDAILDAgLIAVBCBDwCSIKRQ0LCyACIApqIhQgHCgCDCINIAMQ4AohAiAcKAIIIgoEQCACQfQAayEkIA1BCGohCSANKQMAQn+FQoCBgoSIkKDAgH+DISwgC0GYAWoiAkEQaiESIAJBxABqIRogC0HIAGoiAkEQaiERIAJBLGohJSAKIQggDSEFA0AgLFAEQCAJIQIDQCAFQaAHayEFIAIpAwAgAkEIaiIJIQJCf4VCgIGChIiQoMCAf4MiLFANAAsLQQAhEyANIAUgLHqnQQN2QYx/bGoiAmtBjH9tISYgAkH0AGsiDigCACEnIA5BBGooAgAhKCAOQRRqIhAoAgAEQCAlIA5BNGoQjAIgDkHEAGooAgAhE0EAIRUCQCAOQcgAaigCACIMRQRAQQQhAkEAIQYMAQsgDEH/////AUsNCyAMQQJ0IgZBAEgNCyAMQYCAgIACSUECdCEDIAYEfyAGIAMQ8AkFIAMLIgJFDQULIAsgAjYChAEgCyAMNgKAASACIBMgBhDgChogCyAMNgKIAUGAgMAAIQZBACECQYCAwAAhEyAOKAIIIgMEQCADQQFqIgJB/////wBxIAJHDQogAkEEdCITIANBCWoiFWohDCAMIBNJDQoCQAJAIAxBAE4EQCAMDQFBCCECDAILDAwLIAxBCBDwCSICRQ0ICyACIBNqIhMgECgCACICIBUQ4AogA0F/c0EEdCIMaiACIAxqIANBBHRBEGoQ4AoaIA4oAgwhFSAOKAIQIQILIA5BLGooAgAhKSAOQShqKAIAISoCfyAOQRhqKAIAIgxFBEBBACEYQQAMAQsgDEEBaiIGQf////8BcSAGRw0KIAxBCWoiKyAGQQN0IhhqIRAgECAYSQ0KAkACQCAQQQBOBEAgEA0BQQghBgwCCwwMCyAQQQgQ8AkiBkUNBwsgBiAYaiIGIA5BJGooAgAiECArEOAKIAxBf3NBA3QiGGogECAYaiAMQQN0QQhqEOAKGiAOKAIcIRggDigCIAshECALQagCaiACNgIAIAsgBjYCZCALIBA2AmAgCyAYNgJcIAsgDDYCWCALQegBaiICQQhqIBFBCGopAgA3AwAgCyApNgJsIAsgKjYCaCACQRBqIBFBEGopAgA3AwAgCyAOQTBqKAIANgJwIAJBGGogEUEYaikCADcDACACQSBqIBFBIGopAgA3AwAgAkEoaiARQShqKQIANwMAIAJBMGogEUEwaigCADYCACALIBU2AkwgCyADNgJIIAsgCykDSDcDoAIgCyARKQIANwPoAQsgLEIBfSAsgyEsIwBB0ABrIhAkAAJAAkACQAJAIA5BzABqIgJBCGooAgAiA0UEQCAaQoCAgICAATcCAAwBCyADQZmz5gxLDQEgA0HQAGwiDEEASA0BIAJBBGooAgAhFSADQZqz5gxJQQN0IQYgDAR/IAwgBhDwCQUgBgsiAkUNAiAaIAI2AgQgGiADNgIAIANB0ABsIQwgAyEGA0AgDEUNASAGRQ0PIBAgFRDWASAMQdAAayEMIAIgEEHQABDgCkHQAGohAiAVQdAAaiEVIAZBAWsiBg0ACwsgGiADNgIIIBBB0ABqJAAMAgsQxwgACyAMIAZB8PTEACgCACIAQcoEIAAbEQAAAAsgC0GYAWoiA0EIaiALQagCaigCADYCACASIAspA+gBNwIAIBJBCGogC0HoAWoiAkEIaikDADcCACASQRBqIAJBEGopAwA3AgAgEkEYaiACQRhqKQMANwIAIBJBIGogAkEgaikDADcCACASQShqIAJBKGopAwA3AgAgEkEwaiACQTBqKAIANgIAIAsgEzYCpAEgCyALKQOgAjcDmAEgDkHYAGooAgAhBiAOQdwAaikCACEtIA5B5ABqKAIAIQwgDkHoAGopAgAhLiAOQfAAai0AACEOIAtByABqIhMgA0HQABDgChogJCAmQfQAbGoiAiAoNgIEIAIgJzYCACACQQhqIBNB0AAQ4AoaIAIgDjoAcCACIC43AmggAiAMNgJkIAIgLTcCXCACIAY2AlggCEEBayIIDQALCyAcKAIECyECIBYgFDYCDCAWIAo2AgggFiACNgIEIBYgFzYCACALQbACaiQADAMLIAYgA0Hw9MQAKAIAIgBBygQgABsRAAAACyAQQQhB8PTEACgCACIAQcoEIAAbEQAAAAsgDEEIQfD0xAAoAgAiAEHKBCAAGxEAAAALIAdBiANqKAIAIRogBEH4A2oiEkEgaiIcIAdBuAJqEIUEIAdBmAJqKQMAIS0gB0GgAmopAwAhLiASQRBqIQ5BACEFQQAhDEEAIRAjAEEgayIXJAACQAJAAn8gB0GoAmoiESgCACIVRQRAQYCAwAAhFkEADAELIBVBAWqtQhh+IixCIIinDQQgLKciAiAVQQlqIgNqIgUgAkkNBAJAAkAgBUEATgRAIAUNAUEIIQoMAgsMBgsgBUEIEPAJIgpFDQkLIAIgCmoiFiARKAIMIgkgAxDgCiECIBEoAggiBQRAIAJBGGshGCAJQQhqIQYgCSkDAEJ/hUKAgYKEiJCgwIB/gyEsIAUhCiAJIQMDQCAsUARAA0AgA0HAAWshAyAGKQMAIAZBCGohBkJ/hUKAgYKEiJCgwIB/gyIsUA0ACwsgCSADICx6p0EDdkFobGoiAmtBaG0hCwJ/IAJBGGsiDS8BAEUEQCANQRBqKAIAIQwgDUEMaigCACECIA1BCGooAgAhFCANLwECIRBBACETIA1BBGooAgAMAQsgDUEIaigCACEIQQEhE0EBIRQgDUEMaigCACICBEAgAkEASA0JIAJBARDwCSIURQ0FCyAUIAggAhDgChogAgshCCAsQgF9ICyDISwgGCALQRhsaiILIA0oAhQ2AhQgCyAMNgIQIAsgAjYCDCALIBQ2AgggCyAINgIEIAsgEDsBAiALIBM7AQAgCkEBayIKDQALCyARKAIECyECIA4gFjYCDCAOIAU2AgggDiACNgIEIA4gFTYCACAXQSBqJAAMAQsgAkEBQfD0xAAoAgAiAEHKBCAAGxEAAAALIBJBCGoiEyAuNwMAIAQgLTcD+AMgBEHwBmoiFEEgaiIMIQgjAEEQayINJAACQAJAAkAgB0HoAmoiAkEIaigCACIFRQRAIAhCgICAgMAANwIADAELIAVBqtWq1QBLDQUgBUEMbCIKQQBIDQUgAkEEaigCACEGIAVBq9Wq1QBJQQJ0IQMgCgR/IAogAxDwCQUgAwsiAkUNByAIIAI2AgQgCCAFNgIAIAVBDGwhCSAFIQMDQCAJRQ0BIANFDQIgDSAGEMoHIAJBCGogDUEIaigCADYCACACIA0pAwA3AgAgCUEMayEJIAJBDGohAiAGQQxqIQYgA0EBayIDDQALCyAIIAU2AgggDUEQaiQADAELIAUgBUHwvsAAEJwHAAsgB0HIAmopAwAhLSAHQdACaikDACEuIBRBEGohCUEAIQMjAEEwayIIJAACQAJ/IAdB2AJqIg0oAgAiEUUEQEGAgMAAIQtBAAwBCyARQQFqIgJB/////wBxIAJHDQMgAkEEdCIFIBFBCWoiBmohAyADIAVJDQMCQAJAIANBAE4EQCADDQFBCCECDAILDAULIANBCBDwCSICRQ0NCyACIAVqIgsgDSgCDCIKIAYQ4AohAiANKAIIIgMEQCACQRBrIRUgCkEIaiEGIAopAwBCf4VCgIGChIiQoMCAf4MhLCADIQIgCiEFA0AgLFAEQANAIAVBgAFrIQUgBikDACAGQQhqIQZCf4VCgIGChIiQoMCAf4MiLFANAAsLIAhBIGoiECAFICx6p0EBdEHwAXFrIhZBEGsiFxDKByAXKAIMIRcgFSAWIApraiIWIAgpAyA3AgAgCCAXNgIsIBZBCGogEEEIaikDADcCACAsQgF9ICyDISwgAkEBayICDQALCyANKAIECyECIAkgCzYCDCAJIAM2AgggCSACNgIEIAkgETYCACAIQTBqJAAMAAsgBEGgCGogLjcDACAEQegHaiICQQhqIBMpAwA3AwAgAkEQaiAOKQMANwMAIAJBGGogEkEYaikDADcDACACQSBqIBwpAwA3AwAgAkEoaiASQShqKQMANwMAIARBqAhqIAkpAwA3AwAgBEGwCGogFEEYaikDADcDACAEQbgIaiAMKQMANwMAIARBwAhqIBRBKGopAwA3AwAgBCAtNwPwBiAEIC03A5gIIAQgBCkD+AM3A+gHIAQgGjYC4AUgIyACQeAAEOAKGgJ/AkACQCAHQbQDai8BACICQQNxQQNGDQACQCACQQFrDgIBAgALIAdBtgNqLwEAISAgB0HEA2ooAgAhISAHQcADaigCACECIAdBvANqKAIAIQxBACEGIAdBuANqKAIADAILIAdBvANqKAIAIQVBASEGQQEhDCAHQcADaigCACICBEAgAkEATiIDRQ0FIAIgAxDwCSIMRQ0PCyAMIAUgAhDgChogAgwBC0ECIQYgB0G4A2ooAgALIQkgBEHoBmoiEiAEQcgJaiIOKAIANgIAIARB2AZqIhEgBEHYCWoiCigCADYCACAEQegHaiIDQQhqIARB4AlqIgVBCGoiEykDADcDACADQRBqIAVBEGopAwA3AwAgA0EYaiAFQRhqKQMANwMAIAQgBCkDwAk3A+AGIAQgBCkD0Ak3A9AGIAQgBCkD4Ak3A+gHIAdByANqLQAAIRUgB0GQAmopAwAhLCAEQfAIaiAEQfgIaiIFQShqKQMANwMAIANBgAFqIAVBIGopAwA3AwAgA0H4AGogBUEYaikDADcDACADQfAAaiAFQRBqKQMANwMAIARB0AhqIAVBCGopAwA3AwAgA0EoaiAEQYAKaiIFQQhqIhQpAwA3AwAgA0EwaiAFQRBqKQMANwMAIANBOGogBUEYaikDADcDACAEIAQpA/gINwPICCAEIAQpA4AKNwOICCAEQcAIaiAEQYAGaiIFQRhqKQMANwMAIANB0ABqIAVBEGopAwA3AwAgA0HIAGogBUEIaikDADcDACAEIAQpA4AGNwOoCCAEQfAGaiAEQfAEakH4ABDgChpBAiEIIAdBLGotAAAiA0ECRwRAIARB+ANqIgUgB0EgahBrIAQgAzoAhAQgBCAHQS1qLQAAOgCFBCAEQfgEaiAFQQhqKQMANwMAIAQgBCkD+AM3A/AEIAdBOGopAwAhLSAHQUBrKQMAIS4gB0EwaikDACEvIAdByABqKAIAIRBBACEIIAdB0ABqKAIABH8gBEH4A2ogB0HMAGoQygcgBCgCgAQhHiAEKAL4AyEfIAQoAvwDBUEACyENIAdB3ABqKAIAIRYCQCAHQeAAaigCACILRQRAQQEhAwwBCyALQf///x9LDQQgC0EFdCIIQQBIDQQgC0GAgIAgSSEFIAgEfyAIIAUQ8AkFIAULIgNFDQ0LIARBrAVqIAM2AgAgBCALNgKoBSADIBYgCBDgChogBEGwBWogCzYCACAEQbQFaiAHQeQAahCrBSAEQZAFaiAuNwMAIARBmAVqIBA2AgAgBEGkBWogHjYCACAEQaAFaiANNgIAIARBnAVqIB82AgAgBEGIBWogLTcDACAEQegJaiAEQfgEaigCADYCACAEIC83A4AFIAQgBCkD8AQ3A+AJIAQtAPwEIQggBEH4CGogBEH9BGpBwwAQ4AoaCyAHQfwAai0AACEDIARB8ARqIgUgB0HwAGoQayAEIAM6APwEIAQgB0H9AGotAAA6AP0EIBQgBUEIaikDADcDACAEIAQpA/AENwOACiAFIARB6AdqQZABEOAKGiAEQfgDaiINIARB8AZqQfgAEOAKGiAOIBIoAgA2AgAgBEHwA2oiCyARKAIANgIAIAogEygCADYCACAEIAQpA+AGNwPACSAEIAQpA9AGNwPoAyAEIAQoAMkGNgLgAyAEIARBzAZqKAAANgDjAyAEIAQpA+AJNwPQCSAEQYAGaiISIARB+AhqQcMAEOAKGiAHQQhqKQMAIS0gBy0A0AMhESAHKQMAIS4gBEEIaiIDQRBqIAdBEGoQ+gMgA0EsaiAIOgAAIANBKGogCigCADYCACAEIC03AxAgBCAuNwMIIAQgBCkD0Ak3AyggBy0A0QMhCCAEQTVqIBJBwwAQ4AoaIANB+ABqIBQpAwA3AwAgA0HwAGogBCkDgAo3AwAgA0GAAWogBUGQARDgChogA0GQAmogLDcDACAEQaACaiANQfgAEOAKGiADQcgDaiAVOgAAIARBzANqICE2AgAgBEHIA2ogAjYCACAEQcQDaiAMNgIAIARBwANqIAk2AgAgBEG+A2ogIDsBACAEQbwDaiAGOwEAIARBuANqIBk2AgAgBEG0A2ogIjYCACAEQbADaiAZNgIAIARBoANqIA4oAgA2AgAgBEGYA2ogBCkDwAk3AwAgBEGkA2ogBCkD6AM3AgAgBEGsA2ogCygCADYCACAEQdQDaiAEKADjAzYAACAEQdEDaiAEKALgAzYAACAEIBE6ANgDIAQgCDoA2QMCQAJAIB0oAgQiCQRAQQEhAyAdKAIAAkAgHSgCCCICQQFxBEBBgIDEACEFDAELIARBgoDEADYC/AggBEECNgL0ByAEIAI2AvAHIAQgCTYC7AdBACEDIARBADYC6AcgBCAEQfgIajYC+AcgBEHwBmogBEHoB2oQrAMgBCgC/AgiBUGCgMQARgRAIAQoAvgGIQIgBCgC9AYhBSAEKALwBiEKDAELIAQoAvgIIQogBCgC8AYiAgRAIAQoAvQGENQBC0EBIQMLBEAgCRDUAQsgBEEoaiEJIAMNAQJAIAJFBEBBASEDDAELIAJBAE4iBkUNBiACIAYQ8AkiA0UNBAsgBCADNgL8AyAEIAI2AvgDIAMgBSACEOAKGiAEIAI2AoAEIARB8ARqIARB+ANqEOcFIAoEQCAFENQBCyAEQegHaiICQRBqIARB8ARqIgNBEGooAgA2AgAgAkEIaiADQQhqKQMANwMAIAQgBCkD8AQ3A+gHIAkgAhDpBAsgGyAEQQhqQdgDEOAKGgwBCyAbQQM7AbQDIBsgBTYCBCAbIAo2AgAgCRDLASAEKAIYIglFDQACQCAEQSBqKAIAIgVFBEAgBEEkaigCACEKDAELIARBJGooAgAiCkEIaiECIAopAwBCf4VCgIGChIiQoMCAf4MhLCAKIQMDQCAsUARAA0AgA0FAaiEDIAIpAwAgAkEIaiECQn+FQoCBgoSIkKDAgH+DIixQDQALCyAFQQFrIQUgLEIBfSEtIAMgLHqnQfgAcWtBBGsoAgAiBkGEAU8EQCAGEAELICwgLYMhLCAFDQALCyAJQQN0QQhqIgIgCWpBd0YNACAKIAJrENQBCyAEQaAKaiQADAYLIAIgBkHw9MQAKAIAIgBBygQgABsRAAAACxCHCAALEMcIAAsgAyADQfC+wAAQnAcACyAKIANB8PTEACgCACIAQcoEIAAbEQAAAAsgBUEIQfD0xAAoAgAiAEHKBCAAGxEAAAALIA8oAtgDIQIgDygC3AMhAyAdIBtBCGpBrAMQ4AoaIA9BCGogD0GWB2opAQA3AwAgD0EQaiAPQZ4HaikBADcDACAPQRhqIA9BpgdqKQEANwMAIA9BIGogD0GuB2ovAQA7AQAgDyAPKQGOBzcDACAPLwGMByEFIAFBADYCAAJ/IAVBA0cEQEHgA0EIEPAJIgFFDQQgASADNgIMIAEgAjYCCEEAIQogAUEANgIAIAFBEGogD0EoakGsAxDgChogASAFOwG8AyABIA8pAwA3Ab4DIAFBxgNqIA9BCGopAwA3AQAgAUHOA2ogD0EQaikDADcBACABQdYDaiAPQRhqKQMANwEAIAFB3gNqIA9BIGovAQA7AQBBAAwBC0EBIQogAiADEKUGCyECIAAgCjYCCCAAIAI2AgQgACABNgIAIA9BsAdqJAAPCxDVCgALENYKAAtB4ANBCEHw9MQAKAIAIgBBygQgABsRAAAACyADQQhB8PTEACgCACIAQcoEIAAbEQAAAAsgCCAFQfD0xAAoAgAiAEHKBCAAGxEAAAALIAIgA0Hw9MQAKAIAIgBBygQgABsRAAAAC4kDAgJ/AX4jAEHwAGsiAiQAIAIgATYCWCACQdgAahCACiEDIAIoAlghAQJAIANFBEAgAUGEAU8EQCABEAELIAAgATYCBCAAQQE2AgAgAEEIakGEgMQANgIADAELIAIgATYCBCACQShqIgEgAkEEahCeCSACQYWAxAA2AjwgAkHYAGoiA0EMaiABQQhqKAIANgIAIAJBADYCWCACIAIpAyg3AlwgAiACQThqNgJoIAJByABqIAMQswEgAigCPEGFgMQARwRAIAJBIGogAkFAaygCADYCACACIAIpAzg3AxggAigCSARAIAIoAkwQ1AELIAJBEGogAkEgaigCACIBNgIAIAIgAikDGCIENwMIIABBDGogATYCACAAIAQ3AgQgAEEBNgIAIAIoAgQiAEGEAUkNASAAEAEMAQsgAkEQaiACQdAAaigCACIBNgIAIAIgAikDSCIENwMIIABBDGogATYCACAAIAQ3AgQgAEEANgIAIAIoAgQiAEGEAUkNACAAEAELIAJB8ABqJAALpwMBC38gAkUEQCAAQoCAgIDAADcCACAAIAI2AggPCwJAAkAgAkHmzJkzSw0AIAJBFGwiBEEASA0AIAJB58yZM0lBAnQhBSAEBH8gBCAFEPAJBSAFCyIJBEAgACAJNgIEIAAgAjYCACACQRRsIQsgAiEFAkADQCAHIAtHBEAgBUUNAgJAIAEgB2oiAy8BAEUEQCADQQJqLwEAIQwgA0EQaigCACENIANBDGooAgAhBCADQQhqKAIAIQggA0EEaigCACEDQQAhCgwBCyADQQhqKAIAIQRBASEKQQEhCCADQQxqKAIAIgMEQCADQQBIDQYgA0EBEPAJIghFDQcLIAggBCADEOAKGiADIQQLIAcgCWoiBiAKOwEAIAZBEGogDTYCACAGQQxqIAQ2AgAgBkEIaiAINgIAIAZBBGogAzYCACAGQQJqIAw7AQAgB0EUaiEHIAVBAWsiBQ0BCwsgACACNgIIDwsgAiACQciXwQAQnAcACyAEIAVB8PTEACgCACIAQcoEIAAbEQAAAAsQxwgACyADQQFB8PTEACgCACIAQcoEIAAbEQAAAAuUAwEIfyMAQRBrIgMkAAJAAkACQAJAAkAgASgCBCIFIAEoAggiAk0NAEEAIAVrIQQgAkEEaiECIAEoAgAhBgNAAkAgAiAGaiIHQQRrLQAAIghBCWsiCUEXSw0AQQEgCXRBk4CABHFFDQAgASACQQNrNgIIIAQgAkEBaiICakEERw0BDAILCyAIQe4ARw0AIAEgAkEDayIENgIIIAQgBUkNAQwCCyADIAEQ7gQgAygCBARAIAAgAykDADcCBCAAQQxqIANBCGooAgA2AgAgAEEANgIADAQLIAAgAygCADYCBCAAQQE2AgAMAwsgASACQQJrIgY2AggCQAJAIAdBA2stAABB9QBHDQAgBCAFIAQgBUsbIgUgBkYNAiABIAJBAWsiBDYCCCAHQQJrLQAAQewARw0AIAQgBUYNAiABIAI2AgggB0EBay0AAEHsAEYNAQsgA0EJNgIADAILIABBADYCACAAQQhqQQA2AgAMAgsgA0EFNgIACyABIAMQ/QchASAAQQE2AgAgACABNgIECyADQRBqJAALxhYCDH8GfiMAQeAAayIJJAACQCABBEAgASgCAA0BIAFBfzYCACAJQShqIQYjAEHAAWsiBSQAIAUgBCIINgIMIAVBgAFqIAFBCGoiByACEIABAkACQAJAAkACQCAFKAKAASIEQQNGBEAgBUEwaiIEQSRqIAVBqAFqKQMANwIAIARBHGogBUGAAWoiAkEgaikDACIRNwIAIAVBxABqIAJBGGopAwAiEjcCACAEQQxqIAJBEGoiCCkDACITNwIAIAUgBSkDiAEiFDcCNCAFQRBqIgRBGGogETcDACAEQRBqIBI3AwAgBEEIaiATNwMAIAUgFDcDECACIAVBDGpB6IXAABDOASAFKAKAASIEQQdGDQEgBiAFKQKUATcCFCAGQRxqIAVBgAFqIgJBHGopAgA3AgAgBkEkaiACQSRqKQIANwIAIAZBLGogAkEsaikCADcCACAGQTRqIAJBNGooAgA2AgAgBSkChAEhESAGIAUpAowBNwIMIAYgETcCBCAGIAQ2AgAMAgsgBUHYAGogBUGAAWoiAkEsaigCACIHNgIAIAVB0ABqIAJBJGopAgAiETcDACAFQcgAaiACQRxqKQIAIhI3AwAgBUFAayACQRRqKQIAIhM3AwAgBUE4aiACQQxqKQIAIhQ3AwAgBSAFKQKEASIVNwMwIAUpA7ABIRYgBkEsaiAHNgIAIAZBJGogETcCACAGQRxqIBI3AgAgBkEUaiATNwIAIAZBDGogFDcCACAGIBU3AgQgBiAWNwMwIAYgBDYCAAwCCyAIKAIAIQggBUGAAWoiAkEMaigCACEEIAJBCGooAgAhCiAFKAKEASELIAdBIGoiAhCYAwJAAkACQAJAIAdBLGotAABBAkcEQCAFQYABaiAHQTBqIg4gB0GAAWoiDyACIAVBEGpBfwJ/IANEAAAAAAAAAABmIgwgA0QAAAAAAADwQWNxBEAgA6sMAQtBAAtBACAMGyADRAAA4P///+9BZBtBg4AIIAtBA3RB+P//B3F2EJcEAkAgBQJ/AkACQAJAIAUtAIABIg1BE0YEQCAFQegAaiAFQYABaiINQRBqKQMANwMAIAVB4ABqIgxBEGogDUEYaikDADcDACAMQRhqIAVBoAFqKQMANwMAIAUgBSkDiAE3A2AgCw0BIARFDQEgBy0A0QMNBSALQQFrDgIDAwILIAVBzwBqIgcgBUGgAWopAAA3AAAgBUHIAGoiDCAFQYABaiICQRlqKQAANwMAIAVBQGsgAkERaikAACIRNwMAIAVBOGogAkEJaikAACISNwMAIAUgBSkAgQEiEzcDMCAGQShqIAcpAAA3AAAgBkEhaiAMKQMANwAAIAZBGWogETcAACAGQRFqIBI3AAAgBkEJaiATNwAAIAYgDToACCAGQQQ2AgAMCQsgBQJ/AkACQCALQQFrDgIBAQALIAVBPGpBADYCACAFQThqIAQ2AgAgBSAEIAhqNgI0QQEMAQsgBUE4aiAENgIAIAUgBCAIQQR0ajYCNEEACzYCMCAFQYABaiAHIAVB4ABqIAVBMGoQciAFKAKAASIHQQdGDQYgBiAFKQKEATcCBCAGQTRqIAVBgAFqIgJBNGooAgA2AgAgBkEsaiACQSxqKQIANwIAIAZBJGogAkEkaikCADcCACAGQRxqIAJBHGopAgA3AgAgBkEUaiACQRRqKQIANwIAIAZBDGogAkEMaikCADcCAAwHCyAFQTxqQQA2AgAgBUE4aiAENgIAIAUgBCAIajYCNEEBDAELIAVBOGogBDYCACAFIAQgCEEEdGo2AjRBAAs2AjAgBUGAAWogByAFQeAAaiAFQTBqEHIgBSgCgAEiB0EHRg0DIAYgBSkChAE3AgQgBkE0aiAFQYABaiICQTRqKAIANgIAIAZBLGogAkEsaikCADcCACAGQSRqIAJBJGopAgA3AgAgBkEcaiACQRxqKQIANwIAIAZBFGogAkEUaikCADcCACAGQQxqIAJBDGopAgA3AgAMBAsgAhCYAyAHLQAsQQJGDQEgBUGAAWogDiAPIAIgBUHgAGpBAEEAIAQgCBDLBCAFLQCAASIHQRNGDQIgBkEJaiAFKQCBATcAACAGQShqIAVBoAFqKQAANwAAIAZBIWogBUGAAWoiAkEZaikAADcAACAGQRlqIAJBEWopAAA3AAAgBkERaiACQQlqKQAANwAAIAYgBzoACEEEIQcMAwtBjMTAAEErQaTFwAAQnggAC0GMxMAAQStBlMXAABCeCAALIAVBADYCOCAFQoCAgIAQNwMwIAVBgAFqIgJBAzoAICACQoCAgICABDcCGCACQQA2AhAgAkEANgIIIAJBvIHAADYCBCACIAVBMGo2AgAgBUHgAGogAhCnBkUEQCAGIAUpAzA3AgQgBkEMaiAFQThqKAIANgIAIAZBBzYCAAJAIAUvAWwiAkEDcUEDR0EAIAJBAWsbDQAgBUHwAGooAgBFDQAgBUH0AGooAgAQ1AELAkACQAJAAkAgCw4CAQIACyAIBEAgCEEEdCEIIAQhAgNAAkAgAkEEaigCACIHRQ0AIAIoAgBFDQAgBxDUAQsgAkEMaigCACIHQYQBTwRAIAcQAQsgAkEQaiECIAhBEGsiCA0ACwsgCkUNAiAEENQBDAILIApFDQEgBBDUAQwBCyAIBEAgCEEEdCEIIAQhAgNAAkAgAkEEaigCACIHRQ0AIAIoAgBFDQAgBxDUAQsgAkEMaigCACIHQYQBTwRAIAcQAQsgAkEQaiECIAhBEGsiCA0ACwsgCkUNACAEENQBCwJAIAUvARwiAkEDcUEDR0EAIAJBAWsbDQAgBUEgaigCAEUNACAFQSRqKAIAENQBCyAFKAIMIghBgwFLDQUMBgtB1IHAAEE3IAVBuAFqQYyCwABB6ILAABCHBwALIAYgBzYCACAFLwFsIgJBA3FBA0dBACACQQFrGw0AIAVB8ABqKAIARQ0AIAVB9ABqKAIAENQBCwJAAkACQCALDgIBAgALIAgEQCAIQQR0IQggBCECA0ACQCACQQRqKAIAIgdFDQAgAigCAEUNACAHENQBCyACQQxqKAIAIgdBhAFPBEAgBxABCyACQRBqIQIgCEEQayIIDQALCyAKRQ0CIAQQ1AEMAgsgCkUNASAEENQBDAELIAgEQCAIQQR0IQggBCECA0ACQCACQQRqKAIAIgdFDQAgAigCAEUNACAHENQBCyACQQxqKAIAIgdBhAFPBEAgBxABCyACQRBqIQIgCEEQayIIDQALCyAKRQ0AIAQQ1AELAkAgBS8BHCICQQNxQQNHQQAgAkEBaxsNACAFQSBqKAIARQ0AIAVBJGooAgAQ1AELIAUoAgwhCAsgCEGDAU0NAQsgCBABCyAFQcABaiQAIAlBCGoiByAGQRhqIgopAwA3AwAgCUEQaiILIAZBIGoiBikDADcDACAJQRhqIg0gCUHQAGoiDCkDADcDACAJQSBqIg4gCUHYAGoiDykDADcDACAJIAkpAzg3AwAgCSgCNCECIAkoAjAhBCAJKAIsIQUgCSgCKCEIIAFBADYCAAJ/IAhBB0YEQCAERQRAQQAhAkEAIQRBAAwCCyAJIAQ2AiwgCSAFNgIoIAkgAjYCMCACIAVJBEAgCUEoaiACEK0GIAkoAiwhBCAJKAIwIQILQQAMAQsgCiAHKQMANwMAIAYgCykDADcDACAMIA0pAwA3AwAgDyAOKQMANwMAIAkgAjYCNCAJIAQ2AjAgCSAFNgIsIAkgCDYCKCAJIAkpAwA3AzhBASEQIAlBKGoQ3gYLIQEgACAQNgIMIAAgATYCCCAAIAI2AgQgACAENgIAIAlB4ABqJAAPCxDVCgALENYKAAuYFgIMfwZ+IwBB4ABrIggkAAJAIAEEQCABKAIADQEgAUF/NgIAIAhBKGohBiMAQcABayIEJAAgBCADIgc2AgwgBEGAAWogAUEIaiIFIAIQgAECQAJAAkACQAJAIAQoAoABIgNBA0YEQCAEQTBqIgNBJGogBEGoAWopAwA3AgAgA0EcaiAEQYABaiICQSBqKQMAIhA3AgAgBEHEAGogAkEYaikDACIRNwIAIANBDGogAkEQaiIHKQMAIhI3AgAgBCAEKQOIASITNwI0IARBEGoiA0EYaiAQNwMAIANBEGogETcDACADQQhqIBI3AwAgBCATNwMQIAIgBEEMakHohcAAEM4BIAQoAoABIgNBB0YNASAGIAQpApQBNwIUIAZBHGogBEGAAWoiAkEcaikCADcCACAGQSRqIAJBJGopAgA3AgAgBkEsaiACQSxqKQIANwIAIAZBNGogAkE0aigCADYCACAEKQKEASEQIAYgBCkCjAE3AgwgBiAQNwIEIAYgAzYCAAwCCyAEQdgAaiAEQYABaiICQSxqKAIAIgU2AgAgBEHQAGogAkEkaikCACIQNwMAIARByABqIAJBHGopAgAiETcDACAEQUBrIAJBFGopAgAiEjcDACAEQThqIAJBDGopAgAiEzcDACAEIAQpAoQBIhQ3AzAgBCkDsAEhFSAGQSxqIAU2AgAgBkEkaiAQNwIAIAZBHGogETcCACAGQRRqIBI3AgAgBkEMaiATNwIAIAYgFDcCBCAGIBU3AzAgBiADNgIADAILIAcoAgAhAiAEQYABaiIHQQxqKAIAIQMgB0EIaigCACEKIAQoAoQBIQcgBUGAAWoiDCAEQRBqEIADIQsgBUEgaiIJEJgDAkACQAJAAkAgBUEsai0AAEECRwRAIARBgAFqIAVBMGoiDSAMIAkgBEEQaiALQYOACCAHQQN0Qfj//wdxdhCXBAJAIAQCfwJAAkACQCAELQCAASILQRNGBEAgBEHoAGogBEGAAWoiC0EQaikDADcDACAEQeAAaiIOQRBqIAtBGGopAwA3AwAgDkEYaiAEQaABaikDADcDACAEIAQpA4gBNwNgIAcNASADRQ0BIAUtANEDDQUgB0EBaw4CAwMCCyAEQc8AaiIJIARBoAFqKQAANwAAIARByABqIgwgBEGAAWoiBUEZaikAADcDACAEQUBrIAVBEWopAAAiEDcDACAEQThqIAVBCWopAAAiETcDACAEIAQpAIEBIhI3AzAgBkEoaiAJKQAANwAAIAZBIWogDCkDADcAACAGQRlqIBA3AAAgBkERaiARNwAAIAZBCWogEjcAACAGIAs6AAggBkEENgIADAkLIAQCfwJAAkAgB0EBaw4CAQEACyAEQTxqQQA2AgAgBEE4aiADNgIAIAQgAiADajYCNEEBDAELIARBOGogAzYCACAEIAMgAkEEdGo2AjRBAAs2AjAgBEGAAWogBSAEQeAAaiAEQTBqEHIgBCgCgAEiCUEHRg0GIAYgBCkChAE3AgQgBkE0aiAEQYABaiIFQTRqKAIANgIAIAZBLGogBUEsaikCADcCACAGQSRqIAVBJGopAgA3AgAgBkEcaiAFQRxqKQIANwIAIAZBFGogBUEUaikCADcCACAGQQxqIAVBDGopAgA3AgAMBwsgBEE8akEANgIAIARBOGogAzYCACAEIAIgA2o2AjRBAQwBCyAEQThqIAM2AgAgBCADIAJBBHRqNgI0QQALNgIwIARBgAFqIAUgBEHgAGogBEEwahByIAQoAoABIglBB0YNAyAGIAQpAoQBNwIEIAZBNGogBEGAAWoiBUE0aigCADYCACAGQSxqIAVBLGopAgA3AgAgBkEkaiAFQSRqKQIANwIAIAZBHGogBUEcaikCADcCACAGQRRqIAVBFGopAgA3AgAgBkEMaiAFQQxqKQIANwIADAQLIAkQmAMgBS0ALEECRg0BIARBgAFqIA0gDCAJIARB4ABqQQBBACADIAIQywQgBC0AgAEiCUETRg0CIAZBCWogBCkAgQE3AAAgBkEoaiAEQaABaikAADcAACAGQSFqIARBgAFqIgVBGWopAAA3AAAgBkEZaiAFQRFqKQAANwAAIAZBEWogBUEJaikAADcAACAGIAk6AAhBBCEJDAMLQYzEwABBK0GkxcAAEJ4IAAtBjMTAAEErQZTFwAAQnggACyAEQQA2AjggBEKAgICAEDcDMCAEQYABaiIFQQM6ACAgBUKAgICAgAQ3AhggBUEANgIQIAVBADYCCCAFQbyBwAA2AgQgBSAEQTBqNgIAIARB4ABqIAUQpwZFBEAgBiAEKQMwNwIEIAZBDGogBEE4aigCADYCACAGQQc2AgACQCAELwFsIgVBA3FBA0dBACAFQQFrGw0AIARB8ABqKAIARQ0AIARB9ABqKAIAENQBCwJAAkACQAJAIAcOAgECAAsgAgRAIAJBBHQhByADIQIDQAJAIAJBBGooAgAiBUUNACACKAIARQ0AIAUQ1AELIAJBDGooAgAiBUGEAU8EQCAFEAELIAJBEGohAiAHQRBrIgcNAAsLIApFDQIgAxDUAQwCCyAKRQ0BIAMQ1AEMAQsgAgRAIAJBBHQhByADIQIDQAJAIAJBBGooAgAiBUUNACACKAIARQ0AIAUQ1AELIAJBDGooAgAiBUGEAU8EQCAFEAELIAJBEGohAiAHQRBrIgcNAAsLIApFDQAgAxDUAQsCQCAELwEcIgJBA3FBA0dBACACQQFrGw0AIARBIGooAgBFDQAgBEEkaigCABDUAQsgBCgCDCIHQYMBSw0FDAYLQdSBwABBNyAEQbgBakGMgsAAQeiCwAAQhwcACyAGIAk2AgAgBC8BbCIFQQNxQQNHQQAgBUEBaxsNACAEQfAAaigCAEUNACAEQfQAaigCABDUAQsCQAJAAkAgBw4CAQIACyACBEAgAkEEdCEHIAMhAgNAAkAgAkEEaigCACIFRQ0AIAIoAgBFDQAgBRDUAQsgAkEMaigCACIFQYQBTwRAIAUQAQsgAkEQaiECIAdBEGsiBw0ACwsgCkUNAiADENQBDAILIApFDQEgAxDUAQwBCyACBEAgAkEEdCEHIAMhAgNAAkAgAkEEaigCACIFRQ0AIAIoAgBFDQAgBRDUAQsgAkEMaigCACIFQYQBTwRAIAUQAQsgAkEQaiECIAdBEGsiBw0ACwsgCkUNACADENQBCwJAIAQvARwiAkEDcUEDR0EAIAJBAWsbDQAgBEEgaigCAEUNACAEQSRqKAIAENQBCyAEKAIMIQcLIAdBgwFNDQELIAcQAQsgBEHAAWokACAIQQhqIgUgBkEYaiIKKQMANwMAIAhBEGoiCSAGQSBqIgYpAwA3AwAgCEEYaiIMIAhB0ABqIgspAwA3AwAgCEEgaiINIAhB2ABqIg4pAwA3AwAgCCAIKQM4NwMAIAgoAjQhAiAIKAIwIQMgCCgCLCEEIAgoAighByABQQA2AgACfyAHQQdGBEAgA0UEQEEAIQJBACEDQQAMAgsgCCADNgIsIAggBDYCKCAIIAI2AjAgAiAESQRAIAhBKGogAhCtBiAIKAIsIQMgCCgCMCECC0EADAELIAogBSkDADcDACAGIAkpAwA3AwAgCyAMKQMANwMAIA4gDSkDADcDACAIIAI2AjQgCCADNgIwIAggBDYCLCAIIAc2AiggCCAIKQMANwM4QQEhDyAIQShqEN4GCyEBIAAgDzYCDCAAIAE2AgggACACNgIEIAAgAzYCACAIQeAAaiQADwsQ1QoACxDWCgALlQMBBH8jAEHgAGsiAiQAAkACQCABQRBqKAIABEAgAkEIaiABQQhqEMEIIAIoAggNAQsgAEEAOgAAIABBIWpBAjoAAAwBCyACIAIoAgwQiwggAigCBCEDIAIoAgAhBCABIAEoAhRBAWo2AhQgAkEwaiAEEKIDIAItADBFBEAgAkEoaiACQckAaikAADcDACACQSBqIAJBwQBqKQAANwMAIAJBGGogAkE5aikAADcDACACIAIpADE3AxAgAiADIgE2AjBBACEEAn8CQAJAAkAgARAKDgIBAAILQQEhBAtBAQwBCyACQTBqIAJB2ABqQdzHwAAQuAMhBSACKAIwIQFBAAsgAUGEAU8EQCABEAELRQRAIABBAToAACAAIAU2AgQMAgsgACACKQMQNwABIABBADoAACAAQSFqIAQ6AAAgAEEZaiACQShqKQMANwAAIABBEWogAkEgaikDADcAACAAQQlqIAJBGGopAwA3AAAMAQsgACACKAI0NgIEIABBAToAACADQYQBSQ0AIAMQAQsgAkHgAGokAAv9AwEEfyMAQdAAayIEJAACQAJAAkBBDEEEEPAJIgUEQAJAIAJFBEBBASEGDAELIAJBAE4iB0UNAiACIAcQ8AkiBkUNAwsgBiABIAIQ4AohASAFIAI2AgggBSABNgIEIAUgAjYCACAEQQA2AgggBEKAgICAEDcDACAEQRBqIgFBAzoAICABQoCAgICABDcCGCABQQA2AhAgAUEANgIIIAFB4PjBADYCBCABIAQ2AgACQAJAAkACQEECIAMtAAAiAUEGayABQQVNG0H/AXFBAWsOAgIAAQsgAyAEQRBqEMEDDQYMAgsgBEHEAGpBATYCACAEQcwAakEANgIAIARB+PHBADYCQCAEQYTnwQA2AkggBEEANgI4IARBEGogBEE4ahDkB0UNAQwFCyAEQcQAakEBNgIAIARBzABqQQA2AgAgBEHU8cEANgJAIARBhOfBADYCSCAEQQA2AjggBEEQaiAEQThqEOQHDQQLIAAgBCkDADcCACAAQQhqIARBCGooAgA2AgAgAEEUakEBNgIAIABBEGogBTYCACAAQQE2AgwgAxDABiAEQdAAaiQADwtBDEEEQfD0xAAoAgAiAEHKBCAAGxEAAAALEMcIAAsgAiAHQfD0xAAoAgAiAEHKBCAAGxEAAAALQfj4wQBBNyAEQThqQbD5wQBBjPrBABCHBwALtQMBAX8jAEEwayICJAACfwJAAkACQAJAAkACQCAAKAIAQQFrDgUBAgMEBQALIAJBJGpBATYCACACQSxqQQA2AgAgAkGQ18EANgIgIAJBsMTBADYCKCACQQA2AhggASACQRhqEOQHDAULIAJBJGpBATYCACACQSxqQQA2AgAgAkHU1sEANgIgIAJBsMTBADYCKCACQQA2AhggASACQRhqEOQHDAQLIAJBJGpBATYCACACQSxqQQA2AgAgAkG41sEANgIgIAJBsMTBADYCKCACQQA2AhggASACQRhqEOQHDAMLIAJBJGpBATYCACACQSxqQQE2AgAgAkGg1sEANgIgIAJBADYCGCACQYECNgIMIAIgAEEEajYCFCACIAJBCGo2AiggAiACQRRqNgIIIAEgAkEYahDkBwwCCyACQSRqQQE2AgAgAkEsakEANgIAIAJB+NXBADYCICACQbDEwQA2AiggAkEANgIYIAEgAkEYahDkBwwBCyACQSRqQQE2AgAgAkEsakEANgIAIAJB4NXBADYCICACQbDEwQA2AiggAkEANgIYIAEgAkEYahDkBwsgAkEwaiQAC4cDAgh/BX4jAEEgayIFJAAgBSADNgIEIAUgAjYCACABIAUQwgMhDiABQRxqKAIAIgpBFGshCyAOQhmIQv8Ag0KBgoSIkKDAgAF+IRAgAUEQaiIMKAIAIQYgDqchAyAFKAIEIQcgBSgCACEIAkACQANAIAMgBnEiAyAKaikAACIPIBCFIg1CgYKEiJCgwIABfSANQn+Fg0KAgYKEiJCgwIB/gyENA0AgDVAEQCAPIA9CAYaDQoCBgoSIkKDAgH+DQgBSDQMgAyAJQQhqIglqIQMMAgsgDXohESANQgF9IA2DIQ0gCyARp0EDdiADaiAGcUFsbGoiAigCACAIRw0AIAJBBGooAgAgB0cNAAsLIAAgAikCCDcCACACIAQpAgA3AgggAEEIaiACQRBqIgAoAgA2AgAgACAEQQhqKAIANgIADAELIAVBGGogBEEIaigCADYCACAFIAc2AgwgBSAINgIIIAUgBCkCADcDECAMIA4gBUEIaiABEOYDIABBBDoACAsgBUEgaiQAC4cDAgh/BX4jAEEgayIFJAAgBSADNgIEIAUgAjYCACABIAUQwgMhDiABQRxqKAIAIgpBFGshCyAOQhmIQv8Ag0KBgoSIkKDAgAF+IRAgAUEQaiIMKAIAIQYgDqchAyAFKAIEIQcgBSgCACEIAkACQANAIAMgBnEiAyAKaikAACIPIBCFIg1CgYKEiJCgwIABfSANQn+Fg0KAgYKEiJCgwIB/gyENA0AgDVAEQCAPIA9CAYaDQoCBgoSIkKDAgH+DQgBSDQMgAyAJQQhqIglqIQMMAgsgDXohESANQgF9IA2DIQ0gCyARp0EDdiADaiAGcUFsbGoiAigCACAIRw0AIAJBBGooAgAgB0cNAAsLIAAgAikCCDcCACACIAQpAgA3AgggAEEIaiACQRBqIgAoAgA2AgAgACAEQQhqKAIANgIADAELIAVBGGogBEEIaigCADYCACAFIAc2AgwgBSAINgIIIAUgBCkCADcDECAMIA4gBUEIaiABEOYDIABBAjYCAAsgBUEgaiQAC8oDAQZ/QQEhAgJAIAEoAgAiBkEnIAEoAgQoAhAiBxEBAA0AQYKAxAAhAkEwIQECQAJ/AkACQAJAAkACQAJAAkAgACgCACIADigIAQEBAQEBAQECBAEBAwEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEFAAsgAEHcAEYNBAsgABCvBEUNBCAAQQFyZ0ECdkEHcwwFC0H0ACEBDAULQfIAIQEMBAtB7gAhAQwDCyAAIQEMAgtBgYDEACECIAAQ1AUEQCAAIQEMAgsgAEEBcmdBAnZBB3MLIQEgACECC0EFIQMDQCADIQQgAiEFQYGAxAAhAkHcACEAAkACQAJAAkACQEEDIAVBgIDEAGsgBUH//8MATRtBAWsOAwEEAAILQQAhA0H9ACEAIAUhAgJAAkACQCAEQf8BcUEBaw4FBgUAAQIEC0ECIQNB+wAhAAwFC0EDIQNB9QAhAAwEC0EEIQNB3AAhAAwDC0GAgMQAIQIgASIAQYCAxABHDQILIAZBJyAHEQEAIQIMAwsgBEEBIAEbIQMgAiABQQJ0dkEPcSIAQTBB1wAgAEEKSRtqIQAgAUEBa0EAIAEbIQELIAYgACAHEQEARQ0AC0EBDwsgAgupAwEDfyMAQbAHayIEJAACQAJAAkAgAw4CAgEAC0HNhcAAQRkQ1woAC0EBIQULIAQgAjYCMCAEIAE2AiwgBCACNgIoIARB2ANqIgMgBEEoaiIBIAUQ4gIgBCgC2AMhBiAEKALcAyEFIAEgA0EIakGsAxDgChogBEEIaiAEQZYHaikBADcDACAEQRBqIARBngdqKQEANwMAIARBGGogBEGmB2opAQA3AwAgBEEgaiAEQa4Hai8BADsBACAEIAQpAY4HNwMAAkAgAAJ/IAQvAYwHIgFBA0cEQEHgA0EIEPAJIgJFDQIgAiAFNgIMIAIgBjYCCCACQQA2AgAgAkEQaiAEQShqQawDEOAKGiACIAE7AbwDIAIgBCkDADcBvgMgAkHGA2ogBEEIaikDADcBACACQc4DaiAEQRBqKQMANwEAIAJB1gNqIARBGGopAwA3AQAgAkHeA2ogBEEgai8BADsBAEEAIQVBAAwBCyAGIAUQpQYhBUEBCzYCCCAAIAU2AgQgACACNgIAIARBsAdqJAAPC0HgA0EIQfD0xAAoAgAiAEHKBCAAGxEAAAALhAMCC38BfiMAQRBrIgIkACABKAIMIQggASgCACEJAkACQCABKAIIIgogASgCBCIDRgRAIABBADYCCCAAQoCAgIDAADcCACAJRQ0BIAgQ1AEMAQsgASgCECEBIAMpAwghDSADKAIAIQRBMEEEEPAJIgVFDQEgBSAENgIIIAUgATYCACAFQX8gASANp2oiBCABIARLGyIBNgIEIAJBATYCCCACIAU2AgQgAkEENgIAIAogA0EQaiIERwRAQRQhB0EBIQYDQEF/IAEgBCgCCGoiAyABIANLGyEDIAQoAgAhDCACKAIAIAZGBEAgAiAGQQEQ+QUgAigCBCEFCyAFIAdqIgsgDDYCACALQQRrIAM2AgAgC0EIayABNgIAIAIgBkEBaiIGNgIIIAdBDGohByADIQEgCiAEQRBqIgRHDQALCyAJBEAgCBDUAQsgACACKQMANwIAIABBCGogAkEIaigCADYCAAsgAkEQaiQADwtBMEEEQfD0xAAoAgAiAEHKBCAAGxEAAAAL2AIBB39BASEJAkACQCACRQ0AIAEgAkEBdGohCiAAQYD+A3FBCHYhCyAAQf8BcSENA0AgAUECaiEMIAcgAS0AASICaiEIIAsgAS0AACIBRwRAIAEgC0sNAiAIIQcgCiAMIgFGDQIMAQsCQAJAIAcgCE0EQCAEIAhJDQEgAyAHaiEBA0AgAkUNAyACQQFrIQIgAS0AACABQQFqIQEgDUcNAAtBACEJDAULIAcgCEGU2sQAEI4KAAsgCCAEQZTaxAAQjQoACyAIIQcgCiAMIgFHDQALCyAGRQ0AIAUgBmohAyAAQf//A3EhAQNAAkAgBUEBaiEAIAUtAAAiAsAiBEEATgR/IAAFIAAgA0YNASAFLQABIARB/wBxQQh0ciECIAVBAmoLIQUgASACayIBQQBIDQIgCUEBcyEJIAMgBUcNAQwCCwtB/cPEAEErQaTaxAAQnggACyAJQQFxC9ACAgF+Cn9CACABKAIIIgatfSECIABBJGooAgAhAyAAQRxqIQcDQCACp0H/AHEgAkJAfUL/AFYiCEEHdHIhCSACQgeHIQIgACADIAAoAhxHBH8gAwUgByADQQEQnAYgACgCJAsiBUEBaiIDNgIkIAUgACgCICIKaiAJOgAAIARBAWohBCAIDQALIAAgACgCGCAEajYCGCABKAIEIQUgASgCACAGBEAgBSAGQQN0aiEIIABBHGohCSAFIQEDQCABKQMAIQJBACEEA0AgAqdB/wBxIAJCQH1C/wBWIgtBB3RyIQwgAkIHhyECIAAgAyAAKAIcRwR/IAMFIAkgA0EBEJwGIAAoAiAhCiAAKAIkCyIGQQFqIgM2AiQgBiAKaiAMOgAAIARBAWohBCALDQALIAAgACgCGCAEajYCGCAIIAFBCGoiAUcNAAsLBEAgBRDUAQsL6wIBBX8gAEELdCEEQSEhA0EhIQICQANAAkACQEF/IANBAXYgAWoiA0ECdEGo58QAaigCAEELdCIFIARHIAQgBUsbIgVBAUYEQCADIQIMAQsgBUH/AXFB/wFHDQEgA0EBaiEBCyACIAFrIQMgASACSQ0BDAILCyADQQFqIQELAn8CQAJ/AkAgAUEgTQRAIAFBAnQiA0Go58QAaigCAEEVdiECIAFBIEcNAUHXBSEDQR8MAgsgAUEhQYTuxAAQnAcACyADQaznxABqKAIAQRV2IQMgAUUNASABQQFrC0ECdEGo58QAaigCAEH///8AcQwBC0EACyEBAkAgAyACQX9zakUNACAAIAFrIQVB1wUgAiACQdcFTRshBCADQQFrIQBBACEBA0ACQCACIARHBEAgBSABIAJBrOjEAGotAABqIgFPDQEMAwsgBEHXBUGE7sQAEJwHAAsgACACQQFqIgJHDQALIAAhAgsgAkEBcQvEBwIHfwJ+IwBBgAFrIgUkAAJAIAAEQCAAKAIADQEgAEF/NgIAIAUgAjYCWCAFIAE2AlQgBSACNgJQIAUgA0EAR603A0AgBEQAAAAAAADgw2YhASAFQv///////////wACfiAEmUQAAAAAAADgQ2MEQCAEsAwBC0KAgICAgICAgIB/C0KAgICAgICAgIB/IAEbIARE////////30NkG0IAIAQgBGEbNwNIIAVBEGohByAFQUBrIQMjAEHAAWsiASQAIABBKGoiAi0ADCEGIAEgAkENakHDABDgCiEBIAJBAjoADAJAIAZBAkYNACACKAIAIAJB0ABqIAIoAgQiBiACKAIIIgkQzwcgAUGoAWogAUE7aikAADcDACABQaABaiABQTNqKQAANwMAIAFBmAFqIAFBK2opAAA3AwAgAUGQAWogAUEjaikAADcDACABQYgBaiABQRtqKQAANwMAIAFBgAFqIAFBE2opAAA3AwAgAUHwAGoiCkEIaiABQQtqKQAANwMAIAEgASkAAzcDcCABQQA2ArQBIAFByABqIAogAkHgAGogAUGwAWpCAEIAEMYBIAYgCRCTAUUNACAGENQBCyABQfAAaiIGIAJB4ABqIggQrQEgAUEYaiAGQRhqKQMANwMAIAFBEGogBkEQaikDADcDACABQQhqIAZBCGopAwA3AwAgASABKQNwNwMAIAFByABqIgZBCGoiCSADQRhqIgsoAgA2AgAgASADKQIQNwNIIAMpAwAhDCADKQMIIQ0jAEHQAGsiAiQAIAJBPGpBADYCACACQSBqQQA2AgAgAkEwaiABQRxqKAIANgIAIAJCgICAgIABNwI0IAJCADcDCCACIAEpAhQ3AyggAiABKAIQNgIYIAIgASkDCDcDECACIAEpAwA3AwAgAkFAayIKQQhqIAkoAgA2AgAgAiAGKQIANwNAIAcgAiAIIAogDCANEGggAkHQAGokACABQcABaiQAIAsgB0EYaikDADcDACADQRBqIAdBEGopAwA3AwAgA0EIaiAHQQhqKQMANwMAIAUgBSkDEDcDQCAFQQhqIgFBIDYCBCABIAM2AgAgBSgCCCECIAUoAgwhAyAFQeAAaiIBQYCAxAA2AgwgAUGgr8AANgIIIAEgAjYCBCABIAIgA2o2AgAgBUHwAGoiAkEIaiABQQhqKQMANwMAIAUgBSkDYDcDcCAFQTBqIAIQ0wMgBSgCNCIBIAUoAjgQAiAFKAIw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KAIgITMCQCADQfwAaigCACITRQRAQQEhC0EAIQcMAQsgE0H///8fSw0DIBNBBXQiB0EASA0DIBNBgICAIEkhDyAHBH8gByAPEPAJBSAPCyILRQ0FCyALIBcgBxDgCiE0An8gAy8BjAFFBEAgA0GOAWovAQAhHCADQZwBaigCACEdIANBlAFqKAIAIQsgA0GQAWooAgAhB0EAIRcgA0GYAWooAgAMAQsgA0GUAWooAgAhBkEBIRdBASELIANBmAFqKAIAIgcEQCAHQQBIDQQgB0EBEPAJIgtFDQcLIAsgBiAHEOAKGiAHCyEGIA1B0ABqIANBgAFqEIUEIAMpA0ghUSADKQNgIVIgAykDQCFTQQAhJ0EAISggA0HsAGooAgAEQCANQRBqIANB6ABqEMoHIA0oAhAhHiANKAIUISggDSgCGCEYCyADQfABaigCAARAIANB/AFqKAIAIR8gA0H4AWooAgAhICADQfQBaigCACEhQQEhJyADQYACaigCACEZCyADQdwAaigCACE1IANB1ABqKAIAITYgA0HsAWooAgAhNyADQegBaigCACE4IANB5AFqKAIAITkgA0HgAWooAgAhOiADQdwBaigCACE7IANB2AFqKAIAITwgA0GsAWooAgAhPSADQagBaigCACE+IANBpAFqKAIAIT8gA0HUAWooAgAhQCADQdABaigCACFBIANBzAFqKAIAIUIgA0HIAWooAgAhQyADQcQBaigCACFEIANBwAFqKAIAIUUgA0G8AWooAgAhRiADQbgBaigCACFHIANBtAFqKAIAIUggA0GwAWooAgAhSSADKAJYIUogAygCUCFLIAMoAqABIUwgDUEQaiIPQRhqIk0gJikDADcDACAPQRBqIk4gJSkDADcDACAPQQhqIk8gFikDADcDACANQQhqIlAgDUHYAGoiKSgCADYCACANIA0pAzA3AxAgDSANKQNQNwMAQQIhDwJAAkACQEEBIAMoAowCIipBAmsgKkEBTRtBAWsOAgABAgsgA0GcAmooAgAhIiAqRQRAIANBkAJqKAIAIQ4gA0GUAmooAgAhEkEAIQ8MAgsgA0GUAmooAgAhDkEBIQ9BASESIANBmAJqKAIAIgwEQCAMQQBIDQUgDEEBEPAJIhJFDQ0LIBIgDiAMEOAKGiAMIQ4MAQtBBCEPCyAWIE8pAwAiVDcDACAl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aiINIARBGGopAwA3AwAgAkEQaiIOIARBEGopAwA3AwAgAkEIaiIPIARBCGopAwA3AwAgBUFAayICQQhqIAVB7gFqKQEANwMAIAJBEGogBUH2AWovAQA7AQAgBSAFKQO4ATcDiAEgBSAFKQHmATcDQCAFQdgAaiICQQhqIA8pAwA3AwAgAkEQaiAOKQMANwMAIAJBGGogDSkDADcDACACQSBqIAwpAwA3AwAgAkEoaiAJKAIANgIAIAUgBSkDiAE3A1ggCkUNAyADENQBDAMLIAUpArwBIREgBkEMaiAFQcQBaigCADYCACAGIBE3AgQgBkEENgIAIAwgB0VyDQogBEUNCiAHENQBDAoLIAZChoCAgJAQNwMAQQAhAgwKCyAFIAQ2AogCIAUgBzYChAIgBSAENgKAAiAFQbgBaiALQYABaiAFQSBqIAVBgAJqEK0CIAUvAeQBIgdBBEYNByAFQYgBaiICQShqIgkgBUG4AWoiBEEoaigCADYCACACQSBqIgwgBEEgaikDADcDACACQRhqIg0gBEEYaikDADcDACACQRBqIg4gBEEQaikDADcDACACQQhqIg8gBEEIaikDADcDACAFQUBrIgJBCGogBUHuAWopAQA3AwAgAkEQaiAFQfYBai8BADsBACAFIAUpA7gBNwOIASAFIAUpAeYBNwNAIAVB2ABqIgJBKGogCSgCADYCACACQSBqIAwpAwA3AwAgAkEYaiANKQMANwMAIAJBEGogDikDADcDACACQQhqIA8pAwA3AwAgBSAFKQOIATcDWAsgB0EDRg0CIAVBuAFqIgJBKGogBUHYAGoiBEEoaigCADYCACACQSBqIgkgBEEgaikDADcDACACQRhqIARBGGopAwA3AwAgAkEQaiAEQRBqKQMANwMAIAJBCGogBEEIaikDADcDACAFQe4BaiAFQUBrIgJBCGopAwA3AQAgBUH2AWogAkEQai8BADsBACAFIAUpA1g3A7gBIAUgBzsB5AEgBSAFKQNANwHmASAFLQC4AUELRw0DIAUQIjYC/AEjAEEwayICJAAgBUGIAWoiBEEANgIIIARCgICAgBA3AgAgAkEDOgAgIAJCgICAgIAENwIYIAJBADYCECACQQA2AgggAkG8gcAANgIEIAIgBDYCAAJAIAVBuAFqQQFyIAIQzgVFBEAgAkEwaiQADAELQdSBwABBNyACQShqQYyCwABB6ILAABCHBwALIAUgBBCGCTYCgAIgBUH8AWogBUGAAmoQgQogBSgCgAIiAkGEAU8EQCACEAELIAVBiAFqIgIgCRCrCCAFIAIQhgk2AoACIAVB/AFqIAVBgAJqEIEKIAUoAoACIgJBhAFPBEAgAhABCyAGIAUoAvwBNgIEIAZBBjYCAAwECyAFQYgBaiICQSBqIAVBuAFqIgRBIGopAwAiETcDACACQRhqIARBGGopAwAiEjcDACACQRBqIARBEGopAwAiEzcDACACQQhqIARBCGopAwAiFDcDACAFIAUpA7gBIhU3A4gBIAZBKGogETcDACAGQSBqIBI3AwAgBkEYaiATNwMAIAZBEGogFDcDACAGIBU3AwggBkEDNgIAIApFDQYgAxDUAQwGCyAFQbABaiAFQbgBaiICQSxqKAIAIgQ2AgAgBUGoAWogAkEkaikCACIRNwMAIAVBoAFqIAJBHGopAgAiEjcDACAFQZgBaiACQRRqKQIAIhM3AwAgBUGQAWogAkEMaikCACIUNwMAIAUgBSkCvAEiFTcDiAEgBSkD6AEhFiAGQSxqIAQ2AgAgBkEkaiARNwIAIAZBHGogEjcCACAGQRRqIBM3AgAgBkEMaiAUNwIAIAYgFTcCBCAGIBY3AzAgBiAHNgIAAkAgCUUNACAKQYQBSQ0AIAoQAQsgA0GEAUkNByADEAEMBwsgBkKGgICAkBA3AwAMAgsgBRAiNgL8ASAFQYgBaiIEIAVBuAFqIAstANEDELACIAUtAIkBIQcgBS0AiAEhCyAFIAUoAowBNgKAAiMAQRBrIgIkACACIAsgBxD5ASACKAIAIAIoAgQiCyACKAIIEAIhCQRAIAsQ1AELIAJBEGokACAFIAk2AogBIAVB/AFqIAQQgQogBSgCiAEiAkGEAU8EQCACEAELIAVB/AFqIAVBgAJqEIEKIAZBBjYCACAGIAUoAvwBNgIEIAUoAoACIgJBhAFJDQAgAhABCyAFQbgBahCIByAFLwHkASICQQNxQQNHQQAgAkEBaxsNACAFQegBaigCAEUNACAFQewBaigCABDUAQsgA0EARyECDAILIAVBiAFqIgJBIGogBUG4AWoiA0EgaikDACIRNwMAIAJBGGogA0EYaikDACISNwMAIAJBEGogA0EQaikDACITNwMAIAJBCGogA0EIaikDACIUNwMAIAUgBSkDuAEiFTcDiAEgBkEoaiARNwMAIAZBIGogEjcDACAGQRhqIBM3AwAgBkEQaiAUNwMAIAYgFTcDCCAGQQM2AgALIAUvASwiAkEDcUEDR0EAIAJBAWsbDQEgBUEwaigCAEUNASAFQTRqKAIAENQBDAELAkAgA0UNACACDQAgCkUNACADENQBCyAFLwEsIgJBA3FBA0dBACACQQFrGw0AIAVBMGooAgBFDQAgBUE0aigCABDUAQsgBUGQAmokACAIQQhqIgJBCGoiBCAGQRBqIgopAwA3AwAgAkEQaiIFIAZBGGoiBykDADcDACACQRhqIgsgBkEgaiIJKQMANwMAIAJBIGoiDCAGQShqIgYpAwA3AwAgAkEoaiINIAhB6ABqIg4pAwA3AwAgCCAIKQNANwMIIAgoAjwhAiAIKAI4IQMgASABKAIAQQFrNgIAIAAgA0EGRwR/IAogBCkDADcDACAHIAUpAwA3AwAgCSALKQMANwMAIAYgDCkDADcDACAOIA0pAwA3AwAgCCACNgI8IAggAzYCOCAIIAgpAwg3A0AgCEE4ahDcBiEQQQEFQQALNgIIIAAgEDYCBCAAIAI2AgAgCEHwAGokAA8LENUKAAsQ1goAC/MRAxB/Bn4BfCMAQfAAayIJJAACQCABBEAgASgCACIGQX9GDQEgASAGQQFqNgIAIAlBOGohByADIQYgBEEARyERQQAhAyMAQaACayIFJAAgBUHwAGogAUEIaiIPIAIQgAECQAJAAkACQCAFKAJwIghBA0YEQCAFQeQAaiAFQZgBaikDADcCACAFQdwAaiAFQZABaikDACIWNwIAIAVB1ABqIAVB8ABqIgJBGGopAwAiFzcCACAFQcwAaiACQRBqKQMAIhg3AgAgBSAFKQN4IhU3AkQgBUEgaiICQRhqIBY3AwAgAkEQaiAXNwMAIAVBKGogGDcDACAFIBU3AyAgBRAiIgw2AqwBIAVBGGogBhAEAn8CfyAFKAIYIgsEQCAFKAIcDAELIAVBCGogBhAIQQAgBSgCCEUNARpBACELQX8CfyAFKwMQIhtEAAAAAAAAAABmIQMgAyAbRAAAAAAAAPBBY3EEQCAbqwwBC0EAC0EAIAMbIBtEAADg////70FkGwshA0EBCyECIAZBhAFPBEAgBhABCyACRQ0CIAVBQGsgESAEEMAEIAUoAkBFBEAgD0GAAWohDQJAIAVByABqKAIAIgoEQCAFQcwAaigCACEIIAUoAkQgBSADNgJIIAUgCzYCRCAFIAM2AkAgBUHwAGogDSAFQSBqIAVBQGsgCiAIEL0BRQ0BIAoQ1AEMAQsgBSADNgJIIAUgCzYCRCAFIAM2AkAgBUHwAGogDSAFQSBqIAVBQGsQ2wILIAUtAHAiA0ETRg0CIAdBC2ogBS0AczoAACAHQQlqIAUvAHE7AAAgB0EYaiAFKQOAATcDACAHQSBqIAVB8ABqIgJBGGopAwA3AwAgB0EoaiACQSBqKQMANwMAIAUpAnQhFSAHQRRqIAUoAnw2AgAgB0EMaiAVNwIAIAcgAzoACCAHQQM2AgAMBAsgBSkCRCEVIAdBDGogBUHMAGooAgA2AgAgByAVNwIEIAdBBDYCACALRQ0DIANFDQMgCxDUAQwDCyAFQegAaiAFQfAAaiIDQSxqKAIAIgI2AgAgBUHgAGogA0EkaikCACIZNwMAIAVB2ABqIANBHGopAgAiGjcDACAFQdAAaiADQRRqKQIAIhY3AwAgBUHIAGogA0EMaikCACIXNwMAIAUgBSkCdCIYNwNAIAUpA6ABIRUgB0EsaiACNgIAIAdBJGogGTcCACAHQRxqIBo3AgAgB0EUaiAWNwIAIAdBDGogFzcCACAHIBg3AgQgByAVNwMwIAcgCDYCAAJAIBFFDQAgBEGEAUkNACAEEAELIAZBhAFJDQMgBhABDAMLIAVB/ABqKAIAIQggBSgCdCEGIAUgBUH4AGoiCygCACIDNgK8ASAFIAhBBnQiECADajYCuAEgBSADNgK0ASAFIAY2ArABAkAgCEUNACAFQe4BaiESIAVBkAFqIRMDQCALIAMiBkEIaiIMKQMANwMAIAVB8ABqIgNBEGogBkEQaiINKQMANwMAIANBGGogBkEYaiIKKQMANwMAIBMgBkEgaikDADcDACADQShqIAZBKGooAgA2AgAgBSAGQUBrIgM2ArQBIAUgBikDADcDcCAGLwEsIghBA0YNASAFQcABaiIOQRhqIAopAwA3AwAgDkEQaiANKQMANwMAIA5BCGogDCkDADcDACAFIAYpAwA3A8ABIAVB6AFqIBNBCGooAgA2AgAgEiAGKQEuNwEAIBJBCGogBkE2aikBADcBACASQRBqIAZBPmovAQA7AQAgBSAIOwHsASAFIBMpAwA3A+ABIAUQIjYCgAIgBUFAayIKIA4gDy0A0QMQsAIgBS0AQSEIIAUtAEAhBiAFIAUoAkQ2AoQCIAogBiAIEPkBIAUoAkAgBSgCRCIIIAUoAkgQAiEGBEAgCBDUAQsgBSAGNgKIAiAFQYACaiAFQYgCahCBCiAFKAKIAiIGQYQBTwRAIAYQAQsgBUHAAWotAABBC0cEQCAFQYACaiAFQYQCahCBCgsgBUEANgKQAiAFQoCAgIAQNwOIAiAFQUBrIgZBAzoAICAGQoCAgICABDcCGCAGQQA2AhAgBkEANgIIIAZBvIHAADYCBCAGIAVBiAJqNgIAIAVB4AFqIAYQpwZFBEAgBSgCiAIgBSgCjAIiCCAFKAKQAhACIQYEQCAIENQBCyAFIAY2AkAgBUGAAmogBUFAaxCBCiAFKAJAIgZBhAFPBEAgBhABCyAFIAUoAoACEAA2AkAgBUGsAWogBUFAaxCBCiAFKAJAIgZBhAFPBEAgBhABCyAFKAKEAiIGQYQBTwRAIAYQAQsgBSgCgAIiBkGEAU8EQCAGEAELAkAgBS8B7AEiBkEDcUEDR0EAIAZBAWsbDQAgBSgC8AFFDQAgBSgC9AEQ1AELIAVBwAFqEIgHIBBBQGoiEA0BDAILC0HUgcAAQTcgBUGYAmpBjILAAEHogsAAEIcHAAsgBUGwAWoQmwUgBSgCrAEhDAsgB0EGNgIAIAcgDDYCBAJAIAUvASwiA0EDcUEDR0EAIANBAWsbDQAgBUEwaigCAEUNACAFQTRqKAIAENQBCyACDQEgEUUNASAEQYQBSQ0BIAQQAQwBCyAMQYQBTwRAIAwQAQsgBS8BLCICQQNxQQNHQQAgAkEBaxsNACAFQTBqKAIARQ0AIAVBNGooAgAQ1AELIAVBoAJqJAAgCUEIaiICQQhqIhAgB0EQaiILKQMANwMAIAJBEGoiDCAHQRhqIg0pAwA3AwAgAkEYaiIKIAdBIGoiCCkDADcDACACQSBqIgYgB0EoaiIEKQMANwMAIAJBKGoiAyAJQegAaiICKQMANwMAIAkgCSkDQDcDCCAJKAI8IQ4gCSgCOCEPIAEgASgCAEEBazYCACAAIA9BBkcEfyALIBApAwA3AwAgDSAMKQMANwMAIAggCikDADcDACAEIAYpAwA3AwAgAiADKQMANwMAIAkgDjYCPCAJIA82AjggCSAJKQMINwNAIAlBOGoQ3AYhFEEBBUEACzYCCCAAIBQ2AgQgACAONgIAIAlB8ABqJAAPCxDVCgALENYKAAviCwIMfwZ+IwBB8ABrIggkAAJAIAEEQCABKAIAIgRBf0YNASABIARBAWo2AgAgCEE4aiEFIANBAEchByMAQeABayIEJAAgBEGAAWogAUEIaiIGIAIQgAECQAJAAkAgBCgCgAEiCUEDRgRAIARBxABqIARBqAFqKQMANwIAIARBPGogBEGgAWopAwAiEDcCACAEQTRqIARBgAFqIgJBGGopAwAiETcCACAEQSxqIAJBEGopAwAiEjcCACAEIAQpA4gBIhM3AiQgBEEYaiAQNwMAIARBEGogETcDACAEQQhqIBI3AwAgBCATNwMAIAIgByADEMAEIAQoAoABRQRAIARBiAFqKAIAIgdFDQIgBCgChAEgBEEgaiICIAZBgAFqIAQgByAEQYABaiIDQQxqKAIAEM8GIAMgAkHgABDgChojAEGAAWsiAiQAIAIQIjYCDCACQRBqIgYgA0HgABDgChogAkHwAGogBhCnByACKAJ0IgMEQANAIAIoAnAgAyACKAJ4EAIhCgRAIAMQ1AELIAIgCjYCcCACQQxqIAJB8ABqEIEKIAIoAnAiA0GEAU8EQCADEAELIAJB8ABqIAJBEGoQpwcgAigCdCIDDQALCyACKAJMQQNHBEACQCACKAIwIgNFDQAgAyADQQFqQRhsIgNqQXdGDQAgAkE8aigCACADaxDUAQsgAkEgahC8AwsgAigCDCEDIAJBgAFqJABFDQMgBxDUAQwDCyAEKQKEASEQIAVBDGogBEGMAWooAgA2AgAgBSAQNwIEIAVBBDYCACAELwEMIgJBA3FBA0dBACACQQFrGw0DIARBEGooAgBFDQMgBEEUaigCABDUAQwDCyAEQcgAaiAEQYABaiICQSxqKAIAIgY2AgAgBEFAayACQSRqKQIAIhA3AwAgBEE4aiACQRxqKQIAIhE3AwAgBEEwaiACQRRqKQIAIhI3AwAgBEEoaiACQQxqKQIAIhM3AwAgBCAEKQKEASIUNwMgIAQpA7ABIRUgBUEsaiAGNgIAIAVBJGogEDcCACAFQRxqIBE3AgAgBUEUaiASNwIAIAVBDGogEzcCACAFIBQ3AgQgBSAVNwMwIAUgCTYCACAHRQ0CIANBhAFJDQIgAxABDAILIARBIGoiAiAGQYABaiAEEOQFIARBgAFqIgdBIGoiCSACQSBqKQMANwMAIAdBGGoiCiACQRhqKQMANwMAIAdBEGoiCyACQRBqKQMANwMAIAdBCGoiDCACQQhqKQMANwMAIAQgBCkDIDcDgAEjAEFAaiICJAAgAhAiIgM2AgQgAkEIaiIGQSBqIAkpAgA3AwAgBkEYaiAKKQIANwMAIAZBEGogCykCADcDACAGQQhqIAwpAgA3AwAgAiAHKQIANwMIIAJBMGogBhCVByACKAI0IgcEQANAIAIoAjAgByACKAI4EAIhBgRAIAcQ1AELIAIgBjYCMCACQQRqIAJBMGoQgQogAigCMCIDQYQBTwRAIAMQAQsgAkEwaiACQQhqEJUHIAIoAjQiBw0ACyACKAIEIQMLIAJBQGskAAsgBUEGNgIAIAUgAzYCBCAELwEMIgJBA3FBA0dBACACQQFrGw0AIARBEGooAgBFDQAgBEEUaigCABDUAQsgBEHgAWokACAIQQhqIgJBCGoiBCAFQRBqIgcpAwA3AwAgAkEQaiIGIAVBGGoiCSkDADcDACACQRhqIgogBUEgaiILKQMANwMAIAJBIGoiDCAFQShqIgUpAwA3AwAgAkEoaiINIAhB6ABqIg4pAwA3AwAgCCAIKQNANwMIIAgoAjwhAiAIKAI4IQMgASABKAIAQQFrNgIAIAAgA0EGRwR/IAcgBCkDADcDACAJIAYpAwA3AwAgCyAKKQMANwMAIAUgDCkDADcDACAOIA0pAwA3AwAgCCACNgI8IAggAzYCOCAIIAgpAwg3A0AgCEE4ahDcBiEPQQEFQQALNgIIIAAgDzYCBCAAIAI2AgAgCEHwAGokAA8LENUKAAsQ1goAC4ADAQR/IwBBIGsiASQAIABBHGooAgAiAiAAQSBqKAIAQQV0aiACEKUFIQIgAUEIaiAAEOQDIAEgASgCDCIAIAEoAhAQ7Ag2AhwgAUEcahD5CiEDIAEoAhwiBEGEAU8EQCAEEAELIAEoAggEQCAAENQBCyABECs2AgQgAUGUksAAQQgQAjYCFCABIAI2AhggAUEIaiABQQRqIAFBFGogAUEYahD5BwJAIAEtAAhFBEAgASgCGCIAQYQBTwRAIAAQAQsgASgCFCIAQYQBTwRAIAAQAQsgAUGsksAAQQUQAjYCFCABIAM2AhggAUEIaiABQQRqIAFBFGogAUEYahD5ByABLQAIDQEgASgCGCIAQYQBTwRAIAAQAQsgASgCFCIAQYQBTwRAIAAQAQsgASgCBCABQSBqJAAPCyABIAEoAgw2AhxB74/AAEErIAFBHGpBnJDAAEGcksAAEIcHAAsgASABKAIMNgIcQe+PwABBKyABQRxqQZyQwABBtJLAABCHBwALtgIBBX8gAEEIaigCACIDIABBBGooAgAiAmtBiAJuIQEgAiADRwRAIAIgAUGIAmxqIQUDQAJAIAIiASgCMEUNACABQTRqKAIARQ0AIAFBOGooAgAQ1AELIAEoAnQEQCABQfgAaigCABDUAQsCQCABLwGMAUUNACABQZABaigCAEUNACABQZQBaigCABDUAQsgAUGEAWohBCABQYgBaigCACIDBEAgBCgCACECIANBFGwhAwNAAkAgAi8BAEUNACACQQRqKAIARQ0AIAJBCGooAgAQ1AELIAJBFGohAiADQRRrIgMNAAsLIAEoAoABBEAgBCgCABDUAQsgAUGIAmohAgJAIAFB7ABqKAIAIgNFDQAgASgCaEUNACADENQBCyACIAVHDQALCyAAKAIABEAgACgCDBDUAQsLhwMCBX8CfiMAQUBqIgUkAEEBIQcCQCAALQAEDQAgAC0ABSEIIAAoAgAiBigCGCIJQQRxRQRAIAYoAgBBnczEAEGfzMQAIAgbQQJBAyAIGyAGKAIEKAIMEQIADQEgBigCACABIAIgBigCBCgCDBECAA0BIAYoAgBB6MvEAEECIAYoAgQoAgwRAgANASADIAYgBCgCDBEBACEHDAELIAhFBEAgBigCAEGYzMQAQQMgBigCBCgCDBECAA0BIAYoAhghCQsgBUEBOgAXIAVB/MvEADYCHCAFIAYpAgA3AwggBSAFQRdqNgIQIAYpAgghCiAGKQIQIQsgBSAGLQAgOgA4IAUgBigCHDYCNCAFIAk2AjAgBSALNwMoIAUgCjcDICAFIAVBCGoiBjYCGCAGIAEgAhDoAw0AIAVBCGpB6MvEAEECEOgDDQAgAyAFQRhqIAQoAgwRAQANACAFKAIYQZvMxABBAiAFKAIcKAIMEQIAIQcLIABBAToABSAAIAc6AAQgBUFAayQAIAAL4AIBBn8CfwJAAn8gAS0ATCIFBEAgAUEgaiEDIAFBJGoMAQsgASgCQEUNASABQcQAaiEDIAFByABqCyADKAIAIQMoAgAhBkEADAELQQELIQICQAJAAkACfyAALQBMBEAgAEEgaiEEIABBJGoMAQsgACgCQEUNASAAQcQAaiEEIABByABqCyEHIAINASADIAQoAgBHDQEgBiAHKAIARg0CDAELIAINAQsgBQRAIABBAjYCdAsCfwJAAkAgAS0AACICQQVrDggBAAAAAAAAAwALIAFBMGooAgBFDAELIAFBMGooAgAgAUEYaigCAEEAIAJBBUYbTQtFDQAgACgCdEECRw0AIAAgASAALQCAARDZAyAAKAJUajYCVCAAQQEgASgCQCABLQBMIgIbNgJ0IABB/ABqIAFBJGogAUHIAGogAhsoAgA2AgAgAEH4AGogAUEgaiABQcQAaiACGygCADYCAAsLtAMBAX8jAEEQayICJAACfwJAAkACQAJAAkACQAJAAkACQAJAIAAtAABBAWsOCQECAwQFBgcICQALIAIgAEEEajYCDCABQYqXwgBBBSACQQxqQciTwgAQugYMCQsgAiAAQQRqNgIMIAFBiJjCAEEDIAJBDGpBjJjCABC6BgwICyACIABBCGo2AgwgAUGDl8IAQQMgAkEMakGgk8IAELoGDAcLIAIgAEEIajYCDCABQYaXwgBBBCACQQxqQfiXwgAQugYMBgsgAiAAQQhqNgIMIAFBgJfCAEEDIAJBDGpB6JfCABC6BgwFCyACIABBCGo2AgwgAUGYl8IAQQcgAkEMakHYl8IAELoGDAQLIAIgAEEIajYCDCABQY+XwgBBCSACQQxqQaCTwgAQugYMAwsgAiAAQQFqNgIMIAFBzpfCAEEHIAJBDGpB1JDCABC6BgwCCyACIABBAWo2AgggAiAAQQRqNgIMIAFBuZfCAEEHQcCXwgBBCSACQQhqQdiTwgBByZfCAEEFIAJBDGpByJPCABDFBgwBCyABKAIAQbWXwgBBBCABKAIEKAIMEQIACyACQRBqJAALsgYCCH8FfiMAQTBrIgkkACABIAIQzwMhDiABQRxqKAIAIgVBJGshCCAOQhmIQv8Ag0KBgoSIkKDAgAF+IRAgDqchBCABQRBqIgYoAgAhCgJ/AkADQCAQIAQgCnEiCyAFaikAACIPhSIMQoGChIiQoMCAAX0gDEJ/hYNCgIGChIiQoMCAf4MhDQNAIA1QBEAgDyAPQgGGg0KAgYKEiJCgwIB/g0IAUg0DIAsgB0EIaiIHaiEEDAILIA16IQwgDUIBfSANgyENIAIgCCAMp0EDdiALaiAKcUFcbGoiBEEgEOEKDQALCyAEKAIgIQogBCADNgIgQQEMAQsgCUEIaiIHQRhqIAJBGGopAAA3AwAgB0EQaiACQRBqKQAANwMAIAdBCGogAkEIaikAADcDACAJIAM2AiggCSACKQAANwMIIAZBDGooAgAiBSAGKAIAIgggDqciA3EiAmopAABCgIGChIiQoMCAf4MiDFAEQEEIIQQDQCACIARqIARBCGohBCAIcSICIAVqKQAAQoCBgoSIkKDAgH+DIgxQDQALCyAFIAx6p0EDdiACaiAIcSIEaiwAACICQQBOBH8gBSAFKQMAQoCBgoSIkKDAgH+DeqdBA3YiBGotAAAFIAILQQFxIQICQCAGKAIEDQAgAkUNACAGQQEgARCYASADIAYoAgAiCHEiASAGQQxqKAIAIgVqKQAAQoCBgoSIkKDAgH+DIgxQBEBBCCEEA0AgASAEaiEBIARBCGohBCAFIAEgCHEiAWopAABCgIGChIiQoMCAf4MiDFANAAsLIAUgDHqnQQN2IAFqIAhxIgRqLAAAQQBIDQAgBSkDAEKAgYKEiJCgwIB/g3qnQQN2IQQLIAQgBWogA0EZdiIBOgAAIARBCGsgCHEgBWpBCGogAToAACAGIAYoAgQgAms2AgQgBiAGKAIIQQFqNgIIIAUgBEFcbGpBJGsiAUEgaiAHQSBqKAIANgIAIAFBGGogB0EYaikCADcCACABQRBqIAdBEGopAgA3AgAgAUEIaiAHQQhqKQIANwIAIAEgBykCADcCAEEACyEBIAAgCjYCBCAAIAE2AgAgCUEwaiQAC9ECAQF/IwBB0ABrIgMkACAAAn8gAUUEQCAAQQhqQQA2AgBBAAwBCyADIAI2AgQgA0EIaiIBIANBBGoQngkgA0GFgMQANgIcIANBxABqIAFBCGooAgA2AgAgA0EANgI4IAMgAykDCDcCPCADIANBGGo2AkggA0EoaiADQThqELMBAkAgAygCHCICQYWAxABGBEAgA0FAayADQTBqKAIANgIAIAMgAykDKDcDOAwBCyADQUBrIANBIGooAgA2AgAgAyADKQMYNwM4IAMoAihFDQAgAygCLBDUAQsgAygCBCIBQYQBTwRAIAEQAQsgA0EwaiIBIANBQGsoAgA2AgAgAyADKQM4NwMoIAJBhYDEAEYEQCAAIAMpAyg3AgQgAEEMaiABKAIANgIAQQAMAQsgACADKQMoNwIEIABBDGogASgCADYCAEEBCzYCACADQdAAaiQAC+UCAgR+Bn9BAyEDAkAgACABLQANBH9BAwUgAkEYaigCAEUNASABQQRqKAIAIgogASgCACILQZWViLkCbEEFd3NBlZWIuQJsIgNBGXatQoGChIiQoMCAAX4hByACQRxqKAIAIgxBCGshDSACQRBqKAIAIQQDQCADIARxIgMgDGopAAAiBiAHhSIFQoGChIiQoMCAAX0gBUJ/hYNCgIGChIiQoMCAf4MhBQNAIAVQBEAgBiAGQgGGg0KAgYKEiJCgwIB/g0IAUg0EIAMgCUEIaiIJaiEDDAILIAV6IQggBUIBfSAFgyEFIA0gCKdBA3YgA2ogBHFBA3RrIg4oAgAgC0cNACAOQQRqKAIAIApHDQALC0ECCzYCAA8LIAEgASgCCAJ/AkAgAS0ADCIDQQNxQQNGDQACQAJAIANBAWsOAgIAAQsgAkEIagwCCyACQSBqDAELIAJBJGoLKAIAajYCCCAAQQA2AgAL+RUCEn8FfiMAQTBrIhEkACAAIAEQzwMhFyAAQRxqKAIAIhBBIWshCSAXQhmIQv8Ag0KBgoSIkKDAgAF+IRkgF6chByAAQRBqIggoAgAhCwJAAkADQCAZIBAgByALcSIMaikAACIYhSIVQoGChIiQoMCAAX0gFUJ/hYNCgIGChIiQoMCAf4MhFgNAIBZQBEAgGCAYQgGGg0KAgYKEiJCgwIB/g0IAUg0DIAwgBUEIaiIFaiEHDAILIBZ6IRUgFkIBfSAWgyEWIAEgCSAVp0EDdiAMaiALcUFfbGoiB0EgEOEKDQALCyAHLQAgGiAHIAI6ACAMAQsgEUEIaiIOQRhqIAFBGGopAAA3AwAgDkEQaiABQRBqKQAANwMAIA5BCGogAUEIaikAADcDACARIAI6ACggESABKQAANwMIIAgoAgAiAiAXpyIScSIBIAhBDGooAgAiBWopAABCgIGChIiQoMCAf4MiFVAEQEEIIQcDQCABIAdqIQEgB0EIaiEHIAUgASACcSIBaikAAEKAgYKEiJCgwIB/gyIVUA0ACwsgBSAVeqdBA3YgAWogAnEiB2osAAAiAUEATgRAIAUgBSkDAEKAgYKEiJCgwIB/g3qnQQN2IgdqLQAAIQELIAFBAXEhEwJAIAgoAgQNACATRQ0AIAAhAUEAIQUjAEEgayIPJAACQCAIQQhqKAIAIhRBAWoiAkUEQBCHCCAPKAIMGgwBCyAIKAIAIgpBAWohCQJAAkACQAJAIAogCUEDdkEHbCAKQQhJGyINQQF2IAJJBEAgD0EQakEhIAIgDUEBaiIAIAAgAkkbEO4DIA8oAhwiBg0BIA8oAhQaDAULIAhBDGooAgAhBkEAIQADQAJAAn8gBUEBcQRAIABBB2oiBSAASQ0CIAUgCU8NAiAAQQhqDAELIAAgCUkiAkUNASACIAAiBWoLIQAgBSAGaiICKQMAIRUgAiAVQn+FQgeIQoGChIiQoMCAAYMgFUL//v379+/fv/8AhHw3AwBBASEFDAELCyAJQQhPBEAgBiAJaiAGKQAANwAADAILIAZBCGogBiAJEN8KGiAKQX9HDQFBACENDAILIA8oAhAhCyAPKAIUIBRrIQcCQCAJRQRAIAggBzYCBCAIIAs2AgAgCCgCDCENIAggBjYCDAwBCyAIQQxqKAIAIg1BIWshEEEAIQwDQCAMIA1qLAAAQQBOBEAgBiABIBAgDEFfbGoQzwOnIgkgC3EiBWopAABCgIGChIiQoMCAf4MiFVAEQEEIIQADQCAAIAVqIQIgAEEIaiEAIAYgAiALcSIFaikAAEKAgYKEiJCgwIB/gyIVUA0ACwsgBiAVeqdBA3YgBWogC3EiAGosAABBAE4EQCAGKQMAQoCBgoSIkKDAgH+DeqdBA3YhAAsgACAGaiAJQRl2IgI6AAAgAEEIayALcSAGakEIaiACOgAAIAYgAEF/c0EhbGoiAkEgaiANIAxBf3NBIWxqIgBBIGotAAA6AAAgAkEYaiAAQRhqKQAANwAAIAJBEGogAEEQaikAADcAACACQQhqIABBCGopAAA3AAAgAiAAKQAANwAACyAKIAxGIAxBAWohDEUNAAsgCCAHNgIEIAggCzYCACAIQQxqIAY2AgAgCkUNAwsgCkEhbEEoakF4cSIAIApqQXdGDQMgDSAAaxDUAQwDCyAGQSFrIQdBACEAA0ACQCAGIAAiAmoiCy0AAEGAAUcNACAHIAJBX2xqIRAgBiACQX9zQSFsaiEDAkADQCAGIAEgEBDPA6ciDCAKcSIJIgVqKQAAQoCBgoSIkKDAgH+DIhVQBEBBCCEAA0AgACAFaiEFIABBCGohACAGIAUgCnEiBWopAABCgIGChIiQoMCAf4MiFVANAAsLIAYgFXqnQQN2IAVqIApxIgVqLAAAQQBOBEAgBikDAEKAgYKEiJCgwIB/g3qnQQN2IQULIAUgCWsgAiAJa3MgCnFBCE8EQCAGIAVBf3NBIWxqIQQgBSAGaiIALQAAIAAgDEEZdiIAOgAAIAVBCGsgCnEgBmpBCGogADoAAEH/AUYNAiAELQAAIQAgBCADLQAAOgAAIAMgADoAACADLQABIQAgAyAELQABOgABIAQgADoAASAELQACIQAgBCADLQACOgACIAMgADoAAiADLQADIQAgAyAELQADOgADIAQgADoAAyAELQAEIQAgBCADLQAEOgAEIAMgADoABCADLQAFIQAgAyAELQAFOgAFIAQgADoABSAELQAGIQAgBCADLQAGOgAGIAMgADoABiADLQAHIQAgAyAELQAHOgAHIAQgADoAByAELQAIIQAgBCADLQAIOgAIIAMgADoACCADLQAJIQAgAyAELQAJOgAJIAQgADoACSAELQAKIQAgBCADLQAKOgAKIAMgADoACiADLQALIQAgAyAELQALOgALIAQgADoACyAELQAMIQAgBCADLQAMOgAMIAMgADoADCADLQANIQAgAyAELQANOgANIAQgADoADSAELQAOIQAgBCADLQAOOgAOIAMgADoADiADLQAPIQAgAyAELQAPOgAPIAQgADoADyAELQAQIQAgBCADLQAQOgAQIAMgADoAECADLQARIQAgAyAELQAROgARIAQgADoAESAELQASIQAgBCADLQASOgASIAMgADoAEiADLQATIQAgAyAELQATOgATIAQgADoAEyAELQAUIQAgBCADLQAUOgAUIAMgADoAFCADLQAVIQAgAyAELQAVOgAVIAQgADoAFSAELQAWIQAgBCADLQAWOgAWIAMgADoAFiADLQAXIQAgAyAELQAXOgAXIAQgADoAFyAELQAYIQAgBCADLQAYOgAYIAMgADoAGCADLQAZIQAgAyAELQAZOgAZIAQgADoAGSAELQAaIQAgBCADLQAaOgAaIAMgADoAGiADLQAbIQAgAyAELQAbOgAbIAQgADoA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BCAWNwIEIAQgEDoAACAHQQRqKAIAIgRFDQEgBygCAEUNASAEENQBDAELIARBCGogDyACQRBqKAIAIAJBFGooAgAQ4gkgBEETOgAACyACQeAAaiQAAkAgAwJ/AkACQAJAIAMtAKgBIgRBE0YEQCADQYgBaiICQQhqIANBqAFqIgRBEGopAwA3AwAgAkEQaiAEQRhqKQMANwMAIAJBGGogA0HIAWopAwA3AwAgAyADKQOwATcDiAEgA0GEAWooAgAhBCADQYABaigCACECIAwNASACRQ0BIAYtANEDDQUgDEEBaw4CAwMCCyADQecAaiIGIANByAFqKQAANwAAIANB4ABqIgggA0GoAWoiAkEZaikAADcDACADQdgAaiACQRFqKQAAIhY3AwAgA0HQAGogAkEJaikAACIXNwMAIAMgAykAqQEiGDcDSCAFQShqIAYpAAA3AAAgBUEhaiAIKQMANwAAIAVBGWogFjcAACAFQRFqIBc3AAAgBUEJaiAYNwAAIAUgBDoACCAFQQQ2AgAMCAsgAwJ/AkACQCAMQQFrDgIBAQALIANB1ABqQQA2AgAgA0HQAGogAjYCACADIAIgBGo2AkxBAQwBCyADQdAAaiACNgIAIAMgAiAEQQR0ajYCTEEACzYCSCADQagBaiAGIANBiAFqIANByABqEHIgAygCqAEiBEEHRg0FIAUgAykCrAE3AgQgBUE0aiADQagBaiICQTRqKAIANgIAIAVBLGogAkEsaikCADcCACAFQSRqIAJBJGopAgA3AgAgBUEcaiACQRxqKQIANwIAIAVBFGogAkEUaikCADcCACAFQQxqIAJBDGopAgA3AgAMBgsgA0HUAGpBADYCACADQdAAaiACNgIAIAMgAiAEajYCTEEBDAELIANB0ABqIAI2AgAgAyACIARBBHRqNgJMQQALNgJIIANBqAFqIAYgA0GIAWogA0HIAGoQciADKAKoASIEQQdGDQIgBSADKQKsATcCBCAFQTRqIANBqAFqIgJBNGooAgA2AgAgBUEsaiACQSxqKQIANwIAIAVBJGogAkEkaikCADcCACAFQRxqIAJBHGopAgA3AgAgBUEUaiACQRRqKQIANwIAIAVBDGogAkEMaikCADcCAAwDCyADQagBaiADQYgBaiEHIAgQmAMgCC0ADEECRgRAQYzEwABBK0GUxcAAEJ4I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AQsgARCKCDYCBEEBCzoAAAsgA0EgaiQAC6gCAQJ/IwBBEGsiAiQAIAJBADYCDAJ/AkACQCABQYABTwRAIAFBgBBJDQEgAUGAgARPDQIgAiABQT9xQYABcjoADiACIAFBDHZB4AFyOgAMIAIgAUEGdkE/cUGAAXI6AA1BAwwDCyACIAE6AAxBAQwCCyACIAFBP3FBgAFyOgANIAIgAUEGdkHAAXI6AAxBAgwBCyACIAFBP3FBgAFyOgAPIAIgAUEGdkE/cUGAAXI6AA4gAiABQQx2QT9xQYABcjoADSACIAFBEnZBB3FB8AFyOgAMQQQLIQEgACgCCCIDKAIIIQAgASADKAIAIABrSwRAIAMgACABEJwGIAMoAgghAAsgAygCBCAAaiACQQxqIAEQ4AoaIAMgACABajYCCCACQRBqJABBAAvlAgEDfyMAQSBrIgEkACAAKAIAIQIgAEECNgIAAkACQAJAIAIOAwIBAgALIAFBFGpBATYCACABQRxqQQA2AgAgAUHwpMQANgIQIAFBnI7EADYCGCABQQA2AgggAUEIakH4pMQAENoIAAsgAC0ABCECIABBAToABCABIAJBAXEiAjoABwJAAkAgAkUEQCAAQQRqIQICQEGE9cQAKAIAQf////8HcQRAQfT4xAAoAgBFIQMgAC0ABQRAIANFIQMMAgsgA0UNBAwDCyAALQAFRQ0CCyABIAM6AAwgASACNgIIQfSQxABBKyABQQhqQZijxABBiKXEABCHBwALIAFBADYCHCABQZyOxAA2AhggAUEBNgIUIAFBhKHEADYCECABQQA2AgggAUEHaiABQQhqENYHAAtBhPXEACgCAEH/////B3FFDQBB9PjEACgCAEUNACAAQQE6AAULIAJBADoAAAsgAUEgaiQAC8MCAQJ/IwBB0ABrIgMkACADIAEoAgAQADYCECADIAIoAgAQADYCFCADQQhqIANBEGogA0EUahC2CCADKAIMIQECQAJAIAMoAggEQCACKAIAEEchAiADQRI2AiwgAyACNgI0IAMgA0E0ajYCKCADQQE2AkwgA0EBNgJEIANBxJLAADYCQCADQQA2AjggAyADQShqNgJIIANBGGogA0E4ahC3AyADKAI0IgJBhAFPBEAgAhABCyADKAIcIgINAQsgAEEANgIIIAAgATYCACADKAIUIgBBhAFPBEAg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IAkgB0E4ajYCoAEgCSAENgKYASAJIAM2ApABIAkgAyAFakEBajYCjAEgCSADQQhqNgKIASAJIDJCf4VCgIGChIiQoMCAf4M3A4ABIAlBEGohCCMAQZABayIDJAAgA0EIaiIEQSBqIAlBgAFqIgVBIGopAwA3AwAgBEEYaiAFQRhqKQMANwMAIARBEGogBUEQaikDADcDACAEQQhqIAVBCGopAwA3AwAgAyAFKQMANwMIAkACQANAIANBCGoQzQYiBEUNASADIARBIGs2AmggAygCKCADQegAahDaBQ0AIAMoAmgiBEUNAAsgA0FAayIGQRhqIgogBEEYaikAADcDACAGQRBqIhEgBEEQaikAADcDACAGQQhqIhIgBEEIaikAADcDACADIAQpAAA3A0BBgAFBARDwCSIEBEAgBCADKQNANwAAIARBGGogCikDADcAACAEQRBqIBEpAwA3AAAgBEEIaiASKQMANwAAIANBATYCOCADIAQ2AjQgA0EENgIwIANB4ABqIANBCGoiBkEgaikDADcDACAKIAZBGGopAwA3AwAgESAGQRBqKQMANwMAIBIgBkEIaikDADcDACADIAMpAwg3A0BBASEGA0ACQCADQUBrEM0GIgoEQCADIApBIGs2AowBIAMoAmAgA0GMAWoQ2gUNAiADKAKMASIKRQ0CIANB6ABqIhFBGGoiEiAKQRhqKQAANwMAIBFBEGoiHyAKQRBqKQAANwMAIBFBCGoiESAKQQhqKQAANwMAIAMgCikAADcDaCADKAIwIAZHDQEgA0EwaiAGQQEQkwYgAygCNCEEDAELIAggAykDMDcCACAIQQhqIANBOGooAgA2AgAMBAsgBCAGQQV0aiIKIAMpA2g3AAAgCkEYaiASKQMANwAAIApBEGogHykDADcAACAKQQhqIBEpAwA3AAAgAyAGQQFqIgY2AjgMAAsACwwGCyAIQQA2AgggCEKAgICAEDcCAAsgA0GQAWokACAJIAw2AogBIAkgDjYChAEgCSAOIBlBBXRqNgKAASAJQSBqIQYjAEEwayIDJAACQAJAIAUoAgQiBCAFKAIAIghHBEAgBSgCCCEMA0AgDCAEEOIFDQIgCCAEQSBqIgRHDQALCyAGQQA2AgggBkKAgICAEDcCAAwBCyADQRBqIgVBGGoiDiAEQRhqKQAANwMAIAVBEGoiESAE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IAkpAAA3AAAgFCADOgAoIBQgFCkDADcAKUEBITEjAEFAaiICJAAgAkEANgIIIAJCgICAgBA3AwAgAkEQaiIBQQM6ACAgAUKAgICAgAQ3AhggAUEANgIQIAFBADYCCCABQdTzwAA2AgQgASACNgIAAkACQAJAIBRBKGoiAy0AAEETRgRAIANBBGogAkEQahDHA0UNAQwCCyADIAJBEGoQsAENAQsgAigCBCACKAIIEAIhASACKAIABEAgAigCBBDUAQsCQAJAIAMtAABBE0YEQAJAIAMtAAQOAwICAAMLIANBHGooAgAiBQRAIANBGGooAgAhBCAFQQxsIQUDQCAEKAIABEAgBEEEaigCABDUAQsgBEEMaiEEIAVBDGsiBQ0ACwsgAygCFARAIANBGGooAgAQ1AELIANBDGooAgANAQwCCyADEKQDDAELIANBCGooAgBFDQAgA0EMaigCABDUAQsgAkFAayQADAELQezzwABBNyACQThqQaT0wABBgPXAABCHBwALCyAAIDE2AgQgACABNgIAIBRB0ABqJAAPCxDVCgALENYKAAvMAgECfyMAQSBrIgIkAAJ/AkACQAJAQQIgACgCACIALQAAIgNBBGsgA0EDTRtB/wFxQQFrDgIBAgALIAJBFGpBATYCACACQRxqQQA2AgAgAkGg+MEANgIQIAJBhOfBADYCGCACQQA2AgggASACQQhqEOQHDAILAkACQAJAIAAtAAFBAWsOAgECAAsgAkEUakEBNgIAIAJBHGpBADYCACACQZSWwQA2AhAgAkHQkMEANgIYIAJBADYCCCABIAJBCGoQ5AcMAwsgAkEUakEBNgIAIAJBHGpBADYCACACQdyVwQA2AhAgAkHQkMEANgIYIAJBADYCCCABIAJBCGoQ5AcMAgsgAkEUakEBNgIAIAJBHGpBADYCACACQbSVwQA2AhAgAkHQkMEANgIYIAJBADYCCCABIAJBCGoQ5AcMAQsgACABEJUECyACQSBqJAALrAIBBX8CQAJAAkAgAiADcgRAIAFBKGooAgAiBSADTQ0BAkAgAUEkaigCACADQRRsaiIBLwEARQRAIAFBEGooAgAhByABQQxqKAIAIQQgAUEIaigCACEGIAFBBGooAgAhBSABLwECIQEMAQsgAUEIaigCACEHQQEhCEEBIQYgAUEMaigCACIEBEAgBEEA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ACAhQaABaiAhQThqKQAANwMAICFBmAFqICFBMGopAAA3AwAgIUGQAWogIUEoaikAADcDACAhQYgBaiAhQSBqKQAANwMAICFBgAFqICFBGGopAAA3AwAgIUHwAGoiBUEIaiAhQRBqKQAANwMAICEgISkACDcDcCAhQQA2ArQBICFByABqIAUgCkHgAGogIUGwAWpCAEIAEMYBIAggBhCTAUUNACAIENQBCyAKQdAAaiE1IwBBsBhrIgMkAAJAAkACQAJAAkACQAJAAkACQAJAIApB4ABqIihBpAJqKAIAIChBmAJqKAIAcgRAIANBmAtqIgVBADYCECAFIAI2AgQgBSAxNgIAIAUgMTYCCCAFQQxqIAI2AgAgA0H4DWogBRBhIAMoApgOQQZHDQEgAygCgA4hBSADKQP4DSE6DAILIANBADoAlwggA0EAOgCWCEHY88QAKAIAIjdBA08NAgJAAkACQEHY88QAKAIAQQJLDQACQAJAAkBBwPHEAC0AACIHDgMDAgABC0ECIQcMAQtBuPHEABD1A0H/AXEiB0UNAQtBvPHEACgCACAHENAIDQELIANBADYCqAsgA0IANwOYCwwBCyADQZgLaiIFQbzxxAAoAgAiCBCCCSADQfgNaiAFEMUIIAMoAvgNRQ0FIANBmBZqIgdBEGogA0H4DWoiBkEQaiIFKAIANgIAIAdBCGogBkEIaikDADcDACADIAMpA/gNNwOYFiADIANBlghqNgLoFSADQfAQaiADQZgLahDFCCADKALwEEUNBSADQbAIaiIHQRBqIANB8BBqIgZBEGooAgA2AgAgB0EIaiAGQQhqKQMANwMAIANBjA5qQZS3wAA2AgAgAyADKQPwEDcDsAggA0GEt8AANgKADiADIAg2AugUIANBAjYC5BQgBSAGNgIAIAMgBzYChA4gAyADQegVajYC/A0gAyADQZgWajYC+A0gAyADQfgNajYC4BQgAyADQZcIajYC8BAgA0GYC2ogCCADQeAUahDtCAsgA0GYCGoiBkEQaiADQZgLaiIFQRBqKQMANwMAIAZBCGoiBiAFQQhqKQMANwMAIAMgAykDmAsiOjcDmAggOlANAiAGKAIAIAYoAgQiBSgCCEEHakF4cWogA0GYCGogBSgCMBEAAAwCCyADQegUaiADQZgOaiICQQhqKAIANgIAIAMgAikCADcD4BQgAygCgA4hBSADKQP4DSE6AkBB2PPEACgCAEEDSw0AAkACQAJAQaDyxAAtAAAiAg4DAwIAAQtBAiECDAELQZjyxAAQ9QNB/wFxIgJFDQELQZzyxAAoAgAgAhDQCEUNACADQbAIaiICQZzyxAAoAgAQgglBnPLEACgCACEIIANBmAtqIAIQxQggAygCmAtFDQUgA0GYFmoiAkEQaiADQZgLaiIKQRBqIgcoAgA2AgAgAkEIaiAKQQhqIgYpAwA3AwAgAyADKQOYCzcDmBYgA0H8EGpBATYCACADQYQRakEANgIAIANBzLbAADYC+BAgA0GAsMAANgKAESADQQA2AvAQIAogA0GwCGoQxQggAygCmAtFDQUgA0GIA2oiAkEQaiAHKAIANgIAIAJBCGogBikDADcDACADIAMpA5gLNwOIAyADIAU2AogYIANBOGogA0GwCGoQxQggAygCOEUNBSADQeAFaiIHQRBqIANBOGoiBkEQaigCADYCACAHQQhqIAZBCGopAwA3AwAgA0G4C2pB1LbAADYCACADQawLakHctMAANgIAIAMgAykDODcD4AUgA0Ggs8AANgKgCyADQbQLaiADQegVajYCACADQZgLaiICQRBqIANBiBhqNgIAIAMgBzYCsAsgAyADQYgDajYCpAsgAyADQfAQajYCnAsgAyADQZgWajYCmAsgAyADQeAUajYC6BUgAyAINgJAIANBAzYCPCADIAI2AjhBnPLEACgCACAGEPwICyADQeAUahDbBQsgKEGYAWoiBygCcCEGIAMgBTYCoAsgAyA6NwOYCyADQfgNaiAoIANBmAtqIDUQjwEgAy0A+A0iAkETRgRAIAcoAnAhAiApQRM6AAAgKSACIAZrNgIEDAILICkgAykA+Q03AAEgKUEgaiADQfgNaiIFQSBqKQAANwAAIClBGWogBUEZaikAADcAACApQRFqIAVBEWopAAA3AAAgKUEJaiAFQQlqKQAANwAAICkgAjoAAAwBC0HY88QAKAIAIQUCQAJAAkACQAJAIAIEQCADLQCWCCE4IAMtAJcIIQggBQ0EAkACQAJAQdjxxAAtAAAiBw4DBwIAAQtBAiEHDAELQdDxxAAQ9QNB/wFxIgdFDQULQdTxxAAoAgAgBxDQCEUNBCADQZgLaiIGQdTxxAAoAgAQgglB1PHEACgCACEFIANB+A1qIAYQxQggAygC+A1FDQEgA0HwEGoiB0EQaiADQfgNaiIGQRBqKAIANgIAIAdBCGogBkEIaikDADcDACADIAMpA/gNNwPwECADQYQOakEBNgIAIANBjA5qQQA2AgAgA0Ggs8AANgK4CCADQdi3wAA2AoAOIANBgLDAADYCiA4gA0EANgL4DSADIAU2AqAWIANBATYCnBYgAyAGNgK0CCADIAc2ArAIIAMgA0GwCGo2ApgWQdTxxAAoAgAgA0GYFmoQ/AgMBAsgBUEBa0EFSQ0CAkACQAJAQczxxAAtAAAiBQ4DBQIAAQtBAiEFDAELQcTxxAAQ9QNB/wFxIgVFDQMLQcjxxAAoAgAgBRDQCEUNAiADQZgLaiIFQcjxxAAoAgAQgglByPHEACgCACECIANB+A1qIAUQxQggAygC+A1FDQEgA0HwEGoiBkEQaiADQfgNaiIFQRBqKAIANgIAIAZBCGogBUEIaikDADcDACADIAMpA/gNNwPwECADQYQOakEBNgIAIANBjA5qQQA2AgAgA0Ggs8AANgK4CCADIAI2AqAWIANBATYCnBYgA0HousAANgKADiADQYCwwAA2AogOIANBADYC+A0gAyAFNgK0CCADIAY2ArAIIAMgA0GwCGo2ApgWQcjxxAAoAgAgA0GYFmoQ/AgMAgtB3LLAAEEiQeC3wAAQkAoAC0HcssAAQSJB8LrAABCQCgALIANBsAhqENsDDAELIANB8BBqIgVBADYCECAFIAI2AgQgBSAxNgIAIAUgMTYCCCAFQQxqIAI2AgAgA0H4DWogBRBtAkACQAJAAkAgAygCkA4iBkEDRgRAQRxBBBDwCSICDQEMCgsgAykD+A0hOyADKAKADiEFIAMpAoQOITogA0GYC2oiAiADQZQOakHcAhDgChogAyA6NwKMCyADIAU2AogLIAMgOzcDgAsgAyAGNgL4DSADQfgNaiIFQQRyIAJB3AIQ4AohMgJ/AkACQAJAIAUoAgBBAWsOAgECAAsgBUGEAWooAgAgBUGkAWooAgBGDAILIAUoAgggBUEoaigCAEYMAQsgBUEUaigCACICIAVBOGooAgBGBH8gBSgCGCACRgVBAAsLDQEgA0EFNgKYCyADQbAIaiIFQQ46AAAgBSADQZgLaiICKQIANwIEIAVBDGogAkEIaigCADYCACADQQM7AeQKQQEhBUEBIQIMAgsgAiADKQKUDjcCACACQRhqIANBrA5qKAIANgIAIAJBEGogA0GkDmopAgA3AgAgAkEIaiADQZwOaikCADcCACADQZC7wAA2AoAOIAMgAjYC/A0gA0EANgL4DSADQbAIaiIFQQ46AAAgBSADQfgNaiICKQIANwIEIAVBDGogAkEIaigCADYCACADQQM7AeQKDAMLAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkAgAygC+A1BAWsOAgEAAgsgA0HoFWoiBUEIaiADQfgNaiICQSBqKQMANwMAIAVBEGogAkEoaikDADcDACADQYAWaiADQagOaikDADcDACAFQSBqIANBsA5qKQMANwMAIAVBKGogA0G4DmopAwA3AwAgAyADKQOQDjcD6BUgA0HwDmopAwAhPCADQewOaigCACEWIANB6A5qKAIAIQwgA0HkDmooAgAhCSADQeAOaigCACEKIANB2A5qKQMAITsgA0HQDmopAwAhOiADQcwOaigCACEIIANByA5qKAIAIQUgA0HEDmooAgAhBCADQcAOaigCACEHIANByBNqIANBgA9qKAIANgIAIAMgA0H4DmopAwA3A8ATIANB4BVqIANBjA9qKAIANgIAIAMgA0GED2opAgA3A9gVIANB0BVqIANBmA9qKAIANgIAIAMgA0GQD2opAwA3A8gVIANB4BNqIgJBEGogA0GsD2ooAgA2AgAgAkEIaiADQaQPaikCADcDACADIANBnA9qKQIANwPgEyADQeAUaiADQbAPakHkABDgChogA0GAFGoiAkEQaiAyQRBqKAIANgIAIAJBCGogMkEIaikCADcDACADIDIpAgA3A4AUQdjzxAAoAgANB0H08cQAEJ0JQf8BcSICRQ0HQfjxxAAoAgAgAhDQCEUNByADQbAIaiIGQfjxxAAoAgAQgglB+PHEACgCACECIANBmAtqIAYQxQggAygCmAtFDQIgA0GYFmoiE0EQaiADQZgLaiIGQRBqKAIANgIAIBNBCGogBkEIaikDADcDACADIAMpA5gLNwOYFiADQaQLakEBNgIAIANBrAtqQQA2AgAgA0Ggs8AANgKQGCADQay4wAA2AqALIANBgLDAADYCqAsgA0EANgKYCyADIAI2AsgUIANBATYCxBQgAyAGNgKMGCADIBM2AogYIAMgA0GIGGo2AsAUQfjxxAAoAgAgA0HAFGoQ/AgMBwsgA0HoFWoiBUEIaiADQfgNaiICQRBqKQMANwMAIAVBEGogAkEYaikDADcDACAFQRhqIAJBIGopAwA3AwAgBUEgaiACQShqKQMANwMAIAVBKGogA0GoDmopAwA3AwAgAyADKQOADjcD6BUgA0HgDmopAwAhPCACQeQAaigCACEWIANB2A5qKAIAIQwgA0HUDmooAgAhCSADQdAOaigCACEKIANByA5qKQMAITsgA0HADmopAwAhOiADQbwOaigCACEIIANBuA5qKAIAIQUgA0G0DmooAgAhBCADQbAOaigCACEHIANBiBRqIANB8A5qKAIANgIAIAMgA0HoDmopAwA3A4AUIANB6BNqIANB/A5qKAIANgIAIAMgA0H0DmopAgA3A+ATIANByBNqIANBiA9qKAIANgIAIAMgA0GAD2opAwA3A8ATIANBoBRqIgJBEGogA0GcD2ooAgA2AgAgAkEIaiADQZQPaikCADcDACADIANBjA9qKQIANwOgFCADQeAUaiADQaAPakHkABDgChpB2PPEACgCAA0FQejxxAAQnQlB/wFxIgJFDQVB7PHEACgCACACENAIRQ0FIANBsAhqIgZB7PHEACgCABCCCUHs8cQAKAIAIQIgA0GYC2ogBhDFCCADKAKYC0UNAiADQZgWaiITQRBqIANBmAtqIgZBEGooAgA2AgAgE0EIaiAGQQhqKQMANwMAIAMgAykDmAs3A5gWIANBpAtqQQE2AgAgA0GsC2pBADYCACADQaCzwAA2ApAYIANB7LjAADYCoAsgA0GAsMAANgKoCyADQQA2ApgLIAMgAjYCyBQgA0EBNgLEFCADIAY2AowYIAMgEzYCiBggAyADQYgYajYCwBRB7PHEACgCACADQcAUahD8CAwFCyADQZgLaiAyQdgCEOAKGkHY88QAKAIADQNB3PHEABCdCUH/AXEiAkUNA0Hg8cQAKAIAIAIQ0AhFDQMgA0GYFmoiBUHg8cQAKAIAEIIJQeDxxAAoAgAhAiADQbAIaiAFEMUIIAMoArAIRQ0CIANB4BRqIgZBEGogA0GwCGoiBUEQaigCADYCACAGQQhqIAVBCGopAwA3AwAgAyADKQOwCDcD4BQgA0G8CGpBATYCACADQcQIakEANgIAIANBoLPAADYC8BUgA0GsucAANgK4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GUEYaiAbQRhqKQIANwMAIBlBEGogG0EQaikCADcDACAZQQhqIBtBCGopAgA3AwAgGSARNgIgIBkgGykCADcDACAZQcgAaiAZEKwCIBktAEgEQCAZQcgAakEBciERA0AgGUEoaiIGQRhqIBFBGGopAAAiPTcDACAGQRBqIBFBEGopAAAiPDcDACAGQQhqIBFBCGopAAAiOzcDACAZIBEpAAAiOjcDKCAZQcgAaiIGQRhqID03AwAgBkEQaiA8NwMAIAZBCGogOzcDACAZIDo3A0ggICAGEP8EIAYgGRCsAiAZLQBIDQALCyAZENICIBlB8ABqJAAjAEEQayIGJAAgBhDjBSAbQYCAwAA2AgAgG0EEaiAGKQAANwAAIBtBDGogBkEIaikAADcAACAGQRBqJAAgA0GIE2pBADYCACADQZQTaiADQdAVaigCADYCACADQfAQaiIGQQhqIBxBCGopAwA3AwAgBkEQaiAcQRBqKQMANwMAIAZBGGogHEEYaikDADcDACADQdgRaiAJKQMANwMAIANB4BFqIAwpAwA3AwAgBkH4AGogFikDADcDACADQfARaiATKQMANwMAIANB+BFqIAQpAwA3AwAgA0KAgICAgAE3A4ATIAMgAykDyBU3AowTIAMgAykDgBQ3A/AQIAMgAykD4BQ3A9ARIANBoBNqQQA2AgAgA0GoEWogFCkDADcDACADQaARaiAYKQMANwMAIAZBKGogHikDADcDACADQcgRaiAKKQMANwMAIANBwBFqIAgpAwA3AwAgA0G4EWogBykDADcDACADQoCAgIAQNwOYEyADIAMpA6AUNwOQESADIAMpA8AUNwOwESADQYgSaiAjQfgAEOAKGiADQbQTaiAbQRBqKAIANgIAIANBrBNqIBtBCGopAwA3AgAgA0EAOgC4EyADIEE3A4ASIAMgAykDiBg3AqQTIANBmAtqEKkDQQEMBAsgAiADKQPYCDcCACACQSBqIANB+AhqKQMANwIAIAJBGGogA0HwCGopAwA3AgAgAkEQaiADQegIaikDADcCACACQQhqIANB4AhqKQMANwIAIANBiLzAADYCoBYgAyACrUIghkIEhDcDmBYgA0GwCGoiBUEOOgAAIAUgA0GYFmoiAikCADcCBCAFQQxqIAJBCGooAgA2AgAgA0EDOwHkCgsgA0GYC2oQqQNBACECQQEhBQwGCwJAAkAgB0UEQAJAIAVFBEBBASECDAELIAVBAE4iB0UNBiAFIAcQ8AkiAkUNAwsgA0HoCGogAjYCACADIAU2AuQIIAIgBCAFEOAKGiADQewIaiAFNgIADAELIANB7AhqIAg2AgAgA0HoCGogBTYCACADIAQ2AuQICyADQbAIaiIFQShqIANB6BVqIgJBKGopAwA3AwAgBUEgaiACQSBqKQMANwMAIAVBGGogAkEYaikDADcDACAFQRBqIAJBEGopAwA3AwAgBUEIaiACQQhqKQMANwMAIANBxAlqIANBoBRqIgJBCGopAwA3AgAgA0HMCWogAkEQaigCADYCACADIAMpA+gVNwOwCCADIAMpA6AUNwK8CSADQbgJaiADQcgTaigCADYCACADQaAJaiADQYgUaigCADYCACADIAMpA8ATNwOwCSADIAMpA4AUNwOYCSADQdAJaiADQeAUakHkABDgChogA0GMCWogFjYCACADQYQJaiAJNgIAIANBrAlqIANB6BNqKAIANgIAQQEhAiADQQE2AuAIIAMgPDcDkAkgAyA6NwPwCCADIAw2AogJIAMgCjYCgAkgAyA7NwP4CCADIAMpA+ATNwKkCSADQQI2AsAUIANBmAtqIAUgA0HAFGoQ7QICQCADKALICyIMQQJGBEBBGEEEEPAJIgINAQwOCyADQYgYaiIFQQhqIgkgA0GYC2oiE0EUaikCADcDACAFQRBqIgogE0EcaikCADcDACAFQRhqIgggE0EkaikCADcDACAFQSBqIgcgE0EsaigCADYCACADIAMpAqQLNwOIGCADKQOYCyE6IAMoAqALIQYgA0GYFmoiBSATQTRqQewBEOAKGiATENsDIANBsAhqIhZBFGogCSkDADcCACAWQRxqIAopAwA3AgAgFkEkaiAIKQMANwIAIBZBLGogBygCADYCACADIAY2ArgIIAMgOjcDsAggAyADKQOIGDcCvAggAyAMNgLgCCAWQTRqIAVB7AEQ4AoaIBMgFhC7AiADQfAQaiATQdACEOAKGkEAIQVBAQwDCyACIAMpA5gLNwIAIAJBEGogA0GYC2oiB0EQaikDADcCACACQQhqIAdBCGoiBSkDADcCACADQcy7wAA2AqALIAMgAjYCnAtBASECIANBATYCmAsgA0GwCGoiBkEOOgAAIAYgBykCADcCBCAGQQxqIAUoAgA2AgAgA0EDOwHkCkEAIQUMBgsMDQsCQCAHRQRAAkAgBUUEQEEBIQIMAQsgBUEATiIHRQ0EIAUgBxDwCSICRQ0PCyADQegIaiACNgIAIAMgBTYC5AggAiAEIAUQ4AoaIANB7AhqIAU2AgAMAQsgA0HsCGogCDYCACADQegIaiAFNgIAIAMgBDYC5AgLIANBsAhqIhNBKGogA0HoFWoiAkEoaikDADcDACATQSBqIAJBIGopAwA3AwAgE0EYaiACQRhqKQMANwMAIBNBEGogAkEQaikDADcDACATQQhqIAJBCGopAwA3AwAgA0HECWogA0HgE2oiAkEIaikDADcCACADQcwJaiACQRBqKAIANgIAIAMgAykD6BU3A7AIIAMgAykD4BM3ArwJIANBuAlqIANB0BVqKAIANgIAIANBoAlqIANByBNqKAIANgIAIAMgAykDyBU3A7AJIAMgAykDwBM3A5gJIANB0AlqIANB4BRqQeQAEOAKGiADQYwJaiAWNgIAIANBhAlqIAk2AgAgA0GsCWogA0HgFWooAgA2AgBBASEFIANBATYC4AggAyA8NwOQCSADIDo3A/AIIAMgDDYCiAkgAyAKNgKACSADIDs3A/gIIAMgAykD2BU3AqQJIANBwBRqIgdBEGogA0GAFGoiAkEQaigCADYCACAHQQhqIAJBCGopAwA3AwAgAyADKQOAFDcDwBQgA0GgFGohCSAHKAIIIQogBygCBCEIIAcoAhAhBgJAAkACQAJAIAcoAgBFBEACQCAKRQRAQQEhAgwBCyAKQQBOIgdFDQMgCiAHEPAJIgJFDQQLIAkgAjYCCCAJIAo2AgQgAiAIIAoQ4AoaIAkgCjYCDAwBCyAJIAcoAgw2AgwgCSAKNgIIIAkgCDYCBAsgCUEBNgIAIAkgBjYCEAwCCxDHCAALIAogB0Hw9MQAKAIAIgBBygQgABsRAAAACyADQZgLaiATIAkQ7QIgAygCyAsiDEECRgRAQRhBBBDwCSIGRQ0LIAYgAykDmAs3AgAgBkEQaiADQZgLaiIHQRBqKQMANwIAIAZBCGogB0EIaiICKQMANwIAIANBzLvAADYCoAsgAyAGNgKcCyADQQE2ApgLIANBsAhqIgZBDjoAACAGIAcpAgA3AgQgBkEMaiACKAIANgIAIANBAzsB5ApBACEHQQEhAgwGCyADQYgYaiICQQhqIgkgA0GYC2oiE0EUaikCADcDACACQRBqIgogE0EcaikCADcDACACQRhqIgggE0EkaikCADcDACACQSBqIgcgE0EsaigCADYCACADIAMpAqQLNwOIGCADKQOYCyE6IAMoAqALIQYgA0GYFmoiAiATQTRqQewBEOAKGiATENsDIANBsAhqIhZBFGogCSkDADcCACAWQRxqIAopAwA3AgAgFkEkaiAIKQMANwIAIBZBLGogBygCADYCACADIAY2ArgIIAMgOjcDsAggAyADKQOIGDcCvAggAyAMNgLgCCAWQTRqIAJB7AEQ4AoaIBMgFhC7AiADQfAQaiATQdACEOAKGkEBIQJBAAshB0HY88QAKAIADQICQAJAAkBBiPLEAC0AACISDgMFAgABC0ECIRIMAQtBgPLEABD1A0H/AXEiEkUNAwtBhPLEACgCACASENAIRQ0CIANBsAhqIghBhPLEACgCABCCCUGE8sQAKAIAIQYgA0GYC2ogCBDFCCADKAKYC0UNASADQZgWaiIKQRBqIANBmAtqIghBEGooAgA2AgAgCkEIaiAIQQhqKQMANwMAIAMgAykDmAs3A5gWIANBpAtqQQE2AgAgA0GsC2pBADYCACADQaCzwAA2AugUIAMgBjYC8BUgA0EBNgLsFSADQay6wAA2AqALIANBgLDAADYCqAsgA0EANgKYCyADIAg2AuQUIAMgCjYC4BQgAyADQeAUajYC6BVBhPLEACgCACADQegVahD8CAwCCxDHCAALQdyywABBIkG0usAAEJAKAAsgA0GYC2oiCkEANgIQIAogA0GAC2oiBigCBCIINgIEIAogBigCACIGNgIAIApBDGogCDYCACAKIAY2AgggA0GYFmogChBhAkACQAJAIAMoArgWQQZGBEAgAygCoBYhBiADKAKYFiECIAMgAygCnBYiBTYCvAggAyAFNgK0CCADIAI2ArAIIAMgBSAGQaACbCICajYCuAggBg0BIANBsAhqEPYGDAMLIANB6BRqIANBuBZqIglBCGoiCigCADYCACADIAkpAgA3A+AUIDhFDQEgA0GYC2oiCEEIaiIGIAooAgA2AgAgAyAJKQIANwOYCyADQbAIaiIKQQ46AAAgCiAIKQIANwIEIApBDGogBigCADYCACADQQM7AeQKIANBmBZqENkH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AkEANgIYIAJBiQQ2AgwgAiADNgIoIAIgAkEEajYCECACIAI2AgggASAAEOQHDAILIAJBJGpBATYCACACQSxqQQA2AgAgAkGU98MANgIgIAJB4PbDADYCKCACQQA2AhggASACQRhqEOQHDAELIAJBJGpBATYCACACQSxqQQA2AgAgAkH49sMANgIgIAJB4PbDADYCKCACQQA2AhggASACQRhqEOQHCyACQTBqJAAL5AEBAn8CQCAAKAIwRQ0AIABBNGooAgBFDQAgAEE4aigCABDUAQsgACgCdARAIABB+ABqKAIAENQBCwJAIAAvAYwBRQ0AIABBkAFqKAIARQ0AIABBlAFqKAIAENQBCyAAQYgBaigCACICBEAgAEGEAWooAgAhASACQRRsIQIDQAJAIAEvAQBFDQAgAUEEaigCAEUNACABQQhqKAIAENQBCyABQRRqIQEgAkEUayICDQALCyAAKAKAAQRAIABBhAFqKAIAENQBCwJAIABB7ABqKAIAIgFFDQAgACgCaEUNACABENQBCwufAgEGfyMAQeAAayIFJAACQAJAAkACQCABQQhqKAIAIgJFBEAgAEKAgICAgAE3AgAMAQsgAkGXutELSw0BIAJB2ABsIgNBAEgNASABQQRqKAIAIQEgAkGYutELSUEDdCEEIAMEfyADIAQQ8AkFIAQLIgZFDQIgACAGNgIEIAAgAjYCACACQdgAbCEDIAVBEGohByACIQQDQCADRQ0BIARFDQQgBSABKQMANwMIIAcgAUEIahDWASADQdgAayEDIAYgBUEIakHYABDgCkHYAGohBiABQdgAaiEBIARBAWsiBA0ACwsgACACNgIIIAVB4ABqJAAPCxDHCAALIAMgBEHw9MQAKAIAIgBBygQgABsRAAAACyACIAJB8L7AABCcBwALpQIBAn8jAEEwayICJAACQAJAAkACQEECIAAoAgQiA0EDayADQQJNG0EBaw4CAQIACyACQQxqQQE2AgAgAkEUakEANgIAIAJBnOHAADYCCCACQfDfwAA2AhAgAkEANgIADAILIAJBDGpBAjYCACACQRRqQQE2AgAgAkHg4MAANgIIIAJBADYCACACQegANgIcIAIgADYCLCACIAJBGGo2AhAgAiACQSxqNgIYDAELIAJBGGoiA0EMakGNATYCACACQQxqQQI2AgAgAkEUakEC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0cQAEPwDAAvxBAEEfyMAQRBrIgQkAAJAIAEEQCABKAIADQEgAUF/NgIAIAQgAhCgBAJAIAQoAgBFBEAgBEEMaigCACEDIARBCGooAgAhBSAEKAIEIQIgAUFAaygCAARAIAFBxABqKAIAENQBCyABIAI2AkBBACECIAFBADYCACABQcgAaiADNgIAIAFBxABqIAU2AgBBACEBDAELIARBDGooAgAhBSAEQQhqKAIAIQMgBCgCBCEGQQAhAiABQQA2AgBBACEBIANBhYDEAEYNACAEIAU2AgggBCADNgIEIAQgBjYCAEEBIQIjAEHwAGsiAyQAIANBADYCECADQoCAgIAQNwMIIANBGGoiAUEDOgAgIAFCgICAgIAENwIYIAFBADYCECABQQA2AgggAUHU88AANgIEIAEgA0EIajYCAAJAAkACQCAEKAIEQYSAxABGBEAgA0HMAGpBATYCACADQdQAakEANgIAIANB/OHAADYCSCADQfDfwAA2AlAgA0EANgJAIANBGGogA0FAaxDkB0UNAQwCCyADQdgAaiIBQQxqQecANgIAIANBQGsiBUEMakECNgIAIANB1ABqQQI2AgAgAyAEQQhqNgJoIANBvOHAADYCSCADQQA2AkAgA0HoADYCXCADIAQ2AmwgAyABNgJQIAMgA0HsAGo2AmAgAyADQegAajYCWCADQRhqIAUQ5AcNAQsgAygCDCADKAIQEAIhASADKAIIBEAgAygCDBDUAQsgA0HwAGokAAwBC0Hs88AAQTcgA0FAa0Gk9MAAQYD1wAAQhwcACwsgACACNgIEIAAgATYCACAEQRBqJAAPCxDVCgALENYKAAuAAgEIfyMAQRBrIgIkAAJAAkACQCABKAIMIgQgAUEEaigCACIFRwRAIAFBCGooAgAiCSAFayIHQQN2IQMgAyABKAIAIgFBAXZPDQEgAkEANgIIIAJCgICAgMAANwMAQQQhBiAFIAlHBEAgAkEAIAMQ/AUgAigCCCEIIAIoAgQhBgsgBiAIQQN0aiAFIAcQ4AoaIAIgAyAIajYCCCABBEAgBBDUAQsgACACKQMANwIAIABBCGogAkEIaigCADYCAAwDCyABKAIIIARrQQN2IQMgASgCACEBDAELIAQgBSAHEN8KGgsgACADNgIIIAAgBDYCBCAAIAE2AgALIAJBEGokAAvzAQECfwJA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BSACKAIMIAJBIGoiB0EIaiADNgIAIAIgATYCJCACQQU6ACAgB0HUssAAQZCywAAQkwchAwRAIAUQ1AELIABBAjsBACAAIAM2AgQLIARFDQEgARDUAQwBCyAAQQI7AQAgACAENgIECyACQTBqJAAL2gEBAn8jAEEQayIDJAAgAxAiNgIEIAEEQCABQTBsIQQgAEEgaiEBA0AgAwJ/IAFBBGooAgAiAARAIAAgAUEIaigCABACDAELIAEoAgC4EAULNgIIIANBBGogA0EIahCBCiADKAIIIgBBhAFPBEAgABABCyABQTBqIQEgBEEwayIEDQALCyADAn8gAkEEaigCACIABEAgACACQQhqKAIAEAIMAQsgAigCALgQBQs2AgwgA0EEaiADQQxqEIEKIAMoAgwiAEGEAU8EQCAAEAELIAMoAgQgA0EQaiQAC4YCAQJ/IwBB8ABrIgIkACACQTBqIgNBGGogACgCACIAQRhqKQAANwMAIANBEGogAEEQaikAADcDACADQQhqIABBCGopAAA3AwAgAiAAKQAANwMwIAJB0ABqIgBBgIDEADYCDCAAQfC6wgA2AgggACADNgIEIAAgA0EgajYCACACQeAAaiIDQQhqIABBCGopAwA3AwAgAiACKQNQNwNgIAJBIGoiACADENMDIAJBDGpBATYCACACQRRqQQE2AgAgAkG8AjYCHCACQaT8wQA2AgggAkEANgIAIAIgADYCGCACIAJBGGo2AhAgASACEOQHIAIoAiAEQCACKAIkENQBCyACQfAAaiQAC4UCAQJ/IwBBIGsiAyQAAkACQCABKAIAIAIoAgByRQRAIABB2ABqKAIAIgQgASgCBCIBTQ0BIAIoAgQiAiAETw0CIABB1ABqKAIAIgAgAUEMbGohASAAIAJBDGxqIgJBCGooAgAhACABQQRqKAIAIAJBBGooAgAgAUEIaigCACIBIAAgACABSxsQ4QohAiADQSBqJABBfyACIAEgAGsgAhsiAEEARyAAQQBIGw8LIANBFGpBATYCACADQRxqQQA2AgAgA0H4/MIANgIQIANB0PjCADYCGCADQQA2AgggA0EIakGA/cIAENoIAAsgASAEQZD9wgAQnAcACyACIARBoP3CABCcBwAL3gECAn4FfwJAIAAoAgAiBkUNAAJAIAAoAggiBEUEQCAAQQxqKAIAIQMMAQsgACgCDCIDQQhqIQAgAykDAEJ/hUKAgYKEiJCgwIB/gyEBIAMhBQNAIAFQBEADQCAFQYABayEFIAApAwAgAEEIaiEAQn+FQoCBgoSIkKDAgH+DIgFQDQALCyAEQQFrIQQgAUIBfSECIAUgAXqnQQF0QfABcWtBDGsiBygCAARAIAdBBGooAgAQ1AELIAEgAoMhASAEDQALCyAGQQR0QRBqIgAgBmpBd0YNACADIABrENQBCwv3AQIDfgN/AkAgASgCGCIHRQ0AAkAgASkDACICUARAIAEoAhAhBSABKAIIIQYDQCAFQYACayEFIAYpAwAgBkEIaiEGQn+FQoCBgoSIkKDAgH+DIgJQDQALIAEgBTYCECABIAY2AgggASACQgF9IAKDNwMADAELIAEgAkIBfSACgzcDACABKAIQIgVFDQELIAEgB0EBazYCGCAFIAJ6p0ECdEHgA3FrQSBrIgEpAwAhAiABQQhqKQMAIQMgAUEQaikDACEEIABBGGogAUEYaikDADcDACAAQRBqIAQ3AwAgAEEIaiADNwMAIAAgAjcDAA8LIABBAzsBDAuHAgEEfyMAQSBrIgIkACACIAE2AgQgAkHYg8AAQQ4Q+Ao2AhwgAkEIaiACQQRqIAJBHGoQiAUgAigCCCEBAkACQAJAIAIoAhAiA0UEQCACKAIcIgNBhAFPBEAgAxABCyABEANBAUcNASAAIAIoAgQ2AgQgAEEcOgAAIAFBgwFLDQIMAwsgAigCFCEEIAIoAgwhBSAAIAE2AgQgAEEYOgAAIABBEGogBDYCACAAQQxqIAM2AgAgAEEIaiAFNgIAIAIoAhwiAEGEAU8EQCAAEAELIAIoAgQiAUGEAUkNAgwBCyAAQRw6AAAgACABNgIEIAIoAgQiAUGDAU0NAQsgARABCyACQSBqJAAL7g4CD38DfiMAQaABayIHJAAgB0HQAGohCiMAQYACayIFJAAgBSABNgIMIAVBEGogBUEMahDwBiAFQbABaiEEIAUoAhQiDCECIAUoAhghBiMAQUBqIgMkAAJAAkACQAJAAkAgBkUEQEEAIQZBASEIQQMhAgwBCyACLQAAIglBwwBGBEAgAyAGNgIUIAMgBkEBazYCDCADIAI2AhAgA0EBNgIYIAMgAkEBajYCCCADQSBqIANBCGoQkQICfyADKAIgIgJFBEAgAykCJCIRQv8Bg0IAUgRAIBFCIIinIQhCgICAgLACIRFBAwwCC0ETIQhBE0EBEPAJIgJFDQUgAkEPakGXqcIAKAAANgAAIAJBCGpBkKnCACkAADcAACACQYipwgApAAA3AAAgAq1CgICAgLAChCERQQAMAQsgAygCJCEJIAMpAzghEiADNQIsIREgAzUCMCETIANBADYCECADQoCAgIAQNwMIAkACQAJAIBJQDQAgCUEfTQ0CIBNCIIYgEYQhEUEAIQZBASEIA0AgA0EgaiILQRhqIg0gAkEYaikAADcDACALQRBqIg4gAkEQaikAADcDACALQQhqIg8gAkEIaikAADcDACADIAIpAAA3AyAgAygCCCAGRgRAIANBCGogBhCUBiADKAIMIQggAygCECEGCyAIIAZBBXRqIgsgAykDIDcAACALQRhqIA0pAwA3AAAgC0EQaiAOKQMANwAAIAtBCGogDykDADcAACADIAZBAWoiBjYCECASQgF9IhJQDQEgAkEgaiECIBFCgICAgIAEfCERIAlBIGsiCUEgTw0ACwwBCyADQShqIANBEGooAgAiAjYCACADIAMpAwgiETcDICAEQgA3AiggBEEANgIgIARCgICAgMAANwIYIARBADYCECAEQQA2AgQgBCARNwIwIARBOGogAjYCACAEQQA6AEggBEEANgJEIARCgICAgBA3AjwMBQsgAygCCEUNACAIENQBC0EgIAlrIQhBAwshAiARQiCIpyEJIBGnIQYMAQtBASEIQQFBARDwCSIGRQ0DIAZBwwA6AAAgCUEIdEEBciECQQEhCQsgAkH/AXFBA0cEQCAEQQI6AEggBCAJNgIMIAQgBjYCCCAEIAg2AgQgBCACNgIADAELIARBAjoASCAEQQI6AAALIANBQGskAAwCC0ETQQFB8PTEACgCACIAQcoEIAAbEQAAAAtBAUEBQfD0xAAoAgAiAEHKBCAAGxEAAAALAkACQCAFLQD4ASICQQJHBEAgBUHoAGoiAyAFQbABaiIEQcgAEOAKGiAKQcsAaiAEQcsAai0AADoAACAKIAUvAPkBOwBJIAVBIGoiBCADQcgAEOAKGiAKIARByAAQ4AogAjoASCAFKAIQBEAgDBDUAQsgBSgCDCICQYMBSw0BDAILIAVB8ABqIAVBuAFqKQMAIhE3AwAgBSAFKQOwASISNwNoIApBCGog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AkEBNgIcIAJBnPzBADYCGCACQQA2AiQgAkGc+sEANgIgIAJBADYCECABIAJBEGoQ5AcNAwsgAkEBNgIcIAJBpPzBADYCGCACQQE2AiQgAkEANgIQIAJB0QE2AiwgAiACQShqNgIgIAIgAkEMajYCKCABIAJBEGoQ5AcNAiADQQFrIQMgAEEMayIADQALC0EADAELQQELIAJBMGokAAv4AQEBfyMAQTBrIgIkAAJ/AkACQAJAIAAoAgBBAWsOAgECAAsgAkEkakEBNgIAIAJBLGpBATYCACACQfCpwgA2AiAgAkEANgIYIAJBgQI2AgwgAiAAQQRqNgIUIAIgAkEIajYCKCACIAJBFGo2AgggASACQRhqEOQHDAILIAJBJGpBATYCACACQSxqQQA2AgAgAkHQqcIANgIgIAJBkJvCADYCKCACQQA2AhggASACQRhqEOQHDAELIAJBJGpBATYCACACQSxqQQA2AgAgAkGsqcIANgIgIAJBkJvCADYCKCACQQA2AhggASACQRhqEOQHCyACQTBqJAAL8QEBBH8gAUEIaigCACICRQRAIABCgICAgMAANwIAIAAgAjYCCA8LAkACQAJAIAJB/////wBLDQAgAkEDdCIDQQBIDQAgAUEEaigCACEFIAJBgICAgAFJQQJ0IQQgAwR/IAMgBBDwCQUgBAsiAUUNASAAIAE2AgQgACACNgIAIAJBA3QhAyACIQQDQCADBEAgBEUNBCABIAUpAgA3AgAgA0EIayEDIAFBCGohASAFQQhqIQUgBEEBayIEDQELCyAAIAI2AggPCxDHCAALIAMgBEHw9MQAKAIAIgBBygQgABsRAAAACyACIAJBhLrCABCcBwAL2AECAX4EfyMAQYABayIEJAAgACkDACECQYABIQAgBEGAAWohBQJAAkADQCAARQRAQQAhAAwDCyAFQQFrIAKnIgNBD3EiBkEwQdcAIAZBCkkbajoAACACQhBaBEAgBUECayIFIANB/wFxIgNBBHZBMEHXACADQaABSRtqOgAAIABBAmshACACQoACVCACQgiIIQJFDQEMAgsLIABBAWshAAsgAEGBAUkNACAAQYABQejOxAAQjAoACyABQQFB+M7EAEECIAAgBGpBgAEgAGsQtgIgBEGAAWokAAvWAQIBfgR/IwBBgAFrIgQkACAAKQMAIQJBgAEhACAE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IAELIAIoAgRqIAUgABDgChogAiACKAIIIABqNgIIIANBEGokACAEC+0BAQN/IwBBIGsiAyQAAkACQCABIAEgAmoiAUsNAEEEIAAoAgAiAkEBdCIEIAEgASAESRsiASABQQRNGyIBQQxsIQQgAUGr1arVAElBAnQhBQJAIAIEQCADIAJBDGw2AhQgA0EENgIYIAMgAEEEaigCADYCEAwBCyADQQA2AhgLIAMgBCAFIANBEGoQygYgAygCBCECIAMoAgBFBEAgACABNgIAIABBBGogAjYCAAwCCyADQQhqKAIAIgBBgYCAgHhGDQEgAEUNACACIABB8PTEACgCACIAQcoEIAAbEQAAAAsQxwgACyADQSBqJAAL7gEBA38jAEEgayIDJAACQAJAIAEgASACaiIBSw0AQQQgACgCACICQQF0IgQgASABIARJGyIBIAFBBE0bIgFBxABsIQQgAUHiw4cPSUECdCEFAkAgAgRAIAMgAkHEAGw2AhQgA0EENgIYIAMgAEEEaigCADYCEAwBCyADQQA2AhgLIAMgBCAFIANBEGoQygYgAygCBCECIAMoAgBFBEAgACABNgIAIABBBGogAjYCAAwCCyADQQhqKAIAIgBBgYCAgHhGDQEgAEUNACACIABB8PTEACgCACIAQcoEIAAbEQAAAAsQxwgACyADQSBqJAAL7gEBBH8jAEEgayICJAACQAJAIAEgAUEBaiIBSw0AQQQgACgCACIDQQF0IgQgASABIARJGyIBIAFBBE0bIgFB0ABsIQQgAUGas+YMSUEDdCEFAkAgAwRAIAJBCDYCGCACIANB0ABsNgIUIAIgAEEEaigCADYCEAwBCyACQQA2AhgLIAIgBCAFIAJBEGoQygYgAigCBCEDIAIoAgBFBEAgACABNgIAIABBBGogAzYCAAwCCyACQQhqKAIAIgBBgYCAgHhGDQEgAEUNACADIABB8PTEACgCACIAQcoEIAAbEQAAAAsQxwgACyACQSBqJAAL7QEBA38jAEEgayIDJAACQAJAIAEgASACaiIBSw0AQQQgACgCACICQQF0IgQgASABIARJGyIBIAFBBE0bIgFBA3QhBCABQYCAgIABSUECdCEFAkAgAgRAIAMgAkEDdDYCFCADQQQ2AhggAyAAQQRqKAIANgIQDAELIANBADYCGAsgAyAEIAUgA0EQahDKBiADKAIEIQIgAygCAEUEQCAAIAE2AgAgAEEEaiACNgIADAILIANBCGooAgAiAEGBgICAeEYNASAARQ0AIAIgAEHw9MQAKAIAIgBBygQgABsRAAAACxDHCAALIANBIGokAAvQAQIBfwJ+AkACQCAAKQMAIgMgASkDACIEUQRAQX8CfyAALwEIRQRAIABBCmovAQAiAkERTw0DIABBDGoMAQsgAEEUaigCACECIABBEGooAgALAn8gAS8BCEUEQCABQQpqLwEAIgBBEU8NBCABQQxqDAELIAFBFGooAgAhACABQRBqKAIACyACIAAgACACSxsQ4QoiASACIABrIAEbIgBBAEcgAEEASBsPC0F/QQEgAyAEVBsPCyACQRBBmNTCABCNCgALIABBEEGo1MIAEI0KAAvOCAIHfwN+IwBBEGsiAyQAIAAoAgAhACABKAIAQbrMxABBASABKAIEKAIMEQIAIQIgA0EBOgAHIANBADsABSADIAI6AAQgAyABNgIAIAAoAggiBwRAIAAoAgwiAUEIaiEAIAEpAwBCf4VCgIGChIiQoMCAf4MhCQNAIAlQBEADQCABQYABayEBIAApAwAgAEEIaiEAQn+FQoCBgoSIkKDAgH+DIglQDQALCyADIAEgCXqnQQF0QfABcWtBEGsiAjYCCCADIAJBDGo2AgwgA0EIaiEFIwBBQGoiAiQAQQEhBgJAIAMtAAQNAAJAAkACQAJAIAMtAAZFBEAgAy0ABSEIAkAgAygCACIELQAYQQRxRQRAIAgNAQwFCyAIRQ0CDAMLIAQoAgBBnczEAEECIAQoAgQoAgwRAgBFDQMMBQsgAkEkakEBNgIAIAJBLGpBADYCACACQYTNxAA2AiAgAkGEr8QANgIoIAJBADYCGCACQRhqQazNxAAQ2ggACyAEKAIAQbnMxABBASAEKAIEKAIMEQIADQMLIANBAToAByACIANBB2o2AhAgAkH8y8QANgIcIAIgBCkCADcDCCAEKQIIIQogBCkCECELIAIgBC0AIDoAOCACIAQpAhg3AzAgAiALNwMoIAIgCjcDICACIAJBCGo2AhggBSACQRhqQbyawgAoAgARAQANAiACKAIYQejLxABBAiACKAIcKAIMEQIADQIMAQsgBSAEQbyawgAoAgARAQANASAEKAIAQejLxABBAiAEKAIEKAIMEQIADQEL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QQI2AiwgAkECNgIkIAJB1NfAADYCICACQQA2AhggAiACQQhqNgIoIAJBADYCOCACQoCAgIAQNwMwIAJBQGsiAEEDOgAgIABCgICAgIAENwIYIABBADYCECAAQQA2AgggAEGs0sAANgIEIAAgAkEwajYCACACQRhqIAAQ4gdFBEAgAigCNCACKAI4EAwgAigCMARAIAIoAjQQ1AELIAJB8ABqJAAPC0HE0sAAQTcgAkHoAGpB/NLAAEHY08AAEIcHAAvrAQECfyMAQSBrIgIkACAAKAIAIQMCQAJAIAEtABhBEHFBBHZFBEAgAS0AGEEgcUEFdgRAQQEhACADIAEQ7QZFDQIMAwtBASEAIAMgARCPCg0CDAELQQEhACADIAEQ7AYNAQsgAkEUakEBNgIAIAJBHGpBADYCACACQYSewgA2AhAgAkGQm8IANgIYIAJBADYCCCABIAJBCGoQ5AcNACADQQRqIQAgAS0AGEEQcUEEdkUEQCABLQAYQSBxQQV2RQRAIAAgARCPCiEADAILIAAgARDtBiEADAELIAAgARDsBiEACyACQSBqJAAgAAuIAgECfyMAQSBrIgUkAEGE9cQAQYT1xAAoAgAiBkEBajYCAAJAAkAgBkEASA0AQfT4xABB9PjEACgCAEEBaiIGNgIAIAZBAksNACAFIAQ6ABggBSADNgIUIAUgAjYCECAFQYibxAA2AgwgBUGcjsQANgIIQfT0xAAoAgAiAkEASA0AQfT0xAAgAkEBaiICNgIAQfT0xABB/PTEACgCAAR/IAUgACABKAIQEQAAIAUgBSkDADcDCEH89MQAKAIAIAVBCGpBgPXEACgCACgCFBEAAEH09MQAKAIABSACC0EBazYCACAGQQFLDQAgBA0BCwALIwBBEGsiAiQAIAIgATYCDCACIAA2AggAC9YBAQF/IwBBEGsiByQAIAcgACgCACABIAIgACgCBCgCDBECADoACCAHIAA2AgQgByACRToACSAHQQA2AgAgByADIAQQ+AQgBSAGEPgEIQECfyAHLQAIIgAgASgCACICRQ0AGiAAQf8BcSEBQQEgAQ0AGiAHKAIEIQECQCACQQFHDQAgBy0ACUUNACABLQAYQQRxDQBBASABKAIAQbjMxABBASABKAIEKAIMEQIADQEaCyABKAIAQZvJxABBASABKAIEKAIMEQIACyAH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OgAEIAIgATYCACADRQ0BA0AgAiAANgIMIAIgAkEMakHgmsIAEJEKIABBAWohACADQQFrIgMNAAsMAQsgAEEMaigCACEDIABBCGooAgAhACABKAIAQbvMxABBASABKAIEKAIMEQIAIQQgAkEAOgAFIAIgBDoABCACIAE2AgAgA0UNAANAIAIgADYCDCACIAJBDGpB4JrCABCRCiAAQQFqIQAgA0EBayIDDQALCyACLQAEBH9BAQUgAigCACIAKAIAQbzMxABBASAAQQRqKAIAKAIMEQIACyACQRBqJAALtAECAn8BfiMAQTBrIgIkACABQShqKQIAIQQgASgCJCEDIAJBCDoACCACIAEoAgg2AgwCQCADQQJGBEAgACACKQMINwMAIABBIGogAkEIaiIBQSBqKQMANwMAIABBGGogAUEYaikDADcDACAAQRBqIAFBEGopAwA3AwAgAEEIaiABQQhqKQMANwMADAELIAAgAzYCBCAAQRM6AAAgAEEIaiAENwIAIAJBCGoQpAMLIAJBMGokAAuaAQECfwJAAn8CQAJAIAAoAgAOAwEDAwALIABBGGooAgAiAgRAIABBFGooAgAhASACQQxsIQIDQCABKAIABEAgAUEEaigCABDUAQsgAUEMaiEBIAJBDGsiAg0ACwsgACgCEARAIABBFGooAgAQ1AELIABBCGooAgBFDQIgAEEEagwBCyAAQQRqCyAAKAIERQ0AQQRqKAIAENQBCwvSAQEFfwJAIAEoAgQiAiABKAIIRwRAIAEgAkEMajYCBCACLQAEIgNBBEcNAQsgAEEEOgAEDwsgAigCACEEAkAgAigCCCIBKAIMBEAgAUHIAGooAgAhBSABQcwAaigCACEGQTBBBBDwCSICRQ0BCyAAIAE2AiggAEEANgIkIAAgAjYCICAAQoCAgIDgADcCGCAAIAY2AhQgACAFNgIQIAAgATYCDCAAQQA2AgggACADOgAEIAAgBDYCAA8LQTBBBEHw9MQAKAIAIgBBygQgABsRAAAAC8YBAQF/IwBBEGsiCyQAIAAoAgAgASACIAAoAgQoAgwRAgAhASALQQA6AA0gCyABOgAMIAsgADYCCCALQQhqIAMgBCAFIAYQvAQgByAIIAkgChC8BCEBAn8gCy0ADCIAIAstAA1FDQAaIABB/wFxIQJBASACDQAaIAEoAgAiAC0A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AAJAAkACQAJAAkACQCAOQRBqIgQoAgAiDEEBaw4CAgABCyADQcQAakEBNgIAIANBzABqQQA2AgAgA0GQ38AANgJAIANBgNTAADYCSCADQQA2AjggA0EQaiADQThqEOQHDQMMAgsgA0HEAGpBATYCACADQcwAakEANgIAIANByN/AADYCQCADQYDUwAA2AkggA0EANgI4IANBEGogA0E4ahDkB0UNAQwCCyADQcQAakEBNgIAIANBzABqQQA2AgAgA0Gw38AANgJAIANBgNTAADYCSCADQQA2AjggA0EQaiADQThqEOQHDQELIAMoAgQgAygCCBACIQEgAygCAARAIAMoAgQQ1AELAkAgDA0AIAQoAgRFDQAgBEEIaigCABDUAQsgA0HQAGokAAwBC0Hs88AAQTcgA0E4akGk9MAAQYD1wAAQhwcACwsgACACNgIEIAAgATYCACAOQSBqJAAPCxDVCgALENYKAAuqAQIBfgN/AkAgACgCGCIERQ0AAkAgACkDACIBUARAIAAoAhAhAyAAKAIIIQIDQCADQaAHayEDIAIpAwAgAkEIaiECQn+FQoCBgoSIkKDAgH+DIgFQDQALIAAgAzYCECAAIAI2AgggACABQgF9IAGDNwMADAELIAAgAUIBfSABgzcDACAAKAIQIgNFDQELIAAgBEEBazYCGCADIAF6p0EDdkGMf2xqIQILIAILrQEBAX8CQCACBEACfwJAAkACQCABQQBOBEAgAygCCEUNAiADKAIEIgQNASABDQMgAgwECyAAQQhqQQA2AgAMBQsgAygCACAEIAIgARCwCQwCCyABDQAgAgwBCyABIAIQ8AkLIgMEQCAAIAM2AgQgAEEIaiABNgIAIABBADYCAA8LIAAgATYCBCAAQQhqIAI2AgAMAQsgACABNgIEIABBCGpBADYCAAsgAEEBNgIAC78BAQR/IAFBFGohAyABQQxqKAIAIQQgASgCCCEFIAFBHGooAgAiAiABKAIURgRAIAMgAhCMBiABKAIcIQILIAFBGGooAgAgAkEUbGoiAiAFNgIEIAJBADYCACACQQxqQgA3AgAgAkEIaiAENgIAIAEgASgCHEEBajYCHCAAIAMpAgA3AgwgACABKAIQNgIIIANBCGooAgAhAyABQoCAgIDAADcCFCABQQA2AhwgAEEUaiADNgIAIAAgASkCADcC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CyAEQSBqJAALrwEBAn8CQAJAAkACQCAALQAADgMAAwEDCyAALQAEQQNHDQIgAEEIaiIAKAIAIgEoAgAgASgCBCgCABEDACABKAIEIgJBBGooAgBFDQEgAkEIaigCABogASgCABDUAQwBCyAALQAEQQNHDQEgAEEIaiIAKAIAIgEoAgAgASgCBCgCABEDACABKAIEIgJBBGooAgBFDQAgAkEIaigCABogASgCABDUAQsgACgCABDUAQsLlAEBBH8jAEEgayICJAAgAiABNgIcAkAgACgCBCIDBH8gAkEIaiAAKAIAIAMgAkEcahCyBCACKAIIRQ0BIAJBFGooAgAhBCACKAIMIQUgAigCHCEBIAJBEGooAgAFQQALIQMgAiAANgIYIAIgATYCFCACIAQ2AhAgAiADNgIMIAIgBTYCCCACQQhqEJoECyACQSBqJAALowEBAX8jAEFAaiICJAAgACgCACEAIAJCADcDOCACQThqIAAQVCACQRRqQQI2AgAgAkEcakEBNgIAIAIgAigCPCIANgIwIAIgAigCODYCLCACIAA2AiggAkH9AzYCJCACQfDSwwA2AhAgAkEANgIIIAIgAkEoajYCICACIAJBIGo2AhggASACQQhqEOQHIAIoAigEQCACKAIsENQBCyACQUBrJAAL8AEBAn8jAEEwayICJAAgACgCACEAIAEoAgBBuszEAEEBIAEoAgQoAgwRAgAhAyACQQA6AAUgAiADOgAEIAIgATYCACAAKAIAIQEgAiAAKAIIQQAgACgCBCIAGzYCKCACIAA2AiAgAiABNgIcIAIgADYCECACIAE2AgwgAiAARUEBdCIANgIYIAIgADYCCCACQQhqENUDIgAEQANAIAIgADYCLCACIAJBLGpBsK/AABCRCiACQQhqENUDIgANAAsLIAItAAQEf0EBBSACKAIAIgAoAgBBpczEAEEBIABBBGooAgAoAgwRAgALIAJBMGokAAv1AwEFfyMAQUBqIgMkACADQQA2AgggA0KAgICAEDcDACADQRBqIgJBAzoAICACQoCAgICABDcCGCACQQA2AhAgAkEANgIIIAJB1PPAADYCBCACIAM2AgAjAEEwayIBJAACfwJAAkACQAJAIAAoAgAiBEECayIFQQAgBCAFTxtBAWsOAwECAwALIAFBJGpBATYCACABQSxqQQE2AgAgAUHMzsAANgIgIAFBADYCGCABQekANgIMIAEgADYCFCABIAFBCGo2AiggASABQRRqNgIIIAIgAUEYahDkBwwDCyAAQQhqIAIQsAEMAgsgAUEkakEBNgIAIAFBLGpBATYCACABQbDOwAA2AiAgAUEANgIYIAFB6gA2AgwgASAAQQRqNgIUIAEgAUEIajYCKCABIAFBFGo2AgggAiABQRhqEOQHDAELIAFBJGpBATYCACABQSxqQQA2AgAgAUHU78AANgIgIAFB8N/AADYCKCABQQA2AhggAiABQRhqEOQHCyABQTBqJABFBEAgAygCBCADKAIIEAIgAygCAARAIAMoAgQQ1AELAkACQAJAIAAoAgAiAkECayIEQQAgAiAETxsOAgABAgsgABDqBgwBCyAAQQhqEKQDCyADQUBrJAAPC0Hs88AAQTcgA0E4akGk9MAAQYD1wAAQhwcAC5kEAQV/IwBBQGoiAyQAIANBADYCCCADQoCAgIAQNwMAIANBEGoiAkEDOgAgIAJCgICAgIAENwIYIAJBADYCECACQQA2AgggAkHU88AANgIEIAIgAzYCACMAQTBrIgEkAAJ/AkACQAJAAkACQCAAKAIAIgRBAmsiBUEAIAQgBU8bQQFrDgQBAgMEAAsgAUEkakEBNgIAIAFBLGpBATYCACABQdzPwAA2AiAgAUEANgIYIAFB6QA2AgwgASAANgIUIAEgAUEIajYCKCABIAFBFGo2AgggAiABQRhqEOQHDAQLIAFBJGpBATYCACABQSxqQQA2AgAgAUHAz8AANgIgIAFBuMnAADYCKCABQQA2AhggAiABQRhqEOQHDAMLIABBCGogAhCwAQwCCyABQSRqQQE2AgAgAUEsakEANgIAIAFB1O/AADYCICABQfDfwAA2AiggAUEANgIYIAIgAUEYahDkBwwBCyABQSRqQQE2AgAgAUEsakEANgIAIAFB1O/AADYCICABQfDfwAA2AiggAUEANgIYIAIgAUEYahDkBwsgAUEwaiQARQRAIAMoAgQgAygCCBACIAMoAgAEQCADKAIEENQBCwJAAkACQCAAKAIAIgJBAmsiBEEAIAIgBE8bDgMAAgECCyAAEOoGDAELIABBCGoQpAMLIANBQGskAA8LQezzwABBNyADQThqQaT0wABBgPXAABCHBwALmQQBBX8jAEFAaiIDJAAgA0EANgIIIANCgICAgBA3AwAgA0EQaiICQQM6ACAgAkKAgICAgAQ3AhggAkEANgIQIAJBADYCCCACQdTzwAA2AgQgAiADNgIAIwBBMGsiASQAAn8CQAJAAkACQAJAIAAoAgAiBEECayIFQQAgBCAFTxtBAWsOBAECAwQACyABQSRqQQE2AgAgAUEsakEBNgIAIAFB3M/AADYCICABQQA2AhggAUHpADYCDCABIAA2AhQgASABQQhqNgIoIAEgAUEUajYCCCACIAFBGGoQ5AcMBAsgAUEkakEBNgIAIAFBLGpBADYCACABQYzQwAA2AiAgAUG4ycAANgIoIAFBADYCGCACIAFBGGoQ5AcMAwsgAEEIaiACELABDAILIAFBJGpBATYCACABQSxqQQA2AgAgAUHU78AANgIgIAFB8N/AADYCKCABQQA2AhggAiABQRhqEOQHDAELIAFBJGpBATYCACABQSxqQQA2AgAgAUHU78AANgIgIAFB8N/AADYCKCABQQA2AhggAiABQRhqEOQHCyABQTBqJABFBEAgAygCBCADKAIIEAIgAygCAARAIAMoAgQQ1AELAkACQAJAIAAoAgAiAkECayIEQQAgAiAETxsOAwACAQILIAAQ6gYMAQsgAEEIahCkAwsgA0FAayQADwtB7PPAAEE3IANBOGpBpPTAAEGA9cAAEIcHAAu0AQECfyMAQTBrIgIkACACIAE2AgwCQAJAAkACQEEDIAEtAAAiA0EKayADQQlNG0H/AXEOBAEAAAIACyACQRxqQQE2AgAgAkEkakEBNgIAIAJBtI7CADYCGCACQQA2AhAgAkG/AjYCLCACIAJBKGo2AiAgAiACQQxqNgIoIAJBEGpBvI7CABDaCAALIABBCzoAACAAIAEtAAE6AAEMAQsgACABNgIEIABBCjoAAAsgAkEwaiQAC/ABAQJ/IwBBMGsiAiQAIAAoAgAhACABKAIAQbrMxABBASABKAIEKAIMEQIAIQMgAkEAOgAFIAIgAzoABCACIAE2AgAgACgCACEBIAIgACgCCEEAIAAoAgQiABs2AiggAiAANgIgIAIgATYCHCACIAA2AhAgAiABNgIMIAIgAEVBAXQiADYCGCACIAA2AgggAkEIahDWAyIABEADQCACIAA2AiwgAiACQSxqQfCZwgAQkQogAkEIahDWAyIADQALCyACLQAEBH9BAQUgAigCACIAKAIAQaXMxABBASAAQQRqKAIAKAIMEQIACyACQTBqJAALrwEBAX8jAEEQayIGJAACQCABBEAgBiABIAMgBCAFIAIoAhARBwAgBigCBCEBAkAgBigCACIDIAYoAggiAk0EQCABIQQMAQsgA0ECdCEDIAJFBEBBBCEEIAEQ1AEMAQsgASADQQQgAkECdCIBELAJIgRFDQILIAAgAjYCBCAAIAQ2AgAgBkEQaiQADwtBydHDAEEyENcKAAsgAUEEQfD0xAAoAgAiAEHKBCAAGxEAAAALjgEBAn8gACgCCCICIAAoAgBGBEAgACACQQEQ8gULIAAoAgQhAwJAIAJFBEAgAkUNAUEAIAIQmQcACyADQRxqIAMgAkEcbBDfChoLIAMgASkCADcCACAAIAJBAWo2AgggA0EYaiABQRhqKAIANgIAIANBEGogAUEQaikCADcCACADQQhqIAFBCGopAgA3AgALkwEBB38jAEEQayIEJAAgACgCCCIDIAAoAgQiBSADIAVLGyEGIAAoAgAhBwJ/AkADQEEAIAJFDQIaIAMgBkYEQCAEQQU2AgAMAgsgACADQQFqIgU2AgggAkEBayECIAMgB2ohCCABLQAAIAUhAyABQQFqIQEgCC0AAEYNAAsgBEEJNgIACyAAIAQQ/QcLIARBEGokAAudAQECfwJAIAAtAAAiAUEETQRAIAFBAkcNASAALQAEQQNHDQEgAEEIaigCACIBKAIAIAEoAgQoAgARAwAgASgCBCICQQRqKAIABEAgAkEIaigCABogASgCABDUAQsgACgCCBDUAQ8LIAAoAgQgAEEIaiIBKAIAKAIAEQMAIAEoAgAiAUEEaigCAEUNACABQQhqKAIAGiAAKAIEENQBCwudAQEDfyMAQRBrIgIkACACECIiAzYCCCAAIAFHBEADQCACIAEoAgAQ0wggAiACKAIAIAIoAgQQ7Ag2AgwgAkEMahD5CiEDIAIoAgwiBEGEAU8EQCAEEAELIAFBBGohASACIAM2AgwgAkEIaiACQQxqEIEKIAIoAgwiA0GEAU8EQCADEAELIAAgAUcNAAsgAigCCCEDCyACQRBqJAAgAwugAQIFfwF+IAEoAgAiAkEBaiEEIAEoAgghBSABKAIMIgEpAwAhByACBH8gASAEQQJ0QQdqQXhxIgNrIQYgAiADakEJaiEDQQgFQQALIQIgACAGNgIgIAAgBTYCGCAAIAE2AhAgAEEoaiACNgIAIABBJGogAzYCACAAIAEgBGo2AgwgACABQQhqNgIIIAAgB0J/hUKAgYKEiJCgwIB/gzcDAAvCAQEFfyMAQRBrIgIkAAJ/AkACQAJAAkACQCAAKAIIIgEgACgCBCIDSQRAIAAoAgAhBANAAkAgASAEai0AACIFQQlrDiQAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAYDCyAAIAFBAWoiATYCCCABIANHDQALCyACQQM2AgAMBAsgBUH9AEYNAQsgAkETNgIADAILIAAgAUEBajYCCEEADAILIAJBEjYCAAsgACACEPwHCyACQRBqJAALrgEBAn8jAEEwayIDJAAgAyACNwMIAn8CQCABLQACRQRAIAJC/////////w98Qv////////8fVA0BIANBsgE2AhQgAyADQQhqNgIQIANBATYCLCADQQI2AiQgA0Hg/sAANgIgIANBADYCGCADIANBEGo2AiggA0EYahCeByEEQQEMAgsgAhAQIQRBAAwBCyACuRAFIQRBAAshASAAIAQ2AgQgACABNgIAIANBMGokAAvpAQECfyMAQTBrIgIkACABKAIAQbrMxABBASABKAIEKAIMEQIAIQMgAkEAOgAFIAIgAzoABCACIAE2AgAgACgCACEBIAIgACgCCEEAIAAoAgQiABs2AiggAiAANgIgIAIgATYCHCACIAA2AhAgAiABNgIMIAIgAEVBAXQiADYCGCACIAA2AgggAkEIahDWAyIABEADQCACIAA2AiwgAiACQSxqQfCZwgAQkQogAkEIahDWAyIADQALCyACLQAEBH9BAQUgAigCACIAKAIAQaXMxABBASAAQQRqKAIAKAIMEQIACyACQTBqJAALjQEBAn8CQAJAAkAgACgCAA4CAgEACyAAQQhqEKQDDAELIAAoAgQEQCAAQQhqKAIAENQBCwJAAkACQCAALQAQIgFBEmsiAkEAIAEgAk8bDgMAAQIDCyAAQRBqEKQDDwsgAEEYaigCAEUNASAAQRxqKAIAENQBDwsgAEEYaigCAEUNACAAQRxqKAIAENQBCwueAQEBfyMAQSBrIgQkACAEIAIoAgAQADYCDCAEIAMoAgAQADYCHCAEQRBqIAEgBEEMaiAEQRxqEPkHIAQoAgwhAQJAIAQtABAEQCAAIAE2AgQgAEEBOgAAIABBCGogBCgCFDYCAAwBCyAAIAQtABE6AAEgAEEAOgAAIAFBhAFJDQAgARABCyAEKAIcIgBBhAFPBEAgABABCyAEQSBqJAALjQEBA38jAEGAAWsiAyQAIAAoAgAhAANAIAIgA2pB/wBqIABBD3EiBEEwQdcAIARBCkkbajoAACACQQFrIQIgAEEPSyAAQQR2IQANAAsgAkGAAWoiAEGBAU8EQCAAQYABQejOxAAQjAoACyABQQFB+M7EAEECIAIgA2pBgAFqQQAgAmsQtgIgA0GAAWokAAuMAQEDfyMAQYABayIDJAAgACgCACEAA0AgAiADakH/AGogAEEPcSIEQTBBNyAEQQpJG2o6AAAgAkEBayECIABBD0sgAEEEdiEADQALIAJBgAFqIgBBgQFPBEAgAEGAAUHozsQAEIwKAAsgAUEBQfjOxABBAiACIANqQYABakEAIAJrELYCIANBgAFqJAAL4wMCCX8BfiMAQRBrIgEkAAJAIAAEQCAAKAIAIgJBf0cNARDWCgALENUKAAsgACACQQFqNgIAIABBBGohAgJAQQFBARDwCSIDBEAgAUEBNgIIIAEgAzYCBCABQQE2AgAgA0HDADoAACACQTRqKAIAIQUgAkE4aigCACIGrSEKQQEhB0EBIQIDQCAKp0H/AHEgCkL/AFYiCEEHdHIhCSABIAIgB0cEfyACBSABIAdBARCcBiABKAIEIQMgASgCACEHIAEoAggLIgRBAWoiAjYCCCADIARqIAk6AAAgCkIHiCEKIAgNAAsgBgRAIAZBBXQhBgNAIAcgAmtBH00EQCABIAJBIBCcBiABKAIAIQcgASgCBCEDIAEoAgghAgsgAiADaiIEIAUpAAA3AAAgASACQSBqIgI2AgggBEEYaiAFQRhqKQAANwAAIARBEGogBUEQaikAADcAACAEQQhqIAVBCGopAAA3AAAgBUEgaiEFIAZBIGsiBg0ACwsMAQtBAUEBQfD0xAAoAgAiAEHKBCAAGxEAAAALIAEgASgCBCICIAEoAggQ7Ag2AgwgAUEMahD5CiABKAIMIgNBhAFPBEAgAxABCyABKAIABEAgAhDUAQsgACAAKAIAQQFrNgIAIAFBEGokAAukAQECfyMAQTBrIgMkACADIAI3AwgCfwJAIAEtAAJFBEAgAkKAgICAgICAEFQNASADQbMBNgIUIAMgA0EIajYCECADQQE2AiwgA0ECNgIkIANB4P7AADYCICADQQA2AhggAyADQRBqNgIoIANBGGoQngchBEEBDAILIAIQESEEQQAMAQsgAroQBSEEQQALIQEgACAENgIEIAAgATYCACADQTBqJAALpwEBBH8CQAJAAkAgASgCACIEEEwiAUUEQEEBIQMMAQsgAUEATiICRQ0BIAEgAhDwCSIDRQ0CCyAAIAM2AgQgACABNgIAEFYiAhBIIgUQSiEBIAVBhAFPBEAgBRABCyABIAQgAxBLIAFBhAFPBEAgARABCyACQYQBTwRAIAIQAQsgACAEEEw2AggPCxDHCAALIAEgAkHw9MQAKAIAIgBBygQgABsRAAAAC5oBAgV/AX4gASgCACICQQFqIQQgASgCCCEFIAEoAgwiASkDACEHIAIEfyABIARBBXQiA2shBiACIANqQQlqIQNBCAVBAAshAiAAIAY2AiAgACAFNgIYIAAgATYCECAAQShqIAI2AgAgAEEkaiADNgIAIAAgASAEajYCDCAAIAFBCGo2AgggACAHQn+FQoCBgoSIkKDAgH+DNwMAC6IFAQh/IwBBEGsiBiQAAkACQCAARQ0AIAAoAgANASAAQX82AgAgAUUNACABKAIADQEgAUF/NgIAIAFBKGohAyMAQcABayICJAAgAEEoaiIFLQAMIQQgAkEFaiAFQQ1qQcMAEOAKGiAFQQI6AAwCQCAEQQJGDQAgBSgCACAFQdAAaiAFKAIEIgQgBSgCCCIIEM8HIAJBqAFqIAJBQGspAAA3AwAgAkGgAWogAkE4aikAADcDACACQZgBaiACQTBqKQAANwMAIAJBkAFqIAJBKGopAAA3AwAgAkGIAWogAkEgaikAADcDACACQYABaiACQRhqKQAANwMAIAJB8ABqIglBCGogAkEQaikAADcDACACIAIpAAg3A3AgAkEANgK0ASACQcgAaiAJIAVB4ABqIAJBsAFqQgBCABDGASAEIAgQkwFFDQAgBBDUAQsgAy0ADCEEIAJBBWogA0ENakHDABDgChogA0ECOgAMAkAgBEECRg0AIAMoAgAgA0HQAGogAygCBCIEIAMoAggiCBDPByACQagBaiACQUBrKQAANwMAIAJBoAFqIAJBOGopAAA3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CikDIDcDCCAKKAIYIQkgCigCHCIBQQlHBEAgBiAHKQMANwMAIAogATYCHCAKIAk2AhggCiAKKQMINwMgQQEhECMAQUBqIgckACAHQQA2AgggB0KAgICAEDcDACAHQRBqIgZBAzoAICAGQoCAgICABDcCGCAGQQA2AhAgBkEANgIIIAZB1PPAADYCBCAGIAc2AgAjAEFAaiIDJAACfwJAAkACQAJAAkBBASAKQRhqIggoAgQiAUEEayABQQNNG0EBaw4EAQIDBAALIAMgCEEIajYCDCADQRBqIg9BDGpBAjYCACADQSRqQQI2AgAgA0EoaiIBQQxqQesANgIAIANB/OTAADYCGCADQQA2AhAgA0GLATYCLCADIAhBDGo2AjwgAyABNgIgIAMgA0EMajYCMCADIANBPGo2AiggBiAPEOQHDAQLIANBHGpBATYCACADQSRqQQE2AgAgA0GE7cAANgIYIANBADYCECADQZMBNgIsIAMgCDYCPCADIANBKGo2AiAgAyADQTxqNgIoIAYgA0EQahDkBwwDCyADQRxqQQE2AgAgA0EkakEBNgIAIANB5OzAADYCGCADQQA2AhAgA0GVATYCLCADIAhBCGo2AjwgAyADQShqNgIgIAMgA0E8ajYCKCAGIANBEGoQ5AcMAgsgA0EcakEBNgIAIANBJGpBATYCACADQcTswAA2AhggA0EANgIQIANB6gA2AiwgAyAIQQhqNgI8IAMgA0EoajYCICADIANBPGo2AiggBiADQRBqEOQHDAELIANBHGpBATYCACADQSRqQQE2AgAgA0Gk7MAANgIYIANBADYCECADQeoANgIsIAMgCEEIajYCPCADIANBKGo2AiAgAyADQTxqNgIoIAYgA0EQahDkBwshASADQUBrJAACQCABRQRAIAcoAgQgBygCCBACIQ8gBygCAARAIAcoAgQQ1AELAkACQAJAAkBBASAIKAIEIgFBBGsgAUEDTRsOAwABAgMLIAhBDGooAgAEQCAIQRBqKAIAENQBCyAIKAIIIgFBhAFJDQIgARABDAILAkACQCABDgQDAQADAAsgCEEMaigCAARAIAhBEGooAgAQ1AELIAgoAggiAUGEAUkNAiABEAEMAgsgCEEMaigCACIBRQ0BIAhBCGooAgBFDQEgARDUAQwBCyAIQQxqKAIADQAgCEEQaigCACAI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CGohBiMAQfAAayIDJAAgA0HIAGogAhCEBQJAAkACQCADLQBIRQRAIANBPWoiAiADQeEAaikAADcAACADQThqIgcgA0HcAGopAgA3AwAgA0EjaiAHKQMANwAAIANBKGogAikAADcAACADIAMtAEs6ABIgAyADLwBJOwEQIAMgA0HUAGopAgAiCDcDMCADIAg3ABsgAyADKQJMNwATIAZBgAFqIANBEGoQrQUiAg0BQYEBIQIMAgsgBSADKQJMNwIADAILIANBCGogAhDTCCADIAMoAgggAygCDBDsCDYCSCADQcgAahD5CiECIAMoAkgiBkGEAUkNACAGEAELIAVBhIDEADYCBCAFIAI2AgALIANB8ABqJAAgBCkDCCEIQQAhAiABQQA2AgAgACAIQoCAgIBwg0KAgICAwIDACFIEfyAEIAg3AwgjAEHQAGsiASQAIAFBADYCCCABQoCAgIAQNwMAIAFBEGoiAkEDOgAgIAJCgICAgIAENwIYIAJBADYCECACQQA2AgggAkHU88AANgIEIAIgATYCAAJAAkACQCAEQQhqIgIoAgRBg4DEAEYEQCABQcQAakEBNgIAIAFBzABqQQA2AgAgAUGY48AANgJAIAFB8N/AADYCSCABQQA2AjggAUEQaiABQThqEOQHRQ0BDAILIAIgAUEQahD/Bg0BCyABKAIEIAEoAggQAiECIAEoAgAEQCABKAIEENQBCyABQdAAaiQADAELQezzwABBNyABQThqQaT0wABBgPXAABCHBwALQQEFQQALNgIIIAAgAjYCBCAAIAg+AgAgBEEQaiQADwsQ1QoACxDWCgALlAEBAX8jAEEQayICJAACQCABEAlBAUcEQCACIAEQoAQgAigCAEUEQCAAIAIpAgQ3AgQgAEEMaiACQQxqKAIANgIAIABBADYCAAwCCyAAIAIpAgQ3AgQgAEEMaiACQQxqKAIANgIAIABBATYCAAwBCyAAQQA2AgAgAEEIakEANgIAIAFBhAFJDQAgARABCyACQRBqJAALigEBA38CQAJAAkAgACgCACIBKAIIDgIAAQILIAFBEGooAgBFDQEgAUEMaigCABDUAQwBCyABQQxqLQAAQQNHDQAgAUEQaigCACICKAIAIAIoAgQoAgARAwAgAigCBCIDQQRqKAIABEAgA0EIaigCABogAigCABDUAQsgASgC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IAQoAkxBAnRqQeQCaigCACEGIAJBGGogAykDADcAACACQRBqIA4pAwA3AAAgAkEIaiASKQMANwAAIAIgBCkDADcAACACQSBqIAY2AgAgAkEkaiECIAFBAWohASAJIAdBIGoiB0cNAAsLIAUgATYCACANBEAgDxDUAQsgBEHQAGokAAwCCyABIAZB8PTEACgCACIAQcoEIAAbEQAAAAtBnJjCAEEWQdiowgAQkAoACyAIQQA2AsAHIAhCgICAgBA3A7gHIAhByAFqIhJBOGogCEH4AGoiAkE4aikDADcDACASQTBqIAJBMGopAwA3AwAgEkEoaiImIAJBKGopAwA3AwAgEkEgaiInIAJBIGopAwA3AwAgEkEYaiIjIAJBGGopAwA3AwAgEkEQaiIeIAJBEGopAwA3AwAgEkEIaiIkIAJBCGopAwA3AwAgCCAIKQN4NwPIASAIIBM2AowCIAggCEHoAGoiFzYCiAIgCEG4B2ohBkIAITdBACEPIwBB8AVrIgEkAAJAAkACQAJAAkACQAJAAkAgEigCECgCcEGw6gFNBEAgAUHgAGogEkHIABDgChogASgCaCIDIAEoAmQiBWshAiABKAJwIQdBBCEEIAMgBUcEQCACQfn///8HSSIERQ0EIAIgBEECdCILEPAJIgRFDQMLIAQgBSACEOAKIgMgAkEMbiIJQQxsaiELIAFB+ABqLQAAIg1BBEcEQCABKAJ0IQICQCABQYQBaigCAEUEQCABQQA2AvgBDAELIAFBhAJqIAFBkAFqEO8FIAEgAUGcAWooAgA2ApACIAEgAUGMAWooAgA2AoACIAEgAUH8AGopAgA3A/ABIAEgASkChAE3A/gBCyABQesEaiABQfABaiIFQQhqKQMANwAAIAFB8wRqIAVBEGopAwA3AAAgAUH7BGogBUEYaikDADcAACABQYMFaiABQZACaigCADYAACABIAEpA/ABNwDjBCABQcADaiIFQQhqIAFB4ARqIgRBCGopAAA3AwAgBUEQaiAEQRBqKQAANwMAIAVBGGogBEEYaikAADcDACAFQR9qIARBH2opAAA3AAAgASABKQDgBDcDwAMLIAFBmAVqIAFB3wNqKQAANwAAIAFBkQVqIAFB2ANqKQMANwAAIAFBiQVqIAFB0ANqKQMANwAAIAFBgQVqIAFByANqKQMANwAAIAEgASkD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AiALRwRAIAVB+f///wdJIgJFDQQgBSACQQJ0IgIQ8AkiBEUNDgsgBCALIAUQ4AoiCyAFQQxuIg5BDGxqIRMgB0EYai0AACIRQQRHBEAgBygCFCEFAkAgB0EkaigCAEUEQCADQQA2AiAMAQsgA0EsaiAHQTBqEO8FIAMgB0E8aigCADYCOCADIAdBLGooAgA2AiggAyAHQRxqKQIANwMYIAMgBykCJDcDIAsgA0HzAGogA0EYaiICQQhqKQMANwAAIANB+wBqIAJBEGopAwA3AAAgA0GDAWogAkEYaikDADcAACADQYsBaiADQThqKAIANgAAIAMgAykDGDcAayADQUBrIgJBCGogA0HoAGoiBEEIaikAADcDACACQRBqIARBEGopAAA3AwAgAkEYaiAEQRhqKQAANwMAIAJBH2ogBEEfaikAADcAACADIAMpAGg3A0ALIANBoAFqIANB3wBqKQAANwAAIANBmQFqIANBQGsiAkEYaikDADcAACADQZEBaiADQdAAaikDADcAACADQYkBaiACQQhqKQMANwAAIAMgAykDQDcAgQEgAyAROgCAASADIAU2AnwgAyANNgJ4IAMgCzYCdCADIBM2AnAgAyALNgJsIAMgDjYCaCADIAdBQGspAgA3A6gBIANBEGohBSMAQYABayICJAAgBigCCCEEIAJBADYCICACIAY2AiQgAkEANgIIIAJBKGoiDSADQegAaiILQcgAEOAKGiACQfAAaiANEMUEAkACQCACLQB0QQRHBEADQCACKAJoIg5BCGooAgAiEyACKAJ4QSRqKAIAIg1NDQIgAkEIakIBIA5BBGooAgAgDUECdGo1AgAQnAIgAkHwAGogAkEoahDFBCACLQB0QQRHDQALCyACKAIoBEAgAigCNBDUAQsCQCACQUBrIg0tAABBBEYNACACQcwAaigCAEUNACACQdgAaigCAEUNACACQdwAaigCABDUAQsgDSACQQhqIg1BGGopAwA3AwAgAkEoaiIOQRBqIA1BEGopAwA3AwAgDkEIaiANQQhqKQMANwMAIAIgAikDCDcDKCACIA4QwAIgBSACKAIEIARqNgIEIAUgBDYCACACQYABaiQADAELIA0gE0HUlMEAEJwHAAsgAygCFCENIAMoAhAhDiAGKAIIIQUgA0EANgJYIAMgBjYCXCADQgA3A2AgA0EA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IQQgAyAFRwRAIAJB+f///wdJIgRFDQQgAiAEQQJ0IgsQ8AkiBEUNAwsgBCAFIAIQ4AoiAyACQQxuIglBDGxqIQsgAS0AeCINQQRHBEAgASgCdCECAkAgAUGEAWooAgBFBEAgAUEANgL4AQwBCyABQYQCaiABQZABahDvBSABIAFBnAFqKAIANgKQAiABIAFBjAFqKAIANgKAAiABIAFB/ABqKQIANwPwASABIAEpAoQBNwP4AQsgAUHrBGogAUHwAWoiBUEIaikDADcAACABQfMEaiAFQRBqKQMANwAAIAFB+wRqIAVBGGopAwA3AAAgAUGDBWogAUGQAmooAgA2AAAgASABKQPwATcA4wQgAUHAA2oiBUEIaiABQeAEaiIEQQhqKQAANwMAIAVBEGogBEEQaikAADcDACAFQRhqIARBGGopAAA3AwAgBUEfaiAEQR9qKQAANwAAIAEgASkA4AQ3A8ADCyABQZgFaiABQd8DaikAADcAACABQZEFaiABQdgDaikDADcAACABQYkFaiABQdADaikDADcAACABQYEFaiABQcgDaikDADcAACABIAEpA8ADNwD5BCABIAEpA6ABNwOgBSABIA06APgEIAEgAjYC9AQgASAHNgLwBCABIAM2AuwEIAEgCzYC6AQgASADNgLkBCABIAk2AuAEIwBBgAFrIgIkACAGKAIIIQUgAkEANgIgIAIgBjYCJCACQQA2AgggAkEoaiIEIAFB4ARqQcgAEOAKGiACQfAAaiAEEMUEIAItAHRBBEcEQANAQgMhNwJAAkACQAJAQQMgAigCeCIELQAAIgNBCmsgA0EJTRtB/wFxQQFrDgMDAAECC0IFITcMAgtCASE3DAELIAQtAAFBA3RB8LjCAGopAwAhNwsgAkEIakIBIDcQnAIgAkHwAGogAkEoahDFBCACLQB0QQRHDQALCyACKAIoBEAgAigCNBDUAQsCQCACQUBrIgQtAABBBEYNACACQcwAaigCAEUNACACQdgAaigCAEUNACACQdwAaigCABDUAQsgBCACQQhqIgRBGGopAwA3AwAgAkEoaiIDQRBqIARBEGopAwA3AwAgA0EIaiAEQQhqKQMANwMAIAIgAikDCDcDKCACIAMQwAIgASACKAIEIAVqNgIEIAEgBTYCACACQYABaiQAIAEoAmgiAyABKAJkIgVrIQIgASgCBCErIAEoAgAhLCABKAJwIQdBBCEEIAMgBUcEQCACQfn///8HSSIERQ0EIAIgBEECdCILEPAJIgRFDQMLIAQgBSACEOAKIgMgAkEMbiIJQQxsaiELIAEtAHgiDUEERwRAIAEoAnQhAgJAIAFBhAFqKAIARQRAIAFBADYC+AEMAQsgAUGEAmogAUGQAWoQ7wUgASABQZwBaigCADYCkAIgASABQYwBaigCADYCgAIgASABQfwAaikCADcD8AEgASABKQKEATcD+AELIAFB6wRqIAFB8AFqIgVBCGopAwA3AAAgAUHzBGogBUEQaikDADcAACABQfsEaiAFQRhqKQMANwAAIAFBgwVqIAFBkAJqKAIANgAAIAEgASkD8AE3AOMEIAFBwANqIgVBCGogAUHgBGoiBEEIaikAADcDACAFQRBqIARBEGopAAA3AwAgBUEYaiAEQRhqKQAANwMAIAVBH2ogBEEfaikAADcAACABIAEpAOAENwPAAwsgAUGYBWogAUHfA2opAAA3AAAgAUGRBWogAUHYA2opAwA3AAAgAUGJBWogAUHAA2oiBUEQaikDADcAACABQYEFaiAFQQhqKQMANwAAIAEgASkDwAM3APkEIAEgASkDoAE3A6AFIAEgDToA+AQgASACNgL0BCABIAc2AvAEIAEgAzYC7AQgASALNgLoBCABIAM2AuQEIAEgCTYC4AQgCkEQaiEHQgAhNyMAQbADayIDJAAgA0EIaiABQeAEaiINQcgAEOAKGiAGKAIIIRMgA0HoAGpBADYCACADQeQAakGwxMEANgIAIANB8ABqQgA3AwAgA0H1AGpCADcAACADQQA2AmAgA0IANwNQIANBADYCmAEgAyAGNgKcASADQQA2AoABIAMoAhAiBSADKAIMIgRrIQIgAygCGCERQQQhCyAEIAVHBEAgAkH5////B0kiBUUNBCACIAVBAnQiBRDwCSILRQ0HCyALIAQgAhDgCiIJIAJBDG4iFEEMbGohCyADQSBqLQAAIhtBBEcEQCADKAIcIQICQCADQSxqKAIARQRAIANBADYCgAMMAQsgA0GMA2ogA0E4ahDvBSADIANBxABqKAIANgKYAyADIANBNGooAgA2AogDIAMgA0EkaikCADcD+AIgAyADKQIsNwOAAwsgA0GjAmogA0H4AmoiBUEIaikDADcAACAD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IAMoAmRFDQAgAygCaBDUAQsgByATNgIAIAcgEyAbaiICIA9qNgIMIAcgAq1CgYCAgBB+NwIEIANBsANqJAAgDSABQeAAakHIABDgChogCkHIAGohESMAQYACayIDJAAgDUEIaigCACIFIA1BBGooAgAiAmshCSANKAIQIQdBBCELAkACQCACIAVHBEAgCUH5////B0kiBUUNBiAJIAVBAnQiBRDwCSILRQ0BCyALIAIgCRDgCiIEIAlBDG4iD0EMbGohCyANQRhqLQAAIg5BBEcEQCANKAIUIQkCQCANQSRqKAIARQRAIANBADYCIAwBCyADQSxqIA1BMGoQ7wUgAyANQTxqKAIANgI4IAMgDUEsaigCADYCKCADIA1BHGopAgA3AxggAyANKQIkNwMgCyADQcsAaiADQRhqIgJBCGopAwA3AAAgA0HTAGogAkEQaikDADcAACADQdsAaiACQRhqKQMANwAAIANB4wBqIANBOGooAgA2AAAgAyADKQMYNwBDIANBqAFqIgJBCGogA0FAayIFQQhqKQAANwMAIAJBEGogBUEQaikAADcDACACQRhqIAVBGGopAAA3AwAgAkEfaiAFQR9qKQAANwAAIAMgAykAQDcDqAELIANB+ABqIANBxwFqKQAANwAAIANB8QBqIANBqAFqIgJBGGopAwA3AAAgA0HpAGogA0G4AWopAwA3AAAgA0HhAGogAkEIaikDADcAACADIAMpA6gBNwBZIAMgDjoAWCADIAk2AlQgAyAHNgJQIAMgBDYCTCADIAs2AkggAyAENgJEIAMgDzYCQCADIA1BQGspAgA3A4ABIANBEGohBSMAQYABayICJAAgBigCCCEEIAJBADYCICACIAY2AiQgAkEANgIIIAJBKGoiByADQUBrQcgAEOAKGiACQfAAaiAHEMUEIAItAHRBBEcEQANAIAJBCGpCASACKAJ4QTBqNQIAEJwCIAJB8ABqIAJBKGoQxQQgAi0AdEEERw0ACwsgAigCKARAIAIoAjQQ1AELAkAgAkFAayIHLQAAQQRGDQAgAkHMAGooAgBFDQAgAkHYAGooAgBFDQAgAkHcAGooAgAQ1AELIAcgAkEIaiIHQRhqKQMANwMAIAJBKGoiCUEQaiAHQRBqKQMANwMAIAlBCGogB0EIaikDADcDACACIAIpAwg3AyggAiAJEMACIAUgAigCBCAEajYCBCAFIAQ2AgAgAkGAAWokACADKAIUISUgAygCECEtIA1BCGooAgAiBSANQQRqKAIAIgRrIQIgDSgCECEJQQQhCyAEIAVHBEAgAkH5////B0kiBUUNBiACIAVBAnQiBRDwCSILRQ0JCyALIAQgAhDgCiEFIA0tABgiD0EERwRAIA0oAhQhCwJAIA1BJGooAgBFBEAgA0EANgIgDAELIANBLGogDUEwahDvBSADIA1BPGooAgA2AjggAyANQSxqKAIANgIoIAMgDUEcaikCADcDGCADIA0pAiQ3AyALIANBywBqIANBGGoiBEEIaikDADcAACADQdMAaiAEQRBqKQMANwAAIANB2wBqIARBGGopAwA3AAAgA0HjAGogA0E4aigCADYAACADIAMpAxg3AEMgA0GoAWoiBEEIaiADQUBrIgdBCGopAAA3AwAgBEEQaiAHQRBqKQAANwMAIARBGGogB0EYaikAADcDACAEQR9qIAdBH2opAAA3AAAgAyADKQBANwOoAQsgA0EYaiIEQR9qIgcgA0GoAWoiE0EfaikAADcAACAEQRhqIg4gE0EYaikDADcDACAEQRBqIBNBEGopAwAiNjcDACAEQQhqIBNBCGopAwAiNzcDACADQYEBaiA3NwAAIANBiQFqIDY3AAAgA0GRAWogDikDADcAACADQZgBaiAHKQAANwAAIAMgAykDqAEiNjcDGCADIDY3AHkgAyANKQJANwOgASADIA86AHggAyALNgJ0IAMgCTYCcCADIAU2AmwgAyAFNgJkIANBADYCUCADQQA2AkAgAyACQQxuIgI2AmAgAyAFIAJBDGxqNgJoIANBCGohC0EAIQlCACE4QQAhD0EAIRRBACEbQQAhDiMAQZABayIHJAAgBigCCCEcIAdBADYCICAHIAY2AiQgB0EANgIIIAdBKGogA0FAayI1QegAEOAKGiAHQeQAaiEiAkADQCAHKAIoIQICQAJAAkADQCACBEAgBygCMCIFIAcoAjQiCUEwaigCAEkEQCAHIAVBAWo2AjAgCUEsaigCACAFQQN0akEEaigCACEFIAUgBygCLCIJTw0FIAIgBUECdGo1AgAhOEIBITcMBAsgB0EANgIoCwJAAkACQAJAIActAGBBBGsOAgEFAAsgIhDlAiIEDQELA0ACf0EEIAcoAkwiBCAH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ADYCACAKQfQAaiACQQhqKQMANwIAIAogASkDiAM3AmwgCiABKQMQNwIgIApBKGogAUEQaiICQQhqKQMANwIAIApBMGogAkEQaikDADcCACAKIAEpA+ACNwIAIApBCGogAUHoAmopAwA3AgAgCkHoAGpBADYCACAKQoCAgIDAADcCYCAKQcQAaiArNgIAIAogLDYCQCAKQTxqICk2AgAgCiAqNgI4DAELIAFBEGoiAkEgakIBNwMAIAJByABqQgE3AwAgAUHQAGpCADcDACABQgA3AyggAUEANgIQIAFBADYCOCABQeAAaiICQdAAakIBNwMAIAJByABqQgA3AwAgAkEoakIBNwMAIAJBIGpCADcDACABQegBakIBNwMAIAFB4AFqQgA3AwAgAUEANgKQASABQQA2AmggAUIANwNgIAFBADYCuAEgAUHwAWoiAkHQAGpCATcDACACQcgAakIANwMAIAJBKGpCATcDACACQSBqQgA3AwAgAUEANgKgAiABQQA2AvgBIAFCADcD8AEgAUHUAmpCATcCACABQgA3AswCIAFBADoA3AIgAUEANgLIAiABQYADakIBNwMAIAFCADcD+AIgAUEANgLgAiABQYgDaiICQTBqQgE3AwAgAkEoakIANwMAIAJBCGpCATcDACABQQA2ApgDIAFCADcDiAMgAUHAA2oiAkHQAGpCATcDACACQcgAakIANwMAIAFBuARqQgE3AwAgAUGwBGpCADcDACACQShqQgE3AwAgAkEgakIANwMAIAFBADYC8AMgAUEANgKYBCABQQA2AsgDIAFCADcDwAMgAUHgBGoiAiASQcgAEOAKGiABQcAEaiACEMUEAkAgAS0AxARBBEYNACABQcADaiICQQhqIQ4gAUGYBGohEyACQTBqIREgAUHwAWoiAkEIaiEUIAJBMGohGyABQThqIQsgAUHABGpBBHIhDwJAAkADQCABKALIBCEFIAEoAqAFIgJBCGooAgAhAyACQQRqKAIAIQkgASgCpAUhDQJAAkAgASgCwAQiAigCACIHBEAgAyACQQRqKAIAIgRLDQEMCgsgAUEQahD1AiALEPUCDAELIAFBEGogCSAEQQJ0ajUCABDuASALIAetEO4BCyAFQcQAaigCACEHIAEiAgJ/IAUoAkBFBEAgDUEoaigCACIEIAdNDQMgDyANQSRqKAIAIAdBDGxqEN4DQQAMAQsCQCAHIAVByABqKAIAIgRyBEAgAyAETQ0KIAJCATcDyAQgAiAHrTcD0AQgAiAJIARBAnRqKAIANgLYBAwBCyACQgA3A8gEC0EBCzYCwAQgAkHgAGogAkHABGoQoQMgAyAFQSRqKAIAIgRNDQcgBUEgajUCACE2IBsgCSAEQQJ0ajUCABDuASAUIDYgAikD8AEiOH0iN0I/h0KAgICAgICAgIB/hSA3IDYgN1UgOEIAVXMbEOsBIAIgNjcD8AEgAQJ/IAEtANwCRSAFLQBMIgdBAEdzRQRAQQAhBCABKALYAiECIAE1AswCITcDQCA3p0H/AHEgN0L/AFYiDUEHdHIhHCA3QgeIITcgAiABKALQAkYEQCABQdACaiACQQEQnAYgASgC2AIhAgsgASgC1AIgAmogHDoAACABIAJBAWoiAjYC2AIgBEEBaiEEIA0NAAsgASAHOgDcAiABIAEoAsgCIARqNgLIAkEBDAELIAEoAswCQQFqCzYCzAJCAyE3AkACQAJAAkBBAyAFLQAAIgJBCmsgAkEJTRtB/wFxQQFrDgMDAQIACyAFLQABQQN0QcC/wQBqKQMAITcMAgtCBSE3DAELQgEhNwsgAUHgAmogNxDuASABQYgDagJ/AkACQAJAQQMgBS0AACICQQprIAJBCU0bQf8BcUECaw4CAQIACyABQQk6AMAEIAFBwARqDAILIAFBAjoAwAQgASAFKQMINwPIBCABQcAEagwBCyABQQo6AMAEIAEgBTYCxAQgBQsQ4AECQCABLQDABCICQQpGDQACQAJAAkAgAg4JAAEDAwMDAwMCAwsgASgCxARFDQIgASgCyAQQ1AEMAgsgAS0A2wRBGEcNASABKALEBCIEKAIAIQIgBCACQQFrNgIAIAJBAUcNASAPEK4IDAELIAEoAsQERQ0AIAEoAsgEENQBCyARIAVBMGoiBzUCABDuASAHKAIABEBBACEEQQQhAgNAIAVBLGooAgAgAmoiHCgCACINIANPDQQgHEEEazUCACE2IBMgCSANQQJ0ajUCABDuASAOIDYgASkDwAMiOH0iN0I/h0KAgICAgICAgIB/hSA3IDYgN1UgOEIAVXMbEOsBIAEgNjcDwAMgAkEIaiECIARBAWoiBCAHKAIASQ0ACwsgAUHABGogAUHgBGoQxQQgAS0AxARBBEcNAAsMAgsgByAEQYjEwgAQnAcACyANIANB1JTBABCcBwALIAEoAuAEBEAgASgC7AQQ1AELAkAgAUH4BGotAABBBEYNACABQYQFaigCAEUNACABQZAFaigCAEUNACABQZQFaigCABDUAQsgAUHgBGoiByABQRBqQdAAEOAKGiAKQewAaiAHIAYQ1AMgByABQeAAakGQARDgChogCkEgaiAHIAYQvAIgByABQfABakHYABDgChogCiEFIwBB8ABrIgMkACAGKAIIIQQgA0E4aiAHQdAAaikDADcDACADQTBqIAdByABqKQMANwMAIANBKGogB0FAaykDADcDACADQSBqIAdBOGopAwA3AwAgAyAHKQMwNwMYIANByABqIANBGGoQigIgAygCSCADKAJMIQkgAygCUCICIAYoAgAgBCIKa0sEQCAGIAQgAhCcBiAGKAIIIQoLIAYoAgQiDSAKaiAJIAIQ4AoaIAYgAiAKaiICNgIIBEAgCRDUAQsgA0EYaiIKQShqIAdBKGopAwAiNjcDACAKQSBqIAdBIGopAwAiNzcDACAKQRhqIAdBGGopAwAiODcDACAKQRBqIAdBEGopAwAiOTcDACAKQQhqIAdBCGopAwAiOjcDACADIAcpAwA3AxggA0HIAGoiCkEgaiA2NwMAIApBGGogNzcDACAKQRBqIDg3AwAgCkEIaiA5NwMAIAMgOjcDSCADQQhqIAoQiAIgAygCCCADKAIMIQsgAygCECIJIAYoAgAgAiIKa0sEQCAGIAIgCRCcBiAGKAIEIQ0gBigCCCEKCyAKIA1qIAsgCRDgChogBiAJIApqIgo2AggEQCALENQBCyAFIAI2AgggBSACNgIEIAUgBDYCACAFQQxqIAo2AgAgA0HwAGokACAGKAIIIQMgB0EQaiICIAFByAJqIgpBEGopAwA3AwAgB0EIaiIEIApBCGopAwA3AwAgASABKQPIAjcD4AQCfyABKALkBCIKRQRAIAIoAgAhAiABQewEaigCACELIAMMAQsgCq0hNyACKAIAIQIDQCA3p0H/AHEgN0L/AFYiCkEHdHIhByA3QgeIITcgAiABKALoBEYEQCAEIAJBARCcBiABKALwBCECCyABKALsBCILIAJqIAc6AAAgASACQQFqIgI2AvAEIAoNAAsgBigCCAshCiABKALoBCACIAYoAgAg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AiAGRwRAA0AgAUEIaiAGQeAAaikDACAGQYgCajUCAHxCAX0iNyA2fSI4Qj+HQoCAgICAgICAgH+FIDggNkIAVSA3IDhVcxsQnwIgASA3NwMoIDchNiACIAZBoAJqIgZHDQALCyABQdUAakIANwAAIAFCADcDUCABQQA2AkggAUHQkMEANgJEIAFBADYCQCABQgA3AzAgAUIANwNgA0ACQCABQegAaiABQTBqEIACAkACQAJAIAEoAmgiAgRAIAJBAmsNAQJAIAEoAkBFDQAgASgCREUNACABKAJIENQBCyABQTBqIgJBGGogAUEIaiIGQRhqKQMANwMAIAJBEGogBkEQaikDADcDACACQQhqIAZBCGopAwA3AwAgASABKQMINwMwIAEgAhC+AiAErSABKAIEIARqrUIghoQhNgwCCyABKQNwUA0CIAEgASkDYCI3IAEpA3giOHwiNkI/h0KAgICAgICAgIB/hSA2IDhCAFMgNiA3U3MbIjY3A2AgAUEIaiA2IAEpAygiOH0iN0I/h0KAgICAgICAgIB/hSA3IDYgN1UgOEIAVXMbEJ8CIAEgNjcDKAwECyABKQNwITYgASgCbCEGAkAgASgCQEUNACABKAJERQ0AIAEoAkgQ1AELAkAgASgCCEEDRw0AIAEoAgxFDQAgAUEQaigCABDUAQsgBkH/AXFBCEcNBAsgBSA2PgIAIAUgNkIgiD4CBCABQYABaiQADAELIAFBCGoQigMMAQsLIAgoAiwhKSAIKAIoISogCCAQNgLQASAIIAw2AswBIAggGTYCyAEgCCAWNgLYASAIIBc2AtQBIAhBIGohBUIAITYjAEGAAWsiASQAIAooAgghBCASKAIEIQYgEigCACECIAFBADYCICABIAo2AiQgAUIANwMoIAFBADYCCCACIAZHBEADQCABQQhqIAZByABqKQMAIjcgNn0iOEI/h0KAgICAgICAgIB/hSA4IDZCAFUgNyA4VXMbEJ8CIAEgNzcDKCA3ITYgAiAGQaACaiIGRw0ACwsgAUHVAGpCADcAACABQgA3A1AgAUEANgJIIAFB0JDBADYCRCABQQA2AkAgAUIANwMwIAFCADcDYANAAkAgAUHoAGogAUEwahCAAgJAAkACQAJAIAEoAmgiAgRAIAJBAmsNAQJAIAEoAkBFDQAgASgCREUNACABKAJIENQB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IAEoAgBBu8zEAEEBIAEoAgQoAgwRAgAhAyACQQA6AAUgAiADOgAEIAIgATYCACACIAA2AgwgAiACQQxqIgFB4JrCABCRCiACIABBAWo2AgwgAiABQeCawgAQkQogAiAAQQJqNgIMIAIgAUHgmsIAEJEKIAIgAEEDajYCDCACIAFB4JrCABCRCiACLQAEBH9BAQUgAigCACIAKAIAQbzMxABBASAAQQRqKAIAKAIMEQIACyACQRBqJAAL1gEBAX8jAEEQayICJAACfwJAAkACQAJAAkACQCAAKAIAQQFrDgUBAgMEBQALIAEoAgBBxtXBAEEMIAEoAgQoAgwRAgAMBQsgASgCAEG11cEAQREgASgCBCgCDBECAAwECyABKAIAQajVwQBBDSABKAIEKAIMEQIADAMLIAIgAEEEajYCDCABQYzVwQBBCiACQQxqQZjVwQAQugYMAgsgASgCAEH+1MEAQQ4gASgCBCgCDBECAAwBCyABKAIAQfTUwQBBCiABKAIEKAIMEQIACyACQRBqJAALuwgBDn8jAEEQayIJJAACQCAABEAgACgCAA0BIABBfzYCACMAQcABayICJAAgAEEoaiIDLQAMIQEgAkEFaiADQQ1qQcMAEOAKGiADQQI6AAwCQCABQQJGDQAgAygCACADQdAAaiADKAIEIgggAygCCCIEEM8HIAJBqAFqIAJBQGspAAA3AwAgAkGgAWogAkE4aikAADcDACACQZgBaiACQTBqKQAANwMAIAJBkAFqIAJBKGopAAA3AwAgAkGIAWogAkEgaikAADcDACACQYABaiACQRhqKQAANwMAIAJB8ABqIgFBCGogAkEQaikAADcDACACIAIpAAg3A3AgAkEANgK0ASACQcgAaiABIANB4ABqIAJBsAFqQgBCABDGASAIIAQQkwFFDQAgCBDUAQsCf0EAIQhBACADQeAAaiIDQaQCaigCACILRQ0AGiADQaACaigCACEFIANBuAJqIQcCQAJAAkAgAy8BtAIiAUECRgRAIANBwAFqKAIAIgEgBygCACIESwRAIANBvAFqKAIAIARBFGxqIg1BBGohBCALQaACbCEOIA1BDGohAyANQQhqIQgDQAJ/IAUgDmoiAUGUAWsvAQAEQCABQYgBaygCACEGIAFBjAFrKAIADAELIAFBkgFrLwEAIgZBEEsNBSABQZAB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AEEYRw0BIABBBGoiASgCACICKAIAIQAgAiAAQQFrNgIAIABBAUcNASABEK4IDwsgACgCBEUNACAAQQhqKAIAENQBCwt+AQF/IwBBMGsiAiQAIAIgATYCBCACIAA2AgAgAkEIaiIAQQxqQQM2AgAgAkEcakECNgIAIAJBIGoiAUEMakEfNgIAIAJBgK3EADYCECACQQA2AgggAkEfNgIkIAIgATYCGCACIAJBBGo2AiggAiACNgIgIABBtK3EABDaCAALfgEBfyMAQTBrIgIkACACIAE2AgQgAiAANgIAIAJBCGoiAEEMakEDNgIAIAJBHGpBAjYCACACQSBqIgFBDGpBHzYCACACQfCtxAA2AhAgAkEANgIIIAJBHzYCJCACIAE2AhggAiACQQRqNgIoIAIgAjYCICAAQYiuxAAQ2ggAC3sBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQQhqIgBBDGpBAzYCACADQRxqQQI2AgAgA0EgaiIBQQxqQR82AgAgA0GsrsQANgIQIANBADYCCCADQR82AiQgAyABNgIYIAMgA0EEajYCKCADIAM2AiAgACACENoIAAt+AQJ/IwBBMGsiASQAIAEgADYCBCABQRA2AgAgAUEIaiIAQQxqQQM2AgAgAUEcakECNgIAIAFBIGoiAkEMakEfNgIAIAFB3K7EADYCECABQQA2AgggAUEfNgIkIAEgAjYCGCABIAFBBGo2AiggASABNgIgIABB9K7EABDaCAALewEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBCGoiAEEMakECNgIAIANBHGpBAjYCACADQSBqIgFBDGpBHzYCACADQejJxAA2AhAgA0EANgIIIANBHzYCJCADIAE2AhggAyADNgIoIAMgA0EEajYCICAAIAIQ2ggAC/sCAQd/IwBBEGsiAyQAAkAgAARAIAAoAgANASAAQX82AgAjAEHAAWsiASQAIABBKGoiAi0ADCEEIAFBBWogAkENakHDABDgChogAkECOgAMAkAgBEECRg0AIAIoAgAgAkHQAGogAigCBCIEIAIoAggiBhDPByABQagBaiABQUBrKQAANwMAIAFBoAFqIAFBOGopAAA3AwAgAUGYAWogAUEwaikAADcDACABQZABaiABQShqKQAANwMAIAFBiAFqIAFBIGopAAA3AwAgAUGAAWogAUEYaikAADcDACABQfAAaiIHQQhqIAFBEGopAAA3AwAgASABKQAINwNwIAFBADYCtAEgAUHIAGogByACQeAAaiABQbABakIAQgAQxgEgBCAGEJMBRQ0AIAQQ1AELIAMgAkHgAGoQgAcgAUHAAWokACADKAIEIgEgAygCCEEFdGogARClBSADKAIABEAgARDUAQsgAEEANgIAIANBEGokAA8LENUKAAsQ1goAC58BAQJ/IwBBQGoiASQAIAFBADYCCCABQoCAgIAQNwMAIAFBEGoiAkEDOgAgIAJCgICAgIAENwIYIAJBADYCECACQQA2AgggAkGQ/8AANgIEIAIgATYCACAAIAIQ4gdFBEAgASgCBCABKAIIEAwgASgCAARAIAEoAgQQ1AELIAFBQGskAA8LQaj/wABBNyABQThqQeD/wABBvIDBABCHBwALsgIBAn8jAEEQayICJAAgAiAAKAIAIgBBLGo2AgAgAiAAQThqNgIEIAIgADYCCCACIABBKGo2AgwjAEEQayIAJAAgASgCAEHqkcIAQQogASgCBCgCDBECACEDIABBADoADSAAIAM6AAwgACABNgIIIABBCGpB9JHCAEEIIAJB/JHCABC8BEGMksIAQQggAkEEakGUksIAELwEQaSSwgBBBSACQQhqQaySwgAQvARBvJLCAEEGIAJBDGpBxJLCABC8BCEDAn8gAC0ADCIBIAAtAA1FDQAaQQEgAQ0AGiADKAIAIgEtABhBBHFFBEAgASgCAEGzzMQAQQIgASgCBCgCDBECAAwBCyABKAIAQaXMxABBASABKAIEKAIMEQIACyAAQRBqJAAgAkEQaiQAQf8BcUEARwucBwELfyMAQRBrIgokAAJAIAEEQCABKAIADQEgAUF/NgIAIApBCGohDSABQQhqIQQjAEHAAWsiBSQAAkACQCACEAoiB0EBTQRAIARBLGoiCC0AACEGIAUgBEEtaiILQcMAEOAKIQMgCEECOgAAAkAgBkECRg0AIAQoAiAgBEHwAGogBEEkaigCACIIIARBKGooAgAiDBDPByADQagBaiADQTtqKQAANwMAIANBoAFqIANBM2opAAA3AwAgA0HwAGoiBkEoaiADQStqKQAANwMAIANBkAFqIANBI2opAAA3AwAgA0GIAWogA0EbaikAADcDACADQYABaiADQRNqKQAANwMAIAZBCGogA0ELaikAADcDACADIAMpAAM3A3AgA0EANgK0ASADQcgAaiAGIARBgAFqIANBsAFqQgBCABDGASAIIAwQkwFFDQAgCBDUAQsgBEH8AGotAAAhCAJAIAcNACAIRQ0AIARB+ABqIgYoAgAhCSAGQQA2AgAgBEH0AGooAgAgCRCTAQtBACEGIAQgB0EARzoAfCAELQAsIQcgAyALQcMAEOAKIQMgBEECOgAsAkAgB0ECRg0AIAQoAiAgBEHwAGogBEEkaigCACIHIARBKGooAgAiDBDPByADQagBaiADQTtqKQAANwMAIANBoAFqIANBM2opAAA3AwAgA0HwAGoiC0EoaiADQStqKQAANwMAIANBkAFqIANBI2opAAA3AwAgA0GIAWogA0EbaikAADcDACADQYABaiADQRNqKQAANwMAIAtBCGogA0ELaikAADcDACADIAMpAAM3A3AgA0EANgK0ASADQcgAaiALIARBgAFqIANBsAFqQgBCABDGASAHIAwQkwFFDQAgBxDUAQsgBEH9AGogBC0A0QM6AABBggFBgwEgCBshBCACQYMBSw0BDAILIAVBITYCtAEgBUGUhsAANgKwASAFQQI2AkwgBSAFQbABajYCSCAFQQE2AhQgBUEBNgIMIAVBxJLAADYCCCAFQQA2AgAgBSAFQcgAajYCECAFQfAAaiAFELcDIAUoAnQiAyAFKAJ4EPMKIQQgBSgCcARAIAMQ1AELQQEhBiACQYQBSQ0BCyACEAELIA0gBDYCBCANIAY2AgAgBUHAAWokACAKKAIMIQIgCigCCCEEIAFBADYCACAAIARBAEc2AgggACACQQAgBBs2AgQgACACNgIAIApBEGokAA8LENUKAAsQ1goAC58BAQJ/IwBBQGoiASQAIAFBADYCCCABQoCAgIAQNwMAIAFBEGoiAkEDOgAgIAJCgICAgIAENwIYIAJBADYCECACQQA2AgggAkGwiMAANgIEIAIgATYCACAAIAIQ0gVFBEAgASgCBCABKAIIEAIgASgCAARAIAEoAgQQ1AELIAFBQGskAA8LQciIwABBNyABQThqQYCJwABB3InAABCHBwALugEBA38jAEEQayICJAAgACgCACIAQQhqKAIAIQMgAEEEaigCACEAIAEoAgBBu8zEAEEBIAEoAgQoAgwRAgAhBCAC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ACABKAIAQbvMxABBASABKAIEKAIMEQIAIQQgAkEAOgAFIAIgBDoABCACIAE2AgAgAwRAIANBA3QhAQNAIAIgADYCDCACIAJBDGpB8JrCABCRCiAAQQhqIQAgAUEIayIBDQALCyACLQAEBH9BAQUgAigCACIAKAIAQbzMxABBASAAQQRqKAIAKAIMEQIACyACQRBqJAALvQEBA38jAEEQayICJAAgACgCACIAQQhqKAIAIQMgAEEEaigCACEAIAEoAgBBu8zEAEEBIAEoAgQoAgwRAgAhBCACQQA6AAUgAiAEOgAEIAIgATYCACADBEAgA0HQAGwhAQNAIAIgADYCDCACIAJBDGpBgJvCABCRCiAAQdAAaiEAIAFB0ABrIgENAAsLIAItAAQEf0EBBSACKAIAIgAoAgBBvMzEAEEBIABBBGooAgAoAgwRAgALIAJBEGokAAuLAQIBfwJ+IwBBEGsiASQAQZD1xAApAwBQBEACfgJAIABFDQAgACkDACAAQgA3AwBCAVINACAAKQMQIQMgACkDCAwBCyABQgI3AwggAUIBNwMAIAEpAwghAyABKQMACyECQaD1xAAgAzcDAEGY9cQAIAI3AwBBkPXEAEIBNwMACyABQRBqJABBmPXEAAtpAQN/IAAoAgQiASgCCCICQQdqQXhxIAAoAgAiAGogASgCABEDAAJAIABBf0YNACAAIAAoAgQiA0EBazYCBCADQQFHDQAgASgCBEEEIAIgAkEETRsiAWpBB2pBACABa3FFDQAgABDUAQsLdAEBfyAAKAIIIgIgACgCAEYEQCAAIAIQiAYgACgCCCECCyAAKAIEIAJBHGxqIgIgASkCADcCACACQRhqIAFBGGooAgA2AgAgAkEQaiABQRBqKQIANwIAIAJBCGogAUEIaikCADcCACAAIAAoAghBAWo2AggLtwEBA38jAEEQayICJAAgACgCACIAQQRqKAIAIQMgACgCACEAIAEoAgBBu8zEAEEBIAEoAgQoAgwRAgAhBCACQQA6AAUgAiAEOgAEIAIgATYCACADBEAgA0EFdCEBA0AgAiAANgIMIAIgAkEMakHwmcIAEJEKIABBIGohACABQSBrIgENAAsLIAItAAQEf0EBBSACKAIAIgAoAgBBvMzEAEEBIABBBGooAgAoAgwRAgALIAJBEGokAAu1AQEDfyMAQRBr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AygChAIgAmsQ1AELIAMoAlAiAkGEAU8EQCACEAELIAMoAlhFDQkgAygCXCICQYQBSQ0JDAgLIANB4ABqIgJBGGogDi0AACIIOgAAIAJBEGogDCkDACIYNwMAIAJBCGogCikDACIZNwMAIAMgAykDgAEiGjcDYCAFIBo3AAAgBUEIaiAZNwAAIAVBEGogGDcAACAFQRhqIAg6AAAgAyAQNgDDASADIA06AMIBIAMgDzsBwAEgA0HoAWogA0HAAWogCxDCBAwBCwsgByADKQPoATcDACAHQRhqIANB6AFqIgJBGGopAwA3AwAgB0EQaiACQRBqKQMANwMAIAdBCGogAkEIaikDADcDACADKAJQIgJBhAFPBEAgAhABCyADKAJYRQ0GIAMoAlwiAkGDAUsNBQwGCyADQUBrIQVBASECAkAgA0HMAGoiBCgCABASQQFHBEBBACECDAELIAQoAgAQQCEECyAFIAQ2AgQgBSACNgIAIAMoAkBFDQMgAyADKAJENgJgIANBiAFqIANB4ABqEJ4JIANBADYClAEgA0EANgKAAUEAIQIgA0GQAWooAgAEQCADQYwBaigCACICIAMoAogBayIEQQAgAiAETxshAgsgA0HAAWoiBUEIaiACNgIAIANBATYCxAEgAyACNgLAASADQThqIQJBACEEIAUoAgRBAUcEf0EABSAFQQhqKAIAIgQgBSgCAEYLIQUgAiAENgIEIAIgBTYCACADKAI8IQIgAygCOCEEQZj1xAACfkGQ9cQAKQMAQgBSBEBBoPXEACkDACEYQZj1xAApAwAMAQsgA0EoaiIFQgI3AwggBUIBNwMAQZD1xABCATcDAEGg9cQAIAMpAzAiGDcDACADKQMoCyIZQgF8NwMAIANBwAFqIgVBIUGAICACIAJBgCBPG0EAIAQbEO4DIANBvAFqIAMoAswBNgIAIANBtAFqIAMpAsQBNwIAIAMgGDcDqAEgAyAZNwOgASADIAMoAsABIgI2ArABIAUgA0GAAWoQpQQCQCADLQDAAUUEQCADQcABakEBciECA0AgAy0A4QEiBUECRg0CIANB6AFqIgRBGGogAkEYaikAADcDACAEQRBqIAJBEGopAAA3AwAgBEEIaiACQQhqKQAANwMAIAMgAikAADcD6AEgA0GgAWogBCAFQQFxEMIEIANBwAFqIANBgAFqEKUE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AgQEQCABQSBqIAdBCGooAgA2AgAgASAHKQIANwMYC6cEQCAERAAAAAAAAODDZiECIAFBCGoiA0L///////////8AAn4gBJlEAAAAAAAA4ENjBEAgBLAMAQtCgICAgICAgICAfwtCgICAgICAgICAfyACGyAERP///////99DZBtCACAEIARhGzcDCCADQgE3AwALIAFB4ABqIghBGGoiCyABQQhqIgJBGGopAwA3AwAgCEEQaiIMIAJBEGopAwA3AwAgCEEIaiINIAJBCGopAwA3AwAgASABKQMINwNgIAFBKGohDiMAQaABayICJABBIGoiAxCYAyADLQAMIQUgA0ECOgAMAkAgBUECRwRAIAJByABqIgUgA0ENakHDABDgChogAygCACADKAIIIQogAygCBCEJIAJBCGoiBkE4aiIQIAJBgwFqKQAANwMAIAZBMGoiESACQfsAaikAADcDACAGQShqIhIgAkHzAGopAAA3AwAgBkEgaiITIAJB6wBqKQAANwMAIAZBGGoiFCACQeMAaikAADcDACAGQRBqIhUgAkHbAGopAAA3AwAgBkEIaiIGIAJB0wBqKQAANwMAIAIgAikASzcDCCADQdAAaiAJIAoQzwcgBUE4aiAQKQMANwMAIAVBMGogESkDADcDACAFQShqIBIpAwA3AwAgBUEgaiATKQMANwMAIAVBGGogFCkDADcDACAFQRBqIBUpAwA3AwAgBUEIaiAGKQMANwMAIAIgAikDCDcDSCACQZABaiIGQQhqIAhBGGooAgA2AgAgAiAIKQIQNwOQASAOIAUgA0HgAGogBiAIKQMAIAgpAwgQxgEgCSAKEJMBBEAgCRDUAQsgAkGgAWokAAwBC0GMxMAAQStBsMzAABCeCAALAkAgAS0AKEUEQEGBASECDAELIAsgAUHBAGopAAA3AwAgDCABQTlqKQAANwMAIA0gAUExaikAADcDACABIAEpACk3A2AgAUGAAWoiAkGAgMQANgIMIAJBnNLAADYCCCACIAFB4ABqIgM2AgQgAiADQSBqNgIAIAFBkAFqIgNBCGogAkEIaikDADcDACABIAEpA4ABNwOQASABQdAAaiADENMDIAEoAlQiAyABKAJYEAIhAiABKAJQRQ0AIAMQ1AELIAFBoAFqJAAgAEEANgIAIAdBEGokACACDwsQ1QoACxDWCgALbAEBfyMAQSBrIgIkAAJ/IAAoAgAiACgCBEGDgMQARgRAIAJBFGpBATYCACACQRxqQQA2AgAgAkGY48AANgIQIAJB8N/AADYCGCACQQA2AgggASACQQhqEOQHDAELIAAgARD/BgsgAkEgaiQAC3sBAn8gAUEEaigCACEDAkACQAJAIAFBCGooAgAiAUUEQEEBIQIMAQsgAUEASA0BIAFBARDwCSICRQ0CCyACIAMgARDgCiECIAAgATYCCCAAIAI2AgQgACABNgIADwsQxwgACyABQQFB8PTEACgCACIAQcoEIAAbEQAAAAtbAQN/IwBBIGsiAiQAIAEoAgQhAyABKAIAIAJBCGoiAUEQaiAAKAIAIgBBEGopAgA3AwAgAUEIaiAAQQhqKQIANwMAIAIgACkCADcDCCADIAEQ/QIgAkEgaiQAC2UBAX8jAEEgayIEJAAgBCABNgIEIAQgADYCACAEQQhqIgBBEGogAkEQaikCADcDACAAQQhqIAJBCGopAgA3AwAgBCACKQIANwMIQQAgBEGsmMAAIARBBGpBrJjAACAAIAMQ/AMAC3MBAX8jAEEQayICJAAgAiAAKAIAIgBBBGo2AgQgAiAAQRBqNgIIIAIgADYCDCABQfSmwABBEEGEp8AAQQggAkEEakGMp8AAQZynwABBCCACQQhqQaSnwABBtKfAAEEGIAJBDGpBvKfAABC8BiACQRBqJAALcwEBfyMAQRBrIgIkACACIAAoAgAiAEEEajYCBCACIABBEGo2AgggAiAANgIMIAFB9KbAAEEQQYSnwABBCCACQQRqQcynwABBnKfAAEEIIAJBCGpB3KfAAEG0p8AAQQYgAkEMakG8p8AAELwGIAJBEGokAAu3IQIifw1+IwBBEGsiByQAIABBCGohFSACIAAoAgAgACgCCCIFa0sEQCMAQSBrIgYkAAJAAkAgBSACIAVqIgVLDQBBBCAAKAIAIgtBAXQiEiAFIAUgEkkbIgUgBUEETRsiBUEHdCESIAVBgICACElBA3QhFgJAIAsEQCAGQQg2AhggBiALQQd0NgIUIAYgAEEEaigCADYCEAwBCyAGQQA2AhgLIAYgEiAWIAZBEGoQygYgBigCBCELIAYoAgBFBEAgACAFNgIAIABBBGogCzYCAAwCCyAGQQhqKAIAIgVBgYCAgHhGDQEgBUUNACALIAVB8PTEACgCACIAQcoEIAAbEQAAAAsQxwgACyAGQSBqJAAgACgCCCEFCyAHIAAoAgQ2AgggByAVNgIEIAcgBTYCACAHIQtBACEAQQAhB0EAIQZBACEVQQAhEkEAIRYjAEGQAWsiBCQAIAsoAgQhHCALKAIAIRcCQAJAAkACQAJAAkAgASACQQd0aiIdIAFHBEAgASEbIAsoAgggF0EHdGohHiAEQdAAaiIBQRBqIQwgAUEYaiEUIAFBBHIhHwNAAn8CQAJAAkACQAJAAkACQCAZIBtqIgMtAABBAWsOBgECAwQFBgALQoCAgIAgISUgA0Esai8BACIBQQJHBEAgA0EgaikDACEoAn8gAUUEQCADQS5qLwEAIQggA0E+ai8BACEVIANBPGovAQAhEiADQTRqKAIAIQUgA0EwaigCACEAQgAhJSADQThqKAIADAELIANBNGooAgAhAQJAIANBOGooAgAiAEUEQEEBIQUMAQsgAEEASA0MIABBARDwCSIFRQ0OCyAFIAEgABDgChpCgICAgBAhJSAACyEBIACtIAWtQiCGhCEpIANBKGooAgAhBgsgBEEwaiADQQRqEIcDIARBQGsgA0EQahDKBwJAIANBQGsiAC0AACICQQtGBEAgBEELOgBQIAQgA0HBAGotAAA6AFEMAQsgAkEKRgRAIARBCjoAUCAEIANBxABqKAIANgJUDAELIARB0ABqIAAQ/gILAkAgA0HsAGovAQAiAEECRgRAIARBAjsBfAwBCyADQeAAaikDACEmAn8gAEUEQCADQe4Aai8BACEgIANB/ABqKAIAISEgA0H4AGooAgAhACADQfQAaigCACEFQQAhCiADQfAAaigCAAwBCyADQfQAaigCACECQQEhCkEBIQUgA0H4AGooAgAiAARAIABBAEgNDCAAQQEQ8AkiBUUNDgsgBSACIAAQ4AoaIAALIQIgBCAhNgKMASAEIAA2AogBIAQgBTYChAEgBCACNgKAASAEICA7AX4gBCAKOwF8IAQgJjcDcCAEIANB6ABqKAIANgJ4CyAEQQhqIAxBCGopAQA3AwAgBEEQaiAMQRBqKQEANwMAIARBGGogDEEYaikBADcDACAEQSBqIAxBIGopAQA3AwAgBEEoaiAMQShqKQEANwMAIAQgDCkBADcDACApQoCAgIBwgyErIANBAWotAAAhGCAEKQI0IjFCIIinIQkgKUIwiKchDSAoQjCIpyEOIChCIIinIQUgBCkDWCEmIAQpA1AhJyAENQJIISogBCgCRCETIAQoAkAhAiAEKAIwIQogKachDyAopyEQIBUhByASIQBBACERIDGnDAYLQQIhBSADQSRqLwEAIgBBAkcEQCADQRhqKQMAISoCfiAARQRAIANBKGo1AgAhJSADQSZqLwEAIQ4gA0EsaigCACEBQQAhBSADQTBqKQMADAELIANBLGooAgAhAkEBIQVBASEBIANBMGooAgAiAARAIABBAEgNCyAAQQEQ8AkiAUUNDQsgASACIAAQ4AoaIACtIiUgLEKAgICAcIOECyEsIANBIGooAgAhECABrUIghiAlhCEoCyAEQUBrIANBCGoQhwMgA0EEaigCACEKAkAgA0E4aiIALQAAIgFBC0YEQCAEQQs6AFAgBCADQTlqLQAAOgBRDAELIAFBCkYEQCAEQQo6AFAgBCADQTxqKAIANgJUDAELIARB0ABqIAAQ/gILAkAgA0HkAGovAQAiAEECRgRAIARBAjsBfAwBCyADQdgAaikDACEmAn8gAEUEQCADQeYAai8BACEiIANB9ABqKAIAISMgA0HwAGooAgAhASADQewAaigCACEAQQAhBiADQegAaigCAAwBCyADQewAaigCACECQQEhBkEBIQAgA0HwAGooAgAiAQRAIAFBAEgNCyABQQEQ8AkiAEUNDgsgACACIAEQ4AoaIAELIQIgBCAjNgKMASAEIAE2AogBIAQgADYChAEgBCACNgKAASAEICI7AX4gBCAGOwF8IAQgJjcDcCAEIANB4ABqKAIANgJ4CyAEQQhqIBRBCGopAQA3AwAgBEEQaiAUQRBqKQEANwMAIARBGGogFEEYaikBADcDACAEQSBqIBRBIGopAQA3AwAgBCAUKQEANwMAICxCgICAgHCDISsgKEKAgICAcIMhJSADQQFqLQAAIRggBCkDQCIpQiCIpyEJICxCMIinIQ0gKEIwiKchCCAEKQNgISYgBCkDWCEnIAQvAVYhByAELwFUIQAgBCgCUCEBIAQoAkghAiAspyEPICinIQZBASERICmnDAULQQIhACADQTxqLwEAIgFBAkcEQCADQTBqKQMAISYCfiABRQRAIANBQGs1AgAhJSADQT5qLwEAIQcgA0HEAGooAgAhAUEAIQAgA0HIAGopAwAMAQsgA0HEAGooAgAhBkEBIQBBASEBIANByABqKAIAIgIEQCACQQBIDQogAkEBEPAJIgFFDQ8LIAEgBiACEOAKGiACrSIlIC5CgICAgHCDhAshLiABrUIghiAlhCEnIANBOGooAgAhAQsgBCADQSRqEIcDIANBBGooAgAhCiADQRBqKAIABH8gHyADQQxqEOkCIAwgA0EYahDxBCAEIANBCGooAgA2AlAgBCgCXCETIAQpA2AhKiAEKAJoIRAgBCkDUCEpIAQoAlgFQQALIQIgBCkCBCIoQoCAgIBwgyElICZCgICAgHCDISsgKUIgiKchCSAoQjCIpyEIICZCMIinIQ0gBC8BAiEOIAQvAQAhBSAopyEGICanIQ8gLiEmQQIhESAppwwEC0ECIQAgA0E8ai8BACIBQQJHBEAgA0EwaikDACEmAn4gAUUEQCADQUBrNQIAISUgA0E+ai8BACEHIANBxABqKAIAIQFBACEAIANByABqKQMADAELIANBxABqKAIAIQZBASEAQQEhASADQcgAaigCACICBEAgAkEASA0JIAJBARDwCSIBRQ0OCyABIAYgAhDgChogAq0iJSAvQoCAgIBwg4QLIS8gAa1CIIYgJYQhJyADQThqKAIAIQELIAQgA0EkahCHAyADQQRqKAIAIQogA0EQaigCACIYBH8CQCADQRRqKAIAIglFBEBBAiEGQQAhCAwBCyAJQf////8DSw0IIAlBAXQiCEEASA0IIAlBgICAgARJQQF0IQUgCAR/IAggBRDwCQUgBQsiBkUNCQsgBCAGNgJYIAQgCTYCVCAGIBggCBDgChogBCAJNgJcIAwgA0EYahDzAyAEIANBCGooAgA2AlAgBCgCXCETIAQpA2AhKiAEKAJoIRAgBCkDUCEoIAQoAlgFQQALIQIgBCkCBCIpQoCAgIBwgyElICZCgICAgHCDISsgKEIgiKchCSApQjCIpyEIICZCMIinIQ0gBC8BAiEOIAQvAQAhBSAppyEGICanIQ8gLyEmQQMhESAopwwDC0KAgICAICErIANBNGovAQAiAUECRwRAIANBKGopAwAhJwJ+IAFFBEAgA0E2ai8BACENIANBPGooAgAhACADQThqKAIAIQFCACErIANBQGspAwAMAQsgA0E8aigCACECAkAgA0FAaygCACIBRQRAQQEhAAwBCyABQQBIDQggAUEBEPAJIgBFDQsLIAAgAiABEOAKGkKAgICAECErIAGtIDBCgICAgHCDhAshMCADQTBqKAIAIQ8gAEEQdiEHCyADQQRqIQIgBCADQRBqEIcDAkAgA0EIaigCAARAIARB0ABqIAIQygcgBCgCUCEKDAELIARBADYCVCAEIAIoAgAiCjYCUAsgJ0KAgICAcIMhJSAEKQJUIiZCIIinIQkgJ0IwiKchCCADQSBqKQMAIiqnIRAgKkIwiKchDiAqQiCIpyEFIAQ1AgghKiAEKAIEIRMgBCgCACECICenIQYgMCEnQQQhESAmpwwCC0KAgICAICElIANBLGovAQAiAUECRwRAIANBIGopAwAhJwJ/IAFFBEAgA0Euai8BACEIIANBPmovAQAhFiADQTxqLwEAIRogA0E4aigCACEBIANBNGooAgAhAEIAISUgA0EwaigCAAwBCyADQTRqKAIAIQICQCADQThqKAIAIgFFBEBBASEADAELIAFBAEgNByABQQEQ8AkiAEUNCgsgACACIAEQ4AoaQoCAgIAQISUgAQutIACtQiCGhCEmIANBKGooAgAhBgsgBCADQQRqEIcDIARB0ABqIANBEGoQygcgJkKAgICAcIMhKyAmQjCIpyENICdCMIinIQ4gJ0IgiKchBSAEKQIEIihCIIinIQkgBDUCWCEqIAQoAlQhEyAEKAJQIQIgBCgCACEKICanIQ8gJ6chECAWIQcgGiEAQQUhESAopwwBC0ECIQUgA0Ekai8BACIBQQJHBEAgA0EYaikDACEqAn4gAUUEQCADQShqNQIAISUgA0Emai8BACEOIANBLGooAgAhAUEAIQUgA0EwaikDAAwBCyADQSxqKAIAIQJBASEFQQEhASADQTBqKAIAIgAEQCAAQQBIDQYgAEEBEPAJIgFFDQgLIAEgAiAAEOAKGiAArSIlIC1CgICAgHCDhAshLSADQSBqKAIAIRAgAa1CIIYgJYQhJwsgBEHQAGogA0EMahCHAyAtQoCAgIBwgyErICdCgICAgHCDISUgA0EEaigCACEKIC1CMIinIQ0gJ0IwiKchCCAEKAJYIRMgBCgCVCECIAQoAlAhCSAtpyEPICenIQZBBiERIANBCGooAgALISQgGSAeaiIDIBE6AAAgA0HIAGogJjcBACADQUBrICc3AQAgA0E+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QSBrIgIkACACIAAoAgA2AgQgAkEIaiIAQRBqIAFBEGopAgA3AwAgAEEIaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQYC7wgAgABD9AiACQSBqJAALXAEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEIaiIAQRBqIAFBEGopAgA3AwAgAEEIaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQcj2wwAgABD9AiACQSBqJAALXAEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEIaiIAQRBqIAFBEGopAgA3AwAgAEEIaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQeCExAAgABD9AiACQSBqJAALXAEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEIaiIAQRBqIAFBEGopAgA3AwAgAEEIaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQYSOxAAgABD9AiACQSBqJAALXAEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEIaiIAQRBqIAFBEGopAgA3AwAgAEEIaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQZyqxAAgABD9AiACQSBqJAALVgEDfyMAQSBrIgIkACABKAIEIQMgASgCACACQQhqIgFBEGogAEEQaikCADcDACABQQhqIABBCGopAgA3AwAgAiAAKQIANwMIIAMgARD9AiACQSBqJAALXAEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEIaiIAQRBqIAFBEGopAgA3AwAgAEEIaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQcTQxAAgABD9AiACQSBqJAALVgEDfyMAQSBrIgIkACAAKAIEIQMgACgCACACQQhqIgBBEGogAUEQaikCADcDACAAQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAMgABD9AiACQSBqJAALZgEBfyMAQRBrIgIkAAJ/IAAoAgAiACgCAEECRwRAIAIgADYCCCABQaDLwABBAiACQQhqQaTLwAAQugYMAQsgAiAAQQRqNgIMIAFBjMvAAEEDIAJBDGpBkMvAABC6BgsgAkEQaiQAC1kBAX8jAEEgayICJAAgAiAANgIEIAJBCGoiAEEQaiABQRBqKQIANwMAIABBCGogAUEIaikCADcDACACIAEpAgA3AwggAkEE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NwOoASADIDo3A6ABIANBCGpBACACIDpQGxCGAiADQYgBaiADQdgAahCBAiADKAKIASIEQQJHDQALCwJAIAMoAmhFDQAgA0HsAGooAgBFDQAgA0HwAGooAgAQ1AELIANB2ABqIgJBGGogA0EIaiIHQRhqKQMANwMAIAJBEGogB0EQaikDADcDACACQQhqIAdBCGopAwA3AwAgAyADKQMINwNYIAMgAhDAAiAUQQhqIAMoAgQgH2o2AgAgFCAfNgIEIBRBCDoAAAwBCyADKAKMASECIBQgOjcCBCAUIAI2AgACQCADKAJoRQ0AIANB7ABqKAIARQ0AIANB8ABqKAIAENQBCyADKAIIQQNHDQAgAygCDEUNACADQRBqKAIAENQBCyADQbABaiQAAkACfwJAIAwtABAiBEEIRgRAIAwoAhQiAiAMQRhqKAIAIhdJBEAgDCAiNgIoIAwgHTYCJCAMIBY2AiAgDEEQaiEPIAxBIGohEUIAITojAEGwAWsiAyQAIAUoAgghFCADQQA2AiAgAyAFNgIkIANBADYCCAJAAkAgFSgCBCIBIBUoAgAiB08EQCABDQEgA0FAayABIAdrNgIAIANBPGogB0GE58EAajYCACADQcgAakIANwMAIANBzQBqQgA3AAAgA0EANgI4IANCADcDKAwCCyAHIAFByLPCABCOCgALIAFBAEHIs8IAEI0KAAsgESgCBCIEIBEoAgAiFUcEQCADQeAAaiEHIBEoAgghEQNAAn8gBEEoai8BAEECRiIBRQRAAkAgESgCDCIWBEAgA0HYAGogESgCCCAWQQAgBEEgaiABGyIBQQhqEOgCIAMoAlhFDQELDAwLIAEpAwAhOkIBITwgBwwBC0IAITxBAAshASADIDo3A2AgAyA8NwNYIANBCGogARCGAiAVIARB+ABqIgRHDQALCyADQdgAaiIBQShqIANBKGoiB0EoaikDADcDACABQSBqIAdBIGopAwA3AwAgAUEYaiAHQRhqKQMANwMAIAFBEGogB0EQaikDADcDACABQQhqIAdBCGopAwA3AwAgAyADKQMoNwNYIANBiAFqIAEQgQICQAJAIAMoAogBIgRBAkcEQCADQagBaiEBA0AgAykDkAEhOiAEDQIgAyADKQOYATcDqAEgAyA6NwOgASADQQhqQQAgASA6UBsQhgIgA0GIAWogA0HYAGoQgQIgAygCiAEiBEECRw0ACwsCQCADKAJoRQ0AIANB7ABqKAIARQ0AIANB8ABqKAIAENQBCyADQdgAaiIBQRhqIANBCGoiB0EYaikDADcDACABQRBqIAdBEGopAwA3AwAgAUEIaiAHQQhqKQMANwMAIAMgAykDCDcDWCADIAEQwAIgD0EIaiADKAIEIBRqNgIAIA8gFDYCBCAPQQg6AAAMAQsgAygCjAEhASAPIDo3AgQgDyABNgIAAkAgAygCaEUNACADQewAaigCAEUNACADQfAAaigCABDUAQsgAygCCEEDRw0AIAMoAgxFDQAgA0EQaigCABDUAQsgA0GwAWokACAMLQAQIgRBCEcNAiAMQRhqKAIAIQ8gDCgCFCEEQQEhESACIQELIAsgDzYCECALIAQ2AgwgCyAXNgIIIAsgATYCBCALIBE2AgAgDEEwaiQADAMLIAwvABEgDC0AE0EQdHIMAQsgDC8AESAMLQATQRB0cgshACAMKAIUIQEgDCAMKAIYNgIoIAwgATYCJCAMIABBCHQgBHI2AiBBxOTBAEErIAxBIGpB9OrBAEG068EAEIcHAAsgBiASNgLYBCAGIAk2AtQEIAYgGTYC0AQgDUEQaiEPQQAhAkEAIRFBACEMIwBB4AFrIgEkACABQSBqQgA3AwAgAUEYaiILQgA3AwAgAUIANwMQIBsoAgghFCAFKAIIIRYgGygCACEXIBsoAgQhFSABQQA2AkAgASAFNgJEIAFBADYCKCAVIBdGIiJFBEAgAUH4AGoiB0EEciEfIAdBCGohAyAVQdAAaiEEA0ACfyAEQRBrKAIAIgwEQEIAITsgBC8BAEECRwRAIBQoAgwiAkUNByABQfgAaiAUKAIIIAIgBBDoAiABKAJ4DQcgBEEIaykDACE9QgEhOyABKAKAASABKAKEAUECdGpB4AFqKAIAIQILIAJBgICAeHEhB0EBDAELIARBDGshEUGAgIDYASEHQQALIR0gASA9NwOIASABIDs3A4ABIAEgETYCfCABIB02AnggASAHIAJB////B3FyIh02ApABIAFBKGoCfwJAAkAgDARAIDtCAFINAQwCCyAHQYCAgMABRw0BIBEgESgCACIHQQFrNgIAIAdBAUcNASAfEK4IDAELIAEgHa03A4ABIAFCATcDeCADDAELIAFCADcDeEEACxCGAiAEQShqIARB+ABqIQQgF0cNAAsLIAFBnQFqQgA3AAAgAUGnAWogAUHiAGotAAA6AAAgAUIANwOYASABQQA2ApABIAFBnLPCADYCjAEgAUEANgKIASABQgA3A3ggASABLwBgOwClASABQcgBaiABQfgAahCBAgJAAn8CQAJAAkACQAJAAkAgASgCyAEiBEECRwRAIAFBuAFqIQIDQCABKQPQASE6IAQNAiABIAEpA9gBNwO4ASABIDo3A7ABIAFBKGpBACACIDpQGxCGAiABQcgBaiABQfgAahCBAiABKALIASIEQQJHDQALCwJAIAEoAogBRQ0AIAEoAowBRQ0AIAEoApABENQBCyABQfgAaiICQRhqIAFBKGoiB0EYaikDADcDACACQRBqIAdBEGopAwA3AwAgAkEIaiAHQQhqKQMANwMAIAEgASkDKDcDeCABQQhqIAIQwAIgFq0gASgCDCAWaq1CIIaEIToMAQsgASgCzAEhBAJAIAEoAogBRQ0AIAEoAowBRQ0AIAEoApABENQBCwJAIAEoAihBA0cNACABKAIsRQ0AIAFBMGooAgAQ1AELIARB/wFxQQhHDQELIAEgFDYCgAEgASAVNgJ8IAEgFzYCeCABQShqIQMgAUH4AGohEUIAITxBACEEIwBBwAFrIgIkAAJAIAsoAgQiByALKAIAIgtPBEAgB0UEQCAFKAIIIRYgAkEoaiAHIAtrNgIAIAJBJGogC0Gcs8IAajYCACACQTBqQgA3AwAgAkE1akIANwAAIAJBADYCICACQgA3AxAgAkIANwNAIAJBADYCYCACIAU2AmQgAkIANwNoIAJBADYCSAwCCyAHQQBBrJHBABCNCgALIAsgB0GskcEAEI4KAAsgESgCBCILIBEoAgAiI0cEQCARKAIIIR0gC0HQAGohByACQfAAakEEciEkA0ACfyAHQRBrKAIAIiAEQEIAITwgBy8BAEECRwRAIB0oAgwiC0UNDSACQfAAaiAdKAIIIAsgBxDoAiACKAJwDQ0gB0EIaykDACE+QgEhPCACKAJ4IAIoAnxBAnRqQeABaigCACELCyALQYCAgHhxIRFBAQwBCyAHQQxrIQRBgICA2AEhEUEACyEfIAIgPjcDgAEgAiA8NwN4IAIgBDYCdCACIB82AnAgAiARIAtB////B3FyNgKIAQJAICAEQCACQcgAakIA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SQ0AIAMoAjANAAsLIANB4ABqIgFBGGoiDCADQThqIgJBGGopAwA3AwAgAUEQaiACQRBqKQMANwMAIAFBCGogAkEIaikDADcDACADIAMpAzg3A2AgAyABEMACIAMoAgQhMiADIAc2AlxBACEEIANBADYCWCAMQQA2AgAgA0H0AGpBsMTBADYCACADQYABakIANwMAIANBhQFqQgA3AAAgA0GgAWpCADcDACADQZgBakEANgIAIANBlAFqQbDEwQA2AgAgA0EANgJwIANCADcDYCADQQA2ApABICsNASADQfABaiIBQRBqIRQgAUEEciErIAFBAXIhDCADQdMBaiEXIAFBBXIiAkEHaiEsA0ACQAJAAkACQAJAQQMgBS0AACIBQQprIAFBCU0bQf8BcUECaw4CAwABCyADQfABaiAFEP4CIAMtAPABIgFBCkcNAQtBCSEBDAILIANB7gFqIAxBAmotAAA6AAAgA0HIAWoiC0EIaiACQQhqKQAANwMAIAtBEGogAkEQaikAADcDACALQRdqIAJBF2ooAAA2AAAgAyAMLwAAOwHsASADIAIpAAA3A8gBIAFBC0YNBCADLQD0ASELDAELIAMgBUEIaikDADcD+AEgA0HIAWoiAUEIaiACQQhqKQAANwMAIAFBEGogAkEQaikAADcDACABQRdqIAJBF2ooAAA2AAAgAyACKQAANwPIASADLQD0ASELQQIhAQsgA0HGAWoiMyADQe4Bai0AADoAACADQagBaiIVQQhqIjQgA0HIAWoiFkEIaiI1KQMANwMAIBVBEGoiNiAWQRBqIjcpAwA3AwAgFUEXaiIVIBZBF2oiFigAADYAACADIAMvAewBOwHEASADIAMpA8gBNwOoASABQQxGDQIgBUH4AGohBSAWIBUoAAA2AAAgNyA2KQMANwMAIDUgNCkDADcDACAUIBcpAAA3AAAgFEEIaiAXQQhqKQAANwAAIAxBAmogMy0AADoAACAMIAMvAcQBOwAAIAIgAykDqAE3AAAgLCADKACvATYAACADIAs6APQBIAMgAToA8AEgA0HYAGogA0HwAWoQ7QEhFQJAIAMtAPABIgFBCkYNAAJAAkACQCABDgkAAQMDAwMDAwIDCyADKAL0AUUNAiADKAL4ARDUAQwCCyADLQCLAkEYRw0BIAMoAvQBIhYoAgAhASAWIAFBAWs2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QTBqIBkoAgggBSABQQhqEOgCIAsoAjANCUEAIQQgASIFQSBqIQFBAAwDCyAEQewAaigCACIFIARB8ABqKAIAIgJBBXRqIQwgBEH4AGohBCADIQkgAkUNAAsLIAlBDGooAgAiAkUNASALQTBqIAkoAgggAiAFQQhqEOgCIAsoAjANASAFQSBqCyALQQhqIAUpAwAiOiALKQMoIj19IjtCP4dCgICAgICAgICAf4UgOyA9QgBVIDogO1VzGxCfAiALIDo3AyghBQwBCwsMAwsgC0HVAGpCADcAACALQgA3A1AgC0EANgJIIAtB0JDBADYCRCALQQA2AkAgC0IANwMwIAtCADcDYANAAkAgC0HoAGogC0EwahCAAgJAAkACQAJAIAsoAmgiAQRAIAFBAmsNAQJAIAsoAkBFDQAgCygCREUNACALKAJIENQBCyALQTBqIgFBGGogC0EIaiIFQRhqKQMANwMAIAFBEGogBUEQaikDADcDACABQQhqIAVBCGopAwA3AwAgCyALKQMINwMwIAsgARC+AiASrSALKAIEIBJqrUIghoQhOgwCCyALKQNwUA0DIAsgCykDYCI7IAspA3giPXwiOkI/h0KAgICAgICAgIB/hSA6ID1CAFMgOiA7U3MbIjo3A2AgC0EIaiA6IAspAygiPX0iO0I/h0KAgICAgICAgIB/hSA7ID1CAFUgOiA7VXMbEJ8CIAsgOjcDKAwFCyALKQNwITogCygCbCEBAkAgCygCQEUNACALKAJERQ0AIAsoAkgQ1AELAkAgCygCCEEDRw0AIAsoAgxFDQAgC0EQaigCABDUAQsgAUH/AXFBCEcNAQsgBiA6PgIAIAYgOkIgiD4CBCALQYABaiQADAILIAsgOjcCNCALIAE2AjBBvJHBAEErIAtBMGpB6JHBAEH4kcEAEIcHAAsgC0EIahCKAwwBCwsgDUHIAGogBikDADcCACANQUBrIDw3AgAgDUE8aiAbICJqNgIAIA0gGzYCOCANQTRqIBY2AgAgDSARNgIwIA1BLGogHTYCACANIB82AigMAQsgBkFAayIBQSBqQgE3AwAgAUHIAGpCATcDACAGQYABakIANwMAIAZCADcDWCAGQQA2AkAgBkEANgJoIAZBkAFqIgFB0ABqQgE3AwAgAUHIAGpCADcDACABQShqQgE3AwAgAUEgakIANwMA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KAIUENQBCwJAAkACQCAFKAIMIgkoAggOAgABAgsgCUEQaigCAEUNASAJQQxqKAIAENQBDAELIAlBDGotAABBA0cNACAJQRBqKAIAIgIoAgAgAigCBCgCABEDACACKAIEIgdBBGooAgAEQCAHQQhqKAIAGiACKAIAENQBCyAJKAIQENQBCyAFKAIMENQBIAVB8ABqJAAMAQtB7PPAAEE3IAVByABqQaT0wABBgPXAABCHBwALCyAAIDk2AgggACABNgIEIAAgCDYCACAtQRBqJAAPCyAJIAVB8PTEACgCACIAQcoEIAAbEQAAAAtkAgJ/AX4jAEEQayICJABBAEHMscAAKAIAEQYAIgEEQCABIAEpAwAiA0IBfDcDACAAIAEpAwg3AwggACADNwMAIAJBEGokAA8LQYHIwABBxgAgAkEIakHIyMAAQajJwAAQhwcAC1gBAX8gAEEUaigCACIDIAAoAgxGBEAgAEEMaiADEIwGIAAoAhQhAwsgAEEQaigCACADQRRsaiIDIAI2AgwgAyABNgIIIANCATcCACAAIAAoAhRBAWo2AhQLUAEBfwJAIAAoAggiAUUNACABQQA6AAAgAEEMaigCAEUNACAAKAIIENQBCwJAIABBf0YNACAAIAAoAgQiAUEBazYCBCABQQFHDQAgABDUAQsLSgEBfyMAQSBrIgAkACAAQRRqQQE2AgAgAEEcakEANgIAIABBtKnEADYCECAAQZipxAA2AhggAEEANgIIIABBCGpBjKrEABDaCAAL5mIDLn8FfgF8AkACQAJAIABFDQAgACgCAA0BIABBfzYCACABRQ0AIAEoAgANASABQX82AgAgAUEEaiESIwBBwAFrIgQkACAAQQhqIgJBLGoiBi0AACEJIAQgAkEtakHDABDgCiEMIAZBAjoAAAJAIAlBAkYNACACKAIgIAJB8ABqIAJBJGooAgAiBCACQShqKAIAIgoQzwcgDEGoAWogDEE7aikAADcDACAMQaABaiAMQTNqKQAANwMAIAxB8ABqIgZBKGogDEEraikAADcDACAMQZABaiAMQSNqKQAANwMAIAxBiAFqIAxBG2opAAA3AwAgDEGAAWogDEETaikAADcDACAGQQhqIAxBC2opAAA3AwAgDCAMKQADNwNwIAxBADYCtAEgDEHIAGogBiACQYABaiAMQbABakIAQgAQ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AAsgCEEBaiECIAVBLGshBSAIIA5HDQALCyAQICEgIGs2AgQLCyAUQSBqJAALIA8gEykAADcACCAPQTBqICk2AgAgD0EoaiAxNwMAIA9BIGogE0EYaikAADcAACAPQRhqIBNBEGopAAA3AAAgD0EQaiATQQhqKQAANwAAIA9BATYCAAsCQCADKAL4AkUEQCADKAL8AiEEDAELICYgEUEYaikCADcDACAnIBFBEGopAgA3AwAgKCARQQhqKQIANwMAIAMgESkCADcDuAEgAygCqAMiB0EMaigCACEEIAQgBygCACIIIAMpA6ADpyILcSIFaikAAEKAgYKEiJCgwIB/gyIwUARAQQghAgNAIAIgBWohBSACQQhqIQIgBCAFIAhxIgVqKQAAQoCBgoSIkKDAgH+DIjBQDQALCyAEIDB6p0EDdiAFaiAIcSICaiwAACIFQQBOBEAgBCAEKQMAQoCBgoSIkKDAgH+DeqdBA3YiAmotAAAhBQsgAiAEaiALQRl2Igs6AAAgByAHKAIEIAVBAXFrNgIEIAJBCGsgCHEgBGpBCGogCzoAACAEIAJBVGxqIgRBLGsiAkEYaiAmKQMANwIAIAJBEGogJykDADcCACACQQhqICgpAwA3AgAgAiADKQO4ATcCACACQQA2AiggAkKAgICAEDcCICAHIAcoAghBAWo2AggLIAZBIGohBiARIA0oAgAiAkEIaikAADcDACAeIAJBEGopAAA3AwAgHSACQRhqKQAANwMAIAMgAikAADcD+AIgBEEsayIHQShqIgUoAgAhAiACIAdBIGoiBygCAEYEQCAHIAIQlAYgBSgCACECCyAEQQhrKAIAIAJBBXRqIgIgAykD+AI3AAAgAkEYaiAdKQMANwAAIAJBEGogHikDADcAACACQQhqIBEpAwA3AAAgBSAFKAIAQQFqNgIAIAYgLUcNAAsgDSgCACEICyANQQRqIQQCQCADKAKgASICBEAgAygCnAEiBiACQQJ0aiEPA0AgBigCACECIB0gCEEYaikAADcDACAeIAhBEGopAAA3AwAgESAIQQhqKQAANwMAIAMgCCkAADcD+AICQCACKAIARQ0AIANBuAFqIAJBCGooAgAgAkEUaigCACIOIANB+AJqENMEIAMoAsABQQJ0IRMgAygCvAEhByADKAK4ASELIAJBEGooAgAhEEEAIQID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IgIoAgQhASACKAIAIAEoAghBB2pBeHFqIAMgASgCQBEIABogACkDAFANACACKAIAIgEoAgAhACABIABBAWs2AgAgAEEBRw0AIAIQsQcLC0cBAX8CQCAAKAIAQQNHDQAgACgCBCAAQQhqIgEoAgAoAgARAwAgASgCACIBQQRqKAIARQ0AIAFBCGooAgAaIAAoAgQQ1AELC0MBAX8gAiAAKAIAIAAoAggiA2tLBEAgACADIAIQnAYgACgCCCEDCyAAKAIEIANqIAEgAhDgChogACACIANqNgIIQQALgAEBA38jAEEQayICJAAjAEEQayIDJAAgA0EIaiAAKAIAEAQgAygCCCIERQRAQbTRwwBBFRDXCgALIAMoAgwhACACIAQ2AgQgAiAANgIIIAIgADYCACADQRBqJAAgAigCBCIAIAIoAgggARDcCiACKAIABEAgABDUAQsgAkEQaiQAC0MBAX8gAiAAKAIAIAAoAggiA2tLBEAgACADIAIQnQYgACgCCCEDCyAAKAIEIANqIAEgAhDgChogACACIANqNgIIQQALQQEBfyABKAIAIgIgASgCBE8Ef0EABSABIAJBAWo2AgAgASgCCCgCACACECAhAUEBCyECIAAgATYCBCAAIAI2AgALSgEBfyMAQSBrIgAkACAAQRRqQQE2AgAgAEEcakEANgIAIABB/NfAADYCECAAQYDUwAA2AhggAEEANgIIIABBCGpBzNjAABDaCAALPgEBfwJAAkAgAS0AAEUEQCABLQAQQQtGDQEMAgsgAS0AEEELRw0BCyAAIAEpAzA3AgRBASECCyAAIAI2AgALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhCcBiAAKAIIIQMLIAAoAgQgA2ogASACEOAKGiAAIAIgA2o2AggLRAEBfyABKAIQIgIgAUEUaigCAEkEQCAAIAI2AhAgASACQQFqNgIQIAAgASkCCDcCCCAAIAEpAgA3AgAPCyAAQQA2AgALSgEBfyMAQSBrIgAkACAAQRRqQQE2AgAgAEEcakEANgIAIABB3JDEADYCECAAQZyOxAA2AhggAEEANgIIIABBCGpB5JDEABDaCAALSgEBfyMAQSBrIgAkACAAQRRqQQE2AgAgAEEcakEANgIAIABB5KrEADYCECAAQbSqxAA2AhggAEEANgIIIABBCGpB7KrEABDaCAALLwEBfyAAQRRBDCAAKAIYIgEbaigCAARAIABBFGogAEEMaiABG0EEaigCABDUAQsLUwEBf0EUQQQQ8AkiA0UEQEEUQQRB8PTEACgCACIAQcoEIAAbEQAAAAsgAyACNgIEIAMgATYCACADIAApAgA3AgggA0EQaiAAQQhqKAIANgIAIAMLPwEBfyAAKAIIIgIgACgCAEYEQCAAIAIQhAYgACgCCCECCyAAKAIEIAJBAnRqIAE2AgAgACAAKAIIQQFqNgIICzwAIAAgASkDADcDACAAQRhqIAFBGGopAwA3AwAgAEEQaiABQRBqKQMANwMAIABBCGogAUEIaikDADcDAAs8ACAAIAEpAAA3AAAgAEEYaiABQRhqKQAANwAAIABBEGogAUEQaikAADcAACAAQQhqIAFBCGopAAA3AAALVgECfyABKAIEIQIgASgCACEDQQhBBBDwCSIBRQRAQQhBBEHw9MQAKAIAIgBBygQgABsRAAAACyABIAI2AgQgASADNgIAIABB0JrEADYCBCAAIAE2AgALPwIBfwF8IAEoAhhBAXEhAiAAKwMAIQMgASgCEEEBRgRAIAEgAyACIAFBFGooAgAQgwIPCyABIAMgAkEAEN8CC34AAkACQAJAAkAgACgCAC0AAEEBaw4DAQIDAAsgASgCAEGxlMIAQQMgASgCBCgCDBECAA8LIAEoAgBBrJTCAEEFIAEoAgQoAgwRAgAPCyABKAIAQaiUwgBBBCABKAIEKAIMEQIADwsgASgCAEGklMIAQQQgASgCBCgCDBECAAu7BAIFfwF+IwBBEGsiAyQAIAMgADYCDEEBIQACQCABQf8BcUECRwRAAkAgA0EMaiEGIwBBIGsiASQAAkBB3PTEACgCAA0AQdz0xAApAgAhB0Hc9MQAQgE3AgBB7PTEACgCACEAQez0xABBAToAACABQRhqIAA2AgAgAUEQaiIAQeT0xAApAgA3AwBB5PTEAEEANgIAIAEgBzcDCCAHp0UNACAAKAIAIgJFDQAgAiACKAIAIgJBAWs2AgAgAkEBRw0AIAAQsQcLQez0xAAtAAAhAEHs9MQAQQA6AAACQAJAAkAgAEEBcSIABEBBACAAa0Hg9MQAcSIEKAIADQIgBEF/NgIAAkBB5PTEACgCACICBEBB6PTEACgCACEADAELAkAQ+wgiAgRAIAJBBGooAgAhACACKAIAIgIoAgAhBSACIAVBAWo2AgAgBUEATg0BAAtBCEEEEPAJIgJFDQggAkKBgICAEDcCAEGk+MMAIQALQej0xAAgADYCAEHk9MQAIAI2AgALIAIgACgCCEEHakF4cWogBigCACAAKAIUEQEAIQBB7PTEAEEBOgAAIAQgBCgCAEEBajYCAAwBC0EIQQQQ8AkiAEUNAiAAQoCAgIAQNwIAIAFBpPjDADYCDCABIAA2AghBACEAIAFBCGoQsQcLIAFBIGokAAwCC0Hk+cMAQRAgAUEIakH0+cMAQdT5wwAQhwcACwwCCwsgA0EQaiQAIAAPC0EIQQRB8PTEACgCACIAQcoEIAAbEQAAAAtPAQF/QQxBBBDwCSICRQRAQQxBBEHw9MQAKAIAIgBBygQgABsRAAAACyACQRQ6AAggAkGQjsEANgIEIAIgATYCACAAIAKtQiCGQgOENwIACzkAAkACfyACQYCAxABHBEBBASAAIAIgASgCEBEBAA0BGgsgAw0BQQALDwsgACADIAQgASgCDBECAAs4AQJ/IAAgAUE8aigCACABQThqKAIAIgIgAUEwaigCACIDGzYCBCAAIAIgAUE0aigCACADGzYCAAs7AQF/An8gAUEESwRAQfCxfyECQQEMAQsgAUECdEH8zsMAaigCACECQQALIQEgACACNgIEIAAgATYCAAs7AQF/IwBBEGsiAiQAIAIgACgCADYCDCABQbSmwABBFEHIpsAAQQkgAkEMakHUpsAAENAGIAJBEGokAAs7AQF/IwBBEGsiAiQAIAIgACgCADYCDCABQbSmwABBFEHIpsAAQQkgAkEMakHkpsAAENAGIAJBEGokAAs2AQF/IwBBEGsiAyQAIAMgAjYCDCADIAE2AgggACADQQhqEOcCNgIEIABBADYCACADQRBqJAALRgAgACACOgA0IAAgATYCACAAQoCAgIAQNwIEIABCgICAgMAANwIcIABCADcCDCAAQSRqQoCAgIAgNwIAIABBFGpCBDcCAAs7AQF/IwBBEGsiAiQAIAIgACgCADYCDCABQcyowQBBEUHdqMEAQQUgAkEMakHspsEAENAGIAJBEGokAAvkAgECfyMAQSBrIgIkACACQQE6ABggAiABNgIUIAIgADYCECACQbTKxAA2AgwgAkGEr8QANgIIIwBBEGsiASQAAkAgAkEIaiIAKAIMIgIEQCAAKAIIIgNFDQEgASACNgIIIAEgADYCBCABIAM2AgAjAEEQayIAJAAgAEEIaiABQQhqKAIANgIAIAAgASkCADcDACMAQRBrIgEkACAAKAIAIgJBFGooAgAhAwJAAn8CQAJAIAJBDGooAgAOAgABAwsgAw0CQQAhAkGcjsQADAELIAMNASACKAIIIgMoAgQhAiADKAIACyEDIAEgAjYCBCABIAM2AgAgAUH0msQAIAAoAgQiASgCCCAAKAIIIAEtABAQsAYACyABQQA2AgQgASACNgIMIAFB4JrEACAAKAIEIgEoAgggACgCCCABLQAQELAGAAtB4I7EAEErQbCaxAAQnggAC0HgjsQAQStBoJrEABCeCAALNgEBfyMAQRBrIgEkACABQQhqQQA2AgAgASgCDCECIAAgASgCCDYCACAAIAI2AgQgAUEQaiQAC1ABAn8jAEEQayICJAAgAkEIaiIDQZiuwQA2AgQgAyABQQRqQQAgASgCAEEERhs2AgAgAigCDCEBIAAgAigCCDYCACAAIAE2AgQgAkEQaiQACzcBAX8jAEEQayICJAAgAiAAKAIAKAIANgIMIAFBhJXCAEEFIAJBDGpBtJPCABC6BiACQRBqJAALPAACQAJAAkAgAS0AAEEKaw4CAQACCyAAQQs6AAAgACABLQABOgABDwsgACABKAIEEP4CDwsgACABEP4CCzgBAX8jAEEQayICJAAgAiAANgIMIAFB8MzCAEERQYHNwgBBBSACQQxqQbDIwgAQ0AYgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBrKTDAEENQZikwwBBAyACQQxqQZykwwAQ0AYgAkEQaiQACzMAAkAgAEH8////B0sNACAARQRAQQQPCyAAIABB/f///wdJQQJ0EPAJIgBFDQAgAA8LAAvVFAINfwF+AkAgAARAIAAoAgANASAAQX82AgAjAEHAAWsiBCQAIABBKGoiAS0ADCEDIARBBWogAUENakHDABDgChogAUECOgAMAkAgA0ECRg0AIAEoAgAgAUHQAGogASgCBCIDIAEoAggiAhDPByAEQagBaiAEQUBrKQAANwMAIARBoAFqIARBOGopAAA3AwAgBEGYAWogBEEwaikAADcDACAEQZABaiAEQShqKQAANwMAIARBiAFqIARBIGopAAA3AwAgBEGAAWogBEEYaikAADcDACAEQfAAaiIHQQhqIARBEGopAAA3AwAgBCAEKQAINwNwIARBADYCtAEgBEHIAGogByABQeAAaiAEQbABakIAQgAQxgEgAyACEJMBRQ0AIAMQ1AELIAFB4ABqIQYjAEGQAmsiASQAIAFBNGpB2AI2AgAgAUEsakHYAjYCACABQSRqQdgCNgIAIAFBHGpB2AI2AgAgAUEUakHYAjYCACABQbzewgA2AjAgAUGw3sIANgIoIAFBpN7CADYCICABQZTewgA2AhggAUGI3sIANgIQIAFB2AI2AgwgAUH83cIANgIIIAFBBjYC3AEgAUEGNgLUASABQcjdwgA2AtABIAFBBjYCzAEgAUHE3sIANgLIASABIAFBCGo2AtgBIAFB+AFqIAFByAFqELcDIAEoAvgBIAEoAvwBIgIgASgCgAIQAiEHBEAgAhDUAQsgASAHNgIIIAFBCGoQ8QogASgCCCIDQYQBTwRAIAMQAQsgBkGEAmooAgAiAykDACEOIAZB+AFqKAIAIQIgASAGQYACaigCADYCICABIAM2AhggASACIANqQQFqNgIUIAEgA0EIajYCECABIA5Cf4VCgIGChIiQoMCAf4M3AwggAUHIAWogAUEIaiICEOsCIAEoAswBIQMgASgC0AEhByABIAZBmAFqIgk2AgggAyAHIAIQeyABKALIASEFIAEgCTYCGCABIAM2AhQgASADIAdBDGxqNgIQIAEgAzYCDCABIAU2AgggAUEEOgAgIAFByABqIAIQxQQCQAJAAkAgAS0ATEEERg0AIAZBwAFqIQcgBkG8AWohCSAGQfABaiELIAZB7AFqIQwCQAJAAkADQAJAIAEoAkghBSABKAJQIgNBJGooAgAhAiABIAM1AiA3A7gBIAcoAgAiCCACTQ0AIAFBgQM2AoQCIAFBswE2AvwBIAEgCSgCACACQRRsajYCgAIgASABQbgBajYC+AEgAUECNgLcASABQQI2AtQBIAFBpN3CADYC0AEgAUEANgLIASABIAFB+AFqNgLYASABQdgAaiABQcgBahC3AwJAAkAgBSgCACIIIAUoAgQiAnJFBEBBBUEBEPAJIgINAQwJCyABIAitNwO4ASAHKAIAIgUgAk0NBCABQYEDNgKEAiABQbMBNgL8ASABIAkoAgAgAkEUbGo2AoACIAEgAUG4AWo2AvgBIAFBAjYC3AEgAUECNgLUASABQaTdwgA2AtABIAFBADYCyAEgASABQfgBajYC2AEgAUHoAGogAUHIAWoQtwMMAQsgAkEEakGMjsIALQAAOgAAIAJBiI7CACgAADYAACABQQU2AnAgASACNgJsIAFBBTYCaAsgA0HEAGooAgAhAgJAIAMoAkBFBEAgCygCACIFIAJNDQUgAUH4AGogDCgCACACQQxsahDKBwwBCwJAIANByABqKAIAIgUgAnJFBEBBBUEBEPAJIgINAQwJCyABIAKtNwO4ASAHKAIAIgIgBU0NBiABQYEDNgKEAiABQbMBNgL8ASABIAkoAgAgBUEUbGo2AoACIAEgAUG4AWo2AvgBIAFBAjYC3AEgAUECNgLUASABQaTdwgA2AtABIAFBADYCyAEgASABQfgBajYC2AEgAUH4AGogAUHIAWoQtwMMAQsgAkEEakGRjsIALQAAOgAAIAJBjY7CACgAADYAACABQQU2AoABIAEgAjYCfCABQQU2AngLAkACQAJAAkACQEEDIAMtAAAiAkEKayACQQlNG0H/AXFBAWsOAwECAwALIAEgA0EBajYCqAEgAUHUATYCvAEgASABQagBajYCuAEgAUEBNgLcASABQQI2AtQBIAFByODCADYC0AEMAwsgAUGsAzYCvAEgAUH02cIANgK4ASABQQE2AtwBIAFBATYC1AEgAUG44MIANgLQAQwCCyABIANBCGo2AqgBIAFBtQI2ArwBIAEgAUGoAWo2ArgBIAFBATYC3AEgAUECNgLUASABQaTgwgA2AtABDAELIAEgAzYCqAEgAUGtAzYCvAEgASABQagBajYCuAEgAUEBNgLcASABQQE2AtQBIAFBlODCADYC0AELIAFBADYCyAEgASABQbgBaiINNgLYASABQfgBaiIFIAFByAFqIgIQtwMgAUGQAWogBUEIaigCADYCACABIAEpA/gBNwOIASADQTxqKAIAIQogA0E4aigCACEIIAEgBjYC0AEgASAINgLMASABIAggCkEDdGo2AsgBIAFBmAFqIgggAhCdBCADQTBqKAIAIQogA0EsaigCACEDIAEgBjYC0AEgASADNgLMASABIAMgCkEDdGo2AsgBIAFBqAFqIgMgAhCdBCABQa4DNgL0ASABQa4DNgLsASABQa8DNgLkASABQa8DNgLcASABQa8DNgLUASABQa8DNgLMASABIAM2AvABIAEgCDYC6AEgASABQYgBajYC4AEgASABQfgAajYC2AEgASABQegAajYC0AEgASABQdgAajYCyAEgAUEGNgKMAiABQQY2AoQCIAFByN3CADYCgAIgAUEGNgL8ASABQcTewgA2AvgBIAEgAjYCiAIgDSAFELcDIAEoArgBIAEoArwBIgIgASgCwAEQAiEFBEAgAhDUAQsgASAFNgLIASABQcgBahDxCiABKALIASIDQYQBTwRAIAMQAQsgASgCsAEiAgRAIAEoAqwBIQMgAkEMbCECA0AgAygCAARAIANBBGooAgAQ1AELIANBDGohAyACQQxrIgINAAsLIAEoAqgBBEAgASgCrAEQ1AELIAEoAqABIgIEQCABKAKcASEDIAJBDGwhAgNAIAMoAgAEQCADQQRqKAIAENQBCyADQQxqIQMgAkEMayICDQALCyABKAKYAQRAIAEoApwBENQBCyABKAKIAQRAIAEoAowBENQBCyABKAJ4BEAgASgCfBDUAQsgASgCaARAIAEoAmwQ1AELIAEoAlgEQCABKAJcENQBCyABQcgAaiABQQhqEMUEIAEtAExBBEcNAQwFCwsgAiAIQbTdwgAQnAcACyACIAVBtN3CABCcBwALIAIgBUGE4MIAEJwHAAsgBSACQbTdwgAQnAcACyABKAIIBEAgASgCFBDUAQsCQCABLQAgQQRGDQAgAUEsaigCAEUNACABQThqKAIARQ0AIAFBPGooAgAQ1AELIAFBkAJqJAAMAQtBBUEBQfD0xAAoAgAiAEHKBCAAGxEAAAALIARBwAFqJAAgAEEANgIADwsQ1QoACxDWCgALNAEBfyMAQRBrIgIkACACIAAoAgA2AgwgAUHklMEAQQogAkEMakHwlMEAELoGIAJBEGokAAs0AQF/IwBBEGsiAiQAIAIgACgCADYCDCABQfT2wQBBCCACQQxqQfz2wQAQugYgAkEQaiQACzQBAX8jAEEQayICJAAgAiAAKAIANgIMIAFBqPjBAEEFIAJBDGpBsPjBABC6BiACQRBqJAALNAEBfyMAQRBrIgIkACACIAAoAgA2AgwgAUGkkcIAQQQgAkEMakGokcIAELoGIAJBEGokAAs0AQF/IwBBEGsiAiQAIAIgACgCADYCDCABQbiQ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cUEEdkUEQCABLQAYQSBxQQV2RQRAIAAgARCPCg8LIAAgARDtBg8LIAAgARDsBgs4AAJAIAEtABhBEHFBBHZFBEAgAS0AGEEgcUEFdg0BIAAgARCOCQ8LIAAgARDsBg8LIAAgARDtBgsoAQF/IAAoAgAiAUGEAU8EQCABEAELIAAoAgQiAEGEAU8EQCAAEAELC3QBAX9B9NUCQQQQ8AkiAUUEQEH01QJBBEHw9MQAKAIAIgBBygQgABsRAAAACyABQgA3AujVAiABQQBB5tUCEOIKIgFBAjoA8dUCIAFBAToA8NUCIAFBATsB8tUCIABCADcDACAAIAE2AhAgAEEIakIANwMACyEBAX8CQCAAQQRqKAIAIgFFDQAgACgCAEUNACABENQBCwsjAAJAIAFB/P///wdNBEAgACABQQQgAhCwCSIADQELAAsgAAsjAQF/IAAoAgAiAEEATiECIACtQgAgAKx9IAIbIAIgARDdBAslACAARQRAQcnRwwBBMhDXCgALIAAgAiADIAQgBSABKAIQEQ8ACyIBAn4gACkDACICQj+HIQMgAiADhSADfSACQgBZIAEQ3QQLPQAgACgCAC0AAEUEQCABKAIAQYGxwQBBBSABKAIEKAIMEQIADwsgASgCAEH4sMEAQQkgASgCBCgCDBECAAshACAAQZiuwQA2AgQgACABQQRqQQAgASgCAEEERhs2AgALHwAgACgCACIALQAAQQpGBH8gACgCBAUgAAsgARC+BAs9ACAAKAIALQAARQRAIAEoAgBBzeTCAEEGIAEoAgQoAgwRAgAPCyABKAIAQcjkwgBBBSABKAIEKAIMEQIACyMAIABFBEBBydHDAEEyENcKAAsgACACIAMgBCABKAIQEQUACyMAIABFBEBBydHDAEEyENcKAAsgACACIAMgBCABKAIQES4ACyMAIABFBEBBydHDAEEyENcKAAsgACACIAMgBCABKAIQETAACyMAIABFBEBBydHDAEEyENcKAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBydHDAEEyENcKAAsgACACIAMgBCABKAIQEREACxwAIABBAkEBIAFB/wFxIgBBAkYbQQAgABs6AAgLJgAgAEKAgICAwAA3AgggAEEAOgAEIABBADYCACAAQRBqQQA2AgALFQAgACgCAARAIABBBGooAgAQ1AELCx0BAX8gAC0ACCIBQQNPBH8gABD1A0H/AXEFIAELCyIBAX8gASgCABAhIQIgACABNgIIIAAgAjYCBCAAQQA2AgALIQAgAEUEQEHJ0cMAQTIQ1woACyAAIAIgAyABKAIQEQQACyQAIAAtAABFBEAgAUH80cQAQQUQ5AEPCyABQfjRxABBBBDkAQscACAAKAIAIgBBBGooAgAgAEEIaigCACABENwKCxwAIAAoAgAiAEEEaigCACAAQQhqKAIAIAEQhAILHwAgAEUEQEHJ0cMAQTIQ1woACyAAIAIgASgCEBEBAAsdACABKAIARQRAAAsgAEH0jcQANgIEIAAgATYCAAsbABAiIQIgACABNgIIIABBADYCBCAAIAI2AgALKAAgASgCACAAKAIALQAAQQJ0QciWwQBqKAIAQQ4gASgCBCgCDBECAAscACAAKAIAIgAoAgAgASAAQQRqKAIAKAIMEQEACxwAIAAoAgAiACgCACABIABBBGooAgAoAhARAQALFwAgAEEEaigCACAAQQhqKAIAIAEQ3AoLFwAgACACQf8BcbgQBTYCBCAAQQA2AgALFwAgAEEEaigCACAAQQhqKAIAIAEQhAILGQAgACgCACIAKAIAIABBBGooAgAgARCEAgsgAQF/EJoFIgBFBEBBlo/EAEHeAEGUkMQAEJAKAAsgAAsUACAAKAIAIgBBhAFPBEAgABABCwsWACAAKAIAIgAoAgAgACgCBCABENwKC5kHAQd/IAAhCAJAAkACQCACQQlPBEAgAyACEIQEIgANAUEAIQAMAwtBACEAIANBzf97Tw0CQRAgA0EEaiADQQtJG0EHakF4cSEFIAhBCGsiBCgCBEF4cSEBIAEgBGohBwJAAkACQAJAAkACQAJAIAQtAARBA3EEQCABIAVPDQEgB0HU+MQAKAIARg0CIAdB0PjEACgCAEYNAyAHLQAEQQJxQQF2DQcgBygCBEF4cSIGIAFqIgogBUkNByAKIAVrIQkgBkGAAkkNBCAHEIIFDAULIAQoAgRBeHEhASAFQYACSQ0GIAEgBWtBgYAISSAFQQRqIAFNcQ0FIAQoAgAaDAYLIAEgBWsiAkEQSQ0EIAQgBCgCBEEBcSAFckECcjYCBCAEIAVqIgYgBigCBEEBcjYCBCAGIAYoAgRBAXEgAnJBAnI2AgQgAiAGaiIBIAEoAgRBAXI2AgQgBiACEJoDDAQLQcz4xAAoAgAgAWoiASAFTQ0EIAQgBCgCBEEBcSAFckECcjYCBCAEIAVqIgIgAigCBEEBcjYCBCACIAEgBWsiAUEBcjYCBEHM+MQAIAE2AgBB1PjEACACNgIADAMLQcj4xAAoAgAgAWoiASAFSQ0DAkAgASAFayIGQRBJBEAgBCAEKAIEQQFxIAFyQQJyNgIEIAEgBGoiASABKAIEQQFyNgIEQQAhBkEAIQIMAQsgBCAEKAIEQQFxIAVyQQJyNgIEIAQgBWoiAiACKAIEQQFyNgIEIAIgBkEBcjYCBCACIAZqIgEgBjYCACABIAEoAgRBfnE2AgQLQdD4xAAgAjYCAEHI+MQAIAY2AgAMAgsgB0EMaigCACICIAdBCGooAgAiAUcEQCABIAI2AgwgAiABNgIIDAELQcD4xABBwPjEACgCAEF+IAZBA3Z3cTYCAAsgCUEQTwRAIAQgBCgCBEEBcSAFckECcjYCBCAEIAVqIgIgAigCBEEBcjYCBCACIAIoAgRBAXEgCXJBAnI2AgQgAiAJaiIBIAEoAgRBAXI2AgQgAiAJEJoDDAELIAQgBCgCBEEBcSAKckECcjYCBCAEIApqIgEgASgCBEEBcjYCBAsgBA0CCyADEHciAUUNAiABIAggBCgCBEF4cUF8QXggBC0ABEEDcRtqIgAgAyAAIANJGxDgCiEAIAgQ1AEMAgsgACAIIAEgAyABIANJGxDgChogCBDUAQwBCyAELQAEGiAEQQhqIQALIAALFAAQKyECIAAgATYCBCAAIAI2AgALFAAgACABIAIQAjYCBCAAQQA2AgALFQAgASACOgDIAiAAIAFB0AIQ4AoaC/YNAQ5/IAAhECABIRIjAEEgayINJAAgDUEIaiAGQf8BcRDUCCANKAIMIQACQCANKAIIRQRAIA1BEGohCiASKAIQIQYjAEEQayIJJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEEDRwRAIAYtAPLVAiEHIAZBADoA8tUCIAYsAPDVAiILQQBIDQEgBi0A8dUCIQEgAEEERiIOQQEgBi0A89UCIg8bRQ0CIAFBAklBwABBCCABG3IhCCAGIA4gD0EAR3I6APPVAgJAAkAgAEEERkEAIAcbRQRAIAYoAuzVAiIBDQIgCSAGQYCAAmoiEyACIAMgBkGAgAIgBigC6NUCIAggCEECciAAQQRGGyIUEFcgBiAJLQAEIgE6APDVAiADIAkoAgAiC08NASADIQAMCQtBACEHIAkgBkGAgAJqIAIgAyAEIAVBACAIQQRyEFcgBiAJLAAEIgA6APDVAiAJKAIIIQEgCSgCACECIABBAEgEQEEBIQdBfSEADA4LIABFBEBBASEADA4LIAZB/wE6APDVAkEBIQdBeyEADA0LIAkoAgghCCAAQQRGDQYgAyEAQQAhDkEAIQ8DQCAGIAg2AuzVAiAGKALo1QIiDCAIIAUgBSAISxsiEWoiByAMSQ0JIAdBgIACSw0MIAsgDmohDiAEIAYgDGogERDgCiEMIAYgB0H//wFxIgc2AujVAiAGIAggEWs2AuzVAiAPIBFqIQ8gAcBBAEgEQEEBIQRBfSEHDAwLQQEhBAJAIAFBAUcNACADDQBBeyEHDAwLAkAgAUUNACAAIAtGDQAgBSAITQ0AIAUgCEkNACAFIBFrIQUgDCARaiEEIAkgEyACIAtqIgIgACALayIAIAZBgIACIAcgFBBXIAYgCS0ABCIBOgDw1QIgCSgCCCEIIAkoAgAiCyAATQ0BDAkLCyABRSAFIAhPcSEHQQAhBAwKCyAGKALo1QIiAiABIAUgASAFSRsiA2ohACAAIAJJDQMgAEGAgAJLDQQgBCACIAZqIAMQ4AoaIAYgAEH//wFxNgLo1QIgBiABIANrNgLs1QIgCiADNgIMIApBADYCCCAKIAtFIAEgBU1xNgIEIApBADYCAAwMCyAKQoGAgIBgNwIAIApCADcCCAwLCyAKQoGAgIBQNwIAIApCADcCCAwKCyAKQoGAgIBgNwIAIApCADcCCAwJCyACIABByM7DABCOCgALIABBgIACQcjOwwAQjQoACyADBEAgAyEAQQAhDkEAIQ8DQCAGIAg2AuzVAiAGKALo1QIiDCAIIAUgBSAISxsiA2oiByAMSQ0DIAdBgIACSw0GIAsgDmohDiAEIAYgDGogAxDgCiEMIAYgB0H//wFxIgc2AujVAiAGIAggA2s2AuzVAiADIA9qIQ9BASEEIAHAQQBIBEBBfSEHDAYLIAFFDQQgBSAITQRAQXshBwwGCyAFIANrIQUgAyAMaiEEIAkgEyACIAtqIgIgACALayIAIAZBgIACIAcgFBBXIAYgCS0ABCIBOgDw1QIgCSgCCCEIIAkoAgAiCyAATQ0ACwwBC0EAIQBBACEOQQAhDwNAIAYgCDYC7NUCIAYoAujVAiIMIAggBSAFIAhLGyIDaiIHIAxJDQIgB0GAgAJLDQUgCyAOaiEOIAQgBiAMaiADEOAKIQwgBiAHQf//AXEiETYC6NUCIAYgCCADazYC7NUCIAMgD2ohDyABwEEASARAQX0hB0EBIQQMBQtBeyEHAkAgASIEDgIEBQALIAUgCE0EQEEBIQQMBQsgBSADayEFIAMgDGohBCAJIBMgAiALaiICIAAgC2siACAGQYCAAiARIBQQVyAGIAktAAQiAToA8NUCIAkoAgghCCAJKAIAIgsgAE0NAAsLIAsgAEG4zsMAEIwKAAsgDCAHQcjOwwAQjgoAC0F7QQEgBSAISSIEGyEHCyAKIA82AgwgCiAONgIIIAogBzYCBCAKIAQ2AgAMAgsgB0GAgAJByM7DABCNCgALIAogATYCDCAKIAI2AgggCiAANgIEIAogBzYCAAsgCUEQaiQAIBIgEikDACANNQIYfDcDACASIBIpAwggDTUCHHw3AwggDSgCFCEAAkACQAJAIA0oAhBFBEAgAEEBaw4CAgMBCyAQIABBe0YEfyAQQQE6AARBAgVBAAs2AgAMBAsgEEECNgIAIBBBADoABAwDCyAQQQI2AgAgEEECOgAEDAILQQAhAAJAIAZBgIACaiIBLQDlVSICRQ0AQoCAgPA/IAKtiKcgAkEiSXENACABKALkUUUNACABKAL4USEACyAQIAA2AgQgEEEBNgIADAELIA0gADYCEEG5pMMAQSsgDUEQakHkpMMAQdClwwAQhwcACyANQSBqJAALDAAgAQRAIAAQ1AELCxsAIAAgATYCBCAAIAJCh9vHpeTTl5AnUTYCAAsUACAAKAIEIgAgACgCAEEBazYCAAsZACABKAIAQajJxABBDiABKAIEKAIMEQIACxYAIAEgACgCACIAKAIAIAAoAgQQ5AELGQAgASgCAEGg58QAQQUgASgCBCgCDBECAAsZACABKAIAQZTuxABBCyABKAIEKAIMEQIACxUAIAIgASAAQeiowAAgAygCLBEFAAsVACACIAEgAEH4qMAAIAMoAiwRBQALFQAgAiABIABBiKnAACADKAIsEQUACxUAIAIgASAAQZipwAAgAygCLBEFAAsVACACIAEgAEGoqcAAIAMoAiwRBQALFQAgAiABIABBuKnAACADKAIsEQUACxUAIAIgASAAQcipwAAgAygCLBEFAAsVACACIAEgAEHYqcAAIAMoAiwRBQALFQAgAiABIABB6KnAACADKAIsEQUACxUAIAIgASAAQfipwAAgAygCLBEFAAsVACACIAEgAEGUvsIAIAMoAiwRBQALFQAgAiABIABBpL7CACADKAIsEQUACxUAIAIgASAAQbS+wgAgAygCLBEFAAsVACACIAEgAEHEvsIAIAMoAiwRBQALFQAgAiABIABB1L7CACADKAIsEQUACxUAIAIgASAAQeS+wgAgAygCLBEFAAsVACACIAEgAEH0vsIAIAMoAiwRBQALFQAgAiABIABBhL/CACADKAIsEQUACxUAIAIgASAAQZS/wgAgAygCLBEFAAsVACACIAEgAEGkv8IAIAMoAiwRBQALFQAgAiABIABBtL/CACADKAIsEQUACxUAIAIgASAAQcS/wgAgAygCLBEFAAsVACACIAEgAEHUv8IAIAMoAiwRBQALFQAgAiABIABB5L/CACADKAIsEQUACxUAIAIgASAAQfS/wgAgAygCLBEFAAsVACACIAEgAEGEwMIAIAMoAiwRBQALFQAgAiABIABBlMDCACADKAIsEQUACxUAIAIgASAAQaTAwgAgAygCLBEFAAsVACACIAEgAEG0wMIAIAMoAiwRBQALFQAgAiABIABBxMDCACADKAIsEQUACxUAIAIgASAAQdTAwgAgAygCLBEFAAsVACACIAEgAEHkwMIAIAMoAiwRBQALFQAgAiABIABB9MDCACADKAIsEQUACxUAIAIgASAAQYTBwgAgAygCLBEFAAsVACACIAEgAEGUwcIAIAMoAiwRBQALFQAgAiABIABBpMHCACADKAIsEQUACxUAIAIgASAAQbTBwgAgAygCLBEFAAsVACACIAEgAEHEwcIAIAMoAiwRBQALEQAgACABQZgBaiACIAMQlgULEQAgACABQeAAaiACIAMQggILEwAgACgCACABKAIAIAIoAgAQPwsVACACIAEgAEHw+8MAIAMoAiwRBQALEwAgAiABIAApAwAgAygCFBETAAsTACACIAEgADUCACADKAIUERMACxMAIAIgASAAKQMAIAMoAhAREwALFAAgACgCACABIAAoAgQoAgwRAQAL4ggBA38gACEGIwBB8ABrIgAkACAAIAM2AgwgACACNgIIAkACQAJAIAACfwJAAkAgAUGBAk8EQANAIAUgBmogBUEBayEFQYACaiwAAEG/f0wNAAsgBUGBAmoiByABSQ0CIAFBgQJrIAVHDQQgACAHNgIUDAELIAAgATYCFAsgACAGNgIQQYSvxAAhB0EADAELIAUgBmpBgQJqLAAAQb9/TA0BIAAgBzYCFCAAIAY2AhBB4NfEACEHQQULNgIcIAAgBzYCGAJAAkAgASACSSIFDQAgASADSQ0AAn8CQAJAIAIgA00EQAJAAkAgAkUNACABIAJNBEAgASACRg0BDAILIAIgBmosAABBQEgNAQsgAyECCyAAIAI2AiAgASIFIAJLBEAgAkEBaiIFIAJBA2siA0EAIAIgA08bIgNJDQYgBSAGaiADIAZqayEFA0AgBUEBayEFIAIgBmogAkEBayECLAAAQUBIDQALIAJBAWohBQsCQCAFRQ0AIAEgBU0EQCABIAVGDQEMCgsgBSAGaiwAAEG/f0wNCQsgASAFRg0HAkAgBSAGaiIDLAAAIgZBAEgEQCADLQABQT9xIQEgBkEfcSECIAZBX0sNASACQQZ0IAFyIQIMBAsgACAGQf8BcTYCJEEBDAQLIAMtAAJBP3EgAUEGdHIhASAGQXBPDQEgASACQQx0ciECDAILIABB5ABqQekENgIAIABByABqIgJBFGpB6QQ2AgAgAkEMakEfNgIAIABBMGoiAUEMakEENgIAIAFBFGpBBDYCACAAQcTYxAA2AjggAEEANgIwIABBHzYCTCAAIAI2AkAgACAAQRhqNgJgIAAgAEEQajYCWCAAIABBDGo2AlAgACAAQQhqNgJIIAEgBBDaCAALIAJBEnRBgIDwAHEgAy0AA0E/cSABQQZ0cnIiAkGAgMQARg0FCyAAIAI2AiRBASACQYABSQ0AGkECIAJBgBBJDQAaQQNBBCACQYCABEkbCyEBIAAgBTYCKCAAIAEgBWo2AiwgAEEwaiICQQxqQQU2AgAgAkEUakEFNgIAIABB7ABqQekENgIAIABB5ABqQekENgIAIABByABqIgFBFGpB6wQ2AgAgAUEMakGJBDYCACAAQZjZxAA2AjggAEEANgIwIABBHzYCTCAAIAE2AkAgACAAQRhqNgJoIAAgAEEQajYCYCAAIABBKGo2AlggACAAQSRqNgJQIAAgAEEgajYCSCACIAQQ2ggACyAAIAIgAyAFGzYCKCAAQTBqIgJBDGpBAzYCACACQRRqQQM2AgAgAEHIAGoiAUEUakHpBDYCACABQQxqQekENgIAIABBiNjEADYCOCAAQQA2AjAgAEEfNgJMIAAgATYCQCAAIABBGGo2AlggACAAQRBqNgJQIAAgAEEoajYCSCACIAQQ2ggACyADIAVB3NnEABCOCgALIAYgAUEAIAcgBBDqCQALQf3DxABBKyAEEJ4IAAsgBiABIAUgASAEEOoJAAsTACAAQSg2AgQgAEGUlsAANgIACxEAIAAoAgAgACgCBCABENwKCxMAIABBKDYCBCAAQYCwwAA2AgALEwAgAEEoNgIEIABBgNTAADYCAAsTACAAQSg2AgQgAEGQ9cAANgIACwkAIAAgARCEBAsrAAJAIAAgARCEBCIBRQ0AIAFBCGstAARBA3FFDQAgAUEAIAAQ4goaCyABCxMAIABBKDYCBCAAQdSWwQA2AgALEwAgAEEoNgIEIABBsMTBADYCAAsTACAAQSg2AgQgAEGQm8IANgIACxEAIAAgAkHYABDgCiABNgJYCxMAIABBKDYCBCAAQbm7wgA2AgALEwAgAEEoNgIEIABB6NHCADYCAAsWAEHE9MQAIAA2AgBBwPTEAEEBOgAACxwAIAEoAgAgACgCACAAKAIEIAEoAgQoAgwRAgALEQAgACgCACAAKAIEIAEQhAILEwAgAEHQmsQANgIEIAAgATYCAAsPACAAIAFBBGopAgA3AwALEQAgASAAKAIAIAAoAgQQ5AELDQAgACgCACABIAIQFQsNACAAKAIAIAEgAhAxCwwAIAAoAgAQM0EARwsPACAAKAIAIAEoAgAQNBoLDwAgACgCACABKAIAEDUaCwwAIAAoAgAQOkEARwsMACAAKAIAED1BAEcLDgAgACgCACABKAIAED4LDgAgACgCACABKAIAEEQLDQAgACgCACABIAIQRQsMACAAKAIAEE1BAEcL9gEBBn8gACgCACgCACECIwBBgAFrIgMkACABQQxqKAIAIQcgASgCCCEFAkAgASgCGCIGIgBBBHFFDQAgBkEIciEAIAUNACABQoGAgICgATcCCAsgASAAQQRyNgIYQQAhAANAIAAgA2pB/wBqQTBB1wAgAkEPcSIEQQpJGyAEajoAACAAQQFrIQAgAkEPSyACQQR2IQINAAsCQCAAQYABaiICQYEBSQRAIAFBAUH4zsQAQQIgACADakGAAWpBACAAaxC2AiEAIAEgBjYCGCABIAc2AgwgASAFNgIIIANBgAFqJAAMAQsgAkGAAUHozsQAEIwKAAsgAAumBAEFfyAAKAIAIQMjAEEQayIEJAACQAJ/AkACQCABQYABTwRAIARBADYCDCABQYAQSQ0BIAFBgIAETw0CIAQgAUE/cUGAAXI6AA4gBCABQQx2QeABcjoADCAEIAFBBnZBP3FBgAFyOgANQQMMAwsgAygCCCICIAMoAgBGBEAjAEEgayIAJAACQAJAIAJBAWoiAkUNAEEIIAMoAgAiBUEBdCIGIAIgAiAGSRsiAiACQQhNGyICQX9zQR92IQYCQCAFBEAgAEEBNgIYIAAgBTYCFCAAIANBBGooAgA2AhAMAQsgAEEANgIYCyAAIAIgBiAAQRBqELgGIAAoAgQhBSAAKAIARQRAIAMgAjYCACADIAU2AgQMAgsgAEEIaigCACICQYGAgIB4Rg0BIAJFDQAgBSACQfD0xAAoAgAiAEHKBCAAGxEAAAALEMcIAAsgAEEgaiQAIAMoAgghAgsgAyACQQFqNgIIIAMoAgQgAmogAToAAAwDCyAEIAFBP3FBgAFyOgANIAQgAUEGdkHAAXI6AAxBAgwBCyAEIAFBP3FBgAFyOgAPIAQgAUEGdkE/cUGAAXI6AA4gBCABQQx2QT9xQYABcjoADSAEIAFBEnZBB3FB8AFyOgAMQQQLIQAgACADKAIAIAMoAggiAmtLBEAgAyACIAAQqwYgAygCCCECCyADKAIEIAJqIARBDGogABDgChogAyAAIAJqNgIICyAEQRBqJABBAAsOACAAKAIAGgNADAALAAt7AQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EIaiIAQQxqQQI2AgAgA0EcakECNgIAIANBIGoiAUEMakEfNgIAIANBjNPEADYCECADQQA2AgggA0EfNgIkIAMgATYCGCADIANBBGo2AiggAyADNgIgIAAgAhDaCAALewEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBCGoiAEEMakECNgIAIANBHGpBAjYCACADQSBqIgFBDGpBHzYCACADQazTxAA2AhAgA0EANgIIIANBHzYCJCADIAE2AhggAyADQQRqNgIoIAMgAzYCICAAIAIQ2ggAC3sBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQQhqIgBBDGpBAjYCACADQRxqQQI2AgAgA0EgaiIBQQxqQR82AgAgA0Hg08QANgIQIANBADYCCCADQR82AiQgAyABNgIYIAMgA0EEajYCKCADIAM2AiAgACACENoIAAsOACAANQIAQQEgARDdBAttAQF/IwBBEGsiAyQAIAMgATYCDCADIAA2AggjAEEgayIAJAAgAEEMakEBNgIAIABBFGpBATYCACAAQcTKxAA2AgggAEEANgIAIABB6QQ2AhwgACADQQhqNgIYIAAgAEEYajYCECAAIAIQ2ggAC8kCAgR/An4jAEFAaiIDJABBASEFAkAgAC0ABA0AIAAtAAUhBQJAAkACQCAAKAIAIgQoAhgiBkEEcUUEQCAFDQEMAwsgBQ0BQQEhBSAEKAIAQbnMxABBASAEKAIEKAIMEQIADQMgBCgCGCEGDAELQQEhBSAEKAIAQZ3MxABBAiAEKAIEKAIMEQIARQ0BDAILQQEhBSADQQE6ABcgA0H8y8QANgIcIAMgBCkCADcDCCADIANBF2o2AhAgBCkCCCEHIAQpAhAhCCADIAQtACA6ADggAyAEKAIcNgI0IAMgBjYCMCADIAg3AyggAyAHNwMgIAMgA0EIajYCGCABIANBGGogAigCDBEBAA0BIAMoAhhBm8zEAEECIAMoAhwoAgwRAgAhBQwBCyABIAQgAigCDBEBACEFCyAAQQE6AAUgACAFOgAEIANBQGskAAsOACAAKAIAIAEgAhDoAwsOACAAMQAAQQEgARDdBAsOACAAKQMAQQEgARDdBAvKAwIBfgR/IAAoAgApAwAhAiMAQYABayIFJAACQAJAAkACQCABKAIYIgBBEHFFBEAgAEEgcQ0BIAJBASABEN0EIQAMBAtBgAEhACAFQYABaiEEAkACQANAIABFBEBBACEADAMLIARBAWtBMEHXACACpyIDQQ9xIgZBCkkbIAZqOgAAIAJCEFoEQCAEQQJrIgQgA0H/AXEiA0EEdkEwQdcAIANBoAFJG2o6AAAgAEECayEAIAJCgAJUIAJCCIghAkUNAQwCCwsgAEEBayEACyAAQYEBTw0CCyABQQFB+M7EAEECIAAgBWpBgAEgAGsQtgIhAAwDC0GAASEAIAVBgAFqIQQCQAJAA0AgAEUEQEEAIQAMAwsgBEEBa0EwQTcgAqciA0EPcSIGQQpJGyAGajoAACACQhBaBEAgBEECayIEIANB/wFxIgNBBHZBMEE3IANBoAFJG2o6AAAgAEECayEAIAJCgAJUIAJCCIghAkUNAQwCCwsgAEEBayEACyAAQYEBTw0CCyABQQFB+M7EAEECIAAgBWpBgAEgAGsQtgIhAAwCCyAAQYABQejOxAAQjAoACyAAQYABQejOxAAQjAoACyAFQYABaiQAIAALCwAgACMAaiQAIwALwgIBAn8gACgCACEAIwBBEGsiAyQAAn8gAC8BDEECRgRAIAEoAgBBkqrCAEEEIAEoAgQoAgwRAgAMAQsgAyAANgIEIAMgAEEMajYCCCADIABBCGo2AgwjAEEQayICJAAgAiABKAIAQZCqwgBBAiABKAIEKAIMEQIAOgAIIAIgATYCBCACQQA6AAkgAkEANgIAIAIgA0EEakHwmsIAEPgEIANBCGpBwJrCABD4BCADQQxqQZCawgAQ+AQhAAJ/IAItAAgiASAAKAIAIgBFDQAaQQEgAQ0AGiACKAIEIQECQCAAQQFHDQAgAi0ACUUNACABLQAYQQRxDQBBASABKAIAQbjMxABBASABKAIEKAIMEQIADQEaCyABKAIAQZvJxABBASABKAIEKAIMEQIACyACQRBqJABB/wFxQQBHCyADQRBqJAALDAAgACgCACABEKkFCwwAIAAoAgAgARDuBQv4AQEBfyAAKAIAIQIjAEEQayIAJAACfwJAAkACQAJAAkACQCACKAIAQQFrDgUBAgMEBQALIAAgAkEEajYCDCABQc+OwwBBBSAAQQxqQfiMwwAQugYMBQsgACACQQRqNgIMIAFBu47DAEEUIABBDGpB+IzDABC6BgwECyAAIAJBBGo2AgwgAUGqjsMAQREgAEEMakH4jMMAELoGDAMLIAEoAgBBno7DAEEMIAEoAgQoAgwRAgAMAgsgACACQQRqNgIMIAFBj47DAEEPIABBDGpB+IzDABC6BgwBCyABKAIAQYSOwwBBCyABKAIEKAIMEQIACyAAQRBqJAALDAAgACgCACABELABCwwAIAAoAgAgARCPCgsMACAAKAIAIAEQ+wYL+wEBAX8gACgCACECIwBB0ABrIgAkACAAQTRqQdSQwgA2AgAgAEEsakH0lcIANgIAIABBJGpB9JXCADYCACAAQRxqQeSVwgA2AgAgAEEUakHUlcIANgIAIAAgAkEgajYCOCAAIAI2AjwgACACQUBrNgJAIAAgAkEoajYCRCAAIAJBNGo2AkggAEG0k8IANgIMIAAgAkHMAGo2AkwgACAAQcwAajYCMCAAIABByABqNgIoIAAgAEHEAGo2AiAgACAAQUBrNgIYIAAgAEE8ajYCECAAIABBOGo2AgggAUGElsIAQQJBpJXCAEEGIABBCGpBBhC0BSAAQdAAaiQAC2gBAX8gACgCACECIwBBEGsiACQAAn8gAi0AAEELRgRAIAAgAkEBajYCCCABQeiWwgBBBiAAQQhqQdSSwgAQugYMAQsgACACNgIMIAFB0JbCAEEGIABBDGpB2JbCABC6BgsgAEEQaiQACwwAIAAoAgAgARC+BAvfAQEBfyAAKAIAIQIjAEHgAGsiACQAIAAgAUHcjsIAQQoQhQkgAEEgaiIBQRhqIAJBGGopAAA3AwAgAUEQaiACQRBqKQAANwMAIAFBCGogAkEIaikAADcDACAAIAIpAAA3AyAgAEFAayICQYCAxAA2AgwgAkHwusIANgIIIAIgATYCBCACIAFBIGo2AgAgAEHQAGoiAUEIaiACQQhqKQMANwMAIAAgACkDQDcDUCAAQRBqIgIgARDTAyAAIAJBjI3CABD4BBD4BiAAKAIQBEAgACgCFBDUAQsgAEHgAGokAAtBAAJ/IAAoAgAtAABFBEAgASgCAEHN5MIAQQYgASgCBCgCDBECAAwBCyABKAIAQcjkwgBBBSABKAIEKAIMEQIACwugAgEBfyAAKAIAIQIjAEHgAGsiACQAIABBPGpBhKvCADYCACAAQTRqQfSqwgA2AgAgAEEsakHkqsIANgIAIABBJGpBuJvCADYCACAAQRxqQfCawgA2AgAgAEEUakHwmsIANgIAIAAgAkFAazYCRCAAIAJBEGo2AkggACACQRhqNgJMIAAgAkEgajYCUCAAIAJBKGo2AlQgACACQcQAajYCWCAAQZCawgA2AgwgACACNgJcIAAgAEHcAGo2AjggACAAQdgAajYCMCAAIABB1ABqNgIoIAAgAEHQAGo2AiAgACAAQcwAajYCGCAAIABByABqNgIQIAAgAEHEAGo2AgggAUGUq8IAQQ5BrKrCAEEHIABBCGpBBxC0BSAAQeAAaiQACzgBAX8gACgCACECIwBBEGsiACQAIAAgAjYCDCABQYSVwgBBBSAAQQxqQbSTwgAQugYgAEEQaiQACwwAIAAoAgAgARDHAwsZACABKAIAQYTGwABBCiABKAIEKAIMEQIACxkAIAEoAgBB/MfAAEEFIAEoAgQoAgwRAgALQQACfyAAKAIALQAARQRAIAEoAgBBgbHBAEEFIAEoAgQoAgwRAgAMAQsgASgCAEH4sMEAQQkgASgCBCgCDBECAAsLggIBAn8gACgCACECIwBBEGsiACQAAn8CQAJAAkACQAJAAkBBBCACKAIAIgNBCGsgA0EHTRtBAWsOBQECAwQFAAsgASgCAEHQ0MIAQQwgASgCBCgCDBECAAwFCyAAIAJBBGo2AgwgAUG40MIAQQYgAEEMakHA0MIAELoGDAQLIAAgAkEEajYCDCABQaDQwgBBBiAAQQxqQajQwgAQugYMAwsgACACQQRqNgIMIAFBiNDCAEEGIABBDGpBkNDCABC6BgwCCyAAIAI2AgwgAUHvz8IAQQggAEEMakH4z8IAELoGDAELIAEoAgBB6M/CAEEHIAEoAgQoAgwRAgALIABBEGokAAuKBQECfyAAKAIAIQIjAEEwayIAJAACfwJAAkACQAJAAkACQEEEIAIoAgAiA0EIayADQQdNG0EBaw4FAQIDBAUACyAAQSRqQQE2AgAgAEEsakEANgIAIABB4M/CADYCICAAQZi7wgA2AiggAEEANgIYIAEgAEEYahDkBwwFCwJAAkACQCACLQAEQQFrDgIBAgALIABBJGpBATYCACAAQSxqQQA2AgAgAEGUlsEANgIgIABB0JDBADYCKCAAQQA2AhggASAAQRhqEOQHDAYLIABBJGpBATYCACAAQSxqQQA2AgAgAEHclcEANgIgIABB0JDBADYCKCAAQQA2AhggASAAQRhqEOQHDAULIABBJGpBATYCACAAQSxqQQA2AgAgAEG0lcEANgIgIABB0JDBADYCKCAAQQA2AhggASAAQRhqEOQHDAQLIABBJGpBATYCACAAQSxqQQE2AgAgAEGoz8IANgIgIABBADYCGCAAQYIDNgIMIAAgAkEEajYCFCAAIABBCGo2AiggACAAQRRqNgIIIAEgAEEYahDkBwwDCyAAQSRqQQE2AgAgAEEsakEBNgIAIABBiM/CADYCICAAQQA2AhggAEGDAzYCDCAAIAJBBGo2AhQgACAAQQhqNgIoIAAgAEEUajYCCCABIABBGGoQ5AcMAgsgAEEkakEBNgIAIABBLGpBATYCACAAQezOwgA2AiAgAEEANgIYIABBhAM2AgwgACACNgIUIAAgAEEIajYCKCAAIABBFGo2AgggASAAQRhqEOQHDAELIABBJGpBATYCACAAQSxqQQA2AgAgAEHQzsIANgIgIABBmLvCADYCKCAAQQA2AhggASAAQRhqEOQHCyAAQTBqJAALDAAgACgCACABENcBCwwAIAAoAgAgARCsBQvaAgEDfyAAKAIAIQIjAEFAaiIAJAACfwJAAkACQCACKAIAQQFrDgIBAgALIABBHGpBATYCACAAQSRqQQE2AgAgAEHs5cAANgIYIABBADYCECAAQeoANgIsIAAgAkEEajYCPCAAIABBKGo2AiAgACAAQTxqNgIoIAEgAEEQahDkBwwCCyAAQRxqQQE2AgAgAEEkakEBNgIAIABB1OXAADYCGCAAQQA2AhAgAEGQATYCLCAAIAJBBGo2AjwgACAAQShqNgIgIAAgAEE8ajYCKCABIABBEGoQ5AcMAQsgACACQQRqNgIMIABBEGoiA0EMakECNgIAIABBJGpBAjYCACAAQShqIgRBDGpB6wA2AgAgAEH85MAANgIYIABBADYCECAAQYsBNgIsIAAgAkEIajYCPCAAIAQ2AiAgACAAQQxqNgIwIAAgAEE8ajYCKCABIAMQ5AcLIABBQGskAAu9AgEDfyAAKAIAIQIjAEFAaiIAJAACfwJAAkACQCACKAIAQQFrDgIBAgALIABBLGpBATYCACAAQTRqQQA2AgAgAEHo7cAANgIoIABB8N/AADYCMCAAQQA2AiAgASAAQSBqEOQHDAILIABBCGoiA0EMakGPATYCACAAQSBqIgRBDGpBAjYCACAAQTRqQQI2AgAgACACQQRqNgIcIABBwO3AADYCKCAAQQA2AiAgAEGLATYCDCAAIAJBEGo2AjwgACADNgIwIAAgAEE8ajYCECAAIABBHGo2AgggASAEEOQHDAELIABBLGpBATYCACAAQTRqQQE2AgAgAEGo7cAANgIoIABBADYCICAAQTE2AgwgACACQQhqNgI8IAAgAEEIajYCMCAAIABBPGo2AgggASAAQSBqEOQHCyAAQUBrJAAL8wIBA38gACgCACECIwBBMGsiACQAAn8CQAJAAkACQCACLQAAIgNBEmsiBEEAIAMgBE8bQQFrDgMBAgMACyACIAEQsAEMAwsgAEEMakGLATYCACAAQRhqIgNBDGpBAzYCACAAQSxqQQI2AgAgACACQQRqNgIQIABBkO/AADYCICAAQQA2AhggAEHoADYCBCAAIAJBCGo2AhQgACAANgIoIAAgAEEUajYCCCAAIABBEGo2AgAgASADEOQHDAILIABBDGpBiwE2AgAgAEEYaiIDQQxqQQM2AgAgAEEsakECNgIAIAAgAkEEajYCECAAQczuwAA2AiAgAEEANgIYIABB6AA2AgQgACACQQhqNgIUIAAgADYCKCAAIABBFGo2AgggACAAQRBqNgIAIAEgAxDkBwwBCyAAQSRqQQE2AgAgAEEsakEANgIAIABBkO7AADYCICAAQfDfwAA2AiggAEEANgIYIAEgAEEYahDkBwsgAEEwaiQAC6ADAQN/IAAoAgAhAiMAQUBqIgAkAAJ/AkACQAJAAkAgAigCAEEBaw4DAQIDAAsgAEEcakEBNgIAIABBJGpBADYCACAAQfTiwAA2AhggAEHw38AANgIgIABBADYCECABIABBEGoQ5AcMAwsgACACQQRqNgIMIABBEGoiA0EMakECNgIAIABBJGpBAjYCACAAQShqIgRBDGpB6wA2AgAgAEH85MAANgIYIABBADYCECAAQYsBNgIsIAAgAkEIajYCPCAAIAQ2AiAgACAAQQxqNgIwIAAgAEE8ajYCKCABIAMQ5AcMAgsgAEEcakEBNgIAIABBJGpBADYCACAAQdziwAA2AhggAEHw38AANgIgIABBADYCECABIABBEGoQ5AcMAQsgACACQQRqNgIMIABBEGoiA0EMakECNgIAIABBJGpBAjYCACAAQShqIgRBDGpB5wA2AgAgAEGw4sAANgIYIABBADYCECAAQesANgIsIAAgAkEIajYCPCAAIAQ2AiAgACAAQTxqNgIwIAAgAEEMajYCKCABIAMQ5AcLIABBQGskAAtdAQF/IAAoAgAhAiMAQRBrIgAkAAJ/IAIoAgBFBEAgASgCAEGk9MIAQQcgASgCBCgCDBECAAwBCyAAIAI2AgwgAUGQ9MIAQQQgAEEMakGU9MIAELoGCyAAQRBqJAALDAAgACgCACABENoGC20BAX8gACgCACECIwBBMGsiACQAIABBFGpBATYCACAAQRxqQQE2AgAgAEHAlMMANgIQIABBADYCCCAAQdEBNgIkIAAgAjYCLCAAIABBIGo2AhggACAAQSxqNgIgIAEgAEEIahDkByAAQTBqJAALpwEBAn8gACgCACECIwBBMGsiACQAAn8gAigCACICKAIARQRAIAJBCGogARCdBQwBCyAAQRhqIgNBFGpBHzYCACADQQxqQR82AgAgAEEMakEDNgIAIABBFGpBAzYCACAAQbD0wwA2AgggAEEANgIAIABB/gM2AhwgACACNgIgIAAgAkEEajYCKCAAIAJBCGo2AhggACADNgIQIAEgABDkBwsgAEEwaiQACwwAIAAoAgAgARD3BgsMACAAKAIAIAEQjAcLXwEBfyAAKAIAIQIjAEEQayIAJAACfyACLQAAQQRHBEAgACACNgIMIAFBnNDDAEEHIABBDGpBpNDDABC6BgwBCyABKAIAQZTQwwBBCCABKAIEKAIMEQIACyAAQRBqJAALDAAgACgCACABEOsDCwwAIAAoAgAgARCnBAvyAQEDfwJAAkACQAJAAkBBASAAKAIAIgAtABciAkEYayACQRdNG0H/AXFBAWsOAgABAgsgACACIAEQhAIhAAwDCwJAIAAoAgAiA0EgSw0AIAAoAgQiBEGAAUsNACAEQSBqIQJBICADayEAIANBIEcEQCAAQdyHxABqLAAAQUBIDQMLIARB/wBNBEAgAkHch8QAaiwAAEG/f0wNAwsgAEHch8QAaiACIABrIAEQhAIhAAwDC0GLh8QAQT5BzIfEABCeCAALIAAoAgBBCGogACgCBCABEIQCIQAMAQtB3IfEAEGgASAAIAJB/IjEABDqCQALIAALowIBAX8gACgCACECIwBBEGsiACQAAn8CQAJAAkACQAJAAkAgAi0AAEEBaw4FAQIDBAUACyAAIAJBBGo2AgwgAUHQ9MEAQQIgAEEMakHU9MEAELoGDAULIAAgAkEBajYCDCABQbj0wQBBByAAQQxqQcD0wQAQugYMBAsgACACQQRqNgIMIAFBoPTBAEEGIABBDGpBqPTBABC6BgwDCyAAIAJBAWo2AgwgAUGE9MEAQQkgAEEMakGQ9MEAELoGDAILIAAgAkEEajYCCCAAIAJBCGo2AgwgAUHh88EAQRNB9PPBAEEJIABBCGpB3OfBAEH988EAQQcgAEEMakHc58EAEMUGDAELIAEoAgBB2PPBAEEJIAEoAgQoAgwRAgALIABBEGokAAsMACAAKAIAIAEQwQML8gEBA38CQAJAAkACQAJAQQEgACgCACIALQAXIgJBGGsgAkEXTRtB/wFxQQFrDgIAAQILIAAgAiABENwKIQAMAwsCQCAAKAIAIgNBIEsNACAAKAIEIgRBgAFLDQAgBEEgaiECQSAgA2shACADQSBHBEAgAEHch8QAaiwAAEFASA0DCyAEQf8ATQRAIAJB3IfEAGosAABBv39MDQMLIABB3IfEAGogAiAAayABENwKIQAMAwtBi4fEAEE+QcyHxAAQnggACyAAKAIAQQhqIAAoAgQgARDcCiEADAELQdyHxABBoAEgACACQfyIxAAQ6gkACyAAC8MBAQJ/IAAoAgAhAiMAQRBrIgAkAAJ/AkACQAJAAkBBAyACLQAAIgNBCmsgA0EJTRtB/wFxQQFrDgMBAgMACyAAIAJBAWo2AgQgAUHXlMIAQQQgAEEEakHUksIAELoGDAMLIAEoAgBB0ZTCAEEGIAEoAgQoAgwRAgAMAgsgACACQQhqNgIIIAFByJTCAEEJIABBCGpBoJPCABC6BgwBCyAAIAI2AgwgAUG0lMIAQQMgAEEMakG4lMIAELoGCyAAQRBqJAALDAAgACgCACABEJQCCwwAIAAoAgAgARDOBQsOACABQbKYwgBBAhDkAQuQAgECfyAAKAIAIQIjAEEQayIAJAACfwJAAkACQAJAAkBBBCACKAIAIgNBBGsgA0EESRtBAWsOBAECAwQACyAAIAJBBGo2AgwgAUGUscIAQQYgAEEMakGcscIAELoGDAQLIAAgAkEEajYCDCABQfiwwgBBCiAAQQxqQYSxwgAQugYMAwsgACACQQRqNgIIIAAgAkEMajYCDCABQbSwwgBBD0HDsMIAQQsgAEEIakHQsMIAQeCwwgBBBSAAQQxqQeiwwgAQxQYMAgsgACACQQRqNgIMIAFBmbDCAEEJIABBDGpBpLDCABC6BgwBCyAAIAI2AgwgAUGMsMIAQQ0gAEEMakG8ncIAELoGCyAAQRBqJAALDAAgACgCACABEK8GCwwAIAAoAgAgARCgCQusCQMIfwZ+AnwgACgCACECIAEoAhhBAXEhAAJAIAEoAhBBAUYEQCABIAIrAwAgACABQRRqKAIAEIMCIQAMAQsgAikDACIKvyEQAkAgCkL///////////8Ag78iEUQAgOA3ecNBQ2YNACARRAAAAAAAAAAAYiARRC1DHOviNho/Y3ENACABIBAgAEEBEN8CIQAMAQsjAEGgAWsiAiQAIBC9IQoCQCAQIBBiBEBBAiEDDAELIApC/////////weDIg5CgICAgICAgAiEIApCAYZC/v///////w+DIApCNIinQf8PcSIEGyILQgGDIQ1BAyEDAkACQAJAQQFBAkEEIApCgICAgICAgPj/AIMiD1AiBhsgD0KAgICAgICA+P8AURtBA0EEIAYbIA5QG0ECaw4DAAECAwtBBCEDDAILIARBswhrIQUgDVAhA0IBIQwMAQtCgICAgICAgCAgC0IBhiALQoCAgICAgIAIUSIFGyELQgJCASAFGyEMIA1QIQNBy3dBzHcgBRsgBGohBQsgAiAFOwGYASACIAw3A5ABIAJCATcDiAEgAiALNwOAASACIAM6AJoBAn8gA0ECRgRAQYSvxAAhBkEADAELIABFBEBBqMjEAEGEr8QAIApCAFMbIQYgCkI/iKcMAQtBqMjEAEGpyMQAIApCAFMbIQZBAQshAEEBIQUCfwJAAkACQAJAQQMgA0ECayADQQFNG0H/AXFBAWsOAwIBAAMLIAJBKGogAkGAAWogAkEXahCIAQJAIAIoAihFBEAgAkHwAGogAkGAAWogAkEXahBeDAELIAJB+ABqIAJBMGooAgA2AgAgAiACKQMoNwNwCyACQQhqIQggAigCcCEEIAIvAXghByACQShqIQMCQAJAIAIoAnQiCQRAIAQtAABBMUkNASADQQE2AgggAyAENgIEIANBAjsBACAJQQFNDQIgA0ECOwEYIANBAjsBDCADQSBqIAlBAWs2AgAgA0EcaiAEQQFqNgIAIANBFGpBATYCACADQRBqQfrGxAA2AgBBAyEFDAILQdzDxABBIUH8xsQAEJ4IAAtBkMbEAEEhQYzHxAAQnggACwJAAkACQAJAAn8gB8FBAEoEQCADIAVBDGxqIgRBATYCCCAEQfXHxAA2AgQgBEECOwEAIAVBAWoiBEEGTw0CIAdBAWsMAQsgAyAFQQxsaiIEQQI2AgggBEHSx8QANgIEIARBAjsBACAFQQFqIgRBBk8NAkEBIAdrCyEHIAMgBEEMbGoiBCAHOwECIARBATsBACAFQQJqIgVBBksNAiAIIAU2AgQgCCADNgIADAMLIARBBkGIyMQAEJwHAAsgBEEGQeTHxAAQnAcACyAFQQZBmMjEABCNCgALIAIoAgwhBSACKAIIDAMLIAJBAzYCMCACQQI7ASggAkG0yMQANgIsIAJBKGoMAgsgAkEDNgIwIAJBq8jEADYCLCACQQI7ASggAkEoagwBCyACQQM2AjAgAkGuyMQANgIsIAJBAjsBKCACQShqCyEDIAJB/ABqIAU2AgAgAiADNgJ4IAIgADYCdCACIAY2AnAgASACQfAAahCDAyEAIAJBoAFqJAALIAALDAAgACgCACABEJMKCwwAIAAoAgAgARCQCQsMACAAKAIAIAEQlAoLDAAgACgCACABEM4IC8IGAQN/IAAoAgAhACMAQUBqIgIkAAJAAkACQAJAAkACQEEEIAAoAgAiA0EEayADQQRJG0EBaw4EAQIDBAALAkACQAJAIAAtAARBAWsOAgECAAsgAkEsakEBNgIAIAJBNGpBADYCACACQZSWwQA2AiggAkHQkMEANgIwIAJBADYCICABIAJBIGoQ5AchAAwGCyACQSxqQQE2AgAgAkE0akEANgIAIAJB3JXBADYCKCACQdCQwQA2AjAgAkEANgIgIAEgAkEgahDkByEADAULIAJBLGpBATYCACACQTRqQQA2AgAgAkG0lcEANgIoIAJB0JDBADYCMCACQQA2AiAgASACQSBqEOQHIQAMBAsjAEEgayIDJAACfwJAAkACQEECIABBBGoiAC0AACIEQQRrIARBA00bQf8BcUEBaw4CAQIACyADQRRqQQE2AgAgA0EcakEANgIAIANBoPjBADYCECADQYTnwQA2AhggA0EANgIIIAEgA0EIahDkBwwCCwJAAkACQCAALQABQQFrDgIBAgALIANBFGpBATYCACADQRxqQQA2AgAgA0GUlsEANgIQIANB0JDBADYCGCADQQA2AgggASADQQhqEOQHDAMLIANBFGpBATYCACADQRxqQQA2AgAgA0HclcEANgIQIANB0JDBADYCGCADQQA2AgggASADQQhqEOQHDAILIANBFGpBATYCACADQRxqQQA2AgAgA0G0lcEANgIQIANB0JDBADYCGCADQQA2AgggASADQQhqEOQHDAELIAAgARCV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NWZhZWMzY2EzZmI1MDdjMzQwNS9saWJyYXJ5L2NvcmUvc3JjL3N0ci9wYXR0ZXJuLnJzAHgBEABPAAAAuAEAACYAAABfYW1fcmF3X3ZhbHVlX19hbV9kYXRhdHlwZV9fYW1fb2JqZWN0SWQAQYyEwAALAQIAQaCEwAALxgFfYW1fbWV0YXNwbGljZWJvb2xlYW5pbnRzdHJmNjRieXRlc2NhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUAAA4AAAAEAAAABAAAAA8AAABhdXRvbWVyZ2Utd2FzbS9zcmMvaW50ZXJvcC5ycwAAAIACEAAdAAAALQQAABEAAABjb3VudGVydGltZXN0YW1wSW52YWxpZCB2YWx1ZWludmFsaWQgZW51bSB2YWx1ZSBwYXNzZWQAQfSFwAALhxZtdXN0IHBhc3MgYSBib29sIHRvIGVuYWJsZUZyZWV6ZW11c3QgcGFzcyBhIGJvb2wgdG8gZW5hYmxlUGF0Y2hlcy9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9jb25zb2xlX2Vycm9yX3BhbmljX2hvb2stMC4xLjcvc3JjL2xpYi5ycwA1AxAAZgAAAJUAAAAOAAAAaGVhZHMAAAAQAAAACAAAAAQAAAARAAAAYXV0b21lcmdlLXdhc20vc3JjL2xpYi5ycwAAAMQDEAAZAAAAcgMAAAUAAABuZWVkxAMQABkAAABzAwAABQAAAGhhdmXEAxAAGQAAAHQDAAAFAAAAY2hhbmdlcwDEAxAAGQAAAHUDAAAFAAAAEwAAAAwAAAAEAAAAFAAAABUAAAAMAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQAWAAAAAAAAAAEAAAANAAAAL3J1c3RjL2ZjNTk0ZjE1NjY5NjgwZmE3MGQyNTVmYWVjM2NhM2ZiNTA3YzM0MDUvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAJAEEABLAAAA6AkAAAkAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlL3J1c3RjL2ZjNTk0ZjE1NjY5NjgwZmE3MGQyNTVmYWVjM2NhM2ZiNTA3YzM0MDUvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvYnRyZWUvbmF2aWdhdGUucnMAABcFEABfAAAAugAAABUAAAAXBRAAXwAAAJUAAAASAAAAYXNzZXJ0aW9uIGZhaWxlZDogbmV3bGluZXMgPD0gTl9ORVdMSU5FUyAmJiBzcGFjZXMgPD0gTl9TUEFDRVMvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvc21vbF9zdHItMC4xLjI0L3NyYy9saWIucnMAAADWBRAAVwAAAL8BAAARAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgINYFEABXAAAAwAEAABIAAAAvcnVzdGMvZmM1OTRmMTU2Njk2ODBmYTcwZDI1NWZhZWMzY2EzZmI1MDdjMzQwNS9saWJyYXJ5L2NvcmUvc3JjL3NsaWNlL2l0ZXIucnMAAPAGEABOAAAAzwUAABUAAABhdHRlbXB0IHRvIGRpdmlkZSBieSB6ZXJvL3J1c3RjL2ZjNTk0ZjE1NjY5NjgwZmE3MGQyNTVmYWVjM2NhM2ZiNTA3YzM0MDUvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvYnRyZWUvbWFwLnJzAGkHEABaAAAA+QAAACgAAABpBxAAWgAAAB4BAAAbAAAAc2hhcmVkSGVhZHNjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlAAAXAAAABAAAAAQAAAAPAAAAYXV0b21lcmdlLXdhc20vc3JjL2ludGVyb3AucnMAAAAsCBAAHQAAADMAAAAJAAAAbGFzdFNlbnRIZWFkcwAAACwIEAAdAAAANAAAAAkAAAB0aGVpckhlYWRzAAAsCBAAHQAAADUAAAAJAAAAdGhlaXJOZWVkAAAALAgQAB0AAAA2AAAA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AFcAAABWAAAAGAAAAAQAAABYAAAAVwAAALwdEABZAAAAWgAAAFsAAABcAAAAXQAAAF4AAAAoAAAABAAAAF8AAABeAAAAKAAAAAQAAABgAAAAXwAAAPgdEABhAAAAYgAAAGMAAABkAAAAZQAAAHNoYXJlZEhlYWRzbGFzdFNlbnRIZWFkc3RoZWlySGVhZHN0aGVpck5lZWR0aGVpckhhdmVzZW50SGFzaGVzaW5GbGlnaHRsYXN0U3luY2Jsb29taGVhZHNuZWVkY2hhbmdlc2hhdmUAVHJpZWQgdG8gc2hyaW5rIHRvIGEgbGFyZ2VyIGNhcGFjaXR5nB4QACQAAAAvcnVzdGMvZmM1OTRmMTU2Njk2ODBmYTcwZDI1NWZhZWMzY2EzZmI1MDdjMzQwNS9saWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjLnJzyB4QAEwAAACqAQAACQAAAC9ydXN0Yy9mYzU5NGYxNTY2OTY4MGZhNzBkMjU1ZmFlYzNjYTNmYjUwN2MzNDA1L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzAAAkHxAASgAAAI0AAAARAAAAYXNzZXJ0aW9uIGZhaWxlZDogaWR4IDwgQ0FQQUNJVFkvcnVzdGMvZmM1OTRmMTU2Njk2ODBmYTcwZDI1NWZhZWMzY2EzZmI1MDdjMzQwNS9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9ub2RlLnJzAKAfEABbAAAAegIAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBlZGdlLmhlaWdodCA9PSBzZWxmLmhlaWdodCAtIDGgHxAAWwAAAIcCAAAJAAAAoB8QAFsAAACLAgAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IHNyYy5sZW4oKSA9PSBkc3QubGVuKCmgHxAAWwAAANQGAAAFAAAAoB8QAFsAAABWBAAAFgAAAKAfEABbAAAAlgQAABYAAABhc3NlcnRpb24gZmFpbGVkOiBlZGdlLmhlaWdodCA9PSBzZWxmLm5vZGUuaGVpZ2h0IC0gMQAAAKAfEABbAAAArAMAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBvbGRfbGVmdF9sZW4gPj0gY291bnQAoB8QAFsAAACEBQAADQAAAGFzc2VydGlvbiBmYWlsZWQ6IGxlbiA+IDAAAACgHxAAWwAAAGIBAAAJAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZS9ydXN0Yy9mYzU5NGYxNTY2OTY4MGZhNzBkMjU1ZmFlYzNjYTNmYjUwN2MzNDA1L2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL2J0cmVlL25hdmlnYXRlLnJzAACLIRAAXwAAAEwCAAANAAAAiyEQAF8AAAAKAgAAFgAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUvaG9tZS9ydW5uZXIvd29yay9hdXRvbWVyZ2UtcnMvYXV0b21lcmdlLXJzL3J1c3QvYXV0b21lcmdlL3NyYy9hdXRvY29tbWl0LnJzADciEABMAAAADQIAAB0AAAA3IhAATAAAAGUCAAAdAAAANyIQAEwAAAApAgAAHQAAADciEABMAAAAAgIAAB0AAAA3IhAATAAAAEQCAAAdAAAANyIQAEwAAAAYAgAAHQAAADciEABMAAAAUgIAAB0AAAA3IhAATAAAADoCAAAdAAAAYSBzZXF1ZW5jZQAAbAAAAAAAAAABAAAAbQAAAG51bGxhIG51bWJlciQjEAAIAAAAbAAAAAgAAAAEAAAAPgAAAHZhbHVlYWN0aW9ub2Jqa2V5ZWxlbUlkcHJlZGluc2VydGRhdGF0eXBlbmFtZWV4cGFuZHJlZm9wc2RlcHNtZXNzYWdlc2VxYWN0b3JyZXF1ZXN0VHlwZQB6IxAAAwAAAH0jEAAEAAAAgSMQAAcAAACIIxAAAwAAAIsjEAAFAAAAkCMQAAsAAABsAAAAAAAAAAEAAABuAAAAbAAAAAAAAAABAAAAbwAAAGwAAAAAAAAAAQAAAHAAAABhIG1hcGNhbm5vdCBhY2Nlc3MgYSBUaHJlYWQgTG9jYWwgU3RvcmFnZSB2YWx1ZSBkdXJpbmcgb3IgYWZ0ZXIgZGVzdHJ1Y3Rpb24AbAAAAAAAAAABAAAAcQAAAC9ydXN0Yy9mYzU5NGYxNTY2OTY4MGZhNzBkMjU1ZmFlYzNjYTNmYjUwN2MzNDA1L2xpYnJhcnkvc3RkL3NyYy90aHJlYWQvbG9jYWwucnMAWCQQAE8AAACmAQAACQAAAGFscmVhZHkgYm9ycm93ZWRsAAAAAAAAAAEAAAAZAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2hleC0wLjQuMy9zcmMvbGliLnJzAAAA2CQQAFEAAADHAAAAJQAAANgkEABRAAAAxwAAAEEAAABsAAAAAAAAAAEAAAByAAAAbAAAAAAAAAABAAAAcwAAAGwAAAAAAAAAAQAAAHQAAABsAAAAAAAAAAEAAAB1AAAARXJyAGwAAAAEAAAABAAAAHYAAABPawAAbAAAAAQAAAAEAAAAdwAAAHNldGluY2RlbG1ha2VUZXh0bWFrZUxpc3RtYWtlVGFibGVtYWtlTWFwbWFya3VubWFyawDWJRAABwAAAM0lEAAJAAAAxSUQAAgAAAC9JRAACAAAALolEAADAAAAtyUQAAMAAAC0JRAAAwAAAN0lEAAEAAAA4SUQAAYAAAA3IhAATAAAAE8BAAAdAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2l0ZXJ0b29scy0wLjEwLjUvc3JjL2dyb3VwYnlsYXp5LnJzQCYQAGAAAABNAQAAFAAAAEAmEABgAAAASAEAABQAAABAJhAAYAAAAPoAAAAXAAAAY291bGQgbm90IHBhcnNlIEFjdG9yIElEIGFzIGEgaGV4IHN0cmluZzogAADQJhAAKgAAAGVycm9yIGFwcGx5aW5nIGNoYW5nZXM6IAQnEAAYAAAAYmFkIGhlYWRzOiAAJCcQAAsAAABpbnZhbGlkIG9iamVjdCBJRDogADgnEAATAAAAdmFsdWUgYXQgIGluIHZhbHVlcyB0byBpbnNlcnQgd2FzIG5vdCBhIHByaW1pdGl2ZQAAAFQnEAAJAAAAXScQACgAAAB0aGUgdmFsdWUgdG8gaW5zZXJ0IHdhcyBub3QgYSBwcmltaXRpdmUAmCcQACcAAABpbnZhbGlkIG9iamVjdCBpZDogAMgnEAATAAAAdGhlIHZhbHVlIHRvIGluc2VydCBtdXN0IGJlIGFuIG9iamVjdAAAAOQnEAAlAAAAdmFsdWUgd2FzIG5vdCBudW1lcmljAAAAFCgQABUAAABjb3VsZCBub3QgZGVjb2RlIHN5bmMgbWVzc2FnZTogADQoEAAfAAAAZXJyb3IgY2FsbGluZyBwYXRjaCBjYWxsYmFjazogAABcKBAAHgAAAHBhdGNoIHdhcyBub3QgYW4gb2JqZWN0AIQoEAAXAAAAdW5hYmxlIHRvIGJ1aWxkIHBhdGNoZXM6IAAAAKQoEAAZAAAAVW5hYmxlIHRvIHJlYWQgSlMgY2hhbmdlOiAAAMgoEAAaAAAAb3BzYWN0b3JoYXNoc2Vxc3RhcnRPcHRpbWVtZXNzYWdlZGVwc2V4dHJhX2J5dGVzMDEyMzQ1Njc4OWFiY2RlZnsAAAAMAAAABAAAAHwAAAB9AAAADAAAAGEgRGlzcGxheSBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB1bmV4cGVjdGVkbHkAfgAAAAAAAAABAAAADQAAAC9ydXN0Yy9mYzU5NGYxNTY2OTY4MGZhNzBkMjU1ZmFlYzNjYTNmYjUwN2MzNDA1L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwCMKRAASwAAAOgJAAAJAAAAfgAAAAQAAAAEAAAAfwAAAIAAAACBAAAAZGVzY3JpcHRpb24oKSBpcyBkZXByZWNhdGVkOyB1c2UgRGlzcGxheS9ydXN0Yy9mYzU5NGYxNTY2OTY4MGZhNzBkMjU1ZmFlYzNjYTNmYjUwN2MzNDA1L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzAAAoKhAASgAAAI0AAAARAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZS9ydXN0Yy9mYzU5NGYxNTY2OTY4MGZhNzBkMjU1ZmFlYzNjYTNmYjUwN2MzNDA1L2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL2J0cmVlL21hcC9lbnRyeS5ycwCvKhAAYAAAAHUBAAAgAAAAY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZQB+AAAAAAAAAAEAAACCAAAAL3J1c3RjL2ZjNTk0ZjE1NjY5NjgwZmE3MGQyNTVmYWVjM2NhM2ZiNTA3YzM0MDUvbGlicmFyeS9hbGxvYy9zcmMvc3luYy5ycwAAAFwrEABJAAAA2wQAABEAAABpbnZhbGlkIHZhbHVlOiAsIGV4cGVjdGVkIAAAuCsQAA8AAADHKxAACwAAAGludmFsaWQgZWxlbWVudCBxdWVyeQAAAOQrEAAVAAAAL2hvbWUvcnVubmVyL3dvcmsvYXV0b21lcmdlLXJzL2F1dG9tZXJnZS1ycy9ydXN0L2F1dG9tZXJnZS9zcmMvcXVlcnkucnMABCwQAEcAAABhAAAACQAAAF9oZWFkaW52YWxpZCBlbGVtZW50IElET3BlcmF0aW9uYWN0aW9ub2Jqa2V5ZWxlbUlkaW5zZXJ0ZGF0YXR5cGV2YWx1ZXByZWRBIHZhbGlkIE9wSUQAAAClLBAADAAAAH4AAAAIAAAABAAAAD4AAABfcm9vdEEgdmFsaWQgT2JqZWN0SUQAAADRLBAAEAAAAENoYW5nZUZpZWxkU2V0IGNvcnJ1cHRlZCAodGhpcyBpcyBhIGJ1Zyl+AAAABAAAAAQAAABMAAAAL2hvbWUvcnVubmVyL3dvcmsvYXV0b21lcmdlLXJzL2F1dG9tZXJnZS1ycy9ydXN0L2F1dG9tZXJnZS9zcmMvc3RvcmFnZS9sb2FkL3JlY29uc3RydWN0X2RvY3VtZW50LnJzACQtEABjAAAAXAAAAAEAAABsb2FkaW5nIGRvY3VtZW50IG9wAJgtEAATAAAAfgAAABgAAAAEAAAAMgAAAH4AAAAEAAAABAAAAIMAAAB+AAAABAAAAAQAAAAzAAAAJC0QAGMAAACUAAAACQAAAG9wZXJhdGlvbiByZWZlcmVuY2VkIGFuIG9iamVjdCB3aGljaCB3ZSBoYXZlbid0IHNlZW4gYSBjcmVhdGUgb3AgZm9yIHlldPQtEABIAAAAJC0QAGMAAAClAAAAFQAAAG9wIHJlZmVyZW5jZWQgYW4gb2JqZWN0IElEIHdoaWNoIHdhcyBzbWFsbGVyIHRoYW4gdGhlIHByZXZpb3VzIG9iamVjdCBJRFQuEABIAAAAJC0QAGMAAACtAAAAEQAAAG1pc21hdGNoaW5nIGhlYWRzAAAAtC4QABEAAAB+AAAABAAAAAQAAACEAAAAJC0QAGMAAADWAAAADQAAAIUAAAAYAAAABAAAAIYAAACFAAAAGAAAAAQAAACHAAAAhgAAAPAuEACIAAAAiQAAAFsAAACKAAAAXQAAAAAqEAAAAAAAdW5rbm93bgA0LxAABwAAAGJvb2xlYW50aW1lc3RhbXBjb3VudGVy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AAwAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5AKUAAAAAAAAAAQAAAA0AAAAvcnVzdGMvZmM1OTRmMTU2Njk2ODBmYTcwZDI1NWZhZWMzY2EzZmI1MDdjMzQwNS9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMANDoQAEsAAADoCQAACQAAAGRlc2NyaXB0aW9uKCkgaXMgZGVwcmVjYXRlZDsgdXNlIERpc3BsYXlpbnZhbGlkIHZhbHVlOiAsIGV4cGVjdGVkIAAAuDoQAA8AAADHOhAACwAAAG1pc3NpbmcgZmllbGQgYGDkOhAADwAAAPM6EAABAAAAdW5rbm93biBmaWVsZCBgYCwgZXhwZWN0ZWQgAAQ7EAAPAAAAEzsQAAwAAABgLCB0aGVyZSBhcmUgbm8gZmllbGRzAAAEOxAADwAAADA7EAAWAAAAaW52YWxpZCBsZW5ndGggAFg7EAAPAAAAxzoQAAsAAABkdXBsaWNhdGUgZmllbGQgYAAAAHg7EAARAAAA8zoQAAEAAAB1bmtub3duIHZhcmlhbnQgYAAAAJw7EAARAAAAEzsQAAwAAABgLCB0aGVyZSBhcmUgbm8gdmFyaWFudHOcOxAAEQAAAMA7EAAYAAAASW5jb21wbGV0ZQAApQAAAAQAAAAEAAAApgAAAEVycm9yAAAApQAAAAQAAAAEAAAApwAAAG5vdCBlbm91Z2ggZGF0YQAcPBAADwAAAJA6EAAAAAAAL2hvbWUvcnVubmVyL3dvcmsvYXV0b21lcmdlLXJzL2F1dG9tZXJnZS1ycy9ydXN0L2F1dG9tZXJnZS9zcmMvb3BfdHJlZS9ub2RlLnJzAAA8PBAATgAAACkAAAAzAAAAPDwQAE4AAAA8AAAANwAAAGhhZCBza2lwIGZyb20gbm9uLXJvb3Qgbm9kZQCsPBAAGwAAADw8EABOAAAAYAAAADUAAABhY3Rpb25kZWxwYXRobGVuZ3RoaW5jdmFsdWVzcGxpY2VpbnNlcnR2YWx1ZXNwdXSoAAAABAAAAAQAAACpAAAAqgAAAKsAAACsAAAADAAAAAQAAACtAAAArgAAAK8AAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5ALAAAAAAAAAAAQAAAA0AAAAvcnVzdGMvZmM1OTRmMTU2Njk2ODBmYTcwZDI1NWZhZWMzY2EzZmI1MDdjMzQwNS9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMAiD0QAEsAAADoCQAACQAAAAoKU3RhY2s6CgpjYW5ub3QgYWNjZXNzIGEgVGhyZWFkIExvY2FsIFN0b3JhZ2UgdmFsdWUgZHVyaW5nIG9yIGFmdGVyIGRlc3RydWN0aW9usQAAAAAAAAABAAAAcQAAAC9ydXN0Yy9mYzU5NGYxNTY2OTY4MGZhNzBkMjU1ZmFlYzNjYTNmYjUwN2MzNDA1L2xpYnJhcnkvc3RkL3NyYy90aHJlYWQvbG9jYWwucnMARD4QAE8AAACmAQAACQAAAGFscmVhZHkgYm9ycm93ZWSxAAAAAAAAAAEAAAAZAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3NlcmRlLXdhc20tYmluZGdlbi0wLjQuNS9zcmMvbGliLnJzxD4QAGAAAAA1AAAADgAAACBjYW4ndCBiZSByZXByZXNlbnRlZCBhcyBhIEphdmFTY3JpcHQgbnVtYmVyND8QAAAAAAA0PxAALAAAAHA/EAAAAAAAtAAAAAQAAAAEAAAAtQAAALYAAAC3AAAAuQAAAAwAAAAEAAAAugAAALsAAAC8AAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQC9AAAAAAAAAAEAAAANAAAAL3J1c3RjL2ZjNTk0ZjE1NjY5NjgwZmE3MGQyNTVmYWVjM2NhM2ZiNTA3YzM0MDUvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAPA/EABLAAAA6AkAAAkAAABpbnZhbGlkIHR5cGU6ICwgZXhwZWN0ZWQgAAAATEAQAA4AAABaQBAACwAAAL4AAAAAAAAA//////////8vaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvdGlueXZlYy0xLjYuMC9zcmMvdGlueXZlYy5ycwAAAIhAEABZAAAAnwUAAAUAAACIQBAAWQAAAJ8FAAAYAAAAAAAAAP//////////YXNzZXJ0aW9uIGZhaWxlZDogaWR4IDwgQ0FQQUNJVFkvcnVzdGMvZmM1OTRmMTU2Njk2ODBmYTcwZDI1NWZhZWMzY2EzZmI1MDdjMzQwNS9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9ub2RlLnJzADBBEABbAAAAegIAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBlZGdlLmhlaWdodCA9PSBzZWxmLmhlaWdodCAtIDEwQRAAWwAAAIcCAAAJAAAAMEEQAFsAAACLAgAACQAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGU6IAAA7EEQACoAAABlbXB0eSBpbnRlcm5hbCBub2RlACBCEAATAAAAMEEQAFsAAADSBAAAHwAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaGVpZ2h0ID4gMAAAADBBEABbAAAATQIAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBzcmMubGVuKCkgPT0gZHN0LmxlbigpMEEQAFsAAADUBgAABQAAADBBEABbAAAAVgQAABYAAAAwQRAAWwAAAJYEAAAWAAAAYXNzZXJ0aW9uIGZhaWxlZDogZWRnZS5oZWlnaHQgPT0gc2VsZi5ub2RlLmhlaWdodCAtIDEAAAAwQRAAWwAAAKwDAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogb2xkX3JpZ2h0X2xlbiArIGNvdW50IDw9IENBUEFDSVRZADBBEABbAAAAgwUAAA0AAABhc3NlcnRpb24gZmFpbGVkOiBvbGRfbGVmdF9sZW4gPj0gY291bnQAMEEQAFsAAACEBQAADQAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGUwQRAAWwAAALMFAAAWAAAAYXNzZXJ0aW9uIGZhaWxlZDogb2xkX2xlZnRfbGVuICsgY291bnQgPD0gQ0FQQUNJVFkAADBBEABbAAAAwgUAAA0AAABhc3NlcnRpb24gZmFpbGVkOiBvbGRfcmlnaHRfbGVuID49IGNvdW50MEEQAFsAAADDBQAADQAAADBBEABbAAAA8wUAABYAAABhc3NlcnRpb24gZmFpbGVkOiBtYXRjaCB0cmFja19lZGdlX2lkeCB7XG4gICAgTGVmdE9yUmlnaHQ6OkxlZnQoaWR4KSA9PiBpZHggPD0gb2xkX2xlZnRfbGVuLFxuICAgIExlZnRPclJpZ2h0OjpSaWdodChpZHgpID0+IGlkeCA8PSByaWdodF9sZW4sXG59AAAAMEEQAFsAAABVBQAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IG5ld19sZWZ0X2xlbiA8PSBDQVBBQ0lUWQAAMEEQAFsAAAAIBQAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IGxlbiA+IDAAAAAwQRAAWwAAAGIBAAAJAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZS9ydXN0Yy9mYzU5NGYxNTY2OTY4MGZhNzBkMjU1ZmFlYzNjYTNmYjUwN2MzNDA1L2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL2J0cmVlL25hdmlnYXRlLnJzAACXRRAAXwAAAEwCAAANAAAAl0UQAF8AAAAKAgAAFgAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy90aW55dmVjLTEuNi4wL3NyYy90aW55dmVjLnJzAAAAGEYQAFkAAAC1BQAABQAAABhGEABZAAAAtQUAABkAAAAvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvdGlueXZlYy0xLjYuMC9zcmMvdGlueXZlYy5ycwAAAJRGEABZAAAA0AQAAAUAAADAAAAADAAAAAQAAADBAAAAwAAAAAwAAAAEAAAAwgAAAMEAAAAARxAAwwAAAMQAAADFAAAAxgAAAMcAAAAwMTIzNDU2Nzg5YWJjZGVmL3J1c3RjL2ZjNTk0ZjE1NjY5NjgwZmE3MGQyNTVmYWVjM2NhM2ZiNTA3YzM0MDUvbGlicmFyeS9zdGQvc3JjL2lvL21vZC5ycwAAAExHEABJAAAAlgEAADAAAAAvcnVzdGMvZmM1OTRmMTU2Njk2ODBmYTcwZDI1NWZhZWMzY2EzZmI1MDdjMzQwNS9saWJyYXJ5L3N0ZC9zcmMvaW8vcmVhZGJ1Zi5ycwAAAKhHEABNAAAA/QAAABYAAACoRxAATQAAAMsAAAA2AAAAdTY0YXV0b21lcmdlOjpzdG9yYWdlOjpjaGFuZ2U6OlZlcmlmaWVkc21vbF9zdHI6OlNtb2xTdHLIAAAABAAAAAQAAADJAAAAlEYQAFkAAACfBQAABQAAAJRGEABZAAAAnwUAABgAAABhdXRvbWVyZ2Uvc3JjL2NvbHVtbmFyL2NvbHVtbl9yYW5nZS9kZWx0YS5yc4BIEAAsAAAADQAAACsAAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlAMoAAAAMAAAABAAAAMsAAACASBAALAAAABoAAAAJAAAAb3V0IG9mIGJvdW5kcwAAAAhJEAANAAAAgEgQACwAAAAxAAAAGQAAAGFjdG9yY3RyY291bnRlcm5lZ2F0aXZlIHZhbHVlIGVuY291bnRlcmVkYXV0b21lcmdlL3NyYy9xdWVyeS9pbnNlcnQucnMAAFlJEAAdAAAAYQAAAB8AAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwX2VycigpYCBvbiBhbiBgT2tgIHZhbHVlAADIAAAABAAAAAQAAADMAAAAYXV0b21lcmdlL3NyYy9xdWVyeS9saXN0X3ZhbHNfYXQucnMAyEkQACMAAAAkAAAAHwAAAGF1dG9tZXJnZS9zcmMvcXVlcnkvbnRoLnJzAAD8SRAAGgAAAGEAAAAfAAAAYXV0b21lcmdlL3NyYy9zdG9yYWdlL2NvbnZlcnQvb3BfYXNfZG9jb3AucnMoShAALAAAAIwAAAARAAAARGVsdGFSYW5nZQAAyAAAAAQAAAAEAAAAzQAAAGxlYjEyOCB3YXMgemVybyB3aGVuIGl0IHdhcyBleHBlY3RlZCB0byBiZSBub256ZXJvAACAShAAMgAAAGxlYjEyOCB3YXMgaW1wcm9wZXJseSBlbmNvZGVkAAAAvEoQAB0AAABsZWIxMjggd2FzIHRvbyBsYXJnZSBmb3IgdGhlIGRlc3RpbmF0aW9uIHR5cGUAAADkShAALQAAAFVuZXhwZWN0ZWRaZXJvTGViMTI4T3ZlcmxvbmdMZWIxMjhUb29MYXJnZQAAOEsQACpLEAAcSxAAZGVzY3JpcHRpb24oKSBpcyBkZXByZWNhdGVkOyB1c2UgRGlzcGxheS9ydXN0Yy9mYzU5NGYxNTY2OTY4MGZhNzBkMjU1ZmFlYzNjYTNmYjUwN2MzNDA1L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzAAB8SxAASgAAAI0AAAARAAAAYXV0b21lcmdlL3NyYy9xdWVyeS9zZWVrX29wLnJzAADYSxAAHgAAADcAAAAfAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQDYSxAAHgAAADcAAAAjAAAAYXV0b21lcmdlL3NyYy9xdWVyeS9zZWVrX29wX3dpdGhfcGF0Y2gucnMAAABETBAAKQAAAFMAAAAfAAAAREwQACkAAABTAAAAIwAAAERMEAApAAAAfAAAAC8AAABpZGFjdGlvbm9iamtleXZhbHVlc3VjY2luc2VydEZpZWxkU2V0IGNvcnJ1cHRlZCAodGhpcyBpcyBhIGJ1ZylleHBlY3RlZCBhIHR3byBjb2x1bW4gZ3JvdXAgb2YgKGFjdG9yLCBybGUgaW50KSBmb3IgaW5kZXggMTAA30wQADwAAADYAAAAGAAAAAQAAAAyAAAAYXV0b21lcmdlL3NyYy9zdG9yYWdlL2RvY3VtZW50L2RvY19vcF9jb2x1bW5zLnJzNE0QADAAAACXAQAAIQAAAGNvbCA5IHNob3VsZCBiZSBhIHZhbHVlIGNvbHVtbgAAdE0QAB4AAAA0TRAAMAAAAH4BAAAZAAAAdW5rbm93biBjb2x1bW4gdHlwZQCsTRAAEwAAANgAAAAEAAAABAAAANkAAADYAAAABAAAAAQAAADaAAAANE0QADAAAACkAQAAFQAAAE1pc21hdGNoZWRIZWFkc2NoYW5nZXMAANgAAAAEAAAABAAAANsAAABleHBlY3RlZF9oZWFkcwAA3AAAAAwAAAAEAAAA3QAAAGRlcml2ZWRfaGVhZHNhdXRvbWVyZ2Uvc3JjL3N0b3JhZ2UvbG9hZC9yZWNvbnN0cnVjdF9kb2N1bWVudC5ycwBNThAAMgAAADgBAAApAAAAbm8gZGVsZXRlIG9wZXJhdGlvbiBmb3VuZAAAAJBOEAAZAAAA2AAAAAQAAAAEAAAA3gAAANgAAAAEAAAABAAAAN8AAABNThAAMgAAADkBAAARAAAAbWlzc2luZyBhY3RvcgAAAOROEAANAAAA2AAAAAQAAAAEAAAA4AAAAE1OEAAyAAAAWAEAAA0AAABNThAAMgAAAG0BAAANAAAAdW5rbm93biBhY3Rpb24gdHlwZQAsTxAAEwAAANgAAAAEAAAABAAAAEAAAABNThAAMgAAAIMBAAANAAAAaW52YWxpZCB2YWx1ZSBmb3IgY291bnRlciBvcGhPEAAcAAAA2AAAAAQAAAAEAAAA4QAAAE1OEAAyAAAAfQEAABEAAABpZCB3YXMgbm90IGFuIG9iamVjdCBpZACsTxAAFwAAAGNvbXByZXNzZWQgY2h1bmsgd2FzIG5vdCBhIGNoYW5nZQAAAMxPEAAhAAAAaGFzaCAgZG9lcyBub3QgY29ycmVzcG9uZCB0byBhIGNoYW5nZSBpbiB0aGlzIGRvY3VtZW50AAD4TxAABQAAAP1PEAAxAAAAaW5jcmVtZW50IG9wZXJhdGlvbnMgbXVzdCBiZSBhZ2FpbnN0IGEgY291bnRlciB2YWx1ZUBQEAA0AAAAaW52YWxpZCB0eXBlIG9mIHZhbHVlLCBleHBlY3RlZCBgYCBidXQgcmVjZWl2ZWQgYGAAAHxQEAAhAAAAnVAQABAAAACtUBAAAQAAAHNlcSAgaXMgb3V0IG9mIGJvdW5kcwAAAMhQEAAEAAAAzFAQABEAAABpbnZhbGlkIG9wIGZvciBvYmplY3Qgb2YgdHlwZSBgAPBQEAAfAAAArVAQAAEAAABpbnZhbGlkIG9iaiBpZCBmb3JtYXQgYAAgURAAFwAAAK1QEAABAAAAaW52YWxpZCBvYmogaWQgYEhREAAQAAAArVAQAAEAAABpbmRleCAAAGhREAAGAAAAzFAQABEAAABpbnZhbGlkIGhhc2ggAAAAgFEQAA0AAABpbnZhbGlkIFVURi04IGNoYXJhY3RlciBhdCAAmFEQABsAAABpbnZhbGlkIGFjdG9yIElEIGAAALxREAASAAAArVAQAAEAAABnZW5lcmFsIGZhaWx1cmUA4FEQAA8AAABrZXkgbXVzdCBub3QgYmUgYW4gZW1wdHkgc3RyaW5nAPhREAAfAAAAZHVwbGljYXRlIHNlcSAgZm91bmQgZm9yIGFjdG9yIAAgUhAADgAAAC5SEAARAAAAZmFpbGVkIHRvIGxvYWQgY29tcHJlc3NlZCBkYXRhOiBQUhAAIAAAAE5vdEFuT2JqZWN0Tm9uQ2hhbmdlQ29tcHJlc3NlZE1pc3NpbmdIYXNoAAAA2AAAAAQAAAAEAAAA4gAAAE1pc3NpbmdDb3VudGVyTG9hZAAA2AAAAAQAAAAEAAAA4wAAAEludmFsaWRWYWx1ZVR5cGVleHBlY3RlZNgAAAAEAAAABAAAAOQAAAB1bmV4cGVjdGVkSW52YWxpZFNlcdgAAAAEAAAABAAAAOUAAABJbnZhbGlkT3AAAADYAAAABAAAAAQAAADmAAAASW52YWxpZE9iaklkRm9ybWF0SW52YWxpZE9iaklkSW52YWxpZEluZGV4AADYAAAABAAAAAQAAADJAAAASW52YWxpZEhhc2hJbnZhbGlkQ2hhcmFjdGVySW52YWxpZEFjdG9ySWRGYWlsRW1wdHlTdHJpbmdLZXlEdXBsaWNhdGVTZXFOdW1iZXIAAADYAAAABAAAAAQAAADnAAAARGVmbGF0ZQDYAAAABAAAAAQAAADoAAAAQ2hhbmdlR3JhcGgA2AAAAAQAAAAEAAAA6QAAAE5vbk51bWVyaWNJbmNVbmtub3duQWN0aW9ub3BSZWFkRG9jT3BFcnJvcgAA2AAAAAQAAAAEAAAA6gAAAE1pc21hdGNoaW5nQ29sdW1uaW5kZXhtaXNtYXRjaGluZyBjb2x1bW4gYXQgLgAAAGJUEAAWAAAAeFQQAAEAAABtZXNzYWdlAIxUEAAHAAAA2AAAAAwAAAAEAAAA6wAAAOwAAADtAAAAYXV0b21lcmdlOjpzdG9yYWdlOjpkb2N1bWVudDo6ZG9jX29wX2NvbHVtbnNldmVudCBhdXRvbWVyZ2Uvc3JjL3N0b3JhZ2UvZG9jdW1lbnQvZG9jX29wX2NvbHVtbnMucnM6MzgyAACUVBAAAQAAACA3EQCcVBAAtFQQACwAAAA0TRAAMAAAAOBUEAA6AAAAtFQQACwAAAABAAAAfgEAAAQAAAABAAAAZXZlbnQgYXV0b21lcmdlL3NyYy9zdG9yYWdlL2RvY3VtZW50L2RvY19vcF9jb2x1bW5zLnJzOjQwNwAAlFQQAAEAAAAsNxEAnFQQALRUEAAsAAAANE0QADAAAABcVRAAOgAAALRUEAAsAAAAAQAAAJcBAAAEAAAAAQAAAHR5cACMVBAABwAAAKBMEAACAAAA2FUQAAMAAABldmVudCBhdXRvbWVyZ2Uvc3Jj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AAAAJAAAAOBfEABOAAAA8gEAAAsAAADgXxAATgAAABICAAAnAAAA4F8QAE4AAAAaAgAABwAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy90aW55dmVjLTEuNi4wL3NyYy90aW55dmVjLnJzAAAA0GAQAFkAAACrBQAABQAAANBgEABZAAAAqwUAACEAAABmYWlsZWQgdG8gZmlsbCB3aG9sZSBidWZmZXIATGEQABsAAAAlAAAAAwEAAAwAAAAEAAAABAEAAAUBAAAGAQAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQAHAQAAAAAAAAEAAAANAAAAL3J1c3RjL2ZjNTk0ZjE1NjY5NjgwZmE3MGQyNTVmYWVjM2NhM2ZiNTA3YzM0MDUvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzANRhEABLAAAA6AkAAAkAAABkZXNjcmlwdGlvbigpIGlzIGRlcHJlY2F0ZWQ7IHVzZSBEaXNwbGF5L2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3Rpbnl2ZWMtMS42LjAvc3JjL3Rpbnl2ZWMucnMAAABYYhAAWQAAAKsFAAAFAAAAWGIQAFkAAACrBQAAIQAAAGFzc2VydGlvbiBmYWlsZWQ6IG5ld2xpbmVzIDw9IE5fTkVXTElORVMgJiYgc3BhY2VzIDw9IE5fU1BBQ0VTL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3Ntb2xfc3RyLTAuMS4yNC9zcmMvbGliLnJzAAAAEmMQAFcAAAC/AQAAEQAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAS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axAAKgAAAAEAAADXAAAAAAAAAAEAAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlL3J1c3RjL2ZjNTk0ZjE1NjY5NjgwZmE3MGQyNTVmYWVjM2NhM2ZiNTA3YzM0MDUvbGlicmFyeS9zdGQvc3JjL2lvL2ltcGxzLnJzAABvchAASwAAAEEBAAASAAAAY2Fubm90IGFjY2VzcyBhIFRocmVhZCBMb2NhbCBTdG9yYWdlIHZhbHVlIGR1cmluZyBvciBhZnRlciBkZXN0cnVjdGlvbgAAHAEAAAAAAAABAAAAcQAAAC9ydXN0Yy9mYzU5NGYxNTY2OTY4MGZhNzBkMjU1ZmFlYzNjYTNmYjUwN2MzNDA1L2xpYnJhcnkvc3RkL3NyYy90aHJlYWQvbG9jYWwucnMAJHMQAE8AAACmAQAACQAAAFNvbWUcAQAABAAAAAQAAAAdAQAATm9uZRwBAAAEAAAABAAAAB4BAAAcAQAABAAAAAQAAADkAAAAHAEAAAQAAAAEAAAAHwEAABwBAAAEAAAABAAAACABAAAcAQAABAAAAAQAAADJAAAAHAEAAAQAAAAEAAAA4gAAABwBAAAEAAAABAAAACEBAABjb3JydXB0IGRlZmxhdGUgc3RyZWFtAAAAAAAAZ+YJaoWuZ7ty8248OvVPpX9SDlGMaAWbq9mDHxnN4FsvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvc21vbF9zdHItMC4xLjI0L3NyYy9saWIucnMASHQQAFcAAACVAQAAOAAAAGRlcHNGaWVsZFNldCBjb3JydXB0ZWQgKHRoaXMgaXMgYSBidWcpZXJyb3IgY29udmVydGluZyBkZXAgaW5kZXggdG8gdTY0ANZ0EAAhAAAAHAEAABgAAAAEAAAAMgAAABwBAAAEAAAABAAAACIBAAAcAQAACAAAAAgAAAAjAQAAYXV0b21lcmdlL3NyYy9jb2x1bW5hci9jb2x1bW5fcmFuZ2UvZGVwcy5ycwAwdRAAKwAAAFEAAAAdAAAAZ3JvdXBudW0kAQAADAAAAAQAAADLAAAAYXV0b21lcmdlL3NyYy9jb2x1bW5hci9jb2x1bW5fcmFuZ2Uvb2JqX2lkLnJz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OBEAmKUQALClEAAtAAAALKMQADEAAACsphAAOwAAALClEAAtAAAAAQAAAKMBAAADAAAAAQAAAHVuYWJsZSB0byBkZWNvbXByZXNzZSBjb21wcmVzc2VkIGNodW5rAAAopxAAJgAAAGJhZCBkb2N1bWVudCBjaHVuazogWKcQABQAAABiYWQgY2hhbmdlIGNodW5rOiAAAHSnEAASAAAAZmFpbGVkIHRvIHBhcnNlIGhlYWRlcjogkKcQABgAAAB0aGVyZSB3YXMgZGF0YSBpbiBhIGNodW5rIGxlZnRvdmVyIGFmdGVyIHBhcnNpbmewpxAAMAAAAERlZmxhdGVEb2N1bWVudACFAQAABAAAAAQAAACmAQAAQ2hhbmdlAACFAQAABAAAAAQAAACnAQAASGVhZGVyAACFAQAABAAAAAQAAACoAQAATGViMTI4AACFAQAABAAAAAQAAAArAQAATGVmdG92ZXJEYXRhSW52YWxpZCBtYWdpYyBieXRlcwBcqBAAEwAAAHVua25vd24gY2h1bmsgdHlwZTogeKgQABQAAABJbnZhbGlkTWFnaWNCeXRlc1Vua25vd25DaHVua1R5cGUAAACFAQAABAAAAAQAAABPAQBB0NHCAAv5DAYAAAAAAAAAAgAAAAAAAAAEAAAAAAAAAGRlc2NyaXB0aW9uKCkgaXMgZGVwcmVjYXRlZDsgdXNlIERpc3BsYXljYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlL3J1c3RjL2ZjNTk0ZjE1NjY5NjgwZmE3MGQyNTVmYWVjM2NhM2ZiNTA3YzM0MDUvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvYnRyZWUvbWFwL2VudHJ5LnJzADupEABgAAAAdQEAACAAAAA7qRAAYAAAADACAAAYAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3Rpbnl2ZWMtMS42LjAvc3JjL3Rpbnl2ZWMucnMAAAC8qRAAWQAAALUFAAAFAAAAvKkQAFkAAAC1BQAAGQAAALypEABZAAAAnwUAAAUAAAC8qRAAWQAAAJ8FAAAYAAAAL3J1c3RjL2ZjNTk0ZjE1NjY5NjgwZmE3MGQyNTVm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NTA3YzM0MDUvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAPS7EABLAAAA6AkAAAkAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlL3J1c3RjL2ZjNTk0ZjE1NjY5NjgwZmE3MGQyNTVmYWVjM2NhM2ZiNTA3YzM0MDUvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvYnRyZWUvbmF2aWdhdGUucnMAAHu8EABfAAAAugAAABUAAAB7vBAAXwAAAJUAAAASAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3Rpbnl2ZWMtMS42LjAvc3JjL3Rpbnl2ZWMucnMAAAD8vBAAWQAAALUFAAAFAAAA/LwQAFkAAAC1BQAAGQAAAC9ydXN0Yy9mYzU5NGYxNTY2OTY4MGZhNzBkMjU1ZmFlYzNjYTNmYjUwN2MzNDA1L2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL2J0cmVlL21hcC5ycwAAeL0QAFoAAAD5AAAAKAAAAHi9EABaAAAAHgEAABsAAABhIG51bWJlciwgc3RyaW5nLCBib29sLCBvciBudWxsYXV0b21lcmdlL3NyYy9vcF9zZXQucnMAABO+EAAXAAAANgAAABEAAAATvhAAFwAAAFgAAAATAAAAE74QABcAAADZAAAAFAAAAGNhbiBvbmx5IGNvbXBhcmUgbWFwIGtleXMAAABcvhAAGQAAABO+EAAXAAAAegEAABIAAAATvhAAFwAAAHkBAAArAAAAE74QABcAAAB5AQAAPwAAAGF1dG9tZXJnZS9zcmMvcGFyZW50cy5yc7C+EAAYAAAAOQAAABcAAADJAQAACAAAAAQAAADKAQAAyQEAAAgAAAAEAAAAywEAAMoBAADYvhAA8wAAAMwBAADNAQAAzgEAAM8BAADJAQAABAAAAAQAAADQAQAAyQEAAAQAAAAEAAAA0QEAANABAAAUvxAA0gEAANMBAADUAQAA1QEAANYBAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlANcBAAAYAAAABAAAAFgAAABhdXRvbWVyZ2Uvc3JjL3N0b3Jh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LjMuMC9zcmMvcm5nLnJzAABszRAAUgAAAAkAAAANAAAAVW5rbm93biBFcnJvcjogANDNEAAPAAAAT1MgRXJyb3I6IAAA6M0QAAoAAABOb2RlLmpzIEVTIG1vZHVsZXMgYXJlIG5vdCBkaXJlY3RseSBzdXBwb3J0ZWQsIHNlZSBodHRwczovL2RvY3MucnMvZ2V0cmFuZG9tI25vZGVqcy1lcy1tb2R1bGUtc3VwcG9ydENhbGxpbmcgTm9kZS5qcyBBUEkgY3J5cHRvLnJhbmRvbUZpbGxTeW5jIGZhaWxlZE5vZGUuanMgY3J5cHRvIENvbW1vbkpTIG1vZHVsZSBpcyB1bmF2YWlsYWJsZXJhbmRTZWN1cmU6IFZ4V29ya3MgUk5HIG1vZHVsZSBpcyBub3QgaW5pdGlhbGl6ZWRDYWxsaW5nIFdlYiBBUEkgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBmYWlsZWRXZWIgQ3J5cHRvIEFQSSBpcyB1bmF2YWlsYWJsZVJEUkFORDogaW5zdHJ1Y3Rpb24gbm90IHN1cHBvcnRlZFJEUkFORDogZmFpbGVkIG11bHRpcGxlIHRpbWVzOiBDUFUgaXNzdWUgbGlrZWx5UnRsR2VuUmFuZG9tOiBXaW5kb3dzIHN5c3RlbSBmdW5jdGlvbiBmYWlsdXJlU2VjUmFuZG9tQ29weUJ5dGVzOiBpT1MgU2VjdXJpdHkgZnJhbWV3b3JrIGZhaWx1cmVlcnJubzogZGlkIG5vdCByZXR1cm4gYSBwb3NpdGl2ZSB2YWx1ZWdldHJhbmRvbTogdGhpcyB0YXJnZXQgaXMgbm90IHN1cHBvcnRlZAAAACcAAAAmAAAAJwAAADIAAAAtAAAALwAAACEAAAAdAAAALQAAACcAAAAnAAAAMQAAAC0AAAAwAAAAZQAAAA7QEADozxAADtAQALbPEACJzxAAWs8QADnPEAAczxAA784QAA7QEAAO0BAAvs4QAJHOEABhzhAA/M0QAGNhbm5vdCBhY2Nlc3MgYSBUaHJlYWQgTG9jYWwgU3RvcmFnZSB2YWx1ZSBkdXJpbmcgb3IgYWZ0ZXIgZGVzdHJ1Y3Rpb24AAOYBAAAAAAAAAQAAAHEAAAAvcnVzdGMvZmM1OTRmMTU2Njk2ODBmYTcwZDI1NWZhZWMzY2EzZmI1MDdj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ARoBGgEaARoBGgEaARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEcARwBHAEcARwBHAEcARwBHAEcARwBHAEcARwBHAEcARwBHAEcARwBHAEcARwBHAEcARwBHAEcARwBHAEcAR0B9NIQAGIAAAANBgAAGwAAAAAAAAABAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wBBpLLDAAvFFgEBAQEBAQEBAgICAgICAgICAgICAgICAgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUA9NIQAGIAAAARBgAALgAAAAABAgMEBAUFBgYGBgcHBwcICAgICAgICAkJCQkJCQkJCgoKCgoKCgoKCgoKCgoKCgsLCwsLCwsLCwsLCwsLCwsMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8QEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERAAAAAAEBAQECAgICAgICAgMDAwMDAwMDAwMDAwMDAwMEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcAABITFBQVFRYWFhYXFxcXGBgYGBgYGBgZGRkZGRkZGRoaGhoaGhoaGhoaGhoaGhobGxsbGxsbGxsbGxsbGxsbHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwdHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHfTSEABiAAAAGQYAABcAAAAAAAgICQkJCQoKCgoKCgoKCwsLCwsLCwsLCwsLCwsLCwwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDfTSEABiAAAA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AAAqAAAACQAAAAEBAQAEABAREgAIBwkGCgULBAwDDQIOAQ8AAAC44RAAYgAAAA8FAAAoAAAAuOEQAGIAAAAhBQAAIQAAALjhEABiAAAAJwUAAC8AAAC44RAAYgAAAEEFAAAjAAAAuOEQAGIAAABDBQAAGQAAALjhEABiAAAASQUAAB4AAAAvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvbWluaXpfb3hpZGUtMC42LjIvc3JjL2luZmxhdGUvc3RyZWFtLnJz1OYQAGQAAAA5AQAAFQAAANTmEABkAAAAaQEAACYAAABQYXJhbVZlcnNpb25CdWZNZW1EYXRhU3RyZWFtRXJyTm8AAAAAAAAAAgAAAAIAAAADAAAABAAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9taW5pel9veGlkZS0wLjYuMi9zcmMvZGVmbGF0ZS9zdHJlYW0ucnOQ5xAAZAAAADwAAAAUAAAAkOcQAGQAAAA9AAAAGQAAAE92ZXJmbG93SW9FcnJvcgDtAQAABAAAAAQAAADuAQAAcmV0dXJuIHRoaXMvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvanMtc3lzLTAuMy42MS9zcmMvbGliLnJzP+gQAFUAAACpFwAAAQAAAPsBAAAEAAAABAAAAPwBAABgdW53cmFwX3Rocm93YCBmYWlsZWRjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZG51bGwgcG9pbnRlciBwYXNzZWQgdG8gcnVzdHJlY3Vyc2l2ZSB1c2Ugb2YgYW4gb2JqZWN0IGRldGVjdGVkIHdoaWNoIHdvdWxkIGxlYWQgdG8gdW5zYWZlIGFsaWFzaW5nIGluIHJ1c3RKc1ZhbHVlKCkAAGXpEAAIAAAAbekQAAEAQYbTwwALkRXwPwAAAAAAACRAAAAAAAAAWUAAAAAAAECPQAAAAAAAiMNAAAAAAABq+EAAAAAAgIQuQQAAAADQEmNBAAAAAITXl0EAAAAAZc3NQQAAACBfoAJCAAAA6HZIN0IAAACilBptQgAAQOWcMKJCAACQHsS81kIAADQm9WsMQwCA4Dd5w0FDAKDYhVc0dkMAyE5nbcGrQwA9kWDkWOFDQIy1eB2vFURQ7+LW5BpLRJLVTQbP8IBE9krhxwIttUS0ndl5Q3jqRJECKCwqiyBFNQMyt/StVEUChP7kcdmJRYESHy/nJ8BFIdfm+uAx9EXqjKA5WT4pRiSwCIjvjV9GF24FtbW4k0acyUYi46bIRgN82Oqb0P5Ggk3HcmFCM0fjIHnP+RJoRxtpV0O4F55HsaEWKtPO0kcdSpz0h4IHSKVcw/EpYz1I5xkaN/pdckhhoODEePWmSHnIGPbWstxITH3PWcbvEUmeXEPwt2tGScYzVOylBnxJXKC0syeEsUlzyKGgMeXlSY86ygh+XhtKmmR+xQ4bUUrA/d120mGFSjB9lRRHurpKPm7dbGy08ErOyRSIh+EkS0H8GWrpGVpLqT1Q4jFQkEsTTeRaPmTES1dgnfFNfflLbbgEbqHcL0xE88Lk5OljTBWw8x1e5JhMG5xwpXUdz0yRYWaHaXIDTfX5P+kDTzhNcviP48Ribk1H+zkOu/2iTRl6yNEpvddNn5g6RnSsDU5kn+SryItCTj3H3da6LndODDmVjGn6rE6nQ933gRziTpGU1HWioxZPtblJE4tMTE8RFA7s1q+BTxaZEafMG7ZPW//V0L+i60+Zv4Xit0UhUH8vJ9sll1VQX/vwUe/8ilAbnTaTFd7AUGJEBPiaFfVQe1UFtgFbKlFtVcMR4XhgUcgqNFYZl5RRejXBq9+8yVFswVjLCxYAUsfxLr6OGzRSOa66bXIiaVLHWSkJD2ufUh3YuWXpotNSJE4ov6OLCFOtYfKujK4+Uwx9V+0XLXNTT1yt6F34p1Njs9hidfbdUx5wx10JuhJUJUw5tYtoR1Qun4eirkJ9VH3DlCWtSbJUXPT5bhjc5lRzcbiKHpMcVehGsxbz21FVohhg3O9ShlXKHnjTq+e7VT8TK2TLcPFVDtg1Pf7MJVYSToPMPUBbVssQ0p8mCJFW/pTGRzBKxVY9OrhZvJz6VmYkE7j1oTBXgO0XJnPKZFfg6J3vD/2ZV4yxwvUpPtBX710zc7RNBFhrNQCQIWE5WMVCAPRpuW9YuymAOOLTo1gqNKDG2sjYWDVBSHgR+w5ZwSgt6+pcQ1nxcvilJTR4Wa2Pdg8vQa5ZzBmqab3o4lk/oBTE7KIXWk/IGfWni01aMh0w+Uh3glp+JHw3GxW3Wp4tWwVi2uxagvxYQ30IIlujOy+UnIpWW4wKO7lDLYxbl+bEU0qcwVs9ILboXAP2W02o4yI0hCtcMEnOlaAyYVx820G7SH+VXFtSEuoa38pceXNL0nDLAF1XUN4GTf40XW3klUjgPWpdxK5dLaxmoF11GrU4V4DUXRJh4gZtoAleq3xNJEQEQF7W22AtVQV0XswSuXiqBqlef1fnFlVI316vllAuNY0TX1u85HmCcEhfcutdGKOMfl8nszrv5RezX/FfCWvf3edf7bfLRVfVHWD0Up+LVqVSYLEnhy6sTodgnfEoOlcivWACl1mEdjXyYMP8byXUwiZh9PvLLolzXGF4fT+9NciRYdZcjyxDOsZhDDSz99PI+2GHANB6hF0xYqkAhJnltGVi1ADl/x4im2KEIO9fU/XQYqXo6jeoMgVjz6LlRVJ/OmPBha9rk49wYzJnm0Z4s6Rj/kBCWFbg2WOfaCn3NSwQZMbC83RDN0RkeLMwUhRFeWRW4LxmWZavZDYMNuD3veNkQ49D2HWtGGUUc1RO09hOZezH9BCER4Nl6PkxFWUZuGVheH5avh/uZT0Lj/jW0yJmDM6ytsyIV2aPgV/k/2qNZvmwu+7fYsJmOJ1q6pf79maGRAXlfbosZ9RKI6+O9GFniR3sWrJxlmfrJKfxHg7MZxN3CFfTiAFo15TKLAjrNWgNOv03ymVraEhE/mKeH6FoWtW9+4Vn1WixSq16Z8EKaa9OrKzguEBpWmLX1xjndGnxOs0N3yCqadZEoGiLVOBpDFbIQq5pFGqPa3rTGYRJanMGWUgg5X9qCKQ3LTTvs2oKjYU4AevoakzwpobBJR9rMFYo9Jh3U2u7azIxf1WIa6oGf/3ear5rKmRvXssC82s1PQs2fsMnbIIMjsNdtF1s0cc4mrqQkmzG+cZA6TTHbDe4+JAjAv1sI3ObOlYhMm3rT0LJq6lmbebjkrsWVJxtcM47NY600W0MworCsSEGbo9yLTMeqjtumWf831JKcW5/gfuX55ylbt9h+n0hBNtuLH287pTiEG92nGsqOhtFb5SDBrUIYnpvPRIkcUV9sG/MFm3Nlpzkb39cyIC8wxlwzzl90FUaUHBDiJxE6yCEcFSqwxUmKblw6ZQ0m29z73AR3QDBJagjcVYUQTEvklhxa1mR/bq2jnHj13reNDLDcdyNGRbC/vdxU/Gfm3L+LXLU9kOhB79icon0lInJbpdyqzH663tKzXILX3xzjU4Cc812W9Aw4jZzgVRyBL2abHPQdMcituChcwRSeavjWNZzhqZXlhzvC3QUyPbdcXVBdBh6dFXO0nV0npjR6oFHq3Rj/8IysQzhdDy/c3/dTxV1C69Q39SjSnVnbZILZaaAdcAId07+z7R18coU4v0D6nXW/kytfkIgdow+oFgeU1R2L07I7uVniXa7YXpq38G/dhV9jKIr2fN2Wpwvi3bPKHdwg/stVANfdyYyvZwUYpN3sH7sw5k6yHdcnuc0QEn+d/nCECHI7TJ4uPNUKTqpZ3ilMKqziJOdeGdeSnA1fNJ4AfZczEIbB3mCM3R/E+I8eTGgqC9MDXJ5PciSO5+QpnlNencKxzTceXCsimb8oBF6jFctgDsJRnpvrThgiot7emVsI3w2N7F6f0csGwSF5XpeWfchReYae9uXOjXrz1B70j2JAuYDhXtGjSuD30S6e0w4+7ELa/B7XwZ6ns6FJHz2hxhGQqdZfPpUz2uJCJB8OCrDxqsKxHzH9HO4Vg35fPjxkGasUC99O5cawGuSY30KPSGwBneYfUyMKVzIlM59sPeZOf0cA36cdQCIPOQ3fgOTAKpL3W1+4ltASk+qon7actAc41TXfpCPBOQbKg1/utmCblE6Qn8pkCPK5ch2fzN0rDwfe6x/oMjrhfPM4X8vaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvc2VyZGVfanNvbi0xLjAuOTMvc3JjL3JlYWQucnMAACjzEABaAAAAoQEAABQAAAAo8xAAWgAAAMYBAAATAAAAKPMQAFoAAADVAQAAMAAAACjzEABaAAAAywEAACkAAAAo8xAAWgAAAM8BAAA0AAAAKPMQAFoAAAAmAgAAEwAAACjzEABaAAAAPgIAACUAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAQBB0OjDAAsBAQBB9OnDAAvWRmNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUAKPMQAFoAAACmAwAAFgAAAP///////////////////////////////////////////////////////////////wABAgMEBQYHCAn/////////CgsMDQ4P//////////////////////////////////8KCwwNDg////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9UcmllZCB0byBzaHJpbmsgdG8gYSBsYXJnZXIgY2FwYWNpdHkw9hAAJAAAAC9ydXN0Yy9mYzU5NGYxNTY2OTY4MGZhNzBkMjU1ZmFlYzNjYTNmYjUwN2MzNDA1L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnNc9hAATAAAAKoBAAAJAAAAAAIAAAwAAAAEAAAAAQIAAAICAAADAgAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQAEAgAAAAAAAAEAAAANAAAAL3J1c3RjL2ZjNTk0ZjE1NjY5NjgwZmE3MGQyNTVmYWVjM2NhM2ZiNTA3YzM0MDUvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzABj3EABLAAAA6AkAAAkAAAAvcnVzdGMvZmM1OTRmMTU2Njk2ODBmYTcwZDI1NWZhZWMzY2EzZmI1MDdjMzQwNS9saWJyYXJ5L2NvcmUvc3JjL3N0ci9wYXR0ZXJuLnJzAHT3EABPAAAA/gUAABQAAAB09xAATwAAAP4FAAAhAAAAdPcQAE8AAAAKBgAAFAAAAHT3EABPAAAACgYAACEAAABhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikY9xAASwAAAP8EAAANAAAAdPcQAE8AAACLBAAAFwAAAHJlY3Vyc2lvbiBsaW1pdCBleGNlZWRlZHVuZXhwZWN0ZWQgZW5kIG9mIGhleCBlc2NhcGV0cmFpbGluZyBjaGFyYWN0ZXJzdHJhaWxpbmcgY29tbWFsb25lIGxlYWRpbmcgc3Vycm9nYXRlIGluIGhleCBlc2NhcGVrZXkgbXVzdCBiZSBhIHN0cmluZ2NvbnRyb2wgY2hhcmFjdGVyIChcdTAwMDAtXHUwMDFGKSBmb3VuZCB3aGlsZSBwYXJzaW5nIGEgc3RyaW5naW52YWxpZCB1bmljb2RlIGNvZGUgcG9pbnRudW1iZXIgb3V0IG9mIHJhbmdlaW52YWxpZCBudW1iZXJpbnZhbGlkIGVzY2FwZWV4cGVjdGVkIHZhbHVlZXhwZWN0ZWQgaWRlbnRleHBlY3RlZCBgLGAgb3IgYH1gZXhwZWN0ZWQgYCxgIG9yIGBdYGV4cGVjdGVkIGA6YEVPRiB3aGlsZSBwYXJzaW5nIGEgdmFsdWVFT0Ygd2hpbGUgcGFyc2luZyBhIHN0cmluZ0VPRiB3aGlsZSBwYXJzaW5nIGFuIG9iamVjdEVPRiB3aGlsZSBwYXJzaW5nIGEgbGlzdCBhdCBsaW5lICBjb2x1bW4gAAAAdPcQAAAAAAAc+hAACQAAACX6EAAIAAAAaW52YWxpZCB0eXBlOiAsIGV4cGVjdGVkIAAAAEj6EAAOAAAAVvoQAAsAAABpbnZhbGlkIHR5cGU6IG51bGwsIGV4cGVjdGVkIAAAAHT6EAAdAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3NlcmRlX2pzb24tMS4wLjkzL3NyYy9lcnJvci5ycwCc+hAAWwAAAJcBAAAeAAAAnPoQAFsAAACbAQAACQAAAJz6EABbAAAAogEAAB4AAACc+hAAWwAAAKsBAAAnAAAAnPoQAFsAAACvAQAAKQAAAAUCAAAEAAAABAAAAAYCAAAHAgAACAIAAEludmFsaWQgc3RyaW5nIGxlbmd0aAAAAGD7EAAVAAAAT2RkIG51bWJlciBvZiBkaWdpdHOA+xAAFAAAAEludmFsaWQgY2hhcmFjdGVyICBhdCBwb3NpdGlvbiAAnPsQABIAAACu+xAADQAAAEludmFsaWRTdHJpbmdMZW5ndGhPZGRMZW5ndGhJbnZhbGlkSGV4Q2hhcmFjdGVyYwoCAAAEAAAABAAAAAsCAABpbmRleAAAAAoCAAAEAAAABAAAAAwCAAANAgAAAAAAAAEAAAAOAgAADwIAABACAAARAgAAEgIAABMCAAAUAgAAFQIAABYCAAAXAgAAFwIAABgCAAAZAgAAGgIAABsCAAAcAgAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3RyYWNpbmctY29yZS0wLjEuMzAvc3JjL2Rpc3BhdGNoZXIucnMAAHD8EABiAAAALgMAACYAAABhbHJlYWR5IGJvcnJvd2VkDQIAAAAAAAABAAAAGQAAAB0CAAAEAAAABAAAAB4CAAAdAgAABAAAAAQAAAAfAgAAHQIAAAQAAAAEAAAAIAIAAFBvaXNvbkVycm9yACECAAAMAAAABAAAACICAAAjAgAATGF6eSBpbnN0YW5jZSBoYXMgcHJldmlvdXNseSBiZWVuIHBvaXNvbmVkAABU/RAAKgAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9vbmNlX2NlbGwtMS4xNy4xL3NyYy9saWIucnOI/RAAWAAAAP8EAAAZAAAAJAIAABgAAAAEAAAAJQIAAGZhdGFsIHJ1bnRpbWUgZXJyb3I6IAoAAAD+EAAVAAAAFf4QAAEAAAByd2xvY2sgbG9ja2VkIGZvciB3cml0aW5nAAAAKP4QABkAAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlACcCAAAIAAAABAAAACgCAAAvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvdHJhY2luZy1jb3JlLTAuMS4zMC9zcmMvY2FsbHNpdGUucnOI/hAAYAAAACcCAAAdAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3RyYWNpbmctY29yZS0wLjEuMzAvc3JjL2NhbGxzaXRlLnJzQXR0ZW1wdGVkIHRvIHJlZ2lzdGVyIGEgYERlZmF1bHRDYWxsc2l0ZWAgdGhhdCBhbHJlYWR5IGV4aXN0cyEgVGhpcyB3aWxsIGNhdXNlIGFuIGluZmluaXRlIGxvb3Agd2hlbiBhdHRlbXB0aW5nIHRvIHJlYWQgZnJvbSB0aGUgY2FsbHNpdGUgY2FjaGUuIFRoaXMgaXMgbGlrZWx5IGEgYnVnISBZb3Ugc2hvdWxkIG9ubHkgbmVlZCB0byBjYWxsIGBEZWZhdWx0Q2FsbHNpdGU6OnJlZ2lzdGVyYCBvbmNlIHBlciBgRGVmYXVsdENhbGxzaXRlYC4AWP8QAPsAAAD4/hAAYAAAAL8BAAANAAAAKQIAAAwAAAAEAAAAKgIAACsCAAAsAgAAZm9ybWF0dGVyIGVycm9yAIQAEQAPAAAAKAAAAGFscmVhZHkgYm9ycm93ZWQtAgAAAAAAAAEAAAAZAAAALQIAAAAAAAABAAAALgIAAC8CAAAwAgAAMQIAABICAAATAgAAFAIAADICAAAWAgAAFwIAABcCAAAzAgAANAIAADUCAAA2AgAANwIAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy90cmFjaW5nLWNvcmUtMC4xLjMwL3NyYy9kaXNwYXRjaGVyLnJzAAAMAREAYgAAAC4DAAAmAAAAaW52YXJpYW50IHZpb2xhdGVkOiBHTE9CQUxfRElTUEFUQ0ggbXVzdCBiZSBpbml0aWFsaXplZCBiZWZvcmUgR0xPQkFMX0lOSVQgaXMgc2V0AAAADAERAGIAAACuAQAADgAAAP////8vcnVzdGMvZmM1OTRmMTU2Njk2ODBmYTcwZDI1NWZhZWMzY2EzZmI1MDdjMzQwNS9saWJyYXJ5L3N0ZC9zcmMvc3lzL3dhc20vLi4vdW5zdXBwb3J0ZWQvbG9ja3Mvcndsb2NrLnJzAOgBEQBnAAAAPwAAAAkAAAA4AgAABAAAAAQAAAA5AgAAOgIAADsCAAA8AgAABAAAAAQAAAA9AgAAAQAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9vbmNlX2NlbGwtMS4xNy4xL3NyYy9pbXBfc3RkLnJzjAIRAFwAAAClAAAACQAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUAjAIRAFwAAACrAAAAHgAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9zbW9sX3N0ci0wLjEuMjQvc3JjL2xpYi5yc2Fzc2VydGlvbiBmYWlsZWQ6IG5ld2xpbmVzIDw9IE5fTkVXTElORVMgJiYgc3BhY2VzIDw9IE5fU1BBQ0VTAAAANAMRAFcAAAC/AQAAEQAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0AxEAVwAAAMABAAASAAAAYSBzdHJpbmdzdHJ1Y3QgdmFyaWFudAAAlAQRAA4AAAB0dXBsZSB2YXJpYW50AAAArAQRAA0AAABuZXd0eXBlIHZhcmlhbnQAxAQRAA8AAAB1bml0IHZhcmlhbnTcBBEADAAAAGVudW3wBBEABAAAAG1hcAD8BBEAAwAAAHNlcXVlbmNlCAURAAgAAABuZXd0eXBlIHN0cnVjdAAAGAURAA4AAABPcHRpb24gdmFsdWUwBREADAAAAHVuaXQgdmFsdWUAAEQFEQAKAAAAYnl0ZSBhcnJheQAAWAURAAoAAABzdHJpbmcgAGwFEQAHAAAAY2hhcmFjdGVyIGBgfAURAAsAAACHBREAAQAAAGZsb2F0aW5nIHBvaW50IGCYBREAEAAAAIcFEQABAAAAaW50ZWdlciBgAAAAuAURAAkAAACHBREAAQAAAGJvb2xlYW4gYAAAANQFEQAJAAAAhwURAAEAAABvbmUgb2YgAPAFEQAHAAAALCAAAAAGEQACAAAAhwURAAEAAACHBREAAQAAAGAgb3IgYAAAhwURAAEAAAAcBhEABgAAAIcFEQABAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3NlcmRlLTEuMC4xNTIvc3JjL2RlL21vZC5yc2V4cGxpY2l0IHBhbmljAAA8BhEAWAAAAOwIAAASAAAAdW5pdGEgYm9vbGVhbmEgc3RyaW5naTY0dThhIG5vbnplcm8gdTY0dTY0AABDAgAACAAAAAQAAABEAgAARQIAAEYCAAAIAAAABAAAAEcCAABLAgAABAAAAAQAAABMAgAATQIAAE4CAABhbHJlYWR5IGJvcnJvd2VkSwIAAAAAAAABAAAAGQAAAAAAAABLAgAABAAAAAQAAABPAgAASwIAAAQAAAAEAAAAUAIAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWVBY2Nlc3NFcnJvcnVzZSBvZiBzdGQ6OnRocmVhZDo6Y3VycmVudCgpIGlzIG5vdCBwb3NzaWJsZSBhZnRlciB0aGUgdGhyZWFkJ3MgbG9jYWwgZGF0YSBoYXMgYmVlbiBkZXN0cm95ZWRsaWJyYXJ5L3N0ZC9zcmMvdGhyZWFkL21vZC5ycwAAAPQHEQAdAAAA3AIAAAUAAABmYWlsZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIHRocmVhZCBJRDogYml0c3BhY2UgZXhoYXVzdGVkACQIEQA3AAAA9AcRAB0AAABVBAAADQAAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUAHAcRAAAAAAB1bmNhdGVnb3JpemVkIGVycm9yb3RoZXIgZXJyb3JvdXQgb2YgbWVtb3J5dW5leHBlY3RlZCBlbmQgb2YgZmlsZXVuc3VwcG9ydGVkb3BlcmF0aW9uIGludGVycnVwdGVkYXJndW1lbnQgbGlzdCB0b28gbG9uZ2ludmFsaWQgZmlsZW5hbWV0b28gbWFueSBsaW5rc2Nyb3NzLWRldmljZSBsaW5rIG9yIHJlbmFtZWRlYWRsb2NrZXhlY3V0YWJsZSBmaWxlIGJ1c3lyZXNvdXJjZSBidXN5ZmlsZSB0b28gbGFyZ2VmaWxlc3lzdGVtIHF1b3RhIGV4Y2VlZGVkc2VlayBvbiB1bnNlZWthYmxlIGZpbGVubyBzdG9yYWdlIHNwYWNld3JpdGUgemVyb3RpbWVkIG91dGludmFsaWQgZGF0YWludmFsaWQgaW5wdXQgcGFyYW1ldGVyc3RhbGUgbmV0d29yayBmaWxlIGhhbmRsZWZpbGVzeXN0ZW0gbG9vcCBvciBpbmRpcmVjdGlvbiBsaW1pdCAoZS5nLiBzeW1saW5rIGxvb3ApcmVhZC1vbmx5IGZpbGVzeXN0ZW0gb3Igc3RvcmFnZSBtZWRpdW1kaXJlY3Rvcnkgbm90IGVtcHR5aXMgYSBkaXJlY3Rvcnlub3QgYSBkaXJlY3RvcnlvcGVyYXRpb24gd291bGQgYmxvY2tlbnRpdHkgYWxyZWFkeSBleGlzdHNicm9rZW4gcGlwZW5ldHdvcmsgZG93bmFkZHJlc3Mgbm90IGF2YWlsYWJsZWFkZHJlc3MgaW4gdXNlbm90IGNvbm5lY3RlZGNvbm5lY3Rpb24gYWJvcnRlZG5ldHdvcmsgdW5yZWFjaGFibGVob3N0IHVucmVhY2hhYmxlY29ubmVjdGlvbiByZXNldGNvbm5lY3Rpb24gcmVmdXNlZHBlcm1pc3Npb24gZGVuaWVkZW50aXR5IG5vdCBmb3VuZEVycm9ya2luZAAASwIAAAEAAAABAAAAUQIAAG1lc3NhZ2UASwIAAAgAAAAEAAAAUgIAAEtpbmRPc2NvZGUAAEsCAAAEAAAABAAAAFMCAABUAgAADAAAAAQAAABVAgAAIChvcyBlcnJvciApHAcRAAAAAAD0CxEACwAAAP8LEQABAAAAUG9pc29uRXJyb3JsaWJyYXJ5L3N0ZC9zcmMvc3lzX2NvbW1vbi90aHJlYWRfaW5mby5ycyMMEQApAAAAFgAAADMAAABtZW1vcnkgYWxsb2NhdGlvbiBvZiAgYnl0ZXMgZmFpbGVkCgBcDBEAFQAAAHEMEQAOAAAAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJzkAwRABgAAABVAQAACQAAAGNhbm5vdCBtb2RpZnkgdGhlIHBhbmljIGhvb2sgZnJvbSBhIHBhbmlja2luZyB0aHJlYWS4DBEANAAAAGxpYnJhcnkvc3RkL3NyYy9wYW5pY2tpbmcucnP0DBEAHAAAAIYAAAAJAAAA9AwRABwAAAA+AgAADwAAAPQMEQAcAAAAPQIAAA8AAABUAgAADAAAAAQAAABWAgAASwIAAAgAAAAEAAAAVwIAAFgCAAAQAAAABAAAAFkCAABaAgAASwIAAAgAAAAEAAAAWwIAAFwCAABLAgAAAAAAAAEAAABdAgAAVW5zdXBwb3J0ZWQASwIAAAQAAAAEAAAAXgIAAEN1c3RvbWVycm9yAEsCAAAEAAAABAAAAF8CAABVbmNhdGVnb3JpemVkT3RoZXJPdXRPZk1lbW9yeVVuZXhwZWN0ZWRFb2ZJbnRlcnJ1cHRlZEFyZ3VtZW50TGlzdFRvb0xvbmdJbnZhbGlkRmlsZW5hbWVUb29NYW55TGlua3NDcm9zc2VzRGV2aWNlc0RlYWRsb2NrRXhlY3V0YWJsZUZpbGVCdXN5UmVzb3VyY2VCdXN5RmlsZVRvb0xhcmdlRmlsZXN5c3RlbVF1b3RhRXhjZWVkZWROb3RTZWVrYWJsZVN0b3JhZ2VGdWxsV3JpdGVaZXJvVGltZWRPdXRJbnZhbGlkRGF0YUludmFsaWRJbnB1dFN0YWxlTmV0d29ya0ZpbGVIYW5kbGVGaWxlc3lzdGVtTG9vcFJlYWRPbmx5RmlsZXN5c3RlbURpcmVjdG9yeU5vdEVtcHR5SXNBRGlyZWN0b3J5Tm90QURpcmVjdG9yeVdvdWxkQmxvY2tBbHJlYWR5RXhpc3RzQnJva2VuUGlwZU5ldHdvcmtEb3duQWRkck5vdEF2YWlsYWJsZUFkZHJJblVzZU5vdENvbm5lY3RlZENvbm5lY3Rpb25BYm9ydGVkTmV0d29ya1VucmVhY2hhYmxlSG9zdFVucmVhY2hhYmxlQ29ubmVjdGlvblJlc2V0Q29ubmVjdGlvblJlZnVzZWRQZXJtaXNzaW9uRGVuaWVkTm90Rm91bmRvcGVyYXRpb24gc3VjY2Vzc2Z1bGNvbmR2YXIgd2FpdCBub3Qgc3VwcG9ydGVkAAAA9w8RABoAAABsaWJyYXJ5L3N0ZC9zcmMvc3lzL3dhc20vLi4vdW5zdXBwb3J0ZWQvbG9ja3MvY29uZHZhci5ycxwQEQA4AAAAFAAAAAkAAABjYW5ub3QgcmVjdXJzaXZlbHkgYWNxdWlyZSBtdXRleGQQEQAgAAAAbGlicmFyeS9zdGQvc3JjL3N5cy93YXNtLy4uL3Vuc3VwcG9ydGVkL2xvY2tzL211dGV4LnJzAACMEBEANgAAABQAAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogc3RhdGVfYW5kX3F1ZXVlLmFkZHIoKSAmIFNUQVRFX01BU0sgPT0gUlVOTklOR09uY2UgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZAAAFBERACoAAAAC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");

  // wasm-stub:C:\Users\ulyss\Development\nodysseus\node_modules\@automerge\automerge-wasm\bundler\automerge_wasm_bg.wasm
  var automerge_wasm_bg_default2 = (imports) => WebAssembly.instantiate(automerge_wasm_bg_default, imports).then(
    (result) => result.instance.exports
  );

  // node_modules/@automerge/automerge-wasm/bundler/automerge_wasm_bg.js
  var wasm;
  function __wbg_set_wasm(val) {
    wasm = val;
  }
  var heap = new Array(128).fill(void 0);
  heap.push(void 0, null, true, false);
  function getObject(idx) {
    return heap[idx];
  }
  var heap_next = heap.length;
  function addHeapObject(obj) {
    if (heap_next === heap.length)
      heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];
    heap[idx] = obj;
    return idx;
  }
  function dropObject(idx) {
    if (idx < 132)
      return;
    heap[idx] = heap_next;
    heap_next = idx;
  }
  function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
  }
  var lTextDecoder = typeof TextDecoder === "undefined" ? (0, module.require)("util").TextDecoder : TextDecoder;
  var cachedTextDecoder = new lTextDecoder("utf-8", { ignoreBOM: true, fatal: true });
  cachedTextDecoder.decode();
  var cachedUint8Memory0 = null;
  function getUint8Memory0() {
    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
      cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory0;
  }
  function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
  }
  var WASM_VECTOR_LEN = 0;
  var lTextEncoder = typeof TextEncoder === "undefined" ? (0, module.require)("util").TextEncoder : TextEncoder;
  var cachedTextEncoder = new lTextEncoder("utf-8");
  var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view2) {
    return cachedTextEncoder.encodeInto(arg, view2);
  } : function(arg, view2) {
    const buf = cachedTextEncoder.encode(arg);
    view2.set(buf);
    return {
      read: arg.length,
      written: buf.length
    };
  };
  function passStringToWasm0(arg, malloc, realloc) {
    if (realloc === void 0) {
      const buf = cachedTextEncoder.encode(arg);
      const ptr2 = malloc(buf.length);
      getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
      WASM_VECTOR_LEN = buf.length;
      return ptr2;
    }
    let len = arg.length;
    let ptr = malloc(len);
    const mem = getUint8Memory0();
    let offset = 0;
    for (; offset < len; offset++) {
      const code = arg.charCodeAt(offset);
      if (code > 127)
        break;
      mem[ptr + offset] = code;
    }
    if (offset !== len) {
      if (offset !== 0) {
        arg = arg.slice(offset);
      }
      ptr = realloc(ptr, len, len = offset + arg.length * 3);
      const view2 = getUint8Memory0().subarray(ptr + offset, ptr + len);
      const ret = encodeString(arg, view2);
      offset += ret.written;
    }
    WASM_VECTOR_LEN = offset;
    return ptr;
  }
  function isLikeNone(x3) {
    return x3 === void 0 || x3 === null;
  }
  var cachedInt32Memory0 = null;
  function getInt32Memory0() {
    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
      cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachedInt32Memory0;
  }
  var cachedFloat64Memory0 = null;
  function getFloat64Memory0() {
    if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {
      cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);
    }
    return cachedFloat64Memory0;
  }
  function debugString(val) {
    const type = typeof val;
    if (type == "number" || type == "boolean" || val == null) {
      return `${val}`;
    }
    if (type == "string") {
      return `"${val}"`;
    }
    if (type == "symbol") {
      const description = val.description;
      if (description == null) {
        return "Symbol";
      } else {
        return `Symbol(${description})`;
      }
    }
    if (type == "function") {
      const name2 = val.name;
      if (typeof name2 == "string" && name2.length > 0) {
        return `Function(${name2})`;
      } else {
        return "Function";
      }
    }
    if (Array.isArray(val)) {
      const length3 = val.length;
      let debug = "[";
      if (length3 > 0) {
        debug += debugString(val[0]);
      }
      for (let i = 1; i < length3; i++) {
        debug += ", " + debugString(val[i]);
      }
      debug += "]";
      return debug;
    }
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
    let className;
    if (builtInMatches.length > 1) {
      className = builtInMatches[1];
    } else {
      return toString.call(val);
    }
    if (className == "Object") {
      try {
        return "Object(" + JSON.stringify(val) + ")";
      } catch (_) {
        return "Object";
      }
    }
    if (val instanceof Error) {
      return `${val.name}: ${val.message}
${val.stack}`;
    }
    return className;
  }
  function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
      throw new Error(`expected instance of ${klass.name}`);
    }
    return instance.ptr;
  }
  function create7(text_v2, actor) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      var len0 = WASM_VECTOR_LEN;
      wasm.create(retptr, text_v2, ptr0, len0);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return Automerge.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  function load(data2, text_v2, actor) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      var len0 = WASM_VECTOR_LEN;
      wasm.load(retptr, addHeapObject(data2), text_v2, ptr0, len0);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return Automerge.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  function encodeChange(change2) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.encodeChange(retptr, addHeapObject(change2));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  function decodeChange(change2) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.decodeChange(retptr, addHeapObject(change2));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  function initSyncState() {
    const ret = wasm.initSyncState();
    return SyncState.__wrap(ret);
  }
  function importSyncState(state) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.importSyncState(retptr, addHeapObject(state));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return SyncState.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  function exportSyncState(state) {
    _assertClass(state, SyncState);
    const ret = wasm.exportSyncState(state.ptr);
    return takeObject(ret);
  }
  function encodeSyncMessage(message) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.encodeSyncMessage(retptr, addHeapObject(message));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  function decodeSyncMessage(msg) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.decodeSyncMessage(retptr, addHeapObject(msg));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  function encodeSyncState(state) {
    _assertClass(state, SyncState);
    const ret = wasm.encodeSyncState(state.ptr);
    return takeObject(ret);
  }
  function decodeSyncState(data2) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.decodeSyncState(retptr, addHeapObject(data2));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return SyncState.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  function handleError2(f, args2) {
    try {
      return f.apply(this, args2);
    } catch (e) {
      wasm.__wbindgen_exn_store(addHeapObject(e));
    }
  }
  function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
  }
  var TextRepresentation = Object.freeze({
    Array: 0,
    "0": "Array",
    String: 1,
    "1": "String"
  });
  var AutomergeFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_automerge_free(ptr));
  var Automerge = class {
    static __wrap(ptr) {
      const obj = Object.create(Automerge.prototype);
      obj.ptr = ptr;
      AutomergeFinalization.register(obj, obj.ptr, obj);
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.ptr;
      this.ptr = 0;
      AutomergeFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_automerge_free(ptr);
    }
    static new(actor, text_rep) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.automerge_new(retptr, ptr0, len0, text_rep);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return Automerge.__wrap(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    clone(actor) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.automerge_clone(retptr, this.ptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return Automerge.__wrap(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    fork(actor, heads) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.automerge_fork(retptr, this.ptr, ptr0, len0, addHeapObject(heads));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return Automerge.__wrap(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    pendingOps() {
      const ret = wasm.automerge_pendingOps(this.ptr);
      return takeObject(ret);
    }
    commit(message, time) {
      var ptr0 = isLikeNone(message) ? 0 : passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      var len0 = WASM_VECTOR_LEN;
      const ret = wasm.automerge_commit(this.ptr, ptr0, len0, !isLikeNone(time), isLikeNone(time) ? 0 : time);
      return takeObject(ret);
    }
    merge(other) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(other, Automerge);
        wasm.automerge_merge(retptr, this.ptr, other.ptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    rollback() {
      const ret = wasm.automerge_rollback(this.ptr);
      return ret;
    }
    keys(obj, heads) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_keys(retptr, this.ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    text(obj, heads) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_text(retptr, this.ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr0 = r0;
        var len0 = r1;
        if (r3) {
          ptr0 = 0;
          len0 = 0;
          throw takeObject(r2);
        }
        return getStringFromWasm0(ptr0, len0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_free(ptr0, len0);
      }
    }
    splice(obj, start, delete_count, text3) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_splice(retptr, this.ptr, addHeapObject(obj), start, delete_count, addHeapObject(text3));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        if (r1) {
          throw takeObject(r0);
        }
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    push(obj, value, datatype) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_push(retptr, this.ptr, addHeapObject(obj), addHeapObject(value), addHeapObject(datatype));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        if (r1) {
          throw takeObject(r0);
        }
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    pushObject(obj, value) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_pushObject(retptr, this.ptr, addHeapObject(obj), addHeapObject(value));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        if (r3) {
          throw takeObject(r2);
        }
        let v0;
        if (r0 !== 0) {
          v0 = getStringFromWasm0(r0, r1).slice();
          wasm.__wbindgen_free(r0, r1 * 1);
        }
        return v0;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    insert(obj, index2, value, datatype) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_insert(retptr, this.ptr, addHeapObject(obj), index2, addHeapObject(value), addHeapObject(datatype));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        if (r1) {
          throw takeObject(r0);
        }
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    insertObject(obj, index2, value) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_insertObject(retptr, this.ptr, addHeapObject(obj), index2, addHeapObject(value));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        if (r3) {
          throw takeObject(r2);
        }
        let v0;
        if (r0 !== 0) {
          v0 = getStringFromWasm0(r0, r1).slice();
          wasm.__wbindgen_free(r0, r1 * 1);
        }
        return v0;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    put(obj, prop, value, datatype) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_put(retptr, this.ptr, addHeapObject(obj), addHeapObject(prop), addHeapObject(value), addHeapObject(datatype));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        if (r1) {
          throw takeObject(r0);
        }
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    putObject(obj, prop, value) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_putObject(retptr, this.ptr, addHeapObject(obj), addHeapObject(prop), addHeapObject(value));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    increment(obj, prop, value) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_increment(retptr, this.ptr, addHeapObject(obj), addHeapObject(prop), addHeapObject(value));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        if (r1) {
          throw takeObject(r0);
        }
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    get(obj, prop, heads) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_get(retptr, this.ptr, addHeapObject(obj), addHeapObject(prop), isLikeNone(heads) ? 0 : addHeapObject(heads));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    getWithType(obj, prop, heads) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_getWithType(retptr, this.ptr, addHeapObject(obj), addHeapObject(prop), isLikeNone(heads) ? 0 : addHeapObject(heads));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    getAll(obj, arg, heads) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_getAll(retptr, this.ptr, addHeapObject(obj), addHeapObject(arg), isLikeNone(heads) ? 0 : addHeapObject(heads));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    enableFreeze(enable) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_enableFreeze(retptr, this.ptr, addHeapObject(enable));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    enablePatches(enable) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_enablePatches(retptr, this.ptr, addHeapObject(enable));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    registerDatatype(datatype, _function2) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_registerDatatype(retptr, this.ptr, addHeapObject(datatype), addHeapObject(_function2));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        if (r1) {
          throw takeObject(r0);
        }
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    applyPatches(object2, meta2, callback) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_applyPatches(retptr, this.ptr, addHeapObject(object2), addHeapObject(meta2), addHeapObject(callback));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    popPatches() {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_popPatches(retptr, this.ptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    length(obj, heads) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_length(retptr, this.ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));
        var r0 = getFloat64Memory0()[retptr / 8 + 0];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        if (r3) {
          throw takeObject(r2);
        }
        return r0;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    delete(obj, prop) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_delete(retptr, this.ptr, addHeapObject(obj), addHeapObject(prop));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        if (r1) {
          throw takeObject(r0);
        }
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    save() {
      const ret = wasm.automerge_save(this.ptr);
      return takeObject(ret);
    }
    saveIncremental() {
      const ret = wasm.automerge_saveIncremental(this.ptr);
      return takeObject(ret);
    }
    loadIncremental(data2) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_loadIncremental(retptr, this.ptr, addHeapObject(data2));
        var r0 = getFloat64Memory0()[retptr / 8 + 0];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        if (r3) {
          throw takeObject(r2);
        }
        return r0;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    applyChanges(changes) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_applyChanges(retptr, this.ptr, addHeapObject(changes));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        if (r1) {
          throw takeObject(r0);
        }
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    getChanges(have_deps) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_getChanges(retptr, this.ptr, addHeapObject(have_deps));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    getChangeByHash(hash2) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_getChangeByHash(retptr, this.ptr, addHeapObject(hash2));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    getChangesAdded(other) {
      _assertClass(other, Automerge);
      const ret = wasm.automerge_getChangesAdded(this.ptr, other.ptr);
      return takeObject(ret);
    }
    getHeads() {
      const ret = wasm.automerge_getHeads(this.ptr);
      return takeObject(ret);
    }
    getActorId() {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_getActorId(retptr, this.ptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        return getStringFromWasm0(r0, r1);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_free(r0, r1);
      }
    }
    getLastLocalChange() {
      const ret = wasm.automerge_getLastLocalChange(this.ptr);
      return takeObject(ret);
    }
    dump() {
      wasm.automerge_dump(this.ptr);
    }
    getMissingDeps(heads) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_getMissingDeps(retptr, this.ptr, isLikeNone(heads) ? 0 : addHeapObject(heads));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    receiveSyncMessage(state, message) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(state, SyncState);
        wasm.automerge_receiveSyncMessage(retptr, this.ptr, state.ptr, addHeapObject(message));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        if (r1) {
          throw takeObject(r0);
        }
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    generateSyncMessage(state) {
      _assertClass(state, SyncState);
      const ret = wasm.automerge_generateSyncMessage(this.ptr, state.ptr);
      return takeObject(ret);
    }
    toJS(meta2) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_toJS(retptr, this.ptr, addHeapObject(meta2));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    materialize(obj, heads, meta2) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.automerge_materialize(retptr, this.ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads), addHeapObject(meta2));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    emptyChange(message, time) {
      var ptr0 = isLikeNone(message) ? 0 : passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      var len0 = WASM_VECTOR_LEN;
      const ret = wasm.automerge_emptyChange(this.ptr, ptr0, len0, !isLikeNone(time), isLikeNone(time) ? 0 : time);
      return takeObject(ret);
    }
  };
  var SyncStateFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_syncstate_free(ptr));
  var SyncState = class {
    static __wrap(ptr) {
      const obj = Object.create(SyncState.prototype);
      obj.ptr = ptr;
      SyncStateFinalization.register(obj, obj.ptr, obj);
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.ptr;
      this.ptr = 0;
      SyncStateFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_syncstate_free(ptr);
    }
    get sharedHeads() {
      const ret = wasm.syncstate_sharedHeads(this.ptr);
      return takeObject(ret);
    }
    get lastSentHeads() {
      const ret = wasm.syncstate_lastSentHeads(this.ptr);
      return takeObject(ret);
    }
    set lastSentHeads(heads) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.syncstate_set_lastSentHeads(retptr, this.ptr, addHeapObject(heads));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        if (r1) {
          throw takeObject(r0);
        }
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    set sentHashes(hashes) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.syncstate_set_sentHashes(retptr, this.ptr, addHeapObject(hashes));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        if (r1) {
          throw takeObject(r0);
        }
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    clone() {
      const ret = wasm.syncstate_clone(this.ptr);
      return SyncState.__wrap(ret);
    }
  };
  function __wbindgen_object_clone_ref(arg0) {
    const ret = getObject(arg0);
    return addHeapObject(ret);
  }
  function __wbindgen_object_drop_ref(arg0) {
    takeObject(arg0);
  }
  function __wbindgen_string_new(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
  }
  function __wbindgen_is_undefined(arg0) {
    const ret = getObject(arg0) === void 0;
    return ret;
  }
  function __wbindgen_string_get(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "string" ? obj : void 0;
    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
  }
  function __wbindgen_number_new(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
  }
  function __wbindgen_is_string(arg0) {
    const ret = typeof getObject(arg0) === "string";
    return ret;
  }
  function __wbindgen_is_function(arg0) {
    const ret = typeof getObject(arg0) === "function";
    return ret;
  }
  function __wbindgen_number_get(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "number" ? obj : void 0;
    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;
    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);
  }
  function __wbindgen_is_null(arg0) {
    const ret = getObject(arg0) === null;
    return ret;
  }
  function __wbindgen_boolean_get(arg0) {
    const v = getObject(arg0);
    const ret = typeof v === "boolean" ? v ? 1 : 0 : 2;
    return ret;
  }
  function __wbindgen_json_serialize(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = JSON.stringify(obj === void 0 ? null : obj);
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
  }
  function __wbindgen_error_new(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  }
  function __wbg_new_abda76e883ba8a5f() {
    const ret = new Error();
    return addHeapObject(ret);
  }
  function __wbg_stack_658279fe44541cf6(arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
  }
  function __wbg_error_f851667af71bcfc6(arg0, arg1) {
    try {
      console.error(getStringFromWasm0(arg0, arg1));
    } finally {
      wasm.__wbindgen_free(arg0, arg1);
    }
  }
  function __wbindgen_bigint_from_i64(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
  }
  function __wbindgen_bigint_from_u64(arg0) {
    const ret = BigInt.asUintN(64, arg0);
    return addHeapObject(ret);
  }
  function __wbindgen_is_object(arg0) {
    const val = getObject(arg0);
    const ret = typeof val === "object" && val !== null;
    return ret;
  }
  function __wbindgen_jsval_loose_eq(arg0, arg1) {
    const ret = getObject(arg0) == getObject(arg1);
    return ret;
  }
  function __wbg_String_91fba7ded13ba54c(arg0, arg1) {
    const ret = String(getObject(arg1));
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
  }
  function __wbg_set_20cbc34131e76824(arg0, arg1, arg2) {
    getObject(arg0)[takeObject(arg1)] = takeObject(arg2);
  }
  function __wbg_randomFillSync_6894564c2c334c42() {
    return handleError2(function(arg0, arg1, arg2) {
      getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));
    }, arguments);
  }
  function __wbg_getRandomValues_805f1c3d65988a5a() {
    return handleError2(function(arg0, arg1) {
      getObject(arg0).getRandomValues(getObject(arg1));
    }, arguments);
  }
  function __wbg_crypto_e1d53a1d73fb10b8(arg0) {
    const ret = getObject(arg0).crypto;
    return addHeapObject(ret);
  }
  function __wbg_process_038c26bf42b093f8(arg0) {
    const ret = getObject(arg0).process;
    return addHeapObject(ret);
  }
  function __wbg_versions_ab37218d2f0b24a8(arg0) {
    const ret = getObject(arg0).versions;
    return addHeapObject(ret);
  }
  function __wbg_node_080f4b19d15bc1fe(arg0) {
    const ret = getObject(arg0).node;
    return addHeapObject(ret);
  }
  function __wbg_msCrypto_6e7d3e1f92610cbb(arg0) {
    const ret = getObject(arg0).msCrypto;
    return addHeapObject(ret);
  }
  function __wbg_require_78a3dcfbdba9cbce() {
    return handleError2(function() {
      const ret = module.require;
      return addHeapObject(ret);
    }, arguments);
  }
  function __wbg_log_7bb108d119bafbc1(arg0) {
    console.log(getObject(arg0));
  }
  function __wbg_log_d047cf0648d2678e(arg0, arg1) {
    console.log(getObject(arg0), getObject(arg1));
  }
  function __wbg_get_27fe3dac1c4d0224(arg0, arg1) {
    const ret = getObject(arg0)[arg1 >>> 0];
    return addHeapObject(ret);
  }
  function __wbg_length_e498fbc24f9c1d4f(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  }
  function __wbg_new_b525de17f44a8943() {
    const ret = new Array();
    return addHeapObject(ret);
  }
  function __wbg_newnoargs_2b8b6bd7753c76ba(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  }
  function __wbg_next_b7d530c04fd8b217(arg0) {
    const ret = getObject(arg0).next;
    return addHeapObject(ret);
  }
  function __wbg_next_88560ec06a094dea() {
    return handleError2(function(arg0) {
      const ret = getObject(arg0).next();
      return addHeapObject(ret);
    }, arguments);
  }
  function __wbg_done_1ebec03bbd919843(arg0) {
    const ret = getObject(arg0).done;
    return ret;
  }
  function __wbg_value_6ac8da5cc5b3efda(arg0) {
    const ret = getObject(arg0).value;
    return addHeapObject(ret);
  }
  function __wbg_iterator_55f114446221aa5a() {
    const ret = Symbol.iterator;
    return addHeapObject(ret);
  }
  function __wbg_get_baf4855f9a986186() {
    return handleError2(function(arg0, arg1) {
      const ret = Reflect.get(getObject(arg0), getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  }
  function __wbg_call_95d1ea488d03e4e8() {
    return handleError2(function(arg0, arg1) {
      const ret = getObject(arg0).call(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  }
  function __wbg_new_f9876326328f45ed() {
    const ret = new Object();
    return addHeapObject(ret);
  }
  function __wbg_length_ea0846e494e3b16e(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  }
  function __wbg_self_e7c1f827057f6584() {
    return handleError2(function() {
      const ret = self.self;
      return addHeapObject(ret);
    }, arguments);
  }
  function __wbg_window_a09ec664e14b1b81() {
    return handleError2(function() {
      const ret = window.window;
      return addHeapObject(ret);
    }, arguments);
  }
  function __wbg_globalThis_87cbb8506fecf3a9() {
    return handleError2(function() {
      const ret = globalThis.globalThis;
      return addHeapObject(ret);
    }, arguments);
  }
  function __wbg_global_c85a9259e621f3db() {
    return handleError2(function() {
      const ret = global.global;
      return addHeapObject(ret);
    }, arguments);
  }
  function __wbg_set_17224bc548dd1d7b(arg0, arg1, arg2) {
    getObject(arg0)[arg1 >>> 0] = takeObject(arg2);
  }
  function __wbg_from_67ca20fa722467e6(arg0) {
    const ret = Array.from(getObject(arg0));
    return addHeapObject(ret);
  }
  function __wbg_isArray_39d28997bf6b96b4(arg0) {
    const ret = Array.isArray(getObject(arg0));
    return ret;
  }
  function __wbg_push_49c286f04dd3bf59(arg0, arg1) {
    const ret = getObject(arg0).push(getObject(arg1));
    return ret;
  }
  function __wbg_unshift_06a94bcbcb492eb3(arg0, arg1) {
    const ret = getObject(arg0).unshift(getObject(arg1));
    return ret;
  }
  function __wbg_instanceof_ArrayBuffer_a69f02ee4c4f5065(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof ArrayBuffer;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  }
  function __wbg_new_15d3966e9981a196(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  }
  function __wbg_call_9495de66fdbe016b() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  }
  function __wbg_call_99043a1e2a9e5916() {
    return handleError2(function(arg0, arg1, arg2, arg3, arg4) {
      const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3), getObject(arg4));
      return addHeapObject(ret);
    }, arguments);
  }
  function __wbg_instanceof_Date_e353425d719aa266(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Date;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  }
  function __wbg_getTime_7c59072d1651a3cf(arg0) {
    const ret = getObject(arg0).getTime();
    return ret;
  }
  function __wbg_new_f127e324c1313064(arg0) {
    const ret = new Date(getObject(arg0));
    return addHeapObject(ret);
  }
  function __wbg_instanceof_Object_f5a826c4da0d4a94(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Object;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  }
  function __wbg_assign_b0b6530984f36574(arg0, arg1) {
    const ret = Object.assign(getObject(arg0), getObject(arg1));
    return addHeapObject(ret);
  }
  function __wbg_defineProperty_4926f24c724d5310(arg0, arg1, arg2) {
    const ret = Object.defineProperty(getObject(arg0), getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
  }
  function __wbg_entries_4e1315b774245952(arg0) {
    const ret = Object.entries(getObject(arg0));
    return addHeapObject(ret);
  }
  function __wbg_freeze_4dcdbf0b5d9b50f4(arg0) {
    const ret = Object.freeze(getObject(arg0));
    return addHeapObject(ret);
  }
  function __wbg_keys_60443f4f867207f9(arg0) {
    const ret = Object.keys(getObject(arg0));
    return addHeapObject(ret);
  }
  function __wbg_values_7444c4c2ccefdc9b(arg0) {
    const ret = Object.values(getObject(arg0));
    return addHeapObject(ret);
  }
  function __wbg_concat_040af6c9ba38dd98(arg0, arg1) {
    const ret = getObject(arg0).concat(getObject(arg1));
    return addHeapObject(ret);
  }
  function __wbg_slice_47202b1d012cdc55(arg0, arg1, arg2) {
    const ret = getObject(arg0).slice(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  }
  function __wbg_for_9a885d0d6d415e40(arg0, arg1) {
    const ret = Symbol.for(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  }
  function __wbg_toString_7a3e0cd68ea2a337(arg0) {
    const ret = getObject(arg0).toString();
    return addHeapObject(ret);
  }
  function __wbg_buffer_cf65c07de34b9a08(arg0) {
    const ret = getObject(arg0).buffer;
    return addHeapObject(ret);
  }
  function __wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5(arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  }
  function __wbg_new_537b7341ce90bb31(arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
  }
  function __wbg_set_17499e8aa4003ebd(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
  }
  function __wbg_length_27a2afe8ab42b09f(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  }
  function __wbg_instanceof_Uint8Array_01cebe79ca606cca(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Uint8Array;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  }
  function __wbg_newwithlength_b56c882b57805732(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject(ret);
  }
  function __wbg_subarray_7526649b91a252a6(arg0, arg1, arg2) {
    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  }
  function __wbg_apply_5435e78b95a524a6() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = Reflect.apply(getObject(arg0), getObject(arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  }
  function __wbg_deleteProperty_31090878b92a7c0e() {
    return handleError2(function(arg0, arg1) {
      const ret = Reflect.deleteProperty(getObject(arg0), getObject(arg1));
      return ret;
    }, arguments);
  }
  function __wbg_ownKeys_9efe69be404540aa() {
    return handleError2(function(arg0) {
      const ret = Reflect.ownKeys(getObject(arg0));
      return addHeapObject(ret);
    }, arguments);
  }
  function __wbg_set_6aa458a4ebdb65cb() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));
      return ret;
    }, arguments);
  }
  function __wbindgen_debug_string(arg0, arg1) {
    const ret = debugString(getObject(arg1));
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
  }
  function __wbindgen_throw(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  }
  function __wbindgen_memory() {
    const ret = wasm.memory;
    return addHeapObject(ret);
  }

  // node_modules/@automerge/automerge-wasm/bundler/automerge_wasm.js
  __wbg_set_wasm(automerge_wasm_bg_exports2);

  // node_modules/@automerge/automerge/dist/mjs/stable.js
  var SyncStateSymbol = Symbol("_syncstate");
  function use(api) {
    UseApi(api);
  }
  use(automerge_wasm_exports);

  // src/editor/store.ts
  var generic_nodes2 = generic_default.nodes;
  var generic_node_ids = new Set(Object.keys(generic_nodes2));
  var setMapFromGraph = (infomap, data2) => {
    infomap.doc.transact(() => {
      if (infomap.get("name") !== data2.name) {
        infomap.set("name", data2.name);
      }
      if (data2.ref && data2.ref !== infomap.get("ref")) {
        infomap.set("ref", data2?.ref);
      } else if (infomap.has("ref") && !data2.ref) {
        infomap.delete("ref");
      }
      if (data2.value && data2.value !== infomap.get("value")) {
        infomap.set("value", data2?.value);
      } else if (infomap.has("value") && !data2.value) {
        infomap.delete("value");
      }
      if (data2.out && data2.out !== infomap.get("out")) {
        infomap.set("out", data2?.out);
      } else if (infomap.has("out") && !data2.out) {
        infomap.delete("out");
      }
      if (data2.nodes) {
        let nodesymap = infomap.get("nodes");
        if (!infomap.get("nodes")?.set) {
          nodesymap = new YMap();
          infomap.set("nodes", nodesymap);
        }
        if (Array.isArray(data2.nodes)) {
          nodesymap.clear();
          data2.nodes.map((n2) => nodesymap.set(n2.id, n2));
        } else {
          Object.entries(data2.nodes).forEach((kv) => !compare(nodesymap.get(kv[0]), kv[1]) && nodesymap.set(kv[0], kv[1]));
          nodesymap.forEach((node, key) => {
            if (!data2.nodes[key]) {
              nodesymap.delete(key);
            }
          });
        }
      }
      if (data2.edges) {
        let edgesymap = infomap.get("edges");
        if (!infomap.get("edges")?.set) {
          edgesymap = new YMap();
          infomap.set("edges", edgesymap);
        }
        edgesymap.clear();
        if (Array.isArray(data2.edges)) {
          const edgeset = new Set(data2.edges.map((e) => e.from));
          if (edgeset.size !== data2.edges.length) {
            console.log(`invalid edges for ${data2.id}`);
            console.log(data2.edges.filter((e) => {
              edgeset.has(e.from) ? edgeset.delete(e.from) : console.log(e.from);
            }));
          }
          data2.edges.map((e) => edgesymap.set(e.from, e));
        } else {
          Object.entries(data2.edges).forEach((kv) => !compare(edgesymap.get(kv[0]), kv[1]) && edgesymap.set(kv[0], kv[1]));
          edgesymap.forEach((edge, key) => {
            if (!data2.edges[key]) {
              edgesymap.delete(key);
            }
          });
        }
      }
    });
  };
  var ydocStore = async ({ persist = false, rtcpolyfill = void 0, update = void 0 }) => {
    const rootDoc = new Doc();
    const ydoc = new Doc();
    rootDoc.getMap().set("ydoc", ydoc);
    const ymap = ydoc.getMap();
    const getLocalGraphYMap = (id3) => ymap.get(id3).getMap();
    ydoc.on("subdocs", (e) => {
      e.loaded.forEach((sd) => {
        sd.emit("load", [sd]);
      });
    });
    const rdoc = new Doc({ autoLoad: true });
    rootDoc.getMap().set("rdoc", rdoc);
    const rmap = rdoc.getMap();
    const syncedGraphs = /* @__PURE__ */ new Map();
    let undoManager;
    const set3 = (id3, data2) => {
      if (generic_node_ids.has(id3)) {
        generic_nodes2[id3].edges_in = Object.values(generic_nodes2[id3].edges).reduce((acc, edge) => ({ ...acc, [edge.to]: { ...acc[edge.to] ?? {}, [edge.from]: edge } }), {});
        return generic_nodes2[id3];
      } else if (id3 && !id3.startsWith("_") && Object.keys(data2).length > 0) {
        return Promise.resolve(wrapPromise(updateSyncedGraph(id3, data2)).then((sg) => sg.graph).value);
      }
    };
    const add_nodes_edges = (graphId, nodes, edges, remove_edges, remove_nodes) => {
      if (generic_node_ids.has(graphId))
        return;
      ymap.get(graphId).transact(() => {
        remove_nodes.forEach((node) => ymap.get(graphId).getMap().get("nodes").delete(typeof node === "string" ? node : node.id));
        remove_edges.forEach((edge) => ymap.get(graphId).getMap().get("edges").delete(edge.from));
        nodes.forEach((node) => ymap.get(graphId).getMap().get("nodes").set(node.id, node));
        edges.forEach((edge) => ymap.get(graphId).getMap().get("edges").set(edge.from, edge));
      });
      updateSyncedGraph(graphId);
    };
    const add_node = (graphId, node) => {
      if (generic_node_ids.has(graphId))
        return;
      ymap.get(graphId).transact(() => {
        ymap.get(graphId).getMap().get("nodes").set(node.id, node);
      });
      updateSyncedGraph(graphId);
    };
    const remove_node = (graphId, node) => {
      if (generic_node_ids.has(graphId))
        return;
      ymap.get(graphId).transact(() => {
        ymap.get(graphId).getMap().get("nodes").delete(typeof node === "string" ? node : node.id);
        ymap.get(graphId).getMap().get("edges").delete(typeof node === "string" ? node : node.id);
      });
      updateSyncedGraph(graphId);
    };
    const add_edge = (graphId, edge) => {
      if (generic_nodes2[graphId])
        return;
      ymap.get(graphId).transact(() => {
        ymap.get(graphId).getMap().get("edges").set(edge.from, edge);
      });
      updateSyncedGraph(graphId);
    };
    const remove_edge = (graphId, edge) => {
      ymap.get(graphId).transact(() => {
        ymap.get(graphId).getMap().get("edges").delete(edge.from);
      });
      updateSyncedGraph(graphId);
    };
    if (persist !== void 0) {
      const indexeddbProvider = new IndexeddbPersistence(`${persist}-subdocs`, ydoc);
      await indexeddbProvider.whenSynced;
    }
    const updateSyncedGraph = (id3, graph) => wrapPromise(id3 !== "custom_editor" && id3 !== "keybindings" && rtcroom).then((rtcroom2) => wrapPromise(syncedGraphs.get(id3)).then((existing) => ({ existing, rtcroom: rtcroom2 })).value).then(({ existing, rtcroom: rtcroom2 }) => {
      const syncedGraph = wrapPromise(existing && ymap.has(id3) ? existing : Promise.resolve(existing)).then(() => {
        let preloadDoc = ymap.get(id3);
        if (!existing && !preloadDoc && !graph && !rmap.has(id3)) {
          return { graph: void 0 };
        }
        let unloadedRdoc = false;
        let createdPreload = false;
        if (!preloadDoc) {
          createdPreload = true;
          preloadDoc = new Doc(rmap.has(id3) ? { guid: rmap.get(id3) } : void 0);
          preloadDoc.getMap().set("id", id3);
          if (graph) {
            setMapFromGraph(preloadDoc.getMap(), graph);
          } else {
            unloadedRdoc = true;
          }
          ymap.set(id3, preloadDoc);
        } else if (graph) {
          setMapFromGraph(preloadDoc.getMap(), graph);
        }
        if (rtcroom2 && preloadDoc && !rmap.has(id3)) {
          rmap.set(id3, preloadDoc.guid);
        }
        if (!preloadDoc.isLoaded) {
          preloadDoc.load();
        }
        return (!createdPreload && preloadDoc.isLoaded && existing ? wrapPromise({ localDoc: preloadDoc, idb: void 0 }) : wrapPromise(existing && !unloadedRdoc ? existing : Promise.resolve(existing)).then(() => new IndexeddbPersistence(`${persist}-subdocs-${preloadDoc.guid}`, preloadDoc).whenSynced.then((idb) => {
          if (preloadDoc.getMap().get("nodes") && !createdPreload) {
            preloadDoc.transact(() => {
              const edgeReplaceMap = /* @__PURE__ */ new Map();
              let updateEdges = false;
              const docmap = preloadDoc.getMap();
              const docnodes = docmap.get("nodes");
              docmap.get("edges").forEach((e, key) => {
                let edge = e;
                if (edge.from && edge.to) {
                  updateEdges = true;
                  if (docnodes.has(edge.from) && docnodes.has(edge.to)) {
                    if (!edgeReplaceMap.has(edge.to)) {
                      edgeReplaceMap.set(edge.to, /* @__PURE__ */ new Map());
                    }
                    edgeReplaceMap.get(edge.to).set(edge.as, edge.from);
                  } else if (!docnodes.has(edge.from)) {
                    docnodes.set(edge.from, { id: edge.from });
                  } else if (!docnodes.has(edge.to)) {
                    docnodes.set(edge.to, { id: edge.to });
                  }
                } else if (edge.from || edge.to) {
                } else {
                  e.forEach((as, from3) => {
                    if (!(docnodes.has(key) && docnodes.has(from3))) {
                      throw new Error(`invalid edge ${from3} to ${key} as ${as}`);
                    }
                  });
                }
              });
              if (updateEdges) {
              }
            });
          }
          const undoManager2 = new UndoManager(preloadDoc.getMap());
          getLocalGraphYMap(id3).observeDeep((events) => events.forEach((event) => {
            if (event.transaction.local === false || event.transaction.origin === undoManager2) {
              update(event, id3);
              updateSyncedGraph(id3);
            }
          }));
          return { localDoc: preloadDoc, idb, undoManager: undoManager2 };
        }))).then(({ localDoc, idb, undoManager: undoManager2 }) => {
          if (graph) {
            graph.edges_in = Object.values(graph.edges).reduce((acc, edge) => ({ ...acc, [edge.to]: { ...acc[edge.to] ?? {}, [edge.from]: edge } }), {});
            if (!(existing?.graph && compareObjects(graph, existing.graph))) {
              syncedGraphs.set(id3, { ...existing, graph });
              nolib.no.runtime.publish("graphchange", graph, { ...nolib, ...hlib });
            }
            return syncedGraphs.get(id3);
          } else {
            const graph2 = localDoc.getMap().toJSON();
            if (graph2.nodes) {
              graph2.edges_in = Object.values(graph2.edges).reduce((acc, edge) => ({ ...acc, [edge.to]: { ...acc[edge.to] ?? {}, [edge.from]: edge } }), {});
              nolib.no.runtime.publish("graphchange", graph2, { ...nolib, ...hlib });
            }
            const updatedExisting = syncedGraphs.get(id3);
            return {
              graph: graph2,
              idb: idb ?? existing?.idb,
              undoManager: undoManager2 ?? existing.undoManager,
              remoteProvider: rtcroom2 && (existing?.remoteProvider ?? updatedExisting?.remoteProvider ?? new WebrtcProvider(`nodysseus${rtcroom2}_${localDoc.guid}`, localDoc, {
                signaling: ["wss://ws.nodysseus.io"],
                filterBcConns: true,
                password: void 0,
                awareness: void 0,
                maxConns: void 0,
                peerOpts: {
                  config: {
                    iceServers: [
                      { urls: "stun:ws.nodysseus.io:3478" }
                    ]
                  },
                  wrtc: rtcpolyfill
                }
              }))
            };
          }
        }).then((sg) => {
          syncedGraphs.set(id3, sg);
          return sg;
        }).value;
      }).value;
      if (ispromise(syncedGraph) || syncedGraph.graph) {
        syncedGraphs.set(id3, syncedGraph);
      }
      return syncedGraph;
    }).value;
    let rtcroom = wrapPromise(updateSyncedGraph("custom_editor")).then((sg) => sg.graph).then((custom_editor) => !!custom_editor && hlib.run(custom_editor, custom_editor.out ?? "out")).then((custom_editor_result) => {
      rtcroom = custom_editor_result?.rtcroom || false;
      if (rtcroom) {
        new WebrtcProvider(`nodysseus${rtcroom}_subdocs`, rdoc, {
          signaling: ["wss://ws.nodysseus.io"],
          password: void 0,
          awareness: void 0,
          filterBcConns: true,
          maxConns: void 0,
          peerOpts: {
            config: {
              iceServers: [
                { urls: "stun:ws.nodysseus.io:3478" }
              ]
            },
            wrtc: rtcpolyfill
          }
        });
        rdoc.getMap().observe((evts) => {
          evts.keysChanged.forEach((k) => {
            requestAnimationFrame(() => updateSyncedGraph(k));
          });
        });
      }
      return rtcroom;
    }).value;
    if (update !== void 0) {
      ymap.observeDeep((events) => {
        events.forEach((event) => {
          if (!event.transaction.local || event.transaction.origin === undoManager) {
            update(event);
          }
          for (let k of event.keysChanged) {
            if (event.target.get(k)) {
              updateSyncedGraph(k);
            }
          }
        });
      });
    }
    const get4 = (id3) => {
      if (generic_node_ids.has(id3)) {
        return generic_nodes2[id3];
      }
      return wrapPromise(syncedGraphs.get(id3)).then((syncedGraph) => syncedGraph ?? updateSyncedGraph(id3)).then((syncedGraph) => syncedGraph?.graph).value;
    };
    return {
      get: get4,
      set: set3,
      add_node,
      remove_node,
      add_nodes_edges,
      add_edge,
      remove_edge,
      delete: (id3) => {
        console.log(`removing ${id3}`);
        return wrapPromise(syncedGraphs.get(id3)).then((syncedGraph) => {
          syncedGraph?.idb?.clearData();
          syncedGraphs.delete(id3);
          ymap.get(id3)?.destroy();
          ymap.delete(id3);
          rmap.delete(id3);
        }).value;
      },
      clear: () => {
        throw new Error("Can't remove all refs");
      },
      keys: () => {
        const keys3 = [...ymap.keys(), ...Object.keys(generic_nodes2)];
        return keys3;
      },
      undo: persist && ((id3) => wrapPromise(syncedGraphs.get(id3)).then((syncedGraph) => syncedGraph?.undoManager?.undo())),
      redo: persist && ((id3) => wrapPromise(syncedGraphs.get(id3)).then((syncedGraph) => syncedGraph?.undoManager?.redo()))
    };
  };
  var yNodyStore = async (rtcpolyfill) => {
    const statedb = mapStore();
    let nodysseusidb;
    await openDB("nodysseus", 3, {
      upgrade(db, oldVersion, newVersion) {
        if (oldVersion < 2) {
          db.createObjectStore("assets");
        }
        if (oldVersion < 3) {
          db.createObjectStore("persist");
        }
      }
    }).then((db) => {
      nodysseusidb = db;
    });
    return {
      refs: await ydocStore({
        persist: "refs",
        rtcpolyfill,
        update: (event, id3) => {
          if (!id3 && event.keysChanged.size > 1) {
            return;
          }
          const updatedgraph = id3 ?? event.currentTarget.get("id");
          if (updatedgraph !== void 0) {
            requestAnimationFrame(() => {
              nolib.no.runtime.change_graph(nolib.no.runtime.get_ref(updatedgraph), { ...nolib, ...hlib }, event.transaction.local);
            });
          }
        }
      }),
      parents: mapStore(),
      state: mapStore(),
      fns: mapStore(),
      assets: {
        get: (id3) => nodysseusidb.get("assets", id3),
        set: (id3, blob2) => nodysseusidb.put("assets", blob2, id3),
        delete: (id3) => nodysseusidb.delete("assets", id3),
        clear: () => nodysseusidb.clear("assets"),
        keys: () => nodysseusidb.getAllKeys("assets")
      },
      persist: {
        get: (id3) => nodysseusidb.get("persist", id3),
        set: (id3, str) => nodysseusidb.put("persist", str, id3),
        delete: (id3) => nodysseusidb.delete("persist", id3),
        clear: () => nodysseusidb.clear("persist"),
        keys: () => nodysseusidb.getAllKeys("persist")
      }
    };
  };

  // node_modules/worker-webrtc/src/utils/id.js
  var id_default = () => Date.now() + parseInt(Math.random() * 1e6);

  // node_modules/worker-webrtc/src/utils/rpc.js
  var n = 0;
  var promises = {};
  function onmessage(event, wrtc2) {
    if (!(event.data && event.data.command && event.data.command === "RPC_CALLBACK"))
      return;
    event.stopImmediatePropagation();
    const { success, msg, rpcId } = event.data;
    const value = deserialize([msg], wrtc2)[0];
    const { res, rej } = promises[rpcId];
    delete promises[rpcId];
    if (success)
      res(value);
    else
      rej(value);
  }
  function send({ msg, id: id3, command: command2 }, scope) {
    return new Promise((res, rej) => {
      const rpcId = n++;
      promises[rpcId] = { res, rej };
      scope.postMessage({ command: command2, id: id3, rpcId, msg });
    });
  }
  function respond({ rpcId, success, msg, scope }) {
    scope.postMessage({
      command: "RPC_CALLBACK",
      msg,
      success,
      rpcId
    });
  }

  // node_modules/worker-webrtc/src/utils/is.js
  function string2(obj) {
    return typeof obj === "string";
  }
  function object(obj) {
    return typeof obj === "object";
  }
  function array(arr) {
    return Array.isArray(arr);
  }
  function blob(val) {
    return val instanceof Blob;
  }
  function arrayBuffer(val) {
    return val instanceof ArrayBuffer;
  }
  function arrayBufferView(val) {
    return ArrayBuffer.isView(val);
  }

  // node_modules/worker-webrtc/src/utils/com.js
  var references = {};
  var port;
  function addReference(obj, scope = port, id3 = id_default()) {
    obj._id = id3;
    references[id3] = { scope, obj };
  }
  function getRefFromId(id3) {
    const ref = references[id3];
    if (!ref)
      throw new Error("Reference not found");
    return ref;
  }
  function getObjFromId(id3) {
    return getRefFromId(id3).obj;
  }
  function getRefId(obj) {
    return obj._id;
  }
  function getRef(obj) {
    return getRefFromId(getRefId(obj));
  }
  function set2(obj, msg) {
    return post({
      command: "SET",
      msg,
      obj
    });
  }
  function construct(obj, msg) {
    return post({
      command: "CONSTRUCT",
      msg,
      obj
    });
  }
  function post({ obj, msg, command: command2 }) {
    const id3 = getRefId(obj);
    const { scope } = getRef(obj);
    return send({ id: id3, msg, command: command2 }, scope);
  }
  function call(obj, msg) {
    if (string2(obj)) {
      return send({ id: obj, msg, command: "CALL" }, port);
    }
    return post({ obj, msg, command: "CALL" });
  }
  function serialize(cls, ...args2) {
    const [, name2] = cls.toString().match(/\[object (.*)\]/) || [, cls.constructor.name];
    return {
      _type: name2,
      args: args2
    };
  }
  function deserialize(obj, wrtc2) {
    for (const key in obj) {
      const item = obj[key];
      if (item && object(item)) {
        if ("_type" in item) {
          const cls = wrtc2[item._type] || self[item._type];
          const args2 = deserialize(item.args, wrtc2);
          obj[key] = new cls(...args2);
        } else {
          obj[key] = deserialize(item, wrtc2);
        }
      }
    }
    return obj;
  }
  var functions = {
    CONSTRUCT(msg, id3, scope, wrtc2) {
      const obj = new wrtc2[msg.name](...deserialize(msg.args, wrtc2));
      addReference(obj, scope, id3);
    },
    CALL(data2, id3, scope, wrtc2) {
      const obj = string2(id3) ? wrtc2[id3] : getObjFromId(id3);
      const args2 = deserialize(data2.args, wrtc2);
      if (string2(id3)) {
        args2.push(scope);
      }
      if (typeof obj[data2.name] === "function") {
        return obj[data2.name](...args2);
      }
    },
    SET(data2, id3, scope, wrtc2) {
      const { obj } = references[id3];
      for (const key in deserialize(data2)) {
        obj[key] = data2[key];
      }
    }
  };
  function resolveFunction(func) {
    try {
      return Promise.resolve(func());
    } catch (error) {
      return Promise.reject(error);
    }
  }
  function addListener(scope, wrtc2) {
    scope.addEventListener("message", (event) => {
      if (!(event.data && event.data.command && event.data.command in functions)) {
        onmessage(event, wrtc2);
        return;
      }
      event.stopImmediatePropagation();
      const { rpcId, command: command2, msg, id: id3 } = event.data;
      resolveFunction(
        () => functions[command2](msg, id3, scope, wrtc2)
      ).then((msg2) => {
        respond({
          success: true,
          rpcId,
          msg: msg2,
          scope
        });
      }, (error) => {
        respond({
          success: false,
          msg: serialize(error, error.message),
          rpcId,
          scope
        });
      });
    });
  }

  // node_modules/worker-webrtc/src/utils/utils.js
  function getSize(obj) {
    if (!obj)
      return 0;
    if (string2(obj) || array(obj))
      return obj.length;
    if (blob(obj))
      return obj.size;
    if (arrayBuffer(obj) || arrayBufferView(obj))
      return obj.byteLength;
    return 0;
  }

  // node_modules/worker-webrtc/src/window/proxyRTCDataChannel.js
  var proxyRTCDataChannel_default = (datachannel) => {
    const { send: send2 } = datachannel;
    Object.assign(datachannel, {
      onbufferedamountlow(event) {
        set2(this, {
          bufferedAmount: this.bufferedAmount
        });
        call(this, {
          name: "dispatchEvent",
          args: [serialize(event, event.type)]
        });
      },
      onclose(event) {
        set2(this, {
          readyState: this.readyState
        });
        call(this, {
          name: "dispatchEvent",
          args: [serialize(event, event.type)]
        });
      },
      onerror(event) {
        call(this, {
          name: "dispatchEvent",
          args: [serialize(event, event.type, {
            message: event.message,
            filename: event.filename,
            lineno: event.lineno,
            colno: event.colno,
            error: serialize(event.error, event.error.message)
          })]
        });
      },
      onmessage(event) {
        call(this, {
          name: "dispatchEvent",
          args: [serialize(event, event.type, {
            data: event.data
          })]
        });
      },
      onopen(event) {
        set2(this, {
          readyState: this.readyState
        });
        call(this, {
          name: "dispatchEvent",
          args: [serialize(event, event.type)]
        });
      },
      send(data2) {
        const { bufferedAmount } = this;
        send2.call(this, data2);
        set2(this, {
          bufferedAmount: this.bufferedAmount
        });
        if (this.bufferedAmount <= this.bufferedAmountLowThreshold && bufferedAmount + getSize(data2) > this.bufferedAmountLowThreshold) {
          const event = new Event("bufferedamountlow");
          call(this, {
            name: "dispatchEvent",
            args: [serialize(event, event.type)]
          });
        }
      }
    });
    set2(datachannel, {
      label: datachannel.label,
      ordered: datachannel.ordered,
      macPacketLifeTime: datachannel.maxPacketLifeTime,
      maxRetransmits: datachannel.maxRetransmits,
      protocol: datachannel.protocol,
      negotiated: datachannel.negotiated,
      id: datachannel.id,
      binaryType: datachannel.binaryType,
      bufferedAmount: datachannel.bufferedAmount,
      bufferedAmountLowThreshold: datachannel.bufferedAmountLowThreshold,
      maxRetransmitTime: datachannel.maxRetransmitTime,
      readyState: datachannel.readyState,
      reliable: datachannel.reliable
    });
  };

  // node_modules/worker-webrtc/src/window/RTCPeerConnectionProxy.js
  function getCertificates(config2) {
    if (config2 && Array.isArray(config2.certificates)) {
      config2.certificates = config2.certificates.map((id3) => getObjFromId(id3));
    }
  }
  var RTCPeerConnectionProxy = class extends RTCPeerConnection {
    constructor(config2) {
      getCertificates(config2);
      super(config2);
      this.__proto__ = RTCPeerConnectionProxy.prototype;
      const self2 = this;
      Object.assign(this, {
        onconnectionstatechange(event) {
          call(self2, {
            name: "dispatchEvent",
            args: [serialize(event, event.type, {
              connectionState: event.connectionState
            })]
          });
        },
        ondatachannel(event) {
          const { channel } = event;
          const { scope } = getRef(self2);
          addReference(channel, scope);
          construct(channel, {
            name: "RTCDataChannel",
            args: [event.channel.label, {}]
          });
          proxyRTCDataChannel_default(channel);
          call(self2, {
            name: "_ondatachannel",
            args: [getRefId(channel)]
          });
        },
        onicecandidate(event) {
          call(self2, {
            name: "dispatchEvent",
            args: [serialize(event, event.type, {
              candidate: event.candidate ? serialize(event.candidate, event.candidate.toJSON()) : event.candidate
            })]
          });
        },
        oniceconnectionstatechange(event) {
          set2(self2, {
            iceConnectionState: self2.iceConnectionState,
            iceGatheringState: self2.iceGatheringState
          });
          call(self2, {
            name: "dispatchEvent",
            args: [serialize(event, event.type)]
          });
        },
        onicegatheringstatechange(event) {
          call(self2, {
            name: "dispatchEvent",
            args: [serialize(event, event.type)]
          });
        },
        onnegotiationneeded(event) {
          call(self2, {
            name: "dispatchEvent",
            args: [serialize(event, event.type)]
          });
        },
        onremovestream(event) {
          call(self2, {
            name: "dispatchEvent",
            args: [serialize(event, event.type)]
          });
        },
        onsignalingstatechange(event) {
          set2(self2, {
            signalingState: self2.signalingState
          });
          call(self2, {
            name: "dispatchEvent",
            args: [serialize(event, event.type)]
          });
        }
      });
      setTimeout(() => {
        self2._setConfiguration();
        set2(this, {
          canTrickleIceCandidates: this.canTrickleIceCandidates,
          connectionState: this.connectionState,
          defaultIceServers: this.defaultIceServers,
          iceConnectionState: this.iceConnectionState,
          iceGatheringState: this.iceGatheringState,
          signalingState: this.signalingState
        });
      });
    }
    createDataChannel(id3, ...args2) {
      const { scope } = getRef(this);
      const channel = super.createDataChannel(...args2);
      addReference(channel, scope, id3);
      proxyRTCDataChannel_default(channel);
    }
    createOffer(...args2) {
      return super.createOffer(...args2).then((desc) => {
        if (desc && desc.toJSON)
          return desc.toJSON();
        return desc;
      });
    }
    createAnswer(...args2) {
      return super.createAnswer(...args2).then((desc) => {
        if (desc && desc.toJSON)
          return desc.toJSON();
        return desc;
      });
    }
    getStats() {
      return super.getStats().then((stats) => {
        const { scope } = getRef(this);
        addReference(stats, scope);
        construct(stats, {
          name: "RTCStatsReport",
          args: [Array.from(stats)]
        });
        return getRefId(stats);
      });
    }
    setLocalDescription(...args2) {
      return super.setLocalDescription(...args2);
    }
    setRemoteDescription(...args2) {
      return super.setRemoteDescription(...args2);
    }
    setConfiguration(config2) {
      getCertificates(config2);
      super.setConfiguration(config2);
      this._setConfiguration();
    }
    _setConfiguration() {
      if ("getConfiguration" in this) {
        set2(this, {
          _config: this.getConfiguration()
        });
      }
    }
    static generateCertificate(algo, scope) {
      return RTCPeerConnection.generateCertificate(algo).then((cert) => {
        addReference(cert, scope);
        construct(cert, {
          name: "RTCCertificate",
          args: [cert.expires]
        });
        return getRefId(cert);
      });
    }
  };

  // node_modules/worker-webrtc/window.js
  var wrtc = {
    RTCPeerConnection: RTCPeerConnectionProxy,
    RTCSessionDescription,
    RTCIceCandidate
  };
  function polyfillWorker(worker) {
    const isShared = "SharedWorker" in self && worker instanceof SharedWorker;
    const port2 = isShared ? worker.port : worker;
    addListener(port2, wrtc);
    if (isShared)
      port2.start();
  }

  // src/editor/editor.ts
  customElements.define("autocomplete-list", AutocompleteList);
  var SimulationToHyperapp = (state, payload) => [
    {
      ...state,
      levels: calculateLevels(payload.nodes, payload.links, state.editingGraph, state.selected),
      nodes: payload.nodes,
      links: payload.links,
      randid: create_randid()
    },
    [CustomDOMEvent, { html_id: state.html_id, event: "updategraph", detail: { graph: state.editingGraph } }]
  ];
  var Search = (state, { payload, nodes }) => {
    if (payload.key === "Escape") {
      return [{ ...state, search: false, search_index: 0 }, [(dispatch2) => payload.target.value = ""]];
    }
    const direction = payload.key === "Enter" ? payload.shiftKey ? -1 : 1 : 0;
    const search_results = new Fuse(
      nodes.map((n2) => Object.assign(
        {},
        n2,
        nolib.no.runtime.get_node(state.editingGraph, n2.node_id),
        nolib.no.runtime.get_edge_out(state.editingGraph, n2.node_id)
      )),
      { keys: ["name", "ref", "value", "as"] }
    ).search(payload.target.value);
    const search_index = search_results.length > 0 ? (search_results.length + (state.search_index ?? 0) + direction) % search_results.length : 0;
    return [
      {
        ...state,
        search: payload.target.value,
        search_index
      },
      search_results.length > 0 && [(dispatch2) => requestAnimationFrame(() => dispatch2(SelectNode, { node_id: search_results[search_index].item.id }))]
    ];
  };
  var search_el = ({ search: search2 }) => h("div", { id: "search" }, [
    typeof search2 === "string" && h("input", { type: "text", onkeydown: (state, payload) => [Search, { payload, nodes: state.nodes }], onblur: (state, payload) => [{ ...state, search: false }] }, []),
    typeof search2 !== "string" && h("span", { class: "material-icons-outlined graph-action", onclick: (s) => [{ ...s, search: "" }, [FocusEffect, { selector: "#search input" }]] }, [text("search")])
  ]);
  var show_error = (e, t2) => ({
    dom_type: "div",
    props: {},
    children: (Array.isArray(e) ? e : [e]).flatMap((e2) => [
      { dom_type: "text_value", text: `Error: ${e2.message}` },
      { dom_type: "pre", props: {}, children: [{ dom_type: "text_value", text: e2.stack }] },
      t2 && { dom_type: "pre", props: {}, children: [{ dom_type: "text_value", text: t2 }] }
    ].filter((c2) => c2))
  });
  var result_display = (html_id) => app({
    init: { el: { dom_type: "div", props: {}, children: [] } },
    node: document.getElementById(html_id + "-result"),
    dispatch: middleware,
    view: (s) => {
      try {
        return run_h({ dom_type: "div", props: { id: `${html_id}-result` }, children: [s.el] });
      } catch (e) {
        try {
          return run_h({ dom_type: "div", props: { id: `${html_id}-result` }, children: [show_error(e, JSON.stringify(s.el))] });
        } catch (e2) {
          return run_h({ dom_type: "div", props: { id: `${html_id}-result` }, children: [{ dom_type: "text_value", text: "Could not show error" }] });
        }
      }
    }
  });
  var custom_editor_display = (html_id) => app({
    init: { el: { dom_type: "div", props: {}, children: [] } },
    node: document.getElementById(html_id + "-custom-editor-display"),
    dispatch: middleware,
    view: (s) => {
      return run_h(s.el, ["script"]);
    }
  });
  var refresh_custom_editor = () => {
    if (nolib.no.runtime.get_ref("custom_editor")) {
      const graph = nolib.no.runtime.get_ref("custom_editor");
      wrapPromise(graph).then((graph2) => hlib.run(graph2, graph2.out, { _output: "display" })).then((result) => custom_editor_display_dispatch(() => ({ el: result })));
    } else {
      custom_editor_display_dispatch(() => ({ el: { dom_type: "div", props: {}, children: [] } }));
    }
    custom_editor_display_dispatch(() => ({ el: { dom_type: "div", props: {}, children: [] } }));
  };
  var defs = () => h("defs", {}, [
    h("filter", { id: "flood-background", width: 1.2, height: 1.1, x: 0, y: 0 }, [
      h("feFlood", { floodColor: "#000a" }),
      h("feComposite", { in: "SourceGraphic", operator: "over" })
    ]),
    h("marker", { id: "arrow", refX: 8, refY: 4, markerWidth: 8, markerHeight: 8, markerUnits: "userSpaceOnUse", orient: "auto" }, [
      h("polyline", { points: "1 1, 8 4, 1 8" })
    ])
  ]);
  var result_display_dispatch;
  var info_display_dispatch;
  var custom_editor_display_dispatch;
  var mutationObserverSubscription = (dispatch2, { id: id3 }) => {
    const el = document.getElementById(id3);
    const mutobs = new MutationObserver((obs) => requestAnimationFrame(() => obs.forEach((mutrec) => mutrec.addedNodes.forEach((added) => {
      const publishel = (addedel) => {
        if (addedel instanceof HTMLElement) {
          if (addedel.id) {
            nolib.no.runtime.publish("domnodeadded", { id: addedel.id });
          }
          for (let child of addedel.children) {
            publishel(child);
          }
        }
      };
      publishel(el);
    }))));
    mutobs.observe(el, { childList: true, subtree: true });
    return () => (console.log("disconnect"), mutobs).disconnect();
  };
  var error_nodes = (error) => error instanceof AggregateError || Array.isArray(error) || error?.errors ? (Array.isArray(error) ? error : error.errors).map((e) => isNodysseusError(e) ? e.node_id : false).filter((n2) => n2) : isNodysseusError(error) ? [error.node_id] : [];
  var runapp = (init2, load_graph, _lib) => {
    return app({
      init: [
        init2,
        [(dispatch2) => requestAnimationFrame(() => {
          result_display_dispatch = result_display(init2.html_id);
          info_display_dispatch = info_display(init2.html_id);
          custom_editor_display_dispatch = custom_editor_display(init2.html_id);
          dispatch2((s) => [
            { ...s, result_display_dispatch, info_display_dispatch, custom_editor_display_dispatch },
            [() => {
              requestAnimationFrame(() => {
                refresh_custom_editor();
                nolib.no.runtime.change_graph(base_graph(init2.editingGraph), hlib);
              });
            }]
          ]);
        })],
        [(dispatch2) => wrapPromise(nolib.no.runtime.get_graph("custom_editor")).then((graph) => graph && hlib.run(graph, "out")).then((custom_editor_result) => custom_editor_result && dispatch2((s) => ({ ...s, custom_editor_result })))],
        [ChangeEditingGraphId, { id: load_graph, select_out: true, editingGraphId: void 0 }],
        [UpdateSimulation, { ...init2, action: SimulationToHyperapp }],
        [init_code_editor, { html_id: init2.html_id }]
      ],
      dispatch: middleware,
      view: (s) => h("div", { id: s.html_id }, [
        h("svg", { id: `${s.html_id}-editor`, width: s.dimensions.x, height: s.dimensions.y }, [
          h(
            "g",
            { id: `${s.html_id}-editor-panzoom` },
            [memo(defs, {})].concat(
              s.nodes?.map((node) => {
                const newnode = Object.assign({}, node, s.editingGraph.nodes[node.node_id]);
                return memo(node_el, {
                  html_id: s.html_id,
                  selected: s.selected[0] === node.node_id,
                  error: !!error_nodes(s.error).find((e) => e && e.startsWith(s.editingGraph.id + "/" + node.node_id)),
                  selected_distance: s.show_all || !s.levels ? 0 : s.levels.distance_from_selected.get(node.node_id) > 3 ? "far" : s.levels.distance_from_selected.get(node.node_id),
                  node_id: node.node_id,
                  node_name: newnode.name,
                  node_ref: isNodeRef(newnode) ? newnode.ref : void 0,
                  node_value: isNodeValue(newnode) ? newnode.value : void 0,
                  has_nodes: isNodeGraph(newnode) ? newnode.nodes : void 0,
                  nested_edge_count: newnode.nested_edge_count,
                  nested_node_count: newnode.nested_node_count
                });
              }) ?? []
            ).concat(
              s.links?.map((link) => memo(link_el, {
                link: Object.assign({}, link, s.editingGraph.edges[link.source.node_id]),
                selected_distance: s.show_all || !s.levels ? 0 : s.levels.distance_from_selected.get(link.source.node_id) > 3 ? "far" : s.levels.distance_from_selected.get(link.source.node_id)
              })) ?? []
            ).concat(
              s.links?.filter((link) => link.source.node_id == s.selected[0] || link.target.node_id === s.selected[0]).map((link) => insert_node_el({ link, randid: s.randid, node_el_width: s.node_el_width }))
            )
          )
        ]),
        infoWindow({
          node: Object.assign({}, s.nodes.find((n2) => n2.node_id === s.selected[0]), s.editingGraph.nodes[s.selected[0]]),
          hidden: s.show_all,
          edges_in: s.selected_edges_in,
          link_out: Object.assign({}, s.links.find((l) => l.source.node_id === s.selected[0]), s.editingGraph.edges[s.selected[0]]),
          editingGraphId: s.editingGraph.id,
          randid: s.randid,
          editing: s.editing,
          ref_graphs: nolib.no.runtime.ref_graphs(),
          html_id: s.html_id,
          copied_graph: s.copied?.graph,
          inputs: s.inputs,
          graph_out: s.editingGraph.out
        }),
        h("div", { id: `${init2.html_id}-custom-editor-display` }),
        h("div", { id: "graph-actions" }, [
          search_el({ search: s.search }),
          h("span", {
            class: "material-icons-outlined graph-action",
            style: {
              transformOrigin: "center",
              transform: `rotate(${s.displayGraphId ? "0" : "45"}deg)`
            },
            onclick: (s2) => ({
              ...s2,
              displayGraph: s2.displayGraph ? false : s2.editingGraph,
              displayGraphId: s2.displayGraphId ? false : s2.editingGraphId
            })
          }, [text("push_pin")]),
          h("span", {
            class: "material-icons-outlined graph-action",
            onclick: (s2) => [
              { ...s2, norun: !s2.norun },
              () => {
                nolib.no.runtime.togglePause(!s2.norun);
              },
              s2.norun && [refresh_graph, {
                graph: s2.displayGraph ?? s2.editingGraph,
                norun: !s2.norun,
                graphChanged: false,
                result_display_dispatch: s2.result_display_dispatch,
                info_display_dispatch: s2.info_display_dispatch,
                code_editor: s2.code_editor,
                code_editor_nodeid: s2.code_editor_nodeid
              }]
            ]
          }, [text(s.norun ? "play_arrow" : "pause")]),
          h("span", {
            class: "material-icons-outlined graph-action",
            name: "sync-outline",
            onclick: (s2) => [s2, [(dispatch2) => {
              nolib.no.runtime.delete_cache();
              hlib.run(s2.editingGraph, s2.editingGraph.out ?? "out", { _output: "value" }, { profile: false });
              refresh_custom_editor();
              requestAnimationFrame(() => dispatch2((s3) => [s3, [() => {
                s3.simulation.alpha(1);
                s3.simulation.nodes([]);
              }, {}], [UpdateSimulation, {}]]));
            }, {}]]
          }, [text("refresh")])
        ]),
        h("div", { id: `${init2.html_id}-result` }),
        s.error && h("div", { id: "node-editor-error" }, run_h(show_error(s.error, s.error.node_id)))
      ]),
      node: document.getElementById(init2.html_id),
      subscriptions: (s) => [
        document.getElementById(`${init2.html_id}-result`) && [mutationObserverSubscription, { id: `${init2.html_id}-result` }],
        [d3subscription, { action: SimulationToHyperapp, update: UpdateSimulation }],
        [graph_subscription, { editingGraphId: s.editingGraphId, norun: s.norun }],
        [select_node_subscription, {}],
        result_display_dispatch && [result_subscription, { editingGraphId: s.editingGraphId, displayGraphId: s.displayGraphId, norun: s.norun }],
        listen("hashchange", (state, evt) => state.editingGraphId === evt.newURL.substring(evt.newURL.indexOf("#") + 1) || evt.newURL.substring(evt.newURL.indexOf("#") + 1).length === 0 ? state : [state, [ChangeEditingGraphId, { id: evt.newURL.substring(evt.newURL.indexOf("#") + 1), editingGraphId: state.editingGraphId }]]),
        [keydownSubscription, { action: (state, payload) => {
          if (document.getElementById("node-editor-result").contains(payload.target)) {
            return [state];
          }
          const mode = state.editing !== false ? "editing" : state.search !== false ? "searching" : "graph";
          const key_input = (payload.ctrlKey ? "ctrl_" : "") + (payload.shiftKey ? "shift_" : "") + (payload.key === "?" ? "questionmark" : payload.key.toLowerCase());
          let action;
          let effects = [];
          const selected = state.selected[0];
          switch (`${mode}_${key_input}`) {
            case "editing_ctrl_o":
            case "searching_ctrl_o":
            case "graph_ctrl_o": {
              action = [SelectNode, { node_id: state.editingGraph.out, focus_property: "name" }];
              payload.stopPropagation();
              payload.preventDefault();
              break;
            }
            case "graph_arrowup": {
              const parent_edges = nolib.no.runtime.get_edges_in(state.editingGraph, selected);
              const node_id = parent_edges?.[Math.ceil(parent_edges.length / 2) - 1]?.from;
              action = node_id ? [SelectNode, { node_id }] : [state];
              break;
            }
            case "graph_arrowdown": {
              const child_edge = Object.values(state.editingGraph.edges).find((e) => e.from === selected);
              const node_id = child_edge?.to;
              action = node_id ? [SelectNode, { node_id }] : [state];
              break;
            }
            case "graph_arrowleft":
            case "graph_arrowright": {
              const dirmult = key_input === "arrowleft" ? 1 : -1;
              const current_node = nolib.no.runtime.get_node(state.editingGraph, selected);
              if (state.levels) {
                const siblings = state.levels.siblings.get(selected);
                const node_id = siblings.reduce((dist, sibling) => {
                  const sibling_node = state.nodes.find((n2) => n2.node_id === sibling);
                  if (!sibling_node) {
                    return dist;
                  }
                  const xdist = Math.abs(sibling_node.x - current_node.x);
                  dist = dirmult * (sibling_node.x - current_node.x) < 0 && xdist < dist[0] ? [xdist, sibling_node] : dist;
                  return dist;
                }, [state.dimensions.x, void 0])?.[1]?.node_id;
                action = node_id ? [SelectNode, { node_id }] : [state];
              }
              break;
            }
            case "graph_ctrl_s": {
              effects.push([SaveGraph, state]);
              break;
            }
            case "graph_ctrl_c": {
              action = [Copy, { as: nolib.no.runtime.get_edge_out(state.editingGraph, state.selected[0]).as }];
              break;
            }
            case "graph_ctrl_v": {
              action = [Paste];
              break;
            }
            case "graph_f": {
              action = (s2) => [{ ...s2, search: "" }, [FocusEffect, { selector: "#search input" }]];
              break;
            }
            case "graph_shift_enter": {
              action = [ExpandContract, { node_id: state.selected[0] }];
              break;
            }
            case "graph_x": {
              action = [DeleteNode, {
                node_id: state.selected[0]
              }];
              break;
            }
            case "graph_n": {
              action = [SelectNode, { node_id: state.selected[0], focus_property: "name" }];
              break;
            }
            case "graph_v": {
              action = [SelectNode, { node_id: state.selected[0], focus_property: "value" }];
              break;
            }
            case "graph_r": {
              action = [SelectNode, { node_id: state.selected[0], focus_property: "ref" }];
              break;
            }
            case "graph_e": {
              action = [SelectNode, { node_id: state.selected[0], focus_property: "edge" }];
              break;
            }
            case "graph_esc": {
              action = [(state2) => [
                { ...state2, show_all: true, focused: false, editing: false },
                [() => requestAnimationFrame(() => nolib.no.runtime.publish("show_all", { data: true }))]
              ]];
              break;
            }
            case "graph_ctrl_z": {
              const child_edge = Object.values(state.editingGraph.edges).find((e) => e.from === selected);
              const node_id = child_edge?.to;
              nolib.no.runtime.undo(state.editingGraphId);
              effects.push((dispatch2) => requestAnimationFrame(() => dispatch2((s2) => {
                return { ...s2, selected: nolib.no.runtime.get_ref(state.editingGraphId).nodes[s2.selected[0]] ? s2.selected : [node_id] };
              })));
              break;
            }
            case "graph_ctrl_y": {
              const child_edge = Object.values(state.editingGraph.edges).find((e) => e.from === selected);
              const node_id = child_edge?.to;
              nolib.no.runtime.redo(state.editingGraphId);
              effects.push((dispatch2) => requestAnimationFrame(() => dispatch2((s2) => {
                return { ...s2, selected: nolib.no.runtime.get_ref(state.editingGraphId).nodes[s2.selected[0]] ? s2.selected : [node_id] };
              })));
              break;
            }
            default: {
              nolib.no.runtime.publish("keydown", { data: key_input });
            }
          }
          return action ? action : [state, ...effects];
        } }],
        listen("resize", (s2) => [
          {
            ...s2,
            dimensions: { x: document.getElementById(init2.html_id).clientWidth, y: document.getElementById(init2.html_id).clientHeight }
          },
          false
        ]),
        !!document.getElementById(`${init2.html_id}-editor-panzoom`) && [pzobj.init, {
          id: `${init2.html_id}-editor-panzoom`,
          action: (s2, p) => [
            {
              ...s2,
              show_all: p.event !== "effect_transform",
              editing: p.event === "effect_transform" && s2.editing,
              focused: p.event === "effect_transform" && s2.focused,
              noautozoom: p.noautozoom && !s2.stopped
            },
            [() => requestAnimationFrame(() => nolib.no.runtime.publish("show_all", { data: p.event !== "effect_transform" }))]
          ]
        }]
      ]
    });
  };
  var editor = async function(html_id, editingGraph, lib, norun) {
    let nodysseusStore = await yNodyStore();
    let worker;
    initStore(nodysseusStore);
    hlib.worker = () => {
      if (!worker) {
        worker = new Worker("./worker.js", { type: "module" });
        polyfillWorker(worker);
      }
      return worker;
    };
    const simple = generic_default.nodes["simple"];
    simple.edges_in = Object.values(simple.edges).reduce((acc, edge) => ({ ...acc, [edge.to]: { ...acc[edge.to] ?? {}, [edge.from]: edge } }), {});
    const url_params = new URLSearchParams(document.location.search);
    const graph_list = JSON.parse(localStorage.getItem("graph_list")) ?? [];
    const hash_graph = window.location.hash.substring(1);
    const keybindings = await resfetch("json/keybindings.json").then((r) => typeof r === "string" ? JSON.parse(r) : r.json()).then((kb) => (nolib.no.runtime.add_ref(kb), kb));
    const init2 = {
      keybindings,
      editingGraphId: "simple",
      editingGraph: simple,
      displayGraph: false,
      displayGraphId: false,
      hash: window.location.hash ?? "",
      url_params,
      html_id,
      dimensions: {
        x: document.getElementById(html_id).clientWidth,
        y: document.getElementById(html_id).clientHeight
      },
      readonly: false,
      norun: norun || url_params.get("norun") !== null,
      hide_types: false,
      offset: { x: 0, y: 0 },
      nodes: [],
      links: [],
      focused: false,
      editing: false,
      search: false,
      show_all: false,
      show_result: false,
      node_el_width: 256,
      args_display: false,
      selected: ["out"],
      selected_edges_in: [],
      levels: false,
      error: false,
      inputs: {},
      randid: create_randid(),
      custom_editor_result: {}
    };
    runapp(init2, hash_graph && hash_graph !== "" ? hash_graph : graph_list?.[0] ?? "simple", lib);
  };

  // src/index.js
  if ("serviceWorker" in navigator) {
    console.log("installing serviceworker");
    navigator.serviceWorker.register("./sw.js");
  }
  editor("node-editor");
})();
/*!
* The buffer module from node.js, for the browser.
*
* @author   Feross Aboukhadijeh <https://feross.org>
* @license  MIT
*/
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
