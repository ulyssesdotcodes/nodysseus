{
  "nodes": {
    "in": {
      "script": "return input",
      "x": 524.0759770715283,
      "y": -1052.2298725113762
    },
    "onload_diff_empty": {
      "type": "diff_changes",
      "x": -584.2461002811915,
      "y": -69.85353381138827
    },
    "graph_stringify": {
      "type": "stringify",
      "script": "return JSON.stringify(lib.R.omit(['_saveignore'], input.state_graph))",
      "x": 127.34705165549786,
      "y": 574.0438574678276
    },
    "load_graph": {
      "description": "If there's a graph in localstorage, load it and pass the result through to out. If this has already passed through 'out' then just run it",
      "script": "if(input.graph._saveignore?.rerun){ \n  console.log('rerunning'); \n  return {run: input.graph}; \n} \nconst loaded = localStorage.getItem('graph'); \nif(!loaded){ console.log('not loaded'); return {run: input.graph}; } \ntry { \n  console.log('parsing');\n  return {out: JSON.parse(loaded)}; \n} catch(err){ console.error(err); return input.graph; }",
      "x": 555.5623997235942,
      "y": -830.2505928143116
    },
    "load_graph_run": {
      "script": "if(input.last_updated[0] === 'run'){ return input.run }",
      "x": 49.295289675375045,
      "y": -612.7682379212958
    },
    "load_graph_out": {
      "script": "if(input.last_updated[0] === 'out'){ return input.out }",
      "x": 2068.4850081553604,
      "y": -287.1098020661749
    },
    "graph_style_tag": {
      "type": "script",
      "script": "return {create: () => lib.html`#graph { display:flex; flex-direction: row; flex-grow: 2; justify-content: flex-start; align-content: stretch; background-color: #080804 } #graph .node { user-select: none } .tooltip { position: absolute; visibility: hidden; max-width: 120px; pointer-events: none;  }`}",
      "x": 1402.547169064167,
      "y": 144.25409217819163
    },
    "render_graph_style": {
      "type": "render_html",
      "nodes": {
        "target": "document.getElementById('graph_style')"
      },
      "x": 1333.2770392296218,
      "y": 411.8886847207518
    },
    "render_head": {
      "type": "render",
      "nodes": {
        "target": "document.head"
      },
      "x": -581.097458015985,
      "y": 144.25418826712803
    },
    "render_graph": {
      "type": "render",
      "nodes": {
        "target": "document.querySelector('#graph')"
      },
      "x": -562.2056044247454,
      "y": 830.6581540376965
    },
    "create_svg_base": {
      "type": "script",
      "script": "let svg = lib.SVG('.root');\n\nif(!svg){\n  svg = lib.SVG().addTo('#graph')\n    .addClass('root')\n    .viewbox(\n      -window.screen.width / 4, \n      -window.screen.height / 2, \n      window.screen.width / 4, \n      window.screen.height / 2\n    ).panZoom({oneFingerPan: true})\n}\n\nreturn svg; ",
      "x": 772.3429435633877,
      "y": 739.2783888472244
    },
    "create_node": {
      "type": "script",
      "script": "if(input.last_updated[0] == \"create_node\") {\n  return;\n}\n\nconst base = lib.SVG('.root'); \n\nconst id = input.last_updated[0] === \"selected_node\" ? input.selected_node.id : input.id;\nconst next_state = \n  Object.assign(\n    {id}, \n    input.create_node && input.create_node[id] ? input.create_node[id] : {},\n    lib.R.pick(input.last_updated, input),\n    {\n      selected: input.selected_node.id === id,\n      dragging: input.dragging && input.selected_node.id === id\n    }\n  );\n\nif(input.create_node && lib.R.equals(next_state, input.create_node[id])){\n  return;\n}\nconst runState = (state) => {\nconst rsmall=16;\nconst rbig = 20;\nconst r = state.dragging? rbig : rsmall;\n\nconst svg = (base.findOne(`#${state.id}`) ??  base.nested().attr({id: state.id, class: 'node'})).size(256, 48);\nconst text = (svg.findOne(`.name`) ?? svg.text(state.id).addClass('name'))\n  .x(r*2+8)\n  .cy(rbig+2)\n  .font({'family': 'Victor Mono, monospace', 'weight': 'bold'})\n  .fill('#D9EBFF');\nconst circle = (svg.findOne(`.circle`) ?? svg.circle(30).addClass('circle').fill({'opacity': 0}))\n  .radius(r)\n  .move(2,2)\n  .stroke({'width': 2, 'color': state.selected ? '#CE9162' : '#D9EBFF'});\n\nsvg.move(state.x - rbig, state.y - rbig);\n\nreturn lib.R.assoc('_selected_node', input.selected_node?.id, lib.R.assoc(state.id, state, input.create_node??{}));\n\n}\n\nreturn runState(next_state);",
      "x": 642.2657224468053,
      "y": -528.2011909741734
    },
    "hover_node": {
      "type": "script",
      "script": "const base = lib.SVG('.root');\nif(input.last_updated[0] !== 'target' || !base) {return;} \n\nif(input.graph.nodes[input.hover_node?.target]){ lib.SVG(`#${input.hover_node.target}`).fill('#000');}\n\nif(input.graph.nodes[input.target]){\n  lib.SVG(`#${input.target}`).fill('#6EB4D1');\n}\n\nreturn {target: input.target}",
      "x": 596.4947731935139,
      "y": 657.4828774958021
    },
    "create_line": {
      "type": "script",
      "script": "if(input.last_updated[0] == \"create_line\" || !input.edge) {\n  return;\n}\n\nconst base = lib.SVG('.root'); \n\nif(!(base && input.graph.nodes[input.edge.from].x \n     && input.graph.nodes[input.edge.from].y \n     && input.graph.nodes[input.edge.to].x  \n     && input.graph.nodes[input.edge.to].y )){ \n  return; \n}\n\n\nconst origin = {x: input.graph.nodes[input.edge.from].x, y: input.graph.nodes[input.edge.from].y};\nconst dest = {x: input.graph.nodes[input.edge.to].x, y: input.graph.nodes[input.edge.to].y };\nconst dir = {x: dest.x - origin.x, y: dest.y - origin.y};\n\nif(input.create_line && lib.R.equals(input.create_line[input.edge.from+'-'+input.edge.to], {origin, dest})){ return; }\n\nlet line = base.findOne(`#${input.edge.from}-${input.edge.to}`) ?? base.line().attr({id: `${input.edge.from}-${input.edge.to}`}).stroke({width: 1, color: '#A46DB5'});\n\nlet marker = line.reference('marker-start'); \n\nif(!marker) {\n  marker = line.marker('end', 10, 10, function(add) {\n    add.polygon('0,0 8,4 0,8').fill('#CA3AF7');\n  });\n}\n\nif(Math.abs(dir.x) + Math.abs(dir.y) > 0) {    \n  const sum = dir.x + dir.y;\n  const pow = Math.pow(dir.x, 2) + Math.pow(dir.y,2 );\n  const sqr = Math.pow(pow, 0.5);\n  dir.x = dir.x / sqr;\n  dir.y = dir.y / sqr;\n  origin.x += dir.x * 18;    origin.y += dir.y * 18;\n  dest.x -= dir.x * 20;    dest.y -= dir.y * 20;\n  \n  line.stroke({width: 2, color: '#604763'}).plot(origin.x, origin.y, dest.x, dest.y);\n}\n\n\nreturn lib.R.assoc(input.edge.to + '-' + input.edge.from, {origin, dest});",
      "x": 814.4525716228197,
      "y": -522.9881305266051
    },
    "show_errors": {
      "type": "script",
      "script": "for(e of Object.keys(input.graph.nodes)){ lib.SVG(`#${e}`)?.css({fill: state.temp.errors.has(e) ? 'red' : 'black'})}",
      "x": -587.3947425463981,
      "y": -214.69102996642334
    },
    "register_mouse_listener": {
      "script": "const mouse_queue = lib.queue();\nconst mouseEvent = (ty) => (e) => { \n  mouse_queue.push({\n    ty, \n touch_count: e.touches?.length ?? 0,   x: e.x ?? e.touches[0]?.clientX, \n    y: e.y?? e.touches[0]?.clientY, \n    target: e.target?.parentNode.id ?? e.touches[0]?.target?.parentNode.id, \n    button: e.button, \n    buttons: e.buttons\n  })\n}; \ndocument.getElementById('graph').onmousemove = mouseEvent('mousemove'); \ndocument.getElementById('graph').onmousedown = mouseEvent('mousedown'); \ndocument.getElementById('graph').onmouseup = mouseEvent('mouseup'); \ndocument.getElementById('graph').onwheel = mouseEvent('wheel'); \ndocument.getElementById('graph').addEventListener(\"touchstart\", mouseEvent('touchstart'), false);\ndocument.getElementById('graph').addEventListener(\"touchend\", mouseEvent('touchend'), false);\ndocument.getElementById('graph').addEventListener(\"touchcancel\", mouseEvent('touchcancel'), false);\ndocument.getElementById('graph').addEventListener(\"touchmove\", mouseEvent('touchmove'), false);\n\nreturn lib.queueIterator(mouse_queue); ",
      "x": 894.2783995142847,
      "y": -329.5465259253127
    },
    "mouse_stringify": {
      "type": "stringify",
      "x": -577.9488157507783,
      "y": 597.658674456877
    },
    "mouse_log": {
      "type": "log",
      "x": -571.6515312203652,
      "y": 57.66652597394682
    },
    "mouse_target_changed": {
      "type": "value_changed",
      "nodes": {
        "value": [
          "register_mouse_listener",
          "target"
        ]
      },
      "x": 847.6796634131492,
      "y": 294.59922365701345
    },
    "mouse_button_changed": {
      "type": "value_changed",
      "nodes": {
        "value": [
          "register_mouse_listener",
          "button"
        ]
      },
      "x": 818.4740288683445,
      "y": 128.51097694109512
    },
    "mouse_event_type_changed": {
      "type": "value_changed",
      "nodes": {
        "value": [
          "register_mouse_listener",
          "ty"
        ]
      },
      "x": 898.3333740234375,
      "y": 801.2083740234375
    },
    "mouse_wheel_events": {
      "script": "if(input.ty !== 'wheel'){ return; } return input;",
      "x": -579.5231368833815,
      "y": 1063.657681662984
    },
    "mouse_dragging": {
      "type": "script",
      "script": "return ((input.register_mouse_listener.ty === 'mousedown' || input.register_mouse_listener.ty === 'touchstart' || input.register_mouse_listener.ty === 'mouseup' || input.register_mouse_listener.ty === 'touchend') && (input.register_mouse_listener.button === 0 || input.register_mouse_listener.touch_count > 0) || (input.register_mouse_listener.ty === 'mouseleave')) ? (input.register_mouse_listener.ty === 'touchstart' || input.register_mouse_listener.ty === 'mousedown') && input.register_mouse_listener.ty !== 'mouseout' : undefined",
      "x": 672.062163536238,
      "y": 268.6255096983201
    },
    "mouse_select_target": {
      "script": "return (input.event.ty === 'mousedown' || input.event.ty === 'touchstart') ? input.event.target : undefined",
      "x": 829.8821455033221,
      "y": 241.4140698937171
    },
    "svg_pan_zoom_events": {
      "script": "if(input.previous !== undefined){ return; } const q = lib.queue(); lib.SVG('.root').on('panning', e => { q.push(e)}); return lib.queueIterator(q);",
      "x": 679.9337722020338,
      "y": 929.8404334361721
    },
    "prevent_pan_while_dragging": {
      "script": "lib.SVG('.root').panZoom(input.target === 'graph' ? {oneFingerPan: true} : false); return input;",
      "x": 606.9102670954001,
      "y": 960.4530296169991
    },
    "hover_state": {
      "script": "if(!input.mouse_target_changed) {return; } const tt = document.queryselector('.tooltip'); if(input.mouse_event_type_changed !== 'mousemove' || input.mouse_target_changed === 'graph'){ tt.style = `visibility: hidden`;return; } const content = (state.temp.errors.get(input.mouse_target_changed)?.message ?? state.temp.results.get(input.mouse_target_changed)); tt.innertext = typeof content === 'string' ? content : JSON.stringify(content, null, 2); tt.style = `left: ${lib.SVG(`#${input.mouse_target_changed}`)?.x() ?? '0'}px; top: ${lib.SVG(`#${input.mouse_target_changed}`)?.y() ?? '0'}px; visibility: ${content ? 'visible' : 'hidden'};`;",
      "x": -464.59764615887286,
      "y": 1159.6912707517852
    },
    "drag_node": {
      "script": "\nif(!(input.mouse_dragging && input.mouse_select_target && input.graph?.nodes[input.mouse_select_target] && (input.register_mouse_listener.ty === 'mousemove' || input.register_mouse_listener.ty === 'touchmove'))) { \n  return; \n}\n\nconst target = lib.SVG(`#${input.mouse_select_target}`);\n\nconst current = {\n  x: lib.R.path(['nodes', input.mouse_select_target, 'x'], input.graph) ?? 100,\n  y: lib.R.path(['nodes', input.mouse_select_target, 'y'], input.graph) ?? 100\n};\n\nconst next = lib.SVG('.root').point(\n  input.register_mouse_listener.x,\n  input.register_mouse_listener.y\n);\n\n\nif(target?.center && \n   Math.abs(current.x - next.x) > 1 ||  \n   Math.abs(current.y - next.y) > 1){ \n  target.center(next); \n  \n  return lib.R.over(\n    lib.R.lensPath(['nodes', input.mouse_select_target]), \n    lib.R.evolve({x: () => next.x, y: () => next.y}), \n    input.graph\n  );\n}",
      "x": 960.2427620889582,
      "y": 79.41637924134307
    },
    "parse_editor_state_graph": {
      "script": "const mouse_target = input.mouse_select_target; return !mouse_target || mouse_target === 'graph' ? JSON.parse(input.content) : undefined",
      "x": 1396.2498845337539,
      "y": 945.5836447622052
    },
    "parse_editor_node_script": {
      "script": "const mouse_target = input.mouse_select_target; return mouse_target && mouse_target !== 'graph' && input.graph.nodes[mouse_target]?.script ? lib.R.set(lib.R.lensPath(['nodes', mouse_target, 'script']), input.content, input.graph) : undefined",
      "x": 1514.323993501235,
      "y": 728.3273284629504
    },
    "editor_content_changes": {
      "type": "last_updated"
    },
    "last_editor_content_change": {
      "type": "filter_last_updated",
      "x": -581.0974580159849,
      "y": 983.3673519446843
    },
    "state_graph": {
      "type": "filter_last_updated",
      "x": 1443.4795185118526,
      "y": -912.115291709683
    },
    "register_key_listener": {
      "type": "keyboard_event",
      "script": "const isPrevented = (key_e) => node.prevent_default_keys && node.prevent_default_keys.reduce( (acc, key) => acc || Object.keys(key).reduce((acc, k) => acc && key_e[k] === key[k] , true) , false); const key_queue = lib.queue(); const keyboardEvent = (ty) => (e) => { const key_e = {event: ty, code: e.code, altKey: e.altKey, ctrlKey: e.ctrlKey, key: e.key, metaKey: e.metaKey}; if(isPrevented(key_e)) { e.preventDefault(); } key_queue.push(key_e); }; window.addEventListener('keyup', keyboardEvent('keyup')); window.addEventListener('keydown', keyboardEvent('keydown')); return {[Symbol.asyncIterator](){ return { queue: key_queue, next(){ return this.queue.pop().then(value => ({done: false, value})); } } }} ",
      "prevent_default_keys": [
        {
          "ctrlKey": true,
          "key": "s"
        },
        {
          "ctrlKey": true,
          "key": "e"
        }
      ],
      "x": -31.65938273743484,
      "y": 54.5178837087401
    },
    "save_on_ctrl_s": {
      "type": "save_content",
      "nodes": {
        "save_key": "graph"
      },
      "x": 61.225564086159466,
      "y": 948.7322389829436
    },
    "ctrl_s": {
      "script": "return input.ctrlKey && input.key === 's' && input.event === 'keydown'",
      "x": -69.52092420674526,
      "y": 578.2112118201599
    },
    "ctrl_e": {
      "script": "return input.ctrlKey && input.key === 'e' && input.event === 'keydown'",
      "x": 1186.991063933835,
      "y": 488.0316072990038
    },
    "get_save_content": {
      "type": "get_value",
      "nodes": {
        "value": [
          "content"
        ]
      }
    },
    "map_save_value": {
      "type": "trigger",
      "nodes": {
        "key": [
          "key"
        ],
        "trigger": [
          "trigger"
        ]
      },
      "x": 61.225564086159466,
      "y": 775.5569624410493
    },
    "get_edges_changes": {
      "type": "filter_input",
      "nodes": {
        "filter": "return val.path[0] === 'edges';"
      },
      "x": -565.3542466899519,
      "y": 887.3337148114151
    },
    "editor_content": {
      "x": 1226.223202212598,
      "y": 709.4354268272427,
      "script": "return typeof input.last_updated[0] === 'string' ? input[input.last_updated[0]] : lib.R.pick(input.last_updated[0], input)"
    },
    "update_editor_content": {
      "x": 1159.0594105598632,
      "y": 894.0743539673945,
      "edges": [],
      "script": "const newcontent = typeof input.editor_content === 'string' ? input.editor_content : JSON.stringify(input.editor_content, null, 2);\nif(state.editor.state.doc.toString() !== newcontent) { \n  state.editor.dispatch({changes: {from: 0, to: state.editor.state.doc.length, insert: newcontent }}) \n}"
    },
    "log_errors": {
      "script": "state.temp.errors.foreach((id, e) => {console.log(id); console.error(e);})",
      "x": -573.068467828783,
      "y": 536.3084963655695
    },
    "log_results": {
      "script": "console.log(state.temp.results.foreach((v, k) => console.log(`${k}: ${JSON.stringify(v, null, 2)}`)))",
      "x": -573.068467828783,
      "y": 437.05914793717534
    },
    "log_test": {
      "type": "log"
    },
    "configure_editor": {
      "script": " const editor_update_queue = lib.queue(); state.editor.dispatch({ effects: lib.cm.StateEffect.appendConfig.of([ lib.cm.EditorView.theme({'&': {width: '50vw', height: '95vh'}, '.cm-scroller': { overflow: 'auto' }}), lib.cm.EditorView.updateListener.of( update => { if(update.docChanged) { editor_update_queue.push(update.state.doc.toString()) } }), ]) }); return lib.queueIterator(editor_update_queue); ",
      "x": 1652.8642291480908,
      "y": 123.78791745434887
    },
    "drop_node": {
      "script": "if(!input.drop_node_input || input.drop_node_input.key !== 'mouse_dragging' || input.drop_node_input.mouse_dragging || !input.drop_node_input.mouse_select_target || !input.nodes.hasOwnProperty(input.drop_node_input.mouse_select_target)) { return; } const target = lib.SVG(`#${input.drop_node_input.mouse_select_target}`);",
      "x": 508.33277775661236,
      "y": 585.0641053960505
    },
    "drop_node_input": {
      "type": "last_updated",
      "x": 519.3530256848354,
      "y": 444.9495245943574
    },
    "selected_node_script": {
      "script": "const selected_content = input.graph?.nodes[input.mouse_select_target]?.script; if(selected_content && input.last_updated[0] === 'graph'){ return; } return input.graph?.nodes[input.mouse_select_target]?.script ? input.graph.nodes[input.mouse_select_target].script : input.graph",
      "x": 1029.433060637186,
      "y": 544.1317079038969
    },
    "update_selected_content": {
      "script": "return JSON.parse(input.selected_node_script)",
      "x": -578.5823205192493,
      "y": 321.26807316795225
    },
    "push_editor_content_change": {
      "type": "trigger",
      "nodes": {
        "key": [
          "key"
        ],
        "trigger": [
          "trigger"
        ]
      },
      "x": 1703.2425053913962,
      "y": 526.8141274007924
    },
    "edge_stream": {
      "script": "if(input.last_updated[0] === 'edge_stream'){\n  return;\n}\n\nreturn lib.queueIterator(lib.queue().push(input.graph?.edges, true));",
      "x": 782.7736772005348,
      "y": -649.160097418353
    },
    "node_stream": {
      "script": "return lib.queueIterator(lib.queue().push(\n  lib.R.compose(\n    lib.R.map(([k, v]) => lib.R.assoc('id', k, v)), \n    lib.R.toPairs\n  )(input.graph?.nodes), true));",
      "x": 574.502895159803,
      "y": -665.2023799275531
    },
    "out": {
      "script": "return {...input, _saveignore: { rerun: true} }",
      "x": 1901.6069921216456,
      "y": 1232.1100908960047
    },
    "selected_node_changed": {
      "script": "if(input.last_updated[0]!=='selected_node_changed' && input.selected_node !== input.selected_node_changed) return input.selected_node",
      "x": 104.13859963766942,
      "y": 221.5715868704272
    },
    "selected_node": {
      "script": "return lib.R.assoc('id', input.selected_node_id, input.graph.nodes[input.selected_node_id]);",
      "x": 349.0877404420609,
      "y": 91.00903787914996
    }
  },
  "defaults": {
    "log": {
      "script": "console.dir(input)"
    },
    "stringify": {
      "script": "return JSON.stringify(input[node.nodes.key])"
    },
    "tag": {
      "script": "return () => lib.html`<${node.nodes.tag} ...${node.nodes.attrs}>${new function(`return ${node.nodes.content}`)()}</${node.nodes.tag}>`"
    },
    "render_html": {
      "script": "target = new Function(`return ${node.nodes.target}`)(); lib.render(lib.html`${Object.values(input).map(fn => lib.html`<${fn} />`)}`, target)"
    },
    "filter_changed": {
      "script": "return state.temp.results.get(name) === input.value ? undefined : input.value"
    },
    "save_content": {
      "script": "console.log(`saving ${node.nodes.save_key}`); return localStorage.setItem(node.nodes.save_key, input.content)"
    },
    "load_content": {
      "script": "return localStorage.getItem(node.nodes.key)"
    },
    "diff_changes": {
      "script": "if(input.current === undefined || input.next === undefined){return;} const diff = lib.diff(input.current, input.next); return diff.length > 0 ? diff : undefined;"
    },
    "filter_input": {
      "script": "return Object.fromentries(Object.entries(input).filter(val => new function('state', 'name', 'input', 'val', node.nodes.filter)(state, name, input, val)))"
    },
    "get_value": {
      "script": "return lib.R.path(node.nodes.value, input)"
    },
    "value_changed": {
      "script": "if(input.last_updated[0] === node.id){ return; }  const value = lib.R.path(node.nodes.value, input); return input[node.id] === value ? undefined : value"
    },
    "last_updated": {
      "description": "returns the key of the input value that was last updated",
      "script": "return input"
    },
    "filter_last_updated": {
      "script": "return lib.R.pick(input.last_updated, input)"
    },
    "value": {
      "script": "return node.nodes.value"
    },
    "keyboard_event": {
      "script": "\n      const trigger = node.nodes.trigger;\n      const isprevented = (key_e) =>\n        node.nodes.prevent_default_keys && node.nodes.prevent_default_keys.reduce(\n          (acc, key) => acc || Object.keys(key).reduce((acc, k) => acc && key_e[k] === key[k] , true)\n            , false);\n\n      const keyboardevent = (ty) => (e) => {\n        const key_e = {event: ty, code: e.code, altkey: e.altkey, ctrlkey: e.ctrlkey, key: e.key, metakey: e.metakey};\n        if(isprevented(key_e)) {\n          e.preventdefault();\n        }\n\n        new asyncfunction('state', 'name', 'input', state.graph.defaults.run.nodes.script)(state, trigger, key_e);\n      }\n\n  window.addeventlistener('keydown', keyboardevent('keydown'));\n    "
    },
    "trigger": {
      "description": "watches for a true on the trigger input to pass the full input through",
      "script": "const key = ['last_updated', 0]; const trigger = ['trigger']; if(lib.R.path(key, input) === 'trigger' && lib.R.path(trigger, input)){ return input }"
    }
  },
  "edges": [
    {
      "from": "in",
      "to": "load_graph",
      "as": "graph"
    },
    {
      "from": "load_graph",
      "to": "load_graph_run"
    },
    {
      "from": "load_graph",
      "to": "load_graph_out"
    },
    {
      "from": "load_graph_out",
      "to": "out"
    },
    {
      "from": "load_graph_run",
      "to": "register_key_listener"
    },
    {
      "from": "load_graph_run",
      "to": "register_mouse_listener"
    },
    {
      "from": "load_graph_run",
      "to": "configure_editor"
    },
    {
      "from": "load_graph_run",
      "to": "state_graph"
    },
    {
      "from": "state_graph",
      "to": "node_stream",
      "as": "graph"
    },
    {
      "from": "state_graph",
      "to": "edge_stream",
      "as": "graph"
    },
    {
      "from": "state_graph",
      "to": "create_line",
      "as": "graph"
    },
    {
      "from": "edge_stream",
      "to": "create_line",
      "as": "edge"
    },
    {
      "from": "node_stream",
      "to": "create_node"
    },
    {
      "from": "create_node",
      "to": "create_node",
      "as": "create_node"
    },
    {
      "from": "state_graph",
      "to": "create_svg_base"
    },
    {
      "from": "state_graph",
      "to": "hover_node",
      "as": "graph"
    },
    {
      "from": "hover_node",
      "to": "hover_node",
      "as": "hover_node"
    },
    {
      "from": "mouse_target_changed",
      "to": "hover_node",
      "as": "target"
    },
    {
      "from": "create_svg_base",
      "to": "svg_pan_zoom_events",
      "as": "base"
    },
    {
      "from": "svg_pan_zoom_events",
      "to": "svg_pan_zoom_events",
      "as": "previous"
    },
    {
      "from": "hover_node",
      "to": "prevent_pan_while_dragging"
    },
    {
      "from": "mouse_select_target",
      "to": "prevent_pan_while_dragging",
      "as": "target"
    },
    {
      "from": "create_svg_base",
      "to": "hover_node",
      "as": "base"
    },
    {
      "from": "mouse_dragging",
      "to": "drag_node",
      "as": "mouse_dragging"
    },
    {
      "from": "mouse_select_target",
      "to": "drag_node",
      "as": "mouse_select_target"
    },
    {
      "from": "register_mouse_listener",
      "to": "drag_node",
      "as": "register_mouse_listener"
    },
    {
      "from": "state_graph",
      "to": "drag_node",
      "as": "graph"
    },
    {
      "from": "drag_node",
      "to": "state_graph"
    },
    {
      "from": "mouse_dragging",
      "to": "drop_node_input",
      "as": "mouse_dragging"
    },
    {
      "from": "mouse_select_target",
      "to": "drop_node_input",
      "as": "mouse_select_target"
    },
    {
      "from": "register_mouse_listener",
      "to": "drop_node_input",
      "as": "register_mouse_listener"
    },
    {
      "from": "state_graph",
      "to": "drop_node",
      "as": "graph"
    },
    {
      "from": "drop_node_input",
      "to": "drop_node",
      "as": "drop_node_input"
    },
    {
      "from": "configure_editor",
      "to": "editor_content_changes",
      "as": "content"
    },
    {
      "from": "register_key_listener",
      "to": "ctrl_s"
    },
    {
      "from": "register_key_listener",
      "to": "ctrl_e"
    },
    {
      "from": "editor_content_changes",
      "to": "last_editor_content_change"
    },
    {
      "from": "ctrl_s",
      "to": "map_save_value",
      "as": "trigger"
    },
    {
      "from": "state_graph",
      "to": "graph_stringify",
      "as": "state_graph"
    },
    {
      "from": "graph_stringify",
      "to": "map_save_value",
      "as": "content"
    },
    {
      "from": "map_save_value",
      "to": "save_on_ctrl_s"
    },
    {
      "from": "register_mouse_listener",
      "to": "mouse_button_changed",
      "as": "register_mouse_listener"
    },
    {
      "from": "mouse_button_changed",
      "to": "mouse_button_changed",
      "as": "mouse_button_changed"
    },
    {
      "from": "register_mouse_listener",
      "to": "mouse_event_type_changed",
      "as": "register_mouse_listener"
    },
    {
      "from": "register_mouse_listener",
      "to": "mouse_dragging",
      "as": "register_mouse_listener"
    },
    {
      "from": "mouse_event_type_changed",
      "to": "mouse_event_type_changed",
      "as": "mouse_event_type_changed"
    },
    {
      "from": "register_mouse_listener",
      "to": "mouse_select_target",
      "as": "event"
    },
    {
      "from": "mouse_target_changed",
      "to": "mouse_target_changed",
      "as": "mouse_target_changed"
    },
    {
      "from": "register_mouse_listener",
      "to": "mouse_target_changed",
      "as": "register_mouse_listener"
    },
    {
      "from": "ctrl_e",
      "to": "push_editor_content_change",
      "as": "trigger"
    },
    {
      "from": "configure_editor",
      "to": "push_editor_content_change",
      "as": "content"
    },
    {
      "from": "mouse_select_target",
      "to": "push_editor_content_change",
      "as": "mouse_select_target"
    },
    {
      "from": "push_editor_content_change",
      "to": "parse_editor_state_graph"
    },
    {
      "from": "state_graph",
      "to": "parse_editor_node_script",
      "as": "graph"
    },
    {
      "from": "push_editor_content_change",
      "to": "parse_editor_node_script"
    },
    {
      "from": "graph_style_tag",
      "to": "render_graph_style"
    },
    {
      "from": "state_graph",
      "to": "graph_style_tag"
    },
    {
      "from": "parse_editor_node_script",
      "to": "out"
    },
    {
      "from": "parse_editor_state_graph",
      "to": "out"
    },
    {
      "from": "editor_content",
      "to": "update_editor_content",
      "as": "editor_content"
    },
    {
      "from": "mouse_select_target",
      "to": "selected_node_script",
      "as": "mouse_select_target"
    },
    {
      "from": "state_graph",
      "to": "selected_node_script",
      "as": "graph"
    },
    {
      "from": "state_graph",
      "to": "selected_node",
      "as": "graph"
    },
    {
      "from": "selected_node_script",
      "to": "editor_content",
      "as": "content"
    },
    {
      "from": "mouse_select_target",
      "to": "selected_node_changed",
      "as": "selected_node"
    },
    {
      "from": "selected_node_changed",
      "to": "selected_node_changed",
      "as": "selected_node_changed"
    },
    {
      "from": "selected_node",
      "to": "create_node",
      "as": "selected_node"
    },
    {
      "from": "selected_node",
      "to": "node_stream",
      "as": "selected_node"
    },
    {
      "from": "selected_node_changed",
      "to": "selected_node",
      "as": "selected_node_id"
    },
    {
      "from": "mouse_dragging",
      "to": "create_node",
      "as": "dragging"
    }
  ],
  "_saveignore": {
    "rerun": true
  }
}