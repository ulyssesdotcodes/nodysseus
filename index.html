<!DOCTYPE html>
<html>
<head>
  <title>Copane</title>
  <!-- <link rel="stylesheet" href="https://cdn.skypack.dev/codemirror/lib/codemirror.css"> -->
  <style>
    #content {
      display: flex;
      flex-direction: row;
    }
  </style>
</head>
<body>
  <div id="content">
    <div id="render">
      <div class="tooltip"></div>
    </div>
    <div id="editor_wrapper">
      <div id="editor"></div>
    </div>
  </div>
  <script type='module'>
    import * as cmbasic from 'https://cdn.skypack.dev/@codemirror/basic-setup';
    import * as cmstate from 'https://cdn.skypack.dev/@codemirror/state';
    import {json} from "https://cdn.skypack.dev/@codemirror/lang-json";
    import {javascript} from "https://cdn.skypack.dev/@codemirror/lang-javascript";
    import { html, render } from 'https://unpkg.com/htm/preact/standalone.module.js'
    import { SVG } from "https://cdn.skypack.dev/@svgdotjs/svg.js";

    // helpers
    window.AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
    function isFunction(functionToCheck) {
      return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
    }

    class CopaneError extends Error {
      constructor(tag, message) {
        super(`${tag}: ${message}`);
      }
    }

    const rethrow = (tag) => (error) => {
      if (error instanceof CopaneError) {
        throw error;
      } else {
        throw new CopaneError(tag, error.message);
      }
    }

    /////
    // This is a plugin that takes a graph and runs it in js. The logic should be in the nodes, but the scaffolding here should work like all plugins - handle errors, etc.
    /////

    // TODO: Names are unique, just use them for ids?

    const runScript = `
      const node = state.graph.nodes[name];
      const stack = state.graph.edges.filter(c => c[0] === name).map(c => c[1]); 

      while(stack.length > 0) { 
        const run = stack.pop(); 
        const run_node = state.graph.nodes[run];
        const inputs = state.graph.edges.filter(c => c[1] === run).map(c => state.temp.results.get(c[0])); 
        await Promise.resolve(run_node)
          .then(node => new AsyncFunction('state', 'name', 'inputs', state.graph.types[node.type].script)(state, run, inputs))
          .then(result => {
            if(result) {  
              state.temp.results.set(run, result); 
              state.temp.errors.delete(run);
              state.graph.edges.filter(c => c[0] === run).forEach(c => stack.unshift(c[1])); 
            }
          })
          .catch(err => state.temp.errors.set(run, err));
      }
    `;

    const mouseEventScript = `
      const mouseEvent = (ty) => (e) => {
        state.temp.results.set(name, {x: e.x, y: e.y, target: document.elementFromPoint(e.x, e.y).parentElement.id, buttons: e.buttons, button: e.button, ty });
        new AsyncFunction('state', 'name', 'inputs', state.graph.types.run.script)(state, name, inputs);
      };

      document.getElementById('render').onmousemove = mouseEvent('mousemove');
      document.getElementById('render').onmousedown = mouseEvent('mousedown');
      document.getElementById('render').onmouseup = mouseEvent('mouseup');
    `;

    const keyboardEventScript = `
      const keyboardEvent = (ty) => (e) => {
        state.temp.results.set(name, {event: ty, code: e.code, altKey: e.altKey, ctrlKey: e.ctrlKey, key: e.key, metaKey: e.metaKey})
        new AsyncFunction('state', 'name', 'inputs', state.graph.types.run.script)(state, name, inputs);
      }

      document.getElementById('render').addEventListener('keyup', keyboardEvent('keyup'));
    `

    const editorChangeScript = `
      state.editor.dispatch({ 
        effects: state.lib.cm.StateEffect.appendConfig.of(
          state.lib.cm.EditorView.updateListener.of(
            update => {
              if(update.docChanged) {
                state.temp.results.set(name, update.state.doc.toString());
                state.temp.errors.delete(name);
                new AsyncFunction('state', 'name', 'inputs', state.graph.types.run.script)(state, name, inputs)
              }
            }))
      }); 
    `

    // Plugins should have a default graph
    const DEFAULT_GRAPH = {
      "type": "editor",
      // List of all nodes
      "nodes": {
        "graph_change_listen" : {
          "type" : "event",
          "event_type": "graph_change"
        },
        "compile" : {
          "type": "execjs",
          "fn": "return JSON.parse(input);"
        },
        "log" : {
          "type": "execjs",
          "nodes": {
            "script": "console.log(JSON.stringify(inputs))"
          }
        },
        "save_graph" : {
          "type": "execjs",
          "nodes": {
            "script": "localStorage.setItem('data', JSON.stringify(state.graph, null, 2));"
          }
        },
        "mouse_listener":{
          "type": "mouse_event"
        },
        "mouse_stringify": {
          "type": "stringify"
        },
        "mouse_log": {
          "type": "log",
        },
        "extra_log": {
          "type": "log",
        },
        "load": {
          "type": "run",
        },
        "editor_style": {
          "type": "tag",
          "nodes": {
            "attrs": [],
            "content": "`#editor_wrapper { display: flex; flex-grow: 1; height: 100vh; } .cm-scroller { max-height: 100vh; width: 50vw; }`",
            "tag": "style"
          }
        },
        "render_style": {
          "type": "tag",
          "nodes": {
            "attrs": [],
            "content": "`#render { display:flex; flex-grow: 2; justify-content: flex-start; } #render .node { user-select: none } .tooltip { position: absolute; visibility: hidden; max-width: 120px; pointer-events: none; } `",
            "tag": "style"
          }
        },
        "render_head": {
          "type": "render",
          "nodes": {
            "target": "document.head.querySelector('style')"
          }
        },
        "log_test": {
          "type": "log",
          "nodes": {
            "value": "test"
          }
        },
        "render_graph": {
          "type": "render",
          "nodes": {
            "target": "document.querySelector('#render')"
          }
        },
        "create_svg_base": {
          "type": "script",
          "nodes": {
            "script": "return state.lib.SVG().addTo('#render')"
          }
        },
        "create_nodes": {
          "type": "script",
          "nodes": {
            "script": "const base = inputs[0]; return Object.entries(state.graph.nodes).map(([id, n], idx) => base.text(id).build(true).attr({id, class: 'node'}).move(20, 40 * idx));"
          }
        },
        "create_lines": {
          "type": "script",
          "nodes": {
            "script": "const base = inputs[0]; const nodes = inputs[1]; return state.graph.edges.map(c => base.line(state.lib.SVG(`#${c[0]}`)?.cx(), state.lib.SVG(`#${c[0]}`)?.cy(), state.lib.SVG(`#${c[1]}`)?.cx(), state.lib.SVG(`#${c[1]}`)?.cy()).stroke({width: 3, color: '#000'}))"
          }
        },
        "down_trigger": {
          "type": "script",
          "nodes": {
            "script": "if(inputs[0].ty === 'mousedown'){ state.temp.dragging = inputs[0].target; state.temp.selected = inputs[0].target; return inputs[0].target; }"
          }
        },
        "show_in_editor": {
          "type": "script",
          "nodes": {
            "script": "state.editor.dispatch({changes: {from: 0, to: state.editor.state.doc.length, insert: JSON.stringify(state.graph.nodes[inputs[0]] ?? state.graph, null, 2) }})"
          }
        },
        "up_trigger": {
          "type": "script",
          "nodes": {
            "script": "if(inputs[0].ty === 'mouseup'){ state.temp.dragging = undefined}"
          }
        },
        "drag_node": {
          "type": "script",
          "nodes": {
            "script": "if(!state.temp.dragging) return; const target = state.lib.SVG(`#${state.temp.dragging}`); if(target?.center){ target.center(inputs[0].x, inputs[0].y); }"
          }
        },
        "editor_change_listener": {
          "type": "editor_change_event",
        },
        "parse_graph": {
          "type": "script",
          "nodes": {
            "script": "return state.temp.selected === 'render' ? JSON.parse(inputs[0]) : undefined"
          }
        },
        "show_errors": {
          "type": "script",
          "nodes": {
            "script": "for(e of Object.keys(state.graph.nodes)){ state.lib.SVG(`#${e}`)?.css({fill: state.temp.errors.has(e) ? 'red' : 'black'})}"
          }
        },
        "log_errors": {
          "type": "script",
          "nodes": {
            "script": "state.temp.errors.forEach(([id, e]) => {console.log(id); console.error(e);})"
          }
        },
        "mouse_target": {
          "type": "script",
          "nodes": {
            "script": "return inputs[0].target"
          }
        },
        "mouse_target_changed": {
          "type": "filter_changed"
        },
        "hover_state": {
          "type": "script",
          "nodes": {
            "script": "const tt = document.querySelector('.tooltip'); const content = (state.temp.errors.get(inputs[0])?.message ?? state.temp.results.get(inputs[0])); tt.innerText = typeof content === 'string' ? content : JSON.stringify(content, null, 2); tt.style = `left: ${state.lib.SVG(`#${inputs[0]}`)?.x() ?? '0'}px; top: ${state.lib.SVG(`#${inputs[0]}`)?.y() ?? '0'}px; visibility: ${content ? 'visible' : 'hidden'};`;"
          }
        },
        "save_on_ctrl_s": {
          "type": "save_content",
          "nodes"
        }
      },
      "types": {
        "run": {
          "script": runScript
        },
        "log": {
          "script": "console.log(JSON.stringify(inputs))"
        },
        "script": {
          "script": "return new AsyncFunction('state', 'name', 'inputs', state.graph.nodes[name].nodes['script'])(state, name, inputs)"
        },
        "stringify": {
          "script": "return JSON.stringify(inputs)"
        },
        "mouse_event": {
          "script": mouseEventScript
        },
        "tag": {
          "script": "return () => state.lib.html`<${state.graph.nodes[name].nodes.tag} ...${state.graph.nodes[name].nodes.attrs}>${new Function(`return ${state.graph.nodes[name].nodes.content}`)()}</${state.graph.nodes[name].nodes.tag}>`"
        },
        "render": {
          "script": "target = new Function(`return ${state.graph.nodes[name].nodes.target}`)(); state.lib.render(state.lib.html`${target.innerHTML} ${inputs.map(fn => state.lib.html`<${fn} />`)}`, target)"
        },
        "filter_changed": {
          "script": "return state.temp.results.get(name) === inputs[0] ? undefined : inputs[0]"
        },
        "editor_change_event": {
          "script": editorChangeScript
        },
        "save_content": {
          "script": "localStorage.setItem(inputs[0].key, inputs[1].value);"
        },
        "keyboard_event": {
          "script": keyboardEventScript
        }
      },
      // Connections between the nodes - directional
      "edges": [
        ["load", "log_test"], 
        ["load", "mouse_listener"], 
        ["load", "editor_style"], 
        ["load", "render_style"], 
        ["load", "create_svg_base"],
        ["load", "editor_change_listener"],
        ["create_svg_base", "create_nodes"],
        ["create_svg_base", "create_lines"],
        ["create_svg_base", "show_errors"],
        ["editor_change_listener", "parse_graph"],
        ["mouse_listener", "mouse_stringify"], 
        ["mouse_listener", "mouse_target"], 
        ["mouse_target", "mouse_target_changed"],
        ["mouse_listener", "show_errors"], 
        ["mouse_target_changed", "hover_state"], 
        ["editor_style", "render_head"], 
        ["render_style", "render_head"], 
        ["parse_graph", "show_errors"],
        ["create_nodes", "create_lines"],
        ["mouse_listener", "drag_node"],
        ["mouse_listener", "down_trigger"],
        ["down_trigger", "show_in_editor"],
        ["mouse_listener", "up_trigger"],
        ["mouse_listener", "drag_node"],
      ]
    }

    const graph = DEFAULT_GRAPH;


    // HTML setup

    const cm = {...cmbasic, ...cmstate, lang: {javascript, json}}

    const lib = { cm, html, render, SVG }

    const editorEl = document.getElementById("editor");
    const renderEl = document.getElementById("render");

    const editorState  = cm.EditorState.create({
      doc: JSON.stringify(graph, null, 2),
      extensions: [cm.basicSetup, 
        json()
      ]
    });

    const editorView = new cm.EditorView({ 
      state: editorState, 
      parent: editorEl
    });

    // Actual plugin

    // state is passed between nodes
    const state = {
      lib,
      el: {editor: editorEl, render: renderEl },
      editor: editorView,
      graph,
      temp: { results: new Map(), errors: new Map() }
    }

    Object.entries(state.graph.nodes).filter(([id, node]) => id === "load").forEach(([id, n]) => new AsyncFunction('state', 'name', 'inputs', state.graph.types[n.type].script)(state, 'load', []))

    // const createConnection = (graph, log) => (source, dest) => {
    //   const node = {...graph.nodes[dest], id: dest};
    //   const fn = 
    //     node.type === 'execjs'
    //     ? new AsyncFunction('node', 'graph', 'render', 'input', 'lib', node.fn)
    //     : node.type === 'run'
    //     ? async (node, graph, render, input, lib) => { runGraph(input); return input; }
    //     : () => { throw new Error("Unknown node type") }

    //   return [source, { fn: (input) => fn(node, graph, renderNode, input, lib), name: dest }];
    // }

    // // edgesMap :: {id : [{fn: fn<input>, name}]}
    // const createEventChain = (graph, edgesMap, log) => (source, eventChain) => {
    //   const destfns = edgesMap[source] || [];
    //   return (input) => input ? Promise.all(
    //     destfns.map(fnnode => 
    //       fnnode.fn(input)
    //         .catch(rethrow(fnnode.name))
    //         .then(log('output' + fnnode.name))
    //         .then(eventChain(fnnode.name, eventChain))
    //     ) 
    //   ) : Promise.reject("Undefined");
    // };

    // const runGraph = (graph) => {
    //   const logReplacer = (key, val) => isFunction(val) ? "fn" : val;
    //   const log = graph.flags.includes('log') 
    //     ? (tag='log') => (input) => (console.log(`${tag}: ${JSON.stringify(input, logReplacer, 2)}`), input) 
    //     : graph.flags.includes('log_result')
    //     ? tag => input => tag === "result" ? (console.log(`${tag}: ${JSON.stringify(input, logReplacer, 2)}`), input) : input
    //     : tag => input => input;

    //   log(JSON.stringify(graph, null, 2))

    //   const createGraphConnection = createConnection(graph, log);
    //   // Create a edges map of source by id to destination node function
    //   const edgesMap = graph.connections
    //     // create the edges functions
    //     .map(edges => createGraphConnection(...connection))
    //     .map(log('map edges'))
    //     // group the edges by source node
    //     .reduce((acc, [source, fn]) => (acc[source] = (acc[source] || []).concat([fn]), {}, acc), {});

    //   log('final edges map')(connectionMap);

    //   const eventChain = createEventChain(graph, edgesMap, log);

    //   // Set up the base events
    //   const setupFunctions = graph.events.map(event => {
    //     const eventTypeNodes = Object.entries(graph.nodes)
    //       .filter(([id, node]) => node.event_type === event.name);

    //     log('e type nodes')(eventTypeNodes);

    //     const callback = async (input) => Promise.all(eventTypeNodes.map(([id, node]) => eventChain(id, eventChain)).map(fn => fn(input))).then(log('result')).catch(err => console.log(err instanceof CopaneError ? err.message : `unknown error: ${err.message}`));
    //     return () => new Function('lib', 'editor', 'render', 'callback', event.setup)(lib, editorView, renderNode, callback);
    //   });

    //   // Do this afterwards so if run fails it won't reconfigure editor
    //   editorView.dispatch({effects: cm.StateEffect.reconfigure.of([cm.basicSetup, 
    //     json()
    //   ])});

    //   setupFunctions.forEach(fn => fn());
    // }

    // runGraph(graph);

    /*
    // Attempts to update, returns a message if it doesn't
    const parseJson = (pending) => {
      try {
        return {
          text: pending,
          data: JSON.parse(pending.replace(/[\n\r]+/gm, ""))
        }
      } catch(err) {
        return { status: {
          state: "error", 
          phase: "parse", 
          message: err.message 
        }};
      }
    }

    const debounce = (fn, timeout) => {
      let timer;
      return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => fn.apply(this, args), timeout)
      }
    }

    const state = {
      text: localStorage.getItem('state') ? localStorage.getItem('state') : JSON.stringify({
        type: "evaljs",
        run: "console.log(state.status);"
      })
    };


    const editorState  = cm.EditorState.create({
      doc: state.text,
      extensions: [cm.basicSetup, 
        json(),
        cm.EditorView.updateListener.of(update => {
            if (update.docChanged) {
              editorUpdate(update.state.doc.toString());
            }
          })
      ]
    });


    // Parse the new run function and update state
    const updateState = (json) => {
      // Updates, adding "status: 'ok'" if it parses
      const update = parseJson(json);

      if(update.data?.run) {
        try {
          // Pass in both json and data so it can store it
          runState(state, update);

          // If it runs, add everything to state
          state.text = update.text;
          state.data = update.data;
          state.status = {status: "ok"};
          
          // And save to local storage
          localStorage.setItem('state', state.text)
        } catch(err) {
          // If it doesn't run, only add the error message to the state, and rerun the old function (without storing the resulting state)
          state.status = {status: "error", phase: "run", message: err.message, position: err.position };
          runState(state);
        }
      } else {
        // If it doesn't parse, just add the status and run the old version
        state.status = update.status;
        runState(state);
      }
    }

    const editorUpdate = debounce(updateState, 100);

    const editor = {
      state: editorState,
      render: renderNode,
      updateState,
    };

    const runState = (state, update) => new Function('state', 'next', 'editor', 'lib', update?.data.run || state.data?.run)(state, update, editor, lib);

    const view = new cm.EditorView({ 
      state: editorState, 
      parent: editorEl
    });

    updateState(state.text);
    */

  </script>
</body>
</html>