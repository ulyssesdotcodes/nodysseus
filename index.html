<!DOCTYPE html>
<html>
<head>
  <title>Copane</title>
  <!-- <link rel="stylesheet" href="https://cdn.skypack.dev/codemirror/lib/codemirror.css"> -->
</head>
<body>
  <div id="editor"></div>
  <div id="render"></div>
  <script type='module'>
    import * as cm from 'https://cdn.skypack.dev/@codemirror/basic-setup';
    import * as cmstate from 'https://cdn.skypack.dev/@codemirror/state';
    import {json} from "https://cdn.skypack.dev/@codemirror/lang-json";
    import {javascript} from "https://cdn.skypack.dev/@codemirror/lang-javascript";
    import { html, render } from 'https://unpkg.com/htm/preact/standalone.module.js'

    const cmlang = {};
    cmlang.json = json;
    cmlang.javascript = javascript;

    const lib = { cm, cmlang, cmstate, html }

    const editorEl = document.getElementById("editor");
    const renderEl = document.getElementById("render");

    const renderNode = (fn) => render(fn, renderEl);

    // Attempts to update, returns a message if it doesn't
    const parseJson = (pending) => {
      try {
        return {
          text: pending,
          data: JSON.parse(pending.replace(/[\n\r]+/gm, ""))
        }
      } catch(err) {
        return { status: {
          state: "error", 
          phase: "parse", 
          message: err.message 
        }};
      }
    }

    const debounce = (fn, timeout) => {
      let timer;
      return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => fn.apply(this, args), timeout)
      }
    }

    const state = {
      text: localStorage.getItem('state') ? localStorage.getItem('state') : JSON.stringify({
        type: "evaljs",
        run: "console.log(state.status);"
      })
    };


    const editorState  = cm.EditorState.create({
      doc: state.text,
      extensions: [cm.basicSetup, 
        json(),
        cm.EditorView.updateListener.of(update => {
            if (update.docChanged) {
              editorUpdate(update.state.doc.toString());
            }
          })
      ]
    });


    // Parse the new run function and update state
    const updateState = (json) => {
      // Updates, adding "status: 'ok'" if it parses
      const update = parseJson(json);

      if(update.data?.run) {
        try {
          // Pass in both json and data so it can store it
          runState(state, update);

          // If it runs, add everything to state
          state.text = update.text;
          state.data = update.data;
          state.status = {status: "ok"};
          
          // And save to local storage
          localStorage.setItem('state', state.text)
        } catch(err) {
          // If it doesn't run, only add the error message to the state, and rerun the old function (without storing the resulting state)
          state.status = {status: "error", phase: "run", message: err.message, position: err.position };
          runState(state);
        }
      } else {
        // If it doesn't parse, just add the status and run the old version
        state.status = update.status;
        runState(state);
      }
    }

    const editorUpdate = debounce(updateState, 100);

    const editor = {
      state: editorState,
      render: renderNode,
      updateState,
    };

    const runState = (state, update) => new Function('state', 'next', 'editor', 'lib', update?.data.run || state.data?.run)(state, update, editor, lib);

    const view = new cm.EditorView({ 
      state: editorState, 
      parent: editorEl
    });

    updateState(state.text);

  </script>
</body>
</html>